<!DOCTYPE html> 
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
<title>üê≠ Cat vs Mouse ‚Äî Survival (Walls ¬∑ Turrets ¬∑ Bombs)</title>
<style>
  :root{
    --bg:#0b1014; --ink:#e6efff; --muted:#9fb3c8; --panel:#0f172a; --line:#1f2a44;
    --good:#22c55e; --warn:#eab308; --bad:#ef4444; --accent:#60a5fa;
    --grass:#2f7d32; --edge:#58606b; --cell:28px; --view:17;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Arial,sans-serif}
  #hud{position:fixed;top:0;left:0;right:0;display:flex;gap:8px;align-items:center;justify-content:space-between;
       padding:8px 12px;background:linear-gradient(180deg,rgba(10,16,26,.85),rgba(10,16,26,.35));backdrop-filter:blur(6px);z-index:10}
  .chip{display:inline-flex;gap:8px;align-items:center;background:#0e1726;border:1px solid #1f2a44;border-radius:999px;padding:6px 10px}
  .pill{padding:2px 8px;border-radius:999px;border:1px solid #2a3a60;background:#121c30;color:#9fb3d0}
  a.btn{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:10px;border:1px solid #2a3a60;background:#0f1a2e;color:#cfe6ff;text-decoration:none}

  #main{padding-top:56px;display:flex;flex-direction:column;align-items:center;gap:10px}
  #stage{width:calc(var(--cell)*var(--view));height:calc(var(--cell)*var(--view));
         border:2px solid var(--line);border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.35);
         position:relative;overflow:hidden;background:repeating-linear-gradient(90deg,#2e6d31 0,#2e6d31 10px,#2a6a2d 10px,#2a6a2d 20px)}
  #grid{display:grid;grid-template-columns:repeat(var(--view),var(--cell));grid-template-rows:repeat(var(--view),var(--cell));}
  .cell{width:var(--cell);height:var(--cell);position:relative;display:flex;align-items:center;justify-content:center;user-select:none}
  .edge{background:#6d747f}
  .grass{background:linear-gradient(135deg,#2f7d32,#275e28)}
  .emj{position:relative; z-index:2; font-size:20px; line-height:1}
  .hpbar{position:absolute; left:2px; right:2px; top:2px; height:5px; background:#263040; border-radius:4px; overflow:hidden; z-index:3; pointer-events:none}
  .hpbar>i{display:block;height:100%;background:#ff5252}
  .float{position:absolute;pointer-events:none;font-weight:700;animation:rise .8s ease-out forwards; z-index:4}
  @keyframes rise{0%{opacity:1;transform:translateY(0)}100%{opacity:0;transform:translateY(-16px)}}

  .blast{position:absolute;width:10px;height:10px;border-radius:50%;
    background:radial-gradient(circle, rgba(255,240,180,1) 0%, rgba(255,120,40,0.9) 40%, rgba(255,60,0,0.6) 60%, rgba(0,0,0,0) 70%);
    transform:translate(-50%,-50%) scale(1); opacity:0.95; z-index:6; animation:boom .28s ease-out forwards;}
  @keyframes boom{0%{transform:translate(-50%,-50%) scale(.6);opacity:.95}100%{transform:translate(-50%,-50%) scale(2.2);opacity:0}}
  .shock{position:absolute;width:12px;height:12px;border-radius:50%;border:2px solid rgba(255,220,160,.95);
    transform:translate(-50%,-50%) scale(.5);box-shadow:0 0 12px rgba(255,200,120,.8);opacity:1;z-index:6;animation:ring .36s ease-out forwards;}
  @keyframes ring{0%{transform:translate(-50%,-50%) scale(.5);opacity:1}100%{transform:translate(-50%,-50%) scale(3);opacity:0}}
  .freezeOverlay{position:absolute;inset:0; background:rgba(150,220,255,.25); z-index:1; animation:tileBlink .25s ease-out forwards;}
  @keyframes tileBlink{0%{opacity:.35}100%{opacity:0}}

  #pads{width:100%;max-width:860px;display:flex;justify-content:space-between;gap:12px;padding:8px 12px 70px}
  .joyWrap{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center}
  .joy{width:140px;height:140px;border-radius:50%;background:radial-gradient(120px at 50% 50%, #0e1726, #0c1422);
       border:1px solid #223154; position:relative; touch-action:none; box-shadow:0 8px 24px rgba(0,0,0,.35);}
  .joy .knob{position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:78px; height:78px; border-radius:50%;
       background:#13233e; border:1px solid #2a3a60; box-shadow:inset 0 0 0 2px #0b1628;}
  .joy .hint{position:absolute; left:50%; top:50%; width:4px; height:4px; border-radius:50%; background:#3b5ea8; opacity:.7}
  .joyLabel{margin-top:6px; color:#a8c3ff; font-size:13px; text-align:center}
  #toast{position:fixed;bottom:72px;left:50%;transform:translateX(-50%);background:#0e1726;border:1px solid #1f2a44;
         padding:10px 14px;border-radius:10px;box-shadow:0 10px 24px rgba(0,0,0,.35);display:none;z-index:15}

  #powerBar{position:fixed;left:0;right:0;bottom:0;display:flex;gap:8px;align-items:center;justify-content:center;
    padding:8px 10px;background:linear-gradient(0deg,rgba(10,16,26,.9),rgba(10,16,26,.3)); backdrop-filter:blur(6px); z-index:12;}
  #powerBar .opt{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border:1px solid #2a3a60;border-radius:12px;background:#0f1a2e;cursor:pointer}
  #powerBar .opt:hover{background:#13233e}
</style>
</head>
<body>

<!-- HUD -->
<div id="hud">
  <a class="btn" id="fsBtn">‚õ∂ Full Screen</a>
  <div class="chip">
    <span id="hostBadge" class="pill">Host?</span>
    <span>üë• <b id="aliveCount">0</b></span>
    <span>‚≠ê <b id="score">0</b></span>
  </div>
  <div id="held" class="chip">
    <span>Held:</span><span id="heldIcon" style="min-width:28px;text-align:center">‚Äî</span>
    <span id="heldCount" class="pill">0</span>
  </div>
</div>

<div id="main">
  <div id="stage"><div id="grid"></div></div>
  <div id="pads">
    <div class="joyWrap">
      <div id="moveJoy" class="joy">
        <div class="hint" style="transform:translate(-50%,-50%) translate(0,-48px)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(48px,0)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(0,48px)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(-48px,0)"></div>
        <div class="knob"></div>
      </div>
      <div class="joyLabel">Move</div>
    </div>
    <div class="joyWrap">
      <div id="buildJoy" class="joy">
        <div class="hint" style="transform:translate(-50%,-50%) translate(0,-48px)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(48px,0)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(0,48px)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(-48px,0)"></div>
        <div class="knob"></div>
      </div>
      <div class="joyLabel">Build (uses held)</div>
    </div>
  </div>
</div>

<div id="powerBar" style="display:none"></div>
<div id="toast"></div>

<script type="module">
/* ----------------------------- Firebase setup ----------------------------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection,
  addDoc, deleteDoc, serverTimestamp, getDocs, query, where
} from "https://www.gstatic.com/firebasejs/10.11.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
};
const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);

/* ------------------------------- Parameters ------------------------------- */
const url = new URLSearchParams(location.search);
const gameId = url.get("gameId") || "sandbox";
const myName = (url.get("username")||"Player").trim().toLowerCase();

/* --------------------------------- State --------------------------------- */
const gridSize = 40;
const view = 17;
const gridEl = document.getElementById("grid");
const stageEl = document.getElementById("stage");
const cellPx = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'))||28;
let camera = {x:0,y:0};

let I_AM_HOST = false;
let gameDoc = {};
let players = {};
let structures = new Map(); // "x_y" -> {x,y,t,hp,max, expAt?}
let rats = new Map();
let bears = new Map();
let caterpillars = new Map();
let crows = new Map();
let corpses = new Map();
/* NEW: pets and specials */
let fleas = new Map();    // id -> {x,y,owner,createdMs}
let beetles = new Map();  // id -> {x,y,owner,hp,max,atk,lvl}

/* me */
let me = {x:2,y:2,alive:true,score:0,powers:{}};

/* held item */
let heldType = null;   // "üß±","üî´","üí£"
let heldCount = 0;

/* upgrades */
let levels = { wall:0, turret:0, range:0, speed:0 };

/* input */
let baseMoveDelay=120, buildDelay=120;
let lastMoveAt=0, lastBuildAt=0;
let moveIntent={dx:0,dy:0}, buildIntent={dx:0,dy:0};

/* ------------------------------- Helpers --------------------------------- */
const $ = sel => document.querySelector(sel);
function key(x,y){ return `${x}_${y}`; }
function clamp(v,min,max){ return v<min?min:v>max?max:v; }
function inBounds(x,y){ return x>0 && y>0 && x<gridSize-1 && y<gridSize-1; }
function toast(msg,ms=1200){ const el=$("#toast"); el.textContent=msg; el.style.display='block'; setTimeout(()=>el.style.display='none',ms); }
function setHostBadge(){ $("#hostBadge").textContent = I_AM_HOST? "üëë Host" : "Client"; }
function setHeldUI(){ $("#heldIcon").textContent = heldType || "‚Äî"; $("#heldCount").textContent = heldCount || 0; }
function focusCamera(){ camera.x = clamp(me.x - Math.floor(view/2), 0, gridSize - view);
                        camera.y = clamp(me.y - Math.floor(view/2), 0, gridSize - view); }
function floatText(x,y,txt,color="#fff"){
  const el = document.createElement('div');
  el.className='float';
  el.style.left = (x - camera.x)*cellPx + 'px';
  el.style.top  = (y - camera.y)*cellPx + 'px';
  el.style.color = color;
  el.textContent = txt;
  stageEl.appendChild(el);
  setTimeout(()=>el.remove(),900);
}
function minutesSinceStart(){ return Math.floor((Date.now() - (gameDoc.startMs||Date.now()))/60000); }

/* ------------------------------- Blocking -------------------------------- */
const BLOCKERS = ["üß±","üî´","üí£"]; // structures block movement

function isBlocked(x,y){
  if (x<=0||y<=0||x>=gridSize-1||y>=gridSize-1) return true;
  const s=structures.get(key(x,y));
  return !!(s && BLOCKERS.includes(s.t));
}
function tileOccupied(x,y){ return !!structures.get(key(x,y)); }

/* ------------------------------- Rendering ------------------------------- */
function addHPBar(el, cur, max){
  const bar = document.createElement("div"); bar.className="hpbar";
  const fill=document.createElement("i"); const pct = Math.max(0,Math.min(1,(cur||0)/(max||1)));
  fill.style.width=(pct*100)+"%"; bar.appendChild(fill); el.appendChild(bar);
}
function putEmoji(el, ch){
  const span=document.createElement('span'); span.className='emj'; span.textContent=ch; el.appendChild(span);
}
function renderExplosion(x,y){
  const cx = (x - camera.x)*cellPx + cellPx/2;
  const cy = (y - camera.y)*cellPx + cellPx/2;
  const blast = document.createElement('div'); blast.className='blast'; blast.style.left=cx+'px'; blast.style.top=cy+'px';
  const ring  = document.createElement('div'); ring.className='shock'; ring.style.left=cx+'px';  ring.style.top=cy+'px';
  stageEl.appendChild(blast); stageEl.appendChild(ring);
  setTimeout(()=>blast.remove(), 340); setTimeout(()=>ring.remove(), 380);
}
function renderFreezeArea(cx,cy,r=2){
  for (let dx=-r; dx<=r; dx++) for (let dy=-r; dy<=r; dy++){
    const nx=cx+dx, ny=cy+dy; if (!inBounds(nx,ny)) continue;
    if (Math.max(Math.abs(dx),Math.abs(dy))>r) continue;
    const idx = (ny - camera.y)*view + (nx - camera.x);
    if (idx<0 || idx>=gridEl.children.length) continue;
    const tile = gridEl.children[idx];
    const ov = document.createElement('div'); ov.className='freezeOverlay';
    tile.appendChild(ov); setTimeout(()=>ov.remove(), 250);
  }
}
function render(){
  focusCamera();
  gridEl.innerHTML="";
  for(let ry=0; ry<view; ry++){
    for(let rx=0; rx<view; rx++){
      const gx=camera.x+rx, gy=camera.y+ry;
      const el=document.createElement("div"); el.className="cell";
      if (gx===0||gy===0||gx===gridSize-1||gy===gridSize-1) el.classList.add("edge"); else el.classList.add("grass");

      // Structures
      const s=structures.get(key(gx,gy));
      if (s){
        putEmoji(el, s.t);
        if (BLOCKERS.includes(s.t)) addHPBar(el, s.hp||0, s.max||1);
        if (s.t==="üéÅ" || (s.t?.startsWith?.("‚≠ï")) || (s.t?.startsWith?.("üî∫"))) {
          el.style.outline="2px solid #eab308"; el.style.borderRadius="6px";
        }
      }

      // Enemies (emoji + HP)
      const ratHere=[...rats].find(([,r])=>r.x===gx&&r.y===gy);
      if (ratHere){ putEmoji(el,"üêÄ"); addHPBar(el, ratHere[1].hp||1, ratHere[1].max||ratHere[1].hp||1); }
      const bearHere=[...bears].find(([,b])=>b.x===gx&&b.y===gy);
      if (bearHere){ putEmoji(el,"üêª"); addHPBar(el, bearHere[1].hp||1, bearHere[1].max||bearHere[1].hp||1); }
      const catp=[...caterpillars].find(([,c])=>c.x===gx&&c.y===gy);
      if (catp){ putEmoji(el,"üêõ"); addHPBar(el, catp[1].hp||1, catp[1].max||catp[1].hp||1); }
      const crow=[...crows].find(([,c])=>c.x===gx&&c.y===gy);
      if (crow){ putEmoji(el,"üê¶"); addHPBar(el, crow[1].hp||1, crow[1].max||crow[1].hp||1); }

      if (corpses.has(key(gx,gy))) putEmoji(el,"ü™¶");

      // Cat
      if (gameDoc.cat && gameDoc.cat.x===gx && gameDoc.cat.y===gy) {
        putEmoji(el, (gameDoc.cat.stunUntil && Date.now() < gameDoc.cat.stunUntil) ? "üòµ‚Äçüí´" : "üê±");
        addHPBar(el, gameDoc.cat.h||0, Math.max(1, gameDoc.cat.hMax||50));
      }

      // Pets
      const fleaHere=[...fleas].find(([,f])=>f.x===gx&&f.y===gy);
      if (fleaHere){ putEmoji(el,"ü™∞"); }  // fleas suicide, no HP bar
      const beetleHere=[...beetles].find(([,b])=>b.x===gx&&b.y===gy);
      if (beetleHere){ putEmoji(el,"ü™≤"); addHPBar(el, beetleHere[1].hp||1, beetleHere[1].max||1); }

      // Players
      for(const [n,p] of Object.entries(players)){ if (p.alive && p.x===gx && p.y===gy) putEmoji(el,"üê≠"); }
      if (me.alive && me.x===gx && me.y===gy) putEmoji(el,"üê≠");

      gridEl.appendChild(el);
    }
  }
  const aliveCt=(me.alive?1:0)+Object.values(players).filter(p=>p.alive).length;
  $("#aliveCount").textContent=aliveCt;
  $("#score").textContent=me.score;
}

/* ------------------------------- Firestore ------------------------------- */
const gameRef = doc(db,"games",gameId);
const playersCol = collection(db,"games",gameId,"players");
const structsCol = collection(db,"games",gameId,"structures");
const ratsCol = collection(db,"games",gameId,"rats");
const bearsCol = collection(db,"games",gameId,"bears");
const catsCol = collection(db,"games",gameId,"caterpillars");
const crowsCol = collection(db,"games",gameId,"crows");
const corpsesCol = collection(db,"games",gameId,"corpses");
const highsCol = collection(db,"games",gameId,"highscores");
/* NEW: pets */
const fleasCol = collection(db,"games",gameId,"fleas");
const beetlesCol = collection(db,"games",gameId,"beetles");

async function claimHost(){
  const snap = await getDoc(gameRef);
  const data = snap.exists()? snap.data() : {};
  if (!data.host){
    await setDoc(gameRef,{
      host: myName,
      startMs: Date.now(),
      cat: { x:gridSize-2, y:gridSize-2, h: 50, hMax: 50, stunCount:0, stunUntil:0 },
      catPower: 0,
      nextPowerOfferAt: Date.now() + 120000
    },{merge:true});
    I_AM_HOST = true;
  }else{
    I_AM_HOST = (data.host===myName);
    if (!data.cat){
      await setDoc(gameRef,{ cat:{ x:gridSize-2, y:gridSize-2, h:50, hMax:50, stunCount:0, stunUntil:0 } },{merge:true});
    }
  }
  setHostBadge();
}
async function upsertMe(){
  await setDoc(doc(playersCol,myName), {
    x:me.x,y:me.y,alive:me.alive,score:me.score,displayName:myName,
    powers: me.powers || {}
  },{merge:true});
}
function listen(){
  onSnapshot(gameRef,(s)=>{ if (!s.exists()) return; gameDoc=s.data(); if (gameDoc.host===myName && !I_AM_HOST){ I_AM_HOST=true; setHostBadge(); } render(); });
  onSnapshot(playersCol,(snap)=>{ const next={}; snap.forEach(d=>{ if (d.id!==myName) next[d.id]=d.data(); }); players=next; render(); });
  onSnapshot(structsCol,(snap)=>{ const m=new Map(); snap.forEach(d=>{ const v=d.data(); m.set(key(v.x,v.y),v); }); structures=m; render(); });
  onSnapshot(ratsCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(d.id,d.data())); rats=m; render(); });
  onSnapshot(bearsCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(d.id,d.data())); bears=m; render(); });
  onSnapshot(catsCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(d.id,d.data())); caterpillars=m; render(); });
  onSnapshot(crowsCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(d.id,d.data())); crows=m; render(); });
  onSnapshot(corpsesCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(key(d.data().x,d.data().y), d.id)); corpses=m; render(); });
  /* NEW */
  onSnapshot(fleasCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(d.id,d.data())); fleas=m; render(); });
  onSnapshot(beetlesCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(d.id,d.data())); beetles=m; render(); });
}

/* ------------------------------ Placement/HP ------------------------------ */
async function placeStructureHost(x,y,t,hp,extra={}){ await setDoc(doc(structsCol,key(x,y)),{x,y,t,hp,max:hp,...extra}); }
async function deleteStructureHost(x,y){ await deleteDoc(doc(structsCol,key(x,y))); }

function hpWall(){   return Math.round(35 * (1+0.2*levels.wall)); }
function hpTur(){    return Math.round(24 * (1+0.2*levels.turret)); }

/* ------------------------------ Pathfinding ------------------------------ */
function findPath(sx,sy,tx,ty,allowTargetBlocked=false,fly=false,extraBlockersFn=null){
  const Q=[[sx,sy]];
  const P=new Map([[key(sx,sy),null]]);
  const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
  while(Q.length){
    const [x,y]=Q.shift();
    if (x===tx && y===ty) break;
    for(const [dx,dy] of dirs){
      const nx=x+dx, ny=y+dy;
      if (nx<0||ny<0||nx>=gridSize||ny>=gridSize) continue;
      if (P.has(key(nx,ny))) continue;
      const blocked = fly? false : isBlocked(nx,ny) || (extraBlockersFn?.(nx,ny)??false);
      const isTarget = (nx===tx && ny===ty);
      if (blocked && !(allowTargetBlocked && isTarget)) continue;
      P.set(key(nx,ny),[x,y]); Q.push([nx,ny]);
    }
  }
  if (!P.has(key(tx,ty))) return null;
  const path=[]; let cur=[tx,ty];
  while(cur){ path.push(cur); cur=P.get(key(cur[0],cur[1])); }
  path.reverse(); return path;
}

/* ------------------------------- Selection utils ------------------------- */
function manhattan(ax,ay,bx,by){ return Math.abs(ax-bx)+Math.abs(ay-by); }
function nearestStructureFrom(x,y){
  let pick=null, best=1e9;
  for(const s of structures.values()){
    if (!["üß±","üî´","üí£"].includes(s.t)) continue;
    const d=manhattan(x,y,s.x,s.y);
    if (d<best){best=d; pick=s;}
  }
  return pick;
}

/* ------------------------------- Damage helpers -------------------------- */
async function damageEnemy(kind, id, amount){
  if (kind==="rat"){ const r=rats.get(id); if (!r) return; const hp=r.hp-amount; if (hp<=0) await deleteDoc(doc(ratsCol,id)); else await updateDoc(doc(ratsCol,id),{hp}); }
  else if (kind==="bear"){ const b=bears.get(id); if (!b) return; const hp=b.hp-amount; if (hp<=0) await deleteDoc(doc(bearsCol,id)); else await updateDoc(doc(bearsCol,id),{hp}); }
  else if (kind==="cater"){ const c=caterpillars.get(id); if (!c) return; const hp=c.hp-amount; if (hp<=0) await deleteDoc(doc(catsCol,id)); else await updateDoc(doc(catsCol,id),{hp}); }
  else if (kind==="crow"){ const cw=crows.get(id); if (!cw) return; const hp=cw.hp-amount; if (hp<=0) await deleteDoc(doc(crowsCol,id)); else await updateDoc(doc(crowsCol,id),{hp}); }
}
async function damageStructureHost(x,y,amt){
  const id=key(x,y); const s=structures.get(id); if (!s) return;
  if (s.t==="üí£"){ await deleteStructureHost(x,y); await detonateAt(x,y); return; }
  const hp=Math.max(0,(s.hp||0)-amt);
  if (hp<=0) await deleteStructureHost(x,y); else await updateDoc(doc(structsCol,id),{hp});
}

/* ------------------------------- Bombs ----------------------------------- */
async function detonateAt(x,y, dmgRat=18, dmgBear=14, dmgOther=16){
  if (!I_AM_HOST) return;
  renderExplosion(x,y);
  const within = (ux,uy)=> Math.max(Math.abs(ux-x), Math.abs(uy-y))<=1; // 3x3
  for (let dx=-1; dx<=1; dx++) for (let dy=-1; dy<=1; dy++){
    const nx=x+dx, ny=y+dy; const s=structures.get(key(nx,ny));
    if (s && s.t==="üß±"){ await deleteStructureHost(nx,ny); }
  }
  for (const [id,r] of rats){ if (within(r.x,r.y)) await damageEnemy("rat",id,dmgRat); }
  for (const [id,b] of bears){ if (within(b.x,b.y)) await damageEnemy("bear",id,dmgBear); }
  for (const [id,c] of caterpillars){ if (within(c.x,c.y)) await damageEnemy("cater",id,dmgOther); }
  for (const [id,cw] of crows){ if (within(cw.x,cw.y)) await damageEnemy("crow",id,dmgOther); }
  if (gameDoc.cat && within(gameDoc.cat.x,gameDoc.cat.y)){
    await damageCat(16); me.score+=4; await updateDoc(doc(playersCol,myName),{score:me.score}); floatText(gameDoc.cat.x,gameDoc.cat.y,"+4","#ffa94d");
  }
}

/* ------------------------------- Cat HP & stun --------------------------- */
async function damageCat(amount){
  if (!I_AM_HOST) return;
  const snap = await getDoc(gameRef);
  if (!snap.exists()) return;
  const g = snap.data();
  const cat = {...g.cat};
  if (cat.stunUntil && Date.now() < cat.stunUntil) return;

  cat.h = Math.max(0, (cat.h||0) - amount);
  if (cat.h <= 0){
    const nextCount = (cat.stunCount||0) + 1;
    const nextMax   = 50 * (nextCount + 1);
    cat.stunCount = nextCount;
    cat.stunUntil = Date.now() + 10000; // 10s
    cat.hMax = nextMax;
    cat.h = nextMax;
  }
  await updateDoc(gameRef, { cat });
}

/* ------------------------------ Turrets ---------------------------------- */
function turretRange(){ return 5 + levels.range; }
function turretDamage(){ return Math.round(6 * (1 + 0.25*levels.turret)); }
async function hostTurrets(){
  if (!I_AM_HOST) return;
  for (const o of structures.values()){
    if (o.t!=="üî´") continue;
    const rng = turretRange();
    const pool = [];
    if (gameDoc.cat) pool.push({kind:"cat", x:gameDoc.cat.x, y:gameDoc.cat.y});
    for (const [id,r] of rats)  pool.push({kind:"rat", id, x:r.x, y:r.y});
    for (const [id,b] of bears) pool.push({kind:"bear", id, x:b.x, y:b.y});
    for (const [id,c] of caterpillars) pool.push({kind:"cater", id, x:c.x, y:c.y});
    for (const [id,cw] of crows) pool.push({kind:"crow", id, x:cw.x, y:cw.y});
    if (!pool.length) continue;

    pool.sort((a,b)=> (Math.abs(a.x-o.x)+Math.abs(a.y-o.y)) - (Math.abs(b.x-o.x)+Math.abs(b.y-o.y)));
    const t=pool[0];
    const dist = Math.abs(t.x-o.x)+Math.abs(t.y-o.y);
    if (dist>rng) continue;

    const dmg = turretDamage();
    if (t.kind==="rat"){ await damageEnemy("rat",t.id,dmg); }
    else if (t.kind==="bear"){ await damageEnemy("bear",t.id,Math.floor(dmg*0.85)); }
    else if (t.kind==="cater"){ await damageEnemy("cater",t.id,dmg); }
    else if (t.kind==="crow"){ await damageEnemy("crow",t.id,dmg); }
    else if (t.kind==="cat"){ await damageCat(Math.floor(dmg/2)); me.score+=1; await updateDoc(doc(playersCol,myName),{score:me.score}); }
  }
}

/* ------------------------------ Enemy brains ----------------------------- */
function isFrozen(ent){ return (ent.freezeUntil||0) > Date.now(); }

async function hostRatsThink(){
  if (!I_AM_HOST) return;
  for (const [id,r] of rats){
    if (isFrozen(r)) continue;
    let target=null;

    const mice=[]; if (me.alive) mice.push({x:me.x,y:me.y,name:myName});
    for (const [n,p] of Object.entries(players)) if (p.alive) mice.push({x:p.x,y:p.y,name:n});

    let nearMouse = null, nearMouseDist = 1e9;
    for (const m of mice){
      const d=manhattan(r.x,r.y,m.x,m.y);
      if (d<nearMouseDist){ nearMouseDist=d; nearMouse={type:"mouse",...m}; }
    }

    if (nearMouse && nearMouseDist<=8){
      const pathToMouse = findPath(r.x,r.y,nearMouse.x,nearMouse.y,true);
      if (pathToMouse && pathToMouse.length>1) target = nearMouse;
      else{
        let wallPick=null, bestW=1e9;
        for (const s of structures.values()){
          if (s.t!=="üß±") continue;
          const d=manhattan(r.x,r.y,s.x,s.y);
          if (d<bestW){bestW=d; wallPick={type:"struct",x:s.x,y:s.y};}
        }
        target = wallPick || nearMouse;
      }
    }else{
      const st = nearestStructureFrom(r.x,r.y);
      if (st) target={type:"struct",x:st.x,y:st.y};
    }
    if (!target) continue;

    let step=null;
    const p=findPath(r.x,r.y,target.x,target.y,true);
    if (p && p.length>1) step={x:p[1][0],y:p[1][1]};
    else {
      const dx=Math.sign(target.x-r.x), dy=Math.sign(target.y-r.y);
      step = (Math.abs(target.x-r.x)>=Math.abs(target.y-r.y))
        ? {x:clamp(r.x+dx,1,gridSize-2), y:r.y}
        : {x:r.x, y:clamp(r.y+dy,1,gridSize-2)};
    }
    await updateDoc(doc(ratsCol,id),{x:step.x,y:step.y});

    const ms = structures.get(key(step.x,step.y));
    if (ms && ms.t==="üí£"){ await deleteStructureHost(step.x,step.y); await detonateAt(step.x,step.y); }

    if (target.type==="struct" && r.x===target.x && r.y===target.y){ await damageStructureHost(r.x,r.y,1); }
    if (target.type==="mouse" && r.x===target.x && r.y===target.y){
      if (target.name===myName && me.alive){ me.alive=false; await updateDoc(doc(playersCol,myName),{alive:false}); await addDoc(corpsesCol,{x:r.x,y:r.y}); }
      else { await updateDoc(doc(playersCol,target.name),{alive:false}); await addDoc(corpsesCol,{x:r.x,y:r.y}); }
    }
  }
}
async function hostBearsThink(){
  if (!I_AM_HOST) return;
  for (const [id,b] of bears){
    if (isFrozen(b)) continue;
    if (Math.random()<0.5) continue; // slower
    let target=null;

    const mice=[]; if (me.alive) mice.push({x:me.x,y:me.y,name:myName});
    for (const [n,p] of Object.entries(players)) if (p.alive) mice.push({x:p.x,y:p.y,name:n});
    let nearMouse=null, md=1e9; for(const m of mice){ const d=manhattan(b.x,b.y,m.x,m.y); if (d<md){md=d; nearMouse={type:"mouse",...m};}}
    if (nearMouse && md<=8){
      const path=findPath(b.x,b.y,nearMouse.x,nearMouse.y,true);
      if (path) target=nearMouse; else target=nearestStructureFrom(b.x,b.y) ? {type:"struct", ...nearestStructureFrom(b.x,b.y)} : nearMouse;
    }else{
      const st=nearestStructureFrom(b.x,b.y); if (st) target={type:"struct",x:st.x,y:st.y};
    }
    if (!target) continue;

    const p=findPath(b.x,b.y,target.x,target.y,true);
    if (p && p.length>1){ const s=p[1]; await updateDoc(doc(bearsCol,id),{x:s[0],y:s[1]}); }
    else { const dx=Math.sign(target.x-b.x), dy=Math.sign(target.y-b.y); const nx=clamp(b.x+dx,1,gridSize-2), ny=clamp(b.y+dy,1,gridSize-2); await updateDoc(doc(bearsCol,id),{x:nx,y:ny}); }

    if (target.type==="struct" && b.x===target.x && b.y===target.y){ await damageStructureHost(b.x,b.y,4); }
    if (target.type==="mouse" && b.x===target.x && b.y===target.y){
      if (target.name===myName && me.alive){ me.alive=false; await updateDoc(doc(playersCol,myName),{alive:false}); await addDoc(corpsesCol,{x:b.x,y:b.y}); }
      else { await updateDoc(doc(playersCol,target.name),{alive:false}); await addDoc(corpsesCol,{x:b.x,y:b.y}); }
    }
  }
}
async function hostCaterpillarsThink(){
  if (!I_AM_HOST) return;
  for(const [id,c] of caterpillars){
    if (isFrozen(c)) continue;
    const st=nearestStructureFrom(c.x,c.y); if (!st) continue;
    const p=findPath(c.x,c.y,st.x,st.y,true);
    if (p && p.length>1){ const s=p[1]; await updateDoc(doc(catsCol,id),{x:s[0],y:s[1]}); }
    if (c.x===st.x && c.y===st.y){ await damageStructureHost(c.x,c.y,20); await deleteDoc(doc(catsCol,id)); }
  }
}
async function hostCrowsThink(){
  if (!I_AM_HOST) return;
  for(const [id,cw] of crows){
    if (isFrozen(cw)) continue;
    let targets=[];
    if (me.alive) targets.push({x:me.x,y:me.y,type:"mouse"});
    for (const [,p] of Object.entries(players)) if (p.alive) targets.push({x:p.x,y:p.y,type:"mouse"});
    for(const s of structures.values()) if (["üî´","üß±","üí£"].includes(s.t)) targets.push({x:s.x,y:s.y,type:"struct"});
    if (!targets.length) continue;
    targets.sort((a,b)=> (manhattan(cw.x,cw.y,a.x,a.y)) - (manhattan(cw.x,cw.y,b.x,b.y)));
    const t=targets[0];
    const p=findPath(cw.x,cw.y,t.x,t.y,true,true);
    if (p && p.length>1){ const s=p[1]; if (Math.random()<0.5) await updateDoc(doc(crowsCol,id),{x:s[0],y:s[1]}); }
    else{ if (t.type==="struct" && cw.x===t.x && cw.y===t.y){ await damageStructureHost(cw.x,cw.y,2); } }
  }
}

/* ------------------------------- Cat AI ---------------------------------- */
async function hostCatAI(){
  if (!I_AM_HOST || !gameDoc.cat) return;
  const cat = {...gameDoc.cat};
  if (cat.stunUntil && Date.now() < cat.stunUntil){ await updateDoc(gameRef,{cat}); return; }

  const mice=[]; if (me.alive) mice.push({x:me.x,y:me.y,type:"mouse",name:myName});
  for (const [n,p] of Object.entries(players)) if (p.alive) mice.push({x:p.x,y:p.y,type:"mouse",name:n});
  let target=null;

  let nearMouse=null, md=1e9; for(const m of mice){ const d=manhattan(cat.x,cat.y,m.x,m.y); if (d<md){md=d; nearMouse=m;} }
  if (nearMouse && md<=8){
    const path=findPath(cat.x,cat.y,nearMouse.x,nearMouse.y,true);
    if (path) target=nearMouse;
    else { const st=nearestStructureFrom(cat.x,cat.y); if (st) target={x:st.x,y:st.y,type:"struct"}; }
  }else{
    const st=nearestStructureFrom(cat.x,cat.y); if (st) target={x:st.x,y:st.y,type:"struct"};
  }
  if (!target){ await updateDoc(gameRef,{cat}); return; }

  let path = findPath(cat.x,cat.y,target.x,target.y,true);
  if (path && path.length>1){ const step=path[1]; cat.x=step[0]; cat.y=step[1]; }
  else{
    const dx = Math.sign(target.x - cat.x), dy=Math.sign(target.y - cat.y);
    const nx=clamp(cat.x+dx,1,gridSize-2), ny=clamp(cat.y+dy,1,gridSize-2);
    const block = structures.get(key(nx,ny));
    if (!block){ cat.x=nx; cat.y=ny; }
    else if (["üß±","üî´","üí£"].includes(block.t)){ await damageStructureHost(nx,ny,2 + Math.floor((gameDoc.catPower||0)/2)); }
  }

  for (const [ax,ay] of [[1,0],[-1,0],[0,1],[0,-1]]){
    const tx=cat.x+ax, ty=cat.y+ay;
    const s = structures.get(key(tx,ty));
    if (s && ["üß±","üî´","üí£"].includes(s.t)){ await damageStructureHost(tx,ty,2 + Math.floor((gameDoc.catPower||0)/2)); break; }
    if (me.alive && me.x===tx && me.y===ty){ me.alive=false; await updateDoc(doc(playersCol,myName),{alive:false}); await addDoc(corpsesCol,{x:tx,y:ty}); break; }
    for (const [n,p] of Object.entries(players)){ if (p.alive && p.x===tx && p.y===ty){ await updateDoc(doc(playersCol,n),{alive:false}); await addDoc(corpsesCol,{x:tx,y:ty}); break; } }
  }
  await updateDoc(gameRef,{cat});
}

/* ------------------------------- Power-ups --------------------------------
   Now includes: Fire, Lightning, Ice, Stone, Flea, Beetle
-----------------------------------------------------------------------------*/
const powerBar = document.getElementById('powerBar');
const POWER_LIST = ["Fire","Lightning","Ice","Stone","Flea","Beetle"];
function rand2(arr){ const a=[...arr]; const i=Math.floor(Math.random()*a.length); let j=Math.floor(Math.random()*a.length); if (j===i) j=(j+1)%a.length; return [a[i],a[j]]; }
function powerIcon(n){ return n==="Fire"?"üî•":n==="Lightning"?"‚ö°":n==="Ice"?"‚ùÑÔ∏è":n==="Stone"?"ü™®":n==="Flea"?"ü™∞":"ü™≤"; }

function powerPeriod(name,lvl){
  if (name==="Stone")     return Math.max(5000, 30000 - 3000*(lvl-1));
  if (name==="Ice")       return Math.max(5000, 30000 - 1000*(lvl-1));
  if (name==="Lightning") return Math.max(4000, 15000 - 1000*(lvl-1));
  if (name==="Fire")      return Math.max(6000, 30000 - 1000*(lvl-1));
  if (name==="Flea")      return Math.max(5000, 30000 - 1000*(lvl-1)); // base 30s, -1s/level
  if (name==="Beetle")    return Math.max(5000, 45000 - 2000*(lvl-1)); // base 45s, -2s/level
  return 30000;
}
function powerData(p){ return p && typeof p.lvl==="number" ? p : {lvl:0,nextAt:Date.now()+99999999}; }

function showPowerOffer(){
  if (!me.alive) return;
  const [a,b]=rand2(POWER_LIST);
  powerBar.innerHTML="";
  const mk=(name)=>{
    const btn=document.createElement('div'); btn.className='opt';
    btn.innerHTML = `${powerIcon(name)} <b>${name}</b>`;
    btn.onclick=async ()=>{
      const cur = powerData(me.powers?.[name]);
      const nextLvl = (cur.lvl||0)+1;
      const nextAt = Date.now() + powerPeriod(name,nextLvl);
      me.powers = {...(me.powers||{}), [name]:{lvl:nextLvl,nextAt}};
      await updateDoc(doc(playersCol,myName), { powers: me.powers });
      powerBar.style.display='none';
      toast(`${name} +1`);
    };
    return btn;
  };
  powerBar.appendChild(mk(a));
  powerBar.appendChild(mk(b));
  powerBar.style.display='flex';
}

/* ------------------------------ Power ticking ---------------------------- */
async function hostPowerTick(){
  if (!I_AM_HOST) return;

  const g = (await getDoc(gameRef)).data()||{};
  if ((g.nextPowerOfferAt||0) <= Date.now()){
    if (myName===g.host) showPowerOffer();
    await updateDoc(gameRef,{ nextPowerOfferAt: Date.now() + 120000 });
  }

  const all = {...players};
  all[myName] = {x:me.x,y:me.y,alive:me.alive,powers:me.powers};
  const now = Date.now();

  for (const [name,p] of Object.entries(all)){
    if (!p?.alive) continue;
    const px=p.x, py=p.y;
    const powers = p.powers || {};

    /* Stone (unchanged) */
    if (powers.Stone && (powers.Stone.nextAt||0) <= now){
      const lvl=powers.Stone.lvl||1;
      const cand = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
      for (let i=0;i<8;i++){
        const [dx,dy] = cand[Math.floor(Math.random()*cand.length)];
        const x=clamp(px+dx,1,gridSize-2), y=clamp(py+dy,1,gridSize-2);
        if (!tileOccupied(x,y)){ await placeStructureHost(x,y,"üß±", hpWall()); break; }
      }
      const nextAt = now + powerPeriod("Stone",powers.Stone.lvl||1);
      await updateDoc(doc(playersCol,name), { powers: {...powers, Stone:{lvl:powers.Stone.lvl, nextAt} } });
    }

    /* Ice (unchanged) */
    if (powers.Ice && (powers.Ice.nextAt||0) <= now){
      const lvl=powers.Ice.lvl||1;
      const dur = Math.max(1000, (5000 - 500*(lvl-1)));
      const r=2;
      renderFreezeArea(px,py,r);
      const inR = (ux,uy)=> Math.max(Math.abs(ux-px),Math.abs(uy-py))<=r;
      for (const [id,rn] of rats){ if (inR(rn.x,rn.y)) await updateDoc(doc(ratsCol,id), { freezeUntil: now+dur }); }
      for (const [id,b] of bears){ if (inR(b.x,b.y)) await updateDoc(doc(bearsCol,id), { freezeUntil: now+dur }); }
      for (const [id,c] of caterpillars){ if (inR(c.x,c.y)) await updateDoc(doc(catsCol,id), { freezeUntil: now+dur }); }
      for (const [id,cw] of crows){ if (inR(cw.x,cw.y)) await updateDoc(doc(crowsCol,id), { freezeUntil: now+dur }); }
      const nextAt = now + powerPeriod("Ice",lvl);
      await updateDoc(doc(playersCol,name), { powers: {...powers, Ice:{lvl, nextAt} } });
    }

    /* Lightning (unchanged) */
    if (powers.Lightning && (powers.Lightning.nextAt||0) <= now){
      const lvl=powers.Lightning.lvl||1;
      const rng=5; const dmg = 5 + 2*(lvl-1); const chains = 1 + (lvl-1);
      const pool=[];
      for (const [id,r] of rats){ pool.push({kind:"rat",id,x:r.x,y:r.y}); }
      for (const [id,b] of bears){ pool.push({kind:"bear",id,x:b.x,y:b.y}); }
      for (const [id,c] of caterpillars){ pool.push({kind:"cater",id,x:c.x,y:c.y}); }
      for (const [id,cw] of crows){ pool.push({kind:"crow",id,x:cw.x,y:cw.y}); }
      pool.sort((a,b)=> manhattan(px,py,a.x,a.y) - manhattan(px,py,b.x,b.y));
      const inR = pool.filter(e=> manhattan(px,py,e.x,e.y)<=rng);
      let current=inR[0]; let hits=0; const hitSet=new Set();
      const sig=(e)=>e.kind+":"+(e.id??`${e.x},${e.y}`);
      while(current && hits<=chains){
        hitSet.add(sig(current));
        await damageEnemy(current.kind,current.id,dmg);
        let next=null, best=1e9;
        for (const cand of inR){
          if (hitSet.has(sig(cand))) continue;
          const d = manhattan(current.x,current.y,cand.x,cand.y);
          if (d<=5 && d<best){ best=d; next=cand; }
        }
        current=next; hits++;
      }
      const nextAt = now + powerPeriod("Lightning",lvl);
      await updateDoc(doc(playersCol,name), { powers: {...powers, Lightning:{lvl, nextAt} } });
    }

    /* Fire (unchanged) */
    if (powers.Fire && (powers.Fire.nextAt||0) <= now){
      const lvl=powers.Fire.lvl||1;
      const r=2; const inR = (ux,uy)=> Math.max(Math.abs(ux-px),Math.abs(uy-py))<=r;
      renderExplosion(px,py);
      for (const [id,rn] of rats){ if (inR(rn.x,rn.y)){ await damageEnemy("rat",id,10+3*(lvl-1)); const dx=Math.sign(rn.x-px), dy=Math.sign(rn.y-py); const nx=clamp(rn.x+dx,1,gridSize-2), ny=clamp(rn.y+dy,1,gridSize-2); if (!isBlocked(nx,ny)) await updateDoc(doc(ratsCol,id),{x:nx,y:ny}); } }
      for (const [id,b] of bears){ if (inR(b.x,b.y)){ await damageEnemy("bear",id,8+3*(lvl-1)); const dx=Math.sign(b.x-px), dy=Math.sign(b.y-py); const nx=clamp(b.x+dx,1,gridSize-2), ny=clamp(b.y+dy,1,gridSize-2); if (!isBlocked(nx,ny)) await updateDoc(doc(bearsCol,id),{x:nx,y:ny}); } }
      for (const [id,c] of caterpillars){ if (inR(c.x,c.y)){ await damageEnemy("cater",id,10+3*(lvl-1)); } }
      for (const [id,cw] of crows){ if (inR(cw.x,cw.y)){ await damageEnemy("crow",id,10+3*(lvl-1)); } }
      if (gameDoc.cat && inR(gameDoc.cat.x,gameDoc.cat.y)){ await damageCat(8+3*(lvl-1)); }
      const nextAt = now + powerPeriod("Fire",lvl);
      await updateDoc(doc(playersCol,name), { powers: {...powers, Fire:{lvl, nextAt} } });
    }

    /* NEW: Flea spawns ‚Äì spawn lvl fleas near player, through walls pathing */
    if (powers.Flea && (powers.Flea.nextAt||0) <= now){
      const lvl=powers.Flea.lvl||1;
      const count = Math.max(1,lvl);
      for (let i=0;i<count;i++){
        const ox = [-1,0,1][Math.floor(Math.random()*3)];
        const oy = [-1,0,1][Math.floor(Math.random()*3)];
        const sx = clamp(px+ox,1,gridSize-2), sy=clamp(py+oy,1,gridSize-2);
        await addDoc(fleasCol,{ x:sx,y:sy,owner:name,createdMs:now });
      }
      const nextAt = now + powerPeriod("Flea",lvl);
      await updateDoc(doc(playersCol,name), { powers: {...powers, Flea:{lvl, nextAt} } });
    }

    /* NEW: Beetle spawns ‚Äì 1 beetle near player, walls honored */
    if (powers.Beetle && (powers.Beetle.nextAt||0) <= now){
      const lvl=powers.Beetle.lvl||1;
      const hp = 30 + 20*(lvl-1);
      const atk = 5 + 5*(lvl-1);
      const cand = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
      let placed=false;
      for (let t=0;t<8;t++){
        const [dx,dy]=cand[Math.floor(Math.random()*cand.length)];
        const sx=clamp(px+dx,1,gridSize-2), sy=clamp(py+dy,1,gridSize-2);
        const occupied = [...beetles].some(([,b])=>b.x===sx&&b.y===sy);
        if (!isBlocked(sx,sy) && !occupied){ await addDoc(beetlesCol,{ x:sx,y:sy,owner:name,hp:hp,max:hp,atk,lvl }); placed=true; break; }
      }
      if (!placed){ await addDoc(beetlesCol,{ x:px,y:py,owner:name,hp:hp,max:hp,atk,lvl }); }
      const nextAt = now + powerPeriod("Beetle",lvl);
      await updateDoc(doc(playersCol,name), { powers: {...powers, Beetle:{lvl, nextAt} } });
    }
  }
}

/* ------------------------------- NEW: Pets AI ---------------------------- */
function nearestEnemyFrom(x,y){
  const pool=[];
  if (gameDoc.cat) pool.push({kind:"cat", x:gameDoc.cat.x, y:gameDoc.cat.y});
  for (const [id,r] of rats)  pool.push({kind:"rat", id, x:r.x, y:r.y});
  for (const [id,b] of bears) pool.push({kind:"bear", id, x:b.x, y:b.y});
  for (const [id,c] of caterpillars) pool.push({kind:"cater", id, x:c.x, y:c.y});
  for (const [id,cw] of crows) pool.push({kind:"crow", id, x:cw.x, y:cw.y});
  if (!pool.length) return null;
  pool.sort((a,b)=> manhattan(x,y,a.x,a.y) - manhattan(x,y,b.x,b.y));
  return pool[0];
}

/* Fleas: fly through walls; on contact deal 5 then die */
async function hostFleasThink(){
  if (!I_AM_HOST) return;
  for (const [id,f] of fleas){
    const t = nearestEnemyFrom(f.x,f.y);
    if (!t) continue;
    const fly = true;
    const p = findPath(f.x,f.y,t.x,t.y,true,fly);
    if (p && p.length>1){
      const s=p[1]; await updateDoc(doc(fleasCol,id),{x:s[0],y:s[1]});
    }
    // contact?
    if (f.x===t.x && f.y===t.y){
      if (t.kind==="cat") await damageCat(5);
      else await damageEnemy(t.kind,t.id,5);
      await deleteDoc(doc(fleasCol,id));
    }
  }
}

/* Beetles: follow owner, attack within 8, honor walls, avoid stacking */
function beetleBlocker(nx,ny,selfId){
  for (const [bid,b] of beetles){ if (bid!==selfId && b.x===nx && b.y===ny) return true; }
  return false;
}
async function hostBeetlesThink(){
  if (!I_AM_HOST) return;
  for (const [id,b] of beetles){
    // dead?
    if ((b.hp||0)<=0){ await deleteDoc(doc(beetlesCol,id)); continue; }

    const owner = (b.owner===myName) ? me : players[b.owner];
    if (!owner || !owner.alive){ continue; }

    // target enemy within 8
    let target = null;
    const pool=[];
    if (gameDoc.cat) pool.push({kind:"cat", x:gameDoc.cat.x, y:gameDoc.cat.y});
    for (const [eid,r] of rats)  pool.push({kind:"rat", id:eid, x:r.x, y:r.y});
    for (const [eid,br] of bears) pool.push({kind:"bear", id:eid, x:br.x, y:br.y});
    for (const [eid,ct] of caterpillars) pool.push({kind:"cater", id:eid, x:ct.x, y:ct.y});
    for (const [eid,cw] of crows) pool.push({kind:"crow", id:eid, x:cw.x, y:cw.y});
    pool.sort((a,b2)=> manhattan(b.x,b.y,a.x,a.y)-manhattan(b.x,b.y,b2.x,b2.y));
    const near = pool.find(e=> manhattan(b.x,b.y,e.x,e.y) <= 8);

    if (near) target = near;
    else target = { x: owner.x, y: owner.y, kind:"follow" };

    // attack if adjacent / same tile to enemy
    if (near && manhattan(b.x,b.y,near.x,near.y)<=1){
      if (near.kind==="cat") await damageCat(b.atk||5);
      else await damageEnemy(near.kind, near.id, b.atk||5);
      continue;
    }

    // move step toward target honoring walls and other beetles
    const p = findPath(b.x,b.y,target.x,target.y,true,false,(nx,ny)=>beetleBlocker(nx,ny,id));
    let nx=b.x, ny=b.y;
    if (p && p.length>1){ nx=p[1][0]; ny=p[1][1]; }
    else{
      // small separation push if stuck on another beetle
      const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
      for (const [dx,dy] of dirs){
        const tx=clamp(b.x+dx,1,gridSize-2), ty=clamp(b.y+dy,1,gridSize-2);
        if (!isBlocked(tx,ty) && !beetleBlocker(tx,ty,id)){ nx=tx; ny=ty; break; }
      }
    }
    if (nx!==b.x || ny!==b.y) await updateDoc(doc(beetlesCol,id),{x:nx,y:ny});
  }
}

/* ------------------------------- Timers/loops ---------------------------- */
const ensurePickupSpawner = async ()=>{}; // safe stubs
const pickupSpawnerTick  = async ()=>{};

setInterval(async ()=>{ if (!me.alive) return; me.score += 10; await updateDoc(doc(playersCol,myName),{score:me.score}); }, 20000);
setInterval(async ()=>{ if (!I_AM_HOST) return; const cp=(gameDoc.catPower||0)+1; await updateDoc(gameRef,{catPower:cp}); }, 60000);

setInterval(async ()=>{ if (I_AM_HOST) await hostSpawnRatWave(); }, 12000);
setInterval(async ()=>{ if (I_AM_HOST) await hostSpawnBears(); }, 60000);
setInterval(async ()=>{ if (I_AM_HOST) await hostSpawnCaterpillars(); }, 15000);
setInterval(async ()=>{ if (I_AM_HOST) await hostSpawnCrows(); }, 30000);

/* AIs */
let catAITimer=null;
async function catAITick(){
  await hostCatAI();
  const mins = minutesSinceStart();
  const base = 500, factor = Math.pow(0.9, Math.max(0, mins)), delay = Math.max(120, Math.round(base * factor));
  catAITimer = setTimeout(catAITick, delay);
}
catAITick();
setInterval(hostRatsThink, 450);
setInterval(hostBearsThink, 650);
setInterval(hostCaterpillarsThink, 600);
setInterval(hostCrowsThink, 700);
/* NEW pets AI loops */
setInterval(hostFleasThink, 220);   // quick/flyers
setInterval(hostBeetlesThink, 380); // medium pace

/* turrets */
setInterval(hostTurrets, 250);

/* pickups */
setInterval(async ()=>{ if (I_AM_HOST) await hostSpawnPickups(); }, 18000);
setInterval(ensurePickupSpawner, 3000);
setInterval(pickupSpawnerTick, 1500);

/* bombs: check expiry -> detonate (3s fuse) */
setInterval(async ()=>{
  if (!I_AM_HOST) return;
  const now=Date.now();
  for (const s of structures.values()){
    if (s.t==="üí£" && s.expAt && now>=s.expAt){
      await deleteStructureHost(s.x,s.y);
      await detonateAt(s.x,s.y);
    }
  }
}, 250);

/* powers */
setInterval(hostPowerTick, 1000);

/* game over detect */
setInterval(async ()=>{ if (!I_AM_HOST) return; const someoneAlive = me.alive || Object.values(players).some(p=>p.alive); if (!someoneAlive){ await addDoc(highsCol,{when:serverTimestamp(),names:[myName,...Object.keys(players)],score: (me.score + Object.values(players).reduce((a,p)=>a+(p.score||0),0))}); toast("üíÄ All mice dead ‚Äî Game Over"); } }, 3000);

/* --------------------------------- Joysticks ----------------------------- */
function setupJoystick(el, onDir){
  const knob = el.querySelector('.knob');
  const rect = ()=> el.getBoundingClientRect();
  let active=false, cx=0, cy=0, maxR=50;
  const setKnob=(dx,dy)=>{ const r=Math.hypot(dx,dy), sc=r>maxR?maxR/r:1;
    knob.style.left=`calc(50% + ${(dx*sc)}px)`; knob.style.top=`calc(50% + ${(dy*sc)}px)`; };
  const dirFrom=(dx,dy)=>{ if (Math.hypot(dx,dy)<16) return {dx:0,dy:0};
    if (Math.abs(dx)>Math.abs(dy)) return {dx:Math.sign(dx),dy:0}; else return {dx:0,dy:Math.sign(dy)}; };
  const end=()=>{ active=false; setKnob(0,0); onDir({dx:0,dy:0}); };
  el.addEventListener('touchstart',e=>{ e.preventDefault(); active=true; const b=rect(); cx=b.left+b.width/2; cy=b.top+b.height/2; },{passive:false});
  el.addEventListener('touchmove',e=>{ if (!active) return; const t=e.touches[0]; const dx=t.clientX-cx, dy=t.clientY-cy; setKnob(dx,dy); onDir(dirFrom(dx,dy)); },{passive:false});
  el.addEventListener('touchend',e=>{ end(); },{passive:false});
  el.addEventListener('touchcancel',e=>{ end(); },{passive:false});
}
setInterval(()=>{ if (!me.alive) return; const moveDelay = Math.max(35, baseMoveDelay - 10*levels.speed); if (moveIntent.dx||moveIntent.dy) tryMove(moveIntent.dx,moveIntent.dy,moveDelay); }, 30);
setInterval(()=>{ if (!me.alive) return; if (buildIntent.dx||buildIntent.dy) tryBuild(buildIntent.dx,buildIntent.dy); }, 30);
setupJoystick(document.getElementById('moveJoy'), d=>{ moveIntent=d; });
setupJoystick(document.getElementById('buildJoy'), d=>{ buildIntent=d; });

window.addEventListener("keydown",e=>{
  if (e.key==="ArrowUp")  moveIntent={dx:0,dy:-1};
  if (e.key==="ArrowDown")moveIntent={dx:0,dy:1};
  if (e.key==="ArrowLeft")moveIntent={dx:-1,dy:0};
  if (e.key==="ArrowRight")moveIntent={dx:1,dy:0};
  if (e.key==="w") buildIntent={dx:0,dy:-1};
  if (e.key==="s") buildIntent={dx:0,dy:1};
  if (e.key==="a") buildIntent={dx:-1,dy:0};
  if (e.key==="d") buildIntent={dx:1,dy:0};
});
window.addEventListener("keyup",e=>{
  if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)) moveIntent={dx:0,dy:0};
  if (["w","a","s","d"].includes(e.key)) buildIntent={dx:0,dy:0};
});
document.getElementById("fsBtn").onclick=()=>{ const el=document.documentElement; if (document.fullscreenElement) document.exitFullscreen(); else el.requestFullscreen?.(); };

/* --------------------------- Spawns & Pickups ----------------------------- */
async function hostSpawnRatWave(){
  if (!I_AM_HOST) return;
  const cat = gameDoc.cat || {x:gridSize-2,y:gridSize-2,h:50};
  const n = Math.max(2, (gameDoc.catPower||0));
  let spawned=0, tries=0;
  while(spawned<n && tries<100){
    tries++;
    const dx = (Math.random()<.5?-1:1) * (1+Math.floor(Math.random()*3));
    const dy = (Math.random()<.5?-1:1) * (1+Math.floor(Math.random()*3));
    const x = clamp(cat.x+dx,1,gridSize-2);
    const y = clamp(cat.y+dy,1,gridSize-2);
    if (isBlocked(x,y)) continue;
    const hp = 10 + (gameDoc.catPower||0)*3;
    await addDoc(ratsCol,{x,y,hp,max:hp,type:"rat"});
    spawned++;
  }
}
async function hostSpawnBears(){
  if (!I_AM_HOST) return;
  const mins = minutesSinceStart();
  if (mins < 4) return;
  const count = Math.max(1, mins - 3);
  let spawned=0, tries=0;
  while (spawned<count && tries<200){
    tries++;
    const x = 2 + Math.floor(Math.random()*(gridSize-4));
    const y = 2 + Math.floor(Math.random()*(gridSize-4));
    if (isBlocked(x,y)) continue;
    const hp = 45 + (mins-4)*10 + (gameDoc.catPower||0)*5;
    await addDoc(bearsCol,{x,y,hp,max:hp,type:"bear"});
    spawned++;
  }
}
async function hostSpawnCaterpillars(){
  if (!I_AM_HOST) return;
  const mins=minutesSinceStart(); if (mins<3) return;
  if (Math.random()<0.5){
    const x = 2 + Math.floor(Math.random()*(gridSize-4));
    const y = 2 + Math.floor(Math.random()*(gridSize-4));
    if (!isBlocked(x,y)) await addDoc(catsCol,{x,y,hp:12,max:12});
  }
}
async function hostSpawnCrows(){
  if (!I_AM_HOST) return;
  const mins=minutesSinceStart(); if (mins<7) return;
  const cat = gameDoc.cat || {x:gridSize-2,y:gridSize-2};
  const dx = (Math.random()<.5?-1:1) * (3+Math.floor(Math.random()*4));
  const dy = (Math.random()<.5?-1:1) * (3+Math.floor(Math.random()*4));
  const x = clamp(cat.x+dx,1,gridSize-2);
  const y = clamp(cat.y+dy,1,gridSize-2);
  await addDoc(crowsCol,{x,y,hp:7,max:7});
}

/* Pickups (unchanged core) */
function unlockedItems(){
  const arr=[]; const pushW=(icon,w)=>{ for(let i=0;i<w;i++) arr.push(icon); };
  pushW("üß±",6); pushW("üî´",4); pushW("üí£",3);
  return arr;
}
function powerupPool(){ return ["üî∫üß±","üî∫üî´","üî∫üì°","üî∫üèÉ"]; }
async function placeTempPickup(x,y,t,ttlMs=30000){ await setDoc(doc(structsCol, key(x,y)), { x,y,t, hp:1, max:1, expAt: Date.now() + ttlMs }); }
async function hostSpawnPickups(){
  if (!I_AM_HOST) return;
  const types = unlockedItems();
  for (let i=0;i<2;i++){
    const x = 2 + Math.floor(Math.random()*(gridSize-4));
    const y = 2 + Math.floor(Math.random()*(gridSize-4));
    if (tileOccupied(x,y)) continue;
    const pick = types[Math.floor(Math.random()*types.length)];
    const t = "‚≠ï"+pick;
    await placeTempPickup(x,y,t, 30000);
  }
  if (Math.random()<0.5){
    const x = 2 + Math.floor(Math.random()*(gridSize-4));
    const y = 2 + Math.floor(Math.random()*(gridSize-4));
    if (!tileOccupied(x,y)){
      const pool = powerupPool();
      const t = pool[Math.floor(Math.random()*pool.length)];
      await placeTempPickup(x,y,t, 30000);
    }
  }
}
setInterval(async ()=>{
  if (!I_AM_HOST) return;
  const now = Date.now();
  for (const s of structures.values()){
    if ((s.t?.startsWith?.("‚≠ï") || s.t?.startsWith?.("üî∫")) && s.expAt && now >= s.expAt){
      await deleteStructureHost(s.x,s.y);
    }
  }
}, 2000);

/* ------------------------------ Player control --------------------------- */
async function tryMove(dx,dy,moveDelay){
  if (!me.alive) return;
  if (Date.now()-lastMoveAt<moveDelay) return;
  const nx=clamp(me.x+dx,1,gridSize-2), ny=clamp(me.y+dy,1,gridSize-2);
  if (!inBounds(nx,ny)) return;
  me.x=nx; me.y=ny; lastMoveAt=Date.now(); await upsertMe();

  const s=structures.get(key(nx,ny));
  if (s){
    const take=(icon,count)=>{ heldType=icon; heldCount=count; toast(`Held ${icon} x${count}`); };
    if (s.t==="‚≠ïüß±"){ take("üß±",20); await deleteDoc(doc(structsCol,key(nx,ny))); }
    if (s.t==="‚≠ïüî´"){ take("üî´",3);  await deleteDoc(doc(structsCol,key(nx,ny))); }
    if (s.t==="‚≠ïüí£"){ take("üí£",4);  await deleteDoc(doc(structsCol,key(nx,ny))); }

    const inc = (which,msg)=>{ levels[which]++; toast(msg); };
    if (s.t==="üî∫üß±"){ inc("wall","üß± +HP"); await deleteDoc(doc(structsCol,key(nx,ny))); }
    if (s.t==="üî∫üî´"){ inc("turret","üî´ +DMG/+HP"); await deleteDoc(doc(structsCol,key(nx,ny))); }
    if (s.t==="üî∫üì°"){ inc("range","üì° +RANGE"); await deleteDoc(doc(structsCol,key(nx,ny))); }
    if (s.t==="üî∫üèÉ"){ inc("speed","üèÉ Faster"); await deleteDoc(doc(structsCol,key(nx,ny))); }
    setHeldUI();
  }

  // revive
  if (corpses.has(key(nx,ny))){
    const qs = await getDocs(query(corpsesCol, where("x","==",nx), where("y","==",ny)));
    qs.forEach(async d=> await deleteDoc(d.ref));
    const dead = [myName, ...Object.entries(players).filter(([,p])=>!p.alive).map(([n])=>n)]
                  .filter((v,i,a)=>a.indexOf(v)===i);
    if (dead.length){
      const n = dead[0];
      await updateDoc(doc(playersCol,n),{alive:true,x:nx,y:ny});
      me.score += 100; await updateDoc(doc(playersCol,myName),{score:me.score});
      toast("ü©π Revived +100");
    }
  }

  render();
}
async function tryBuild(dx,dy){
  if (!me.alive) return;
  if (Date.now()-lastBuildAt<buildDelay) return;
  if (!heldType || heldCount<=0) { toast("No held item"); return; }
  const tx=clamp(me.x+dx,1,gridSize-2), ty=clamp(me.y+dy,1,gridSize-2);
  if (!inBounds(tx,ty)) return;
  if (tileOccupied(tx,ty)) return;

  let hp=10, extra={};
  if (heldType==="üß±"){ hp=hpWall(); }
  if (heldType==="üî´"){ hp=hpTur(); }
  if (heldType==="üí£"){ hp=1; extra.expAt = Date.now() + 3000; }

  await placeStructureHost(tx,ty,heldType,hp,extra);
  heldCount--; lastBuildAt=Date.now(); setHeldUI(); render();
}

/* --------------------------------- Boot ---------------------------------- */
(async function init(){
  me.x = 2 + Math.floor(Math.random()*6);
  me.y = 2 + Math.floor(Math.random()*6);
  me.powers = {};
  await upsertMe();
  const g=await getDoc(gameRef);
  if (!g.exists() || !g.data()?.startMs){ await setDoc(gameRef,{startMs:Date.now()},{merge:true}); }
  await claimHost();
  listen();
  if (I_AM_HOST) await hostSpawnPickups();
  setHeldUI();
  setHostBadge();
  render();
})();
</script>
</body>
</html>


















