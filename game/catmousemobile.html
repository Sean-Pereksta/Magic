<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
<title>ğŸ­ Cat vs Mouse â€” Mobile Survival</title>
<style>
  :root{
    --bg:#0b1014; --ink:#e6efff; --muted:#9fb3c8; --panel:#0f172a; --line:#1f2a44;
    --good:#22c55e; --warn:#eab308; --bad:#ef4444; --accent:#60a5fa;
    --grass:#2f7d32; --edge:#58606b; --cell:28px; --view:17;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Arial,sans-serif}
  /* HUD */
  #hud{position:fixed;top:0;left:0;right:0;display:flex;gap:8px;align-items:center;justify-content:space-between;
       padding:8px 12px;background:linear-gradient(180deg,rgba(10,16,26,.85),rgba(10,16,26,.35));backdrop-filter:blur(6px);z-index:10}
  .chip{display:inline-flex;gap:8px;align-items:center;background:#0e1726;border:1px solid #1f2a44;border-radius:999px;padding:6px 10px}
  .pill{padding:2px 8px;border-radius:999px;border:1px solid #2a3a60;background:#121c30;color:#9fb3d0}
  a.btn{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:10px;border:1px solid #2a3a60;background:#0f1a2e;color:#cfe6ff;text-decoration:none}

  #main{padding-top:56px;display:flex;flex-direction:column;align-items:center;gap:10px}
  #stage{width:calc(var(--cell)*var(--view));height:calc(var(--cell)*var(--view));
         border:2px solid var(--line);border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.35);
         position:relative;overflow:hidden;background:repeating-linear-gradient(90deg,#2e6d31 0,#2e6d31 10px,#2a6a2d 10px,#2a6a2d 20px)}
  #grid{display:grid;grid-template-columns:repeat(var(--view),var(--cell));grid-template-rows:repeat(var(--view),var(--cell));}
  .cell{width:var(--cell);height:var(--cell);display:flex;align-items:center;justify-content:center;
        position:relative;font-size:20px;user-select:none}
  .edge{background:#6d747f}
  .grass{background:linear-gradient(135deg,#2f7d32,#275e28)}
  .hpbar{position:absolute;left:2px;right:2px;bottom:2px;height:4px;background:#263040;border-radius:3px;overflow:hidden}
  .hpbar>i{display:block;height:100%;background:#ff5252}
  .float{position:absolute;pointer-events:none;font-weight:700;animation:rise .8s ease-out forwards}
  @keyframes rise{0%{opacity:1;transform:translateY(0)}100%{opacity:0;transform:translateY(-16px)}}

  /* Joysticks */
  #pads{width:100%;max-width:860px;display:flex;justify-content:space-between;gap:12px;padding:8px 12px 14px}
  .joyWrap{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center}
  .joy{
    width:140px;height:140px;border-radius:50%;
    background:radial-gradient(120px at 50% 50%, #0e1726, #0c1422);
    border:1px solid #223154; position:relative; touch-action:none; box-shadow:0 8px 24px rgba(0,0,0,.35);
  }
  .joy .knob{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    width:78px; height:78px; border-radius:50%; background:#13233e; border:1px solid #2a3a60;
    box-shadow:inset 0 0 0 2px #0b1628;
  }
  .joy .hint{position:absolute; left:50%; top:50%; width:4px; height:4px; border-radius:50%; background:#3b5ea8; opacity:.7}
  .joyLabel{margin-top:6px; color:#a8c3ff; font-size:13px; text-align:center}

  #toast{position:fixed;bottom:16px;left:50%;transform:translateX(-50%);background:#0e1726;border:1px solid #1f2a44;
         padding:10px 14px;border-radius:10px;box-shadow:0 10px 24px rgba(0,0,0,.35);display:none;z-index:15}
</style>
</head>
<body>

<!-- HUD: Fullscreen FIRST, then Score, then Held -->
<div id="hud">
  <a class="btn" id="fsBtn">â›¶ Full Screen</a>
  <div class="chip">
    <span id="hostBadge" class="pill">Host?</span>
    <span>ğŸ‘¥ <b id="aliveCount">0</b></span>
    <span>â­ <b id="score">0</b></span>
    <span class="pill">+10 / 20s</span>
  </div>
  <div id="held" class="chip">
    <span>Held:</span><span id="heldIcon" style="min-width:28px;text-align:center">â€”</span>
    <span id="heldCount" class="pill">0</span>
  </div>
</div>

<div id="main">
  <div id="stage"><div id="grid"></div></div>
  <div id="pads">
    <div class="joyWrap">
      <div id="moveJoy" class="joy">
        <div class="hint" style="transform:translate(-50%,-50%) translate(0,-48px)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(48px,0)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(0,48px)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(-48px,0)"></div>
        <div class="knob"></div>
      </div>
      <div class="joyLabel">Move</div>
    </div>
    <div class="joyWrap">
      <div id="buildJoy" class="joy">
        <div class="hint" style="transform:translate(-50%,-50%) translate(0,-48px)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(48px,0)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(0,48px)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(-48px,0)"></div>
        <div class="knob"></div>
      </div>
      <div class="joyLabel">Build (uses held)</div>
    </div>
  </div>
</div>

<div id="toast"></div>

<script type="module">
/* ----------------------------- Firebase setup ----------------------------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection,
  addDoc, deleteDoc, serverTimestamp, getDocs, query, where
} from "https://www.gstatic.com/firebasejs/10.11.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
};
const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);

/* ------------------------------- Parameters ------------------------------- */
const url = new URLSearchParams(location.search);
const gameId = url.get("gameId") || "sandbox";
const myName = (url.get("username")||"Player").trim().toLowerCase();

/* --------------------------------- State --------------------------------- */
const gridSize = 40;
const view = 17;
const gridEl = document.getElementById("grid");
const stageEl = document.getElementById("stage");
const cellPx = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'))||28;
let camera = {x:0,y:0};

let I_AM_HOST = false;
let gameDoc = {};
let players = {};          // other players (self is local-authority)
let structures = new Map();// "x_y" -> {t,hp,max,flags...}
let rats = new Map();      // id -> {x,y,hp,max,type:"rat"|"firerat"}
let caterpillars = new Map(); // id -> {x,y,hp?,max?}
let crows = new Map();     // id -> {x,y} (flies over walls)
let fleas = new Map();     // id -> {x,y,life}
let corpses = new Map();   // "x_y" -> id

let me = {x:2,y:2,alive:true,score:0};

// Single held item (last pickup)
let heldType = null;   // "ğŸ§±","ğŸ”«","ğŸ","ğŸ§¨","ğŸ›¢ï¸","âš¡","ğŸ”Œ","ğŸ©¹","ğŸ”€"
let heldCount = 0;

// Upgrade levels
let levels = {
  wall:0, turret:0, hive:0,
  spike:0, oil:0, arc:0, power:0, repair:0, router:0
};

// Input
let moveDelay=120, buildDelay=120;
let lastMoveAt=0, lastBuildAt=0;
let moveIntent={dx:0,dy:0}, buildIntent={dx:0,dy:0};

/* ------------------------------- Helpers --------------------------------- */
const $ = sel => document.querySelector(sel);
function key(x,y){ return `${x}_${y}`; }
function clamp(v,min,max){ return v<min?min:v>max?max:v; }
function inBounds(x,y){ return x>0 && y>0 && x<gridSize-1 && y<gridSize-1; }
function toast(msg,ms=1200){ const el=$("#toast"); el.textContent=msg; el.style.display='block'; setTimeout(()=>el.style.display='none',ms); }
function setHostBadge(){ $("#hostBadge").textContent = I_AM_HOST? "ğŸ‘‘ Host" : "Client"; }
function setHeldUI(){ $("#heldIcon").textContent = heldType || "â€”"; $("#heldCount").textContent = heldCount || 0; }

function focusCamera(){ camera.x = clamp(me.x - Math.floor(view/2), 0, gridSize - view);
                        camera.y = clamp(me.y - Math.floor(view/2), 0, gridSize - view); }

function spawnHitParticles(x, y, count=6, color="#f6d365"){
  const baseX = (x - camera.x)*cellPx + cellPx/2;
  const baseY = (y - camera.y)*cellPx + cellPx/2;
  for (let i=0;i<count;i++){
    const p = document.createElement('div');
    p.style.position='absolute'; p.style.left=baseX+'px'; p.style.top=baseY+'px';
    p.style.width='4px'; p.style.height='4px'; p.style.borderRadius='50%'; p.style.background=color; p.style.pointerEvents='none';
    const ang=Math.random()*Math.PI*2, spd=8+Math.random()*14, dx=Math.cos(ang)*spd, dy=Math.sin(ang)*spd;
    p.animate([{transform:'translate(-2px,-2px)',opacity:1},{transform:`translate(${dx}px,${dy}px)`,opacity:0}],
              {duration:280+Math.random()*220,easing:'ease-out',fill:'forwards'});
    stageEl.appendChild(p); setTimeout(()=>p.remove(),520);
  }
}

/* ------------------------------- Blocking -------------------------------- */
// Mice can walk over structures, but AI/placements consider blocks
function isBlocked(x,y){
  if (x<=0||y<=0||x>=gridSize-1||y>=gridSize-1) return true;
  const s=structures.get(key(x,y));
  return !!(s && ["ğŸ§±","ğŸ”«","ğŸ","ğŸ§¨","ğŸ›¢ï¸","âš¡","ğŸ”Œ","ğŸ©¹","ğŸ”€"].includes(s.t));
}
function tileOccupied(x,y){ return !!structures.get(key(x,y)); }

/* ------------------------------- Rendering ------------------------------- */
function hpBar(el, cur, max){
  const bar = document.createElement("div"); bar.className="hpbar";
  const fill=document.createElement("i"); const pct = Math.max(0,Math.min(1,(cur||0)/(max||1)));
  fill.style.width=(pct*100)+"%"; bar.appendChild(fill); el.appendChild(bar);
}

function render(){
  focusCamera();
  gridEl.innerHTML="";
  for(let ry=0; ry<view; ry++){
    for(let rx=0; rx<view; rx++){
      const gx=camera.x+rx, gy=camera.y+ry;
      const el=document.createElement("div"); el.className="cell";
      if (gx===0||gy===0||gx===gridSize-1||gy===gridSize-1) el.classList.add("edge"); else el.classList.add("grass");
      let txt="";

      // structures
      const s=structures.get(key(gx,gy));
      if (s){
        txt=s.t;
        if (["ğŸ§±","ğŸ”«","ğŸ","ğŸ§¨","ğŸ›¢ï¸","âš¡","ğŸ”Œ","ğŸ©¹","ğŸ”€"].includes(s.t)){
          hpBar(el, s.hp||0, s.max||1);
        }
        // burning visual on walls
        if (s.t==="ğŸ§±" && s.burn){ el.style.boxShadow="inset 0 0 10px rgba(255,80,0,.8)"; }
      }

      // enemies overlays + hp bars
      const ratHere=[...rats].find(([,r])=>r.x===gx&&r.y===gy);
      if (ratHere){ txt = ratHere[1].type==="firerat" ? "ğŸ€ğŸ”¥" : "ğŸ€"; hpBar(el, ratHere[1].hp||1, ratHere[1].max||ratHere[1].hp||1); }
      const catp=[...caterpillars].find(([,c])=>c.x===gx&&c.y===gy);
      if (catp){ txt="ğŸ›"; if (catp[1].hp) hpBar(el, catp[1].hp, catp[1].max||catp[1].hp); }
      const crow=[...crows].find(([,c])=>c.x===gx&&c.y===gy);
      if (crow){ txt="ğŸ¦"; }

      // fleas
      for(const f of fleas.values()){ if (f.x===gx&&f.y===gy) txt="ğŸ"; }

      // corpse
      if (corpses.has(key(gx,gy))) txt="ğŸª¦";

      // cat
      if (gameDoc.cat && gameDoc.cat.x===gx && gameDoc.cat.y===gy) txt="ğŸ±";

      // players
      for(const [n,p] of Object.entries(players)){ if (p.alive && p.x===gx && p.y===gy) txt="ğŸ­"; }
      if (me.alive && me.x===gx && me.y===gy) txt="ğŸ­";

      el.textContent=txt;
      gridEl.appendChild(el);
    }
  }
  const aliveCt=(me.alive?1:0)+Object.values(players).filter(p=>p.alive).length;
  $("#aliveCount").textContent=aliveCt;
  $("#score").textContent=me.score;
}

/* ------------------------------- Firestore ------------------------------- */
const gameRef = doc(db,"games",gameId);
const playersCol = collection(db,"games",gameId,"players");
const structsCol = collection(db,"games",gameId,"structures");
const ratsCol = collection(db,"games",gameId,"rats");
const catsCol = collection(db,"games",gameId,"caterpillars");
const crowsCol = collection(db,"games",gameId,"crows");
const fleasCol = collection(db,"games",gameId,"fleas");
const corpsesCol = collection(db,"games",gameId,"corpses");
const highsCol = collection(db,"games",gameId,"highscores");

async function claimHost(){
  const snap = await getDoc(gameRef);
  const data = snap.exists()? snap.data() : {};
  if (!data.host){
    await setDoc(gameRef,{
      host: myName,
      startMs: Date.now(),
      cat: { x:gridSize-2, y:gridSize-2, h: Number.POSITIVE_INFINITY },
      catPower: 0
    },{merge:true});
    I_AM_HOST = true;
  }else{
    I_AM_HOST = (data.host===myName);
    if (!data.cat){
      await setDoc(gameRef,{ cat:{ x:gridSize-2, y:gridSize-2, h:Number.POSITIVE_INFINITY } },{merge:true});
    }
  }
  setHostBadge();
}
async function upsertMe(){
  await setDoc(doc(playersCol,myName), {x:me.x,y:me.y,alive:me.alive,score:me.score,displayName:myName},{merge:true});
}
function listen(){
  onSnapshot(gameRef,(s)=>{ if (!s.exists()) return; gameDoc=s.data(); if (gameDoc.host===myName && !I_AM_HOST){ I_AM_HOST=true; setHostBadge(); } render(); });
  onSnapshot(playersCol,(snap)=>{ const next={}; snap.forEach(d=>{ if (d.id!==myName) next[d.id]=d.data(); }); players=next; render(); });
  onSnapshot(structsCol,(snap)=>{ const m=new Map(); snap.forEach(d=>{ const v=d.data(); m.set(key(v.x,v.y),v); }); structures=m; render(); });
  onSnapshot(ratsCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(d.id,d.data())); rats=m; render(); });
  onSnapshot(catsCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(d.id,d.data())); caterpillars=m; render(); });
  onSnapshot(crowsCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(d.id,d.data())); crows=m; render(); });
  onSnapshot(fleasCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(d.id,d.data())); fleas=m; render(); });
  onSnapshot(corpsesCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(key(d.data().x,d.data().y), d.id)); corpses=m; render(); });
}

/* ------------------------------ Placement/HP ------------------------------ */
async function placeStructureHost(x,y,t,hp,extra={}){
  await setDoc(doc(structsCol,key(x,y)),{x,y,t,hp,max:hp,...extra});
}
async function damageStructureHost(x,y,amt){
  const id=key(x,y); const s=structures.get(id); if (!s) return;
  spawnHitParticles(x,y,6);
  let hp=Math.max(0,(s.hp||0)-amt);
  // apply oil slow marker to enemies elsewhere; for walls we handle burn below
  if (hp<=0) await deleteDoc(doc(structsCol,id));
  else await updateDoc(doc(structsCol,id),{hp});
}
function hpWall(){   return Math.round(60 * (1+0.15*levels.wall)); }
function hpTur(){    return Math.round(30 * (1+0.15*levels.turret)); }
function hpHive(){   return Math.round(35 * (1+0.15*levels.hive)); }
function hpSpike(){  return Math.round(18 * (1+0.15*levels.spike)); }
function hpOil(){    return Math.round(18 * (1+0.15*levels.oil)); }
function hpArc(){    return Math.round(28 * (1+0.15*levels.arc)); }
function hpPower(){  return Math.round(28 * (1+0.15*levels.power)); }
function hpRepair(){ return Math.round(28 * (1+0.15*levels.repair)); }
function hpRouter(){ return Math.round(24 * (1+0.15*levels.router)); }

function dmgTurret(){  return Math.round(6 * (1+0.25*levels.turret) * (1 + 0.15*nearbyPowerBonus)); }
function dmgArc(){     return Math.round(5 * (1+0.25*levels.arc) * (1 + 0.15*nearbyPowerBonus)); }
function spikeDamage(){return Math.round(10 * (1+0.3*levels.spike)); }
function oilSlowPct(){ return Math.min(0.6, 0.25 + 0.08*levels.oil); }
function repairPerTickBase(){ return 1 + Math.floor(levels.repair/2); }
function catBiteDmg(){ return 2 + Math.floor((gameDoc.catPower||0)/2); } // used as cap for total repair stack

function arcJumps(){ return 1 + Math.floor(levels.arc/3); } // +1 jump every 3 upgrades
function powerBuffRadius(){ return 2; }
function repairRadius(){ return 2; }

/* ------------------------------ Pathfinding ------------------------------ */
function findPath(sx,sy,tx,ty,allowTargetBlocked=false,fly=false){
  // fly=true ignores blocks (for crows)
  const Q=[[sx,sy]];
  const P=new Map([[key(sx,sy),null]]);
  const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
  while(Q.length){
    const [x,y]=Q.shift();
    if (x===tx && y===ty) break;
    for(const [dx,dy] of dirs){
      const nx=x+dx, ny=y+dy;
      if (nx<0||ny<0||nx>=gridSize||ny>=gridSize) continue;
      if (P.has(key(nx,ny))) continue;
      const blocked = fly? false : isBlocked(nx,ny);
      const isTarget = (nx===tx && ny===ty);
      if (blocked && !(allowTargetBlocked && isTarget)) continue;
      P.set(key(nx,ny),[x,y]); Q.push([nx,ny]);
    }
  }
  if (!P.has(key(tx,ty))) return null;
  const path=[]; let cur=[tx,ty];
  while(cur){ path.push(cur); cur=P.get(key(cur[0],cur[1])); }
  path.reverse(); return path;
}

/* ------------------------------ Host logic ------------------------------- */
function anyMouseAlive(){ if (me.alive) return true; return Object.values(players).some(p=>p.alive); }
async function saveHighscoreIfNeeded(){
  const everyone = [myName,...Object.keys(players)];
  const total = me.score + Object.values(players).reduce((a,p)=>a+(p.score||0),0);
  await addDoc(highsCol,{when:serverTimestamp(),names:everyone,score:total});
}

/* ---- Pickups (with timed unlocks) ---- */
function minutesSinceStart(){ return Math.floor((Date.now() - (gameDoc.startMs||Date.now()))/60000); }
function unlockedItems(){
  const m=minutesSinceStart();
  const base = ["ğŸ§±","ğŸ”«","ğŸ"];
  const extra = [];
  if (m>=3) extra.push("âš¡");    // Arc Tower
  if (m>=4) extra.push("ğŸ”Œ");    // Power Node
  if (m>=5) extra.push("ğŸ©¹");    // Repair Node
  extra.push("ğŸ§¨","ğŸ›¢ï¸","ğŸ”€");   // Spike, Oil, Router available anytime
  return base.concat(extra);
}
function powerupPool(){
  const m=minutesSinceStart();
  const arr=["ğŸ”ºğŸ§±","ğŸ”ºğŸ”«","ğŸ”ºğŸ","ğŸ”ºğŸ§¨","ğŸ”ºğŸ›¢ï¸","ğŸ”ºğŸ”€"];
  if (m>=3) arr.push("ğŸ”ºâš¡");
  if (m>=4) arr.push("ğŸ”ºğŸ”Œ");
  if (m>=5) arr.push("ğŸ”ºğŸ©¹");
  return arr;
}

async function hostSpawnPickups(){
  const types = unlockedItems();
  for (let i=0;i<3;i++){
    const x = 2 + Math.floor(Math.random()*(gridSize-4));
    const y = 2 + Math.floor(Math.random()*(gridSize-4));
    if (tileOccupied(x,y)) continue;
    const t = "â­•"+types[Math.floor(Math.random()*types.length)];
    await placeStructureHost(x,y,t,1);
  }
  if (Math.random()<0.45){
    const x = 2 + Math.floor(Math.random()*(gridSize-4));
    const y = 2 + Math.floor(Math.random()*(gridSize-4));
    if (!tileOccupied(x,y)){
      const picks = powerupPool();
      const t = picks[Math.floor(Math.random()*picks.length)];
      await placeStructureHost(x,y,t,1);
    }
  }
}

/* ---- Enemy spawns ---- */
async function hostSpawnRatWave(){
  if (!I_AM_HOST) return;
  const cat = gameDoc.cat || {x:gridSize-2,y:gridSize-2,h:Number.POSITIVE_INFINITY};
  const n = Math.max(2, (gameDoc.catPower||0));
  let spawned=0, tries=0;
  while(spawned<n && tries<100){
    tries++;
    const dx = (Math.random()<.5?-1:1) * (1+Math.floor(Math.random()*3));
    const dy = (Math.random()<.5?-1:1) * (1+Math.floor(Math.random()*3));
    const x = clamp(cat.x+dx,1,gridSize-2);
    const y = clamp(cat.y+dy,1,gridSize-2);
    if (isBlocked(x,y)) continue;
    const hp = 6 + (gameDoc.catPower||0)*3;
    await addDoc(ratsCol,{x,y,hp,max:hp,type:"rat"});
    spawned++;
  }
}
async function hostSpawnCaterpillars(){
  if (!I_AM_HOST) return;
  const mins=minutesSinceStart(); if (mins<3) return;
  const count = 1 + (mins-3);
  let spawned=0, tries=0;
  while (spawned<count && tries<200){
    tries++;
    const x = 2 + Math.floor(Math.random()*(gridSize-4));
    const y = 2 + Math.floor(Math.random()*(gridSize-4));
    if (isBlocked(x,y)) continue;
    await addDoc(catsCol,{x,y}); spawned++;
  }
}
async function hostSpawnFireRats(){
  if (!I_AM_HOST) return;
  const mins=minutesSinceStart(); if (mins<5) return;
  // spawn every 30s; loop caller handles cadence
  const cat = gameDoc.cat || {x:gridSize-2,y:gridSize-2};
  const dx = (Math.random()<.5?-1:1) * (2+Math.floor(Math.random()*3));
  const dy = (Math.random()<.5?-1:1) * (2+Math.floor(Math.random()*3));
  const x = clamp(cat.x+dx,1,gridSize-2);
  const y = clamp(cat.y+dy,1,gridSize-2);
  if (isBlocked(x,y)) return;
  const hp = 10 + (gameDoc.catPower||0)*4;
  await addDoc(ratsCol,{x,y,hp,max:hp,type:"firerat"});
}
async function hostSpawnCrows(){
  if (!I_AM_HOST) return;
  const mins=minutesSinceStart(); if (mins<7) return;
  const cat = gameDoc.cat || {x:gridSize-2,y:gridSize-2};
  const dx = (Math.random()<.5?-1:1) * (3+Math.floor(Math.random()*4));
  const dy = (Math.random()<.5?-1:1) * (3+Math.floor(Math.random()*4));
  const x = clamp(cat.x+dx,1,gridSize-2);
  const y = clamp(cat.y+dy,1,gridSize-2);
  // crows can spawn anywhere in-bounds
  await addDoc(crowsCol,{x,y});
}

/* ---- Cat AI ---- */
async function hostCatAI(){
  if (!I_AM_HOST || !gameDoc.cat) return;
  const cat={...gameDoc.cat};
  let bestPath=null;

  const aliveM=[];
  if (me.alive) aliveM.push({x:me.x,y:me.y});
  for(const p of Object.values(players)) if (p.alive) aliveM.push({x:p.x,y:p.y});

  for(const m of aliveM){
    const p=findPath(cat.x,cat.y,m.x,m.y,false);
    if (p && (!bestPath||p.length<bestPath.length)) bestPath=p;
  }
  if (!bestPath){
    for(const o of structures.values()){
      if (["ğŸ”«","âš¡","ğŸ"].includes(o.t)){
        const p=findPath(cat.x,cat.y,o.x,o.y,false);
        if (p && (!bestPath||p.length<bestPath.length)) bestPath=p;
      }
    }
  }
  if (!bestPath){
    let min=1e9, pick=null, pth=null;
    for(const o of structures.values()){
      if (!["ğŸ§±","ğŸ”«","ğŸ","âš¡","ğŸ”Œ","ğŸ©¹","ğŸ”€","ğŸ§¨","ğŸ›¢ï¸"].includes(o.t)) continue;
      const p=findPath(cat.x,cat.y,o.x,o.y,false);
      if (p && p.length<min){ min=p.length; pick=o; pth=p; }
    }
    if (pick){ bestPath=pth; }
  }
  if (bestPath && bestPath.length>1){
    const step=bestPath[1]; cat.x=step[0]; cat.y=step[1];
  }
  // bite adjacent structure or mouse
  const adj=[[1,0],[-1,0],[0,1],[0,-1]];
  for(const [dx,dy] of adj){
    const tx=cat.x+dx, ty=cat.y+dy;
    const s=structures.get(key(tx,ty));
    if (s && ["ğŸ§±","ğŸ”«","ğŸ","âš¡","ğŸ”Œ","ğŸ©¹","ğŸ”€","ğŸ§¨","ğŸ›¢ï¸"].includes(s.t)){
      await damageStructureHost(tx,ty, catBiteDmg());
      // set wall burning if fire rat would later interact tooâ€”cat bites donâ€™t ignite
      break;
    }
    if (me.alive && me.x===tx && me.y===ty){
      me.alive=false; await updateDoc(doc(playersCol,myName),{alive:false});
      await addDoc(corpsesCol,{x:tx,y:ty}); break;
    }
    for (const [n,p] of Object.entries(players)){
      if (p.alive && p.x===tx && p.y===ty){
        await updateDoc(doc(playersCol,n),{alive:false});
        await addDoc(corpsesCol,{x:tx,y:ty}); break;
      }
    }
  }
  await updateDoc(gameRef,{cat});
}

/* ---- Turrets / Arc towers / Nodes / Repair / Mines / Oil / Routers ---- */
function nearbyPowerBonusFor(x,y){
  // % bonus from power nodes within radius (stacking)
  let count=0;
  for(const s of structures.values()){
    if (s.t==="ğŸ”Œ"){
      const d=Math.abs(s.x-x)+Math.abs(s.y-y);
      if (d<=powerBuffRadius()) count += (1+0.25*levels.power); // each node ~+25% at lvl0, scales a bit with upgrades
    }
  }
  return count*0.15; // turn stacked â€œcountâ€ into percentage chunks
}
let nearbyPowerBonus = 0; // recalculated per tower when firing

async function hostTurretsAndArc(){
  if (!I_AM_HOST) return;
  for(const o of structures.values()){
    if (!["ğŸ”«","âš¡"].includes(o.t)) continue;
    const rng = o.t==="ğŸ”«" ? 5 : 4;
    nearbyPowerBonus = nearbyPowerBonusFor(o.x,o.y);

    // find nearest enemy (cat counts as â€œhit feedback onlyâ€, no HP)
    const targets=[];
    if (gameDoc.cat){
      const d=Math.abs(gameDoc.cat.x-o.x)+Math.abs(gameDoc.cat.y-o.y);
      if (d<=rng) targets.push({type:"cat",x:gameDoc.cat.x,y:gameDoc.cat.y});
    }
    for(const [id,r] of rats){
      const d=Math.abs(r.x-o.x)+Math.abs(r.y-o.y);
      if (d<=rng) targets.push({type:"rat",id,x:r.x,y:r.y});
    }
    for(const [id,c] of caterpillars){
      const d=Math.abs(c.x-o.x)+Math.abs(c.y-o.y);
      if (d<=rng) targets.push({type:"cater",id,x:c.x,y:c.y});
    }
    for(const [id,cw] of crows){
      const d=Math.abs(cw.x-o.x)+Math.abs(cw.y-o.y);
      if (d<=rng) targets.push({type:"crow",id,x:cw.x,y:cw.y});
    }
    if (!targets.length) continue;
    targets.sort((a,b)=> (Math.abs(a.x-o.x)+Math.abs(a.y-o.y)) - (Math.abs(b.x-o.x)+Math.abs(b.y-o.y)));
    const t=targets[0];

    if (o.t==="ğŸ”«"){
      const dmg=dmgTurret();
      spawnHitParticles(t.x,t.y,6);
      if (t.type==="rat"){
        const r=rats.get(t.id); if (!r) continue;
        const hp=r.hp - dmg; if (hp<=0) await deleteDoc(doc(ratsCol,t.id)); else await updateDoc(doc(ratsCol,t.id),{hp});
      }else if (t.type==="cater"){
        // Caterpillars are one-shot impact units; optionally give them hp
        await deleteDoc(doc(catsCol,t.id));
      }else if (t.type==="crow"){
        await deleteDoc(doc(crowsCol,t.id));
      }
      // cat: visual only

    }else if (o.t==="âš¡"){
      // chain lightning
      let jumps=arcJumps();
      const dmg=dmgArc();
      let chainList=[t];
      let hitSet=new Set([t.id||`${t.type}:${t.x}:${t.y}`]);
      while(jumps>0){
        const last=chainList[chainList.length-1];
        spawnHitParticles(last.x,last.y,8,"#bde1ff");
        // apply dmg
        if (last.type==="rat"){
          const r=rats.get(last.id); if (r){ const hp=r.hp-dmg; if (hp<=0) await deleteDoc(doc(ratsCol,last.id)); else await updateDoc(doc(ratsCol,last.id),{hp}); }
        }else if (last.type==="cater"){ await deleteDoc(doc(catsCol,last.id)); }
        else if (last.type==="crow"){ await deleteDoc(doc(crowsCol,last.id)); }
        // find next target within 3
        let next=null, best=1e9;
        const pool = [];
        for(const [id,r] of rats) pool.push({type:"rat",id,x:r.x,y:r.y});
        for(const [id,c] of caterpillars) pool.push({type:"cater",id,x:c.x,y:c.y});
        for(const [id,cw] of crows) pool.push({type:"crow",id,x:cw.x,y:cw.y});
        for(const cand of pool){
          const sig=cand.id||`${cand.type}:${cand.x}:${cand.y}`;
          if (hitSet.has(sig)) continue;
          const d=Math.abs(cand.x-last.x)+Math.abs(cand.y-last.y);
          if (d<=3 && d<best){ best=d; next=cand; }
        }
        if (!next) break;
        hitSet.add(next.id||`${next.type}:${next.x}:${next.y}`);
        chainList.push(next);
        jumps--;
      }
    }
  }
}

/* ---- Hives, fleas, routers ---- */
function hiveSpawnRate(){ return Math.max(900, 1800 * (1 - 0.15*levels.hive)); }
async function hostFleaHiveTick(){
  if (!I_AM_HOST) return;
  const now=Date.now();
  for(const o of structures.values()){
    if (o.t!=="ğŸ") continue;
    if (!o._next) o._next = now + hiveSpawnRate();
    if (now < o._next) continue;
    o._next = now + hiveSpawnRate();
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dx,dy] of dirs){
      const nx=o.x+dx, ny=o.y+dy;
      if (isBlocked(nx,ny)) continue;
      let occ=false; for(const f of fleas.values()) if (f.x===nx&&f.y===ny){occ=true;break;}
      if (occ) continue;
      await addDoc(fleasCol,{x:nx,y:ny,life:25}); // ~10s via 400ms tick
      break;
    }
  }
}
function routerNearHive(rx,ry){
  // is this router within 5 of any hive?
  for(const s of structures.values()){
    if (s.t==="ğŸ"){
      const d=Math.abs(s.x-rx)+Math.abs(s.y-ry);
      if (d<=5) return true;
    }
  }
  return false;
}
async function hostFleasMove(){
  if (!I_AM_HOST) return;
  for(const [id,f] of fleas){
    // target nearest cat/rat/caterpillar/crow
    let target=null, best=1e9;
    const addCand = (x,y,tag) => { const d=Math.abs(x-f.x)+Math.abs(y-f.y); if (d<best){best=d; target={x,y,tag};} };
    if (gameDoc.cat){ addCand(gameDoc.cat.x,gameDoc.cat.y,"cat"); }
    for(const r of rats.values()) addCand(r.x,r.y,"rat");
    for(const c of caterpillars.values()) addCand(c.x,c.y,"cater");
    for(const cw of crows.values()) addCand(cw.x,cw.y,"crow");

    // router logic: if a router exists within 5 of a hive, fleas path to it first and duplicate on pass
    let routerDest=null;
    for(const s of structures.values()){
      if (s.t==="ğŸ”€" && routerNearHive(s.x,s.y)){
        const d=Math.abs(s.x-f.x)+Math.abs(s.y-f.y);
        if (d<best){ routerDest={x:s.x,y:s.y}; }
      }
    }

    let step=null;
    if (routerDest){
      const p=findPath(f.x,f.y,routerDest.x,routerDest.y,true);
      if (p && p.length>1) step=p[1];
    }
    if (!step && target){
      const dx = Math.sign(target.x - f.x), dy = Math.sign(target.y - f.y);
      step = (Math.abs(target.x-f.x)>=Math.abs(target.y-f.y)) ? {x:f.x+dx,y:f.y} : {x:f.x,y:f.y+dy};
    }
    if (step){
      // duplicate if stepping onto router tile in â€œrouter modeâ€
      const steppingRouter = structures.get(key(step.x,step.y));
      await updateDoc(doc(fleasCol,id),{x:clamp(step.x,1,gridSize-2),y:clamp(step.y,1,gridSize-2),life:f.life-1});
      if (steppingRouter && steppingRouter.t==="ğŸ”€" && routerNearHive(steppingRouter.x,steppingRouter.y)){
        // spawn clone next step toward final target if free
        if (target){
          const dx = Math.sign(target.x - step.x), dy = Math.sign(target.y - step.y);
          const nx=clamp(step.x + (Math.abs(target.x-step.x)>=Math.abs(target.y-step.y)?dx:0),1,gridSize-2);
          const ny=clamp(step.y + (Math.abs(target.x-step.x)< Math.abs(target.y-step.y)?dy:0),1,gridSize-2);
          await addDoc(fleasCol,{x:nx,y:ny,life:Math.max(10,f.life-3)});
        }
      }
      // damage if collide
      if (gameDoc.cat && step.x===gameDoc.cat.x && step.y===gameDoc.cat.y){
        spawnHitParticles(step.x,step.y,5,"#7cf");
        me.score+=1; await updateDoc(doc(playersCol,myName),{score:me.score});
      }
      for(const [rid,r] of rats){
        if (r.x===step.x && r.y===step.y){
          const nh=(r.hp||0)-5; spawnHitParticles(step.x,step.y,5);
          if (nh<=0) await deleteDoc(doc(ratsCol,rid)); else await updateDoc(doc(ratsCol,rid),{hp:nh});
        }
      }
      for(const [cid,c] of caterpillars){
        if (c.x===step.x && c.y===step.y){ spawnHitParticles(step.x,step.y,5); await deleteDoc(doc(catsCol,cid)); }
      }
      for(const [crid,cw] of crows){
        if (cw.x===step.x && cw.y===step.y){ spawnHitParticles(step.x,step.y,5); await deleteDoc(doc(crowsCol,crid)); }
      }
    }else{
      await updateDoc(doc(fleasCol,id),{life:f.life-1});
    }
    if (f.life-1<=0){ await deleteDoc(doc(fleasCol,id)); }
  }
}

/* ---- Enemy brains ---- */
async function hostRatsThink(){
  if (!I_AM_HOST) return;
  for(const [id,r] of rats){
    // oil slow?
    let slowed=false;
    const os=structures.get(key(r.x,r.y));
    if (os && os.t==="ğŸ›¢ï¸") slowed=true;
    if (slowed && Math.random() < oilSlowPct()) continue; // skip move this tick

    // target nearest mouse or structure
    let targets=[];
    if (me.alive) targets.push({x:me.x,y:me.y,type:"mouse",name:myName});
    for (const [n,p] of Object.entries(players)) if (p.alive) targets.push({x:p.x,y:p.y,type:"mouse",name:n});
    for(const s of structures.values()) if (["ğŸ§±","ğŸ”«","ğŸ","âš¡","ğŸ”Œ","ğŸ©¹","ğŸ”€","ğŸ§¨","ğŸ›¢ï¸"].includes(s.t))
      targets.push({x:s.x,y:s.y,type:"struct"});

    if (!targets.length) continue;
    targets.sort((a,b)=> (Math.abs(a.x-r.x)+Math.abs(a.y-r.y)) - (Math.abs(b.x-r.x)+Math.abs(b.y-r.y)));
    const t = targets[0];
    const p = findPath(r.x,r.y,t.x,t.y,false);
    if (p && p.length>1){
      const step=p[1];
      await updateDoc(doc(ratsCol,id),{x:step[0],y:step[1]});
      // spike mines trigger
      const ms=structures.get(key(step[0],step[1]));
      if (ms && ms.t==="ğŸ§¨"){
        const dmg=spikeDamage(); spawnHitParticles(step[0],step[1],8);
        const hp=r.hp-dmg;
        await deleteDoc(doc(structsCol,key(step[0],step[1]))); // mine consumed
        if (hp<=0) await deleteDoc(doc(ratsCol,id)); else await updateDoc(doc(ratsCol,id),{hp});
      }
    }else if (t.type==="struct" && (r.x===t.x && r.y===t.y)){
      // chew structure
      await damageStructureHost(r.x,r.y, 1 + Math.floor((gameDoc.catPower||0)/3));
    }
    // attack mouse
    if (t.type==="mouse" && r.x===t.x && r.y===t.y){
      if (t.name===myName && me.alive){ me.alive=false; await updateDoc(doc(playersCol,myName),{alive:false}); await addDoc(corpsesCol,{x:r.x,y:r.y}); }
      else await updateDoc(doc(playersCol,t.name),{alive:false});
    }

    // FIRE RAT effect: ignite walls it touches; spread 50%
    if (r.type==="firerat"){
      const s=structures.get(key(r.x,r.y));
      if (s && s.t==="ğŸ§±"){
        const idk=key(r.x,r.y);
        await updateDoc(doc(structsCol,idk),{burn:true});
      }
    }
  }
}
async function hostCaterpillarsThink(){
  if (!I_AM_HOST) return;
  for(const [id,c] of caterpillars){
    // seek walls then turrets
    let pick=null,best=1e9;
    for(const s of structures.values()){
      if (!["ğŸ§±","ğŸ”«","âš¡"].includes(s.t)) continue;
      const d=Math.abs(s.x-c.x)+Math.abs(s.y-c.y);
      if (d<best){best=d; pick=s;}
    }
    if (!pick) continue;
    const p=findPath(c.x,c.y,pick.x,pick.y,true);
    if (p && p.length>1){
      const step=p[1]; await updateDoc(doc(catsCol,id),{x:step[0],y:step[1]});
    }
    if (c.x===pick.x && c.y===pick.y){
      spawnHitParticles(c.x,c.y,8);
      await damageStructureHost(c.x,c.y,20);
      await deleteDoc(doc(catsCol,id));
    }
  }
}
async function hostCrowsThink(){
  if (!I_AM_HOST) return;
  for(const [id,cw] of crows){
    // fly at nearest mouse or tower; ignores blocks
    let targets=[];
    if (me.alive) targets.push({x:me.x,y:me.y,type:"mouse"});
    for (const [,p] of Object.entries(players)) if (p.alive) targets.push({x:p.x,y:p.y,type:"mouse"});
    for(const s of structures.values()) if (["ğŸ”«","âš¡","ğŸ"].includes(s.t)) targets.push({x:s.x,y:s.y,type:"struct"});
    if (!targets.length) continue;
    targets.sort((a,b)=> (Math.abs(a.x-cw.x)+Math.abs(a.y-cw.y)) - (Math.abs(b.x-cw.x)+Math.abs(b.y-cw.y)));
    const t=targets[0];
    const p=findPath(cw.x,cw.y,t.x,t.y,true,true);
    if (p && p.length>1){
      const step=p[1];
      // slow flight: move only every other tick
      if (Math.random()<0.5) await updateDoc(doc(crowsCol,id),{x:step[0],y:step[1]});
    }else{
      if (t.type==="struct" && cw.x===t.x && cw.y===t.y){
        spawnHitParticles(cw.x,cw.y,6);
        await damageStructureHost(cw.x,cw.y,2);
      }
    }
  }
}

/* ---- Environmental effects: burn on walls, repairers ---- */
async function hostWallBurnTick(){
  if (!I_AM_HOST) return;
  // apply burn DoT & 50% spread chance to adjacent walls (only from fire rat ignitions)
  const toUpdate=[];
  for(const s of structures.values()){
    if (s.t==="ğŸ§±" && s.burn){
      toUpdate.push(s);
    }
  }
  for(const w of toUpdate){
    await damageStructureHost(w.x,w.y,3); // burn DoT
    // 50% spread to adjacent walls
    if (Math.random()<0.5){
      const adj=[[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of adj){
        const nb=structures.get(key(w.x+dx,w.y+dy));
        if (nb && nb.t==="ğŸ§±" && !nb.burn){
          await updateDoc(doc(structsCol,key(nb.x,nb.y)),{burn:true});
        }
      }
    }
  }
}
async function hostRepairTick(){
  if (!I_AM_HOST) return;
  // for each repair node, heal neighbors; sum heal per structure capped by catBiteDmg()
  const heals = new Map(); // "x_y" -> totalHeal
  for(const s of structures.values()){
    if (s.t!=="ğŸ©¹") continue;
    const per = repairPerTickBase() * (1 + 0.2*levels.repair);
    for (const o of structures.values()){
      if (!["ğŸ§±","ğŸ”«","ğŸ","âš¡","ğŸ”Œ","ğŸ©¹","ğŸ”€","ğŸ§¨","ğŸ›¢ï¸"].includes(o.t)) continue;
      const d=Math.abs(o.x-s.x)+Math.abs(o.y-s.y);
      if (d<=repairRadius()){
        const k=key(o.x,o.y);
        heals.set(k,(heals.get(k)||0)+per);
      }
    }
  }
  const cap = catBiteDmg();
  for(const [k,amt] of heals){
    const s=structures.get(k); if (!s) continue;
    const healed = Math.min(amt, cap);
    const nh = Math.min(s.max||s.hp||9999, (s.hp||0)+Math.floor(healed));
    await updateDoc(doc(structsCol,k),{hp:nh});
  }
}

/* ------------------------------ Player control --------------------------- */
async function tryMove(dx,dy){
  if (!me.alive) return;
  if (Date.now()-lastMoveAt<moveDelay) return;
  const nx=clamp(me.x+dx,1,gridSize-2), ny=clamp(me.y+dy,1,gridSize-2);
  if (!inBounds(nx,ny)) return;
  // mice can walk over structures
  me.x=nx; me.y=ny; lastMoveAt=Date.now(); await upsertMe();

  // pickups
  const s=structures.get(key(nx,ny));
  if (s){
    // item pickups
    const take=(icon,count,label)=>{ heldType=icon; heldCount=count; toast(`Held ${icon} x${count}`); };
    if (s.t==="â­•ğŸ§±"){ take("ğŸ§±",20); await deleteDoc(doc(structsCol,key(nx,ny))); }
    if (s.t==="â­•ğŸ”«"){ take("ğŸ”«",3);  await deleteDoc(doc(structsCol,key(nx,ny))); }
    if (s.t==="â­•ğŸ"){ take("ğŸ",2);  await deleteDoc(doc(structsCol,key(nx,ny))); }
    if (s.t==="â­•ğŸ§¨"){ take("ğŸ§¨",4);  await deleteDoc(doc(structsCol,key(nx,ny))); }
    if (s.t==="â­•ğŸ›¢ï¸"){ take("ğŸ›¢ï¸",6);  await deleteDoc(doc(structsCol,key(nx,ny))); }
    if (s.t==="â­•âš¡"){  take("âš¡",2);  await deleteDoc(doc(structsCol,key(nx,ny))); }
    if (s.t==="â­•ğŸ”Œ"){  take("ğŸ”Œ",2);  await deleteDoc(doc(structsCol,key(nx,ny))); }
    if (s.t==="â­•ğŸ©¹"){  take("ğŸ©¹",2);  await deleteDoc(doc(structsCol,key(nx,ny))); }
    if (s.t==="â­•ğŸ”€"){  take("ğŸ”€",2);  await deleteDoc(doc(structsCol,key(nx,ny))); }

    // powerups (upgrades)
    const inc = (k,msg)=>{ levels[k]++; toast(msg); };
    if (s.t==="ğŸ”ºğŸ§±"){ inc("wall","ğŸ§± +15% HP"); await deleteDoc(doc(structsCol,key(nx,ny))); }
    if (s.t==="ğŸ”ºğŸ”«"){ inc("turret","ğŸ”« +HP/+DMG"); await deleteDoc(doc(structsCol,key(nx,ny))); }
    if (s.t==="ğŸ”ºğŸ"){ inc("hive","ğŸ +rate/+HP"); await deleteDoc(doc(structsCol,key(nx,ny))); }
    if (s.t==="ğŸ”ºğŸ§¨"){ inc("spike","ğŸ§¨ +DMG/+HP"); await deleteDoc(doc(structsCol,key(nx,ny))); }
    if (s.t==="ğŸ”ºğŸ›¢ï¸"){ inc("oil","ğŸ›¢ï¸ +SLOW/+HP"); await deleteDoc(doc(structsCol,key(nx,ny))); }
    if (s.t==="ğŸ”ºâš¡"){  inc("arc","âš¡ +DMG / +jumps"); await deleteDoc(doc(structsCol,key(nx,ny))); }
    if (s.t==="ğŸ”ºğŸ”Œ"){  inc("power","ğŸ”Œ +buff power"); await deleteDoc(doc(structsCol,key(nx,ny))); }
    if (s.t==="ğŸ”ºğŸ©¹"){  inc("repair","ğŸ©¹ +healing"); await deleteDoc(doc(structsCol,key(nx,ny))); }
    if (s.t==="ğŸ”ºğŸ”€"){  inc("router","ğŸ”€ +efficiency"); await deleteDoc(doc(structsCol,key(nx,ny))); }
    setHeldUI();
  }

  // revive
  if (corpses.has(key(nx,ny))){
    const qs = await getDocs(query(corpsesCol, where("x","==",nx), where("y","==",ny)));
    qs.forEach(async d=> await deleteDoc(d.ref));
    const dead = [myName, ...Object.entries(players).filter(([,p])=>!p.alive).map(([n])=>n)]
                  .filter((v,i,a)=>a.indexOf(v)===i);
    if (dead.length){
      const n = dead[0];
      await updateDoc(doc(playersCol,n),{alive:true,x:nx,y:ny});
      me.score += 100; await updateDoc(doc(playersCol,myName),{score:me.score});
      toast("ğŸ©¹ Revived +100");
    }
  }

  render();
}
async function tryBuild(dx,dy){
  if (!me.alive) return;
  if (Date.now()-lastBuildAt<buildDelay) return;
  if (!heldType || heldCount<=0) { toast("No held item"); return; }
  const tx=clamp(me.x+dx,1,gridSize-2), ty=clamp(me.y+dy,1,gridSize-2);
  if (!inBounds(tx,ty)) return;
  if (tileOccupied(tx,ty)) return;

  let hp=10, extra={};
  if (heldType==="ğŸ§±"){ hp=hpWall(); }
  if (heldType==="ğŸ”«"){ hp=hpTur(); }
  if (heldType==="ğŸ"){ hp=hpHive(); }
  if (heldType==="ğŸ§¨"){ hp=hpSpike(); }    // mine
  if (heldType==="ğŸ›¢ï¸"){ hp=hpOil(); }     // oil tile
  if (heldType==="âš¡"){  hp=hpArc(); }
  if (heldType==="ğŸ”Œ"){  hp=hpPower(); }
  if (heldType==="ğŸ©¹"){  hp=hpRepair(); }
  if (heldType==="ğŸ”€"){  hp=hpRouter(); }

  await placeStructureHost(tx,ty,heldType,hp,extra);
  heldCount--; lastBuildAt=Date.now(); setHeldUI(); render();
}

/* ------------------------------- Timers/loops ---------------------------- */
// scoring trickle
setInterval(async ()=>{ if (!me.alive) return; me.score += 10; await updateDoc(doc(playersCol,myName),{score:me.score}); }, 20000);

// difficulty scaler (cat power)
setInterval(async ()=>{ if (!I_AM_HOST) return; const cp=(gameDoc.catPower||0)+1; await updateDoc(gameRef,{catPower:cp}); }, 60000);

// waves & unlock-based spawns
setInterval(async ()=>{ if (I_AM_HOST) await hostSpawnRatWave(); }, 12000);
setInterval(async ()=>{ if (I_AM_HOST) await hostSpawnCaterpillars(); }, 15000);
setInterval(async ()=>{ if (I_AM_HOST) await hostSpawnFireRats(); }, 30000);
setInterval(async ()=>{ if (I_AM_HOST) await hostSpawnCrows(); }, 30000);

// brains
setInterval(hostCatAI, 500);
setInterval(hostRatsThink, 450);
setInterval(hostCaterpillarsThink, 600);
setInterval(hostCrowsThink, 700);

// towers & support
setInterval(hostTurretsAndArc, 1000);
setInterval(hostFleaHiveTick, 1000);
setInterval(hostFleasMove, 400);
setInterval(async ()=>{ if (I_AM_HOST) await hostSpawnPickups(); }, 18000);
setInterval(hostWallBurnTick, 900);
setInterval(hostRepairTick, 1000);

// game over detect
setInterval(async ()=>{ if (!I_AM_HOST) return; if (!anyMouseAlive()){ await saveHighscoreIfNeeded(); toast("ğŸ’€ All mice dead â€” Game Over"); } }, 3000);

/* --------------------------------- Joysticks ----------------------------- */
function setupJoystick(el, onDir){
  const knob = el.querySelector('.knob');
  const rect = ()=> el.getBoundingClientRect();
  let active=false, cx=0, cy=0, maxR=50;
  const setKnob=(dx,dy)=>{ const r=Math.hypot(dx,dy), sc=r>maxR?maxR/r:1;
    knob.style.left=`calc(50% + ${(dx*sc)}px)`; knob.style.top=`calc(50% + ${(dy*sc)}px)`; };
  const dirFrom=(dx,dy)=>{ if (Math.hypot(dx,dy)<16) return {dx:0,dy:0};
    if (Math.abs(dx)>Math.abs(dy)) return {dx:Math.sign(dx),dy:0}; else return {dx:0,dy:Math.sign(dy)}; };
  const end=()=>{ active=false; setKnob(0,0); onDir({dx:0,dy:0}); };
  el.addEventListener('touchstart',e=>{ e.preventDefault(); active=true; const b=rect(); cx=b.left+b.width/2; cy=b.top+b.height/2; },{passive:false});
  el.addEventListener('touchmove',e=>{ if (!active) return; const t=e.touches[0]; const dx=t.clientX-cx, dy=t.clientY-cy; setKnob(dx,dy); onDir(dirFrom(dx,dy)); },{passive:false});
  el.addEventListener('touchend',e=>{ end(); },{passive:false});
  el.addEventListener('touchcancel',e=>{ end(); },{passive:false});
}
// repeaters
setInterval(()=>{ if (!me.alive) return; if (moveIntent.dx||moveIntent.dy) tryMove(moveIntent.dx,moveIntent.dy); }, 30);
setInterval(()=>{ if (!me.alive) return; if (buildIntent.dx||buildIntent.dy) tryBuild(buildIntent.dx,buildIntent.dy); }, 30);
setupJoystick(document.getElementById('moveJoy'), d=>{ moveIntent=d; });
setupJoystick(document.getElementById('buildJoy'), d=>{ buildIntent=d; });

// Keyboard fallback (desktop)
window.addEventListener("keydown",e=>{
  if (e.key==="ArrowUp")  moveIntent={dx:0,dy:-1};
  if (e.key==="ArrowDown")moveIntent={dx:0,dy:1};
  if (e.key==="ArrowLeft")moveIntent={dx:-1,dy:0};
  if (e.key==="ArrowRight")moveIntent={dx:1,dy:0};
  if (e.key==="w") buildIntent={dx:0,dy:-1};
  if (e.key==="s") buildIntent={dx:0,dy:1};
  if (e.key==="a") buildIntent={dx:-1,dy:0};
  if (e.key==="d") buildIntent={dx:1,dy:0};
});
window.addEventListener("keyup",e=>{
  if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)) moveIntent={dx:0,dy:0};
  if (["w","a","s","d"].includes(e.key)) buildIntent={dx:0,dy:0};
});

// Fullscreen
document.getElementById("fsBtn").onclick=()=>{ const el=document.documentElement; if (document.fullscreenElement) document.exitFullscreen(); else el.requestFullscreen?.(); };

/* --------------------------------- Boot ---------------------------------- */
(async function init(){
  me.x = 2 + Math.floor(Math.random()*6);
  me.y = 2 + Math.floor(Math.random()*6);
  await upsertMe();
  // mark start time if missing
  const g=await getDoc(gameRef);
  if (!g.exists() || !g.data()?.startMs){ await setDoc(gameRef,{startMs:Date.now()},{merge:true}); }
  await claimHost();
  listen();
  if (I_AM_HOST) await hostSpawnPickups();
  setHeldUI();
  setHostBadge();
  render();
})();
</script>
</body>
</html>



