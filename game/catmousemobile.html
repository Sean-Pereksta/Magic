<!DOCTYPE html> 
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
<title>üê≠ Cat vs Mouse ‚Äî Survival (Walls ¬∑ Turrets ¬∑ Bombs ¬∑ Factories)</title>
<style>
  :root{
    --bg:#0b1014; --ink:#e6efff; --muted:#9fb3c8; --panel:#0f172a; --line:#1f2a44;
    --good:#22c55e; --warn:#eab308; --bad:#ef4444; --accent:#60a5fa;
    --grass:#2f7d32; --edge:#58606b; --cell:28px; --view:17;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Arial,sans-serif}

  #hud{position:fixed;top:0;left:0;right:0;display:flex;gap:8px;align-items:center;justify-content:space-between;
       padding:8px 12px;background:linear-gradient(180deg,rgba(10,16,26,.85),rgba(10,16,26,.35));backdrop-filter:blur(6px);z-index:10}
  .chip{display:inline-flex;gap:8px;align-items:center;background:#0e1726;border:1px solid #1f2a44;border-radius:999px;padding:6px 10px}
  .pill{padding:2px 8px;border-radius:999px;border:1px solid #2a3a60;background:#121c30;color:#9fb3d0}
  a.btn{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:10px;border:1px solid #2a3a60;background:#0f1a2e;color:#cfe6ff;text-decoration:none}

  /* Cooldowns HUD (top-right) */
  #coolwrap{position:fixed; top:56px; right:10px; z-index:11; display:flex; flex-direction:column; gap:6px;}
  .cool{display:flex; align-items:center; gap:6px; background:#0e1726; border:1px solid #203054; padding:4px 8px; border-radius:10px; min-width:180px; justify-content:space-between}
  .cool b{font-weight:600}
  .cool .eta{font-variant-numeric:tabular-nums; color:#a8c3ff}

  /* Upgrades panel */
  #upgradePanel{
    position:fixed;
    top:56px;
    left:10px;
    z-index:11;
    background:#020617;
    border:1px solid #1f2937;
    border-radius:12px;
    box-shadow:0 10px 30px rgba(0,0,0,.6);
    font-size:12px;
    min-width:200px;
    overflow:hidden;
  }
  #upgradeHeader{
    padding:6px 10px;
    cursor:pointer;
    display:flex;
    align-items:center;
    justify-content:space-between;
    background:#0b1120;
    color:#e5e7eb;
  }
  #upgradeHeader span.label{
    display:flex;
    align-items:center;
    gap:6px;
  }
  #upgradeHeader small{
    color:#9ca3af;
  }
  #upgradePanel.collapsed #upgradeBody{display:none;}
  #upgradeBody{
    padding:6px 8px;
    display:flex;
    flex-direction:column;
    gap:6px;
    max-height:260px;
    overflow:auto;
  }
  .upRow{
    display:flex;
    flex-direction:column;
    gap:3px;
    padding:4px 6px;
    border-radius:8px;
    background:#020617;
    border:1px solid #1e293b;
  }
  .upRowTop{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:4px;
  }
  .upRowTop .title{
    display:flex;
    align-items:center;
    gap:6px;
  }
  .upRowTop .meta{
    font-size:11px;
    color:#9ca3af;
  }
  .upBtn{
    padding:2px 8px;
    border-radius:999px;
    border:1px solid #4b5563;
    background:#111827;
    font-size:11px;
    cursor:default;
    color:#9ca3af;
    white-space:nowrap;
  }
  .upBtn.ready{
    background:#16a34a;
    border-color:#16a34a;
    color:#f9fafb;
    cursor:pointer;
  }
  .upBarOuter{
    height:5px;
    border-radius:999px;
    background:#111827;
    overflow:hidden;
    margin-top:2px;
  }
  .upBarInner{
    height:100%;
    width:0%;
    background:linear-gradient(90deg,#4b5563,#9ca3af);
    transition:width .2s;
  }

  #main{padding-top:56px;display:flex;flex-direction:column;align-items:center;gap:10px}
  #stage{width:calc(var(--cell)*var(--view));height:calc(var(--cell)*var(--view));
         border:2px solid var(--line);border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.35);
         position:relative;overflow:hidden;background:repeating-linear-gradient(90deg,#2e6d31 0,#2e6d31 10px,#2a6a2d 10px,#2a6a2d 20px)}
  #grid{display:grid;grid-template-columns:repeat(var(--view),var(--cell));grid-template-rows:repeat(var(--view),var(--cell));}
  .cell{width:var(--cell);height:var(--cell);position:relative;display:flex;align-items:center;justify-content:center;user-select:none}
  .edge{background:#6d747f}
  .grass{background:linear-gradient(135deg,#2f7d32,#275e28)}
  .emj{position:relative; z-index:2; font-size:20px; line-height:1}
  .hpbar{position:absolute; left:2px; right:2px; top:2px; height:5px; background:#263040; border-radius:4px; overflow:hidden; z-index:3; pointer-events:none}
  .hpbar>i{display:block;height:100%;background:#ff5252}
  .float{position:absolute;pointer-events:none;font-weight:700;animation:rise .8s ease-out forwards; z-index:4}
  @keyframes rise{0%{opacity:1;transform:translateY(0)}100%{opacity:0;transform:translateY(-16px)}}

  .blast{position:absolute;width:10px;height:10px;border-radius:50%;
    background:radial-gradient(circle, rgba(255,240,180,1) 0%, rgba(255,120,40,0.9) 40%, rgba(255,60,0,0.6) 60%, rgba(0,0,0,0) 70%);
    transform:translate(-50%,-50%) scale(1); opacity:0.95; z-index:6; animation:boom .28s ease-out forwards;}
  @keyframes boom{0%{transform:translate(-50%,-50%) scale(.6);opacity:.95}100%{transform:translate(-50%,-50%) scale(2.2);opacity:0}}
  .shock{position:absolute;width:12px;height:12px;border-radius:50%;border:2px solid rgba(255,220,160,.95);
    transform:translate(-50%,-50%) scale(.5);box-shadow:0 0 12px rgba(255,200,120,.8);opacity:1;z-index:6;animation:ring .36s ease-out forwards;}
  @keyframes ring{0%{transform:translate(-50%,-50%) scale(.5);opacity:1}100%{transform:translate(-50%,-50%) scale(3);opacity:0}}
  .freezeOverlay{position:absolute;inset:0; background:rgba(150,220,255,.25); z-index:1; animation:tileBlink .25s ease-out forwards;}
  @keyframes tileBlink{0%{opacity:.35}100%{opacity:0}}

  /* Turret laser */
  .laser{
    position:absolute;
    height:3px;
    border-radius:999px;
    background:linear-gradient(90deg,rgba(148,163,184,.1),rgba(251,191,36,1));
    transform-origin:0 50%;
    opacity:.95;
    z-index:5;
    animation:laser .18s ease-out forwards;
  }
  @keyframes laser{0%{opacity:.95}100%{opacity:0}}

  #pads{width:100%;max-width:860px;display:flex;justify-content:space-between;gap:12px;padding:8px 12px 70px}
  .joyWrap{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center}
  .joy{width:140px;height:140px;border-radius:50%;background:radial-gradient(120px at 50% 50%, #0e1726, #0c1422);
       border:1px solid #223154; position:relative; touch-action:none; box-shadow:0 8px 24px rgba(0,0,0,.35);}
  .joy .knob{position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:78px; height:78px; border-radius:50%;
       background:#13233e; border:1px solid #2a3a60; box-shadow:inset 0 0 0 2px #0b1628;}
  .joy .hint{position:absolute; left:50%; top:50%; width:4px; height:4px; border-radius:50%; background:#3b5ea8; opacity:.7}
  .joyLabel{margin-top:6px; color:#a8c3ff; font-size:13px; text-align:center}

  #toast{position:fixed;bottom:72px;left:50%;transform:translateX(-50%);background:#0e1726;border:1px solid #1f2a44;
         padding:10px 14px;border-radius:10px;box-shadow:0 10px 24px rgba(0,0,0,.35);display:none;z-index:15}

  #powerBar{position:fixed;left:0;right:0;bottom:0;display:flex;gap:8px;align-items:center;justify-content:center;
    padding:8px 10px;background:linear-gradient(0deg,rgba(10,16,26,.9),rgba(10,16,26,.3)); backdrop-filter:blur(6px); z-index:12;}
  #powerBar .opt{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border:1px solid #2a3a60;border-radius:12px;background:#0f1a2e;cursor:pointer}
  #powerBar .opt:hover{background:#13233e}

  /* Unlock overlay */
  #metaOverlay{
    position:fixed; inset:0;
    display:flex; align-items:center; justify-content:center;
    background:radial-gradient(circle at center,rgba(15,23,42,.96),rgba(15,23,42,.98));
    z-index:20;
    opacity:0;
    pointer-events:none;
    transition:opacity .5s ease-out;
  }
  #metaOverlay.show{opacity:1;pointer-events:auto;}
  #metaOverlay.fade{opacity:0;pointer-events:none;}
  .metaBox{
    background:#020617;
    border:1px solid #1e293b;
    border-radius:16px;
    padding:16px 20px;
    min-width:280px;
    max-width:420px;
    box-shadow:0 20px 40px rgba(0,0,0,.6);
  }
  .metaBox h2{margin:0 0 4px;font-size:18px;}
  .metaBox p{margin:0 0 10px;color:var(--muted);font-size:13px;}
  .metaList{display:flex;flex-direction:column;gap:6px;margin-top:6px;}
  .metaNode{
    display:flex;justify-content:space-between;align-items:center;
    padding:6px 8px;border-radius:10px;border:1px solid #1f2937;font-size:13px;
  }
  .metaNode.active{border-color:#22c55e;background:rgba(34,197,94,.08);}
  .metaNode.locked{opacity:.45;}
  .metaNode span.label{display:flex;align-items:center;gap:6px;}

  /* Summary modal */
  #summaryModal{
    position:fixed; inset:0;
    display:none;
    align-items:center; justify-content:center;
    background:rgba(15,23,42,.9);
    z-index:25;
  }
  #summaryModal .box{
    background:#020617;
    border:1px solid #1f2937;
    border-radius:16px;
    padding:18px 22px;
    min-width:280px;
    max-width:420px;
    box-shadow:0 24px 40px rgba(0,0,0,.7);
  }
  #summaryModal h2{margin:0 0 6px;font-size:20px;}
  #summaryModal p{margin:2px 0;color:var(--muted);font-size:13px;}
  #summaryModal .stats{margin-top:10px;margin-bottom:10px;}
  #summaryModal .stats div{display:flex;justify-content:space-between;margin:2px 0;font-size:14px;}
  #summaryModal button{
    margin-top:10px;
    padding:6px 10px;
    border-radius:10px;
    border:1px solid #334155;
    background:#0f172a;
    color:#e5e7eb;
    cursor:pointer;
  }
</style>
</head>
<body>

<!-- HUD -->
<div id="hud">
  <a class="btn" id="fsBtn">‚õ∂ Full Screen</a>
  <div class="chip">
    <span id="hostBadge" class="pill">Host?</span>
    <span>üë• <b id="aliveCount">0</b></span>
    <span>‚≠ê <b id="score">0</b></span>
    <span>üí∞ <b id="gold">0</b></span>
  </div>
  <div id="held" class="chip">
    <span>Held:</span><span id="heldIcon" style="min-width:28px;text-align:center">‚Äî</span>
    <span id="heldCount" class="pill">0</span>
  </div>
</div>

<!-- Upgrades dropdown -->
<div id="upgradePanel" class="collapsed">
  <div id="upgradeHeader">
    <span class="label">‚¨á Upgrades</span>
    <small>Spend gold from factories</small>
  </div>
  <div id="upgradeBody"></div>
</div>

<!-- Cooldown HUD -->
<div id="coolwrap"></div>

<div id="main">
  <div id="stage"><div id="grid"></div></div>
  <div id="pads">
    <div class="joyWrap">
      <div id="moveJoy" class="joy">
        <div class="hint" style="transform:translate(-50%,-50%) translate(0,-48px)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(48px,0)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(0,48px)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(-48px,0)"></div>
        <div class="knob"></div>
      </div>
      <div class="joyLabel">Move</div>
    </div>
    <div class="joyWrap">
      <div id="buildJoy" class="joy">
        <div class="hint" style="transform:translate(-50%,-50%) translate(0,-48px)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(48px,0)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(0,48px)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(-48px,0)"></div>
        <div class="knob"></div>
      </div>
      <div class="joyLabel">Build (uses held)</div>
    </div>
  </div>
</div>

<div id="powerBar" style="display:none"></div>
<div id="toast"></div>

<!-- Unlock overlay -->
<div id="metaOverlay">
  <div class="metaBox">
    <h2>Unlocks This Run</h2>
    <p id="metaSubtitle">Loading progression‚Ä¶</p>
    <div id="metaList" class="metaList"></div>
  </div>
</div>

<!-- Run summary -->
<div id="summaryModal">
  <div class="box">
    <h2>Run Summary</h2>
    <p id="summarySubtitle"></p>
    <div class="stats" id="summaryStats"></div>
    <button id="summaryClose">Play Again</button>
  </div>
</div>

<script type="module">
/* ----------------------------- Firebase setup ----------------------------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection,
  addDoc, deleteDoc, serverTimestamp, getDocs, query, where, increment
} from "https://www.gstatic.com/firebasejs/10.11.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
};
const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);

/* ------------------------------- Parameters ------------------------------- */
const url = new URLSearchParams(location.search);
const gameId = url.get("gameId") || "sandbox";
const myName = (url.get("username")||"Player").trim().toLowerCase();

/* --------------------------------- State --------------------------------- */
const gridSize = 40;
const view = 17;
const gridEl = document.getElementById("grid");
const stageEl = document.getElementById("stage");
const coolwrap = document.getElementById("coolwrap");
const cellPx = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'))||28;
let camera = {x:0,y:0};

let I_AM_HOST = false;
let gameDoc = {};
let players = {};
let structures = new Map(); // "x_y" -> {x,y,t,hp,max,expAt?,owner?}
let rats = new Map();
let bears = new Map();
let caterpillars = new Map();
let crows = new Map();
let corpses = new Map();
let fleas = new Map();
let beetles = new Map();
let golems = new Map();     // NEW: siege enemies

let me = {x:2,y:2,alive:true,score:0,gold:0,powers:{}};

// held item
let heldType = null;   // "üß±","üî´","üí£","üè≠"
let heldCount = 0;

// upgrades (manual, via gold)
let levels = { wall:0, turret:0, range:0, speed:0 };

// power global passives (team-wide scaling)
let globalStoneLevel=0, globalLightningLevel=0, globalFireLevel=0, globalIceLevel=0, globalFleasLevel=0, globalBeetlesLevel=0;

// meta progression
const metaRef = doc(db,"games",gameId,"meta","global");
let meta = { totalRuns:0, bestScore:0 };

// input
let baseMoveDelay=120, buildDelay=120;
let lastMoveAt=0, lastBuildAt=0;
let moveIntent={dx:0,dy:0}, buildIntent={dx:0,dy:0};

// summary flag
let summaryShown=false;
let gameOverTriggered=false;

/* ------------------------------- Helpers --------------------------------- */
const $ = sel => document.querySelector(sel);
function key(x,y){ return `${x}_${y}`; }
function clamp(v,min,max){ return v<min?min:v>max?max:v; }
function inBounds(x,y){ return x>0 && y>0 && x<gridSize-1 && y<gridSize-1; }
function toast(msg,ms=1200){ const el=$("#toast"); el.textContent=msg; el.style.display='block'; setTimeout(()=>el.style.display='none',ms); }
function setHostBadge(){ $("#hostBadge").textContent = I_AM_HOST? "üëë Host" : "Client"; }
function setHeldUI(){ $("#heldIcon").textContent = heldType || "‚Äî"; $("#heldCount").textContent = heldCount || 0; }
function focusCamera(){ camera.x = clamp(me.x - Math.floor(view/2), 0, gridSize - view);
                        camera.y = clamp(me.y - Math.floor(view/2), 0, gridSize - view); }
function floatText(x,y,txt,color="#fff"){
  const el = document.createElement('div');
  el.className='float';
  el.style.left = (x - camera.x)*cellPx + 'px';
  el.style.top  = (y - camera.y)*cellPx + 'px';
  el.style.color = color;
  el.textContent = txt;
  stageEl.appendChild(el);
  setTimeout(()=>el.remove(),900);
}
function minutesSinceStart(){ return Math.floor((Date.now() - (gameDoc.startMs||Date.now()))/60000); }

function formatDuration(ms){
  const totalSec = Math.floor(ms/1000);
  const min = Math.floor(totalSec/60);
  const sec = totalSec%60;
  return `${min}m ${sec.toString().padStart(2,'0')}s`;
}

/* Gold + upgrades UI helpers */
function updateGoldUI(){
  const el=document.getElementById("gold");
  if (el) el.textContent = me.gold || 0;
}

/* Upgrade config */
const UPG_CFG = {
  wall:  { key:"wall",   icon:"üß±", label:"Wall Armor",     baseCost:40 },
  turret:{ key:"turret", icon:"üî´", label:"Turret Power",   baseCost:60 },
  range: { key:"range",  icon:"üì°", label:"Turret Range",   baseCost:50 },
  speed: { key:"speed",  icon:"üèÉ", label:"Mouse Speed",    baseCost:50 },
};
function getUpgradeCost(k){
  const cfg = UPG_CFG[k];
  const base = cfg.baseCost;
  const lvl = levels[k] || 0;
  return Math.round(base * Math.pow(1.4, lvl)); // grows each purchase
}
function buyUpgrade(k){
  const cost = getUpgradeCost(k);
  if ((me.gold||0) < cost) return;
  me.gold -= cost;
  levels[k] = (levels[k]||0) + 1;
  updateGoldUI();
  renderUpgradesUI();
  safeUpdate(doc(playersCol,myName), { gold: me.gold });
  toast(`${UPG_CFG[k].label} Lv${levels[k]}`);
}
function renderUpgradesUI(){
  const body = document.getElementById("upgradeBody");
  if (!body) return;
  body.innerHTML="";
  Object.values(UPG_CFG).forEach(cfg=>{
    const lvl = levels[cfg.key] || 0;
    const cost = getUpgradeCost(cfg.key);
    const row=document.createElement("div");
    row.className="upRow";

    const top=document.createElement("div");
    top.className="upRowTop";

    const title=document.createElement("div");
    title.className="title";
    title.innerHTML = `<span>${cfg.icon}</span><span>${cfg.label}</span>`;

    const meta=document.createElement("div");
    meta.className="meta";
    meta.textContent = `Lv ${lvl} ¬∑ ${cost}g`;

    const btn=document.createElement("button");
    btn.className="upBtn";
    const can = (me.gold||0) >= cost;
    if (can){
      btn.classList.add("ready");
      btn.textContent="Upgrade";
      btn.onclick=()=>buyUpgrade(cfg.key);
    }else{
      btn.textContent=`${cost}g`;
      btn.onclick=null;
    }

    top.appendChild(title);
    top.appendChild(meta);
    top.appendChild(btn);

    const barOuter=document.createElement("div");
    barOuter.className="upBarOuter";
    const barInner=document.createElement("div");
    barInner.className="upBarInner";
    const pct = Math.max(0, Math.min(1, (me.gold||0)/cost));
    barInner.style.width = (pct*100)+"%";
    barOuter.appendChild(barInner);

    row.appendChild(top);
    row.appendChild(barOuter);
    body.appendChild(row);
  });
}

/* Safe firestore wrappers */
async function safeUpdate(ref, data){
  try{ await updateDoc(ref, data); }catch(e){ /* ignore */ }
}
async function safeDelete(ref){
  try{ await deleteDoc(ref); }catch(e){ /* ignore */ }
}
async function safeSet(ref, data, opts){ try{ await setDoc(ref, data, opts||{});}catch(e){/* ignore*/}}

/* ------------------------- Meta / unlocks utilities ---------------------- */
async function loadMeta(){
  try{
    const snap = await getDoc(metaRef);
    if (snap.exists()) meta = { ...meta, ...snap.data() };
  }catch(e){}
}
async function updateMetaAfterRun(runScore){
  try{
    const snap = await getDoc(metaRef);
    let cur = snap.exists()? snap.data() : { totalRuns:0, bestScore:0 };
    const next = {
      totalRuns:(cur.totalRuns||0)+1,
      bestScore:Math.max(cur.bestScore||0, runScore||0)
    };
    await safeSet(metaRef,next,{merge:true});
    meta = {...meta,...next};
  }catch(e){}
}
function unlockNodes(){
  const best = meta.bestScore||0;
  const runs = meta.totalRuns||0;
  return [
    {id:"wall1", label:"Sturdy Walls", desc:"+10% wall HP", active:best>=500},
    {id:"wall2", label:"Fortified Walls", desc:"+20% wall HP total", active:best>=2000},
    {id:"tur1", label:"Sharpshooter Turrets", desc:"+10% turret damage", active:best>=1500},
    {id:"tur2", label:"Master Engineer", desc:"+20% turret damage total", active:best>=3500},
    {id:"bomb1", label:"Bomb Expert", desc:"+1 bomb radius", active:best>=2500},
    {id:"bomb2", label:"Demolition Master", desc:"+2 bomb radius total", active:best>=4500},
    {id:"vet",   label:"Veteran Defender", desc:`${runs} total runs`, active:runs>=5}
  ];
}
function showMetaOverlay(){
  const overlay = document.getElementById("metaOverlay");
  const listEl = document.getElementById("metaList");
  const subtitle = document.getElementById("metaSubtitle");
  const nodes = unlockNodes();
  subtitle.textContent = `Best Score: ${meta.bestScore||0} ¬∑ Runs: ${meta.totalRuns||0}`;
  listEl.innerHTML="";
  nodes.forEach(n=>{
    const row=document.createElement("div");
    row.className="metaNode "+(n.active?"active":"locked");
    row.innerHTML = `<span class="label">${n.active?"‚úÖ":"üîí"} ${n.label}</span><span>${n.desc}</span>`;
    listEl.appendChild(row);
  });
  overlay.classList.add("show");
  setTimeout(()=>{ overlay.classList.add("fade"); }, 2500);
  setTimeout(()=>{ overlay.style.display="none"; }, 3200);
}
function wallHpMetaMult(){
  const best = meta.bestScore||0;
  let m=1;
  if (best>=500) m+=0.10;
  if (best>=2000) m+=0.10;
  return m;
}
function turretDmgMetaMult(){
  const best = meta.bestScore||0;
  let m=1;
  if (best>=1500) m+=0.10;
  if (best>=3500) m+=0.10;
  return m;
}
function bombRadiusBase(){
  const best = meta.bestScore||0;
  let r=1;
  if (best>=2500) r++;
  if (best>=4500) r++;
  return r;
}

/* ------------------------------- Blocking -------------------------------- */
const BLOCKERS = ["üß±","üî´","üí£","üè≠"];
function isBlocked(x,y){
  if (x<=0||y<=0||x>=gridSize-1||y>=gridSize-1) return true;
  const s=structures.get(key(x,y));
  return !!(s && BLOCKERS.includes(s.t));
}
function tileOccupied(x,y){ return !!structures.get(key(x,y)); }

/* ------------------------------- Rendering ------------------------------- */
function addHPBar(el, cur, max){
  const bar = document.createElement("div"); bar.className="hpbar";
  const fill=document.createElement("i"); const pct = Math.max(0,Math.min(1,(cur||0)/(max||1)));
  fill.style.width=(pct*100)+"%"; bar.appendChild(fill); el.appendChild(bar);
}
function putEmoji(el, ch){
  const span=document.createElement('span'); span.className='emj'; span.textContent=ch; el.appendChild(span);
}
function renderExplosion(x,y){
  const cx = (x - camera.x)*cellPx + cellPx/2;
  const cy = (y - camera.y)*cellPx + cellPx/2;
  const blast = document.createElement('div'); blast.className='blast'; blast.style.left=cx+'px'; blast.style.top=cy+'px';
  const ring  = document.createElement('div'); ring.className='shock'; ring.style.left=cx+'px';  ring.style.top=cy+'px';
  stageEl.appendChild(blast); stageEl.appendChild(ring);
  setTimeout(()=>blast.remove(), 340); setTimeout(()=>ring.remove(), 380);
}
function renderFreezeArea(cx,cy,r=2){
  for (let dx=-r; dx<=r; dx++) for (let dy=-r; dy<=r; dy++){
    const nx=cx+dx, ny=cy+dy; if (!inBounds(nx,ny)) continue;
    if (Math.max(Math.abs(dx),Math.abs(dy))>r) continue;
    const idx = (ny - camera.y)*view + (nx - camera.x);
    if (idx<0 || idx>=gridEl.children.length) continue;
    const tile = gridEl.children[idx];
    const ov = document.createElement('div'); ov.className='freezeOverlay';
    tile.appendChild(ov); setTimeout(()=>ov.remove(), 250);
  }
}
function renderTurretShot(sx,sy,tx,ty){
  const fromX = (sx - camera.x + 0.5)*cellPx;
  const fromY = (sy - camera.y + 0.5)*cellPx;
  const toX   = (tx - camera.x + 0.5)*cellPx;
  const toY   = (ty - camera.y + 0.5)*cellPx;
  const dx = toX - fromX;
  const dy = toY - fromY;
  const dist = Math.hypot(dx,dy);
  const angle = Math.atan2(dy,dx)*180/Math.PI;
  const el = document.createElement('div');
  el.className='laser';
  el.style.left = fromX+'px';
  el.style.top  = fromY+'px';
  el.style.width = dist+'px';
  el.style.transform = `translateY(-50%) rotate(${angle}deg)`;
  stageEl.appendChild(el);
  setTimeout(()=>el.remove(),220);
}
function render(){
  focusCamera();
  gridEl.innerHTML="";
  for(let ry=0; ry<view; ry++){
    for(let rx=0; rx<view; rx++){
      const gx=camera.x+rx, gy=camera.y+ry;
      const el=document.createElement("div"); el.className="cell";
      if (gx===0||gy===0||gx===gridSize-1||gy===gridSize-1) el.classList.add("edge"); else el.classList.add("grass");

      const s=structures.get(key(gx,gy));
      if (s){
        putEmoji(el, s.t);
        if (BLOCKERS.includes(s.t)) addHPBar(el, s.hp||0, s.max||1);
        if (s.t==="üéÅ" || (s.t?.startsWith?.("‚≠ï")) || (s.t?.startsWith?.("üî∫"))) {
          el.style.outline="2px solid #eab308"; el.style.borderRadius="6px";
        }
      }

      const ratHere=[...rats].find(([,r])=>r.x===gx&&r.y===gy);
      if (ratHere){ putEmoji(el,"üêÄ"); addHPBar(el, ratHere[1].hp||1, ratHere[1].max||ratHere[1].hp||1); }
      const bearHere=[...bears].find(([,b])=>b.x===gx&&b.y===gy);
      if (bearHere){ putEmoji(el,"üêª"); addHPBar(el, bearHere[1].hp||1, bearHere[1].max||bearHere[1].hp||1); }
      const catp=[...caterpillars].find(([,c])=>c.x===gx&&c.y===gy);
      if (catp){ putEmoji(el,"üêõ"); addHPBar(el, catp[1].hp||1, catp[1].max||catp[1].hp||1); }
      const crow=[...crows].find(([,c])=>c.x===gx&&c.y===gy);
      if (crow){ putEmoji(el,"üê¶"); addHPBar(el, crow[1].hp||1, crow[1].max||crow[1].hp||1); }
      const golem=[...golems].find(([,g])=>g.x===gx&&g.y===gy);
      if (golem){ putEmoji(el,"üßå"); addHPBar(el, golem[1].hp||1, golem[1].max||golem[1].hp||1); }

      // Allies
      const fleaHere=[...fleas].find(([,f])=>f.x===gx&&f.y===gy);
      if (fleaHere){ putEmoji(el,"ü™∞"); }
      const beetleHere=[...beetles].find(([,bt])=>bt.x===gx&&bt.y===gy);
      if (beetleHere){ putEmoji(el,"ü™≤"); addHPBar(el, beetleHere[1].hp||1, beetleHere[1].max||1); }

      if (corpses.has(key(gx,gy))) putEmoji(el,"ü™¶");

      if (gameDoc.cat && gameDoc.cat.x===gx && gameDoc.cat.y===gy) {
        putEmoji(el, (gameDoc.cat.stunUntil && Date.now() < gameDoc.cat.stunUntil) ? "üòµ‚Äçüí´" : "üê±");
        addHPBar(el, gameDoc.cat.h||0, Math.max(1, gameDoc.cat.hMax||50));
      }

      for(const [n,p] of Object.entries(players)){ if (p.alive && p.x===gx && p.y===gy) putEmoji(el,"üê≠"); }
      if (me.alive && me.x===gx && me.y===gy) putEmoji(el,"üê≠");

      gridEl.appendChild(el);
    }
  }
  const aliveCt=(me.alive?1:0)+Object.values(players).filter(p=>p.alive).length;
  $("#aliveCount").textContent=aliveCt;
  $("#score").textContent=me.score;
}

/* ------------------------------- Firestore ------------------------------- */
const gameRef = doc(db,"games",gameId);
const playersCol = collection(db,"games",gameId,"players");
const structsCol = collection(db,"games",gameId,"structures");
const ratsCol = collection(db,"games",gameId,"rats");
const bearsCol = collection(db,"games",gameId,"bears");
const catsCol = collection(db,"games",gameId,"caterpillars");
const crowsCol = collection(db,"games",gameId,"crows");
const corpsesCol = collection(db,"games",gameId,"corpses");
const fleasCol = collection(db,"games",gameId,"fleas");
const beetlesCol = collection(db,"games",gameId,"beetles");
const golemsCol = collection(db,"games",gameId,"golems");

const highsCol = collection(db,"games",gameId,"highscores");

async function claimHost(){
  const snap = await getDoc(gameRef);
  const data = snap.exists()? snap.data() : {};
  if (!data.host){
    await safeSet(gameRef,{
      host: myName,
      startMs: Date.now(),
      cat: { x:gridSize-2, y:gridSize-2, h: 50, hMax: 50, stunCount:0, stunUntil:0 },
      catPower: 0,
      nextPowerOfferAt: Date.now() + 120000
    },{merge:true});
    I_AM_HOST = true;
  }else{
    I_AM_HOST = (data.host===myName);
    if (!data.cat){
      await safeSet(gameRef,{ cat:{ x:gridSize-2, y:gridSize-2, h:50, hMax:50, stunCount:0, stunUntil:0 } },{merge:true});
    }
  }
  setHostBadge();
}
async function upsertMe(){
  await safeSet(doc(playersCol,myName), {
    x:me.x,y:me.y,alive:me.alive,score:me.score,displayName:myName,
    powers: me.powers || {},
    gold: me.gold || 0
  },{merge:true});
}
function listen(){
  onSnapshot(gameRef,(s)=>{
    if (!s.exists()) return;
    gameDoc=s.data();
    if (gameDoc.host===myName && !I_AM_HOST){ I_AM_HOST=true; setHostBadge(); }
    render();
    if (gameDoc.gameOver && !summaryShown){
      showSessionSummary(gameDoc);
    }
  });
  onSnapshot(playersCol,(snap)=>{
    const next={};
    snap.forEach(d=>{
      const data=d.data();
      if (d.id===myName){
        me.gold = data.gold || 0;
        updateGoldUI();
        renderUpgradesUI();
      }else{
        next[d.id]=data;
      }
    });
    players=next;
    render();
  });
  onSnapshot(structsCol,(snap)=>{ const m=new Map(); snap.forEach(d=>{ const v=d.data(); m.set(key(v.x,v.y),v); }); structures=m; render(); });
  onSnapshot(ratsCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(d.id,d.data())); rats=m; render(); });
  onSnapshot(bearsCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(d.id,d.data())); bears=m; render(); });
  onSnapshot(catsCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(d.id,d.data())); caterpillars=m; render(); });
  onSnapshot(crowsCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(d.id,d.data())); crows=m; render(); });
  onSnapshot(corpsesCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(key(d.data().x,d.data().y), d.id)); corpses=m; render(); });
  onSnapshot(fleasCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(d.id,d.data())); fleas=m; render(); });
  onSnapshot(beetlesCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(d.id,d.data())); beetles=m; render(); });
  onSnapshot(golemsCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(d.id,d.data())); golems=m; render(); });
}

/* ------------------------------ Placement/HP ------------------------------ */
async function placeStructureHost(x,y,t,hp,extra={}){ await safeSet(doc(structsCol,key(x,y)),{x,y,t,hp,max:hp,...extra}); }
async function deleteStructureHost(x,y){ await safeDelete(doc(structsCol,key(x,y))); }

function hpWall(){
  const base = 35;
  const metaMult = wallHpMetaMult();
  const stoneMult = 1 + 0.05*globalStoneLevel;
  return Math.round(base * (1+0.2*levels.wall) * metaMult * stoneMult);
}
function hpTur(){
  const base = 24;
  const metaMult = turretDmgMetaMult(); // treat as small hp buff too
  return Math.round(base * (1+0.2*levels.turret) * metaMult);
}

/* ------------------------------ Pathfinding ------------------------------ */
function findPath(sx,sy,tx,ty,allowTargetBlocked=false,fly=false,extraBlocks=new Set()){
  const Q=[[sx,sy]];
  const P=new Map([[key(sx,sy),null]]);
  const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
  while(Q.length){
    const [x,y]=Q.shift();
    if (x===tx && y===ty) break;
    for(const [dx,dy] of dirs){
      const nx=x+dx, ny=y+dy;
      if (nx<0||ny<0||nx>=gridSize||ny>=gridSize) continue;
      if (P.has(key(nx,ny))) continue;
      let blocked = isBlocked(nx,ny);
      if (fly) blocked=false;
      if (extraBlocks.has(key(nx,ny))) blocked=true;
      const isTarget = (nx===tx && ny===ty);
      if (blocked && !(allowTargetBlocked && isTarget)) continue;
      P.set(key(nx,ny),[x,y]); Q.push([nx,ny]);
    }
  }
  if (!P.has(key(tx,ty))) return null;
  const path=[]; let cur=[tx,ty];
  while(cur){ path.push(cur); cur=P.get(key(cur[0],cur[1])); }
  path.reverse(); return path;
}

/* ------------------------------- Enemy target logic ---------------------- */
function manhattan(ax,ay,bx,by){ return Math.abs(ax-bx)+Math.abs(ay-by); }
function nearestStructureFrom(x,y){
  let pick=null, best=1e9;
  for(const s of structures.values()){
    if (!["üß±","üî´","üí£","üè≠"].includes(s.t)) continue;
    const d=manhattan(x,y,s.x,s.y);
    if (d<best){best=d; pick=s;}
  }
  return pick;
}

/* ------------------------------- Bombs ----------------------------------- */
async function detonateAt(x,y, dmgRat=18, dmgBear=14, dmgOther=16, radiusOverride){
  if (!I_AM_HOST) return;
  renderExplosion(x,y);
  const radius = radiusOverride ?? bombRadiusBase();
  const within = (ux,uy)=> Math.max(Math.abs(ux-x), Math.abs(uy-y))<=radius;

  for (let dx=-radius; dx<=radius; dx++) for (let dy=-radius; dy<=radius; dy++){
    const nx=x+dx, ny=y+dy;
    const s=structures.get(key(nx,ny));
    if (s && s.t==="üß±"){ await deleteStructureHost(nx,ny); }
  }

  for (const [id,r] of rats){ if (within(r.x,r.y)) { const hp=(r.hp||0)-dmgRat; if (hp<=0) await safeDelete(doc(ratsCol,id)); else await safeUpdate(doc(ratsCol,id),{hp}); } }
  for (const [id,b] of bears){ if (within(b.x,b.y)) { const hp=(b.hp||0)-dmgBear; if (hp<=0) await safeDelete(doc(bearsCol,id)); else await safeUpdate(doc(bearsCol,id),{hp}); } }
  for (const [id,c] of caterpillars){ if (within(c.x,c.y)) { const hp=(c.hp||0)-dmgOther; if (hp<=0) await safeDelete(doc(catsCol,id)); else await safeUpdate(doc(catsCol,id),{hp}); } }
  for (const [id,cw] of crows){ if (within(cw.x,cw.y)) { const hp=(cw.hp||0)-dmgOther; if (hp<=0) await safeDelete(doc(crowsCol,id)); else await safeUpdate(doc(crowsCol,id),{hp}); } }
  for (const [id,g] of golems){ if (within(g.x,g.y)) { const hp=(g.hp||0)-dmgOther; if (hp<=0) await safeDelete(doc(golemsCol,id)); else await safeUpdate(doc(golemsCol,id),{hp}); } }

  if (gameDoc.cat && within(gameDoc.cat.x,gameDoc.cat.y)){
    await damageCat(16); me.score+=4; await safeUpdate(doc(playersCol,myName),{score:me.score}); floatText(gameDoc.cat.x,gameDoc.cat.y,"+4","#ffa94d");
  }
}

/* ------------------------------- Cat HP & stun --------------------------- */
async function damageCat(amount){
  if (!I_AM_HOST) return;
  const snap = await getDoc(gameRef);
  if (!snap.exists()) return;
  const g = snap.data();
  const cat = {...g.cat};
  if (cat.stunUntil && Date.now() < cat.stunUntil) return;

  cat.h = Math.max(0, (cat.h||0) - amount);
  if (cat.h <= 0){
    const nextCount = (cat.stunCount||0) + 1;
    const nextMax   = 50 * (nextCount + 1);
    cat.stunCount = nextCount;
    cat.stunUntil = Date.now() + 10000; // 10s
    cat.hMax = nextMax;
    cat.h = nextMax;
  }
  await safeUpdate(gameRef, { cat });
}

/* ------------------------------ Turrets ---------------------------------- */
function turretRange(){ return 5 + levels.range; }
function turretDamage(){
  const base = 6;
  const metaMult = turretDmgMetaMult();
  const lightningMult = 1 + 0.05*globalLightningLevel;
  return Math.round(base * (1 + 0.25*levels.turret) * metaMult * lightningMult);
}
async function damageEnemy(kind,id,amount){
  if (kind==="rat"){ const r=rats.get(id); if (!r) return; const hp=r.hp-amount; if (hp<=0) await safeDelete(doc(ratsCol,id)); else await safeUpdate(doc(ratsCol,id),{hp}); }
  else if (kind==="bear"){ const b=bears.get(id); if (!b) return; const hp=b.hp-amount; if (hp<=0) await safeDelete(doc(bearsCol,id)); else await safeUpdate(doc(bearsCol,id),{hp}); }
  else if (kind==="cater"){ const c=caterpillars.get(id); if (!c) return; const hp=c.hp-amount; if (hp<=0) await safeDelete(doc(catsCol,id)); else await safeUpdate(doc(catsCol,id),{hp}); }
  else if (kind==="crow"){ const cw=crows.get(id); if (!cw) return; const hp=cw.hp-amount; if (hp<=0) await safeDelete(doc(crowsCol,id)); else await safeUpdate(doc(crowsCol,id),{hp}); }
  else if (kind==="golem"){ const g=golems.get(id); if (!g) return; const hp=g.hp-amount; if (hp<=0) await safeDelete(doc(golemsCol,id)); else await safeUpdate(doc(golemsCol,id),{hp}); }
}
async function hostTurrets(){
  if (!I_AM_HOST) return;
  for (const o of structures.values()){
    if (o.t!=="üî´") continue;
    const rng = turretRange();
    const pool = [];
    if (gameDoc.cat) pool.push({kind:"cat", x:gameDoc.cat.x, y:gameDoc.cat.y});
    for (const [id,r] of rats)  pool.push({kind:"rat", id, x:r.x, y:r.y});
    for (const [id,b] of bears) pool.push({kind:"bear", id, x:b.x, y:b.y});
    for (const [id,c] of caterpillars) pool.push({kind:"cater", id, x:c.x, y:c.y});
    for (const [id,cw] of crows) pool.push({kind:"crow", id, x:cw.x, y:cw.y});
    for (const [id,g] of golems) pool.push({kind:"golem", id, x:g.x, y:g.y});
    if (!pool.length) continue;

    pool.sort((a,b)=> (Math.abs(a.x-o.x)+Math.abs(a.y-o.y)) - (Math.abs(b.x-o.x)+Math.abs(b.y-o.y)));
    const t=pool[0];
    const dist = Math.abs(t.x-o.x)+Math.abs(t.y-o.y);
    if (dist>rng) continue;

    // visual
    renderTurretShot(o.x,o.y,t.x,t.y);

    const dmg = turretDamage();
    if (t.kind==="cat"){ await damageCat(Math.floor(dmg/2)); me.score+=1; await safeUpdate(doc(playersCol,myName),{score:me.score}); }
    else { await damageEnemy(t.kind,t.id,dmg); }
  }
}

/* ------------------------------ Enemy brains ----------------------------- */
function isFrozen(ent){ return (ent.freezeUntil||0) > Date.now(); }

async function damageStructureHost(x,y,amt){
  const id=key(x,y); const s=structures.get(id); if (!s) return;
  if (s.t==="üí£"){ await deleteStructureHost(x,y); await detonateAt(x,y); return; }
  const hp=Math.max(0,(s.hp||0)-amt);
  if (hp<=0) await deleteStructureHost(x,y); else await safeUpdate(doc(structsCol,id),{hp});
}

async function hostRatsThink(){
  if (!I_AM_HOST) return;
  for (const [id,r] of rats){
    if (isFrozen(r)) continue;
    let target=null, best=1e9;
    const mice=[]; if (me.alive) mice.push({x:me.x,y:me.y,name:myName});
    for (const [n,p] of Object.entries(players)) if (p.alive) mice.push({x:p.x,y:p.y,name:n});

    let nearMouse = null, nearMouseDist = 1e9;
    for (const m of mice){
      const d=manhattan(r.x,r.y,m.x,m.y);
      if (d<nearMouseDist){ nearMouseDist=d; nearMouse={type:"mouse",...m}; }
    }

    if (nearMouse && nearMouseDist<=8){
      const pathToMouse = findPath(r.x,r.y,nearMouse.x,nearMouse.y,true);
      if (pathToMouse && pathToMouse.length>1){
        target = nearMouse;
      }else{
        let wallPick=null, bestW=1e9;
        for (const s of structures.values()){
          if (s.t!=="üß±") continue;
          const d=manhattan(r.x,r.y,s.x,s.y);
          if (d<bestW){bestW=d; wallPick={type:"struct",x:s.x,y:s.y};}
        }
        target = wallPick || nearMouse;
      }
    }else{
      const st = nearestStructureFrom(r.x,r.y);
      if (st) target={type:"struct",x:st.x,y:st.y};
    }
    if (!target) continue;

    let step=null;
    const p=findPath(r.x,r.y,target.x,target.y,true);
    if (p && p.length>1) step={x:p[1][0],y:p[1][1]};
    else {
      const dx=Math.sign(target.x-r.x), dy=Math.sign(target.y-r.y);
      step = (Math.abs(target.x-r.x)>=Math.abs(target.y-r.y))
        ? {x:clamp(r.x+dx,1,gridSize-2), y:r.y}
        : {x:r.x, y:clamp(r.y+dy,1,gridSize-2)};
    }
    await safeUpdate(doc(ratsCol,id),{x:step.x,y:step.y});

    const ms = structures.get(key(step.x,step.y));
    if (ms && ms.t==="üí£"){ await deleteStructureHost(step.x,step.y); await detonateAt(step.x,step.y); }

    if (target.type==="struct" && r.x===target.x && r.y===target.y){ await damageStructureHost(r.x,r.y,1); }
    if (target.type==="mouse" && r.x===target.x && r.y===target.y){
      if (target.name===myName && me.alive){ me.alive=false; await safeUpdate(doc(playersCol,myName),{alive:false}); await addDoc(corpsesCol,{x:r.x,y:r.y}); }
      else { await safeUpdate(doc(playersCol,target.name),{alive:false}); await addDoc(corpsesCol,{x:r.x,y:r.y}); }
    }
  }
}
async function hostBearsThink(){
  if (!I_AM_HOST) return;
  for (const [id,b] of bears){
    if (isFrozen(b)) continue;
    if (Math.random()<0.5) continue;
    let target=null;

    const mice=[]; if (me.alive) mice.push({x:me.x,y:me.y,name:myName});
    for (const [n,p] of Object.entries(players)) if (p.alive) mice.push({x:p.x,y:p.y,name:n});
    let nearMouse=null, md=1e9; for(const m of mice){ const d=manhattan(b.x,b.y,m.x,m.y); if (d<md){md=d; nearMouse={type:"mouse",...m};}}
    if (nearMouse && md<=8){
      const path=findPath(b.x,b.y,nearMouse.x,nearMouse.y,true);
      if (path) target=nearMouse; else target=nearestStructureFrom(b.x,b.y) ? {type:"struct", ...nearestStructureFrom(b.x,b.y)} : nearMouse;
    }else{
      const st=nearestStructureFrom(b.x,b.y); if (st) target={type:"struct",x:st.x,y:st.y};
    }
    if (!target) continue;

    const p=findPath(b.x,b.y,target.x,target.y,true);
    if (p && p.length>1){ const s=p[1]; await safeUpdate(doc(bearsCol,id),{x:s[0],y:s[1]}); }
    else { const dx=Math.sign(target.x-b.x), dy=Math.sign(target.y-b.y); const nx=clamp(b.x+dx,1,gridSize-2), ny=clamp(b.y+dy,1,gridSize-2); await safeUpdate(doc(bearsCol,id),{x:nx,y:ny}); }

    if (target.type==="struct" && b.x===target.x && b.y===target.y){ await damageStructureHost(b.x,b.y,4); }
    if (target.type==="mouse" && b.x===target.x && b.y===target.y){
      if (target.name===myName && me.alive){ me.alive=false; await safeUpdate(doc(playersCol,myName),{alive:false}); await addDoc(corpsesCol,{x:b.x,y:b.y}); }
      else { await safeUpdate(doc(playersCol,target.name),{alive:false}); await addDoc(corpsesCol,{x:b.x,y:b.y}); }
    }
  }
}
async function hostCaterpillarsThink(){
  if (!I_AM_HOST) return;
  for(const [id,c] of caterpillars){
    if (isFrozen(c)) continue;
    const st=nearestStructureFrom(c.x,c.y); if (!st) continue;
    const p=findPath(c.x,c.y,st.x,st.y,true);
    if (p && p.length>1){ const s=p[1]; await safeUpdate(doc(catsCol,id),{x:s[0],y:s[1]}); }
    if (c.x===st.x && c.y===st.y){ await damageStructureHost(c.x,c.y,20); await safeDelete(doc(catsCol,id)); }
  }
}
async function hostCrowsThink(){
  if (!I_AM_HOST) return;
  for(const [id,cw] of crows){
    if (isFrozen(cw)) continue;
    let targets=[];
    if (me.alive) targets.push({x:me.x,y:me.y,type:"mouse"});
    for (const [,p] of Object.entries(players)) if (p.alive) targets.push({x:p.x,y:p.y,type:"mouse"});
    for(const s of structures.values()){
      if (["üî´","üß±","üí£","üè≠"].includes(s.t)){
        targets.push({x:s.x,y:s.y,type:"struct",priority:(s.t==="üè≠"?0:1)});
      }
    }
    if (!targets.length) continue;
    targets.sort((a,b)=>{
      const pa = (a.priority===0?0.6:1);
      const pb = (b.priority===0?0.6:1);
      const da = manhattan(cw.x,cw.y,a.x,a.y)*pa;
      const db = manhattan(cw.x,cw.y,b.x,b.y)*pb;
      return da-db;
    });
    const t=targets[0];
    const p=findPath(cw.x,cw.y,t.x,t.y,true,true);
    if (p && p.length>1){
      const s=p[1];
      if (Math.random()<0.5) await safeUpdate(doc(crowsCol,id),{x:s[0],y:s[1]});
    } else {
      if (t.type==="struct" && cw.x===t.x && cw.y===t.y){ await damageStructureHost(cw.x,t.y,2); }
    }
  }
}
async function hostGolemsThink(){
  if (!I_AM_HOST) return;
  for (const [id,g] of golems){
    if (isFrozen(g)) continue;
    const st = nearestStructureFrom(g.x,g.y);
    if (!st) continue;
    const p = findPath(g.x,g.y,st.x,st.y,true);
    if (p && p.length>1){
      const s=p[1];
      await safeUpdate(doc(golemsCol,id),{x:s[0],y:s[1]});
    }
    const dist = manhattan(g.x,g.y,st.x,st.y);
    if (dist<=1){
      await damageStructureHost(st.x,st.y, 10 + (gameDoc.catPower||0)*2);
    }
  }
}

/* ------------------------------- Cat AI ---------------------------------- */
async function hostCatAI(){
  if (!I_AM_HOST || !gameDoc.cat) return;
  const cat = {...gameDoc.cat};
  if (cat.stunUntil && Date.now() < cat.stunUntil){ await safeUpdate(gameRef,{cat}); return; }

  const mice=[]; if (me.alive) mice.push({x:me.x,y:me.y,type:"mouse",name:myName});
  for (const [n,p] of Object.entries(players)) if (p.alive) mice.push({x:p.x,y:p.y,type:"mouse",name:n});
  let target=null;

  let nearMouse=null, md=1e9; for(const m of mice){ const d=manhattan(cat.x,cat.y,m.x,m.y); if (d<md){md=d; nearMouse=m;} }
  if (nearMouse && md<=8){
    const path=findPath(cat.x,cat.y,nearMouse.x,nearMouse.y,true);
    if (path) target=nearMouse;
    else { const st=nearestStructureFrom(cat.x,cat.y); if (st) target={x:st.x,y:st.y,type:"struct"}; }
  }else{
    const st=nearestStructureFrom(cat.x,cat.y); if (st) target={x:st.x,y:st.y,type:"struct"};
  }
  if (!target){ await safeUpdate(gameRef,{cat}); return; }

  let path = findPath(cat.x,cat.y,target.x,target.y,true);
  if (path && path.length>1){ const step=path[1]; cat.x=step[0]; cat.y=step[1]; }
  else{
    const dx = Math.sign(target.x - cat.x), dy=Math.sign(target.y - cat.y);
    const nx=clamp(cat.x+dx,1,gridSize-2), ny=clamp(cat.y+dy,1,gridSize-2);
    const block = structures.get(key(nx,ny));
    if (!block){ cat.x=nx; cat.y=ny; }
    else if (["üß±","üî´","üí£","üè≠"].includes(block.t)){ await damageStructureHost(nx,ny,2 + Math.floor((gameDoc.catPower||0)/2)); }
  }

  for (const [ax,ay] of [[1,0],[-1,0],[0,1],[0,-1]]){
    const tx=cat.x+ax, ty=cat.y+ay;
    const s = structures.get(key(tx,ty));
    if (s && ["üß±","üî´","üí£","üè≠"].includes(s.t)){ await damageStructureHost(tx,ty,2 + Math.floor((gameDoc.catPower||0)/2)); break; }
    if (me.alive && me.x===tx && me.y===ty){ me.alive=false; await safeUpdate(doc(playersCol,myName),{alive:false}); await addDoc(corpsesCol,{x:tx,y:ty}); break; }
    for (const [n,p] of Object.entries(players)){ if (p.alive && p.x===tx && p.y===ty){ await safeUpdate(doc(playersCol,n),{alive:false}); await addDoc(corpsesCol,{x:tx,y:ty}); break; } }
  }
  await safeUpdate(gameRef,{cat});
}

/* ------------------------------- Power-ups -------------------------------- */
const powerBar = document.getElementById('powerBar');
const POWER_LIST = ["Fire","Lightning","Ice","Stone","Fleas","Beetles"];
function rand2(arr){ const a=[...arr]; const i=Math.floor(Math.random()*a.length); let j=Math.floor(Math.random()*a.length); if (j===i) j=(j+1)%a.length; return [a[i],a[j]]; }
function powerIcon(n){ return n==="Fire"?"üî•":n==="Lightning"?"‚ö°":n==="Ice"?"‚ùÑÔ∏è":n==="Stone"?"ü™®":n==="Fleas"?"ü™∞":"ü™≤"; }

function powerPeriod(name,lvl){
  if (name==="Stone") return Math.max(5000, 30000 - 3000*(lvl-1));
  if (name==="Ice")   return Math.max(5000, 30000 - 1000*(lvl-1));
  if (name==="Lightning") return Math.max(4000, 15000 - 1000*(lvl-1));
  if (name==="Fire")  return Math.max(6000, 30000 - 1000*(lvl-1));
  if (name==="Fleas") return Math.max(3000, 30000 - 1000*(lvl-1));
  if (name==="Beetles")return Math.max(5000, 45000 - 2000*(lvl-1));
  return 30000;
}
function powerData(p){ return p && typeof p.lvl==="number" ? p : {lvl:0,nextAt:Date.now()+99999999}; }

function showPowerOffer(){
  if (!me.alive) return;
  const [a,b]=rand2(POWER_LIST);
  powerBar.innerHTML="";
  const mk=(name)=>{
    const btn=document.createElement('div'); btn.className='opt';
    btn.innerHTML = `${powerIcon(name)} <b>${name}</b>`;
    btn.onclick=async ()=>{
      const cur = powerData(me.powers?.[name]);
      const nextLvl = (cur.lvl||0)+1;
      const nextAt = Date.now() + powerPeriod(name,nextLvl);
      me.powers = {...(me.powers||{}), [name]:{lvl:nextLvl,nextAt}};
      await safeUpdate(doc(playersCol,myName), { powers: me.powers });
      powerBar.style.display='none';
      toast(`${name} +1`);
    };
    return btn;
  };
  powerBar.appendChild(mk(a));
  powerBar.appendChild(mk(b));
  powerBar.style.display='flex';
}

/* ------------------------------- Spawns & Pickups ------------------------ */
const BLOCK_PICKUPS = new Set(["üß±","üî´","üí£","üè≠"]);
function unlockedItems(){
  const arr=[]; const pushW=(icon,w)=>{ for(let i=0;i<w;i++) arr.push(icon); };
  pushW("üß±",6); pushW("üî´",4); pushW("üí£",3); pushW("üè≠",3); // factories added
  return arr;
}
// No more auto-upgrade pickups
function powerupPool(){ return []; }

async function placeTempPickup(x,y,t,ttlMs=30000){
  await safeSet(doc(structsCol, key(x,y)), { x,y,t, hp:1, max:1, expAt: Date.now() + ttlMs });
}
async function hostSpawnPickups(){
  if (!I_AM_HOST) return;
  const types = unlockedItems();
  for (let i=0;i<2;i++){
    const x = 2 + Math.floor(Math.random()*(gridSize-4));
    const y = 2 + Math.floor(Math.random()*(gridSize-4));
    if (tileOccupied(x,y)) continue;
    const pick = types[Math.floor(Math.random()*types.length)];
    const t = "‚≠ï"+pick;
    await placeTempPickup(x,y,t, 30000);
  }
  // powerupPool disabled for now (no free upgrades)
}
setInterval(async ()=>{
  if (!I_AM_HOST) return;
  const now = Date.now();
  for (const s of structures.values()){
    if ((s.t?.startsWith?.("‚≠ï") || s.t?.startsWith?.("üî∫")) && s.expAt && now >= s.expAt){
      await deleteStructureHost(s.x,s.y);
    }
  }
}, 2000);

/* ------------------------------ Player control --------------------------- */
async function tryMove(dx,dy,moveDelay){
  if (!me.alive) return;
  if (Date.now()-lastMoveAt<moveDelay) return;
  const nx=clamp(me.x+dx,1,gridSize-2), ny=clamp(me.y+dy,1,gridSize-2);
  if (!inBounds(nx,ny)) return;
  me.x=nx; me.y=ny; lastMoveAt=Date.now(); await upsertMe();

  const s=structures.get(key(nx,ny));
  if (s){
    const take=(icon,count)=>{ heldType=icon; heldCount=count; toast(`Held ${icon} x${count}`); };
    if (s.t==="‚≠ïüß±"){ take("üß±",20); await safeDelete(doc(structsCol,key(nx,ny))); }
    if (s.t==="‚≠ïüî´"){ take("üî´",3);  await safeDelete(doc(structsCol,key(nx,ny))); }
    if (s.t==="‚≠ïüí£"){ take("üí£",4);  await safeDelete(doc(structsCol,key(nx,ny))); }
    if (s.t==="‚≠ïüè≠"){ take("üè≠",3);  await safeDelete(doc(structsCol,key(nx,ny))); } // factories pickup

    // Removed all "üî∫" auto-upgrade pickups (manual upgrades only now)
    setHeldUI();
  }

  // revive (use cached corpse map, avoid multi-where index)
  if (corpses.has(key(nx,ny))){
    const corpseId = corpses.get(key(nx,ny));
    if (corpseId) await safeDelete(doc(corpsesCol, corpseId));

    const dead = [
      myName,
      ...Object.entries(players).filter(([,p])=>!p.alive).map(([n])=>n)
    ].filter((v,i,a)=>a.indexOf(v)===i);

    if (dead.length){
      const n = dead[0];
      await safeUpdate(doc(playersCol,n),{alive:true,x:nx,y:ny});
      me.score += 100; await safeUpdate(doc(playersCol,myName),{score:me.score});
      toast("ü©π Revived +100");
    }
  }

  render();
}
async function tryBuild(dx,dy){
  if (!me.alive) return;
  if (Date.now()-lastBuildAt<buildDelay) return;
  if (!heldType || heldCount<=0) { toast("No held item"); return; }
  const tx=clamp(me.x+dx,1,gridSize-2), ty=clamp(me.y+dy,1,gridSize-2);
  if (!inBounds(tx,ty)) return;
  if (tileOccupied(tx,ty)) return;

  let hp=10, extra={};
  if (heldType==="üß±"){ hp=hpWall(); }
  if (heldType==="üî´"){ hp=hpTur(); }
  if (heldType==="üí£"){ hp=1; extra.expAt = Date.now() + 3000; } // 3s fuse
  if (heldType==="üè≠"){
    hp = hpWall();
    extra.owner = myName;
    extra.factory = true;
    extra.cashRate = 3; // gold per tick chunk
  }

  await placeStructureHost(tx,ty,heldType,hp,extra);
  heldCount--; lastBuildAt=Date.now(); setHeldUI(); render();
}

/* ------------------------------ Allies (Fleas & Beetles) ----------------- */
// Fleas: fly to nearest enemy, deal 5 on hit, then die
async function hostFleaTick(){
  if (!I_AM_HOST) return;
  for (const [id,f] of fleas){
    const pool=[];
    if (gameDoc.cat) pool.push({kind:"cat", x:gameDoc.cat.x, y:gameDoc.cat.y});
    for (const [rid,r] of rats) pool.push({kind:"rat", id:rid, x:r.x,y:r.y});
    for (const [bid,b] of bears) pool.push({kind:"bear", id:bid, x:b.x,y:b.y});
    for (const [cid,c] of caterpillars) pool.push({kind:"cater", id:cid, x:c.x,y:c.y});
    for (const [cwId,cw] of crows) pool.push({kind:"crow", id:cwId, x:cw.x,y:cw.y});
    for (const [gid,g] of golems) pool.push({kind:"golem", id:gid, x:g.x,y:g.y});
    if (!pool.length){ await safeDelete(doc(fleasCol,id)); continue; }
    pool.sort((a,b)=> manhattan(f.x,f.y,a.x,a.y)-manhattan(f.x,f.y,b.x,b.y));
    const t=pool[0];

    const p=findPath(f.x,f.y,t.x,t.y,true,true);
    let nx=f.x, ny=f.y;
    if (p && p.length>1){ nx=p[1][0]; ny=p[1][1]; }
    else { const dx=Math.sign(t.x-f.x), dy=Math.sign(t.y-f.y); nx=clamp(f.x+dx,1,gridSize-2); ny=clamp(f.y+dy,1,gridSize-2); }
    await safeUpdate(doc(fleasCol,id),{x:nx,y:ny});

    if (nx===t.x && ny===t.y){
      if (t.kind==="cat"){ await damageCat(5); }
      else { await damageEnemy(t.kind,t.id,5); }
      await safeDelete(doc(fleasCol,id));
    }
  }
}

// Beetles: follow owner, path with walls, attack within 8, avoid overlap
function beetleStats(lvl){ return {hp: 30 + 20*(lvl-1), dmg: 5 + 5*(lvl-1)}; }
async function hostBeetleTick(){
  if (!I_AM_HOST) return;
  const occupied = new Set([...beetles.values()].map(b=>key(b.x,b.y)));
  for (const [id,b] of beetles){
    const owner = (b.owner && (b.owner===myName ? {x:me.x,y:me.y,alive:me.alive} : players[b.owner])) || null;
    if (!owner || !owner.alive){ continue; }
    const pool=[];
    if (gameDoc.cat) pool.push({kind:"cat", x:gameDoc.cat.x, y:gameDoc.cat.y});
    for (const [rid,r] of rats) pool.push({kind:"rat", id:rid, x:r.x,y:r.y});
    for (const [bid,br] of bears) pool.push({kind:"bear", id:bid, x:br.x,y:br.y});
    for (const [cid,ct] of caterpillars) pool.push({kind:"cater", id:cid, x:ct.x,y:ct.y});
    for (const [cwId,cw] of crows) pool.push({kind:"crow", id:cwId, x:cw.x,y:cw.y});
    for (const [gid,g] of golems) pool.push({kind:"golem", id:gid, x:g.x,y:g.y});
    const inR = pool.filter(e=> manhattan(b.x,b.y,e.x,e.y)<=8);
    if (inR.length){
      inR.sort((a,b2)=>manhattan(b.x,b.y,a.x,a.y)-manhattan(b.x,b.y,b2.x,b2.y));
      const t=inR[0];
      const p=findPath(b.x,b.y,t.x,t.y,true,false,occupied);
      let nx=b.x, ny=b.y;
      if (p && p.length>1){ nx=p[1][0]; ny=p[1][1]; }
      if (!occupied.has(key(nx,ny))){ await safeUpdate(doc(beetlesCol,id),{x:nx,y:ny}); occupied.delete(key(b.x,b.y)); occupied.add(key(nx,ny)); }
      if (nx===t.x && ny===t.y){
        await (t.kind==="cat" ? damageCat(beetleStats(b.lvl||1).dmg) : damageEnemy(t.kind,t.id,beetleStats(b.lvl||1).dmg));
      }
      continue;
    }
    const p2=findPath(b.x,b.y,owner.x,owner.y,true,false,occupied);
    if (p2 && p2.length>2){
      const s=p2[1]; const nx=s[0], ny=s[1];
      if (!occupied.has(key(nx,ny))){ await safeUpdate(doc(beetlesCol,id),{x:nx,y:ny}); occupied.delete(key(b.x,b.y)); occupied.add(key(nx,ny)); }
    }
  }
}

/* ------------------------------- Timers/loops ---------------------------- */
/* Pickup spawner stubs (no-op for now; safe globals) */
async function ensurePickupSpawner(){ }
async function pickupSpawnerTick(){ }

setInterval(async ()=>{ if (!me.alive) return; me.score += 10; await safeUpdate(doc(playersCol,myName),{score:me.score}); }, 20000);
setInterval(async ()=>{ if (!I_AM_HOST) return; const cp=(gameDoc.catPower||0)+1; await safeUpdate(gameRef,{catPower:cp}); }, 60000);

setInterval(async ()=>{ if (I_AM_HOST) await hostSpawnRatWave(); }, 12000);
setInterval(async ()=>{ if (I_AM_HOST) await hostSpawnBears(); }, 60000);
setInterval(async ()=>{ if (I_AM_HOST) await hostSpawnCaterpillars(); }, 15000);
setInterval(async ()=>{ if (I_AM_HOST) await hostSpawnCrows(); }, 30000);
setInterval(async ()=>{ if (I_AM_HOST) await hostSpawnGolems(); }, 45000);

/* AIs */
let catAITimer=null;
async function catAITick(){
  await hostCatAI();
  const mins = minutesSinceStart();
  const base = 500, factor = Math.pow(0.9, Math.max(0, mins)), delay = Math.max(120, Math.round(base * factor));
  catAITimer = setTimeout(catAITick, delay);
}
catAITick();
setInterval(hostRatsThink, 450);
setInterval(hostBearsThink, 650);
setInterval(hostCaterpillarsThink, 600);
setInterval(hostCrowsThink, 700);
setInterval(hostGolemsThink, 800);

/* turrets */
setInterval(hostTurrets, 250);

/* Factory income (gold generator) */
async function hostFactoryTick(){
  if (!I_AM_HOST) return;
  const incomePerTick = 3; // gold per factory per tick
  const byOwner = {};
  for (const s of structures.values()){
    if (s.t==="üè≠" && s.owner){
      byOwner[s.owner] = (byOwner[s.owner] || 0) + (s.cashRate || incomePerTick);
    }
  }
  const entries = Object.entries(byOwner);
  for (const [owner,amt] of entries){
    await safeUpdate(doc(playersCol, owner), { gold: increment(amt) });
  }
}
setInterval(hostFactoryTick, 2500);

/* pickups */
setInterval(async ()=>{ if (I_AM_HOST) await hostSpawnPickups(); }, 18000);
setInterval(ensurePickupSpawner, 3000);
setInterval(pickupSpawnerTick, 1500);

/* bombs fuse */
setInterval(async ()=>{
  if (!I_AM_HOST) return;
  const now=Date.now();
  for (const s of structures.values()){
    if (s.t==="üí£" && s.expAt && now>=s.expAt){
      await deleteStructureHost(s.x,s.y);
      await detonateAt(s.x,s.y);
    }
  }
}, 250);

/* powers driver (single loop) */
async function hostPowerTick(){
  if (!I_AM_HOST) return;

  // Offer chooser every 2 min
  const g = (await getDoc(gameRef)).data()||{};
  if ((g.nextPowerOfferAt||0) <= Date.now()){
    if (myName===g.host) showPowerOffer();
    await safeUpdate(gameRef,{ nextPowerOfferAt: Date.now() + 120000 });
  }

  const all = {...players}; all[myName] = {x:me.x,y:me.y,alive:me.alive,powers:me.powers};
  for (const [name,p] of Object.entries(all)){
    if (!p?.alive) continue;
    const px=p.x, py=p.y;
    const powers = p.powers || {};
    const now = Date.now();

    // Stone (auto walls + passive wall HP scaling via globalStoneLevel)
    if (powers.Stone && (powers.Stone.nextAt||0) <= now){
      const lvl=powers.Stone.lvl||1;
      globalStoneLevel = Math.max(globalStoneLevel, lvl);
      const attempts = (lvl>=3)?2:1;
      const cand = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
      for (let k=0;k<attempts;k++){
        for (let i=0;i<8;i++){
          const [dx,dy] = cand[Math.floor(Math.random()*cand.length)];
          const x=clamp(px+dx,1,gridSize-2), y=clamp(py+dy,1,gridSize-2);
          if (!tileOccupied(x,y)){ await placeStructureHost(x,y,"üß±", hpWall()); break; }
        }
      }
      const nextAt = now + powerPeriod("Stone",lvl);
      if (name===myName){ me.powers.Stone.nextAt = nextAt; await safeUpdate(doc(playersCol,myName),{powers:me.powers}); }
      else { await safeUpdate(doc(playersCol,name), { powers: {...powers, Stone:{lvl, nextAt} } }); }
    }

    // Ice (radius & duration scale by lvl)
    if (powers.Ice && (powers.Ice.nextAt||0) <= now){
      const lvl=powers.Ice.lvl||1;
      globalIceLevel = Math.max(globalIceLevel,lvl);
      const dur = Math.max(1500, (5000 - 400*(lvl-1)));
      const r=2 + (lvl>=3?1:0);
      renderFreezeArea(px,py,r);
      const inR = (ux,uy)=> Math.max(Math.abs(ux-px),Math.abs(uy-py))<=r;
      for (const [id,rn] of rats){ if (inR(rn.x,rn.y)) await safeUpdate(doc(ratsCol,id), { freezeUntil: now+dur }); }
      for (const [id,b] of bears){ if (inR(b.x,b.y)) await safeUpdate(doc(bearsCol,id), { freezeUntil: now+dur }); }
      for (const [id,c] of caterpillars){ if (inR(c.x,c.y)) await safeUpdate(doc(catsCol,id), { freezeUntil: now+dur }); }
      for (const [id,cw] of crows){ if (inR(cw.x,cw.y)) await safeUpdate(doc(crowsCol,id), { freezeUntil: now+dur }); }
      for (const [id,g] of golems){ if (inR(g.x,g.y)) await safeUpdate(doc(golemsCol,id), { freezeUntil: now+dur }); }
      const nextAt = now + powerPeriod("Ice",lvl);
      if (name===myName){ me.powers.Ice.nextAt = nextAt; await safeUpdate(doc(playersCol,myName),{powers:me.powers}); }
      else { await safeUpdate(doc(playersCol,name), { powers: {...powers, Ice:{lvl, nextAt} } }); }
    }

    // Lightning (chains, damage, passive turret synergy via globalLightningLevel)
    if (powers.Lightning && (powers.Lightning.nextAt||0) <= now){
      const lvl=powers.Lightning.lvl||1;
      globalLightningLevel = Math.max(globalLightningLevel,lvl);
      const rng=5; const dmg = 5 + 2*(lvl-1); const chains = 1 + (lvl-1);
      const pool=[];
      for (const [id,r] of rats){ pool.push({kind:"rat",id,x:r.x,y:r.y}); }
      for (const [id,b] of bears){ pool.push({kind:"bear",id,x:b.x,y:b.y}); }
      for (const [id,c] of caterpillars){ pool.push({kind:"cater",id,x:c.x,y:c.y}); }
      for (const [id,cw] of crows){ pool.push({kind:"crow",id,x:cw.x,y:cw.y}); }
      for (const [id,g] of golems){ pool.push({kind:"golem",id,x:g.x,y:g.y}); }
      pool.sort((a,b)=> manhattan(px,py,a.x,a.y) - manhattan(px,py,b.x,b.y));
      const inR = pool.filter(e=> manhattan(px,py,e.x,e.y)<=rng);
      let current=inR[0]; let hits=0; const hitSet=new Set();
      const sig=(e)=>e.kind+":"+(e.id??`${e.x},${e.y}`);
      while(current && hits<=chains){
        hitSet.add(sig(current));
        if (current.kind==="cat"){ await damageCat(dmg); }
        else { await damageEnemy(current.kind,current.id,dmg); }
        let next=null, best=1e9;
        for (const cand of inR){
          if (hitSet.has(sig(cand))) continue;
          const d = manhattan(current.x,current.y,cand.x,cand.y);
          if (d<=5 && d<best){ best=d; next=cand; }
        }
        current=next; hits++;
      }
      const nextAt = now + powerPeriod("Lightning",lvl);
      if (name===myName){ me.powers.Lightning.nextAt = nextAt; await safeUpdate(doc(playersCol,myName),{powers:me.powers}); }
      else { await safeUpdate(doc(playersCol,name), { powers: {...powers, Lightning:{lvl, nextAt} } }); }
    }

    // Fire (bigger damage + small knockback)
    if (powers.Fire && (powers.Fire.nextAt||0) <= now){
      const lvl=powers.Fire.lvl||1;
      globalFireLevel = Math.max(globalFireLevel,lvl);
      const r=2; const inR = (ux,uy)=> Math.max(Math.abs(ux-px),Math.abs(uy-py))<=r;
      renderExplosion(px,py);
      const doKnock = (obj,col,idKey,baseDmg)=>{
        if (!inR(obj.x,obj.y)) return;
        const hp=obj.hp-baseDmg;
        const dx=Math.sign(obj.x-px), dy=Math.sign(obj.y-py);
        const nx=clamp(obj.x+dx,1,gridSize-2), ny=clamp(obj.y+dy,1,gridSize-2);
        const ref = doc(col,idKey);
        if (hp<=0) safeDelete(ref); else safeUpdate(ref,{hp});
        if (!isBlocked(nx,ny)) safeUpdate(ref,{x:nx,y:ny});
      };
      for (const [id,rn] of rats){ doKnock(rn,ratsCol,id,10+3*(lvl-1)); }
      for (const [id,b] of bears){ doKnock(b,bearsCol,id,8+3*(lvl-1)); }
      for (const [id,c] of caterpillars){ if (inR(c.x,c.y)){ const hp=c.hp-(10+3*(lvl-1)); if (hp<=0) await safeDelete(doc(catsCol,id)); else await safeUpdate(doc(catsCol,id),{hp}); } }
      for (const [id,cw] of crows){ if (inR(cw.x,cw.y)){ const hp=cw.hp-(10+3*(lvl-1)); if (hp<=0) await safeDelete(doc(crowsCol,id)); else await safeUpdate(doc(crowsCol,id),{hp}); } }
      for (const [id,g] of golems){ if (inR(g.x,g.y)){ const hp=g.hp-(8+3*(lvl-1)); if (hp<=0) await safeDelete(doc(golemsCol,id)); else await safeUpdate(doc(golemsCol,id),{hp}); } }
      if (gameDoc.cat && inR(gameDoc.cat.x,gameDoc.cat.y)){ await damageCat(8+3*(lvl-1)); }
      const nextAt = now + powerPeriod("Fire",lvl);
      if (name===myName){ me.powers.Fire.nextAt = nextAt; await safeUpdate(doc(playersCol,myName),{powers:me.powers}); }
      else { await safeUpdate(doc(playersCol,name), { powers: {...powers, Fire:{lvl, nextAt} } }); }
    }

    // Fleas (spawn N fleas, N = lvl)
    if (powers.Fleas && (powers.Fleas.nextAt||0) <= now){
      const lvl=powers.Fleas.lvl||1;
      globalFleasLevel = Math.max(globalFleasLevel,lvl);
      const count = Math.max(1,lvl);
      const offsets=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
      for (let i=0;i<count;i++){
        const off = offsets[i%offsets.length];
        const fx=clamp(px+off[0],1,gridSize-2), fy=clamp(py+off[1],1,gridSize-2);
        await addDoc(fleasCol,{x:fx,y:fy,owner:name});
      }
      const nextAt = now + powerPeriod("Fleas",lvl);
      if (name===myName){ me.powers.Fleas.nextAt = nextAt; await safeUpdate(doc(playersCol,myName),{powers:me.powers}); }
      else { await safeUpdate(doc(playersCol,name), { powers: {...powers, Fleas:{lvl, nextAt} } }); }
    }

    // Beetles (cap per owner; stats scale)
    if (powers.Beetles && (powers.Beetles.nextAt||0) <= now){
      const lvl=powers.Beetles.lvl||1;
      globalBeetlesLevel = Math.max(globalBeetlesLevel,lvl);
      const existing = [...beetles.values()].filter(b=>b.owner===name).length;
      if (existing<6){
        const st = beetleStats(lvl);
        const off=[[1,0],[-1,0],[0,1],[0,-1]][Math.floor(Math.random()*4)];
        const bx=clamp(px+off[0],1,gridSize-2), by=clamp(py+off[1],1,gridSize-2);
        await addDoc(beetlesCol,{x:bx,y:by,hp:st.hp,max:st.hp,owner:name,lvl});
      }
      const nextAt = now + powerPeriod("Beetles",lvl);
      if (name===myName){ me.powers.Beetles.nextAt = nextAt; await safeUpdate(doc(playersCol,myName),{powers:me.powers}); }
      else { await safeUpdate(doc(playersCol,name), { powers: {...powers, Beetles:{lvl, nextAt} } }); }
    }
  }
}
setInterval(hostPowerTick, 1000);

/* Allies AI loops */
setInterval(hostFleaTick, 220);
setInterval(hostBeetleTick, 300);

/* game over detect */
setInterval(async ()=>{
  if (!I_AM_HOST || gameOverTriggered) return;
  const someoneAlive = me.alive || Object.values(players).some(p=>p.alive);
  if (!someoneAlive){
    gameOverTriggered = true;
    const teamScore = me.score + Object.values(players).reduce((a,p)=>a+(p.score||0),0);
    await addDoc(highsCol,{
      when:serverTimestamp(),
      names:[myName,...Object.keys(players)],
      score: teamScore
    });
    await updateMetaAfterRun(teamScore);
    await safeUpdate(gameRef,{
      gameOver:true,
      finalScore:teamScore,
      gameOverAt: Date.now()
    });
  }
}, 3000);

/* --------------------------- Enemy Spawning ------------------------------- */
async function hostSpawnRatWave(){
  if (!I_AM_HOST) return;
  const cat = gameDoc.cat || {x:gridSize-2,y:gridSize-2,h:50};
  const n = Math.max(2, (gameDoc.catPower||0));
  let spawned=0, tries=0;
  while(spawned<n && tries<100){
    tries++;
    const dx = (Math.random()<.5?-1:1) * (1+Math.floor(Math.random()*3));
    const dy = (Math.random()<.5?-1:1) * (1+Math.floor(Math.random()*3));
    const x = clamp(cat.x+dx,1,gridSize-2);
    const y = clamp(cat.y+dy,1,gridSize-2);
    if (isBlocked(x,y)) continue;
    const hp = 10 + (gameDoc.catPower||0)*3;
    await addDoc(ratsCol,{x,y,hp,max:hp,type:"rat"});
    spawned++;
  }
}
async function hostSpawnBears(){
  if (!I_AM_HOST) return;
  const mins = minutesSinceStart();
  if (mins < 4) return;
  const count = Math.max(1, mins - 3);
  let spawned=0, tries=0;
  while (spawned<count && tries<200){
    tries++;
    const x = 2 + Math.floor(Math.random()*(gridSize-4));
    const y = 2 + Math.floor(Math.random()*(gridSize-4));
    if (isBlocked(x,y)) continue;
    const hp = 45 + (mins-4)*10 + (gameDoc.catPower||0)*5;
    await addDoc(bearsCol,{x,y,hp,max:hp,type:"bear"});
    spawned++;
  }
}
async function hostSpawnCaterpillars(){
  if (!I_AM_HOST) return;
  const mins=minutesSinceStart(); if (mins<3) return;
  if (Math.random()<0.5){
    const x = 2 + Math.floor(Math.random()*(gridSize-4));
    const y = 2 + Math.floor(Math.random()*(gridSize-4));
    if (!isBlocked(x,y)) await addDoc(catsCol,{x,y,hp:12,max:12});
  }
}
async function hostSpawnCrows(){
  if (!I_AM_HOST) return;
  const mins=minutesSinceStart(); if (mins<7) return;
  const cat = gameDoc.cat || {x:gridSize-2,y:gridSize-2};
  const dx = (Math.random()<.5?-1:1) * (3+Math.floor(Math.random()*4));
  const dy = (Math.random()<.5?-1:1) * (3+Math.floor(Math.random()*4));
  const x = clamp(cat.x+dx,1,gridSize-2);
  const y = clamp(cat.y+dy,1,gridSize-2);
  await addDoc(crowsCol,{x,y,hp:7,max:7});
}
async function hostSpawnGolems(){
  if (!I_AM_HOST) return;
  const mins=minutesSinceStart(); if (mins<10) return;
  const cat = gameDoc.cat || {x:gridSize-2,y:gridSize-2};
  const num = Math.min(1 + Math.floor((mins-10)/5), 3);
  let spawned=0, tries=0;
  while(spawned<num && tries<200){
    tries++;
    const dx = (Math.random()<.5?-1:1) * (4+Math.floor(Math.random()*4));
    const dy = (Math.random()<.5?-1:1) * (4+Math.floor(Math.random()*4));
    const x = clamp(cat.x+dx,1,gridSize-2);
    const y = clamp(cat.y+dy,1,gridSize-2);
    if (isBlocked(x,y)) continue;
    const hp = 80 + (gameDoc.catPower||0)*10;
    await addDoc(golemsCol,{x,y,hp,max:hp,type:"golem"});
    spawned++;
  }
}

/* --------------------------- Cooldown HUD update -------------------------- */
function msLeft(t){ return Math.max(0,(t||0)-Date.now()); }
function fmt(ms){ const s=Math.ceil(ms/1000); return s<=0?"ready":`${s}s`; }
function drawCooldowns(){
  const p = me.powers||{};
  const order=["Fire","Lightning","Ice","Stone","Fleas","Beetles"];
  coolwrap.innerHTML="";
  for (const name of order){
    const cur = p[name]; const lvl = cur?.lvl||0; const eta = cur? fmt(msLeft(cur.nextAt)) : "‚Äî";
    const row=document.createElement('div'); row.className="cool";
    row.innerHTML = `<span>${powerIcon(name)} <b>${name}</b> <small style="opacity:.7">Lv${lvl}</small></span><span class="eta">${eta}</span>`;
    coolwrap.appendChild(row);
  }
}
setInterval(drawCooldowns, 250);

/* ----------------------------- Summary UI -------------------------------- */
function showSessionSummary(gdoc){
  if (summaryShown) return;
  summaryShown=true;
  const modal = document.getElementById("summaryModal");
  const subtitle = document.getElementById("summarySubtitle");
  const statsEl = document.getElementById("summaryStats");
  const start = gdoc.startMs || Date.now();
  const end = gdoc.gameOverAt || Date.now();
  const dur = Math.max(0,end-start);
  const finalScore = gdoc.finalScore || (me.score + Object.values(players).reduce((a,p)=>a+(p.score||0),0));
  subtitle.textContent = `Time survived: ${formatDuration(dur)}`;
  statsEl.innerHTML="";
  const addStat = (label,val)=>{ const row=document.createElement('div'); row.innerHTML=`<span>${label}</span><span>${val}</span>`; statsEl.appendChild(row); };
  addStat("Team Score", finalScore);
  addStat("Your Score", me.score);
  addStat("Cat Power Reached", gdoc.catPower||0);
  addStat("Total Runs (all time)", meta.totalRuns||0);
  addStat("Best Score (all time)", meta.bestScore||0);
  modal.style.display='flex';
}
document.getElementById("summaryClose").onclick=()=>{
  location.reload();
};

/* --------------------------------- Joysticks ----------------------------- */
function setupJoystick(el, onDir){
  const knob = el.querySelector('.knob');
  const rect = ()=> el.getBoundingClientRect();
  let active=false, cx=0, cy=0, maxR=50;
  const setKnob=(dx,dy)=>{ const r=Math.hypot(dx,dy), sc=r>maxR?maxR/r:1;
    knob.style.left=`calc(50% + ${(dx*sc)}px)`; knob.style.top=`calc(50% + ${(dy*sc)}px)`; };
  const dirFrom=(dx,dy)=>{ if (Math.hypot(dx,dy)<16) return {dx:0,dy:0};
    if (Math.abs(dx)>Math.abs(dy)) return {dx:Math.sign(dx),dy:0}; else return {dx:0,dy:Math.sign(dy)}; };
  const end=()=>{ active=false; setKnob(0,0); onDir({dx:0,dy:0}); };
  el.addEventListener('touchstart',e=>{ e.preventDefault(); active=true; const b=rect(); cx=b.left+b.width/2; cy=b.top+b.height/2; },{passive:false});
  el.addEventListener('touchmove',e=>{ if (!active) return; const t=e.touches[0]; const dx=t.clientX-cx, dy=t.clientY-cy; setKnob(dx,dy); onDir(dirFrom(dx,dy)); },{passive:false});
  el.addEventListener('touchend',e=>{ end(); },{passive:false});
  el.addEventListener('touchcancel',e=>{ end(); },{passive:false});
}
setInterval(()=>{ if (!me.alive) return; const moveDelay = Math.max(35, baseMoveDelay - 10*levels.speed); if (moveIntent.dx||moveIntent.dy) tryMove(moveIntent.dx,moveIntent.dy,moveDelay); }, 30);
setInterval(()=>{ if (!me.alive) return; if (buildIntent.dx||buildIntent.dy) tryBuild(buildIntent.dx,buildIntent.dy); }, 30);
setupJoystick(document.getElementById('moveJoy'), d=>{ moveIntent=d; });
setupJoystick(document.getElementById('buildJoy'), d=>{ buildIntent=d; });

window.addEventListener("keydown",e=>{
  if (e.key==="ArrowUp")  moveIntent={dx:0,dy:-1};
  if (e.key==="ArrowDown")moveIntent={dx:0,dy:1};
  if (e.key==="ArrowLeft")moveIntent={dx:-1,dy:0};
  if (e.key==="ArrowRight")moveIntent={dx:1,dy:0};
  if (e.key==="w") buildIntent={dx:0,dy:-1};
  if (e.key==="s") buildIntent={dx:0,dy:1};
  if (e.key==="a") buildIntent={dx:-1,dy:0};
  if (e.key==="d") buildIntent={dx:1,dy:0};
});
window.addEventListener("keyup",e=>{
  if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)) moveIntent={dx:0,dy:0};
  if (["w","a","s","d"].includes(e.key)) buildIntent={dx:0,dy:0};
});
document.getElementById("fsBtn").onclick=()=>{ const el=document.documentElement; if (document.fullscreenElement) document.exitFullscreen(); else el.requestFullscreen?.(); };

/* Upgrade panel toggle */
document.getElementById("upgradeHeader").onclick=()=>{
  const panel=document.getElementById("upgradePanel");
  panel.classList.toggle("collapsed");
  const label=panel.querySelector("#upgradeHeader .label");
  if (label){
    label.textContent = panel.classList.contains("collapsed") ? "‚¨á Upgrades" : "‚¨Ü Upgrades";
  }
};

/* --------------------------------- Boot ---------------------------------- */
(async function init(){
  me.x = 2 + Math.floor(Math.random()*6);
  me.y = 2 + Math.floor(Math.random()*6);
  me.powers = {};
  me.gold = me.gold || 0;
  await upsertMe();
  const g=await getDoc(gameRef);
  if (!g.exists() || !g.data()?.startMs){ await safeSet(gameRef,{startMs:Date.now()},{merge:true}); }
  await claimHost();
  await loadMeta();
  listen();
  if (I_AM_HOST) await hostSpawnPickups();
  setHeldUI();
  setHostBadge();
  updateGoldUI();
  renderUpgradesUI();
  render();
  showMetaOverlay();
})();
</script>
</body>
</html>















