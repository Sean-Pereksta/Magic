<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
<title>ğŸ­ Cat vs Mouse â€” Mobile Survival</title>
<style>
  :root{
    --bg:#0b1014; --ink:#e6efff; --muted:#9fb3c8; --panel:#0f172a; --line:#1f2a44;
    --good:#22c55e; --warn:#eab308; --bad:#ef4444; --accent:#60a5fa;
    --grass:#2f7d32; --edge:#58606b; --cell:28px; --view:17; --rad:14px;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Arial,sans-serif}

  /* HUD: Fullscreen â†’ Score â†’ Held */
  #hud{position:fixed;top:0;left:0;right:0;display:flex;gap:8px;align-items:center;
       padding:8px 10px;background:linear-gradient(180deg,rgba(10,16,26,.9),rgba(10,16,26,.35));backdrop-filter:blur(6px);z-index:10}
  .btn{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:10px;border:1px solid #2a3a60;background:#0f1a2e;color:#cfe6ff;text-decoration:none}
  .chip{display:inline-flex;gap:8px;align-items:center;background:#0e1726;border:1px solid #1f2a44;border-radius:999px;padding:6px 10px}
  .pill{padding:2px 8px;border-radius:999px;border:1px solid #2a3a60;background:#121c30;color:#9fb3d0}
  #scoreWrap b{font-weight:700}
  #heldWrap{min-width:160px}

  #main{padding-top:54px;display:flex;flex-direction:column;align-items:center;gap:10px}
  #stage{width:calc(var(--cell)*var(--view));height:calc(var(--cell)*var(--view));
         border:2px solid var(--line);border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.35);
         position:relative;overflow:hidden;background:repeating-linear-gradient(90deg,#2e6d31 0,#2e6d31 10px,#2a6a2d 10px,#2a6a2d 20px)}
  #grid{display:grid;grid-template-columns:repeat(var(--view),var(--cell));grid-template-rows:repeat(var(--view),var(--cell));}
  .cell{width:var(--cell);height:var(--cell);display:flex;align-items:center;justify-content:center;
        position:relative;font-size:20px;user-select:none}
  .edge{background:#6d747f}
  .grass{background:linear-gradient(135deg,#2f7d32,#275e28)}
  .hpbar{position:absolute;left:2px;right:2px;bottom:2px;height:4px;background:#263040;border-radius:3px;overflow:hidden}
  .hpbar>i{display:block;height:100%;background:#ff5252}
  .float{position:absolute;pointer-events:none;font-weight:700;animation:rise .8s ease-out forwards}
  @keyframes rise{0%{opacity:1;transform:translateY(0)}100%{opacity:0;transform:translateY(-16px)}}

  #pads{width:100%;max-width:860px;display:flex;justify-content:space-between;gap:12px;padding:8px 12px 14px}
  .joyWrap{flex:1;display:flex;align-items:center;justify-content:center}
  .joy{
    width:140px;height:140px;border-radius:50%;
    background:radial-gradient(120px at 50% 50%, #0e1726, #0c1422);
    border:1px solid #223154; position:relative; touch-action:none; box-shadow:0 8px 24px rgba(0,0,0,.35);
  }
  .joy .knob{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    width:78px; height:78px; border-radius:50%; background:#13233e; border:1px solid #2a3a60;
    box-shadow:inset 0 0 0 2px #0b1628;
  }
  .joy .hint{position:absolute; left:50%; top:50%; width:4px; height:4px; border-radius:50%; background:#3b5ea8; opacity:.7}
  .joyLabel{margin-top:6px; color:#a8c3ff; font-size:13px; text-align:center}

  #toast{position:fixed;bottom:16px;left:50%;transform:translateX(-50%);background:#0e1726;border:1px solid #1f2a44;
         padding:10px 14px;border-radius:10px;box-shadow:0 10px 24px rgba(0,0,0,.35);display:none;z-index:15}
</style>
</head>
<body>

<!-- HUD -->
<div id="hud">
  <a class="btn" id="fsBtn">â›¶ Full Screen</a>
  <div id="scoreWrap" class="chip">â­ Score: <b id="score">0</b></div>
  <div id="heldWrap" class="chip">
    <span>Held:</span><span id="heldIcon" class="pill">â€”</span><span id="heldCount" class="pill">0</span>
    <span id="hostBadge" class="pill">Client</span>
  </div>
</div>

<!-- Stage -->
<div id="main">
  <div id="stage"><div id="grid"></div></div>

  <!-- Dual Joysticks -->
  <div id="pads">
    <div class="joyWrap">
      <div id="moveJoy" class="joy">
        <div class="hint" style="transform:translate(-50%,-50%) translate(0,-48px)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(48px,0)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(0,48px)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(-48px,0)"></div>
        <div class="knob"></div>
      </div>
      <div class="joyLabel">Move</div>
    </div>
    <div class="joyWrap">
      <div id="buildJoy" class="joy">
        <div class="hint" style="transform:translate(-50%,-50%) translate(0,-48px)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(48px,0)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(0,48px)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(-48px,0)"></div>
        <div class="knob"></div>
      </div>
      <div class="joyLabel">Build (uses held)</div>
    </div>
  </div>
</div>

<div id="toast"></div>

<script type="module">
/* ----------------------------- Firebase setup ----------------------------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection,
  addDoc, deleteDoc, serverTimestamp, getDocs, query, where
} from "https://www.gstatic.com/firebasejs/10.11.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
};
const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);

/* ------------------------------- Params & State --------------------------- */
const url = new URLSearchParams(location.search);
const gameId = url.get("gameId") || "sandbox";
const myName = (url.get("username")||"Player").trim().toLowerCase();

const gridSize = 40, view = 17, cell = 28;
const gridEl = document.getElementById("grid");
const stageEl = document.getElementById("stage");
let camera = {x:0,y:0};

let I_AM_HOST = false;
let gameDoc = {};
let players = {};
let structures = new Map(); // key -> {x,y,t,hp,max,fire?,_next?}
let rats = new Map();       // id -> {x,y,hp,max,type:"rat"|"firerat"|"crow"}
let caterpillars = new Map();
let fleas = new Map();
let corpses = new Map();

let me = {x:2,y:2,alive:true,score:0};

/* Items & levels */
const BUILD_TYPES = ["ğŸ§±","ğŸ”«","ğŸ","ğŸ§¨","ğŸ›¢ï¸","âš¡","ğŸ”·","â•","ğŸ”€"];
let heldType = null; let heldCount = 0;

// per-type upgrade levels
let levels = {"ğŸ§±":0,"ğŸ”«":0,"ğŸ":0,"ğŸ§¨":0,"ğŸ›¢ï¸":0,"âš¡":0,"ğŸ”·":0,"â•":0};

/* Timers & gating */
let moveDelay = 120, buildDelay = 120, lastMoveAt=0, lastBuildAt=0;
let moveIntent = {dx:0,dy:0}, buildIntent={dx:0,dy:0};

const UNLOCK_MS = { "âš¡":3*60000, "ğŸ”·":4*60000, "â•":5*60000 }; // items & powerups
const ENEMY_MS = { firerat:5*60000, crow:7*60000 };
const CAT_DAMAGE = ()=> 3 + Math.floor((gameDoc.catPower||0)/2); // cap for repair tick

/* Firestore refs */
const gameRef = doc(db,"games",gameId);
const playersCol = collection(db,"games",gameId,"players");
const structsCol = collection(db,"games",gameId,"structures");
const ratsCol    = collection(db,"games",gameId,"rats");
const catsCol    = collection(db,"games",gameId,"caterpillars");
const fleasCol   = collection(db,"games",gameId,"fleas");
const corpsesCol = collection(db,"games",gameId,"corpses");

/* ------------------------------- UI helpers ------------------------------ */
const $ = s=>document.querySelector(s);
function toast(msg,ms=1200){ const el=$("#toast"); el.textContent=msg; el.style.display='block'; setTimeout(()=>el.style.display='none',ms); }
function setHostBadge(){ $("#hostBadge").textContent = I_AM_HOST? "ğŸ‘‘ Host" : "Client"; }
function setHeldUI(){ $("#heldIcon").textContent = heldType || "â€”"; $("#heldCount").textContent = heldCount || 0; }
function clamp(v,min,max){ return v<min?min:v>max?max:v; }
function focusCamera(){ camera.x=clamp(me.x-Math.floor(view/2),0,gridSize-view); camera.y=clamp(me.y-Math.floor(view/2),0,gridSize-view); }
function K(x,y){ return `${x}_${y}`; }
function inBounds(x,y){ return x>0 && y>0 && x<gridSize-1 && y<gridSize-1; }
function floatText(x,y,text,color="#fff"){
  const sx=(x-camera.x)*cell+cell/2, sy=(y-camera.y)*cell+cell/2;
  const el=document.createElement("div"); el.className="float";
  el.style.left=(sx-8)+"px"; el.style.top=(sy-6)+"px"; el.style.color=color; el.textContent=text;
  stageEl.appendChild(el); setTimeout(()=>el.remove(),800);
}

/* ---------------------------- Blocking & pathing ------------------------- */
function isBlockedForPlacement(x,y){
  const s=structures.get(K(x,y));
  return !!(s && ["ğŸ§±","ğŸ”«","ğŸ","âš¡","ğŸ”·","â•","ğŸ”€"].includes(s.t));
}
function isBlockedForGroundEnemy(x,y){
  if (!inBounds(x,y)) return true;
  const s=structures.get(K(x,y));
  return !!(s && ["ğŸ§±","ğŸ”«","ğŸ","âš¡","ğŸ”·","â•","ğŸ”€"].includes(s.t));
}
function findPath(sx,sy,tx,ty,blockFn){
  const Q=[[sx,sy]], P=new Map([[K(sx,sy),null]]), D=[[1,0],[-1,0],[0,1],[0,-1]];
  while(Q.length){
    const [x,y]=Q.shift(); if (x===tx&&y===ty) break;
    for(const [dx,dy] of D){
      const nx=x+dx, ny=y+dy;
      if (!inBounds(nx,ny) || P.has(K(nx,ny))) continue;
      if (blockFn(nx,ny) && !(nx===tx&&ny===ty)) continue;
      P.set(K(nx,ny),[x,y]); Q.push([nx,ny]);
    }
  }
  if (!P.has(K(tx,ty))) return null;
  const path=[]; let cur=[tx,ty]; while(cur){ path.push(cur); cur=P.get(K(cur[0],cur[1])); } path.reverse(); return path;
}

/* ---------------------------- Structure stats ---------------------------- */
function hpWall(){   return Math.round(60  * (1+0.15*levels["ğŸ§±"])); }
function hpTur(){    return Math.round(30  * (1+0.15*levels["ğŸ”«"])); }
function hpHive(){   return Math.round(35  * (1+0.15*levels["ğŸ"])); }
function hpArc(){    return Math.round(28  * (1+0.15*levels["âš¡"])); }
function hpNode(){   return Math.round(26  * (1+0.15*levels["ğŸ”·"])); }
function hpRepair(){ return Math.round(26  * (1+0.15*levels["â•"])); }
function hpRouter(){ return 24; }
function hpOil(){    return 18 + 4*levels["ğŸ›¢ï¸"]; } // destructible
function hpMine(){   return 10 + 2*levels["ğŸ§¨"]; }

function dmgTurret(){ return Math.round(6 * (1+0.25*levels["ğŸ”«"])); }
function dmgArc(){    return Math.round(5 * (1+0.25*levels["âš¡"])); }
function arcChains(){ return 1 + Math.floor(levels["âš¡"]/3); }
function powerBuffPct(){ return 0.20 + 0.08*levels["ğŸ”·"]; } // % buff to ğŸ”« & âš¡
function repairPerNode(){ return 1 + Math.floor(1+levels["â•"]*0.6); }

function mineBurst(){  return 8 + 3*levels["ğŸ§¨"]; }
function oilSlow(){    return 1 + Math.min(3, Math.floor(levels["ğŸ›¢ï¸"]/2)); }
function oilBurnDmg(){ return 2 + Math.floor(levels["ğŸ›¢ï¸"]/2); }

/* ------------------------------- Rendering ------------------------------- */
function render(){
  focusCamera(); gridEl.innerHTML="";
  for(let ry=0; ry<view; ry++){
    for(let rx=0; rx<view; rx++){
      const gx=camera.x+rx, gy=camera.y+ry;
      const c=document.createElement("div"); c.className="cell "+((gx===0||gy===0||gx===gridSize-1||gy===gridSize-1)?"edge":"grass");
      let glyph="";

      const s=structures.get(K(gx,gy));
      if (s){
        if (s.t==="ğŸ›¢ï¸" && s.fire>0) glyph="ğŸ”¥"; else glyph=s.t;
        if (["ğŸ§±","ğŸ”«","ğŸ","âš¡","ğŸ”·","â•","ğŸ”€"].includes(s.t)){
          const bar=document.createElement("div"); bar.className="hpbar";
          const fill=document.createElement("i"); fill.style.width=((s.hp||0)/(s.max||1)*100)+"%";
          bar.appendChild(fill); c.appendChild(bar);
        }
      }
      if (s && /^â­•/.test(s.t)) glyph=s.t.replace("â­•","");
      if (s && /^ğŸ”º/.test(s.t)) glyph=s.t; // show triangle

      for(const f of fleas.values()) if (f.x===gx&&f.y===gy) glyph="ğŸ";
      for(const [id,r] of rats) if (r.x===gx&&r.y===gy){
        glyph=(r.type==="crow"?"ğŸ¦":(r.type==="firerat"?"ğŸ”¥ğŸ€":"ğŸ€"));
        const bar=document.createElement("div"); bar.className="hpbar";
        const fill=document.createElement("i"); fill.style.width=((r.hp||0)/(r.max||1)*100)+"%";
        bar.appendChild(fill); c.appendChild(bar);
      }
      for(const [id,ct] of caterpillars) if (ct.x===gx&&ct.y===gy) glyph="ğŸ›";
      if (corpses.has(K(gx,gy))) glyph="ğŸª¦";

      for(const [n,p] of Object.entries(players)) if (p.alive && p.x===gx && p.y===gy) glyph="ğŸ­";
      if (me.alive && me.x===gx && me.y===gy) glyph="ğŸ­";

      c.textContent=glyph; gridEl.appendChild(c);
    }
  }
  $("#score").textContent = me.score;
  setHostBadge();
}

/* ------------------------------ Firestore IO ----------------------------- */
async function claimHost(){
  const s=await getDoc(gameRef); const d=s.exists()?s.data():{};
  if (!d.host){
    await setDoc(gameRef,{host:myName,startMs:Date.now(),catPower:0,lastFirerat:0,lastCrow:0},{merge:true});
    I_AM_HOST=true;
  }else I_AM_HOST=(d.host===myName);
  setHostBadge(); render();
}
async function upsertMe(){ await setDoc(doc(playersCol,myName),{x:me.x,y:me.y,alive:me.alive,score:me.score,displayName:myName},{merge:true}); }
function listen(){
  onSnapshot(gameRef,(s)=>{ if (!s.exists()) return; gameDoc=s.data(); render(); });
  onSnapshot(playersCol,(snap)=>{ const next={}; snap.forEach(d=>{ if (d.id!==myName) next[d.id]=d.data(); }); players=next; render(); });
  onSnapshot(structsCol,(snap)=>{ const m=new Map(); snap.forEach(d=>{ const v=d.data(); m.set(K(v.x,v.y),v); }); structures=m; render(); });
  onSnapshot(ratsCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(d.id,d.data())); rats=m; render(); });
  onSnapshot(catsCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(d.id,d.data())); caterpillars=m; render(); });
  onSnapshot(fleasCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(d.id,d.data())); fleas=m; render(); });
  onSnapshot(corpsesCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(K(d.data().x,d.data().y), d.id)); corpses=m; render(); });
}

/* ------------------------------- Host helpers ---------------------------- */
async function placeStructureHost(x,y,t,hp,extra={}){ await setDoc(doc(structsCol,K(x,y)),{x,y,t,hp,max:hp,fire:0,...extra}); }
async function damageStructureHost(x,y,amt){
  const id=K(x,y); const s=structures.get(id); if (!s) return;
  const hp=Math.max(0,(s.hp||0)-amt);
  if (hp<=0) await deleteDoc(doc(structsCol,id));
  else await updateDoc(doc(structsCol,id),{hp});
}

function now(){ return Date.now(); }
function msSinceStart(){ return now() - (gameDoc.startMs||now()); }
function unlocked(t){ return !UNLOCK_MS[t] || msSinceStart()>=UNLOCK_MS[t]; }

/* --------------------------- Spawn pickups (host) ------------------------ */
async function hostSpawnPickups(){
  // item pool by unlocks
  const base = ["ğŸ§±","ğŸ”«","ğŸ","ğŸ§¨","ğŸ›¢ï¸"];
  const gated = ["âš¡","ğŸ”·","â•"].filter(unlocked);
  const pool = [...base, ...gated];

  // place 3 item pickups
  let placed=0, tries=0;
  while(placed<3 && tries<50){
    tries++;
    const x=2+Math.floor(Math.random()*(gridSize-4));
    const y=2+Math.floor(Math.random()*(gridSize-4));
    if (structures.get(K(x,y))) continue;
    const t="â­•"+pool[Math.floor(Math.random()*pool.length)];
    await placeStructureHost(x,y,t,1); placed++;
  }
  // 1 upgrade triangle respecting unlocks
  const upPool = pool;
  if (Math.random()<0.45 && upPool.length){
    let px=0,py=0,c=0;
    while(c<30){
      c++; px=2+Math.floor(Math.random()*(gridSize-4)); py=2+Math.floor(Math.random()*(gridSize-4));
      if (!structures.get(K(px,py))) break;
    }
    if (!structures.get(K(px,py))){
      const t="ğŸ”º"+ upPool[Math.floor(Math.random()*upPool.length)];
      await placeStructureHost(px,py,t,1);
    }
  }
}

/* ------------------------------- Enemies --------------------------------- */
function enemyStats(type){
  if (type==="rat")     return {hp:10,max:10};
  if (type==="firerat") return {hp:14,max:14};
  if (type==="crow")    return {hp:12,max:12}; // flies
  return {hp:10,max:10};
}
async function hostSpawnRats(n=3){
  let spawned=0, tries=0;
  while(spawned<n && tries<80){
    tries++;
    const x=gridSize-2 - Math.floor(Math.random()*3);
    const y=2 + Math.floor(Math.random()*(gridSize-4));
    if (isBlockedForGroundEnemy(x,y)) continue;
    const st=enemyStats("rat");
    await addDoc(ratsCol,{x,y,hp:st.hp,max:st.max,type:"rat"});
    spawned++;
  }
}
async function hostSpawnFireRat(){
  const st=enemyStats("firerat");
  const x=gridSize-2 - Math.floor(Math.random()*3);
  const y=2 + Math.floor(Math.random()*(gridSize-4));
  if (isBlockedForGroundEnemy(x,y)) return;
  await addDoc(ratsCol,{x,y,hp:st.hp,max:st.max,type:"firerat"});
}
async function hostSpawnCrow(){
  const st=enemyStats("crow");
  const x=gridSize-2 - Math.floor(Math.random()*3);
  const y=2 + Math.floor(Math.random()*(gridSize-4));
  await addDoc(ratsCol,{x,y,hp:st.hp,max:st.max,type:"crow"});
}

/* ------------------------------ Towers / Nodes --------------------------- */
function nearbyStructs(cx,cy,r,filterFn){ const out=[]; for(const s of structures.values()){ if (Math.abs(s.x-cx)+Math.abs(s.y-cy)<=r && (!filterFn || filterFn(s))) out.push(s);} return out; }

async function hostTurretsAndArcTick(){
  if (!I_AM_HOST) return;

  for (const s of structures.values()){
    // Power/Repair effects apply as auras
    if (s.t==="ğŸ”·"){ /* power node aura handled in damage calc via lookup */ }
    if (s.t==="â•"){
      const heals = repairPerNode();
      // heal nearby structures but cap total heal per tile to CAT_DAMAGE()
      for (const t of nearbyStructs(s.x,s.y,2, ss=>["ğŸ§±","ğŸ”«","ğŸ","âš¡"].includes(ss.t))){
        const cap=CAT_DAMAGE(); const cur = (t._healTick||0);
        const can = Math.max(0, cap - cur);
        const give = Math.min(can, heals);
        if (give>0){
          const nh = Math.min(t.max, (t.hp||0)+give);
          await updateDoc(doc(structsCol,K(t.x,t.y)),{hp:nh});
          t._healTick = cur + give;
        }
      }
    }

    // Turret fire
    if (s.t==="ğŸ”«"){
      const rng=5; let bestId=null, bestD=1e9;
      for(const [id,r] of rats){
        const d=Math.abs(r.x-s.x)+Math.abs(r.y-s.y);
        if (d<bestD && d<=rng){ bestD=d; bestId=id; }
      }
      if (bestId){
        // power node buff
        const buffs = nearbyStructs(s.x,s.y,2, ss=>ss.t==="ğŸ”·").length;
        const mult = 1 + powerBuffPct()*buffs;
        const dmg = Math.round(dmgTurret()*mult);
        const r = rats.get(bestId); if (!r) continue;
        const nh=(r.hp||0)-dmg; if (nh<=0) await deleteDoc(doc(ratsCol,bestId));
        else await updateDoc(doc(ratsCol,bestId),{hp:nh});
        floatText(s.x,s.y,"ğŸ”«","#aef");
      }
    }

    // Arc tower chain
    if (s.t==="âš¡"){
      const rng=4; let firstId=null, bestD=1e9;
      for(const [id,r] of rats){
        const d=Math.abs(r.x-s.x)+Math.abs(r.y-s.y);
        if (d<bestD && d<=rng){ bestD=d; firstId=id; }
      }
      if (!firstId) continue;
      const chainN = arcChains();
      let chainTargets=[firstId];

      // find additional closest rats to the last
      let last = rats.get(firstId);
      for(let jump=0;jump<chainN;jump++){
        let nextId=null, nd=1e9;
        for(const [id,r] of rats){
          if (chainTargets.includes(id)) continue;
          const d=Math.abs(r.x-last.x)+Math.abs(r.y-last.y);
          if (d<nd && d<=3){ nd=d; nextId=id; }
        }
        if (!nextId) break;
        chainTargets.push(nextId); last = rats.get(nextId);
      }

      // power node buff
      const buffs = nearbyStructs(s.x,s.y,2, ss=>ss.t==="ğŸ”·").length;
      const mult = 1 + powerBuffPct()*buffs;
      const dmg = Math.round(dmgArc()*mult);

      for(const id of chainTargets){
        const r=rats.get(id); if (!r) continue;
        const nh=(r.hp||0)-dmg; if (nh<=0) await deleteDoc(doc(ratsCol,id));
        else await updateDoc(doc(ratsCol,id),{hp:nh});
      }
      floatText(s.x,s.y,"âš¡","#9ff");
    }
  }

  // reset per-tile heal cap accumulator each tick window
  for (const s of structures.values()){ if (s._healTick) delete s._healTick; }
}

/* ------------------------------- Fleas / Router -------------------------- */
async function hostHiveAndFleaTick(){
  if (!I_AM_HOST) return;
  const nowMs=Date.now();
  for(const h of structures.values()){
    if (h.t!=="ğŸ") continue;
    if (!h._next) h._next = nowMs + Math.max(900, 1800 * (1 - 0.15*levels["ğŸ"]));
    if (nowMs < h._next) continue;
    h._next = nowMs + Math.max(900, 1800 * (1 - 0.15*levels["ğŸ"]));
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    for (const [dx,dy] of dirs){
      const nx=h.x+dx, ny=h.y+dy;
      if (!inBounds(nx,ny) || isBlockedForGroundEnemy(nx,ny)) continue;
      let occ=false; for(const f of fleas.values()) if (f.x===nx&&f.y===ny){occ=true;break;}
      if (occ) continue;
      await addDoc(fleasCol,{x:nx,y:ny,life:25}); break;
    }
  }

  // Flea routing & duplication on router
  for (const [id,f] of fleas){
    // If within 5 of any hive thatâ€™s within 5 of a router, target nearest router
    let rx=null, ry=null, best=1e9;
    for(const r of structures.values()){
      if (r.t!=="ğŸ”€") continue;
      for(const h of structures.values()){
        if (h.t!=="ğŸ") continue;
        const dh = Math.abs(h.x-r.x)+Math.abs(h.y-r.y);
        const df = Math.abs(f.x-r.x)+Math.abs(f.y-r.y);
        if (dh<=5 && df<best && df<=8){ best=df; rx=r.x; ry=r.y; }
      }
    }
    let tx=f.x, ty=f.y;
    if (rx!==null){ tx=rx; ty=ry; } else {
      // otherwise chase nearest enemy
      let bestD=1e9, pick=null;
      for(const r of rats.values()){
        const d=Math.abs(r.x-f.x)+Math.abs(r.y-f.y);
        if (d<bestD){ bestD=d; pick=r; }
      }
      if (pick){ tx=pick.x; ty=pick.y; }
    }
    const dx = Math.sign(tx-f.x), dy=Math.sign(ty-f.y);
    const nx = clamp(f.x + (Math.abs(tx-f.x)>=Math.abs(ty-f.y)?dx:0),1,gridSize-2);
    const ny = clamp(f.y + (Math.abs(tx-f.x)< Math.abs(ty-f.y)?dy:0),1,gridSize-2);

    // duplicate if passing through router
    const isRouter = structures.get(K(nx,ny))?.t==="ğŸ”€";
    if (isRouter && Math.random()<0.35){ await addDoc(fleasCol,{x:nx,y:ny,life:20}); }

    await updateDoc(doc(fleasCol,id),{x:nx,y:ny,life:f.life-1});

    // bite
    for(const [rid,r] of rats){
      if (r.x===nx && r.y===ny){
        const nh=(r.hp||0)-5; if (nh<=0) await deleteDoc(doc(ratsCol,rid)); else await updateDoc(doc(ratsCol,rid),{hp:nh});
      }
    }
    if (f.life-1<=0) await deleteDoc(doc(fleasCol,id));
  }
}

/* ------------------------------- Rat AI ---------------------------------- */
function nearestTargetForEnemy(ex,ey,fly=false){
  const targets=[];
  if (me.alive) targets.push({x:me.x,y:me.y,kind:"mouse"});
  for(const [n,p] of Object.entries(players)) if (p.alive) targets.push({x:p.x,y:p.y,kind:"mouse"});
  for(const s of structures.values()) if (["ğŸ§±","ğŸ”«","ğŸ","âš¡","ğŸ”·","â•","ğŸ”€","ğŸ§¨","ğŸ›¢ï¸"].includes(s.t)) targets.push({x:s.x,y:s.y,kind:"struct"});
  if (!targets.length) return null;
  targets.sort((a,b)=>(Math.abs(a.x-ex)+Math.abs(a.y-ey))-(Math.abs(b.x-ex)+Math.abs(b.y-ey)));
  return targets[0];
}
async function hostRatsThink(){
  if (!I_AM_HOST) return;
  for(const [id,r] of rats){
    const fly = (r.type==="crow");
    const t = nearestTargetForEnemy(r.x,r.y,fly);
    if (!t) continue;

    // move
    if (fly){
      const dx = Math.sign(t.x - r.x), dy = Math.sign(t.y - r.y);
      const nx = r.x + (Math.abs(t.x-r.x)>=Math.abs(t.y-r.y)?dx:0);
      const ny = r.y + (Math.abs(t.x-r.x)< Math.abs(t.y-r.y)?dy:0);
      await updateDoc(doc(ratsCol,id),{x:nx,y:ny});
    }else{
      const p=findPath(r.x,r.y,t.x,t.y,isBlockedForGroundEnemy);
      if (p && p.length>1){
        const step=p[1]; await updateDoc(doc(ratsCol,id),{x:step[0],y:step[1]});
      }
    }

    // interact after step
    const cur=rats.get(id) || r; const rx=cur.x, ry=cur.y;
    const s=structures.get(K(rx,ry));

    // Oil: slow & ignite on fire rat
    if (s && s.t==="ğŸ›¢ï¸"){
      if (r.type==="firerat") await updateDoc(doc(structsCol,K(rx,ry)),{fire:1500});
    }

    // Spikemine: burst & consume
    if (s && s.t==="ğŸ§¨"){
      const dmg = mineBurst(); const nh=(cur.hp||0)-dmg;
      floatText(rx,ry,"-"+dmg,"#f88");
      if (nh<=0) await deleteDoc(doc(ratsCol,id)); else await updateDoc(doc(ratsCol,id),{hp:nh});
      await deleteDoc(doc(structsCol,K(rx,ry)));
      continue;
    }

    // Attack structure
    if (s && ["ğŸ§±","ğŸ”«","ğŸ","âš¡","ğŸ”·","â•","ğŸ”€","ğŸ›¢ï¸"].includes(s.t)){
      let dmg = 1 + Math.floor((gameDoc.catPower||0)/3);
      if (r.type==="firerat" && s.t==="ğŸ§±"){ // bonus vs wall + burn spread
        dmg += 2;
        const newFire = Math.max(s.fire||0, 2500); // short DOT burn
        await updateDoc(doc(structsCol,K(rx,ry)),{fire:newFire});
        // 50% spread to adjacent walls
        const adj=[[1,0],[-1,0],[0,1],[0,-1]];
        for(const [dx,dy] of adj){
          const a=structures.get(K(rx+dx,ry+dy));
          if (a && a.t==="ğŸ§±" && Math.random()<0.5){
            await updateDoc(doc(structsCol,K(a.x,a.y)),{fire:2000});
          }
        }
      }
      await damageStructureHost(rx,ry,dmg);
    }

    // Attack mice
    if (t.kind==="mouse" && rx===t.x && ry===t.y){
      // kill target mouse
      if (t.x===me.x && t.y===me.y && me.alive){ me.alive=false; await updateDoc(doc(playersCol,myName),{alive:false}); await addDoc(corpsesCol,{x:rx,y:ry}); }
      for (const [n,p] of Object.entries(players)){
        if (p.alive && p.x===rx && p.y===ry){ await updateDoc(doc(playersCol,n),{alive:false}); await addDoc(corpsesCol,{x:rx,y:ry}); }
      }
    }
  }
}

/* ------------------------------ Caterpillars ----------------------------- */
async function hostCaterpillarsThink(){
  if (!I_AM_HOST) return;
  for(const [id,c] of caterpillars){
    let target=null, best=1e9;
    for(const s of structures.values()){
      if (!["ğŸ§±","ğŸ”«"].includes(s.t)) continue;
      const d=Math.abs(s.x-c.x)+Math.abs(s.y-c.y);
      if (d<best){ best=d; target=s; }
    }
    if (!target) continue;
    const p=findPath(c.x,c.y,target.x,target.y,(x,y)=>isBlockedForGroundEnemy(x,y)&&!(x===target.x&&y===target.y));
    if (p && p.length>1){
      const step=p[1]; await updateDoc(doc(catsCol,id),{x:step[0],y:step[1]});
    }else if (c.x===target.x && c.y===target.y){
      await damageStructureHost(c.x,c.y,20); await deleteDoc(doc(catsCol,id));
    }
  }
}

/* ------------------------------- Host spawners --------------------------- */
async function hostWaves(){
  if (!I_AM_HOST) return;
  // Base waves
  await hostSpawnRats(2 + Math.floor((gameDoc.catPower||0)/2));

  // Timed specials
  if (msSinceStart()>=ENEMY_MS.firerat){
    const last = gameDoc.lastFirerat||0;
    if (now()-last>=30000){ await hostSpawnFireRat(); await updateDoc(gameRef,{lastFirerat:now()}); }
  }
  if (msSinceStart()>=ENEMY_MS.crow){
    const last = gameDoc.lastCrow||0;
    if (now()-last>=30000){ await hostSpawnCrow(); await updateDoc(gameRef,{lastCrow:now()}); }
  }
}

/* ------------------------------- Oil burning ----------------------------- */
async function hostEnvironmentalTick(){
  if (!I_AM_HOST) return;
  for (const s of structures.values()){
    if (s.t==="ğŸ›¢ï¸" && s.fire>0){
      // burning oil: DOT to enemies on tile
      for(const [id,r] of rats){
        if (r.x===s.x && r.y===s.y){
          const nh=(r.hp||0)-oilBurnDmg(); if (nh<=0) await deleteDoc(doc(ratsCol,id)); else await updateDoc(doc(ratsCol,id),{hp:nh});
        }
      }
      const nf = Math.max(0,(s.fire||0)-200);
      await updateDoc(doc(structsCol,K(s.x,s.y)),{fire:nf});
    }
    if (s.t==="ğŸ§±" && s.fire>0){
      // burning wall: DOT to self
      const nh = Math.max(0,(s.hp||0)-2);
      const nf = Math.max(0,(s.fire||0)-200);
      if (nh<=0) await deleteDoc(doc(structsCol,K(s.x,s.y)));
      else await updateDoc(doc(structsCol,K(s.x,s.y)),{hp:nh,fire:nf});
    }
  }
}

/* -------------------------- Player movement & build ---------------------- */
function tileOccupied(x,y){ return !!structures.get(K(x,y)); } // for placement only

async function tryMove(dx,dy){
  if (!me.alive) return;
  if (Date.now()-lastMoveAt<moveDelay) return;
  const nx=clamp(me.x+dx,1,gridSize-2), ny=clamp(me.y+dy,1,gridSize-2);
  me.x=nx; me.y=ny; lastMoveAt=Date.now(); await upsertMe();

  // pickups & upgrades
  const s=structures.get(K(nx,ny));
  if (s){
    if (/^â­•/.test(s.t)){
      const itm=s.t.replace("â­•","");
      // give charges
      const charges = { "ğŸ§±":20, "ğŸ”«":3, "ğŸ":2, "ğŸ§¨":3, "ğŸ›¢ï¸":4, "âš¡":1, "ğŸ”·":1, "â•":1, "ğŸ”€":1 }[itm]||1;
      heldType=itm; heldCount=charges; await deleteDoc(doc(structsCol,K(nx,ny))); toast(`Held ${itm} x${charges}`);
    }
    if (/^ğŸ”º/.test(s.t)){
      const up=s.t.replace("ğŸ”º","");
      levels[up] = (levels[up]||0)+1;
      await deleteDoc(doc(structsCol,K(nx,ny)));
      toast(`${up} upgraded`);
    }
    setHeldUI();
  }

  // revive
  if (corpses.has(K(nx,ny))){
    const qs = await getDocs(query(corpsesCol, where("x","==",nx), where("y","==",ny)));
    qs.forEach(async d=> await deleteDoc(d.ref));
    const candidates=[myName, ...Object.entries(players).filter(([,p])=>!p.alive).map(([n])=>n)];
    const pick=[...new Set(candidates)][0];
    if (pick){ await updateDoc(doc(playersCol,pick),{alive:true,x:nx,y:ny}); me.score+=100; await updateDoc(doc(playersCol,myName),{score:me.score}); toast("ğŸ©¹ Revived +100"); }
  }

  render();
}
async function tryBuild(dx,dy){
  if (!me.alive) return;
  if (Date.now()-lastBuildAt<buildDelay) return;
  if (!heldType || heldCount<=0){ toast("No held item"); return; }
  const tx=clamp(me.x+dx,1,gridSize-2), ty=clamp(me.y+dy,1,gridSize-2);
  if (tileOccupied(tx,ty)) return;

  let hp=10;
  if (heldType==="ğŸ§±") hp=hpWall();
  if (heldType==="ğŸ”«") hp=hpTur();
  if (heldType==="ğŸ") hp=hpHive();
  if (heldType==="ğŸ§¨") hp=hpMine();
  if (heldType==="ğŸ›¢ï¸") hp=hpOil();
  if (heldType==="âš¡")  hp=hpArc();
  if (heldType==="ğŸ”·")  hp=hpNode();
  if (heldType==="â•")  hp=hpRepair();
  if (heldType==="ğŸ”€")  hp=hpRouter();

  // respect unlocks for âš¡ ğŸ”· â• (and their triangles handled at spawn time)
  if (["âš¡","ğŸ”·","â•"].includes(heldType) && !unlocked(heldType)){ toast(`${heldType} not unlocked yet`); return; }

  await placeStructureHost(tx,ty,heldType,hp);
  heldCount--; lastBuildAt=Date.now(); setHeldUI(); render();
}

/* ---------------------------- Game ticks & loops ------------------------- */
function anyMouseAlive(){ if (me.alive) return true; return Object.values(players).some(p=>p.alive); }

// Score drip
setInterval(async ()=>{ if (!me.alive) return; me.score += 10; await updateDoc(doc(playersCol,myName),{score:me.score}); }, 20000);

// Difficulty scaler (for caps/AI)
setInterval(async ()=>{ if (!I_AM_HOST) return; const cp=(gameDoc.catPower||0)+1; await updateDoc(gameRef,{catPower:cp}); }, 60000);

// Host drivers
setInterval(async ()=>{ if (I_AM_HOST) await hostSpawnPickups(); }, 18000);
setInterval(async ()=>{ if (I_AM_HOST) await hostWaves(); }, 12000);
setInterval(async ()=>{ if (I_AM_HOST) await hostTurretsAndArcTick(); }, 900);
setInterval(async ()=>{ if (I_AM_HOST) await hostHiveAndFleaTick(); }, 700);
setInterval(async ()=>{ if (I_AM_HOST) await hostRatsThink(); }, 450);
setInterval(async ()=>{ if (I_AM_HOST) await hostCaterpillarsThink(); }, 1200);
setInterval(async ()=>{ if (I_AM_HOST) await hostEnvironmentalTick(); }, 300);

// Joystick setup
function setupJoystick(el, onDir){
  const knob=el.querySelector('.knob'); let active=false, cx=0, cy=0; const maxR=50;
  function setKnob(dx,dy){ const r=Math.hypot(dx,dy), s=r>maxR?maxR/r:1; knob.style.left=`calc(50% + ${(dx*s)}px)`; knob.style.top=`calc(50% + ${(dy*s)}px)`; }
  function dir(dx,dy){ if (Math.hypot(dx,dy)<16) return {dx:0,dy:0}; return (Math.abs(dx)>Math.abs(dy))?{dx:Math.sign(dx),dy:0}:{dx:0,dy:Math.sign(dy)}; }
  function end(){ active=false; setKnob(0,0); onDir({dx:0,dy:0}); }
  el.addEventListener('touchstart',e=>{ e.preventDefault(); active=true; const b=el.getBoundingClientRect(); cx=b.left+b.width/2; cy=b.top+b.height/2; },{passive:false});
  el.addEventListener('touchmove',e=>{ if (!active) return; const t=e.touches[0]; const dx=t.clientX-cx, dy=t.clientY-cy; setKnob(dx,dy); onDir(dir(dx,dy)); },{passive:false});
  el.addEventListener('touchend',()=>end(),{passive:false});
  el.addEventListener('touchcancel',()=>end(),{passive:false});
}
setupJoystick(document.getElementById('moveJoy'), d=>{ moveIntent=d; });
setupJoystick(document.getElementById('buildJoy'), d=>{ buildIntent=d; });
// Keyboard (desktop)
window.addEventListener("keydown",e=>{
  if (e.key==="ArrowUp")  moveIntent={dx:0,dy:-1};
  if (e.key==="ArrowDown")moveIntent={dx:0,dy:1};
  if (e.key==="ArrowLeft")moveIntent={dx:-1,dy:0};
  if (e.key==="ArrowRight")moveIntent={dx:1,dy:0};
  if (e.key==="w") buildIntent={dx:0,dy:-1};
  if (e.key==="s") buildIntent={dx:0,dy:1};
  if (e.key==="a") buildIntent={dx:-1,dy:0};
  if (e.key==="d") buildIntent={dx:1,dy:0};
});
window.addEventListener("keyup",e=>{
  if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)) moveIntent={dx:0,dy:0};
  if (["w","a","s","d"].includes(e.key)) buildIntent={dx:0,dy:0};
});

// Repeater ticks (decoupled from delays; delays enforced inside tryMove/tryBuild)
setInterval(()=>{ if (moveIntent.dx||moveIntent.dy) tryMove(moveIntent.dx,moveIntent.dy); }, 30);
setInterval(()=>{ if (buildIntent.dx||buildIntent.dy) tryBuild(buildIntent.dx,buildIntent.dy); }, 30);

// Full screen
$("#fsBtn").onclick=()=>{ const el=document.documentElement; if (document.fullscreenElement) document.exitFullscreen(); else el.requestFullscreen?.(); };

/* --------------------------------- Boot ---------------------------------- */
(async function init(){
  me.x = 2 + Math.floor(Math.random()*6);
  me.y = 2 + Math.floor(Math.random()*6);
  await upsertMe();
  await claimHost();
  listen();
  if (I_AM_HOST) await hostSpawnPickups();
  setHeldUI(); render();
})();
</script>
</body>
</html>



