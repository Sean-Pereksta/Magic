<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
<title>üê≠ Cat vs Mouse ‚Äî Mobile Survival</title>
<style>
  :root{
    --bg:#0b1014; --ink:#e6efff; --muted:#9fb3c8; --panel:#0f172a; --line:#1f2a44;
    --good:#22c55e; --warn:#eab308; --bad:#ef4444; --accent:#60a5fa;
    --grass:#2f7d32; --edge:#58606b; --cell:28px; --view:17; --rad:14px;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Arial,sans-serif}
  #hud{position:fixed;top:0;left:0;right:0;display:flex;gap:8px;align-items:center;justify-content:space-between;
       padding:8px 12px;background:linear-gradient(180deg,rgba(10,16,26,.85),rgba(10,16,26,.35));backdrop-filter:blur(6px);z-index:10}
  #hud b{font-weight:700}
  #held{min-width:120px;display:flex;gap:8px;align-items:center}
  #main{padding-top:56px;display:flex;flex-direction:column;align-items:center;gap:10px}
  #stage{width:calc(var(--cell)*var(--view));height:calc(var(--cell)*var(--view));
         border:2px solid var(--line);border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.35);
         position:relative;overflow:hidden;background:repeating-linear-gradient(90deg,#2e6d31 0,#2e6d31 10px,#2a6a2d 10px,#2a6a2d 20px)}
  #grid{display:grid;grid-template-columns:repeat(var(--view),var(--cell));grid-template-rows:repeat(var(--view),var(--cell));}
  .cell{width:var(--cell);height:var(--cell);display:flex;align-items:center;justify-content:center;
        position:relative;font-size:20px;user-select:none}
  .edge{background:#6d747f}
  .grass{background:linear-gradient(135deg,#2f7d32,#275e28)}
  .hpbar{position:absolute;left:2px;right:2px;bottom:2px;height:4px;background:#263040;border-radius:3px;overflow:hidden}
  .hpbar>i{display:block;height:100%;background:#ff5252}
  .float{position:absolute;pointer-events:none;font-weight:700;animation:rise .8s ease-out forwards}
  @keyframes rise{0%{opacity:1;transform:translateY(0)}100%{opacity:0;transform:translateY(-16px)}}

  #pads{width:100%;max-width:860px;display:flex;justify-content:space-between;gap:12px;padding:8px 12px 14px}
  .joyWrap{flex:1;display:flex;align-items:center;justify-content:center}
  .joy{
    width:140px;height:140px;border-radius:50%;
    background:radial-gradient(120px at 50% 50%, #0e1726, #0c1422);
    border:1px solid #223154; position:relative; touch-action:none; box-shadow:0 8px 24px rgba(0,0,0,.35);
  }
  .joy .knob{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    width:78px; height:78px; border-radius:50%; background:#13233e; border:1px solid #2a3a60;
    box-shadow:inset 0 0 0 2px #0b1628;
  }
  .joy .hint{position:absolute; left:50%; top:50%; width:4px; height:4px; border-radius:50%; background:#3b5ea8; opacity:.7}
  .joyLabel{margin-top:6px; color:#a8c3ff; font-size:13px; text-align:center}

  .chip{display:inline-flex;gap:6px;align-items:center;background:#0e1726;border:1px solid #1f2a44;border-radius:999px;padding:6px 10px}
  .pill{padding:2px 8px;border-radius:999px;border:1px solid #2a3a60;background:#121c30;color:#9fb3d0}
  .wide{min-width:44px;text-align:center}
  #catbar{height:10px;border-radius:6px;background:#2a344d;overflow:hidden;flex:1;margin:0 10px}
  #catbar i{display:block;height:100%;background:#f87171}
  a.btn{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:10px;border:1px solid #2a3a60;background:#0f1a2e;color:#cfe6ff;text-decoration:none}
  #toast{position:fixed;bottom:16px;left:50%;transform:translateX(-50%);background:#0e1726;border:1px solid #1f2a44;
         padding:10px 14px;border-radius:10px;box-shadow:0 10px 24px rgba(0,0,0,.35);display:none;z-index:15}
</style>
</head>
<body>

<!-- HUD -->
<div id="hud">
  <div class="chip">
    <span id="hostBadge" class="pill">Host?</span>
    <span>üë• <b id="aliveCount">0</b></span>
    <span>‚≠ê <b id="score">0</b></span>
    <span class="pill">+10 / 20s</span>
  </div>
  <div id="held" class="chip">
    <span>Held:</span><span id="heldIcon" class="wide">‚Äî</span>
    <span id="heldCount" class="pill">0</span>
  </div>
  <div class="chip" style="min-width:210px">
    <span>üê±</span>
    <div id="catbar"><i style="width:100%"></i></div>
    <span id="catHp">‚Äî</span>
  </div>
  <a class="btn" id="fsBtn">‚õ∂ Full Screen</a>
</div>

<!-- Stage -->
<div id="main">
  <div id="stage">
    <div id="grid"></div>
  </div>

  <!-- Pads -->
  <div id="pads">
    <!-- Move joystick -->
    <div class="joyWrap">
      <div id="moveJoy" class="joy">
        <div class="hint" style="transform:translate(-50%,-50%) translate(0,-48px)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(48px,0)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(0,48px)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(-48px,0)"></div>
        <div class="knob"></div>
      </div>
      <div class="joyLabel">Move</div>
    </div>
    <!-- Build joystick -->
    <div class="joyWrap">
      <div id="buildJoy" class="joy">
        <div class="hint" style="transform:translate(-50%,-50%) translate(0,-48px)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(48px,0)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(0,48px)"></div>
        <div class="hint" style="transform:translate(-50%,-50%) translate(-48px,0)"></div>
        <div class="knob"></div>
      </div>
      <div class="joyLabel">Build (uses held)</div>
    </div>
  </div>
</div>

<div id="toast"></div>

<script type="module">
/* ----------------------------- Firebase setup ----------------------------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection,
  addDoc, deleteDoc, serverTimestamp, getDocs, query, where
} from "https://www.gstatic.com/firebasejs/10.11.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
};
const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);

/* ------------------------------- Parameters ------------------------------- */
const url = new URLSearchParams(location.search);
const gameId = url.get("gameId") || "sandbox";
const myName = (url.get("username")||"Player").trim().toLowerCase();

/* --------------------------------- State --------------------------------- */
const gridSize = 40;       // world size
const view = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--view'))||17;
const gridEl = document.getElementById("grid");
const stageEl = document.getElementById("stage");
let camera = {x:0,y:0};

let I_AM_HOST = false;
let gameDoc = {};
let players = {};         // {name:{x,y,alive,score}}
let structures = new Map(); // "x_y" -> {t,hp,max}
let rats = new Map();       // id -> {x,y,hp}
let caterpillars = new Map(); // id -> {x,y}
let fleas = new Map();       // id -> {x,y,life}
let corpses = new Map();     // "x_y" -> name

let me = {x:1,y:1,alive:true,score:0};

// **Single held item only** (last pickup determines type)
let heldType = null;           // one of "üß±","üî´","üêù"
let heldCount = 0;             // remaining uses

// Power-up levels (affect HP/DMG/Rate); persist client-side
let levels = { wall:0, turret:0, hive:0 };

// Timers
let moveDelay = 120;        // ms per move
let buildDelay = 120;       // same tick as move, but independent
let lastMoveAt = 0, lastBuildAt = 0;

// Input intentions from joysticks
let moveIntent = {dx:0,dy:0};
let buildIntent = {dx:0,dy:0};

/* ------------------------------- UI helpers ------------------------------ */
const $ = sel => document.querySelector(sel);
const toastEl = $("#toast");
function toast(msg,ms=1200){ toastEl.textContent=msg; toastEl.style.display='block'; setTimeout(()=>toastEl.style.display='none',ms); }
function setHostBadge(){ $("#hostBadge").textContent = I_AM_HOST? "üëë Host" : "Client"; }
function setHeldUI(){
  $("#heldIcon").textContent = heldType || "‚Äî";
  $("#heldCount").textContent = heldCount || 0;
}
function setCatBar(hp, max=1000){
  const pct = Math.max(0, Math.min(1, (hp??0)/max));
  $("#catbar i").style.width = (pct*100)+"%";
  $("#catHp").textContent = hp ?? "‚Äî";
}
function floatText(x,y,text,color="#fff"){
  const cell = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'))||28;
  const sx = (x - camera.x)*cell + cell/2;
  const sy = (y - camera.y)*cell + cell/2;
  const el = document.createElement("div");
  el.className="float";
  el.style.left = (sx-8)+"px";
  el.style.top  = (sy-6)+"px";
  el.style.color = color;
  el.textContent = text;
  stageEl.appendChild(el);
  setTimeout(()=>el.remove(), 800);
}

/* --------------------------------- Grid ---------------------------------- */
const cell = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'))||28;
function clamp(v,min,max){ return v<min?min:v>max?max:v; }
function focusCamera(){
  camera.x = clamp(me.x - Math.floor(view/2), 0, gridSize - view);
  camera.y = clamp(me.y - Math.floor(view/2), 0, gridSize - view);
}
function key(x,y){ return `${x}_${y}`; }

/* ------------------------------- Rendering ------------------------------- */
function render(){
  focusCamera();
  gridEl.innerHTML = "";
  for(let ry=0; ry<view; ry++){
    for(let rx=0; rx<view; rx++){
      const gx = camera.x + rx, gy = camera.y + ry;
      const cellEl = document.createElement("div");
      cellEl.className="cell";
      if (gx===0 || gy===0 || gx===gridSize-1 || gy===gridSize-1) cellEl.classList.add("edge");
      else cellEl.classList.add("grass");

      // structure?
      const s = structures.get(key(gx,gy));
      let txt = "";
      if (s){
        txt = s.t;
        if (["üß±","üî´","üêù"].includes(s.t)){
          const bar = document.createElement("div");
          bar.className="hpbar";
          const fill = document.createElement("i");
          const pct = Math.max(0, Math.min(1, (s.hp||0)/(s.max||1)));
          fill.style.width = (pct*100)+"%";
          bar.appendChild(fill);
          cellEl.appendChild(bar);
        }
      }

      // pickups overlay
      if (s && (s.t==="‚≠ïüß±"||s.t==="‚≠ïüî´"||s.t==="‚≠ïüêù")) txt = s.t.replace("‚≠ï",""); // draw icon only
      if (s && (s.t==="üî∫üß±"||s.t==="üî∫üî´"||s.t==="üî∫üêù")) txt = s.t;

      // friendly fleas
      for(const f of fleas.values()){ if (f.x===gx && f.y===gy) txt="üêû"; }
      for(const r of rats.values()){ if (r.x===gx && r.y===gy) txt="üêÄ"; }
      for(const c of caterpillars.values()){ if (c.x===gx && c.y===gy) txt="üêõ"; }
      if (corpses.has(key(gx,gy))) txt="ü™¶";
      if (gameDoc.cat && gameDoc.cat.x===gx && gameDoc.cat.y===gy) txt="üê±";
      for(const [name,p] of Object.entries(players)){ if (p.alive && p.x===gx && p.y===gy) txt="üê≠"; }
      if (me.alive && me.x===gx && me.y===gy) txt="üê≠";

      cellEl.textContent = txt;
      gridEl.appendChild(cellEl);
    }
  }
  const aliveCt = (me.alive?1:0) + Object.values(players).filter(p=>p.alive).length;
  $("#aliveCount").textContent = aliveCt;
  $("#score").textContent = me.score;
}

/* ------------------------------- Firestore ------------------------------- */
const gameRef = doc(db,"games",gameId);
const playersCol = collection(db,"games",gameId,"players");
const structsCol = collection(db,"games",gameId,"structures");
const ratsCol = collection(db,"games",gameId,"rats");
const catsCol = collection(db,"games",gameId,"caterpillars");
const fleasCol = collection(db,"games",gameId,"fleas");
const corpsesCol = collection(db,"games",gameId,"corpses");
const highsCol = collection(db,"games",gameId,"highscores");

async function claimHost(){
  const snap = await getDoc(gameRef);
  const data = snap.exists()? snap.data() : {};
  if (!data.host){
    await setDoc(gameRef,{host:myName,startMs:Date.now(),cat:{x:gridSize-2,y:gridSize-2,h:1000},catPower:0,nextWave:Date.now()+25000},{merge:true});
    I_AM_HOST = true;
  }else{
    I_AM_HOST = (data.host===myName);
  }
  setHostBadge();
}

async function upsertMe(){
  await setDoc(doc(playersCol,myName), {x:me.x,y:me.y,alive:me.alive,score:me.score,displayName:myName},{merge:true});
}

function listen(){
  onSnapshot(gameRef,(s)=>{ if (!s.exists()) return; gameDoc = s.data(); setCatBar(gameDoc.cat?.h ?? 1000, 1000); if (gameDoc.host===myName && !I_AM_HOST){ I_AM_HOST=true; setHostBadge(); } render(); });
  onSnapshot(playersCol,(snap)=>{ const next={}; snap.forEach(d=>{ const n=d.id; if (n===myName) return; next[n]=d.data(); }); players=next; render(); });
  onSnapshot(structsCol,(snap)=>{ const m=new Map(); snap.forEach(d=>{ const v=d.data(); m.set(key(v.x,v.y),v); }); structures=m; render(); });
  onSnapshot(ratsCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(d.id,d.data())); rats=m; render(); });
  onSnapshot(catsCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(d.id,d.data())); caterpillars=m; render(); });
  onSnapshot(fleasCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(d.id,d.data())); fleas=m; render(); });
  onSnapshot(corpsesCol,(snap)=>{ const m=new Map(); snap.forEach(d=>m.set(key(d.data().x,d.data().y), d.id)); corpses=m; render(); });
}

/* ------------------------------- Blocking -------------------------------- */
// Blocks for AI & placement; **mice can walk over structures now**
function isBlocked(x,y){
  if (x<=0||y<=0||x>=gridSize-1||y>=gridSize-1) return true;
  const s=structures.get(key(x,y));
  return !!(s && ["üß±","üî´","üêù"].includes(s.t));
}
function tileOccupied(x,y){ return !!structures.get(key(x,y)); }

/* ------------------------------- Pathfinding ------------------------------ */
function findPath(sx,sy,tx,ty,allowTargetBlocked=false){
  const Q=[[sx,sy]];
  const P=new Map([[key(sx,sy),null]]);
  const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
  while(Q.length){
    const [x,y]=Q.shift();
    if (x===tx && y===ty) break;
    for(const [dx,dy] of dirs){
      const nx=x+dx, ny=y+dy;
      if (nx<0||ny<0||nx>=gridSize||ny>=gridSize) continue;
      if (P.has(key(nx,ny))) continue;
      const blocked = isBlocked(nx,ny);
      const isTarget = (nx===tx && ny===ty);
      if (blocked && !(allowTargetBlocked && isTarget)) continue;
      P.set(key(nx,ny),[x,y]); Q.push([nx,ny]);
    }
  }
  if (!P.has(key(tx,ty))) return null;
  const path=[]; let cur=[tx,ty];
  while(cur){ path.push(cur); cur=P.get(key(cur[0],cur[1])); }
  path.reverse(); return path;
}

/* ------------------------------ Host routines ---------------------------- */
function anyMouseAlive(){ if (me.alive) return true; return Object.values(players).some(p=>p.alive); }
async function saveHighscoreIfNeeded(){
  const everyone = [myName,...Object.keys(players)];
  const total = me.score + Object.values(players).reduce((a,p)=>a+(p.score||0),0);
  await addDoc(highsCol,{when:serverTimestamp(),names:everyone,score:total});
}
async function placeStructureHost(x,y,t,hp){ await setDoc(doc(structsCol,key(x,y)),{x,y,t,hp,max:hp}); }
async function damageStructureHost(x,y,amt){
  const id = key(x,y); const s = structures.get(id); if (!s) return;
  const hp = Math.max(0,(s.hp||0)-amt);
  if (hp<=0) await deleteDoc(doc(structsCol,id)); else await updateDoc(doc(structsCol,id),{hp});
}
function hpWall(){  return Math.round(60  * (1+0.15*levels.wall)); }
function hpTur(){   return Math.round(30  * (1+0.15*levels.turret)); }
function hpHive(){  return Math.round(35  * (1+0.15*levels.hive)); }
function dmgTurret(){ return Math.round(6 * (1+0.25*levels.turret)); }
function hiveSpawnRate(){ return Math.max(900, 1800 * (1 - 0.15*levels.hive)); }

async function hostSpawnPickups(){
  const types = ["üß±","üî´","üêù"];
  for (let i=0;i<3;i++){
    const x = 2 + Math.floor(Math.random()*(gridSize-4));
    const y = 2 + Math.floor(Math.random()*(gridSize-4));
    if (tileOccupied(x,y)) continue;
    const t = "‚≠ï"+types[Math.floor(Math.random()*types.length)];
    await placeStructureHost(x,y,t,1);
  }
  if (Math.random()<0.4){
    const x = 2 + Math.floor(Math.random()*(gridSize-4));
    const y = 2 + Math.floor(Math.random()*(gridSize-4));
    if (!tileOccupied(x,y)){
      const t = "üî∫"+types[Math.floor(Math.random()*types.length)];
      await placeStructureHost(x,y,t,1);
    }
  }
}
async function hostSpawnWave(){
  if (!I_AM_HOST) return;
  const cat = gameDoc.cat || {x:gridSize-2,y:gridSize-2,h:1000};
  const n = Math.max(2, (gameDoc.catPower||0));
  let spawned=0, tries=0;
  while(spawned<n && tries<100){
    tries++;
    const dx = (Math.random()<.5?-1:1) * (1+Math.floor(Math.random()*3));
    const dy = (Math.random()<.5?-1:1) * (1+Math.floor(Math.random()*3));
    const x = clamp(cat.x+dx,1,gridSize-2);
    const y = clamp(cat.y+dy,1,gridSize-2);
    if (isBlocked(x,y)) continue;
    await addDoc(ratsCol,{x,y,hp: (5 + (gameDoc.catPower||0)*3)});
    spawned++;
  }
}
async function hostSpawnCaterpillars(){
  if (!I_AM_HOST) return;
  const mins = Math.floor((Date.now() - (gameDoc.startMs||Date.now()))/60000);
  if (mins<3) return;
  const count = 1 + (mins-3);
  let spawned=0, tries=0;
  while (spawned<count && tries<200){
    tries++;
    const x = 2 + Math.floor(Math.random()*(gridSize-4));
    const y = 2 + Math.floor(Math.random()*(gridSize-4));
    if (isBlocked(x,y)) continue;
    await addDoc(catsCol,{x,y});
    spawned++;
  }
}
async function hostCatAI(){
  if (!I_AM_HOST || !gameDoc.cat) return;
  const cat = {...gameDoc.cat};
  let bestPath=null;

  const aliveM = [];
  if (me.alive) aliveM.push({x:me.x,y:me.y});
  for(const p of Object.values(players)){ if (p.alive) aliveM.push({x:p.x,y:p.y}); }

  for(const m of aliveM){
    const p = findPath(cat.x,cat.y,m.x,m.y,false);
    if (p && (!bestPath || p.length<bestPath.length)) bestPath=p;
  }
  if (!bestPath){
    for(const o of structures.values()){
      if (o.t==="üî´"){
        const p=findPath(cat.x,cat.y,o.x,o.y,false);
        if (p && (!bestPath || p.length<bestPath.length)) bestPath=p;
      }
    }
  }
  if (!bestPath){
    let min=1e9, pth=null;
    for(const o of structures.values()){
      if (!["üß±","üî´","üêù"].includes(o.t)) continue;
      const p=findPath(cat.x,cat.y,o.x,o.y,false);
      if (p && p.length<min){ min=p.length; pth=p; }
    }
    if (pth) bestPath=pth;
  }
  if (bestPath && bestPath.length>1){
    const step = bestPath[1];
    cat.x=step[0]; cat.y=step[1];
  }
  const adj = [[1,0],[-1,0],[0,1],[0,-1]];
  for(const [dx,dy] of adj){
    const tx=cat.x+dx, ty=cat.y+dy;
    const s = structures.get(key(tx,ty));
    if (s && ["üß±","üî´","üêù"].includes(s.t)){ await damageStructureHost(tx,ty, 2 + Math.floor((gameDoc.catPower||0)/2)); break; }
    if (me.alive && me.x===tx && me.y===ty){ me.alive=false; await updateDoc(doc(playersCol,myName),{alive:false}); await addDoc(corpsesCol,{x:tx,y:ty}); break; }
    for (const [n,p] of Object.entries(players)){
      if (p.alive && p.x===tx && p.y===ty){ await updateDoc(doc(playersCol,n),{alive:false}); await addDoc(corpsesCol,{x:tx,y:ty}); break; }
    }
  }
  await updateDoc(gameRef,{cat});
}
async function hostTurretsShoot(){
  if (!I_AM_HOST) return;
  for(const o of structures.values()){
    if (o.t!=="üî´") continue;
    const rng=5; const inRange=[];
    if (gameDoc.cat){
      const d=Math.abs(gameDoc.cat.x-o.x)+Math.abs(gameDoc.cat.y-o.y);
      if (d<=rng) inRange.push({type:"cat",x:gameDoc.cat.x,y:gameDoc.cat.y});
    }
    for(const [id,r] of rats){
      const d=Math.abs(r.x-o.x)+Math.abs(r.y-o.y);
      if (d<=rng) inRange.push({type:"rat",id,x:r.x,y:r.y});
    }
    if (!inRange.length) continue;
    inRange.sort((a,b)=> (Math.abs(a.x-o.x)+Math.abs(a.y-o.y)) - (Math.abs(b.x-o.x)+Math.abs(b.y-o.y)));
    const t=inRange[0], dmg=dmgTurret();
    if (t.type==="cat"){
      const nh = Math.max(0,(gameDoc.cat?.h||0) - dmg);
      await updateDoc(gameRef,{cat:{...gameDoc.cat,h:nh}}); me.score+=1; await updateDoc(doc(playersCol,myName),{score:me.score}); floatText(t.x,t.y,"+1","#7cf");
    }else{
      const r = rats.get(t.id); if (!r) continue;
      const hp=(r.hp||0)-dmg; if (hp<=0) await deleteDoc(doc(ratsCol,t.id)); else await updateDoc(doc(ratsCol,t.id),{hp});
      floatText(t.x,t.y,"-"+dmg,"#f88");
    }
  }
}
async function hostFleaHiveTick(){
  if (!I_AM_HOST) return;
  const now=Date.now();
  for(const o of structures.values()){
    if (o.t!=="üêù") continue;
    if (!o._next) o._next = now + hiveSpawnRate();
    if (now < o._next) continue;
    o._next = now + hiveSpawnRate();
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dx,dy] of dirs){
      const nx=o.x+dx, ny=o.y+dy;
      if (isBlocked(nx,ny)) continue;
      let occ=false; for(const f of fleas.values()) if (f.x===nx&&f.y===ny){occ=true;break;}
      if (occ) continue;
      await addDoc(fleasCol,{x:nx,y:ny,life:25}); // ~10s at 400ms tick
      break;
    }
  }
}
async function hostFleasMove(){
  if (!I_AM_HOST) return;
  for(const [id,f] of fleas){
    let tx=gameDoc.cat?.x, ty=gameDoc.cat?.y; let best=1e9;
    if (typeof tx==="number"){ best = Math.abs(tx-f.x)+Math.abs(ty-f.y); }
    for(const r of rats.values()){
      const d=Math.abs(r.x-f.x)+Math.abs(r.y-f.y);
      if (d<best){ best=d; tx=r.x; ty=r.y; }
    }
    if (typeof tx==="number"){
      const dx = Math.sign(tx - f.x), dy = Math.sign(ty - f.y);
      const nx = clamp(f.x + (Math.abs(tx-f.x)>=Math.abs(ty-f.y)?dx:0),1,gridSize-2);
      const ny = clamp(f.y + (Math.abs(tx-f.x)< Math.abs(ty-f.y)?dy:0),1,gridSize-2);
      await updateDoc(doc(fleasCol,id),{x:nx,y:ny,life:f.life-1});
      if (gameDoc.cat && nx===gameDoc.cat.x && ny===gameDoc.cat.y){
        await updateDoc(gameRef,{cat:{...gameDoc.cat,h:Math.max(0,gameDoc.cat.h-1)}}); me.score+=1; await updateDoc(doc(playersCol,myName),{score:me.score}); floatText(nx,ny,"+1","#7cf");
      }
      for(const [rid,r] of rats){
        if (r.x===nx && r.y===ny){
          const nh=(r.hp||0)-5; if (nh<=0) await deleteDoc(doc(ratsCol,rid)); else await updateDoc(doc(ratsCol,rid),{hp:nh});
          floatText(nx,ny,"-5","#f88");
        }
      }
    }else{
      await updateDoc(doc(fleasCol,id),{life:f.life-1});
    }
    if (f.life-1<=0){ await deleteDoc(doc(fleasCol,id)); }
  }
}
async function hostRatsThink(){
  if (!I_AM_HOST) return;
  for(const [id,r] of rats){
    let targets=[];
    if (me.alive) targets.push({x:me.x,y:me.y,type:"mouse",name:myName});
    for (const [n,p] of Object.entries(players)) if (p.alive) targets.push({x:p.x,y:p.y,type:"mouse",name:n});
    for(const s of structures.values()){ if (["üß±","üî´","üêù"].includes(s.t)) targets.push({x:s.x,y:s.y,type:"struct"}); }
    if (!targets.length) continue;
    targets.sort((a,b)=> (Math.abs(a.x-r.x)+Math.abs(a.y-r.y)) - (Math.abs(b.x-r.x)+Math.abs(b.y-r.y)));
    const t = targets[0];
    const p = findPath(r.x,r.y,t.x,t.y,false);
    if (p && p.length>1){ const step=p[1]; await updateDoc(doc(ratsCol,id),{x:step[0],y:step[1]}); }
    else if (t.type==="struct" && (r.x===t.x && r.y===t.y)){ await damageStructureHost(r.x,r.y, 1 + Math.floor((gameDoc.catPower||0)/3)); }
    if (t.type==="mouse" && r.x===t.x && r.y===t.y){
      if (t.name===myName && me.alive){ me.alive=false; await updateDoc(doc(playersCol,myName),{alive:false}); await addDoc(corpsesCol,{x:r.x,y:r.y}); }
      else await updateDoc(doc(playersCol,t.name),{alive:false});
    }
  }
}
async function hostCaterpillarsThink(){
  if (!I_AM_HOST) return;
  for(const [id,c] of caterpillars){
    let pick=null, best=1e9;
    for(const s of structures.values()){
      if (!["üß±","üî´"].includes(s.t)) continue;
      const d=Math.abs(s.x-c.x)+Math.abs(s.y-c.y);
      if (d<best){ best=d; pick=s; }
    }
    if (!pick) continue;
    const p = findPath(c.x,c.y,pick.x,pick.y,true);
    if (p && p.length>1){ const step=p[1]; await updateDoc(doc(catsCol,id),{x:step[0],y:step[1]}); }
    if (c.x===pick.x && c.y===pick.y){ await damageStructureHost(c.x,c.y,20); await deleteDoc(doc(catsCol,id)); }
  }
}

/* ------------------------------ Movement/Build --------------------------- */
function inBounds(x,y){ return x>0 && y>0 && x<gridSize-1 && y<gridSize-1; }
async function tryMove(dx,dy){
  if (!me.alive) return;
  if (Date.now()-lastMoveAt<moveDelay) return;
  const nx = clamp(me.x+dx,1,gridSize-2);
  const ny = clamp(me.y+dy,1,gridSize-2);
  if (!inBounds(nx,ny)) return;
  // **Mice can walk over structures**: no block check here
  me.x=nx; me.y=ny; lastMoveAt=Date.now(); await upsertMe();

  // pickups
  const s = structures.get(key(nx,ny));
  if (s){
    if (s.t==="‚≠ïüß±"){ heldType="üß±"; heldCount = 20; await deleteDoc(doc(structsCol,key(nx,ny))); toast("Held üß± x20"); }
    if (s.t==="‚≠ïüî´"){ heldType="üî´"; heldCount = 3;  await deleteDoc(doc(structsCol,key(nx,ny))); toast("Held üî´ x3"); }
    if (s.t==="‚≠ïüêù"){ heldType="üêù"; heldCount = 2;  await deleteDoc(doc(structsCol,key(nx,ny))); toast("Held üêù x2"); }
    if (s.t==="üî∫üß±"){ levels.wall++;   await deleteDoc(doc(structsCol,key(nx,ny))); toast("üß± +15% HP"); }
    if (s.t==="üî∫üî´"){ levels.turret++; await deleteDoc(doc(structsCol,key(nx,ny))); toast("üî´ +15% HP / +25% DMG"); }
    if (s.t==="üî∫üêù"){ levels.hive++;   await deleteDoc(doc(structsCol,key(nx,ny))); toast("üêù +15% HP / +15% rate"); }
    setHeldUI();
  }

  // corpse revive (same as before)
  if (corpses.has(key(nx,ny))){
    const qs = await getDocs(query(corpsesCol, where("x","==",nx), where("y","==",ny)));
    qs.forEach(async d=> await deleteDoc(d.ref));
    const dead = [myName, ...Object.entries(players).filter(([,p])=>!p.alive).map(([n])=>n)].filter((v,i,a)=>a.indexOf(v)===i);
    if (dead.length){
      const n = dead[0];
      await updateDoc(doc(playersCol,n),{alive:true,x:nx,y:ny});
      me.score += 100; await updateDoc(doc(playersCol,myName),{score:me.score});
      toast("ü©π Revived +100");
    }
  }

  render();
}
async function tryBuild(dx,dy){
  if (!me.alive) return;
  if (Date.now()-lastBuildAt<buildDelay) return;
  if (!heldType || heldCount<=0) { toast("No held item"); return; }

  const tx = clamp(me.x+dx,1,gridSize-2);
  const ty = clamp(me.y+dy,1,gridSize-2);
  if (!inBounds(tx,ty)) return;
  if (tileOccupied(tx,ty)) return; // **block placement** if something is there

  let hp=10;
  if (heldType==="üß±") hp=hpWall();
  if (heldType==="üî´") hp=hpTur();
  if (heldType==="üêù") hp=hpHive();

  await placeStructureHost(tx,ty,heldType,hp);
  heldCount--; lastBuildAt=Date.now(); setHeldUI(); render();
}

/* ------------------------------- Timers/loops ---------------------------- */
// +10 points every 20s
setInterval(async ()=>{ if (!me.alive) return; me.score += 10; await updateDoc(doc(playersCol,myName),{score:me.score}); }, 20000);

// host difficulty scaler
setInterval(async ()=>{ if (!I_AM_HOST) return; const cp=(gameDoc.catPower||0)+1;
  const cat={...(gameDoc.cat||{x:gridSize-2,y:gridSize-2,h:1000})}; cat.h=(cat.h||1000)+10;
  await updateDoc(gameRef,{catPower:cp,cat}); }, 60000);
// host waves & AI
setInterval(async ()=>{ if (I_AM_HOST) await hostSpawnWave(); }, 12000);
setInterval(async ()=>{ if (I_AM_HOST) await hostSpawnCaterpillars(); }, 15000);
setInterval(hostTurretsShoot, 1200);
setInterval(hostCatAI, 500);
setInterval(hostRatsThink, 450);
setInterval(hostFleaHiveTick, 1000);
setInterval(hostFleasMove, 400);
// host pickups
setInterval(async ()=>{ if (I_AM_HOST) await hostSpawnPickups(); }, 18000);
// game over detect
setInterval(async ()=>{ if (!I_AM_HOST) return; if (!anyMouseAlive()){ await saveHighscoreIfNeeded(); toast("üíÄ All mice dead ‚Äî Game Over"); } }, 3000);

/* --------------------------------- Joysticks ----------------------------- */
function setupJoystick(el, onDir){
  const knob = el.querySelector('.knob');
  const rect = ()=> el.getBoundingClientRect();
  let active=false, cx=0, cy=0, maxR=50;

  function setKnob(dx,dy){
    const r = Math.hypot(dx,dy);
    const scale = r>maxR ? maxR/r : 1;
    knob.style.left = `calc(50% + ${(dx*scale)}px)`;
    knob.style.top  = `calc(50% + ${(dy*scale)}px)`;
  }
  function dirFrom(dx,dy){
    if (Math.hypot(dx,dy)<16) return {dx:0,dy:0};
    if (Math.abs(dx)>Math.abs(dy)) return {dx: Math.sign(dx), dy:0};
    else return {dx:0, dy: Math.sign(dy)};
  }
  function end(){
    active=false; setKnob(0,0); onDir({dx:0,dy:0});
  }
  el.addEventListener('touchstart',e=>{
    e.preventDefault();
    active=true; const b=rect();
    cx=b.left+b.width/2; cy=b.top+b.height/2;
  },{passive:false});
  el.addEventListener('touchmove',e=>{
    if (!active) return;
    const t=e.touches[0]; const dx=t.clientX-cx; const dy=t.clientY-cy;
    setKnob(dx,dy); onDir(dirFrom(dx,dy));
  },{passive:false});
  el.addEventListener('touchend',e=>{ end(); },{passive:false});
  el.addEventListener('touchcancel',e=>{ end(); },{passive:false});
}

// Move & Build repeaters (independent ticks)
setInterval(()=>{
  if (!me.alive) return;
  if (moveIntent.dx||moveIntent.dy) tryMove(moveIntent.dx,moveIntent.dy);
}, 30);
setInterval(()=>{
  if (!me.alive) return;
  if (buildIntent.dx||buildIntent.dy) tryBuild(buildIntent.dx,buildIntent.dy);
}, 30);

setupJoystick(document.getElementById('moveJoy'), d=>{ moveIntent=d; });
setupJoystick(document.getElementById('buildJoy'), d=>{ buildIntent=d; });

// Keyboard fallback (desktop)
window.addEventListener("keydown",e=>{
  if (e.key==="ArrowUp")  moveIntent={dx:0,dy:-1};
  if (e.key==="ArrowDown")moveIntent={dx:0,dy:1};
  if (e.key==="ArrowLeft")moveIntent={dx:-1,dy:0};
  if (e.key==="ArrowRight")moveIntent={dx:1,dy:0};
  if (e.key==="w") buildIntent={dx:0,dy:-1};
  if (e.key==="s") buildIntent={dx:0,dy:1};
  if (e.key==="a") buildIntent={dx:-1,dy:0};
  if (e.key==="d") buildIntent={dx:1,dy:0};
});
window.addEventListener("keyup",e=>{
  if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)) moveIntent={dx:0,dy:0};
  if (["w","a","s","d"].includes(e.key)) buildIntent={dx:0,dy:0};
});

// Full screen
$("#fsBtn").onclick=()=>{ const el=document.documentElement; if (document.fullscreenElement) document.exitFullscreen(); else el.requestFullscreen?.(); };

/* --------------------------------- Boot ---------------------------------- */
(async function init(){
  me.x = 2 + Math.floor(Math.random()*6);
  me.y = 2 + Math.floor(Math.random()*6);
  await upsertMe();
  await claimHost();
  listen();
  if (I_AM_HOST) await hostSpawnPickups();
  setHeldUI();
  setHostBadge();
  render();
})();
</script>
</body>
</html>


