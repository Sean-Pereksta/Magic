<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>üó∫Ô∏è CircleRogue ‚Äî First-Person Forge Run</title>
  <style>
    html, body{
      margin:0; height:100%; background:#000; overflow:hidden;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
    }

    canvas{ display:block; }

    #ui{
      position:fixed; inset:0; pointer-events:none; color:#fff;
    }
    .topbar{
      position:absolute; left:10px; right:10px; top:10px;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      flex-wrap:wrap; pointer-events:none;
    }
    .leftPills, .rightPills{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .pill{
      pointer-events:none;
      display:inline-flex; gap:8px; align-items:center;
      padding:8px 10px; border-radius:999px;
      background:rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.16);
      backdrop-filter:blur(8px);
      font-weight:900; font-size:13px;
      box-shadow:0 10px 22px rgba(0,0,0,.25);
      white-space:nowrap;
    }
    .pill b{ font-weight:1000; }

    #toast{
      position:absolute; left:50%; top:70px; transform:translateX(-50%);
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.18);
      border-radius:999px;
      padding:8px 12px;
      font-weight:900;
      pointer-events:none;
      backdrop-filter:blur(10px);
      opacity:0; transition:opacity .18s;
      max-width:min(820px,92vw);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }

    #regionBanner{
      position:absolute;
      left:50%;
      top:44px;
      transform:translateX(-50%);
      font-size:12px;
      font-weight:900;
      letter-spacing:.4px;
      color:rgba(255,255,255,.95);
      text-shadow:0 2px 8px rgba(0,0,0,.65);
      opacity:0;
      transition:opacity .35s;
      pointer-events:none;
      z-index:5;
    }

    #fxLayer{
      position:absolute;
      inset:0;
      pointer-events:none;
      overflow:hidden;
    }
    .floatText{
      position:absolute;
      transform:translate(-50%,-50%);
      font-weight:1000;
      font-size:13px;
      color:#fde68a;
      text-shadow:0 2px 6px rgba(0,0,0,.6);
      white-space:nowrap;
      pointer-events:none;
    }

    .muted{ opacity:.78; font-weight:700; }

    #centerMsg{
      position:absolute; left:50%; top:50%;
      transform:translate(-50%,-50%);
      background:rgba(0,0,0,.58);
      border:1px solid rgba(255,255,255,.18);
      border-radius:16px;
      padding:14px 16px;
      font-weight:900;
      text-align:center;
      pointer-events:auto;
      backdrop-filter:blur(10px);
      min-width:min(560px,92vw);
      box-shadow:0 18px 60px rgba(0,0,0,.45);
    }
    #centerMsg .row{
      display:flex; gap:10px; justify-content:center; flex-wrap:wrap;
      margin-top:10px;
    }
    #centerMsg button{
      cursor:pointer; border:none;
      padding:10px 12px; border-radius:12px;
      font-weight:1000;
      background:#22c55e; color:#07110a;
      box-shadow:0 10px 22px rgba(0,0,0,.35);
    }
    #centerMsg button.alt{
      background:rgba(255,255,255,.12); color:#fff;
      border:1px solid rgba(255,255,255,.22);
    }

    #overlayVignette{
      position:absolute; inset:0;
      background:radial-gradient(circle at 50% 50%,
        rgba(0,0,0,0) 0%,
        rgba(0,0,0,.55) 60%,
        rgba(0,0,0,.82) 100%);
      pointer-events:none;
      opacity:.55;
    }

    #overlayDead{
      position:absolute; inset:0;
      background:radial-gradient(circle at 50% 35%,
        rgba(0,0,0,.15) 0%,
        rgba(0,0,0,.92) 70%);
      opacity:0; pointer-events:none; transition:opacity .12s linear;
    }

    #crosshair{
      position:absolute; left:50%; top:50%;
      width:14px; height:14px; transform:translate(-50%,-50%);
      pointer-events:none;
      filter:drop-shadow(0 2px 6px rgba(0,0,0,.6));
    }
    #crosshair:before, #crosshair:after{
      content:""; position:absolute; left:50%; top:50%;
      transform:translate(-50%,-50%);
      background:rgba(255,255,255,.92);
      border-radius:2px;
    }
    #crosshair:before{ width:2px; height:14px; }
    #crosshair:after{ width:14px; height:2px; }
    #crosshairDot{
      position:absolute; left:50%; top:50%;
      width:4px; height:4px; transform:translate(-50%,-50%);
      background:rgba(34,197,94,.95);
      border-radius:50%;
    }

    /* Buttons (fullscreen + load) */
    .topBtns{
      position:absolute;
      right:14px;
      top:84px;
      display:flex; gap:10px;
      pointer-events:auto;
    }
    .btn{
      pointer-events:auto;
      border:none;
      border-radius:14px;
      padding:12px 14px;
      font-weight:1000;
      font-size:15px;
      background:rgba(34,197,94,.95);
      color:#04120a;
      box-shadow:0 8px 18px rgba(0,0,0,.35);
      cursor:pointer;
    }
    .btn.secondary{
      background:rgba(255,255,255,.12);
      color:#fff;
      border:1px solid rgba(255,255,255,.22);
      box-shadow:0 8px 18px rgba(0,0,0,.35);
    }

    /* Forge / LevelUp modals */
    #modalShade{
      position:absolute; inset:0;
      background:rgba(0,0,0,.62);
      backdrop-filter:blur(8px);
      opacity:0;
      pointer-events:none;
      transition:opacity .12s linear;
    }
    #modal{
      position:absolute; left:50%; top:50%;
      transform:translate(-50%,-50%);
      width:min(980px,94vw);
      max-height:min(84vh,760px);
      overflow:auto;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.18);
      background:linear-gradient(180deg, rgba(15,23,42,.92), rgba(2,6,23,.92));
      box-shadow:0 20px 80px rgba(0,0,0,.55);
      padding:14px 14px 16px;
      opacity:0;
      pointer-events:none;
      transition:opacity .12s linear;
    }
    #modal h2{ margin:6px 6px 4px; font-size:16px; }
    #modal .sub{ margin:0 6px 10px; opacity:.75; font-weight:800; font-size:13px; }

    .grid2{
      display:grid;
      grid-template-columns: 1.05fr 1.4fr;
      gap:12px;
    }
    .panel{
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.14);
      border-radius:14px;
      padding:10px;
    }
    .panelTitle{
      font-weight:1000; margin-bottom:6px;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .chipRow{ display:flex; flex-wrap:wrap; gap:8px; }
    .chip{
      display:inline-flex; gap:8px; align-items:center;
      padding:7px 10px; border-radius:999px;
      background:rgba(0,0,0,.30);
      border:1px solid rgba(255,255,255,.12);
      font-weight:950; font-size:12px;
    }
    .recipes{ display:grid; grid-template-columns:repeat(2, minmax(0, 1fr)); gap:10px; }
    .card{
      background:rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.14);
      border-radius:14px;
      padding:10px;
    }
    .card .name{ font-weight:1000; }
    .card .desc{ margin-top:6px; opacity:.78; font-weight:800; font-size:12px; line-height:1.3; }
    .card .req{ margin-top:8px; display:flex; gap:6px; flex-wrap:wrap; }
    .req .reqItem{
      font-size:12px; font-weight:950; opacity:.9;
      padding:4px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
    }
    .card .rowBtns{ margin-top:10px; display:flex; gap:10px; flex-wrap:wrap; }
    .card button{
      cursor:pointer; border:none;
      padding:9px 10px; border-radius:12px;
      font-weight:1000;
      background:#22c55e; color:#07110a;
    }
    .card button.secondary{
      background:rgba(255,255,255,.12);
      color:#fff;
      border:1px solid rgba(255,255,255,.18);
    }
    .card button:disabled{
      opacity:.45; cursor:not-allowed;
    }

    /* Mobile controls */
    #mobileControls{
      position:absolute; inset:0;
      pointer-events:none;
      display:none;
    }
    .joystick{
      position:absolute;
      width:132px; height:132px;
      border-radius:50%;
      background:rgba(15,23,42,.36);
      border:2px solid rgba(255,255,255,.28);
      backdrop-filter:blur(8px);
      pointer-events:auto;
      touch-action:none;
    }
    #moveStick{ left:16px; bottom:20px; }
    #lookStick{ right:16px; bottom:20px; }
    .joystickKnob{
      position:absolute; left:50%; top:50%;
      width:64px; height:64px;
      margin-left:-32px; margin-top:-32px;
      border-radius:50%;
      background:rgba(255,255,255,.75);
      border:2px solid rgba(0,0,0,.2);
      box-shadow:0 8px 18px rgba(0,0,0,.4);
      transition:transform .05s linear;
      pointer-events:none;
    }

    /* Mobile interact button */
    #mobileInteract{
      position:absolute;
      left:50%;
      bottom:180px;
      transform:translateX(-50%);
      pointer-events:auto;
      display:none;
      border:none;
      border-radius:16px;
      padding:14px 16px;
      font-weight:1100;
      background:rgba(34,197,94,.95);
      color:#04120a;
      box-shadow:0 10px 24px rgba(0,0,0,.38);
      touch-action:manipulation;
    }

    @media (pointer: coarse){
      #mobileControls{ display:block; }
      .topBtns{ top:16px; }
      .btn{ padding:13px 15px; font-size:16px; }
      #mobileInteract{ display:none; }

      #modal{
        width:min(98vw, 980px);
        max-height:88vh;
      }
      .grid2{ grid-template-columns:1fr; }
      .panel{
        max-height:36vh;
        overflow:auto;
      }
      .recipes{ grid-template-columns:1fr; }
    }
  </style>
</head>
<body>
  <div id="ui">
    <div class="topbar">
      <div class="leftPills">
        <div class="pill">‚ù§Ô∏è <span id="hpText">‚Äî</span></div>
        <div class="pill">‚≠ê <span id="lvlText">‚Äî</span></div>
        <div class="pill">üß≠ <span id="regionText">‚Äî</span></div>
      </div>
      <div class="rightPills">
        <div class="pill">üó°Ô∏è <span id="weaponText">‚Äî</span></div>
        <div class="pill">üì¶ <span id="matsText">‚Äî</span></div>
      </div>
    </div>

    <div id="toast"></div>
    <div id="regionBanner"></div>
    <div id="fxLayer"></div>

    <div class="topBtns">
      <button id="loadBtn" class="btn secondary" type="button">‚¨Ü Load</button>
      <button id="fsBtn" class="btn" type="button">‚õ∂ Fullscreen</button>
    </div>

    <div id="crosshair"><div id="crosshairDot"></div></div>

    <div id="mobileControls">
      <div id="moveStick" class="joystick" aria-label="Movement joystick">
        <div id="moveKnob" class="joystickKnob"></div>
      </div>
      <div id="lookStick" class="joystick" aria-label="Look joystick">
        <div id="lookKnob" class="joystickKnob"></div>
      </div>
      <button id="mobileInteract" type="button">‚öíÔ∏è Use Forge</button>
    </div>

    <div id="overlayVignette"></div>
    <div id="overlayDead"></div>

    <div id="modalShade"></div>
    <div id="modal"></div>

    <div id="centerMsg">
      <div id="centerTitle" style="font-size:18px">CircleRogue</div>
      <div id="centerSub" class="muted" style="margin-top:6px">
        Huge circular world ‚Ä¢ 3 danger rings ‚Ä¢ Forge crafting ‚Ä¢ Auto-fire aim cone ‚Ä¢ Packs scale with level ‚Ä¢ Local save/load
      </div>
      <div class="row">
        <button id="lockBtn" style="display:none">Click to Play</button>
        <button id="newBtn" class="alt">New Run</button>
        <button id="resumeBtn" class="alt">Resume (Load)</button>
      </div>
      <div class="muted" style="margin-top:10px; font-size:12px">
        Tip: Flying enemies require pitching the camera upward to keep them in the aim cone.
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js";

    // ============================================================
    // Small utilities
    // ============================================================
    const $ = (id)=>document.getElementById(id);

    const toast = $("toast");
    function showToast(msg, ms=2200){
      toast.textContent = msg;
      toast.style.opacity = "1";
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=>toast.style.opacity="0", ms);
    }

    function showRegionBanner(reg, band){
      const key = reg.id;
      if(key===lastRegionBannerKey) return;
      lastRegionBannerKey = key;
      regionBanner.textContent = `${reg.name} ‚Äî Difficulty ${difficultyText(band)}`;
      regionBanner.style.opacity = "1";
      clearTimeout(showRegionBanner._t);
      showRegionBanner._t = setTimeout(()=>{ regionBanner.style.opacity = "0"; }, 3000);
    }

    function spawnFloatingText(text, x, y, z, color="#fde68a"){
      const el = document.createElement("div");
      el.className = "floatText";
      el.textContent = text;
      el.style.color = color;
      fxLayer.appendChild(el);
      floatingTexts.push({ el, x, y, z, life:0, maxLife:1.2 });
    }

    function tickFloatingTexts(dt){
      for(let i=floatingTexts.length-1;i>=0;i--){
        const f = floatingTexts[i];
        f.life += dt;
        f.y += dt*0.95;

        const p = _v3.set(f.x, f.y, f.z).project(camera);
        const onScreen = p.z < 1;
        if(onScreen){
          const sx = (p.x*0.5 + 0.5) * innerWidth;
          const sy = (-p.y*0.5 + 0.5) * innerHeight;
          f.el.style.display = "block";
          f.el.style.left = `${sx}px`;
          f.el.style.top = `${sy}px`;
          f.el.style.opacity = String(clamp(1 - f.life/f.maxLife, 0, 1));
        }else{
          f.el.style.display = "none";
        }

        if(f.life >= f.maxLife){
          f.el.remove();
          floatingTexts.splice(i,1);
        }
      }
    }

    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function smoothstep(t){ t=clamp(t,0,1); return t*t*(3-2*t); }
    function dist2(ax,az,bx,bz){ const dx=ax-bx, dz=az-bz; return dx*dx+dz*dz; }

    function xorshift32(seed){
      let x = (seed|0) || 123456789;
      return ()=>{ x^=x<<13; x^=x>>>17; x^=x<<5; return (x>>>0)/4294967296; };
    }
    function hash2i(x,z,seed){
      // stable 0..1
      const s = Math.sin((x*127.1 + z*311.7 + seed*74.7))*43758.5453123;
      return s - Math.floor(s);
    }

    // ============================================================
    // Renderer / scene
    // ============================================================
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(2, devicePixelRatio||1));
    renderer.setSize(innerWidth, innerHeight);
    renderer.setClearColor(0x070a10, 1);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x070a10, 0.013);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.05, 380);
    const world = new THREE.Group();
    scene.add(world);

    scene.add(new THREE.HemisphereLight(0xcfe3ff, 0x0b1020, 0.42));
    const dir = new THREE.DirectionalLight(0xffffff, 0.30);
    dir.position.set(10, 22, 14);
    scene.add(dir);

    // ============================================================
    // Game constants
    // ============================================================
    const SAVE_KEY = "circleRogueSave_v1";
    const WORLD_RADIUS = 1680;
    const SAFE_MARGIN  = 60;
    const DANGER_BANDS = [
      { id:"inner", min:0, max:520, hpMul:1.25, dmgMul:1.18, terrainMul:1.08, dropChance:0.48, xpMul:1.2, label:"I" },
      { id:"mid", min:520, max:1120, hpMul:2.15, dmgMul:1.72, terrainMul:1.45, dropChance:0.72, xpMul:1.85, label:"II" },
      { id:"outer", min:1120, max:WORLD_RADIUS, hpMul:3.6, dmgMul:2.55, terrainMul:1.95, dropChance:0.95, xpMul:2.8, label:"III" },
    ];

    function dangerBandAt(x,z){
      const r = Math.hypot(x,z);
      for(const band of DANGER_BANDS){
        if(r >= band.min && r < band.max) return band;
      }
      return DANGER_BANDS[DANGER_BANDS.length-1];
    }

    function difficultyText(band){
      return `Ring ${band.label} ‚Ä¢ Drop ${(band.dropChance*100)|0}% ‚Ä¢ XP x${band.xpMul.toFixed(2)}`;
    }

    const PLAYER_H = 1.72;
    const PLAYER_R = 0.35;
    const GRAVITY  = 11.0;

    const CHUNK = 64;
    const CHUNK_R = 1; // render radius in chunks (3x3 = 9 chunks)
    const ENEMY_CAP_BASE = 18;

    // ============================================================
    // UI refs
    // ============================================================
    const centerMsg = $("centerMsg");
    const centerTitle = $("centerTitle");
    const centerSub = $("centerSub");
    const lockBtn = $("lockBtn");
    const newBtn = $("newBtn");
    const resumeBtn = $("resumeBtn");
    const overlayDead = $("overlayDead");
    const fsBtn = $("fsBtn");
    const loadBtn = $("loadBtn");

    const hpText = $("hpText");
    const lvlText = $("lvlText");
    const regionText = $("regionText");
    const weaponText = $("weaponText");
    const matsText = $("matsText");
    const regionBanner = $("regionBanner");
    const fxLayer = $("fxLayer");

    const modalShade = $("modalShade");
    const modal = $("modal");

    const moveStick = $("moveStick");
    const moveKnob  = $("moveKnob");
    const lookStick = $("lookStick");
    const lookKnob  = $("lookKnob");
    const mobileInteract = $("mobileInteract");

    // ============================================================
    // Pointer lock + controls (same feel as your provided file)
    // ============================================================
    let pointerLocked = false;
    function requestLock(){ renderer.domElement.requestPointerLock?.(); }
    document.addEventListener("pointerlockchange", ()=>{
      pointerLocked = (document.pointerLockElement === renderer.domElement);
      lockBtn.style.display = (!pointerLocked && phase==="play") ? "inline-block" : "none";
    });

    // mouse look
    document.addEventListener("mousemove", (e)=>{
      if(!pointerLocked || paused || phase!=="play") return;
      const sens = 0.0022;
      me.yaw   -= e.movementX * sens;
      me.pitch -= e.movementY * sens;
      me.pitch = clamp(me.pitch, -1.32, 1.32);
    });

    // keys
    const keys = {};
    addEventListener("keydown", (e)=>{
      keys[e.key.toLowerCase()] = true;
      if(e.key===" ") e.preventDefault();
      if(e.key==="Escape" && phase==="play"){
        // let ESC unlock pointer; also closes modals
        if(uiMode !== "none") closeModal();
      }
      if((e.key==="e" || e.key==="E") && phase==="play"){
        if(uiMode==="forge") closeModal();
        else tryOpenForge();
      }
    });
    addEventListener("keyup", (e)=>{ keys[e.key.toLowerCase()] = false; });

    // fullscreen
    fsBtn.addEventListener("click", async ()=>{
      try{
        if(!document.fullscreenElement) await document.documentElement.requestFullscreen?.();
        else await document.exitFullscreen?.();
      }catch{}
    });

    // click to lock
    renderer.domElement.addEventListener("click", ()=>{
      if(phase==="play" && !pointerLocked && uiMode==="none") requestLock();
    });

    // ============================================================
    // Mobile dual joysticks (same logic as your file)
    // ============================================================
    const isCoarsePointer = matchMedia("(pointer: coarse)").matches;
    const mobile = {
      enabled: isCoarsePointer,
      moveX:0, moveY:0,
      lookX:0, lookY:0,
      movePointerId:null,
      lookPointerId:null,
    };

    function setJoystick(knob, dx, dy, r){
      if(r<=0) return {x:0,y:0};
      const len = Math.hypot(dx,dy);
      const k = (len>r && len>0) ? (r/len) : 1;
      const cx = dx*k, cy = dy*k;
      knob.style.transform = `translate(${cx}px, ${cy}px)`;
      return { x: clamp(cx/r, -1, 1), y: clamp(cy/r, -1, 1) };
    }
    function resetJoystick(knob){ knob.style.transform="translate(0px, 0px)"; }

    if(moveStick){
      moveStick.addEventListener("pointerdown", (e)=>{
        if(!mobile.enabled) return;
        mobile.movePointerId = e.pointerId;
        moveStick.setPointerCapture(e.pointerId);
        const r = moveStick.getBoundingClientRect();
        const joy = setJoystick(moveKnob, e.clientX-(r.left+r.width/2), e.clientY-(r.top+r.height/2), r.width*0.5);
        mobile.moveX = joy.x; mobile.moveY = joy.y;
      });
      moveStick.addEventListener("pointermove", (e)=>{
        if(!mobile.enabled || mobile.movePointerId!==e.pointerId) return;
        const r = moveStick.getBoundingClientRect();
        const joy = setJoystick(moveKnob, e.clientX-(r.left+r.width/2), e.clientY-(r.top+r.height/2), r.width*0.5);
        mobile.moveX = joy.x; mobile.moveY = joy.y;
      });
      const endJoy = (e)=>{
        if(mobile.movePointerId!==e.pointerId) return;
        mobile.movePointerId=null; mobile.moveX=0; mobile.moveY=0; resetJoystick(moveKnob);
      };
      moveStick.addEventListener("pointerup", endJoy);
      moveStick.addEventListener("pointercancel", endJoy);
      moveStick.addEventListener("lostpointercapture", ()=>{
        mobile.movePointerId=null; mobile.moveX=0; mobile.moveY=0; resetJoystick(moveKnob);
      });
    }

    if(lookStick){
      lookStick.addEventListener("pointerdown", (e)=>{
        if(!mobile.enabled) return;
        mobile.lookPointerId = e.pointerId;
        lookStick.setPointerCapture(e.pointerId);
        const r = lookStick.getBoundingClientRect();
        const joy = setJoystick(lookKnob, e.clientX-(r.left+r.width/2), e.clientY-(r.top+r.height/2), r.width*0.5);
        mobile.lookX = joy.x; mobile.lookY = joy.y;
      });
      lookStick.addEventListener("pointermove", (e)=>{
        if(!mobile.enabled || mobile.lookPointerId!==e.pointerId) return;
        const r = lookStick.getBoundingClientRect();
        const joy = setJoystick(lookKnob, e.clientX-(r.left+r.width/2), e.clientY-(r.top+r.height/2), r.width*0.5);
        mobile.lookX = joy.x; mobile.lookY = joy.y;
      });
      const endLook = (e)=>{
        if(mobile.lookPointerId!==e.pointerId) return;
        mobile.lookPointerId=null; mobile.lookX=0; mobile.lookY=0; resetJoystick(lookKnob);
      };
      lookStick.addEventListener("pointerup", endLook);
      lookStick.addEventListener("pointercancel", endLook);
      lookStick.addEventListener("lostpointercapture", ()=>{
        mobile.lookPointerId=null; mobile.lookX=0; mobile.lookY=0; resetJoystick(lookKnob);
      });
    }

    addEventListener("pointerup", (e)=>{
      if(mobile.movePointerId===e.pointerId){
        mobile.movePointerId=null; mobile.moveX=0; mobile.moveY=0; resetJoystick(moveKnob);
      }
      if(mobile.lookPointerId===e.pointerId){
        mobile.lookPointerId=null; mobile.lookX=0; mobile.lookY=0; resetJoystick(lookKnob);
      }
    });

    mobileInteract.addEventListener("click", ()=>{
      if(phase!=="play") return;
      if(uiMode==="forge") closeModal();
      else tryOpenForge();
    });

    // ============================================================
    // Procedural textures (fast + lightweight)
    // ============================================================
    function makeCanvasTexture(drawFn, size=256){
      const c=document.createElement("canvas"); c.width=c.height=size;
      const g=c.getContext("2d"); drawFn(g,size);
      const t=new THREE.CanvasTexture(c);
      t.colorSpace = THREE.SRGBColorSpace;
      t.wrapS=t.wrapT = THREE.RepeatWrapping;
      t.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy?.()||8);
      t.needsUpdate=true;
      return t;
    }

    // ============================================================
// FX textures + helpers (cheap detail via sprites / additive glows)
// ============================================================
const FX_TEX = {
  softGlow: makeCanvasTexture((g,n)=>{
    g.clearRect(0,0,n,n);
    const cx=n/2, cy=n/2;
    const r=n*0.48;
    const grad=g.createRadialGradient(cx,cy,0,cx,cy,r);
    grad.addColorStop(0,"rgba(255,255,255,1)");
    grad.addColorStop(0.22,"rgba(255,255,255,0.65)");
    grad.addColorStop(0.55,"rgba(255,255,255,0.18)");
    grad.addColorStop(1,"rgba(255,255,255,0)");
    g.fillStyle=grad;
    g.beginPath(); g.arc(cx,cy,r,0,Math.PI*2); g.fill();
  }, 256),
  spark: makeCanvasTexture((g,n)=>{
    g.clearRect(0,0,n,n);
    g.translate(n/2,n/2);
    for(let i=0;i<18;i++){
      g.rotate((Math.PI*2)/18);
      g.fillStyle=`rgba(255,255,255,${0.10 + Math.random()*0.12})`;
      g.fillRect(0, -2, n*0.42, 4);
    }
    g.setTransform(1,0,0,1,0,0);
    const cx=n/2, cy=n/2, r=n*0.48;
    const grad=g.createRadialGradient(cx,cy,0,cx,cy,r);
    grad.addColorStop(0,"rgba(255,255,255,0.70)");
    grad.addColorStop(1,"rgba(255,255,255,0)");
    g.fillStyle=grad;
    g.beginPath(); g.arc(cx,cy,r,0,Math.PI*2); g.fill();
  }, 256),
  runeRing: makeCanvasTexture((g,n)=>{
    g.clearRect(0,0,n,n);
    const cx=n/2, cy=n/2;
    g.strokeStyle = "rgba(255,255,255,0.9)";
    g.lineWidth = n*0.028;
    g.beginPath(); g.arc(cx,cy,n*0.36,0,Math.PI*2); g.stroke();
    g.lineWidth = n*0.012;
    g.strokeStyle = "rgba(255,255,255,0.7)";
    g.beginPath(); g.arc(cx,cy,n*0.43,0,Math.PI*2); g.stroke();
    for(let i=0;i<20;i++){
      const a = (i/20)*Math.PI*2;
      const r0 = n*0.30, r1=n*0.46;
      g.strokeStyle = `rgba(255,255,255,${0.3 + (i%2)*0.35})`;
      g.lineWidth = n*0.008;
      g.beginPath();
      g.moveTo(cx+Math.cos(a)*r0, cy+Math.sin(a)*r0);
      g.lineTo(cx+Math.cos(a)*r1, cy+Math.sin(a)*r1);
      g.stroke();
    }
  }, 256),
  crack: makeCanvasTexture((g,n)=>{
    g.clearRect(0,0,n,n);
    g.strokeStyle = "rgba(255,255,255,0.95)";
    g.lineCap = "round";
    g.lineWidth = n*0.045;
    g.beginPath();
    g.moveTo(n*0.08,n*0.48);
    for(let i=1;i<=7;i++){
      const x = n*(0.08 + i*0.12);
      const y = n*(0.52 + Math.sin(i*1.45)*0.2);
      g.lineTo(x,y);
    }
    g.stroke();
  }, 256),
};

const BOSS_FX_POOL = {
  spark: [],
  glow: [],
  ring: [],
};

const ALIEN_BOSS_VFX_POOL = {
  lasers: [],
  starTelegraphs: [],
};

function takeBossFx(type, createFn){
  const m = BOSS_FX_POOL[type]?.pop() || createFn();
  m.visible = true;
  return m;
}

function releaseBossFx(type, mesh){
  if(!mesh) return;
  mesh.visible = false;
  if(mesh.parent) mesh.parent.remove(mesh);
  if(mesh.material){
    if(Array.isArray(mesh.material)) mesh.material.forEach(mm=>{ if(mm.opacity!=null) mm.opacity = mm.userData?.baseOpacity ?? mm.opacity; });
    else if(mesh.material.opacity!=null) mesh.material.opacity = mesh.material.userData?.baseOpacity ?? mesh.material.opacity;
  }
  BOSS_FX_POOL[type]?.push(mesh);
}



function makeBossFxSprite(tex=FX_TEX.softGlow, color=0xffffff, size=1, opacity=0.6){
  const sp = new THREE.Sprite(new THREE.SpriteMaterial({
    map: tex, color, transparent:true, opacity,
    depthWrite:false, blending:THREE.AdditiveBlending
  }));
  sp.scale.set(size,size,1);
  sp.material.userData = { baseOpacity: opacity };
  return sp;
}

function spawnBossFxSparkBurst(x,y,z,color=0xffffff,count=8,speed=5,life=0.7){
  for(let i=0;i<count;i++){
    const a = (i/count)*Math.PI*2 + Math.random()*0.25;
    const v = speed*(0.65+Math.random()*0.6);
    const s = takeBossFx('spark', ()=>makeBossFxSprite(FX_TEX.spark,color,0.45,0.85));
    s.material.color.setHex(color);
    s.material.opacity = 0.85;
    s.position.set(x,y + 0.08 + Math.random()*0.2,z);
    world.add(s);
    projectiles.push({ mesh:s, kind:'bossFx', fxType:'spark', x:s.position.x, y:s.position.y, z:s.position.z, vx:Math.cos(a)*v, vy:1.0+Math.random()*1.6, vz:Math.sin(a)*v, drag:0.88, life:life*(0.8+Math.random()*0.4), grav:7.5 });
  }
}

function spawnBossFxRing(x,y,z,color=0xffffff,life=0.55,maxScale=3.6,kind='shockwave'){
  const ring = takeBossFx('ring', ()=> new THREE.Mesh(
    bossGeoCache().bossFxRing,
    new THREE.MeshBasicMaterial({ map:FX_TEX.runeRing, color, transparent:true, opacity:0.7, side:THREE.DoubleSide, depthWrite:false, blending:THREE.AdditiveBlending })
  ));
  ring.material.color.setHex(color);
  ring.material.opacity = 0.75;
  ring.rotation.x = -Math.PI/2;
  ring.position.set(x,y,z);
  ring.scale.setScalar(0.72);
  world.add(ring);
  projectiles.push({ mesh:ring, kind, fxType:'ring', from:'fx', x,y,z, vx:0,vy:0,vz:0, life, maxLife:life, maxScale });
  return ring;
}
function glowSprite(color=0xffffff, size=0.6, opacity=0.85, tex=FX_TEX.softGlow){
  const m = new THREE.SpriteMaterial({
    map: tex,
    color,
    transparent:true,
    opacity,
    depthWrite:false,
    blending: THREE.AdditiveBlending
  });
  const s = new THREE.Sprite(m);
  s.scale.set(size, size, 1);
  return s;
}

function addEyePair(parent, opts={}){
  const {
    y=0.9, z=0.55, sep=0.22,
    size=0.16,
    color=0xffffff,
    opacity=0.95
  } = opts;
  const L = glowSprite(color, size, opacity);
  const R = glowSprite(color, size, opacity);
  L.position.set(-sep, y, z);
  R.position.set( sep, y, z);
  parent.add(L,R);
  return [L,R];
}

function addAdditiveRing(parent, radius=0.6, tube=0.06, color=0xffffff, opacity=0.6){
  const ring = new THREE.Mesh(
    new THREE.TorusGeometry(radius, tube, 10, 28),
    new THREE.MeshBasicMaterial({
      color,
      transparent:true,
      opacity,
      depthWrite:false,
      blending:THREE.AdditiveBlending
    })
  );
  parent.add(ring);
  return ring;
}
    const TEX = {
      desert: makeCanvasTexture((g,n)=>{
        g.fillStyle="#d7c08b"; g.fillRect(0,0,n,n);
        for(let i=0;i<5200;i++){
          const x=(Math.random()*n)|0, y=(Math.random()*n)|0;
          const a=0.04+Math.random()*0.12;
          const v=170+((Math.random()*40)|0);
          g.fillStyle=`rgba(${v},${v-6},${v-20},${a})`;
          g.fillRect(x,y,1,1);
        }
        for(let i=0;i<60;i++){
          const x=(Math.random()*n)|0;
          g.fillStyle=`rgba(90,60,20,${0.03+Math.random()*0.05})`;
          g.fillRect(x,0,1,n);
        }
      }),
      forest: makeCanvasTexture((g,n)=>{
        g.fillStyle="#2f6b3a"; g.fillRect(0,0,n,n);
        for(let i=0;i<5200;i++){
          const x=(Math.random()*n)|0, y=(Math.random()*n)|0;
          const a=0.04+Math.random()*0.10;
          const v=30+((Math.random()*40)|0);
          g.fillStyle=`rgba(${v},${80+((Math.random()*60)|0)},${v},${a})`;
          g.fillRect(x,y,1,1);
        }
        g.strokeStyle="rgba(255,255,255,0.05)";
        for(let i=0;i<16;i++){
          g.beginPath();
          g.moveTo(0, (i/16)*n);
          g.lineTo(n, (i/16)*n);
          g.stroke();
        }
      }),
      snow: makeCanvasTexture((g,n)=>{
        g.fillStyle="#e8f0ff"; g.fillRect(0,0,n,n);
        for(let i=0;i<6200;i++){
          const x=(Math.random()*n)|0, y=(Math.random()*n)|0;
          const a=0.03+Math.random()*0.08;
          const v=210+((Math.random()*35)|0);
          g.fillStyle=`rgba(${v},${v},${255},${a})`;
          g.fillRect(x,y,1,1);
        }
        for(let i=0;i<40;i++){
          const x=(Math.random()*n)|0, w=1+((Math.random()*2)|0);
          g.fillStyle=`rgba(120,170,255,${0.02+Math.random()*0.03})`;
          g.fillRect(x,0,w,n);
        }
      }),
      alien: makeCanvasTexture((g,n)=>{
        const grad=g.createLinearGradient(0,0,n,n);
        grad.addColorStop(0,"#ff3ad7");
        grad.addColorStop(1,"#22d3ee");
        g.fillStyle=grad; g.fillRect(0,0,n,n);
        for(let i=0;i<5000;i++){
          const x=(Math.random()*n)|0, y=(Math.random()*n)|0;
          const a=0.03+Math.random()*0.10;
          const r=140+((Math.random()*115)|0);
          const b=140+((Math.random()*115)|0);
          g.fillStyle=`rgba(${r},${60+((Math.random()*80)|0)},${b},${a})`;
          g.fillRect(x,y,1,1);
        }
        for(let i=0;i<90;i++){
          const x=(Math.random()*n)|0;
          g.fillStyle=`rgba(255,255,255,${0.02+Math.random()*0.03})`;
          g.fillRect(x,0,1,n);
        }
      }),
      hell: makeCanvasTexture((g,n)=>{
        g.fillStyle="#3b0a12"; g.fillRect(0,0,n,n);
        for(let i=0;i<5600;i++){
          const x=(Math.random()*n)|0, y=(Math.random()*n)|0;
          const a=0.04+Math.random()*0.12;
          g.fillStyle=`rgba(${140+((Math.random()*115)|0)},${20+((Math.random()*30)|0)},${20+((Math.random()*40)|0)},${a})`;
          g.fillRect(x,y,1,1);
        }
        // lava cracks
        g.strokeStyle="rgba(255,80,30,0.22)";
        g.lineWidth=2;
        for(let i=0;i<24;i++){
          g.beginPath();
          g.moveTo(Math.random()*n, Math.random()*n);
          for(let k=0;k<6;k++){
            g.lineTo(Math.random()*n, Math.random()*n);
          }
          g.stroke();
        }
      })
    };

    // ============================================================
    // Regions (big pie-slices around the circle)
    // ============================================================
    const REGIONS = [
      { id:"desert", name:"Desert Expanse",   fog:0xcaa46f, sky:0x0a1018, tex:"desert", ground:0xffffff,
        props:{ cactus:18, rock:12 }, drops:["iron","hide"], enemies:["scarab","scorpion","sandwisp"] },
      { id:"forest", name:"Forest Wilds",     fog:0x224b31, sky:0x071018, tex:"forest", ground:0xffffff,
        props:{ tree:16, rock:8 }, drops:["hide","essence"], enemies:["boar","spriggan","spitter","goblin","mirebat"] },
      { id:"snow",   name:"Frost Crown",      fog:0xbcd5ff, sky:0x050812, tex:"snow", ground:0xffffff,
        props:{ pine:16, rock:12 }, drops:["iron","crystal"], enemies:["icegolem","wolf","frostling"] },
      { id:"alien",  name:"Neon Bloom",       fog:0x5be3ff, sky:0x070610, tex:"alien", ground:0xffffff,
        props:{ crystal:18, shroom:12 }, drops:["crystal","essence"], enemies:["drone","floater","shardling","skitter"] },
      { id:"hell",   name:"Ash & Ember",      fog:0x4a0010, sky:0x050306, tex:"hell",  ground:0xffffff,
        props:{ spire:16, lava:10 }, drops:["ember","iron"], enemies:["imp","brute","mortar"] },
    ];

    function regionAt(x,z){
      const ang = Math.atan2(z, x); // -pi..pi
      let t = (ang + Math.PI) / (Math.PI*2); // 0..1
      const idx = Math.floor(t * REGIONS.length) % REGIONS.length;
      return REGIONS[idx];
    }

    // ============================================================
    // Height function (deterministic)
    // ============================================================
    let worldSeed = (Math.random()*1e9)|0;
    function heightAt(x,z, regId){
      // low-cost layered noise
      const s = worldSeed;
      const n1 = hash2i(Math.floor(x*0.20), Math.floor(z*0.20), s);
      const n2 = hash2i(Math.floor(x*0.07), Math.floor(z*0.07), s^0x9e3779b9);
      const n3 = hash2i(Math.floor(x*0.03), Math.floor(z*0.03), s^0x85ebca6b);

      let amp = 0.55;
      if(regId==="desert") amp = 1.05;
      if(regId==="forest") amp = 0.55;
      if(regId==="snow")   amp = 0.75;
      if(regId==="alien")  amp = 0.85;
      if(regId==="hell")   amp = 0.95;

      const h = (n1-0.5)*0.8 + (n2-0.5)*1.2 + (n3-0.5)*1.8;
      return h * amp;
    }

    // ============================================================
    // Shared geometries/materials for props
    // ============================================================
    const MAT = {
      cactus: new THREE.MeshStandardMaterial({ color:0x20c35a, roughness:0.95 }),
      wood:   new THREE.MeshStandardMaterial({ color:0x6b4f2a, roughness:0.95 }),
      leaf:   new THREE.MeshStandardMaterial({ color:0x16a34a, roughness:0.95 }),
      pine:   new THREE.MeshStandardMaterial({ color:0x1f7a4f, roughness:0.95 }),
      rock:   new THREE.MeshStandardMaterial({ color:0x6b7280, roughness:0.98 }),
      ice:    new THREE.MeshStandardMaterial({ color:0xdbeafe, roughness:0.55, metalness:0.05, emissive:0x0b1b3f, emissiveIntensity:0.15 }),
      crystal:new THREE.MeshStandardMaterial({ color:0xff3ad7, roughness:0.28, metalness:0.18, emissive:0x7c3aed, emissiveIntensity:0.35 }),
      shroom: new THREE.MeshStandardMaterial({ color:0x22d3ee, roughness:0.75, emissive:0x0ea5e9, emissiveIntensity:0.22 }),
      spire:  new THREE.MeshStandardMaterial({ color:0x1f0a10, roughness:0.95, emissive:0x3b0a12, emissiveIntensity:0.20 }),
      lava:   new THREE.MeshStandardMaterial({ color:0xff3b1a, roughness:0.35, emissive:0xff3b1a, emissiveIntensity:1.20 }),
      forge:  new THREE.MeshStandardMaterial({ color:0x111827, roughness:0.7, metalness:0.25, emissive:0x0b1020, emissiveIntensity:0.2 }),
      forgeGlow: new THREE.MeshStandardMaterial({ color:0x22c55e, roughness:0.25, metalness:0.0, emissive:0x22c55e, emissiveIntensity:1.2, transparent:true, opacity:0.7 }),
      drop:   new THREE.MeshStandardMaterial({ color:0xffffff, roughness:0.35, metalness:0.05, emissive:0xffffff, emissiveIntensity:0.45 }),
    };

    const GEO = {
      ground: (()=>{
        const g = new THREE.PlaneGeometry(CHUNK, CHUNK, 12, 12);
        g.rotateX(-Math.PI/2);
        return g;
      })(),
      cactus: new THREE.CylinderGeometry(0.15, 0.22, 2.2, 6),
      trunk:  new THREE.CylinderGeometry(0.12, 0.18, 2.2, 7),
      cone:   new THREE.ConeGeometry(0.9, 2.4, 8),
      pine:   new THREE.ConeGeometry(1.0, 2.6, 8),
      rock:   new THREE.DodecahedronGeometry(0.55, 0),
      ice:    new THREE.DodecahedronGeometry(0.7, 0),
      crystal:new THREE.OctahedronGeometry(0.75, 0),
      shroom: new THREE.CylinderGeometry(0.25, 0.35, 0.6, 8),
      cap:    new THREE.SphereGeometry(0.55, 10, 10),
      spire:  new THREE.ConeGeometry(0.55, 2.8, 7),
      lava:   new THREE.SphereGeometry(0.45, 12, 10),
      bolt:   new THREE.SphereGeometry(0.08, 10, 8),
      ember:  new THREE.SphereGeometry(0.12, 10, 8),
      drop:   new THREE.OctahedronGeometry(0.16, 0),
    };

    const groundMats = {};
    for(const r of REGIONS){
      const t = TEX[r.tex];
      const m = new THREE.MeshStandardMaterial({
        color: r.ground,
        map: t,
        roughness: 1.0,
        metalness: 0.0,
      });
      m.map.repeat.set(10, 10);
      groundMats[r.id] = m;
    }

    // ============================================================
    // Chunk system (procedural visuals within range)
    // ============================================================
    const chunks = new Map(); // key -> {group, ground, props[]}

    function chunkKey(cx,cz){ return cx + "," + cz; }

    function inWorldCircle(x,z){
      return (x*x + z*z) <= (WORLD_RADIUS*WORLD_RADIUS);
    }

    function deformGround(geo, cx, cz, regionId){
      // Modify position buffer to match heightAt for this chunk
      const pos = geo.attributes.position;
      for(let i=0;i<pos.count;i++){
        const vx = pos.getX(i);
        const vz = pos.getZ(i);
        const wx = cx*CHUNK + vx;
        const wz = cz*CHUNK + vz;
        const h = heightAt(wx, wz, regionId);
        pos.setY(i, h);
      }
      pos.needsUpdate = true;
      geo.computeVertexNormals();
    }

    function addInstanced(group, geo, mat, count, rnd, placeFn){
      const im = new THREE.InstancedMesh(geo, mat, count);
      im.castShadow = false;
      im.receiveShadow = true;
      const dummy = new THREE.Object3D();
      for(let i=0;i<count;i++){
        placeFn(dummy, i, rnd);
        dummy.updateMatrix();
        im.setMatrixAt(i, dummy.matrix);
      }
      group.add(im);
      return im;
    }

    function createChunk(cx, cz){
      const key = chunkKey(cx,cz);
      if(chunks.has(key)) return;

      const wx = cx*CHUNK, wz = cz*CHUNK;
      if(!inWorldCircle(wx, wz)) return;

      const reg = regionAt(wx, wz);
      const group = new THREE.Group();
      group.position.set(wx, 0, wz);

      // ground
      const g = GEO.ground.clone();
      deformGround(g, cx, cz, reg.id);
      const ground = new THREE.Mesh(g, groundMats[reg.id]);
      ground.receiveShadow = true;
      group.add(ground);

      const rnd = xorshift32(((worldSeed^0xA53A9B1D) + cx*928371 + cz*19349663)|0);

      // Props by region (instanced, low overhead)
      const prop = reg.props || {};
      const chunkCenterBand = dangerBandAt(wx + CHUNK*0.5, wz + CHUNK*0.5);
      const baseCount = (a)=>Math.max(0, Math.round((a + ((rnd()*6)|0)) * chunkCenterBand.terrainMul));

      if(reg.id==="desert"){
        addInstanced(group, GEO.cactus, MAT.cactus, baseCount(prop.cactus||18), rnd, (d,i,rr)=>{
          const px = (rr()-0.5)*(CHUNK*0.92);
          const pz = (rr()-0.5)*(CHUNK*0.92);
          const y  = heightAt(wx+px, wz+pz, reg.id);
          d.position.set(px, y+1.05, pz);
          d.rotation.y = rr()*Math.PI*2;
          const s = 0.7 + rr()*0.9;
          d.scale.set(s, 0.85 + rr()*0.9, s);
        });
        addInstanced(group, GEO.rock, MAT.rock, baseCount(prop.rock||14), rnd, (d,i,rr)=>{
          const px = (rr()-0.5)*(CHUNK*0.95);
          const pz = (rr()-0.5)*(CHUNK*0.95);
          const y  = heightAt(wx+px, wz+pz, reg.id);
          d.position.set(px, y+0.35, pz);
          d.rotation.y = rr()*Math.PI*2;
          const s = 0.35 + rr()*0.75;
          d.scale.set(s,s,s);
        });
      }

      if(reg.id==="forest"){
        const treeCount = baseCount(prop.tree||18);
        const treeSpots = [];
        for(let i=0;i<treeCount;i++){
          const px=(rnd()-0.5)*(CHUNK*0.9), pz=(rnd()-0.5)*(CHUNK*0.9);
          const y=heightAt(wx+px, wz+pz, reg.id);
          const s=0.7+rnd()*1.1;
          const trunkSy = 1.0 + rnd()*1.0;
          const crownSy = 1.2 + rnd()*0.7;
          const crown = s * (1.25 + rnd()*0.2);
          treeSpots.push({ px, pz, y, s, rot:rnd()*Math.PI*2, trunkSy, crownSy, crown });
        }

        // trunks
        addInstanced(group, GEO.trunk, MAT.wood, treeCount, rnd, (d,i)=>{
          const t = treeSpots[i];
          d.position.set(t.px, t.y+1.1, t.pz);
          d.rotation.y=t.rot;
          d.scale.set(t.s, t.trunkSy, t.s);
        });
        // leaves cones (aligned with trunks)
        addInstanced(group, GEO.cone, MAT.leaf, treeCount, rnd, (d,i)=>{
          const t = treeSpots[i];
          const trunkTop = t.y + 1.1 + (1.1 * t.trunkSy);
          const crownY = trunkTop + (1.2 * t.crownSy);
          d.position.set(t.px, crownY, t.pz);
          d.rotation.y=t.rot;
          d.scale.set(t.crown, t.crownSy, t.crown);
        });
        addInstanced(group, GEO.rock, MAT.rock, baseCount(prop.rock||10), rnd, (d,i,rr)=>{
          const px=(rr()-0.5)*(CHUNK*0.95), pz=(rr()-0.5)*(CHUNK*0.95);
          const y=heightAt(wx+px, wz+pz, reg.id);
          d.position.set(px, y+0.35, pz);
          d.rotation.y=rr()*Math.PI*2;
          const s=0.35+rr()*0.7;
          d.scale.set(s,s,s);
        });
      }

      if(reg.id==="snow"){
        const pineCount = baseCount(prop.pine||18);
        const pineSpots = [];
        for(let i=0;i<pineCount;i++){
          const px=(rnd()-0.5)*(CHUNK*0.9), pz=(rnd()-0.5)*(CHUNK*0.9);
          const y=heightAt(wx+px, wz+pz, reg.id);
          const rot=rnd()*Math.PI*2;
          const trunkS=0.6+rnd()*0.9;
          const trunkSy=0.8+rnd()*1.0;
          const crownS=0.8+rnd()*1.1;
          const crownSy=0.9+rnd()*1.0;
          pineSpots.push({ px,pz,y,rot,trunkS,trunkSy,crownS,crownSy });
        }
        addInstanced(group, GEO.trunk, MAT.wood, pineCount, rnd, (d,i)=>{
          const t = pineSpots[i];
          d.position.set(t.px, t.y+1.0, t.pz);
          d.rotation.y=t.rot;
          d.scale.set(t.trunkS, t.trunkSy, t.trunkS);
        });
        addInstanced(group, GEO.pine, MAT.pine, pineCount, rnd, (d,i)=>{
          const t = pineSpots[i];
          const trunkTop = t.y + 1.0 + (1.1 * t.trunkSy);
          const crownY = trunkTop + (1.3 * t.crownSy);
          d.position.set(t.px, crownY, t.pz);
          d.rotation.y=t.rot;
          d.scale.set(t.crownS, t.crownSy, t.crownS);
        });
        addInstanced(group, GEO.ice, MAT.ice, baseCount(prop.rock||12), rnd, (d,i,rr)=>{
          const px=(rr()-0.5)*(CHUNK*0.95), pz=(rr()-0.5)*(CHUNK*0.95);
          const y=heightAt(wx+px, wz+pz, reg.id);
          d.position.set(px, y+0.45, pz);
          d.rotation.y=rr()*Math.PI*2;
          const s=0.35+rr()*0.85;
          d.scale.set(s,s,s);
        });
      }

      if(reg.id==="alien"){
        addInstanced(group, GEO.crystal, MAT.crystal, baseCount(prop.crystal||18), rnd, (d,i,rr)=>{
          const px=(rr()-0.5)*(CHUNK*0.92), pz=(rr()-0.5)*(CHUNK*0.92);
          const y=heightAt(wx+px, wz+pz, reg.id);
          d.position.set(px, y+0.9, pz);
          d.rotation.y=rr()*Math.PI*2;
          const s=0.6+rr()*1.4;
          d.scale.set(s, 0.8+rr()*1.8, s);
        });
        addInstanced(group, GEO.shroom, MAT.shroom, baseCount(prop.shroom||12), rnd, (d,i,rr)=>{
          const px=(rr()-0.5)*(CHUNK*0.95), pz=(rr()-0.5)*(CHUNK*0.95);
          const y=heightAt(wx+px, wz+pz, reg.id);
          d.position.set(px, y+0.3, pz);
          d.rotation.y=rr()*Math.PI*2;
          const s=0.7+rr()*1.0;
          d.scale.set(s, 0.8+rr()*0.8, s);
        });
        addInstanced(group, GEO.cap, MAT.crystal, baseCount(prop.shroom||12), rnd, (d,i,rr)=>{
          const px=(rr()-0.5)*(CHUNK*0.95), pz=(rr()-0.5)*(CHUNK*0.95);
          const y=heightAt(wx+px, wz+pz, reg.id);
          d.position.set(px, y+0.9, pz);
          d.rotation.y=rr()*Math.PI*2;
          const s=0.7+rr()*1.0;
          d.scale.set(s, 0.55+rr()*0.6, s);
        });
      }

      if(reg.id==="hell"){
        addInstanced(group, GEO.spire, MAT.spire, baseCount(prop.spire||16), rnd, (d,i,rr)=>{
          const px=(rr()-0.5)*(CHUNK*0.92), pz=(rr()-0.5)*(CHUNK*0.92);
          const y=heightAt(wx+px, wz+pz, reg.id);
          d.position.set(px, y+1.35, pz);
          d.rotation.y=rr()*Math.PI*2;
          const s=0.7+rr()*1.2;
          d.scale.set(s, 0.9+rr()*1.2, s);
        });
        addInstanced(group, GEO.lava, MAT.lava, baseCount(prop.lava||12), rnd, (d,i,rr)=>{
          const px=(rr()-0.5)*(CHUNK*0.95), pz=(rr()-0.5)*(CHUNK*0.95);
          const y=heightAt(wx+px, wz+pz, reg.id);
          d.position.set(px, y+0.4, pz);
          d.rotation.y=rr()*Math.PI*2;
          const s=0.65+rr()*1.0;
          d.scale.set(s,s,s);
        });
      }

      world.add(group);
      chunks.set(key, { group, ground });
    }

    function disposeChunk(key){
      const c = chunks.get(key);
      if(!c) return;
      world.remove(c.group);
      c.group.traverse((o)=>{
        if(o.geometry?.dispose) o.geometry.dispose();
        const m = o.material;
        if(Array.isArray(m)) m.forEach(mm=>mm?.dispose?.());
        else m?.dispose?.();
      });
      chunks.delete(key);
    }

    let _lastChunkX = 999999;
let _lastChunkZ = 999999;

function tickChunks(){
  const cx = Math.floor(me.x / CHUNK);
  const cz = Math.floor(me.z / CHUNK);
  if(cx === _lastChunkX && cz === _lastChunkZ) return;
  _lastChunkX = cx; _lastChunkZ = cz;

  for(let dz=-CHUNK_R; dz<=CHUNK_R; dz++){
    for(let dx=-CHUNK_R; dx<=CHUNK_R; dx++){
      createChunk(cx+dx, cz+dz);
    }
  }
  for(const key of chunks.keys()){
    const [kx,kz] = key.split(",").map(Number);
    if(Math.abs(kx-cx)>CHUNK_R+1 || Math.abs(kz-cz)>CHUNK_R+1){
      disposeChunk(key);
    }
  }
}

    // ============================================================
    // Forge placement (pre-generated, highlighted, interact pauses)
    // ============================================================
    const forges = []; // {x,z, regionId, mesh, beacon}
    const FORGE_ACTIVE_MAX = 18;          // how many full forge meshes to keep alive
const FORGE_ACTIVE_DIST = 320;        // only consider forges within this distance
const FORGE_ACTIVE_DIST2 = FORGE_ACTIVE_DIST * FORGE_ACTIVE_DIST;
    let lastRegionBannerKey = "";
    const floatingTexts = [];
    function buildForgeMesh(){
      const g = new THREE.Group();
      const base = new THREE.Mesh(new THREE.CylinderGeometry(1.1, 1.2, 0.5, 16), MAT.forge);
      base.position.y = 0.25;
      g.add(base);

      const anvil = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.35, 0.9), MAT.forge);
      anvil.position.set(0, 0.78, 0);
      g.add(anvil);

      const horn = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.05, 0.9, 12), MAT.forge);
      horn.rotation.z = Math.PI/2;
      horn.position.set(0.85, 0.82, 0);
      g.add(horn);

      const glowRing = new THREE.Mesh(new THREE.TorusGeometry(1.35, 0.12, 12, 28), MAT.forgeGlow);
      glowRing.rotation.x = Math.PI/2;
      glowRing.position.y = 0.08;
      g.add(glowRing);

      const beaconMat = new THREE.MeshBasicMaterial({
        color: 0x6ee7b7,
        transparent: true,
        opacity: 0.28,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
      });
      const beacon = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.65, 90, 12, 1, true), beaconMat);
      beacon.position.y = 45.0;
      g.add(beacon);

      const light = new THREE.PointLight(0x22c55e, 1.25, 16, 2.0);
      light.position.set(0, 2.2, 0);
      g.add(light);

      g.userData.glowRing = glowRing;
      g.userData.beacon = beacon;
      g.userData.light = light;
      return g;
    }
    function ensureForgeBeacon(f){
  if(f.beaconSprite) return;
  const y = heightAt(f.x, f.z, f.regionId);
  const s = glowSprite(0x6ee7b7, 3.4, 0.22, FX_TEX.softGlow); // cheap
  s.position.set(f.x, y + 26, f.z);
  world.add(s);
  f.beaconSprite = s;
}

    function genForges(){
      forges.length = 0;
      const rnd = xorshift32(worldSeed ^ 0xC0FFEE);
      const ringCount = 8;

      for(let ring=0; ring<ringCount; ring++){
        const ringT = (ring+1)/(ringCount+1);
        const radius = 240 + ringT*(WORLD_RADIUS-330);
        for(let regionIdx=0; regionIdx<REGIONS.length; regionIdx++){
          const regionStart = (regionIdx / REGIONS.length) * Math.PI*2 - Math.PI;
          const regionEnd = ((regionIdx+1) / REGIONS.length) * Math.PI*2 - Math.PI;
          const slice = regionEnd - regionStart;
          const perSlice = 2 + Math.floor(ring/2);
          for(let j=0;j<perSlice;j++){
            const lane = (j+1)/(perSlice+1);
            const angle = regionStart + slice*(0.10 + 0.80*lane) + (rnd()-0.5)*slice*0.10;
            const x = Math.cos(angle)*radius;
            const z = Math.sin(angle)*radius;
            const reg = regionAt(x,z);
            forges.push({ x, z, regionId: reg.id, mesh:null });
          }
        }
      }
    }

    function tickForges(now){
  // always ensure cheap beacons (they‚Äôre just sprites)
  for(const f of forges) ensureForgeBeacon(f);

  // pick nearest forges (within distance), keep only a small number ‚Äúfully alive‚Äù
  const near = [];
  for(const f of forges){
    const d2 = dist2(me.x, me.z, f.x, f.z);
    if(d2 <= FORGE_ACTIVE_DIST2) near.push([d2, f]);
  }
  near.sort((a,b)=>a[0]-b[0]);
  const activeSet = new Set(near.slice(0, FORGE_ACTIVE_MAX).map(x=>x[1]));

  // spawn/animate only active; despawn the rest
  for(const f of forges){
    const active = activeSet.has(f);

    if(active){
      if(!f.mesh){
        const m = buildForgeMesh();
        const y = heightAt(f.x, f.z, f.regionId);
        m.position.set(f.x, y, f.z);
        world.add(m);
        f.mesh = m;
      }

      // animate nearby only
      const t = now * 0.001;
      const pulse = 0.65 + 0.35 * Math.sin(t*2.2 + (f.x+f.z)*0.01);
      f.mesh.userData.glowRing.material.opacity = 0.30 + 0.55*pulse;
      f.mesh.userData.beacon.material.opacity   = 0.18 + 0.14*pulse;

      // üëá point lights are expensive ‚Äî keep them only for active forges
      f.mesh.userData.light.intensity = 0.6 + 0.8*pulse;
      f.mesh.rotation.y += 0.002;

      // make beacon sprite a little stronger when close
      if(f.beaconSprite) f.beaconSprite.material.opacity = 0.10;
    }else{
      // remove heavy mesh if it exists
      if(f.mesh){
        world.remove(f.mesh);
        f.mesh.traverse(o=>{
          if(o.geometry?.dispose) o.geometry.dispose();
          const m = o.material;
          if(Array.isArray(m)) m.forEach(mm=>mm?.dispose?.());
          else m?.dispose?.();
        });
        f.mesh = null;
      }
      // beacon sprite stays (cheap)
      if(f.beaconSprite) f.beaconSprite.material.opacity = 0.22;
    }
  }
}

    function nearestForge(){
      let best=null, bestD=1e18;
      for(const f of forges){
        const d2 = dist2(me.x, me.z, f.x, f.z);
        if(d2 < bestD){ bestD=d2; best=f; }
      }
      return best ? { forge:best, d:Math.sqrt(bestD) } : null;
    }

    // ============================================================
    // Weapons
    // ============================================================
    const WEAPONS = {
      "Arc Bolt": {
        kind:"bolt",
        desc:"Fast bolts. Reliable. Moderate range.",
        dmg: 10, range: 28, fireRate: 7.2,
        color: 0x60a5fa, splinter:false
      },
      "Sun Beam": {
        kind:"beam",
        desc:"Continuous beam. Melts single targets in-cone.",
        dps: 18, range: 24,
        color: 0xfff3a0
      },
      "Shock Wave": {
        kind:"wave",
        desc:"Forward wave that can hit multiple enemies.",
        dmg: 16, range: 18, fireRate: 2.2,
        color: 0x22c55e
      },
      "Shard Rifle": {
        kind:"bolt",
        desc:"Bolts that splinter to nearby enemies.",
        dmg: 9, range: 30, fireRate: 6.2,
        color: 0xff3ad7, splinter:true
      },
      "Ember Lance": {
        kind:"bolt",
        desc:"Slow heavy bolt with small explosion on hit.",
        dmg: 18, range: 26, fireRate: 3.0,
        color: 0xff3b1a, explode:true
      },
      "Viper Needler": { kind:"bolt", desc:"Poisons targets with quick toxic needles.", dmg:8, range:28, fireRate:8.0, color:0x7cff6b, poison:3.0 },
      "Toxic Repeater": { kind:"bolt", desc:"Rapid poison bolts with decent pressure.", dmg:7, range:27, fireRate:9.1, color:0x52ff8f, poison:2.2 },
      "Stun Hammer": { kind:"bolt", desc:"Heavy shock rounds that briefly stun.", dmg:22, range:24, fireRate:2.0, color:0xfde047, stun:0.75 },
      "Static Pike": { kind:"bolt", desc:"Precise rounds with a short electrical stun.", dmg:15, range:30, fireRate:3.8, color:0x93c5fd, stun:0.35 },
      "Thunder Fork": { kind:"bolt", desc:"Chain lightning with 2 jumps.", dmg:13, range:28, fireRate:4.2, color:0x7dd3fc, chainBounces:2, chainRange:7.2 },
      "Storm Scepter": { kind:"bolt", desc:"Chain lightning with 3 jumps and punchy arcs.", dmg:14, range:29, fireRate:3.8, color:0x38bdf8, chainBounces:3, chainRange:8.2 },
      "Zeus Driver": { kind:"bolt", desc:"Devastating lightning cannon with many bounces.", dmg:26, range:32, fireRate:1.9, color:0x22d3ee, chainBounces:6, chainRange:9.5, explode:true, aoe:2.8 },
      "Tri-Seeker": { kind:"bolt", desc:"Fires at up to 3 nearest enemies when one is targeted.", dmg:10, range:27, fireRate:4.8, color:0xa78bfa, volleyTargets:3 },
      "Hydra Volley": { kind:"bolt", desc:"Launches 3 seeking bolts with light splinters.", dmg:11, range:30, fireRate:4.0, color:0xc084fc, volleyTargets:3, splinter:2 },
      "Cerberus Array": { kind:"bolt", desc:"Triple-lock launcher with explosive payload.", dmg:14, range:31, fireRate:3.0, color:0xf97316, volleyTargets:3, explode:true, aoe:2.9 },
      "Splintergun II": { kind:"bolt", desc:"Shatters into 2 extra shards on hit.", dmg:12, range:29, fireRate:5.6, color:0xe879f9, splinter:2 },
      "Splintergun III": { kind:"bolt", desc:"Shatters into 3 extra shards on hit.", dmg:11, range:29, fireRate:5.2, color:0xd946ef, splinter:3 },
      "Splinterstorm": { kind:"bolt", desc:"Massive 5-way splinter burst weapon.", dmg:10, range:30, fireRate:4.3, color:0xff4df0, splinter:5 },
      "Nova Cannon": { kind:"bolt", desc:"Huge explosive shots with heavy recoil force.", dmg:28, range:27, fireRate:1.7, color:0xfb7185, explode:true, aoe:3.6, knockback:7.5 },
      "Quake Driver": { kind:"bolt", desc:"Knockback slugs launch enemies backward.", dmg:20, range:28, fireRate:2.5, color:0xf59e0b, knockback:10.0 },
      "Ramjet": { kind:"bolt", desc:"Fast kinetic rounds with medium knockback.", dmg:14, range:31, fireRate:5.1, color:0xfbbf24, knockback:5.2 },
      "Venom Arc": { kind:"bolt", desc:"Poison + chain combo for swarm clearing.", dmg:12, range:28, fireRate:4.1, color:0x4ade80, poison:2.6, chainBounces:2, chainRange:7.0 },
      "Paralyzer": { kind:"bolt", desc:"Long stuns but slower firing cadence.", dmg:18, range:26, fireRate:1.5, color:0xfef08a, stun:1.15 },
      "Frost Shock": { kind:"bolt", desc:"Stuns and bounces once through packs.", dmg:16, range:27, fireRate:2.7, color:0xbfdbfe, stun:0.55, chainBounces:1, chainRange:6.4 },
      "Ion Scatter": { kind:"bolt", desc:"Explosive ion bursts with two splinters.", dmg:15, range:29, fireRate:3.3, color:0x67e8f9, explode:true, aoe:2.6, splinter:2 },
      "Overload Prism": { kind:"bolt", desc:"Arcs lightning, then splinters from the first target.", dmg:17, range:30, fireRate:2.8, color:0x818cf8, chainBounces:3, chainRange:7.8, splinter:3 },
      "Abyss Rail": { kind:"bolt", desc:"Elite railgun with stun, poison, and knockback.", dmg:34, range:36, fireRate:1.6, color:0x94a3b8, stun:0.45, poison:2.8, knockback:8.0 },
      "Cataclysm Core": { kind:"bolt", desc:"Expensive superweapon: chain, explode, and splinter.", dmg:38, range:35, fireRate:1.25, color:0xff5e7a, explode:true, aoe:4.2, chainBounces:5, chainRange:9.5, splinter:4, knockback:9.5 },
      "Tempest Crown": { kind:"bolt", desc:"Rapid chain lightning emperor gun.", dmg:19, range:32, fireRate:3.7, color:0x22d3ee, chainBounces:4, chainRange:8.8 },
      "Plagueburst": { kind:"bolt", desc:"Explosive toxic payloads for grouped enemies.", dmg:16, range:28, fireRate:3.1, color:0x86efac, explode:true, aoe:3.0, poison:3.8 },
      "Basilisk": { kind:"bolt", desc:"Heavy venom rounds with severe poison.", dmg:20, range:30, fireRate:2.4, color:0x65a30d, poison:5.2 },
      "Thunderclap Mortar": { kind:"bolt", desc:"Slow cannon with shockwave explosion + stun.", dmg:27, range:26, fireRate:1.45, color:0xfcd34d, explode:true, aoe:3.4, stun:0.7 },
      "Rift Trident": { kind:"bolt", desc:"Triple-lock chaos bolts with chain sparks.", dmg:15, range:31, fireRate:3.4, color:0xa78bfa, volleyTargets:3, chainBounces:2, chainRange:6.8 },
      "Oracle Splitter": { kind:"bolt", desc:"High-end splitter with long bounce chains.", dmg:24, range:34, fireRate:2.1, color:0xe879f9, splinter:4, chainBounces:4, chainRange:8.6 },
      "Kingbreaker": { kind:"bolt", desc:"Boss-tier cannon, massive hit and control effects.", dmg:45, range:35, fireRate:1.05, color:0xffd166, explode:true, aoe:4.6, stun:0.9, knockback:12.0, chainBounces:3, chainRange:8.8 },
      "Irradiator": { kind:"bolt", desc:"Low fire rate mutagen round; irradiated foes hurt nearby enemies while bugs swarm them.", dmg:24, range:29, fireRate:1.2, color:0x84cc16, irradiate:{ duration:4.8, dps:5.0, radius:3.4 } },
      "Longshot Sniper": { kind:"bolt", desc:"Very long range precision rifle with slow cadence.", dmg:52, range:48, fireRate:0.85, color:0xe2e8f0 },
      "Needle Pierce": { kind:"bolt", desc:"Pierces one enemy and hits another target behind it.", dmg:19, range:33, fireRate:3.4, color:0x67e8f9, pierce:1 },
      "Drillline": { kind:"bolt", desc:"Deep-penetration drill round that can cut through many enemies.", dmg:17, range:34, fireRate:2.2, color:0x22d3ee, pierce:4 },
      "Quartz Pin": { kind:"bolt", desc:"Light crystal rounds that pierce once.", dmg:13, range:30, fireRate:5.2, color:0xa5b4fc, pierce:1 },
      "Needle Gale": { kind:"bolt", desc:"Fast needle stream with light piercing.", dmg:9, range:29, fireRate:9.4, color:0x5eead4, pierce:1 },
      "Wyrm Borer": { kind:"bolt", desc:"Burrowing payload with deep penetration and poison.", dmg:21, range:33, fireRate:2.0, color:0x4d7c0f, pierce:3, poison:2.6 },
      "Volt Lance": { kind:"bolt", desc:"Punchy bolt that pierces and then chains.", dmg:20, range:32, fireRate:2.5, color:0x38bdf8, pierce:2, chainBounces:2, chainRange:6.8 },
      "Comet Spear": { kind:"bolt", desc:"Explosive piercing comet projectile.", dmg:27, range:31, fireRate:1.7, color:0xfb7185, pierce:1, explode:true, aoe:2.7 },
      "Pulse Needle": { kind:"bolt", desc:"Precise low recoil needle with stun jab.", dmg:14, range:35, fireRate:4.4, color:0x93c5fd, pierce:1, stun:0.35 },
      "Blight Sprayer": { kind:"bolt", desc:"Irradiates on impact with weak direct damage.", dmg:11, range:27, fireRate:4.8, color:0x65a30d, irradiate:{ duration:3.6, dps:3.2, radius:2.8 } },
      "Hive Driver": { kind:"bolt", desc:"Heavy mutagen driver with chain arcs.", dmg:29, range:32, fireRate:1.5, color:0xa3e635, irradiate:{ duration:5.2, dps:5.8, radius:3.6 }, chainBounces:2, chainRange:6.4 },
      "Atlas Sniper": { kind:"bolt", desc:"Ultra-long sniper platform with huge punch.", dmg:64, range:54, fireRate:0.62, color:0xf8fafc, knockback:8.5 },
      "Glassline": { kind:"bolt", desc:"Long bolt that pierces deep targets.", dmg:23, range:41, fireRate:1.8, color:0xc4b5fd, pierce:5 },
      "Rupture Rail": { kind:"bolt", desc:"Rail slug with piercing and explosion.", dmg:35, range:40, fireRate:1.2, color:0x94a3b8, pierce:2, explode:true, aoe:3.1 },
      "Bog Repeater": { kind:"bolt", desc:"Forest repeater with poison and pierce.", dmg:12, range:28, fireRate:7.5, color:0x22c55e, pierce:1, poison:2.0 },
      "Vortex Drill": { kind:"bolt", desc:"Spinning drill slugs penetrate clustered enemies.", dmg:18, range:33, fireRate:3.0, color:0x0ea5e9, pierce:3 },
      "Rime Longbow": { kind:"bolt", desc:"Slow frost sniper bolt with stun.", dmg:37, range:46, fireRate:0.95, color:0xbfdbfe, stun:0.5 },
      "Prism Borer": { kind:"bolt", desc:"Crystalline deep-pierce weapon with splinters.", dmg:22, range:36, fireRate:2.4, color:0xe879f9, pierce:4, splinter:2 },
      "Deepcore Spike": { kind:"bolt", desc:"Extreme penetration spike for thick lines.", dmg:26, range:38, fireRate:1.9, color:0xf59e0b, pierce:6 },
      "Leech Sniper": { kind:"bolt", desc:"Long-range toxic sniper with irradiate splash.", dmg:41, range:50, fireRate:0.78, color:0x84cc16, poison:4.0, irradiate:{ duration:4.0, dps:4.3, radius:3.1 } },
      "Razor Choir": { kind:"bolt", desc:"Multi-target piercing harmonics.", dmg:16, range:31, fireRate:4.3, color:0x22d3ee, pierce:2, volleyTargets:3 },
      "Aether Harpoon": { kind:"bolt", desc:"Harpoon cannon with long range and knockback.", dmg:33, range:44, fireRate:1.15, color:0xfef08a, pierce:2, knockback:10.0 },
      "Night Drill": { kind:"bolt", desc:"Darkmatter drill cannon, very deep piercing.", dmg:28, range:39, fireRate:1.6, color:0x6366f1, pierce:7 }
    };

    const WEAPON_RECIPES = [
      { name:"Arc Bolt", req:{ iron:6, hide:4 } },
      { name:"Sun Beam", req:{ essence:9, iron:6 } },
      { name:"Shock Wave", req:{ hide:8, essence:6 } },
      { name:"Shard Rifle", req:{ crystal:10, essence:6 } },
      { name:"Ember Lance", req:{ ember:10, iron:8 } },
      { name:"Viper Needler", req:{ essence:10, hide:8, ember:4 } },
      { name:"Toxic Repeater", req:{ essence:13, iron:10, hide:8 } },
      { name:"Stun Hammer", req:{ iron:16, crystal:9, ember:8 } },
      { name:"Static Pike", req:{ crystal:11, iron:10, essence:9 } },
      { name:"Thunder Fork", req:{ crystal:13, essence:10, iron:8 } },
      { name:"Storm Scepter", req:{ crystal:16, essence:14, ember:8 } },
      { name:"Zeus Driver", req:{ crystal:28, essence:24, ember:20, iron:18 } },
      { name:"Tri-Seeker", req:{ iron:12, crystal:10, essence:8 } },
      { name:"Hydra Volley", req:{ iron:15, crystal:14, essence:12 } },
      { name:"Cerberus Array", req:{ ember:16, iron:16, crystal:12, essence:12 } },
      { name:"Splintergun II", req:{ crystal:12, essence:10, hide:8 } },
      { name:"Splintergun III", req:{ crystal:15, essence:13, hide:10 } },
      { name:"Splinterstorm", req:{ crystal:23, essence:20, ember:12, iron:10 } },
      { name:"Nova Cannon", req:{ ember:21, iron:18, crystal:15 } },
      { name:"Quake Driver", req:{ iron:20, hide:14, ember:10 } },
      { name:"Ramjet", req:{ iron:16, hide:11, crystal:8 } },
      { name:"Venom Arc", req:{ essence:16, crystal:13, hide:10, ember:6 } },
      { name:"Paralyzer", req:{ crystal:18, essence:16, iron:14 } },
      { name:"Frost Shock", req:{ crystal:16, essence:12, iron:10, hide:8 } },
      { name:"Ion Scatter", req:{ crystal:18, ember:14, essence:12 } },
      { name:"Overload Prism", req:{ crystal:22, essence:20, ember:14, iron:10 } },
      { name:"Abyss Rail", req:{ iron:30, crystal:24, essence:20, ember:18 } },
      { name:"Cataclysm Core", req:{ iron:38, crystal:34, essence:32, ember:30, hide:16 } },
      { name:"Tempest Crown", req:{ crystal:26, essence:24, ember:18, iron:12 } },
      { name:"Plagueburst", req:{ essence:24, ember:18, hide:15, crystal:12 } },
      { name:"Basilisk", req:{ essence:22, hide:20, ember:16, iron:12 } },
      { name:"Thunderclap Mortar", req:{ ember:24, crystal:18, iron:16 } },
      { name:"Rift Trident", req:{ crystal:24, essence:21, ember:14, iron:14 } },
      { name:"Oracle Splitter", req:{ crystal:28, essence:26, ember:18, iron:16 } },
      { name:"Kingbreaker", req:{ iron:42, crystal:38, essence:34, ember:34, hide:20 } },
      { name:"Irradiator", req:{ essence:28, ember:22, hide:18, crystal:16 } },
      { name:"Longshot Sniper", req:{ iron:30, crystal:24, essence:14 } },
      { name:"Needle Pierce", req:{ iron:17, crystal:12, hide:10 } },
      { name:"Drillline", req:{ iron:24, crystal:16, ember:12 } },
      { name:"Quartz Pin", req:{ crystal:12, essence:10, iron:8 } },
      { name:"Needle Gale", req:{ iron:15, hide:12, essence:8 } },
      { name:"Wyrm Borer", req:{ ember:18, iron:18, essence:14 } },
      { name:"Volt Lance", req:{ crystal:18, essence:14, iron:14 } },
      { name:"Comet Spear", req:{ ember:20, crystal:15, iron:14 } },
      { name:"Pulse Needle", req:{ crystal:14, iron:12, essence:9 } },
      { name:"Blight Sprayer", req:{ essence:16, hide:14, ember:8 } },
      { name:"Hive Driver", req:{ essence:30, ember:22, crystal:18, hide:15 } },
      { name:"Atlas Sniper", req:{ iron:40, crystal:34, essence:20 } },
      { name:"Glassline", req:{ crystal:26, essence:20, iron:14 } },
      { name:"Rupture Rail", req:{ iron:34, crystal:28, ember:22 } },
      { name:"Bog Repeater", req:{ hide:16, essence:14, iron:12 } },
      { name:"Vortex Drill", req:{ iron:24, crystal:18, ember:12 } },
      { name:"Rime Longbow", req:{ crystal:28, essence:20, iron:16 } },
      { name:"Prism Borer", req:{ crystal:30, essence:24, ember:16 } },
      { name:"Deepcore Spike", req:{ iron:32, ember:20, crystal:20 } },
      { name:"Leech Sniper", req:{ essence:32, hide:22, crystal:26, ember:18 } },
      { name:"Razor Choir", req:{ crystal:22, essence:18, iron:14 } },
      { name:"Aether Harpoon", req:{ iron:36, crystal:28, essence:22 } },
      { name:"Night Drill", req:{ iron:38, ember:24, crystal:24, essence:20 } },
    ];

    const MAT_KEYS = ["iron","hide","essence","crystal","ember"];
    const recipeCost = (req)=>MAT_KEYS.reduce((sum,k)=>sum + (req[k]||0), 0);
    for(let i=0;i<WEAPON_RECIPES.length;i++){
      const r = WEAPON_RECIPES[i];
      const tier = i+1;
      const growth = 1 + tier*0.22 + tier*tier*0.018;
      const w = WEAPONS[r.name];
      if(w){
        if(w.dmg!=null) w.dmg = Math.round(w.dmg * (1 + tier*0.030));
        if(w.dps!=null) w.dps = Math.round((w.dps * (1 + tier*0.026))*10)/10;
      }
      const scaledReq = {};
      for(const k of MAT_KEYS){
        if(r.req[k]){
          scaledReq[k] = Math.max(1, Math.round(r.req[k] * growth));
        }
      }
      r.req = scaledReq;

      const cost = recipeCost(r.req);
      const costPower = 1 + Math.pow(cost/80, 1.2);
      const effectPower = 1 + Math.pow(cost/120, 1.08);
      if(w){
        if(w.dmg!=null) w.dmg = Math.max(2, Math.round(w.dmg * costPower));
        if(w.dps!=null) w.dps = Math.round((w.dps * (0.55 + costPower*0.52))*10)/10;
        if(w.aoe!=null) w.aoe = Math.round(w.aoe * (0.9 + effectPower*0.24) * 10) / 10;
        if(w.poison!=null) w.poison = Math.round(w.poison * (0.92 + effectPower*0.28) * 10) / 10;
        if(w.stun!=null) w.stun = Math.round(w.stun * (0.92 + effectPower*0.18) * 100) / 100;
        if(w.knockback!=null) w.knockback = Math.round(w.knockback * (0.9 + effectPower*0.22) * 10) / 10;
        if(w.chainRange!=null) w.chainRange = Math.round(w.chainRange * (0.96 + effectPower*0.12) * 10) / 10;
        if(w.chainBounces!=null) w.chainBounces = Math.min(12, Math.max(1, Math.round(w.chainBounces * (0.9 + effectPower*0.13))));
        if(w.splinter!=null) w.splinter = Math.min(8, Math.max(1, Math.round(w.splinter * (0.92 + effectPower*0.12))));
        if(w.pierce!=null) w.pierce = Math.min(10, Math.max(1, Math.round(w.pierce * (0.9 + effectPower*0.12))));
        if(w.volleyTargets!=null) w.volleyTargets = Math.min(6, Math.max(2, Math.round(w.volleyTargets * (0.94 + effectPower*0.08))));
        if(w.irradiate){
          w.irradiate = {
            duration: Math.round((w.irradiate.duration||3.5) * (0.95 + effectPower*0.11) * 10)/10,
            dps: Math.round((w.irradiate.dps||3.5) * (0.9 + effectPower*0.24) * 10)/10,
            radius: Math.round((w.irradiate.radius||2.8) * (0.95 + effectPower*0.14) * 10)/10,
          };
        }
      }
    }

    WEAPON_RECIPES.sort((a,b)=>{
      const diff = recipeCost(a.req) - recipeCost(b.req);
      return diff!==0 ? diff : a.name.localeCompare(b.name);
    });

    const RECIPES = [
      ...WEAPON_RECIPES.map((w)=>({ type:"weapon", name:w.name, req:w.req, equip:true })),
      {
        type:"upgrade",
        name:"Reinforced Plate (+Max HP)",
        req:{ iron:10, hide:10 },
        apply:(p)=>{ p.maxHp += 25; p.hp = Math.min(p.maxHp, p.hp+25); }
      },
      {
        type:"upgrade",
        name:"Tempered Core (+Damage)",
        req:{ iron:12, essence:8 },
        apply:(p)=>{ p.damageMul *= 1.12; }
      },
      {
        type:"upgrade",
        name:"Long Sight (+Range)",
        req:{ crystal:10, hide:6 },
        apply:(p)=>{ p.rangeMul *= 1.10; }
      },
      {
        type:"upgrade",
        name:"Nanoweave Recovery (+Regen)",
        req:{ essence:12, crystal:8, hide:8 },
        apply:(p)=>{ p.hpRegen += 0.9; }
      },
    ];

    // ============================================================
    // Player state
    // ============================================================
    const me = {
      x: 0, z: 0,
      y: PLAYER_H,
      vx:0, vz:0, vy:0,
      yaw: 0,
      pitch: 0,
      grounded: true,

      // stats
      level: 1,
      xp: 0,
      nextXp: 24,

      maxHp: 100,
      hp: 100,

      speedMul: 1.0,
      damageMul: 1.0,
      rangeMul: 1.0,
      hpRegen: 1.4,

      // gear
      weapon: "Arc Bolt",
      ownedWeapons: new Set(["Arc Bolt"]),

      // inventory materials
      mats: { iron:0, hide:0, essence:0, crystal:0, ember:0 },

      // abilities (unlocked flags)
      abil: {
        poisonAura:false,
        lifeGrip:false,
        meteorite:false,
        firebolt:false,
        turretTotem:false,
      },

      // cooldowns/timers
      fireCd: 0,
      fireboltCd: 0,
      lifeGripT: 0,
      meteorT: 0,
      lastHitAt: -999,
      slowT: 0,
      slowMul: 1.0,
      turnSlowT: 0,
      turretCd: 0,
    };

    function resetRun(newSeed=true){
      if(newSeed) worldSeed = (Math.random()*1e9)|0;
      me.x = 0; me.z = 0;
      me.vx=me.vz=me.vy=0;
      me.yaw = 0; me.pitch = 0;

      me.level=1; me.xp=0; me.nextXp=24;

      me.maxHp=100; me.hp=100;
      me.speedMul=1.0; me.damageMul=1.0; me.rangeMul=1.0; me.hpRegen=1.4;

      me.weapon="Arc Bolt";
      me.slowT=0; me.slowMul=1.0; me.turnSlowT=0;
      me.ownedWeapons = new Set(["Arc Bolt"]);
      me.mats = { iron:0, hide:0, essence:0, crystal:0, ember:0 };

      me.abil = { poisonAura:false, lifeGrip:false, meteorite:false, firebolt:false, turretTotem:false };
      me.fireCd=0; me.fireboltCd=0; me.lifeGripT=0; me.meteorT=0; me.turretCd=0;
      me.lastHitAt = -999;

      alive = true;
      overlayDead.style.opacity = "0";

      for(const k of Object.keys(bossCycle)) bossCycle[k] = false;
      sigilsCollected = 0;
      // clear entities
      clearEntities();
      lastRegionBannerKey = "";

      // regen forges + chunks
      genForges();
      showToast("üü© New run started.");
      saveGame(true);
    }

    // ============================================================
    // Save / Load
    // ============================================================
    function saveGame(silent=false){
      const data = {
        v: 1,
        seed: worldSeed,
        t: Date.now(),
        player: {
          x: me.x, z: me.z,
          yaw: me.yaw, pitch: me.pitch,
          level: me.level, xp: me.xp, nextXp: me.nextXp,
          maxHp: me.maxHp, hp: me.hp,
          speedMul: me.speedMul, damageMul: me.damageMul, rangeMul: me.rangeMul, hpRegen: me.hpRegen,
          weapon: me.weapon,
          ownedWeapons: Array.from(me.ownedWeapons),
          mats: me.mats,
          abil: me.abil,
          cds: { fireboltCd: me.fireboltCd, lifeGripT: me.lifeGripT, meteorT: me.meteorT },
          lastHitAt: me.lastHitAt
        },
        sigilsCollected,
        bossCycle
      };
      try{
        localStorage.setItem(SAVE_KEY, JSON.stringify(data));
        if(!silent) showToast("üíæ Saved.");
      }catch{
        if(!silent) showToast("‚ö†Ô∏è Could not save (storage blocked).");
      }
    }

    function loadGame(){
      try{
        const raw = localStorage.getItem(SAVE_KEY);
        if(!raw){ showToast("No save found."); return false; }
        const data = JSON.parse(raw);
        if(!data || !data.player){ showToast("Save is invalid."); return false; }

        worldSeed = data.seed|0 || worldSeed;

        const p = data.player;
        me.x = +p.x || 0; me.z = +p.z || 0;
        me.yaw = +p.yaw || 0; me.pitch = clamp(+p.pitch||0, -1.32, 1.32);
        me.level = +p.level||1;
        me.xp = +p.xp||0;
        me.nextXp = +p.nextXp || Math.round(24 + me.level*18 + me.level*me.level*1.35);

        me.maxHp = +p.maxHp||100;
        me.hp = clamp(+p.hp||me.maxHp, 0, me.maxHp);

        me.speedMul = +p.speedMul||1;
        me.damageMul = +p.damageMul||1;
        me.rangeMul = +p.rangeMul||1;
        me.hpRegen = +p.hpRegen||1.4;

        me.weapon = String(p.weapon||"Arc Bolt");
        me.ownedWeapons = new Set(Array.isArray(p.ownedWeapons)? p.ownedWeapons : ["Arc Bolt"]);
        if(!me.ownedWeapons.has(me.weapon)) me.ownedWeapons.add(me.weapon);

        me.mats = Object.assign({ iron:0, hide:0, essence:0, crystal:0, ember:0 }, p.mats||{});
        me.abil = Object.assign({ poisonAura:false, lifeGrip:false, meteorite:false, firebolt:false }, p.abil||{});

        me.fireboltCd = +(p.cds?.fireboltCd||0);
        me.lifeGripT  = +(p.cds?.lifeGripT||0);
        me.meteorT    = +(p.cds?.meteorT||0);
        me.lastHitAt = +(p.lastHitAt ?? -999);

        sigilsCollected = +(data.sigilsCollected||0);
        for(const k of Object.keys(bossCycle)) bossCycle[k] = !!(data.bossCycle && data.bossCycle[k]);

        alive = true;
        overlayDead.style.opacity = "0";

        clearEntities();
        lastRegionBannerKey = "";
        genForges();
        showToast("‚¨Ü Loaded save.");
        return true;
      }catch{
        showToast("‚ö†Ô∏è Failed to load save.");
        return false;
      }
    }

    loadBtn.addEventListener("click", ()=>{
      if(loadGame()){
        phase = "play";
        centerMsg.style.display="none";
        uiMode="none";
        paused=false;
        saveGame(true);
      }
    });

    newBtn.addEventListener("click", ()=>{
      phase = "play";
      centerMsg.style.display="none";
      resetRun(true);
      paused=false; uiMode="none";
    });

    resumeBtn.addEventListener("click", ()=>{
      const ok = loadGame();
      phase = "play";
      centerMsg.style.display="none";
      if(!ok) resetRun(true);
      paused=false; uiMode="none";
    });

    // ============================================================
    // Enemies, projectiles, drops
    // ============================================================
    const enemies = [];     // {id,type,mesh,hp,maxHp,spd,dmg,range, yOff, flying, state, t, cd, wind, targetMarker}
    const projectiles = []; // {x,y,z,vx,vy,vz,life,rad,dmg,from,kind,color, splinter, explode, aoe, poison, stun, knockback, chainBounces, chainRange}
    const drops = [];       // {x,y,z,mesh,mat,spin,qty}
    const turrets = [];     // {mesh,life,fireCd}

    const ALIEN_BOSS_SPAWN_MIN = 240; // seconds in alien region
    const ALIEN_BOSS_SPAWN_MAX = 360;
    const REGION_BOSS_SPAWN_MIN = 85;
    const REGION_BOSS_SPAWN_MAX = 130;
    let alienRegionClock = 0;
    let alienBossSpawnAt = ALIEN_BOSS_SPAWN_MIN + Math.random()*(ALIEN_BOSS_SPAWN_MAX-ALIEN_BOSS_SPAWN_MIN);
    let alienBoss = null;
    let regionBoss = null;
    let titanBoss = null;
    let sigilsCollected = 0;
    const bossCycle = { desert:false, forest:false, snow:false, alien:false, hell:false };
    const regionBossClock = { desert:0, forest:0, snow:0, hell:0 };
    const regionBossSpawnAt = {
      desert: REGION_BOSS_SPAWN_MIN + Math.random()*(REGION_BOSS_SPAWN_MAX-REGION_BOSS_SPAWN_MIN),
      forest: REGION_BOSS_SPAWN_MIN + Math.random()*(REGION_BOSS_SPAWN_MAX-REGION_BOSS_SPAWN_MIN),
      snow: REGION_BOSS_SPAWN_MIN + Math.random()*(REGION_BOSS_SPAWN_MAX-REGION_BOSS_SPAWN_MIN),
      hell: REGION_BOSS_SPAWN_MIN + Math.random()*(REGION_BOSS_SPAWN_MAX-REGION_BOSS_SPAWN_MIN),
    };

    let nextEnemyId = 1;

    function bossGeoCache(){
      return bossGeoCache._geo || (bossGeoCache._geo = {
        sphHi: new THREE.SphereGeometry(1, 16, 12),
        sphLo: new THREE.SphereGeometry(1, 10, 8),
        box: new THREE.BoxGeometry(1,1,1),
        cone: new THREE.ConeGeometry(1,1,10),
        cyl: new THREE.CylinderGeometry(1,1,1,10),
        torusThin: new THREE.TorusGeometry(1, 0.08, 10, 30),
        torusMid: new THREE.TorusGeometry(1, 0.14, 12, 28),
        dode: new THREE.DodecahedronGeometry(1,0),
        oct: new THREE.OctahedronGeometry(1,0),
        bossFxRing: new THREE.RingGeometry(0.35,1.0,30),
        alienStarMarker: new THREE.RingGeometry(0.95, 1.3, 28),
        alienStarRock: new THREE.DodecahedronGeometry(0.48, 0),
        alienLaserCore: new THREE.CylinderGeometry(0.12, 0.12, 62, 10),
        alienLaserAura: new THREE.PlaneGeometry(1.7, 62),
        forestFogRing: new THREE.RingGeometry(0.25,0.95,22),
        snowRibbonPlane: new THREE.PlaneGeometry(18,1.2),
        titanQuakeRuneRing: new THREE.RingGeometry(0.65,1.4,36),
        titanQuakeCrackPlane: new THREE.PlaneGeometry(2.9,1.0),
        titanStarCrackPlane: new THREE.PlaneGeometry(2.5,1.0),
      });
    }

    function buildAlienBossMesh(){
      const G = bossGeoCache();
      const g = new THREE.Group();
      const matHull = new THREE.MeshStandardMaterial({ color:0x60a5fa, emissive:0x4338ca, emissiveIntensity:0.45, metalness:0.45, roughness:0.4 });
      const matFrame = new THREE.MeshStandardMaterial({ color:0x22d3ee, emissive:0x06b6d4, emissiveIntensity:0.8, metalness:0.25, roughness:0.28 });
      const matCore = new THREE.MeshStandardMaterial({ color:0xff7ce6, emissive:0xff7ce6, emissiveIntensity:1.2, roughness:0.2, transparent:true, opacity:0.92 });

      const hull = new THREE.Group();
      const hullBase = new THREE.Mesh(G.sphHi, matHull);
      hullBase.scale.set(8.1, 1.95, 5.2);
      hull.add(hullBase);
      const hullTop = new THREE.Mesh(G.sphLo, matHull.clone());
      hullTop.material.emissiveIntensity = 0.52;
      hullTop.scale.set(5.55, 1.08, 3.65);
      hullTop.position.y = 0.7;
      hull.add(hullTop);

      const panelSeams = [];
      for(let i=0;i<4;i++){
        const seam = new THREE.Mesh(G.torusThin, new THREE.MeshBasicMaterial({ color:0x7dd3fc, transparent:true, opacity:0.28, depthWrite:false, blending:THREE.AdditiveBlending }));
        seam.rotation.x = Math.PI/2;
        seam.scale.set(2.75 + i*1.0, 2.75 + i*1.0, 1);
        seam.position.y = 0.12 - i*0.05;
        panelSeams.push(seam);
        hull.add(seam);
      }

      const ring = new THREE.Mesh(G.torusMid, matFrame);
      ring.scale.set(6.45, 6.45, 6.45);
      ring.rotation.x = Math.PI/2;

      const runePips = [];
      for(let i=0;i<10;i++){
        const a = i*Math.PI*2/10;
        const pip = new THREE.Mesh(G.box, new THREE.MeshBasicMaterial({ color:0xe879f9, transparent:true, opacity:0.72, depthWrite:false, blending:THREE.AdditiveBlending }));
        pip.scale.set(0.2,0.06,0.1);
        pip.position.set(Math.cos(a)*6.5, 0, Math.sin(a)*6.5);
        pip.rotation.y = -a;
        runePips.push(pip);
        g.add(pip);
      }

      const emitters = [];
      for(let i=0;i<6;i++){
        const a = i*Math.PI*2/6;
        const em = new THREE.Mesh(G.cyl, matFrame.clone());
        em.scale.set(0.22, 0.52, 0.22);
        em.position.set(Math.cos(a)*6.4, -0.25, Math.sin(a)*6.4);
        em.rotation.z = Math.PI*0.5;
        em.rotation.y = a;
        const tip = new THREE.Mesh(G.cone, matCore.clone());
        tip.scale.set(0.2,0.45,0.2);
        tip.position.set(0.56, 0, 0);
        tip.rotation.z = -Math.PI*0.5;
        em.add(tip);
        emitters.push(em);
        g.add(em);
      }

      const core = new THREE.Mesh(G.sphLo, matCore);
      core.scale.set(1.6,1.2,1.6);
      core.position.y = -1.55;

      const shield = new THREE.Mesh(G.sphLo, new THREE.MeshStandardMaterial({ color:0xc4b5fd, emissive:0x60a5fa, emissiveIntensity:0.55, metalness:0.12, roughness:0.3, transparent:true, opacity:0.32 }));
      shield.scale.set(2.8,1.55,2.8);
      shield.position.y = -1.58;

      const thrusters = [];
      for(let i=0;i<5;i++){
        const a = i*Math.PI*2/5;
        const pod = new THREE.Mesh(G.cone, matFrame);
        pod.scale.set(0.35, 0.85, 0.35);
        pod.position.set(Math.cos(a)*4.6, -1.3, Math.sin(a)*2.95);
        pod.rotation.z = Math.PI;
        pod.rotation.y = -a;
        const glow = glowSprite(0x67e8f9, 1.1, 0.7, FX_TEX.spark);
        glow.position.set(0, -0.5, 0);
        pod.add(glow);
        thrusters.push(pod);
        g.add(pod);
      }

      const fins = [];
      for(let i=0;i<6;i++){
        const a = (i/6)*Math.PI*2;
        const fin = new THREE.Mesh(G.cone, matHull);
        fin.scale.set(0.5,1.45,0.32);
        fin.position.set(Math.cos(a)*3.7, -0.4, Math.sin(a)*2.45);
        fin.rotation.z = Math.PI;
        fin.rotation.y = -a;
        fins.push(fin);
        g.add(fin);
      }

      const eyes = addEyePair(g, { y:-0.55, z:2.6, sep:0.68, size:0.42, color:0xa5f3fc, opacity:0.95 });
      const halo = addAdditiveRing(g, 6.1, 0.18, 0x67e8f9, 0.45);
      halo.rotation.x = Math.PI/2;
      const glow = glowSprite(0xa78bfa, 3.8, 0.32);
      glow.position.y = -1.2;

      g.add(hull, ring, core, shield, glow);
      g.userData.parts = { hull, ring, core, shield, halo, thrusters, fins, eyes, glow, emitters, runePips, panelSeams };
      g.userData.animBoss = (dt, now, bossState={})=>{
        const basePulse = 0.5 + 0.5*Math.sin(now*2.1);
        const phaseBoost = bossState.phase === "laser" ? 0.45 : (bossState.phase === "starfall" ? 0.22 : 0);
        const bob = Math.sin(now*1.25)*0.18;
        const sway = Math.sin(now*0.78)*0.08;
        g.position.y = bob;
        g.rotation.z = sway;
        ring.rotation.z += dt*0.55;
        halo.rotation.y += dt*0.4;
        core.scale.setScalar(1.08 + basePulse*0.12 + phaseBoost*0.04);
        core.material.emissiveIntensity = 0.9 + basePulse*0.4 + phaseBoost*0.55;
        core.material.emissive.setHex(bossState.phase === "laser" ? 0xff8ae9 : 0x67e8f9);
        shield.material.opacity = 0.24 + basePulse*0.1 + phaseBoost*0.12;
        shield.scale.set(2.76 + basePulse*0.14, 1.52 + basePulse*0.1, 2.76 + basePulse*0.14);
        const combatBoost = g.userData.boostThrusters ? 1 : 0;
        for(let i=0;i<thrusters.length;i++){
          const p = thrusters[i];
          p.position.y = -1.25 + Math.sin(now*3.8 + i)*0.1;
          p.children[0].material.opacity = 0.35 + combatBoost*0.32 + 0.2*Math.sin(now*(combatBoost?14:6.2) + i*1.2);
        }
        for(let i=0;i<emitters.length;i++){
          const e = emitters[i];
          e.children[0].material.emissiveIntensity = 0.6 + 0.3*Math.sin(now*3 + i) + phaseBoost*0.45;
        }
      };
      return g;
    }

    function buildRegionBossMesh(regionId){
      const G = bossGeoCache();
      const palette = {
        desert:{ body:0xfbbf24, em:0x92400e, accent:0xfde68a, eye:0xfff7d6 },
        forest:{ body:0x4ade80, em:0x14532d, accent:0x86efac, eye:0xdcfce7 },
        snow:{ body:0x93c5fd, em:0x1e3a8a, accent:0xc7d2fe, eye:0xe0f2fe },
        hell:{ body:0xff5a36, em:0x7f1d1d, accent:0xfdba74, eye:0xffedd5 }
      }[regionId] || { body:0x94a3b8, em:0x334155, accent:0xe2e8f0, eye:0xffffff };

      const g = new THREE.Group();
      const bodyMat = new THREE.MeshStandardMaterial({ color:palette.body, emissive:palette.em, emissiveIntensity:0.85, roughness:0.52, metalness:0.1 });
      const accentMat = new THREE.MeshStandardMaterial({ color:palette.accent, emissive:palette.accent, emissiveIntensity:0.55, roughness:0.35, metalness:0.12, transparent:true, opacity:0.88 });
      let parts = { eyes:[] };

      if(regionId === "desert"){
        const head = new THREE.Mesh(G.cone, bodyMat);
        head.scale.set(1.65, 2.9, 1.55);
        head.rotation.x = Math.PI;
        head.position.y = 0.95;
        g.add(head);

        const jaws = [];
        for(let i=0;i<3;i++){
          const jaw = new THREE.Mesh(G.box, accentMat);
          jaw.scale.set(1.45 - i*0.22, 0.24, 0.54);
          jaw.position.set(0, 0.55 - i*0.22, 1.0 + i*0.22);
          jaws.push(jaw);
          g.add(jaw);
        }
        const dorsal = [];
        for(let i=0;i<8;i++){
          const sp = new THREE.Mesh(G.cone, bodyMat);
          sp.scale.set(0.16, 0.52 + (i%3)*0.14, 0.16);
          sp.position.set((i-3.5)*0.45, 1.4 + Math.sin(i)*0.1, -0.2 - i*0.33);
          sp.rotation.z = Math.PI;
          dorsal.push(sp);
          g.add(sp);
        }
        const halo = addAdditiveRing(g, 2.45, 0.18, 0xfbbf24, 0.38);
        halo.rotation.x = Math.PI/2;
        const eyes = addEyePair(g, { y:0.72, z:1.38, sep:0.58, size:0.24, color:palette.eye, opacity:0.95 });
        parts = { head, jaws, dorsal, halo, eyes };
      }else if(regionId === "forest"){
        const trunk = new THREE.Mesh(G.cyl, bodyMat);
        trunk.scale.set(1.2, 2.0, 1.1);
        trunk.position.y = 0.95;
        const shoulders = [];
        for(let i=0;i<2;i++){
          const sh = new THREE.Mesh(G.box, bodyMat);
          sh.scale.set(0.75,0.5,0.65);
          sh.position.set(i===0?-1.05:1.05, 1.65, 0.1);
          shoulders.push(sh);
          g.add(sh);
        }
        const cap = new THREE.Mesh(G.sphLo, accentMat);
        cap.scale.set(2.1,0.82,2.1);
        cap.position.y = 2.55;
        const capStem = new THREE.Mesh(G.cyl, accentMat);
        capStem.scale.set(0.45,0.58,0.45);
        capStem.position.y = 2.08;
        const sacs = [];
        for(let i=0;i<4;i++){
          const s = new THREE.Mesh(G.sphLo, new THREE.MeshStandardMaterial({ color:0x86efac, emissive:0x4ade80, emissiveIntensity:0.9, transparent:true, opacity:0.62 }));
          s.scale.setScalar(0.35 + (i%2)*0.08);
          s.position.set((i-1.5)*0.45, 1.35 + (i%2)*0.24, -0.95 - (i%3)*0.22);
          sacs.push(s);
          g.add(s);
        }
        const mask = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 1.45), new THREE.MeshBasicMaterial({ map:FX_TEX.rune, color:0xbbf7d0, transparent:true, opacity:0.8, side:THREE.DoubleSide, blending:THREE.AdditiveBlending, depthWrite:false }));
        mask.position.set(0,1.3,1.15);
        g.add(mask);
        g.add(trunk, cap, capStem);
        parts = { trunk, shoulders, cap, capStem, sacs, mask };
      }else if(regionId === "snow"){
        const core = new THREE.Mesh(G.sphLo, new THREE.MeshStandardMaterial({ color:0xc7d2fe, emissive:0x60a5fa, emissiveIntensity:0.8, transparent:true, opacity:0.45 }));
        core.scale.set(1.25,1.65,1.25);
        core.position.y = 1.2;
        const cloakPlanes = [];
        for(let i=0;i<4;i++){
          const p = new THREE.Mesh(new THREE.PlaneGeometry(2.8,3.6), new THREE.MeshBasicMaterial({ map:FX_TEX.softGlow, color:0xbfdbfe, transparent:true, opacity:0.26, side:THREE.DoubleSide, blending:THREE.AdditiveBlending, depthWrite:false }));
          p.position.y = 1.2;
          p.rotation.y = i*Math.PI/4;
          cloakPlanes.push(p);
          g.add(p);
        }
        const aurora = addAdditiveRing(g, 1.75, 0.15, 0x93c5fd, 0.42);
        aurora.position.y = 3.1;
        aurora.rotation.x = Math.PI/2;
        const ribbons = [];
        for(let i=0;i<3;i++){
          const rb = new THREE.Mesh(new THREE.PlaneGeometry(0.34,2.7), new THREE.MeshBasicMaterial({ map:FX_TEX.softGlow, color:0x93c5fd, transparent:true, opacity:0.35, side:THREE.DoubleSide, blending:THREE.AdditiveBlending, depthWrite:false }));
          rb.position.set((i-1)*0.55, 0.35, -0.35 - i*0.35);
          ribbons.push(rb);
          g.add(rb);
        }
        parts = { core, cloakPlanes, aurora, ribbons };
        g.add(core);
      }else if(regionId === "hell"){
        const torso = new THREE.Mesh(G.box, bodyMat);
        torso.scale.set(1.8,2.2,1.2);
        torso.position.y = 1.4;
        const helm = new THREE.Mesh(G.sphLo, new THREE.MeshStandardMaterial({ color:0x7f1d1d, emissive:0x450a0a, emissiveIntensity:0.6, roughness:0.5 }));
        helm.scale.set(1.15,0.95,1.02);
        helm.position.set(0,3.0,0.1);
        const horns = [];
        for(let i=0;i<2;i++){
          const h = new THREE.Mesh(G.cone, accentMat);
          h.scale.set(0.22,0.9,0.22);
          h.position.set(i===0?-0.7:0.7, 3.45, -0.05);
          h.rotation.z = i===0 ? 0.45 : -0.45;
          horns.push(h);
          g.add(h);
        }
        const furnace = new THREE.Mesh(G.box, new THREE.MeshStandardMaterial({ color:0xfdba74, emissive:0xff3b1a, emissiveIntensity:1.35, roughness:0.2 }));
        furnace.scale.set(0.8,0.65,0.45);
        furnace.position.set(0,1.4,1.0);
        const handle = new THREE.Mesh(G.cyl, bodyMat);
        handle.scale.set(0.16,1.35,0.16);
        handle.position.set(1.55,1.5,0.1);
        handle.rotation.z = 0.65;
        const maulHead = new THREE.Mesh(G.box, new THREE.MeshStandardMaterial({ color:0xff7849, emissive:0xff3b1a, emissiveIntensity:1.0, roughness:0.25 }));
        maulHead.scale.set(0.62,0.44,0.92);
        maulHead.position.set(2.25,2.16,0.22);
        g.add(torso, helm, furnace, handle, maulHead);
        const eyes = addEyePair(g, { y:3.0, z:0.95, sep:0.34, size:0.17, color:0xffedd5, opacity:0.92 });
        parts = { torso, helm, horns, furnace, handle, maulHead, eyes };
      }else{
        const fallback = new THREE.Mesh(G.sphHi, bodyMat);
        fallback.scale.set(2.1,1.6,2.1);
        g.add(fallback);
        parts = { fallback };
      }

      g.userData.parts = parts;
      g.userData.animBoss = (dt, now, bossState={})=>{
        const pulse = 0.5 + 0.5*Math.sin(now*2.4);
        const phaseBoost = Math.min(0.5, (bossState.attackIntensity || 0)*0.22 + (bossState.isAttacking ? 0.2 : 0));
        g.position.y = Math.sin(now*1.15)*0.16;
        g.rotation.z = Math.sin(now*0.8)*0.05;
        if(regionId === "desert"){
          parts.halo.rotation.y += dt*0.6;
          parts.head.material.emissiveIntensity = 0.75 + pulse*0.3 + phaseBoost*0.5;
          parts.halo.material.opacity = 0.24 + pulse*0.16 + phaseBoost*0.18;
          for(let i=0;i<parts.jaws.length;i++) parts.jaws[i].position.z = 1.0 + i*0.22 + Math.sin(now*2.2 + i)*0.06;
        }else if(regionId === "forest"){
          parts.cap.rotation.y += dt*0.25;
          parts.trunk.material.emissiveIntensity = 0.72 + pulse*0.32 + phaseBoost*0.4;
          for(let i=0;i<parts.sacs.length;i++) parts.sacs[i].material.opacity = 0.45 + 0.2*Math.sin(now*2.7 + i);
          parts.mask.material.opacity = 0.65 + Math.sin(now*2.2)*0.16;
        }else if(regionId === "snow"){
          parts.aurora.rotation.y += dt*0.75;
          parts.core.material.emissiveIntensity = 0.8 + pulse*0.35 + phaseBoost*0.45;
          parts.aurora.material.opacity = 0.24 + 0.2*Math.sin(now*2.6) + phaseBoost*0.2;
          for(let i=0;i<parts.ribbons.length;i++) parts.ribbons[i].rotation.z = Math.sin(now*2.4 + i)*0.25;
        }else if(regionId === "hell"){
          parts.torso.material.emissiveIntensity = 0.68 + pulse*0.3 + phaseBoost*0.45;
          parts.furnace.material.emissiveIntensity = 1.0 + 0.45*Math.sin(now*3.8) + phaseBoost*0.55;
          parts.furnace.material.color.setHex(phaseBoost > 0.25 ? 0xffedd5 : 0xfdba74);
          parts.maulHead.material.emissiveIntensity = 0.8 + 0.35*Math.sin(now*4.6) + phaseBoost*0.35;
        }
      };
      return g;
    }

    function buildTitanBossMesh(){
      const G = bossGeoCache();
      const g = new THREE.Group();
      const matBody = new THREE.MeshStandardMaterial({ color:0xb4befe, emissive:0x7c3aed, emissiveIntensity:0.95, roughness:0.34, metalness:0.34 });
      const matAccent = new THREE.MeshStandardMaterial({ color:0x93c5fd, emissive:0x60a5fa, emissiveIntensity:0.75, roughness:0.25, metalness:0.25 });

      const core = new THREE.Mesh(G.dode, matBody);
      core.scale.set(2.65,2.95,2.65);

      const ring = new THREE.Mesh(G.torusMid, new THREE.MeshBasicMaterial({ color:0x93c5fd, transparent:true, opacity:0.56, depthWrite:false, blending:THREE.AdditiveBlending }));
      ring.scale.set(3.42,3.42,3.42);
      ring.rotation.x = Math.PI/2;

      const ringB = new THREE.Mesh(G.torusThin, new THREE.MeshBasicMaterial({ color:0xc4b5fd, transparent:true, opacity:0.48, depthWrite:false, blending:THREE.AdditiveBlending }));
      ringB.scale.set(2.82,2.82,2.82);
      ringB.rotation.x = Math.PI*0.25;
      ringB.rotation.z = Math.PI*0.2;

      const shoulderPylons = [];
      for(let i=0;i<4;i++){
        const a = i*Math.PI*0.5;
        const pylon = new THREE.Mesh(G.box, matAccent);
        pylon.scale.set(0.65,1.4,0.65);
        pylon.position.set(Math.cos(a)*2.95, 0.8, Math.sin(a)*2.95);
        const cap = new THREE.Mesh(G.cone, matAccent);
        cap.scale.set(0.4,0.75,0.4);
        cap.position.y = 1.05;
        pylon.add(cap);
        shoulderPylons.push(pylon);
        g.add(pylon);
      }

      const shards = [];
      for(let i=0;i<10;i++){
        const a = i*Math.PI*2/10;
        const sh = new THREE.Mesh(G.oct, new THREE.MeshStandardMaterial({ color:0xc4b5fd, emissive:0xa78bfa, emissiveIntensity:0.9, roughness:0.25 }));
        sh.scale.set(0.36,0.56,0.36);
        sh.position.set(Math.cos(a)*4.2, Math.sin(i*0.9)*1.35, Math.sin(a)*4.2);
        shards.push({mesh:sh,a,off:Math.random()*Math.PI*2});
        g.add(sh);
      }

      const satellites = [];
      for(let i=0;i<3;i++){
        const sat = new THREE.Group();
        const orb = new THREE.Mesh(G.oct, new THREE.MeshStandardMaterial({ color:0xe9d5ff, emissive:0xe9d5ff, emissiveIntensity:0.95, roughness:0.2 }));
        orb.scale.set(0.42,0.58,0.42);
        sat.add(orb);
        const sigil = new THREE.Mesh(new THREE.PlaneGeometry(0.85,0.85), new THREE.MeshBasicMaterial({ map:FX_TEX.rune, color:0xc4b5fd, transparent:true, opacity:0.65, blending:THREE.AdditiveBlending, side:THREE.DoubleSide, depthWrite:false }));
        sat.add(sigil);
        satellites.push({root:sat, orb, sigil, a:(i/3)*Math.PI*2, h:0.8+i*0.7});
        g.add(sat);
      }

      const orbitCore = new THREE.Mesh(G.oct, new THREE.MeshStandardMaterial({ color:0xe9d5ff, emissive:0xe9d5ff, emissiveIntensity:1.05, roughness:0.2 }));
      orbitCore.scale.set(0.85,0.95,0.85);
      orbitCore.position.set(0,0,0);
      const eye = addEyePair(g, { y:0.2, z:2.45, sep:0.6, size:0.34, color:0xe9d5ff, opacity:0.9 });
      const aura = glowSprite(0xa78bfa, 4.2, 0.2);

      g.add(core, ring, ringB, orbitCore, aura);
      g.userData.parts = { core, ring, ringB, shoulderPylons, shards, orbitCore, eye, aura, satellites };
      g.userData.animBoss = (dt, now, bossState={})=>{
        const pulse = 0.5 + 0.5*Math.sin(now*2.5);
        const specialBoost = Math.max(0, bossState.specialPulse || 0);
        g.position.y = Math.sin(now*1.1)*0.2;
        g.rotation.z = Math.sin(now*0.7)*0.06;
        ring.rotation.z += dt*0.45;
        ringB.rotation.y -= dt*0.36;
        const hpNorm = Math.max(0, Math.min(1, g.userData.hpNorm ?? 1));
        ring.material.opacity = 0.36 + (1-hpNorm)*0.3 + pulse*0.14 + specialBoost*0.12;
        core.material.emissiveIntensity = 0.78 + pulse*0.35 + specialBoost*0.45;
        core.material.emissive.setHex(bossState.phase === "quake" ? 0xe9d5ff : 0x7c3aed);
        orbitCore.position.y = Math.sin(now*1.8)*0.4;
        orbitCore.rotation.x += dt*0.9;
        orbitCore.rotation.z += dt*1.3;
        for(let i=0;i<shoulderPylons.length;i++) shoulderPylons[i].rotation.z = Math.sin(now*1.2 + i)*0.06;
        for(let i=0;i<shards.length;i++){
          const s = shards[i];
          const a = s.a + now*0.55 + s.off;
          s.mesh.position.set(Math.cos(a)*4.2, Math.sin(now*1.8 + s.off)*1.45, Math.sin(a)*4.2);
          s.mesh.rotation.x += dt*1.4;
        }
        const specialPulse = g.userData.specialPulse ?? 0;
        for(let i=0;i<satellites.length;i++){
          const s = satellites[i];
          const a = s.a + now*0.45;
          s.root.position.set(Math.cos(a)*5.6, s.h + Math.sin(now*1.2+i)*0.25, Math.sin(a)*5.6);
          s.sigil.material.opacity = 0.48 + specialPulse*0.35 + Math.sin(now*3+i)*0.12;
          s.orb.material.emissiveIntensity = 0.85 + specialPulse*0.75 + Math.sin(now*2.4+i)*0.2;
        }
      };
      return g;
    }

    function clearEntities(){
      for(const e of enemies) world.remove(e.mesh);
      for(const p of projectiles) world.remove(p.mesh);
      for(const d of drops) world.remove(d.mesh);
      for(const t of turrets) world.remove(t.mesh);
      if(alienBoss?.mesh) world.remove(alienBoss.mesh);
      if(alienBoss?.lasers){ for(const l of alienBoss.lasers){ releaseAlienBossLaser(l); } }
      if(alienBoss?.starTelegraphs){ for(const t of alienBoss.starTelegraphs){ releaseAlienStarTelegraph(t); } }
      clearBossFx(regionBoss);
      clearBossFx(titanBoss);
      if(regionBoss?.mesh) world.remove(regionBoss.mesh);
      if(titanBoss?.mesh) world.remove(titanBoss.mesh);
      for(const f of floatingTexts) f.el.remove();
      floatingTexts.length = 0;
      enemies.length=0; projectiles.length=0; drops.length=0; turrets.length=0;
      alienBoss = null;
      regionBoss = null;
      titanBoss = null;
      alienRegionClock = 0;
      alienBossSpawnAt = ALIEN_BOSS_SPAWN_MIN + Math.random()*(ALIEN_BOSS_SPAWN_MAX-ALIEN_BOSS_SPAWN_MIN);
      for(const k of Object.keys(regionBossClock)){
        regionBossClock[k] = 0;
        regionBossSpawnAt[k] = REGION_BOSS_SPAWN_MIN + Math.random()*(REGION_BOSS_SPAWN_MAX-REGION_BOSS_SPAWN_MIN);
      }
    }

    function spawnAlienBoss(){
      if(alienBoss) return;
      const ang = Math.random()*Math.PI*2;
      const d = 34 + Math.random()*18;
      const x = me.x + Math.cos(ang)*d;
      const z = me.z + Math.sin(ang)*d;
      const gy = heightAt(x,z,"alien");

      const g = buildAlienBossMesh();
      g.position.set(x, gy+17.5, z);
      world.add(g);

      const lvlScale = Math.max(1, me.level);
      const hpScale = 1 + lvlScale*0.32;
      const dmgScale = 1 + lvlScale*0.12;

      alienBoss = {
        id: -1,
        type: "alienBoss",
        mesh: g,
        hp: Math.round(1800 * hpScale),
        maxHp: Math.round(1800 * hpScale),
        state: "starfall",
        stateT: 0,
        starCd: 0,
        spin: 0,
        starTelegraphs: [],
        lasers: [],
        laserDps: 7.5 * dmgScale,
        touchDmg: 16 * dmgScale,
        projectileDmgScale: dmgScale,
        lift: 17.5,
      };
      showToast(`üõ∏ A Neon Mothership descends... (Lv ${me.level})`);
    }

    function dropBossRewards(boss){
      if(!boss?.mesh) return;
      const reg = regionAt(boss.mesh.position.x, boss.mesh.position.z);
      const baseCount = 20 + Math.floor(me.level*1.8);
      for(let i=0;i<baseCount;i++){
        const matName = reg.drops[i % reg.drops.length];
        const c = MAT_COL[matName] || 0xffffff;
        const m = new THREE.Mesh(GEO.drop, MAT.drop.clone());
        m.material.color.setHex(c);
        m.material.emissive.setHex(c);
        m.material.emissiveIntensity = 0.95;
        m.scale.setScalar(1.25);

        const a = (i/baseCount) * Math.PI*2;
        const r = 0.8 + (i%5)*0.32;
        const x = boss.mesh.position.x + Math.cos(a)*r;
        const z = boss.mesh.position.z + Math.sin(a)*r;
        const y = heightAt(x, z, reg.id) + 0.45;
        m.position.set(x, y, z);
        world.add(m);

        const qty = 1 + Math.floor(me.level/7);
        drops.push({ x, y, z, mesh:m, mat:matName, spin: Math.random()*10, pull:0, qty });
      }
    }

    function damageAlienBoss(dmg){
      if(!alienBoss) return;
      alienBoss.hp -= dmg;
      if(alienBoss.hp <= 0){
        const boss = alienBoss;
        for(const t of alienBoss.starTelegraphs){ releaseAlienStarTelegraph(t); }
        for(const l of alienBoss.lasers){ releaseAlienBossLaser(l); }
        world.remove(alienBoss.mesh);
        alienBoss = null;
        dropBossRewards(boss);
        awardBossSigil("alien", boss.mesh.position.x, boss.mesh.position.z);
        const xpGain = Math.round((220 + me.level*34) * dangerBandAt(me.x, me.z).xpMul);
        gainXp(xpGain);
        spawnFloatingText(`+${xpGain} XP`, boss.mesh.position.x, boss.mesh.position.y+2.2, boss.mesh.position.z, "#86efac");
        alienRegionClock = 0;
        alienBossSpawnAt = ALIEN_BOSS_SPAWN_MIN + Math.random()*(ALIEN_BOSS_SPAWN_MAX-ALIEN_BOSS_SPAWN_MIN);
        showToast("‚ú® Alien mothership destroyed. Massive loot dropped!");
      }
    }

    function spawnSigilDrop(x, z, regionId){
      const y = heightAt(x, z, regionId) + 0.55;
      const m = new THREE.Mesh(
        new THREE.OctahedronGeometry(0.34, 0),
        new THREE.MeshStandardMaterial({ color:0xfef08a, emissive:0xfef08a, emissiveIntensity:1.35, roughness:0.2, metalness:0.05 })
      );
      m.position.set(x, y, z);
      world.add(m);
      drops.push({ x, y, z, mesh:m, mat:"sigil", spin:Math.random()*10, pull:0, qty:1, regionId });
    }

    function awardBossSigil(regionId, x, z){
      if(bossCycle[regionId]) return;
      bossCycle[regionId] = true;
      sigilsCollected = Object.values(bossCycle).filter(Boolean).length;
      spawnSigilDrop(x, z, regionId);
      showToast(`üî± ${regionId.toUpperCase()} sigil shard dropped! (${sigilsCollected}/5)`);
      if(sigilsCollected >= 5) showToast("üóø All sigils gathered. The Infinity Titan stirs...");
    }

    function regionBossStyle(regionId){
      if(regionId==="desert") return { name:"Dune Leviathan", color:0xfbbf24, emissive:0x92400e, hp:920, speed:4.9 };
      if(regionId==="forest") return { name:"Sporefather", color:0x4ade80, emissive:0x14532d, hp:980, speed:4.4 };
      if(regionId==="snow") return { name:"Aurora Wraith", color:0x93c5fd, emissive:0x1e3a8a, hp:940, speed:5.2 };
      return { name:"Infernal Forge-King", color:0xff5a36, emissive:0x7f1d1d, hp:1060, speed:5.0 };
    }

    function spawnRegionBoss(regionId){
      if(regionBoss || bossCycle[regionId]) return;
      const st = regionBossStyle(regionId);
      const ang = Math.random()*Math.PI*2;
      const d = 22 + Math.random()*10;
      const x = me.x + Math.cos(ang)*d;
      const z = me.z + Math.sin(ang)*d;
      const y = heightAt(x,z,regionId) + 1.45;
      const g = buildRegionBossMesh(regionId);
      g.position.set(x,y,z);
      world.add(g);
      const hpMul = dangerBandAt(x,z).hpMul;
      regionBoss = { type:"regionBoss", regionId, name:st.name, mesh:g, hp:Math.round(st.hp*hpMul), maxHp:Math.round(st.hp*hpMul), speed:st.speed, t:0, cdA:0, cdB:0, cdC:0, trails:[], telegraphs:[], ribbons:[], sigils:[], anvils:[], burst:[] };
      showToast(`üëë ${st.name} emerges in ${regionId}!`);
    }

    function spawnTitanBoss(){
      if(titanBoss || sigilsCollected<5) return;
      const x = 0, z = 0, y = heightAt(0,0,regionAt(0,0).id) + 4.6;
      const g = buildTitanBossMesh();
      g.position.set(x,y,z); world.add(g);
      titanBoss = { type:"titan", mesh:g, hp:Math.round(3600 + me.level*80), maxHp:Math.round(3600 + me.level*80), coreCd:0.5, quakeCd:6.5, starCd:9.5, quakeTele:0, starPlan:null, lastSpecial:0 };
      showToast("üóø Infinity Titan has spawned at the world center!");
    }

    function clearBossFx(b){
      if(!b) return;
      for(const t of (b.trails||[])){ if(t.mesh) world.remove(t.mesh); }
      for(const t of (b.telegraphs||[])){ if(t.mesh) world.remove(t.mesh); }
      for(const t of (b.ribbons||[])){ if(t.mesh) world.remove(t.mesh); }
      for(const t of (b.sigils||[])){ if(t.mesh) world.remove(t.mesh); }
      for(const t of (b.anvils||[])){ if(t.mesh) world.remove(t.mesh); }
      for(const t of (b.burst||[])){ if(t.mesh) world.remove(t.mesh); }
      for(const l of (b.lasers||[])){ releaseAlienBossLaser(l); }
      for(const t of (b.starTelegraphs||[])){ releaseAlienStarTelegraph(t); }
      for(let i=projectiles.length-1;i>=0;i--){
        const p = projectiles[i];
        if(p.kind!=="bossFx" && p.kind!=="shockwave" && p.kind!=="alienStarTelegraph") continue;
        if(p.mesh && p.mesh.parent) p.mesh.parent.remove(p.mesh);
        if(p.fxType) releaseBossFx(p.fxType, p.mesh);
        projectiles.splice(i,1);
      }
    }

    function killRegionBoss(){
      if(!regionBoss) return;
      const b = regionBoss;
      clearBossFx(b);
      world.remove(b.mesh);
      dropBossRewards(b);
      awardBossSigil(b.regionId, b.mesh.position.x, b.mesh.position.z);
      const xpGain = Math.round((180 + me.level*24) * dangerBandAt(me.x, me.z).xpMul);
      gainXp(xpGain);
      regionBoss = null;
      showToast(`‚ú® ${b.name} defeated.`);
    }

    function killTitanBoss(){
      if(!titanBoss) return;
      const b = titanBoss;
      clearBossFx(b);
      world.remove(b.mesh);
      titanBoss = null;
      me.mats.iron += 80; me.mats.hide += 70; me.mats.essence += 75; me.mats.crystal += 70; me.mats.ember += 90;
      const xpGain = Math.round((800 + me.level*80) * dangerBandAt(me.x, me.z).xpMul);
      gainXp(xpGain);
      for(const k of Object.keys(bossCycle)) bossCycle[k] = false;
      sigilsCollected = 0;
      showToast("üåå Infinity Titan shattered! Massive resources gained. Sigils reset.");
    }

    function damageRegionBoss(dmg){
      if(!regionBoss) return;
      regionBoss.hp -= dmg;
      if(regionBoss.hp <= 0) killRegionBoss();
    }

    function damageTitanBoss(dmg){
      if(!titanBoss) return;
      titanBoss.hp -= dmg;
      if(titanBoss.hp <= 0) killTitanBoss();
    }

    function makeHealthBar(){
      const g = new THREE.Group();
      const bg = new THREE.Mesh(new THREE.PlaneGeometry(1.1, 0.14), new THREE.MeshBasicMaterial({ color:0x000000, transparent:true, opacity:0.55 }));
      const fg = new THREE.Mesh(new THREE.PlaneGeometry(1.05, 0.10), new THREE.MeshBasicMaterial({ color:0x22c55e, transparent:true, opacity:0.92 }));
      bg.position.z = 0.001;
      fg.position.z = 0.002;
      fg.position.x = -0.025;
      g.add(bg, fg);
      g.userData.bg = bg;
      g.userData.fg = fg;
      return g;
    }

    function makeEnemyMesh(type, regId){
  const g = new THREE.Group();

  // --- cached enemy geometries (created once) ---
  const EG = makeEnemyMesh._geo || (makeEnemyMesh._geo = {
    sph12: new THREE.SphereGeometry(1, 14, 12),
    sph10: new THREE.SphereGeometry(1, 12, 10),
    sph8:  new THREE.SphereGeometry(1, 10, 8),
    box:   new THREE.BoxGeometry(1,1,1),
    cyl:   new THREE.CylinderGeometry(1,1,1,10),
    cone:  new THREE.ConeGeometry(1,1,10),
    torus: new THREE.TorusGeometry(1,0.12,10,28),
    cap:   new THREE.CapsuleGeometry(0.5, 1.0, 8, 12),
    plane: new THREE.PlaneGeometry(1,1),
    dode:  new THREE.DodecahedronGeometry(1,0),
    oct:   new THREE.OctahedronGeometry(1,0),
  });

  // --- region palette baseline ---
  let baseCol = 0x94a3b8, emisCol = 0x0b1020, accentCol = 0x22c55e;
  if(regId==="desert"){ baseCol = 0x8b6b3a; emisCol=0x2a1a0b; accentCol=0xfbbf24; }
  if(regId==="forest"){ baseCol = 0x2dd47a; emisCol=0x0b2a18; accentCol=0x22c55e; }
  if(regId==="snow"){   baseCol = 0xaad7ff; emisCol=0x0b1b3f; accentCol=0x93c5fd; }
  if(regId==="alien"){  baseCol = 0xff3ad7; emisCol=0x7c3aed; accentCol=0x22d3ee; }
  if(regId==="hell"){   baseCol = 0xff2a2a; emisCol=0x4a0010; accentCol=0xff3b1a; }

  // tweak per enemy identity so everything isn‚Äôt ‚Äújust region colored‚Äù
  const TYPE_TINT = {
    scarab: 0x7c5a2b, scorpion:0x5b3a1a, sandwisp:0xfbbf24,
    boar:0x8b5a3a, spriggan:0x22c55e, spitter:0x84cc16,
    wolf:0x64748b, icegolem:0xdbeafe, frostling:0xbfdbfe,
    drone:0x22d3ee, floater:0xa78bfa, shardling:0xff3ad7,
    imp:0xff2a2a, brute:0xdc2626, mortar:0xf97316, goblin:0x65a30d, mirebat:0x4ade80, skitter:0x67e8f9
  };
  const typeTint = TYPE_TINT[type] ?? baseCol;
  g.userData.typeTint = typeTint;

  const matBody = new THREE.MeshStandardMaterial({
    color: typeTint,
    roughness: 0.72,
    metalness: (regId==="alien") ? 0.18 : 0.06,
    emissive: emisCol,
    emissiveIntensity: 0.35
  });

  const matDark = new THREE.MeshStandardMaterial({
    color: 0x111827,
    roughness: 0.9,
    metalness: 0.05,
    emissive: emisCol,
    emissiveIntensity: 0.12
  });

  const matBone = new THREE.MeshStandardMaterial({
    color: 0xf8fafc,
    roughness: 0.55,
    metalness: 0.02,
    emissive: 0x000000,
    emissiveIntensity: 0.0
  });

  const matGlow = new THREE.MeshBasicMaterial({
    color: accentCol,
    transparent:true,
    opacity:0.55,
    depthWrite:false,
    blending:THREE.AdditiveBlending
  });

  const matGlass = new THREE.MeshStandardMaterial({
    color: accentCol,
    roughness: 0.12,
    metalness: 0.05,
    emissive: accentCol,
    emissiveIntensity: 0.9,
    transparent:true,
    opacity: 0.65
  });

  const parts = { legs:[], wings:[], rings:[], tentacles:[], sacs:[], tail:[], club:null, recoil:null, thrusters:[] };
  g.userData.parts = parts;

  // Helper: quick limb
  function limbCylinder(r1,r2,h,mat){
    const m = new THREE.Mesh(new THREE.CylinderGeometry(r1,r2,h,8), mat);
    return m;
  }

  // ---------------------------
  // DESERT: SCARAB
  // ---------------------------
  if(type==="scarab" || type==="beetle"){
    // segmented shell
    const s1 = new THREE.Mesh(EG.sph12, matBody); s1.scale.set(0.72,0.52,0.86); s1.position.set(0,0.55,0.05);
    const s2 = new THREE.Mesh(EG.sph12, matBody); s2.scale.set(0.65,0.50,0.72); s2.position.set(0,0.56,-0.38);
    const s3 = new THREE.Mesh(EG.sph10, matBody); s3.scale.set(0.55,0.44,0.55); s3.position.set(0,0.55,0.48);

    const ridge = new THREE.Mesh(EG.torus, matGlow);
    ridge.scale.set(0.38,0.22,0.34);
    ridge.rotation.x = Math.PI/2;
    ridge.position.set(0,0.65,0.08);

    const head = new THREE.Mesh(EG.sph10, matDark); head.scale.set(0.35,0.30,0.40); head.position.set(0,0.52,0.78);
    const horn = new THREE.Mesh(EG.cone, matBody); horn.scale.set(0.12,0.42,0.12); horn.position.set(0,0.70,1.02); horn.rotation.x = Math.PI/2;

    // mandibles
    const mandL = new THREE.Mesh(EG.cone, matDark);
    mandL.scale.set(0.08,0.26,0.08);
    mandL.position.set(-0.18,0.46,0.92);
    mandL.rotation.set(Math.PI/2, 0, 0.35);
    const mandR = mandL.clone();
    mandR.position.x = 0.18; mandR.rotation.z = -0.35;

    // legs (6)
    for(let side of [-1,1]){
      for(let i=0;i<3;i++){
        const leg = limbCylinder(0.04,0.05,0.55, matDark);
        leg.position.set(side*(0.45 + i*0.03), 0.28, 0.35 - i*0.28);
        leg.rotation.z = side*0.9;
        leg.rotation.x = 0.35 - i*0.12;
        parts.legs.push(leg);
        g.add(leg);
      }
    }

    // eyes
    const eyes = addEyePair(g, { y:0.58, z:0.92, sep:0.18, size:0.16, color:accentCol, opacity:0.95 });

    g.add(s1,s2,s3, ridge, head, horn, mandL, mandR);

    g.userData.anim = (e,dt,now)=>{
      const t = now*0.004;
      for(let i=0;i<parts.legs.length;i++){
        const leg = parts.legs[i];
        const phase = (i%3)*0.9 + (i<3?0:0.25);
        leg.rotation.x = (0.35 - (i%3)*0.12) + Math.sin(t*10 + phase)*0.18*(e.state==="chase"?1:0.35);
      }
      ridge.rotation.z += dt*2.2;
      const pulse = 0.55 + 0.45*Math.sin(now*0.01 + e.id);
      ridge.material.opacity = 0.30 + 0.35*pulse;
      eyes[0].material.opacity = eyes[1].material.opacity = 0.55 + 0.45*pulse;
    };
  }

  // ---------------------------
  // DESERT: SCORPION
  // ---------------------------
  else if(type==="scorpion"){
    const body = new THREE.Mesh(EG.cap, matBody);
    body.scale.set(0.42,0.55,0.42);
    body.position.y = 0.62;

    const head = new THREE.Mesh(EG.sph10, matDark);
    head.scale.set(0.30,0.26,0.34);
    head.position.set(0,0.58,0.62);

    // claws
    for(let side of [-1,1]){
      const arm = limbCylinder(0.06,0.07,0.55, matBody);
      arm.position.set(side*0.52,0.55,0.48);
      arm.rotation.z = side*0.85;
      const claw = new THREE.Mesh(EG.sph10, matDark);
      claw.scale.set(0.18,0.14,0.22);
      claw.position.set(side*0.78,0.48,0.70);
      const pinch = new THREE.Mesh(EG.cone, matDark);
      pinch.scale.set(0.06,0.22,0.06);
      pinch.position.set(side*0.86,0.48,0.84);
      pinch.rotation.x = Math.PI/2;
      g.add(arm, claw, pinch);
    }

    // legs
    for(let side of [-1,1]){
      for(let i=0;i<3;i++){
        const leg = limbCylinder(0.035,0.05,0.62, matDark);
        leg.position.set(side*(0.42 + i*0.05), 0.24, 0.25 - i*0.28);
        leg.rotation.z = side*1.05;
        leg.rotation.x = 0.55 - i*0.14;
        parts.legs.push(leg);
        g.add(leg);
      }
    }

    // segmented tail
    const tailRoot = new THREE.Group();
    tailRoot.position.set(0,0.72,-0.45);
    const segs = [];
    for(let i=0;i<4;i++){
      const seg = new THREE.Mesh(EG.sph10, matBody);
      seg.scale.set(0.22 - i*0.03, 0.18 - i*0.02, 0.26 - i*0.04);
      seg.position.set(0, i*0.18, -i*0.12);
      seg.rotation.x = -0.2;
      segs.push(seg);
      tailRoot.add(seg);
    }
    const stinger = new THREE.Mesh(EG.cone, matGlow);
    stinger.scale.set(0.12,0.35,0.12);
    stinger.position.set(0, 0.78, -0.42);
    stinger.rotation.x = -Math.PI/2;
    tailRoot.add(stinger);

    addEyePair(g, { y:0.60, z:0.78, sep:0.16, size:0.14, color:accentCol, opacity:0.95 });

    g.add(body, head, tailRoot);
    parts.tail = segs;
    parts.rings.push(stinger);

    g.userData.anim = (e,dt,now)=>{
      const t = now*0.004;
      const atk = (e.state==="windup"||e.state==="attack") ? 1 : 0;
      tailRoot.rotation.x = -0.55 + Math.sin(t*6 + e.id)*0.15 + atk*0.35;
      tailRoot.rotation.y = Math.sin(t*4 + e.id*0.7)*0.12;
      stinger.material.opacity = 0.35 + 0.35*(0.5+0.5*Math.sin(now*0.02 + e.id));
      for(let i=0;i<parts.legs.length;i++){
        parts.legs[i].rotation.x = (0.55 - (i%3)*0.14) + Math.sin(t*10 + i)*0.14*(e.state==="chase"?1:0.35);
      }
    };
  }

  // ---------------------------
  // AIR: SANDWISP / FLOATER (shared ‚Äúfloaty VFX‚Äù style)
  // ---------------------------
  else if(type==="sandwisp" || type==="floater"){
    const core = new THREE.Mesh(EG.sph12, matGlass);
    core.scale.set(0.34,0.34,0.34);
    core.position.y = 1.05;

    const nucleus = new THREE.Mesh(EG.sph10, matGlow);
    nucleus.scale.set(0.20,0.20,0.20);
    nucleus.position.y = 1.05;

    const ring1 = addAdditiveRing(g, 0.62, 0.06, accentCol, 0.55);
    ring1.position.y = 1.02;
    ring1.rotation.x = Math.PI/2;

    const ring2 = addAdditiveRing(g, 0.48, 0.05, 0xffffff, 0.35);
    ring2.position.y = 1.10;
    ring2.rotation.set(Math.PI/2, 0.6, 0);

    // orbit dust/sparks
    const orbs = [];
    for(let i=0;i<4;i++){
      const s = glowSprite(type==="sandwisp" ? 0xfbbf24 : accentCol, 0.22, 0.55, FX_TEX.spark);
      s.position.set(Math.cos(i)*0.55, 1.02 + (i%2)*0.12, Math.sin(i)*0.55);
      g.add(s);
      orbs.push(s);
    }
    parts.rings.push(ring1, ring2);
    g.add(core, nucleus);

    g.userData.anim = (e,dt,now)=>{
      const t = now*0.0035;
      ring1.rotation.z += dt*2.4;
      ring2.rotation.z -= dt*1.9;
      const pulse = 0.55 + 0.45*Math.sin(now*0.014 + e.id);
      core.material.opacity = 0.48 + 0.22*pulse;
      nucleus.material.opacity = 0.28 + 0.30*pulse;
      ring1.material.opacity = 0.35 + 0.35*pulse;
      ring2.material.opacity = 0.18 + 0.22*pulse;

      for(let i=0;i<orbs.length;i++){
        const a = t*3.4 + i*(Math.PI*2/orbs.length);
        orbs[i].position.x = Math.cos(a)*0.62;
        orbs[i].position.z = Math.sin(a)*0.62;
        orbs[i].position.y = 1.02 + 0.18*Math.sin(a*1.6 + i);
        orbs[i].material.opacity = 0.25 + 0.35*pulse;
      }
    };
  }

  // ---------------------------
  // FOREST: BOAR
  // ---------------------------
  else if(type==="boar"){
    const body = new THREE.Mesh(EG.cap, matBody);
    body.scale.set(0.62,0.40,0.48);
    body.position.y = 0.72;

    const head = new THREE.Mesh(EG.sph10, matDark);
    head.scale.set(0.30,0.26,0.34);
    head.position.set(0,0.76,0.78);

    const snout = limbCylinder(0.12,0.16,0.32, matDark);
    snout.position.set(0,0.68,1.05);
    snout.rotation.x = Math.PI/2;

    const tuskL = new THREE.Mesh(EG.cone, matBone);
    tuskL.scale.set(0.06,0.24,0.06);
    tuskL.position.set(-0.18,0.62,0.98);
    tuskL.rotation.x = Math.PI/2;
    const tuskR = tuskL.clone(); tuskR.position.x = 0.18;

    // bristles
    const bristles = [];
    for(let i=0;i<6;i++){
      const b = new THREE.Mesh(EG.cone, matDark);
      b.scale.set(0.05,0.18,0.05);
      b.position.set((i-2.5)*0.10, 0.98, 0.10 - i*0.08);
      b.rotation.x = -0.25;
      bristles.push(b);
      g.add(b);
    }

    // legs
    for(let x of [-0.28, 0.28]){
      for(let z of [-0.18, 0.26]){
        const leg = limbCylinder(0.06,0.08,0.52, matDark);
        leg.position.set(x,0.30,z);
        parts.legs.push(leg);
        g.add(leg);
      }
    }

    addEyePair(g, { y:0.82, z:0.90, sep:0.18, size:0.12, color:0xffffff, opacity:0.85 });

    g.add(body, head, snout, tuskL, tuskR);

    g.userData.anim = (e,dt,now)=>{
      const t = now*0.0045;
      const run = (e.state==="chase") ? 1 : 0.25;
      head.rotation.x = 0.10 + Math.sin(t*6 + e.id)*0.08*run;
      for(let i=0;i<parts.legs.length;i++){
        parts.legs[i].rotation.x = Math.sin(t*10 + i*1.2)*0.55*run;
      }
      for(let i=0;i<bristles.length;i++){
        bristles[i].rotation.z = Math.sin(t*7 + i)*0.18;
      }
    };
  }

  // ---------------------------
  // FOREST: SPRIGGAN (tree-humanoid)
  // ---------------------------
  else if(type==="spriggan"){
    const trunk = limbCylinder(0.30,0.40,1.20, MAT.wood);
    trunk.position.y = 0.90;

    const torsoPlate = new THREE.Mesh(EG.box, MAT.wood);
    torsoPlate.scale.set(0.55,0.65,0.30);
    torsoPlate.position.set(0,1.05,0.05);

    const head = new THREE.Mesh(EG.sph10, MAT.wood);
    head.scale.set(0.28,0.26,0.28);
    head.position.set(0,1.65,0.15);

    // leafy crown + antlers
    const crown = new THREE.Mesh(EG.cone, MAT.leaf);
    crown.scale.set(0.70,0.90,0.70);
    crown.position.set(0,2.05,0.05);

    const antL = limbCylinder(0.06,0.06,0.65, MAT.wood);
    antL.position.set(-0.22,2.05,0.05);
    antL.rotation.z = 0.55;
    const antR = antL.clone(); antR.position.x = 0.22; antR.rotation.z = -0.55;

    // arms (branchy)
    for(let side of [-1,1]){
      const upper = limbCylinder(0.08,0.10,0.85, MAT.wood);
      upper.position.set(side*0.58,1.18,0.05);
      upper.rotation.z = side*0.75;
      const fore = limbCylinder(0.06,0.08,0.75, MAT.wood);
      fore.position.set(side*0.92,0.88,0.15);
      fore.rotation.z = side*1.1;
      g.add(upper, fore);
    }

    // rune mask
    const mask = new THREE.Mesh(EG.plane, new THREE.MeshBasicMaterial({
      map: FX_TEX.spark,
      color: accentCol,
      transparent:true,
      opacity:0.55,
      depthWrite:false,
      blending:THREE.AdditiveBlending
    }));
    mask.scale.set(0.45,0.35,1);
    mask.position.set(0,1.60,0.42);
    g.add(mask);

    // leaf motes
    const motes = [];
    for(let i=0;i<3;i++){
      const m = glowSprite(0x22c55e, 0.28, 0.45, FX_TEX.softGlow);
      m.position.set((Math.random()-0.5)*0.8, 1.6 + Math.random()*0.6, (Math.random()-0.5)*0.8);
      g.add(m);
      motes.push(m);
    }

    g.add(trunk, torsoPlate, head, crown, antL, antR);

    g.userData.anim = (e,dt,now)=>{
      const t = now*0.0038;
      trunk.rotation.y = Math.sin(t*1.2 + e.id)*0.10;
      crown.rotation.y += dt*0.6;
      mask.material.opacity = 0.35 + 0.30*(0.5+0.5*Math.sin(now*0.016 + e.id));
      for(let i=0;i<motes.length;i++){
        const a = t*2.8 + i*2.1;
        motes[i].position.x = Math.cos(a)*0.55;
        motes[i].position.z = Math.sin(a)*0.55;
        motes[i].position.y = 1.55 + 0.35*Math.sin(a*1.6 + i);
      }
    };
  }

  // ---------------------------
  // FOREST: SPITTER (toxic creature)
  // ---------------------------
  else if(type==="spitter"){
    const body = new THREE.Mesh(EG.sph12, matBody);
    body.scale.set(0.60,0.50,0.70);
    body.position.y = 0.78;

    const belly = new THREE.Mesh(EG.sph10, matDark);
    belly.scale.set(0.45,0.35,0.55);
    belly.position.set(0,0.62,0.20);

    const snout = limbCylinder(0.12,0.20,0.52, matDark);
    snout.position.set(0,0.78,0.88);
    snout.rotation.x = Math.PI/2;

    // toxic sacs
    for(let i=0;i<3;i++){
      const sac = new THREE.Mesh(EG.sph10, matGlass);
      sac.scale.set(0.22,0.20,0.22);
      sac.position.set((i-1)*0.26, 1.05, -0.05 - i*0.10);
      g.add(sac);
      parts.sacs.push(sac);
    }

    // drip glow under mouth
    const drip = glowSprite(0x84cc16, 0.28, 0.42, FX_TEX.softGlow);
    drip.position.set(0,0.45,1.02);
    g.add(drip);

    addEyePair(g, { y:0.90, z:0.76, sep:0.22, size:0.12, color:0x84cc16, opacity:0.8 });

    g.add(body, belly, snout);

    g.userData.anim = (e,dt,now)=>{
      const t = now*0.005;
      const pulse = 0.55 + 0.45*Math.sin(now*0.02 + e.id);
      for(let i=0;i<parts.sacs.length;i++){
        const sac = parts.sacs[i];
        sac.scale.set(0.22*(0.9+0.25*pulse), 0.20*(0.9+0.25*pulse), 0.22*(0.9+0.25*pulse));
        sac.material.opacity = 0.52 + 0.18*pulse;
      }
      drip.material.opacity = 0.22 + 0.35*pulse;
      drip.position.y = 0.44 + 0.06*Math.sin(t*3.2);
    };
  }

  // ---------------------------
  // SNOW: WOLF
  // ---------------------------
  else if(type==="wolf"){
    const body = new THREE.Mesh(EG.cap, matBody);
    body.scale.set(0.58,0.32,0.42);
    body.position.y = 0.64;

    const head = new THREE.Mesh(EG.sph10, matDark);
    head.scale.set(0.26,0.22,0.28);
    head.position.set(0,0.72,0.72);

    const snout = new THREE.Mesh(EG.box, matDark);
    snout.scale.set(0.18,0.12,0.28);
    snout.position.set(0,0.62,0.92);

    const tail = limbCylinder(0.05,0.07,0.55, matDark);
    tail.position.set(0,0.70,-0.72);
    tail.rotation.x = -0.8;

    const earL = new THREE.Mesh(EG.cone, matDark);
    earL.scale.set(0.08,0.22,0.08);
    earL.position.set(-0.16,0.95,0.66);
    const earR = earL.clone(); earR.position.x = 0.16;

    // legs
    const legPos = [
      [-0.22, 0.32, 0.20],
      [ 0.22, 0.32, 0.20],
      [-0.22, 0.32,-0.18],
      [ 0.22, 0.32,-0.18],
    ];
    for(const [lx,ly,lz] of legPos){
      const leg = limbCylinder(0.05,0.07,0.50, matDark);
      leg.position.set(lx,ly,lz);
      parts.legs.push(leg);
      g.add(leg);
    }

    addEyePair(g, { y:0.78, z:0.80, sep:0.16, size:0.11, color:0xffffff, opacity:0.85 });

    g.add(body, head, snout, tail, earL, earR);

    g.userData.anim = (e,dt,now)=>{
      const t = now*0.006;
      const run = (e.state==="chase") ? 1 : 0.25;
      head.rotation.x = 0.08 + Math.sin(t*4 + e.id)*0.06*run;
      tail.rotation.y = Math.sin(t*5 + e.id)*0.35;
      for(let i=0;i<parts.legs.length;i++){
        parts.legs[i].rotation.x = Math.sin(t*10 + i*(Math.PI/2))*0.75*run;
      }
    };
  }

  // ---------------------------
  // SNOW: ICE GOLEM
  // ---------------------------
  else if(type==="icegolem"){
    const torso = new THREE.Mesh(new THREE.BoxGeometry(0.95,1.25,0.70), MAT.ice);
    torso.position.y = 1.05;

    const head = new THREE.Mesh(new THREE.BoxGeometry(0.58,0.58,0.58), MAT.ice);
    head.position.y = 1.82;

    // arms
    const armL = new THREE.Mesh(new THREE.BoxGeometry(0.28,0.90,0.28), MAT.ice);
    const armR = armL.clone();
    armL.position.set(-0.75,1.20,0); armL.rotation.z=0.18;
    armR.position.set( 0.75,1.20,0); armR.rotation.z=-0.18;

    // spikes
    for(let side of [-1,1]){
      const spike = new THREE.Mesh(EG.cone, matGlow);
      spike.scale.set(0.10,0.55,0.10);
      spike.position.set(side*0.35, 1.65, -0.25);
      spike.rotation.x = Math.PI;
      g.add(spike);
    }

    // face glow + eyes
    const face = glowSprite(0x93c5fd, 0.35, 0.55, FX_TEX.spark);
    face.position.set(0,1.80,0.38);
    g.add(face);
    addEyePair(g, { y:1.82, z:0.36, sep:0.18, size:0.14, color:0x93c5fd, opacity:0.9 });

    g.add(torso, head, armL, armR);

    g.userData.anim = (e,dt,now)=>{
      const pulse = 0.55 + 0.45*Math.sin(now*0.012 + e.id);
      face.material.opacity = 0.35 + 0.35*pulse;
    };
  }

  // ---------------------------
  // SNOW: FROSTLING
  // ---------------------------
  else if(type==="frostling"){
    const body = new THREE.Mesh(EG.cap, matBody);
    body.scale.set(0.30,0.46,0.30);
    body.position.y = 0.92;

    const hood = new THREE.Mesh(EG.cone, matDark);
    hood.scale.set(0.45,0.65,0.45);
    hood.position.set(0,1.18,0.10);

    const spike = new THREE.Mesh(EG.cone, MAT.ice);
    spike.scale.set(0.18,0.55,0.18);
    spike.position.set(0,1.55,0);
    spike.rotation.x = Math.PI;

    const aura = glowSprite(0xbfdbfe, 1.1, 0.18, FX_TEX.softGlow);
    aura.position.set(0,0.80,0);
    g.add(aura);

    addEyePair(g, { y:1.10, z:0.52, sep:0.14, size:0.12, color:0xbfdbfe, opacity:0.9 });

    g.add(body, hood, spike);

    g.userData.anim = (e,dt,now)=>{
      const t = now*0.006;
      const atk = (e.state==="windup"||e.state==="attack") ? 1 : 0;
      hood.rotation.y = Math.sin(t*1.5 + e.id)*0.25;
      spike.rotation.z = Math.sin(t*2.2 + e.id)*0.10 + atk*0.30;
      aura.material.opacity = 0.10 + 0.10*(0.5+0.5*Math.sin(now*0.012+e.id));
    };
  }

  // ---------------------------
  // ALIEN: DRONE
  // ---------------------------
  else if(type==="drone"){
    const core = new THREE.Mesh(EG.oct, MAT.crystal);
    core.scale.set(0.45,0.45,0.45);
    core.position.y = 1.20;

    const ring = addAdditiveRing(g, 0.70, 0.06, 0x22d3ee, 0.45);
    ring.position.y = 1.18;
    ring.rotation.x = Math.PI/2;

    // fins
    for(let side of [-1,1]){
      const fin = new THREE.Mesh(new THREE.BoxGeometry(0.65,0.08,0.18), MAT.shroom);
      fin.position.set(side*0.55,1.20,0);
      fin.rotation.z = side*0.25;
      g.add(fin);
      parts.wings.push(fin);
    }

    // thrusters
    for(let side of [-1,1]){
      const thr = glowSprite(0x22d3ee, 0.35, 0.45, FX_TEX.softGlow);
      thr.position.set(side*0.25,1.10,-0.45);
      g.add(thr);
      parts.thrusters.push(thr);
    }

    g.add(core);
    parts.rings.push(ring);

    g.userData.anim = (e,dt,now)=>{
      ring.rotation.z += dt*3.4;
      core.rotation.y += dt*2.2;
      const pulse = 0.55 + 0.45*Math.sin(now*0.02 + e.id);
      ring.material.opacity = 0.22 + 0.35*pulse;
      for(let i=0;i<parts.wings.length;i++){
        parts.wings[i].rotation.z = (i? -1:1) * (0.20 + 0.18*Math.sin(now*0.02 + e.id));
      }
      for(const thr of parts.thrusters){
        thr.material.opacity = 0.18 + 0.40*pulse;
        thr.scale.set(0.30 + 0.18*pulse, 0.30 + 0.18*pulse, 1);
      }
    };
  }

  // ---------------------------
  // ALIEN: SHARDLING
  // ---------------------------
  else if(type==="shardling"){
    const body = new THREE.Mesh(EG.dode, MAT.crystal);
    body.scale.set(0.52,0.52,0.52);
    body.position.y = 0.90;

    // shard crown
    for(let i=0;i<6;i++){
      const shard = new THREE.Mesh(EG.cone, MAT.shroom);
      shard.scale.set(0.14,0.65,0.14);
      const a = i*(Math.PI*2/6);
      shard.position.set(Math.cos(a)*0.36, 1.25, Math.sin(a)*0.36);
      shard.rotation.x = Math.PI;
      shard.rotation.y = a;
      g.add(shard);
      parts.rings.push(shard);
    }

    const coreGlow = glowSprite(0xff3ad7, 0.55, 0.35, FX_TEX.softGlow);
    coreGlow.position.set(0,0.95,0);
    g.add(coreGlow);

    g.add(body);

    g.userData.anim = (e,dt,now)=>{
      body.rotation.y += dt*1.6;
      const pulse = 0.55 + 0.45*Math.sin(now*0.015 + e.id);
      coreGlow.material.opacity = 0.18 + 0.30*pulse;
      for(let i=0;i<parts.rings.length;i++){
        parts.rings[i].rotation.z += dt*(1.2 + i*0.05);
      }
    };
  }

  // ---------------------------
  // HELL: IMP
  // ---------------------------
  else if(type==="imp"){
    const body = new THREE.Mesh(EG.sph12, matBody);
    body.scale.set(0.40,0.42,0.40);
    body.position.y = 0.72;

    const head = new THREE.Mesh(EG.sph10, matDark);
    head.scale.set(0.28,0.26,0.28);
    head.position.set(0,0.98,0.18);

    const hornL = new THREE.Mesh(EG.cone, matDark);
    hornL.scale.set(0.08,0.28,0.08);
    hornL.position.set(-0.16,1.20,0.10);
    hornL.rotation.z = 0.35;
    const hornR = hornL.clone(); hornR.position.x = 0.16; hornR.rotation.z = -0.35;

    // wings
    for(let side of [-1,1]){
      const wing = new THREE.Mesh(EG.plane, new THREE.MeshBasicMaterial({
        map: FX_TEX.spark,
        color: 0xff3b1a,
        transparent:true,
        opacity:0.45,
        depthWrite:false,
        blending:THREE.AdditiveBlending,
        side:THREE.DoubleSide
      }));
      wing.scale.set(0.85,0.55,1);
      wing.position.set(side*0.55,0.90,-0.05);
      wing.rotation.y = side*(Math.PI/2 - 0.55);
      g.add(wing);
      parts.wings.push(wing);
    }

    const flame = glowSprite(0xff3b1a, 0.70, 0.35, FX_TEX.softGlow);
    flame.position.set(0,0.55,-0.25);
    g.add(flame);

    addEyePair(g, { y:0.98, z:0.40, sep:0.14, size:0.12, color:0xffd166, opacity:0.9 });

    g.add(body, head, hornL, hornR);

    g.userData.anim = (e,dt,now)=>{
      const t = now*0.008;
      const flap = 0.55 + 0.45*Math.sin(t + e.id);
      for(let i=0;i<parts.wings.length;i++){
        const w = parts.wings[i];
        w.rotation.z = (i? -1:1) * (0.25 + 0.55*flap);
        w.material.opacity = 0.25 + 0.25*flap;
      }
      flame.material.opacity = 0.18 + 0.30*flap;
      flame.scale.set(0.55 + 0.35*flap, 0.55 + 0.35*flap, 1);
    };
  }

  // ---------------------------
  // HELL: BRUTE
  // ---------------------------
  else if(type==="brute"){
    const body = new THREE.Mesh(EG.cap, matBody);
    body.scale.set(0.70,0.85,0.70);
    body.position.y = 1.15;

    const shoulders = new THREE.Mesh(EG.sph12, matDark);
    shoulders.scale.set(0.70,0.42,0.65);
    shoulders.position.y = 1.55;

    const helm = new THREE.Mesh(EG.box, matDark);
    helm.scale.set(0.45,0.35,0.45);
    helm.position.set(0,1.92,0.05);

    const rune = glowSprite(0xff3b1a, 0.55, 0.25, FX_TEX.spark);
    rune.position.set(0,1.28,0.45);
    g.add(rune);

    // club
    const club = new THREE.Group();
    const handle = limbCylinder(0.08,0.09,1.25, MAT.spire);
    handle.position.set(0,0.65,0);
    const head = new THREE.Mesh(EG.sph12, matGlow);
    head.scale.set(0.30,0.30,0.30);
    head.position.set(0,1.25,0);
    club.add(handle, head);
    club.position.set(0.92,1.05,0);
    club.rotation.z = -0.85;
    g.add(club);
    parts.club = club;

    addEyePair(g, { y:1.92, z:0.32, sep:0.18, size:0.14, color:0xffd166, opacity:0.9 });

    g.add(body, shoulders, helm);

    g.userData.anim = (e,dt,now)=>{
      const t = now*0.004;
      const atk = (e.state==="windup"||e.state==="attack") ? 1 : 0;
      rune.material.opacity = 0.12 + 0.22*(0.5+0.5*Math.sin(now*0.015+e.id));
      if(parts.club){
        const base = -0.85;
        parts.club.rotation.z = base + Math.sin(t*2.2+e.id)*0.10 + atk*0.65;
      }
    };
  }

  // ---------------------------
  // HELL: MORTAR (siege creature)
  // ---------------------------
  else if(type==="mortar"){
    const base = new THREE.Mesh(new THREE.CylinderGeometry(0.52,0.62,0.65,14), matBody);
    base.position.y = 0.85;

    const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.14,0.18,1.10,12), matDark);
    barrel.position.set(0,1.30,0.32);
    barrel.rotation.x = 0.60;

    const ring = addAdditiveRing(g, 0.70, 0.07, 0xff3b1a, 0.35);
    ring.position.y = 0.85;
    ring.rotation.x = Math.PI/2;

    // wheels
    for(let side of [-1,1]){
      const wheel = new THREE.Mesh(EG.torus, matDark);
      wheel.scale.set(0.20,0.20,0.20);
      wheel.position.set(side*0.62,0.62,0.05);
      wheel.rotation.x = Math.PI/2;
      g.add(wheel);
    }

    const fuse = glowSprite(0xff3b1a, 0.38, 0.35, FX_TEX.spark);
    fuse.position.set(0,1.05,0.58);
    g.add(fuse);

    g.add(base, barrel, ring);
    parts.recoil = barrel;
    parts.rings.push(ring);

    g.userData.anim = (e,dt,now)=>{
      const pulse = 0.55 + 0.45*Math.sin(now*0.02 + e.id);
      ring.material.opacity = 0.18 + 0.22*pulse;
      fuse.material.opacity = 0.18 + 0.35*pulse;

      // recoil feel during windup/attack
      if(parts.recoil){
        const atk = (e.state==="windup"||e.state==="attack") ? 1 : 0;
        parts.recoil.position.z = 0.32 - atk*0.10;
      }
    };
  }

  // fallback (shouldn‚Äôt happen much)
  else {
    const body = new THREE.Mesh(EG.sph12, matBody);
    body.scale.set(0.45,0.45,0.45);
    body.position.y = 0.8;
    g.add(body);
    addEyePair(g, { y:0.9, z:0.5, sep:0.18, size:0.14, color:accentCol, opacity:0.8 });
  }

  // Health bar (auto position above actual model)
  const bar = makeHealthBar();
  g.add(bar);
  g.userData.hpBar = bar;

  // place bar above model bounds (after building)
  g.updateMatrixWorld(true);
  const box = new THREE.Box3().setFromObject(g);
  bar.position.y = box.max.y + 0.35;
  bar.position.z = 0;

  return g;
}

    function enemyStats(type, level, x=0, z=0){
      // base stats per archetype (inner ring baseline)
      let baseHp=26, baseDmg=8, spd=2.1, range=1.3, flying=false, yOff=0.0, kind="melee", modelLift=0.78;
      if(type==="scarab"){ baseHp=22; baseDmg=7; spd=2.9; range=1.15; kind="melee"; }
      if(type==="scorpion"){ baseHp=30; baseDmg=9; spd=2.3; range=1.35; kind="melee"; }
      if(type==="sandwisp"){ baseHp=18; baseDmg=6; spd=2.3; range=12; kind="ranged"; flying=true; yOff=1.2; modelLift=1.65; }
      if(type==="boar"){ baseHp=32; baseDmg=10; spd=2.7; range=1.45; kind="melee"; }
      if(type==="spriggan"){ baseHp=48; baseDmg=11; spd=1.85; range=1.5; kind="melee"; }
      if(type==="spitter"){ baseHp=26; baseDmg=8; spd=2.35; range=12.5; kind="ranged"; flying=true; yOff=1.4; modelLift=1.9; }
      if(type==="wolf"){ baseHp=26; baseDmg=9; spd=3.2; range=1.25; kind="melee"; }
      if(type==="icegolem"){ baseHp=75; baseDmg=14; spd=1.5; range=1.7; kind="melee"; }
      if(type==="frostling"){ baseHp=22; baseDmg=7; spd=3.2; range=7.5; kind="ranged"; }
      if(type==="drone"){ baseHp=28; baseDmg=10; spd=2.5; range=13; kind="ranged"; flying=true; yOff=1.35; modelLift=1.85; }
      if(type==="floater"){ baseHp=38; baseDmg=9; spd=2.0; range=14; kind="ranged"; flying=true; yOff=1.6; modelLift=2.1; }
      if(type==="shardling"){ baseHp=34; baseDmg=11; spd=2.2; range=1.35; kind="melee"; }
      if(type==="imp"){ baseHp=28; baseDmg=10; spd=2.8; range=1.3; kind="melee"; }
      if(type==="brute"){ baseHp=95; baseDmg=16; spd=1.7; range=1.9; kind="melee"; }
      if(type==="mortar"){ baseHp=45; baseDmg=14; spd=1.6; range=18; kind="mortar"; }
      if(type==="goblin"){ baseHp=30; baseDmg=12; spd=2.5; range=16.5; kind="lobber"; }
      if(type==="mirebat"){ baseHp=24; baseDmg=8; spd=3.1; range=11.5; kind="ranged"; flying=true; yOff=1.1; modelLift=1.55; }
      if(type==="skitter"){ baseHp=20; baseDmg=7; spd=3.8; range=1.15; kind="melee"; modelLift=0.62; }

      const band = dangerBandAt(x,z);
      const hp = Math.round(baseHp * band.hpMul * (1 + 0.14*(level-1)));
      const dmg = Math.round(baseDmg * band.dmgMul * (1 + 0.09*(level-1)));
      return { hp, dmg, spd: spd*(1+0.02*(level-1)), range, flying, yOff, kind, modelLift, band:band.id, bandMul:band };
    }

    function spawnEnemy(type, x, z, regId){
      const st = enemyStats(type, me.level, x, z);
      const mesh = makeEnemyMesh(type, regId);
      const yBase = heightAt(x,z, regId);
      const y = yBase + st.modelLift + (st.flying ? (1.0+st.yOff) : 0.0);
      mesh.position.set(x, y, z);

      const e = {
        id: nextEnemyId++,
        type,
        regId,
        mesh,
        x, z,
        yBase: yBase,
        yOff: st.flying ? (1.0+st.yOff) : 0.0,
        modelLift: st.modelLift,
        flying: st.flying,
        hp: st.hp,
        maxHp: st.hp,
        spd: st.spd,
        dmg: st.dmg,
        range: st.range,
        kind: st.kind,
        dangerBand: st.band,
        inOuter: st.band==="outer",

        state: "chase", // chase -> windup -> attack -> recover
        cd: 0,
        wind: 0,
        tele: null, // telegraph visual mesh (circle/marker)
        bob: Math.random()*10,
        stunT: 0,
        poisonT: 0,
        poisonDps: 0,
        kbX: 0,
        kbZ: 0,
        burstLeft: 0,
        data: {},
      };

      world.add(mesh);
      enemies.push(e);
      return e;
    }

    function spawnPack(){
      const reg = regionAt(me.x, me.z);
      const cap = ENEMY_CAP_BASE + Math.floor(me.level*1.35);
      if(enemies.length >= cap) return false;

      // require travel between spawns
      if(travelMeter < 28) return false;
      if(spawnCooldown > 0) return false;

      const rnd = xorshift32(((worldSeed^0xBADC0DE) + (me.level*99173)|0) ^ ((Date.now()/1000)|0));
      const packSize = clamp(2 + (rnd()*3|0) + Math.floor(me.level*0.16), 2, 10);

      // spawn 48..86 units away
      const dist = 48 + rnd()*38;
      const ang = rnd()*Math.PI*2;
      const cx = me.x + Math.cos(ang)*dist;
      const cz = me.z + Math.sin(ang)*dist;

      // keep inside world
      const rr = Math.hypot(cx,cz);
      if(rr > WORLD_RADIUS-40) return false;

      const types = reg.enemies;
      for(let i=0;i<packSize;i++){
        const t = types[(rnd()*types.length)|0];
        const a = rnd()*Math.PI*2;
        const r = 3 + rnd()*8; // spacing
        const x = cx + Math.cos(a)*r;
        const z = cz + Math.sin(a)*r;
        spawnEnemy(t, x, z, reg.id);
      }

      travelMeter = 0;
      spawnCooldown = 8.4 + rnd()*3.6;
      return true;
    }

    // ============================================================
    // Player firing / aim cone
    // ============================================================
    function cameraForward(out){
      out.set(0,0,-1).applyEuler(camera.rotation).normalize();
      return out;
    }

    function pickTarget(maxRange){
      const fwd = cameraForward(_v1);
      const ox = me.x, oy = me.y, oz = me.z;
      const range2 = maxRange*maxRange;

      let best = null;
      let bestScore = 1e18;

      const aimCone = 0.15; // radians-ish cone feel
      for(const e of enemies){
        if(e.hp<=0) continue;
        const ex = e.mesh.position.x;
        const ez = e.mesh.position.z;
        const ey = e.mesh.position.y + (e.flying?0.15:0.65);

        const dx = ex-ox, dy = ey-oy, dz = ez-oz;
        const d2 = dx*dx + dy*dy + dz*dz;
        if(d2 > range2) continue;

        const len = Math.sqrt(d2);
        const vx = dx/len, vy=dy/len, vz=dz/len;
        const dot = fwd.x*vx + fwd.y*vy + fwd.z*vz;
        const ang = Math.acos(clamp(dot, -1, 1));
        if(ang > aimCone) continue;

        // prefer smaller angle, then distance
        const score = ang*2.2 + len*0.02;
        if(score < bestScore){
          bestScore = score;
          best = e;
        }
      }
      if(alienBoss && alienBoss.hp>0){
        const bx = alienBoss.mesh.position.x;
        const by = alienBoss.mesh.position.y;
        const bz = alienBoss.mesh.position.z;
        const dx = bx-ox, dy = by-oy, dz = bz-oz;
        const d2 = dx*dx + dy*dy + dz*dz;
        if(d2 <= range2){
          const len = Math.sqrt(d2);
          const vx = dx/len, vy=dy/len, vz=dz/len;
          const dot = fwd.x*vx + fwd.y*vy + fwd.z*vz;
          const ang = Math.acos(clamp(dot, -1, 1));
          if(ang <= aimCone){
            const score = ang*1.8 + len*0.015;
            if(score < bestScore){
              bestScore = score;
              best = alienBoss;
            }
          }
        }
      }
      return best;
    }

    function spawnBolt(fromX, fromY, fromZ, toX, toY, toZ, cfg, isSplinter=false){
      const dir = _v2.set(toX-fromX, toY-fromY, toZ-fromZ);
      const len = dir.length();
      if(len<=0.0001) return;
      dir.multiplyScalar(1/len);

      const speed = isSplinter ? 22 : 26;
      const vx = dir.x*speed, vy = dir.y*speed, vz = dir.z*speed;

      const mesh = new THREE.Mesh(GEO.bolt, new THREE.MeshStandardMaterial({
        color: cfg.color,
        emissive: cfg.color,
        emissiveIntensity: 1.2,
        roughness: 0.25,
        metalness: 0.05
      }));
      mesh.position.set(fromX, fromY, fromZ);
      world.add(mesh);

      projectiles.push({
        mesh,
        x:fromX, y:fromY, z:fromZ,
        vx, vy, vz,
        life: 1.6,
        rad: 0.45,
        dmg: cfg.dmg * me.damageMul * (isSplinter?0.65:1.0),
        from:"player",
        kind:"bolt",
        color: cfg.color,
        splinter: !!cfg.splinter && !isSplinter,
        explode: !!cfg.explode,
        aoe: cfg.aoe ?? (cfg.explode ? 2.4 : 0.0),
        splinterCount: cfg.splinterCount ?? ((typeof cfg.splinter==="number") ? cfg.splinter : (cfg.splinter ? 3 : 0)),
        poison: cfg.poison || 0,
        stun: cfg.stun || 0,
        knockback: cfg.knockback || 0,
        chainBounces: cfg.chainBounces || 0,
        chainRange: cfg.chainRange || 7.0,
        pierceLeft: cfg.pierce || 0,
        hitIds: new Set(),
        irradiate: cfg.irradiate || null
      });
    }

    // beam visual (core + glow + crackle segments)
    const beamGroup = new THREE.Group();
    beamGroup.visible = false;
    world.add(beamGroup);

    function makeBeamLine(opacity){
      const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
      const mat = new THREE.LineBasicMaterial({ color:0xfff3a0, transparent:true, opacity });
      return new THREE.Line(geo, mat);
    }

    const beamLineCore = makeBeamLine(0.88);
    const beamLineGlow = makeBeamLine(0.48);
    beamGroup.add(beamLineGlow);
    beamGroup.add(beamLineCore);

    const BEAM_CRACKLE_COUNT = 7;
    const beamCrackleGeo = new THREE.BufferGeometry();
    beamCrackleGeo.setAttribute("position", new THREE.Float32BufferAttribute(new Float32Array(BEAM_CRACKLE_COUNT * 2 * 3), 3));
    const beamCrackleMat = new THREE.LineBasicMaterial({ color:0xfff7c2, transparent:true, opacity:0.56 });
    const beamCrackle = new THREE.LineSegments(beamCrackleGeo, beamCrackleMat);
    beamGroup.add(beamCrackle);

    const _beamFrom = new THREE.Vector3();
    const _beamTo = new THREE.Vector3();
    const _beamDir = new THREE.Vector3();
    const _beamSide = new THREE.Vector3();
    const _beamUp = new THREE.Vector3();

    function updateBeamVisual(fromX, fromY, fromZ, toX, toY, toZ, color){
      _beamFrom.set(fromX, fromY, fromZ);
      _beamTo.set(toX, toY, toZ);
      _beamDir.subVectors(_beamTo, _beamFrom);
      const beamLen = _beamDir.length();
      if(beamLen < 0.001){
        beamGroup.visible = false;
        return;
      }
      _beamDir.multiplyScalar(1/beamLen);

      const pulse = performance.now()*0.026;
      const energyFlicker = 0.64 + 0.28*Math.sin(pulse);

      beamGroup.visible = true;
      beamLineCore.material.color.setHex(color);
      beamLineGlow.material.color.setHex(color);
      beamCrackle.material.color.setHex(color);
      beamLineCore.material.opacity = 0.78 + 0.18*Math.sin(pulse*1.12);
      beamLineGlow.material.opacity = 0.32 + 0.16*Math.sin(pulse*0.93 + 0.7);
      beamCrackle.material.opacity = 0.26 + 0.24*Math.sin(pulse*1.7 + 0.4);

      const coreArr = beamLineCore.geometry.attributes.position;
      const glowArr = beamLineGlow.geometry.attributes.position;
      coreArr.setXYZ(0, fromX, fromY, fromZ);
      coreArr.setXYZ(1, toX, toY, toZ);
      glowArr.setXYZ(0, fromX, fromY, fromZ);
      glowArr.setXYZ(1, toX, toY, toZ);
      coreArr.needsUpdate = true;
      glowArr.needsUpdate = true;

      _beamUp.set(0,1,0);
      _beamSide.crossVectors(_beamDir, _beamUp);
      if(_beamSide.lengthSq() < 0.0001){
        _beamUp.set(1,0,0);
        _beamSide.crossVectors(_beamDir, _beamUp);
      }
      _beamSide.normalize();
      _beamUp.crossVectors(_beamSide, _beamDir).normalize();

      const crackleArr = beamCrackle.geometry.attributes.position;
      for(let i=0; i<BEAM_CRACKLE_COUNT; i++){
        const t = (i + 1) / (BEAM_CRACKLE_COUNT + 1);
        const segLen = 0.06 + Math.random()*0.14;
        const phase = pulse + i*1.73;
        const lateral = (Math.sin(phase*2.2)*0.11 + Math.cos(phase*1.4)*0.06) * energyFlicker;
        const vertical = (Math.cos(phase*1.9)*0.08) * energyFlicker;
        const baseX = fromX + _beamDir.x * beamLen * t;
        const baseY = fromY + _beamDir.y * beamLen * t;
        const baseZ = fromZ + _beamDir.z * beamLen * t;

        const sx = baseX + _beamSide.x*lateral + _beamUp.x*vertical;
        const sy = baseY + _beamSide.y*lateral + _beamUp.y*vertical;
        const sz = baseZ + _beamSide.z*lateral + _beamUp.z*vertical;

        const ex = sx + _beamSide.x*segLen*Math.sin(phase*2.8+0.6) + _beamUp.x*segLen*Math.cos(phase*2.1);
        const ey = sy + _beamSide.y*segLen*Math.sin(phase*2.8+0.6) + _beamUp.y*segLen*Math.cos(phase*2.1);
        const ez = sz + _beamSide.z*segLen*Math.sin(phase*2.8+0.6) + _beamUp.z*segLen*Math.cos(phase*2.1);

        crackleArr.setXYZ(i*2, sx, sy, sz);
        crackleArr.setXYZ(i*2+1, ex, ey, ez);
      }
      crackleArr.needsUpdate = true;
    }

    // wave visual pool
    const waves = []; // {mesh, life, maxLife, range, dmg}
    function spawnWave(cfg){
      const ring = new THREE.Mesh(
        new THREE.TorusGeometry(0.35, 0.08, 10, 26),
        new THREE.MeshStandardMaterial({
          color: cfg.color,
          emissive: cfg.color,
          emissiveIntensity: 1.0,
          transparent:true,
          opacity:0.8,
          roughness:0.3
        })
      );
      ring.position.set(me.x, heightAt(me.x,me.z,regionAt(me.x,me.z).id)+0.15, me.z);
      ring.rotation.x = Math.PI/2;
      ring.rotation.z = -me.yaw; // face forward-ish
      world.add(ring);
      waves.push({
        mesh:ring,
        life:0,
        maxLife:0.55,
        maxR: cfg.range * me.rangeMul,
        dmg: cfg.dmg * me.damageMul,
        hit: new Set()
      });
    }

    // ============================================================
    // Enemy attacks + telegraphs
    // ============================================================
    function makeTeleCircle(color=0xff2a2a){
      const m = new THREE.Mesh(
        new THREE.RingGeometry(0.6, 0.75, 28),
        new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.85, side:THREE.DoubleSide })
      );
      m.rotation.x = -Math.PI/2;
      return m;
    }

    function makeMarker(color=0xff3b1a){
      const m = new THREE.Mesh(
        new THREE.RingGeometry(0.7, 1.0, 28),
        new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.9, side:THREE.DoubleSide })
      );
      m.rotation.x = -Math.PI/2;
      return m;
    }

    function distanceBandMultiplier(x,z){
      return dangerBandAt(x,z);
    }

    function enemyWindupFor(e){
      const b = e.dangerBand;
      if(e.type==="scorpion") return 0.72;
      if(e.type==="boar") return (b==="outer" && e.data.doubleChargeReady) ? 0.34 : 0.55;
      if(e.type==="icegolem") return 0.95;
      if(e.type==="brute") return 0.78;
      if(e.kind==="mortar") return 0.9;
      if(e.kind==="lobber") return 0.75;
      if(e.kind==="ranged") return 0.6;
      return 0.52;
    }

    function spawnEnemyBolt(e, toX, toY, toZ, opts={}){
  const fromX = e.mesh.position.x;
  const fromZ = e.mesh.position.z;
  const fromY = e.mesh.position.y + (e.flying?0.25:0.9);

  const dir = _v2.set(toX-fromX, toY-fromY, toZ-fromZ);
  const len = dir.length(); if(len<=0.0001) return;
  dir.multiplyScalar(1/len);

  let speed = opts.speed ?? 18;
  let color = opts.color ?? 0xef4444;
  let rad = opts.rad ?? 0.55;
  let life = opts.life ?? 2.2;
  let kind = opts.kind ?? "bolt";
  let aoe = opts.aoe ?? 0;
  let puddle = opts.puddle || 0;
  let slow = opts.slow || 0;

  if(e.type==="sandwisp"){
    speed = opts.speed ?? 8.2;
    color = 0xfbbf24;
    life = opts.life ?? 4.2;
    rad = 0.62;
    kind = opts.kind ?? "sandOrb";
  }else if(e.type==="frostling"){
    speed = opts.speed ?? 21;
    color = 0x93c5fd;
    life = opts.life ?? 1.7;
    rad = 0.35;
    slow = Math.max(slow, 0.28);
    kind = opts.kind ?? "iceShard";
  }

  // Build a richer projectile model (group)
  const grp = new THREE.Group();

  const addGlow = (sz, op)=>{
    const s = glowSprite(color, sz, op, FX_TEX.softGlow);
    s.position.set(0,0,0);
    grp.add(s);
    grp.userData._glow = s;
  };

  if(kind==="sandOrb"){
    const core = new THREE.Mesh(
      new THREE.SphereGeometry(0.22, 12, 10),
      new THREE.MeshStandardMaterial({
        color,
        emissive: color,
        emissiveIntensity: 1.2,
        roughness:0.25,
        transparent:true,
        opacity:0.75
      })
    );
    const ring = new THREE.Mesh(
      new THREE.TorusGeometry(0.30, 0.06, 10, 24),
      new THREE.MeshBasicMaterial({
        color,
        transparent:true,
        opacity:0.55,
        depthWrite:false,
        blending:THREE.AdditiveBlending
      })
    );
    ring.rotation.x = Math.PI/2;
    grp.add(core, ring);
    addGlow(0.75, 0.35);
    grp.userData.spin = 6.0;
  }
  else if(kind==="toxic"){
    const blob = new THREE.Mesh(
      new THREE.SphereGeometry(0.18, 12, 10),
      new THREE.MeshStandardMaterial({
        color,
        emissive: color,
        emissiveIntensity: 1.3,
        roughness:0.22,
        transparent:true,
        opacity:0.9
      })
    );
    blob.scale.set(1.0,1.2,1.0);
    grp.add(blob);
    addGlow(0.65, 0.30);
    grp.userData.spin = 9.0;
  }
  else if(kind==="iceShard"){
    const shard = new THREE.Mesh(
      new THREE.ConeGeometry(0.14, 0.55, 10),
      new THREE.MeshStandardMaterial({
        color,
        emissive: color,
        emissiveIntensity: 1.1,
        roughness:0.18,
        transparent:true,
        opacity:0.95
      })
    );
    shard.rotation.x = Math.PI; // point forward-ish
    grp.add(shard);
    addGlow(0.55, 0.25);
    grp.userData.spin = 10.0;
  }
  else{
    const core = new THREE.Mesh(
      GEO.ember,
      new THREE.MeshStandardMaterial({
        color,
        emissive: color,
        emissiveIntensity: 1.3,
        roughness:0.25,
        transparent:true,
        opacity:0.95
      })
    );
    grp.add(core);
    addGlow(0.55, 0.22);
    grp.userData.spin = 7.0;
  }

  grp.position.set(fromX, fromY, fromZ);
  world.add(grp);

  projectiles.push({
    mesh: grp,
    x:fromX, y:fromY, z:fromZ,
    vx:dir.x*speed, vy:dir.y*speed, vz:dir.z*speed,
    life,
    rad,
    dmg: e.dmg,
    from:"enemy",
    kind,
    color,
    splinter:false,
    explode:false,
    aoe,
    puddle,
    slow,
    spin: grp.userData.spin || 0
  });
}

    function spawnMortar(e, targetX, targetZ){
      // marker first
      const reg = regionAt(targetX, targetZ);
      const marker = makeMarker(0xff3b1a);
      marker.position.set(targetX, heightAt(targetX,targetZ, reg.id)+0.05, targetZ);
      world.add(marker);

      // schedule a projectile that "falls" after delay
      const delay = 0.95;
      e.tele = { marker, t:0, delay, x:targetX, z:targetZ };
    }

    function spawnGoblinSpear(targetX, targetZ, dmg){
      const reg = regionAt(targetX, targetZ);
      const gy = heightAt(targetX, targetZ, reg.id);
      const marker = makeMarker(0xfbbf24);
      marker.position.set(targetX, gy+0.05, targetZ);
      marker.scale.set(0.8,0.8,0.8);
      world.add(marker);
      projectiles.push({ mesh:marker, x:targetX, y:gy+0.05, z:targetZ, life:1.1, from:"enemy", kind:"goblinSpear", dmg, aoe:1.8 });
    }

    function explodeAt(x,y,z, rad, dmg, from="player"){
      // quick visual: expanding sphere
      const s = new THREE.Mesh(
        new THREE.SphereGeometry(0.35, 10, 10),
        new THREE.MeshStandardMaterial({
          color: 0xff3b1a,
          emissive: 0xff3b1a,
          emissiveIntensity: 1.6,
          transparent:true,
          opacity:0.75,
          roughness:0.25
        })
      );
      s.position.set(x,y,z);
      world.add(s);
      projectiles.push({
        mesh:s,
        x,y,z,
        vx:0,vy:0,vz:0,
        life:0.22,
        rad:rad,
        dmg:dmg,
        from,
        kind:"explosion",
        aoe:rad,
        explode:false,
        splinter:false
      });

      const r2 = rad*rad;

      if(from==="player"){
        for(const e of enemies){
          if(e.hp<=0) continue;
          const ex=e.mesh.position.x, ez=e.mesh.position.z, ey=e.mesh.position.y+(e.flying?0.2:0.7);
          const d2 = (ex-x)*(ex-x) + (ez-z)*(ez-z) + (ey-y)*(ey-y);
          if(d2<=r2){
            const fall = 1 - Math.sqrt(d2)/rad;
            dealDamageEnemy(e, dmg*fall);
          }
        }
      }else{
        const px=me.x, pz=me.z, py=me.y;
        const d2 = (px-x)*(px-x)+(pz-z)*(pz-z)+(py-y)*(py-y);
        if(d2<=r2){
          const fall = 1 - Math.sqrt(d2)/rad;
          takeDamage(dmg*fall, "Explosion");
        }
      }
    }

    // ============================================================
    // Drops / inventory
    // ============================================================
    const MAT_COL = {
      iron:   0x93c5fd,
      hide:   0xf59e0b,
      essence:0x22c55e,
      crystal:0xff3ad7,
      ember:  0xff3b1a,
      sigil:  0xfef08a
    };

    function dropFromEnemy(e){
      const ex = e.mesh?.position.x ?? e.x;
      const ez = e.mesh?.position.z ?? e.z;
      const reg = regionAt(ex, ez);
      const band = dangerBandAt(ex, ez);
      const dropsHere = reg.drops;
      const rnd = xorshift32((worldSeed ^ (e.id*2654435761))|0);

      if(rnd() > band.dropChance) return;

      const count = (rnd()<0.72) ? 1 : 2;
      for(let i=0;i<count;i++){
        const matName = dropsHere[(rnd()*dropsHere.length)|0];
        const c = MAT_COL[matName] || 0xffffff;

        const m = new THREE.Mesh(GEO.drop, MAT.drop.clone());
        m.material.color.setHex(c);
        m.material.emissive.setHex(c);
        m.material.emissiveIntensity = 0.8;
        m.material.roughness = 0.35;

        const y = heightAt(ex, ez, reg.id);
        const ox = (rnd()-0.5)*0.24, oz=(rnd()-0.5)*0.24;
        m.position.set(ex+ox, y+0.35, ez+oz);
        world.add(m);

        drops.push({ x:ex+ox, y:y+0.35, z:ez+oz, mesh:m, mat:matName, spin: rnd()*10, pull:0, qty:1 });
      }
    }

    function xpFromEnemy(e){
      const band = dangerBandAt(e.mesh.position.x, e.mesh.position.z);
      const typeBonus = ({ brute:7, icegolem:6, mortar:5, floater:4, goblin:4, drone:3 })[e.type] || 0;
      const base = 5 + Math.floor(me.level*0.75) + typeBonus;
      return Math.max(2, Math.round(base * band.xpMul));
    }

    function pickupDrops(dt){
      for(let i=drops.length-1;i>=0;i--){
        const d = drops[i];
        d.spin += dt*3.2;
        d.mesh.rotation.y = d.spin;
        d.mesh.position.y = d.y + Math.sin(d.spin*1.2)*0.08;

        const dx = me.x - d.mesh.position.x;
        const dz = me.z - d.mesh.position.z;
        const dy = me.y - d.mesh.position.y;
        const d2 = dx*dx+dz*dz+dy*dy;
        if(d2 < 5.2*5.2){
          const dd = Math.sqrt(d2)||1;
          const pull = clamp((5.2-dd)/5.2, 0, 1);
          d.pull = Math.min(1.6, (d.pull||0) + dt*(0.9 + pull*2.1));
          d.mesh.position.x += (dx/dd) * d.pull * dt * 6.0;
          d.mesh.position.z += (dz/dd) * d.pull * dt * 6.0;
          d.mesh.position.y += (dy/dd) * d.pull * dt * 4.0;
        }
        if(d2 < 1.7*1.7){
          const qty = d.qty || 1;
          if(d.mat === "sigil"){
            showToast(`üî± Sigil shard secured (${sigilsCollected}/5)`);
          }else{
            me.mats[d.mat] = (me.mats[d.mat]||0) + qty;
            showToast(`+${qty} ${d.mat}`);
          }
          world.remove(d.mesh);
          drops.splice(i,1);
        }
      }
    }

    // ============================================================
    // Damage / XP / leveling
    // ============================================================
    let alive = true;

    function takeDamage(dmg, why="Hit"){
      if(!alive) return;
      me.lastHitAt = performance.now()*0.001;
      me.hp -= dmg;
      me.hp = Math.max(0, me.hp);
      if(me.hp <= 0){
        alive = false;
        overlayDead.style.opacity = "1";
        showToast("üíÄ You fell. Load a save or start a new run.", 2800);
        openDeathModal();
      }
    }

    function gainXp(xp){
      me.xp += xp;
      while(me.xp >= me.nextXp){
        me.xp -= me.nextXp;
        me.level++;
        me.nextXp = Math.round(24 + me.level*18 + me.level*me.level*1.35);
        // small heal on level
        me.hp = Math.min(me.maxHp, me.hp + 12);
        showToast(`‚≠ê Level ${me.level}! Choose an upgrade.`);
        saveGame(true);
        openLevelUpModal();
      }
    }

    function spawnEnemyDeathBurst(e){
      if(!e?.mesh) return;
      const tint = new THREE.Color((e.mesh.userData?.typeTint ?? 0xffffff));
      const pieces = 12 + Math.floor(Math.random()*7);
      for(let i=0;i<pieces;i++){
        const spark = glowSprite(tint.getHex(), 0.12 + Math.random()*0.12, 0.8, FX_TEX.spark);
        spark.position.copy(e.mesh.position);
        spark.position.y += (e.flying?0.55:0.35) + (Math.random()-0.5)*0.35;
        world.add(spark);
        const v = 3.2 + Math.random()*3.4;
        const ang = Math.random()*Math.PI*2;
        projectiles.push({
          mesh:spark,
          x:spark.position.x,
          y:spark.position.y,
          z:spark.position.z,
          vx:Math.cos(ang)*v,
          vy:(Math.random()*2.2)+0.8,
          vz:Math.sin(ang)*v,
          life:0.35 + Math.random()*0.25,
          rad:0,
          dmg:0,
          from:"fx",
          kind:"enemyDeathFx"
        });
      }
    }

    function dealDamageEnemy(e, dmg){
      e.hp -= dmg;
      if(e.hp <= 0){
        e.hp = 0;
        // cleanup telegraphs
        if(e.tele?.marker){ world.remove(e.tele.marker); }
        if(e.tele?.ring){ world.remove(e.tele.ring); }
        spawnEnemyDeathBurst(e);

        if(e.type==="scarab" && e.inOuter && !e.data.splitSpawned){
          e.data.splitSpawned = true;
          for(let i=0;i<2;i++){
            const a = (Math.PI*i) + Math.random()*0.5;
            const sx = e.mesh.position.x + Math.cos(a)*0.85;
            const sz = e.mesh.position.z + Math.sin(a)*0.85;
            const tiny = spawnEnemy("scarab", sx, sz, e.regId);
            tiny.maxHp = Math.max(8, Math.round(e.maxHp*0.28));
            tiny.hp = tiny.maxHp;
            tiny.dmg = Math.max(3, Math.round(e.dmg*0.45));
            tiny.spd *= 1.22;
          }
        }

        if(e.type==="shardling" && !e.data.fractured){
          e.data.fractured = true;
          for(let i=0;i<2;i++){
            const a = i*Math.PI + 0.4;
            const sx = e.mesh.position.x + Math.cos(a)*1.05;
            const sz = e.mesh.position.z + Math.sin(a)*1.05;
            const f = spawnEnemy("shardling", sx, sz, e.regId);
            f.maxHp = Math.max(7, Math.round(e.maxHp*0.24));
            f.hp = f.maxHp;
            f.dmg = Math.max(4, Math.round(e.dmg*0.48));
            f.spd *= 1.95;
            f.mesh.scale.setScalar(0.62);
            f.data.fractured = true;
            f.data.miniShard = true;
            f.inOuter = false;
          }
        }

        // drops + xp
        dropFromEnemy(e);
        const xpGain = xpFromEnemy(e);
        gainXp(xpGain);
        spawnFloatingText(`+${xpGain} XP`, e.mesh.position.x, e.mesh.position.y+1.3, e.mesh.position.z, "#86efac");
      }
    }

    function applyBoltEffects(e, p){
      if(!e || e.hp<=0 || !p) return;
      if(p.poison>0){
        e.poisonT = Math.max(e.poisonT||0, 2.8);
        e.poisonDps = Math.max(e.poisonDps||0, p.poison * me.damageMul);
      }
      if(p.stun>0){
        e.stunT = Math.max(e.stunT||0, p.stun);
      }
      if(p.irradiate){
        e.data.irradiateT = Math.max(e.data.irradiateT||0, p.irradiate.duration||3.5);
        e.data.irradiateDps = Math.max(e.data.irradiateDps||0, p.irradiate.dps||3.5);
        e.data.irradiateRad = Math.max(e.data.irradiateRad||0, p.irradiate.radius||2.8);
      }
      if(p.knockback>0){
        const dx = e.mesh.position.x - p.x;
        const dz = e.mesh.position.z - p.z;
        const d = Math.hypot(dx,dz) || 1;
        e.kbX += (dx/d) * p.knockback;
        e.kbZ += (dz/d) * p.knockback;
      }
    }

    function chainLightningFrom(target, p){
      if(!target || !p.chainBounces) return;
      let from = target;
      const jumped = new Set([target.id]);
      for(let i=0;i<p.chainBounces;i++){
        const candidates = enemies
          .filter(e=>e.hp>0 && !jumped.has(e.id))
          .sort((a,b)=>dist2(a.mesh.position.x,a.mesh.position.z,from.mesh.position.x,from.mesh.position.z)-dist2(b.mesh.position.x,b.mesh.position.z,from.mesh.position.x,from.mesh.position.z));
        const next = candidates[0];
        if(!next) break;
        const d = Math.hypot(next.mesh.position.x-from.mesh.position.x, next.mesh.position.z-from.mesh.position.z);
        if(d > (p.chainRange||7)) break;

        const pts = [
          new THREE.Vector3(from.mesh.position.x, from.mesh.position.y+0.6, from.mesh.position.z),
          new THREE.Vector3(next.mesh.position.x, next.mesh.position.y+0.6, next.mesh.position.z)
        ];
        const geo = new THREE.BufferGeometry().setFromPoints(pts);
        const line = new THREE.Line(geo, new THREE.LineBasicMaterial({ color:p.color||0x7dd3fc, transparent:true, opacity:0.95 }));
        world.add(line);
        projectiles.push({ mesh:line, x:0,y:0,z:0,vx:0,vy:0,vz:0,life:0.12,rad:0,dmg:0,from:"fx",kind:"fxLine" });

        dealDamageEnemy(next, p.dmg * 0.62);
        applyBoltEffects(next, p);
        jumped.add(next.id);
        from = next;
      }
    }

    function tickPlayerRegen(dt, now){
      if(paused || !alive) return;
      if(me.hp >= me.maxHp) return;
      if(now - me.lastHitAt < 5.0) return;
      me.hp = Math.min(me.maxHp, me.hp + me.hpRegen*dt);
    }

    // ============================================================
    // Abilities (unlocked via level-up options)
    // ============================================================
    function tickAbilities(dt){
      if(!alive) return;
      // Poison aura: purple hue and drain near you
      if(me.abil.poisonAura){
        const rad = 6.0;
        const r2 = rad*rad;
        for(const e of enemies){
          if(e.hp<=0) continue;
          const dx = e.mesh.position.x-me.x;
          const dz = e.mesh.position.z-me.z;
          const d2 = dx*dx+dz*dz;
          if(d2<=r2){
            // tint enemy
            e.mesh.traverse((o)=>{
              if(o.material && o.material.emissive){
                o.material.emissive.setHex(0x7c3aed);
                o.material.emissiveIntensity = 0.7;
              }
            });
            dealDamageEnemy(e, dt * (3.0 + 0.35*me.level) );
          }
        }
      }

      // Life grip: periodically tether a random enemy and steal health
      if(me.abil.lifeGrip){
        me.lifeGripT -= dt;
        if(me.lifeGripT <= 0){
          me.lifeGripT = 5.2 + Math.random()*2.0;
          const candidates = enemies.filter(e=>e.hp>0 && dist2(me.x,me.z,e.mesh.position.x,e.mesh.position.z) < 22*22);
          if(candidates.length){
            const e = candidates[(Math.random()*candidates.length)|0];
            const steal = 8 + me.level*0.45;
            dealDamageEnemy(e, steal);
            me.hp = Math.min(me.maxHp, me.hp + steal*0.45);

            // line effect
            const pts = [new THREE.Vector3(me.x, me.y, me.z), new THREE.Vector3(e.mesh.position.x, e.mesh.position.y+0.6, e.mesh.position.z)];
            const geo = new THREE.BufferGeometry().setFromPoints(pts);
            const line = new THREE.Line(geo, new THREE.LineBasicMaterial({ color:0x7c3aed, transparent:true, opacity:0.9 }));
            world.add(line);
            projectiles.push({ mesh:line, x:0,y:0,z:0, vx:0,vy:0,vz:0, life:0.16, rad:0, dmg:0, from:"fx", kind:"fxLine" });
          }
        }
      }

      // Meteorite: periodically strike near a random enemy
      if(me.abil.meteorite){
        me.meteorT -= dt;
        if(me.meteorT <= 0){
          me.meteorT = 6.8 + Math.random()*2.8;
          const candidates = enemies.filter(e=>e.hp>0 && dist2(me.x,me.z,e.mesh.position.x,e.mesh.position.z) < 36*36);
          if(candidates.length){
            const e = candidates[(Math.random()*candidates.length)|0];
            const tx = e.mesh.position.x + (Math.random()-0.5)*2.0;
            const tz = e.mesh.position.z + (Math.random()-0.5)*2.0;
            const reg = regionAt(tx,tz);
            const gy = heightAt(tx,tz, reg.id);

            const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(0.35,0), new THREE.MeshStandardMaterial({
              color:0xffd37a,
              emissive:0xff3b1a,
              emissiveIntensity:1.4,
              roughness:0.35
            }));
            rock.position.set(tx, gy+18, tz);
            world.add(rock);
            projectiles.push({
              mesh:rock,
              x:tx, y:gy+18, z:tz,
              vx:0, vy:-26, vz:0,
              life:1.2,
              rad:0.5,
              dmg:0,
              from:"fx",
              kind:"meteor",
              targetY: gy+0.3,
              aoe: 3.2,
              hitDmg: 24 + me.level*1.2
            });
          }
        }
      }

      // Firebolt: cooldown; fires at target you're facing, big explosion
      if(me.abil.firebolt){
        me.fireboltCd -= dt;
        if(me.fireboltCd <= 0){
          const t = pickTarget(24*me.rangeMul);
          if(t){
            me.fireboltCd = 6.5;
            showToast("üî• Firebolt!");

            const fx = new THREE.Mesh(GEO.ember, new THREE.MeshStandardMaterial({
              color:0xff3b1a, emissive:0xff3b1a, emissiveIntensity:1.8, roughness:0.25
            }));
            const fromX=me.x, fromY=me.y, fromZ=me.z;
            const toX=t.mesh.position.x, toY=t.mesh.position.y+0.65, toZ=t.mesh.position.z;
            fx.position.set(fromX,fromY,fromZ);
            world.add(fx);

            const dir = _v2.set(toX-fromX, toY-fromY, toZ-fromZ);
            const len = dir.length() || 1;
            dir.multiplyScalar(1/len);
            const speed=34;

            projectiles.push({
              mesh:fx,
              x:fromX, y:fromY, z:fromZ,
              vx:dir.x*speed, vy:dir.y*speed, vz:dir.z*speed,
              life:1.1,
              rad:0.8,
              dmg: 0,
              from:"player",
              kind:"firebolt",
              aoe: 4.2,
              hitDmg: 32 + me.level*1.6
            });
          }
        }
      }

      if(me.abil.turretTotem){
        me.turretCd -= dt;
        if(me.turretCd <= 0){
          me.turretCd = 13.0;
          const m = new THREE.Mesh(new THREE.CylinderGeometry(0.22,0.34,1.1,10), new THREE.MeshStandardMaterial({ color:0x93c5fd, emissive:0x38bdf8, emissiveIntensity:0.9, roughness:0.35 }));
          m.position.set(me.x + Math.cos(me.yaw)*1.5, heightAt(me.x,me.z,regionAt(me.x,me.z).id)+0.55, me.z + Math.sin(me.yaw)*1.5);
          world.add(m);
          turrets.push({ mesh:m, life:5.0, fireCd:0.08 });
        }
      }

      for(let i=turrets.length-1;i>=0;i--){
        const t = turrets[i];
        t.life -= dt;
        t.fireCd -= dt;
        const reg = regionAt(t.mesh.position.x, t.mesh.position.z);
        t.mesh.position.y = heightAt(t.mesh.position.x, t.mesh.position.z, reg.id) + 0.55;
        const target = enemies.filter(e=>e.hp>0).sort((a,b)=>dist2(a.mesh.position.x,a.mesh.position.z,t.mesh.position.x,t.mesh.position.z)-dist2(b.mesh.position.x,b.mesh.position.z,t.mesh.position.x,t.mesh.position.z))[0];
        if(target){
          t.mesh.lookAt(target.mesh.position.x, t.mesh.position.y+0.12, target.mesh.position.z);
          if(t.fireCd<=0){
            t.fireCd = 0.22;
            spawnBolt(t.mesh.position.x, t.mesh.position.y+0.35, t.mesh.position.z, target.mesh.position.x, target.mesh.position.y+0.6, target.mesh.position.z, { dmg:7.5, color:0x93c5fd, chainBounces:1, chainRange:4.6 });
          }
        }
        if(t.life<=0){ world.remove(t.mesh); turrets.splice(i,1); }
      }

    }

    // ============================================================
    // Modals (forge / level-up / death)
    // ============================================================
    let uiMode = "none"; // none | forge | level | death
    let paused = false;

    function openModal(html){
      modal.innerHTML = html;
      modalShade.style.opacity = "1";
      modalShade.style.pointerEvents = "auto";
      modal.style.opacity = "1";
      modal.style.pointerEvents = "auto";
    }
    function closeModal(){
      uiMode = "none";
      paused = false;
      modalShade.style.opacity = "0";
      modalShade.style.pointerEvents = "none";
      modal.style.opacity = "0";
      modal.style.pointerEvents = "none";
      modal.innerHTML = "";
    }

    modalShade.addEventListener("click", ()=>{
      // click outside closes forge; level-up/death shouldn't close
      if(uiMode==="forge") closeModal();
    });

    function canAfford(req){
      for(const k in req){
        if((me.mats[k]||0) < req[k]) return false;
      }
      return true;
    }
    function payReq(req){
      for(const k in req){ me.mats[k] -= req[k]; }
    }

    function openForgeModal(){
      uiMode = "forge";
      paused = true;

      const inv = Object.entries(me.mats)
        .map(([k,v])=>`<span class="chip">${k}: <b>${v}</b></span>`)
        .join("");

      const owned = Array.from(me.ownedWeapons)
        .map(w=>`<span class="chip">üó°Ô∏è ${w}${w===me.weapon ? " (equipped)" : ""}</span>`)
        .join("");

      const recipesHtml = RECIPES.map((r)=>{
        const ownedWeapon = r.type==="weapon" && me.ownedWeapons.has(r.name);
        const ok = !ownedWeapon && canAfford(r.req);
        const reqHtml = Object.entries(r.req).map(([k,v])=>`<span class="reqItem">${k} √ó${v}</span>`).join("");
        const desc = (r.type==="weapon")
          ? (WEAPONS[r.name]?.desc || "Weapon")
          : "Forge upgrade";
        const extra = (r.type==="weapon")
          ? `<div class="desc"><b>Type:</b> ${WEAPONS[r.name].kind.toUpperCase()} ‚Ä¢ <b>Range:</b> ${WEAPONS[r.name].range ?? WEAPONS[r.name].range} ‚Ä¢ <b>Dmg:</b> ${WEAPONS[r.name].dmg ?? (WEAPONS[r.name].dps+" DPS")}</div>`
          : `<div class="desc">Permanent upgrade when crafted.</div>`;

        return `
          <div class="card">
            <div class="name">‚öíÔ∏è ${r.name}</div>
            <div class="desc">${desc}</div>
            ${extra}
            <div class="req">${reqHtml}</div>
            <div class="rowBtns">
              <button data-craft="${r.name}" ${ok ? "" : "disabled"}>${ownedWeapon ? "Owned" : (ok ? "Craft" : "Need Mats")}</button>
              ${r.type==="weapon" && me.ownedWeapons.has(r.name) ? `<button class="secondary" data-equip="${r.name}">Equip</button><span class="muted" style="font-size:12px">Owned permanently</span>` : ""}
            </div>
          </div>
        `;
      }).join("");

      openModal(`
        <h2>‚öíÔ∏è Forge</h2>
        <div class="sub">Paused. Craft weapons/upgrades with materials you collected.</div>
        <div class="grid2">
          <div class="panel">
            <div class="panelTitle">üì¶ Inventory <span class="muted">(materials)</span></div>
            <div class="chipRow">${inv || `<span class="muted">No materials yet.</span>`}</div>
            <div style="height:10px"></div>
            <div class="panelTitle">üó°Ô∏è Owned Weapons</div>
            <div class="chipRow">${owned || `<span class="muted">None</span>`}</div>
            <div style="height:10px"></div>
            <div class="muted" style="font-size:12px; line-height:1.3">
              Tip: Higher-level regions tend to spawn tougher packs, but also better drops.
            </div>
            <div style="height:10px"></div>
            <button class="btn secondary" id="closeForgeBtn" type="button" style="pointer-events:auto">Close (E / ESC)</button>
          </div>
          <div class="panel">
            <div class="panelTitle">üõ†Ô∏è Recipes</div>
            <div class="recipes">${recipesHtml}</div>
          </div>
        </div>
      `);

      $("closeForgeBtn").addEventListener("click", closeModal);

      modal.querySelectorAll("[data-craft]").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const name = btn.getAttribute("data-craft");
          const rec = RECIPES.find(r=>r.name===name);
          if(!rec) return;
          if(!canAfford(rec.req)) return;

          payReq(rec.req);

          if(rec.type==="weapon"){
            me.ownedWeapons.add(name);
            me.weapon = name;
            showToast(`üó°Ô∏è Crafted & equipped: ${name}`);
          }else{
            rec.apply?.(me);
            showToast(`‚ú® Crafted: ${name}`);
          }
          saveGame(true);
          openForgeModal(); // refresh
        });
      });

      modal.querySelectorAll("[data-equip]").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const name = btn.getAttribute("data-equip");
          if(!me.ownedWeapons.has(name)) return;
          me.weapon = name;
          showToast(`üó°Ô∏è Equipped: ${name}`);
          saveGame(true);
          openForgeModal();
        });
      });
    }

    function openLevelUpModal(){
      uiMode = "level";
      paused = true;

      const pool = [];

      pool.push({
        title:"‚ù§Ô∏è More Health",
        sub:`+20 Max HP (and heal 20)`,
        apply:()=>{ me.maxHp += 20; me.hp = Math.min(me.maxHp, me.hp+20); }
      });
      pool.push({
        title:"üó°Ô∏è More Damage",
        sub:`+15% damage`,
        apply:()=>{ me.damageMul *= 1.15; }
      });
      pool.push({
        title:"üéØ More Range",
        sub:`+12% weapon range`,
        apply:()=>{ me.rangeMul *= 1.12; }
      });
      pool.push({
        title:"üëü More Speed",
        sub:`+12% movement speed`,
        apply:()=>{ me.speedMul *= 1.12; }
      });

      pool.push({
        title:"üíö Better Regen",
        sub:`+0.7 HP/sec out-of-combat regen`,
        apply:()=>{ me.hpRegen += 0.7; }
      });

      // abilities (only if not owned)
      if(!me.abil.poisonAura){
        pool.push({
          title:"üü£ Poison Aura",
          sub:"Nearby enemies gain a purple hue and slowly lose health.",
          apply:()=>{ me.abil.poisonAura=true; }
        });
      }
      if(!me.abil.lifeGrip){
        pool.push({
          title:"üß¨ Life Grip",
          sub:"Periodically tethers a random enemy, steals health, heals you.",
          apply:()=>{ me.abil.lifeGrip=true; me.lifeGripT = 2.0; }
        });
      }
      if(!me.abil.meteorite){
        pool.push({
          title:"‚òÑÔ∏è Meteorite",
          sub:"Periodically calls down explosive meteorites on enemies.",
          apply:()=>{ me.abil.meteorite=true; me.meteorT = 2.6; }
        });
      }
      if(!me.abil.firebolt){
        pool.push({
          title:"üî• Firebolt",
          sub:"On cooldown, fires a bolt at the enemy you‚Äôre aiming at and explodes.",
          apply:()=>{ me.abil.firebolt=true; me.fireboltCd = 2.0; }
        });
      }
      if(!me.abil.turretTotem){
        pool.push({
          title:"üõ°Ô∏è Turret Totem",
          sub:"Periodically spawns a 5-second auto-firing turret.",
          apply:()=>{ me.abil.turretTotem=true; me.turretCd = 1.5; }
        });
      }

      // pick 3
      const rnd = xorshift32((worldSeed ^ (me.level*98731) ^ ((Date.now()/1000)|0))|0);
      const picks = [];
      const used = new Set();
      while(picks.length<3 && used.size<pool.length){
        const i = (rnd()*pool.length)|0;
        if(used.has(i)) continue;
        used.add(i);
        picks.push(pool[i]);
      }

      const cards = picks.map((p, idx)=>`
        <div class="card" style="min-height:140px">
          <div class="name">${p.title}</div>
          <div class="desc">${p.sub}</div>
          <div class="rowBtns">
            <button data-pick="${idx}">Choose</button>
          </div>
        </div>
      `).join("");

      openModal(`
        <h2>‚≠ê Level Up ‚Äî Choose 1</h2>
        <div class="sub">Game paused. Pick one upgrade to continue.</div>
        <div class="panel">
          <div class="recipes" style="grid-template-columns:repeat(3, minmax(0, 1fr))">${cards}</div>
        </div>
      `);

      modal.querySelectorAll("[data-pick]").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const idx = +btn.getAttribute("data-pick");
          picks[idx]?.apply?.();
          saveGame(true);
          closeModal();
        });
      });
    }

    function openDeathModal(){
      uiMode = "death";
      paused = true;
      openModal(`
        <h2>üíÄ You fell</h2>
        <div class="sub">Load your save, or start a fresh run.</div>
        <div class="panel">
          <div class="row" style="justify-content:flex-start">
            <button class="btn secondary" id="deathLoad">‚¨Ü Load Save</button>
            <button class="btn" id="deathNew">üü© New Run</button>
          </div>
          <div class="muted" style="margin-top:10px; font-size:12px">
            Tip: Use forges often ‚Äî crafting upgrades makes later packs much easier.
          </div>
        </div>
      `);
      $("deathLoad").addEventListener("click", ()=>{
        const ok = loadGame();
        if(!ok) resetRun(true);
        alive = true;
        overlayDead.style.opacity = "0";
        closeModal();
      });
      $("deathNew").addEventListener("click", ()=>{
        resetRun(true);
        alive = true;
        overlayDead.style.opacity = "0";
        closeModal();
      });
    }

    // ============================================================
    // Forge open logic
    // ============================================================
    function tryOpenForge(){
      if(paused || !alive) return;
      const nf = nearestForge();
      if(!nf) return;
      if(nf.d <= 3.2){
        openForgeModal();
      }
    }

    // ============================================================
    // Movement / camera / world boundary
    // ============================================================
    function tickMove(dt){
      if(phase!=="play") return;

      if(mobile.enabled && !paused){
        const turnRate = 2.8 * (me.turnSlowT>0 ? 0.72 : 1.0);
        const lookRate = 2.2 * (me.turnSlowT>0 ? 0.72 : 1.0);
        me.yaw   -= mobile.lookX * turnRate * dt;
        me.pitch -= mobile.lookY * lookRate * dt;
        me.pitch = clamp(me.pitch, -1.32, 1.32);
      }

      if(paused || !alive){
        // keep camera attached
        const reg = regionAt(me.x, me.z);
        const gy = heightAt(me.x, me.z, reg.id);
        me.y = gy + PLAYER_H;
        camera.position.set(me.x, me.y, me.z);
        camera.rotation.set(me.pitch, me.yaw, 0, "YXZ");
        return;
      }

      const forward = (keys["w"]||keys["arrowup"]) ? 1 : 0;
      const back    = (keys["s"]||keys["arrowdown"]) ? 1 : 0;
      const left    = (keys["a"]||keys["arrowleft"]) ? 1 : 0;
      const right   = (keys["d"]||keys["arrowright"]) ? 1 : 0;

      let mx = right - left;
      let mz = forward - back;

      const sprint = !!keys["shift"];
      const baseSpeed = sprint ? 5.6 : 4.0;
      if(me.slowT>0){
        me.slowT = Math.max(0, me.slowT - dt);
        if(me.slowT<=0) me.slowMul = 1.0;
      }
      if(me.turnSlowT>0) me.turnSlowT = Math.max(0, me.turnSlowT-dt);
      const speed = baseSpeed * me.speedMul * me.slowMul;

      if(mobile.enabled){
        mx = mobile.moveX;
        mz = -mobile.moveY;
      }

      const mlen = Math.hypot(mx, mz);
      if(mlen>0){ mx/=mlen; mz/=mlen; }

      const sy = Math.sin(me.yaw), cy = Math.cos(me.yaw);
      const targetVx = (mx*cy - mz*sy)*speed;
      const targetVz = (-mx*sy - mz*cy)*speed;

      const accel = 18;
      me.vx += (targetVx - me.vx) * Math.min(1, accel*dt);
      me.vz += (targetVz - me.vz) * Math.min(1, accel*dt);

      // gravity + jump
      const reg = regionAt(me.x, me.z);
      const groundY = heightAt(me.x, me.z, reg.id);

      if(keys[" "] && me.grounded){
        me.vy = 3.8;
        me.grounded = false;
      }

      me.vy -= GRAVITY*dt;
      me.y += me.vy*dt;

      const desiredGround = groundY + PLAYER_H;
      if(me.y <= desiredGround){
        me.y = desiredGround;
        me.vy = 0;
        me.grounded = true;
      }

      const nx = me.x + me.vx*dt;
      const nz = me.z + me.vz*dt;

      me.x = nx; me.z = nz;

      // never clip into rising terrain after horizontal movement
      const nextReg = regionAt(me.x, me.z);
      const nextGround = heightAt(me.x, me.z, nextReg.id) + PLAYER_H;
      if(me.y < nextGround){
        me.y = nextGround;
        if(me.vy < 0) me.vy = 0;
        me.grounded = true;
      }

      // world boundary push-back
      const rr = Math.hypot(me.x, me.z);
      if(rr > WORLD_RADIUS - 2){
        const k = (WORLD_RADIUS - 2) / rr;
        me.x *= k; me.z *= k;
        me.vx *= 0.2; me.vz *= 0.2;
        showToast("üß± World boundary.");
      }

      // travel meter for spawning pacing
      travelMeter += Math.hypot(me.vx*dt, me.vz*dt);

      camera.position.set(me.x, me.y, me.z);
      camera.rotation.set(me.pitch, me.yaw, 0, "YXZ");
    }

    // ============================================================
    // Enemy update
    // ============================================================
    function tickEnemies(dt, now){
      if(paused || !alive) return;

      // soft separation to prevent clumping
      const sepR = 2.5;
      const sepR2 = sepR*sepR;

      for(const e of enemies){
        if(e.hp<=0) continue;

        // update base ground y and flight bob
        const reg = regionAt(e.mesh.position.x, e.mesh.position.z);
        e.yBase = heightAt(e.mesh.position.x, e.mesh.position.z, reg.id);

        e.bob += dt * (e.flying ? 2.4 : 1.5);
        const flyY = e.flying ? (e.yBase + e.modelLift + e.yOff + Math.sin(e.bob)*0.18) : (e.yBase + e.modelLift);
        e.mesh.position.y = flyY;

        // health bar faces camera
        const bar = e.mesh.userData.hpBar;
        if(bar){
          bar.lookAt(camera.position);
          const t = clamp(e.hp / e.maxHp, 0, 1);
          bar.userData.fg.scale.x = t;
          bar.userData.fg.position.x = -0.525 + (t*0.525);
          // color shift
          const col = (t>0.55) ? 0x22c55e : (t>0.25 ? 0xeab308 : 0xef4444);
          bar.userData.fg.material.color.setHex(col);
        }

        // remove poison tint fade (if aura not affecting)
        if(!me.abil.poisonAura){
          e.mesh.traverse((o)=>{
            if(o.material && o.material.emissive){
              // slight region emissive baseline
              o.material.emissiveIntensity = Math.max(0.25, o.material.emissiveIntensity*0.94);
            }
          });
        }

        // status effects
        if(e.poisonT>0){
          e.poisonT -= dt;
          dealDamageEnemy(e, dt*(e.poisonDps||0));
          e.mesh.traverse((o)=>{
            if(o.material && o.material.emissive){
              o.material.emissive.setHex(0x22c55e);
              o.material.emissiveIntensity = Math.max(o.material.emissiveIntensity||0.4, 0.85);
            }
          });
        }
        if(e.data.irradiateT>0){
          e.data.irradiateT -= dt;
          const dps = e.data.irradiateDps||3.5;
          dealDamageEnemy(e, dps*dt);
          const rad = e.data.irradiateRad||2.8;
          for(const o of enemies){
            if(o===e || o.hp<=0) continue;
            if(dist2(o.mesh.position.x,o.mesh.position.z,e.mesh.position.x,e.mesh.position.z) <= rad*rad){
              dealDamageEnemy(o, dps*0.45*dt);
            }
          }
          if(!e.data.bugSwarm){
            const swarm = new THREE.Group();
            for(let b=0;b<5;b++) swarm.add(new THREE.Mesh(new THREE.SphereGeometry(0.05,6,5), new THREE.MeshBasicMaterial({ color:0x84cc16 })));
            e.mesh.add(swarm);
            e.data.bugSwarm = swarm;
          }
          let bi=0;
          for(const bug of e.data.bugSwarm.children){
            const a = now*0.006 + bi*1.25;
            bug.position.set(Math.cos(a)*0.55,0.8+Math.sin(a*2.1)*0.2,Math.sin(a)*0.55);
            bi++;
          }
        }else if(e.data.bugSwarm){
          e.mesh.remove(e.data.bugSwarm);
          e.data.bugSwarm = null;
        }
        if(e.stunT>0) e.stunT -= dt;
        if(e.data.turretCd>0) e.data.turretCd -= dt;

        // state machine
        e.cd -= dt;

        // separation force
        let rx=0, rz=0;
        for(const o of enemies){
          if(o===e || o.hp<=0) continue;
          const dx = e.mesh.position.x - o.mesh.position.x;
          const dz = e.mesh.position.z - o.mesh.position.z;
          const d2 = dx*dx + dz*dz;
          if(d2>0.0001 && d2<sepR2){
            const d = Math.sqrt(d2);
            const push = (sepR - d)/sepR;
            rx += (dx/d)*push;
            rz += (dz/d)*push;
          }
        }

        // chase player
        const px = me.x, pz = me.z;
        const ex = e.mesh.position.x, ez = e.mesh.position.z;
        const dx = px-ex, dz = pz-ez;
        const d = Math.hypot(dx,dz) || 1;

        // for ranged, stop a bit farther
        let want = (e.kind==="melee") ? 1.2 : (e.kind==="mortar" ? 14.5 : 10.5);
        if(e.type==="boar") want = 2.6;
        if(e.type==="icegolem") want = 2.0;
        if(e.type==="frostling") want = 7.0;
        if(e.type==="sandwisp") want = 11.5;
        if(e.type==="goblin") want = 13.5;
        if(e.type==="mirebat") want = 9.2;
        const go = (d > want) ? 1 : 0;

        // attacks
        if(e.stunT>0){
          if(e.tele?.ring){ world.remove(e.tele.ring); }
          e.tele = e.tele?.marker ? e.tele : null;
          e.state = "chase";
        }
        if(e.type==="wolf" && e.inOuter && !e.data.howlCd){
          e.data.howlCd = 6.0;
          for(const ally of enemies){
            if(ally.type!=="wolf" && ally.type!=="frostling") continue;
            const a2 = dist2(ally.mesh.position.x, ally.mesh.position.z, e.mesh.position.x, e.mesh.position.z);
            if(a2 < 13*13){ ally.spd *= 1.08; }
          }
        }
        if(e.data.howlCd>0) e.data.howlCd -= dt;

        if(e.state==="chase"){
          if(e.type==="boar" && !e.data.chargeState && d<11.5 && e.cd<=0){
            const ln = new THREE.Mesh(new THREE.PlaneGeometry(1.2, d), new THREE.MeshBasicMaterial({ color:0xff2a2a, transparent:true, opacity:0.45, side:THREE.DoubleSide }));
            ln.rotation.x = -Math.PI/2;
            ln.rotation.z = Math.atan2(dx,dz);
            ln.position.set(e.mesh.position.x + (dx/d)*(d*0.5), e.yBase+0.06, e.mesh.position.z + (dz/d)*(d*0.5));
            world.add(ln);
            e.data.chargeState = { t:2.0, dirx:dx/d, dirz:dz/d, line:ln, dash:0.65, dmg:e.dmg*1.9 };
            e.state="recover";
            e.wind=2.0;
          }
          // decide to attack
          if(e.cd <= 0){
            if(e.kind==="melee" && d <= e.range+0.6){
              e.state="windup";
              e.wind = enemyWindupFor(e);
              e.cd = 0.9 + Math.random()*0.9;
              const ring = makeTeleCircle(0xff2a2a);
              ring.position.set(ex, e.yBase+0.04, ez);
              world.add(ring);
              e.tele = { ring };
            }else if(e.kind==="ranged" && d <= e.range){
              e.state="windup";
              e.wind = enemyWindupFor(e);
              e.cd = 1.0 + Math.random()*0.9;
              const ring = makeTeleCircle(0x60a5fa);
              ring.position.set(ex, e.yBase+0.04, ez);
              ring.scale.set(0.8,0.8,0.8);
              world.add(ring);
              e.tele = { ring };
            }else if(e.kind==="lobber" && d <= e.range){
              e.state="windup";
              e.wind = enemyWindupFor(e);
              e.cd = 1.2 + Math.random()*0.8;
              const ring = makeTeleCircle(0xfbbf24);
              ring.position.set(ex, e.yBase+0.04, ez);
              ring.scale.set(0.95,0.95,0.95);
              world.add(ring);
              e.tele = { ring };
            }else if(e.kind==="mortar" && d <= e.range){
              e.state="windup";
              e.wind = enemyWindupFor(e);
              e.cd = 2.1 + Math.random()*0.9;
              // telegraph landing zone near player's current position
              const tx = me.x + (Math.random()-0.5)*2.2;
              const tz = me.z + (Math.random()-0.5)*2.2;
              spawnMortar(e, tx, tz);
              if(e.inOuter){
                const tx2 = me.x + (me.vx*0.45) + (Math.random()-0.5)*1.4;
                const tz2 = me.z + (me.vz*0.45) + (Math.random()-0.5)*1.4;
                spawnMortar(e, tx2, tz2);
              }
            }
          }
        }

        if(e.state==="windup"){
          e.wind -= dt;
          // animate telegraph
          if(e.tele?.ring){
            e.tele.ring.position.set(e.mesh.position.x, e.yBase+0.04, e.mesh.position.z);
            const p = 1.0 + (0.3*Math.sin(now*0.02));
            e.tele.ring.scale.set(p,p,p);
            e.tele.ring.material.opacity = 0.55 + 0.35*Math.sin(now*0.014);
          }
          if(e.wind <= 0){
            e.state="attack";
          }
        }

        if(e.state==="attack"){
          // execute
          if(e.kind==="melee"){
            // if still close, hit
            if(d <= e.range+0.9){
              takeDamage(e.dmg, "Melee");
              if(e.type==="scorpion"){ me.slowT = Math.max(me.slowT, 3.0); me.slowMul = Math.min(me.slowMul, 0.82); }
              if(e.type==="wolf"){ me.slowT = Math.max(me.slowT, 1.2); me.slowMul = Math.min(me.slowMul, 0.86); }
            }
            if(e.type==="boar" && e.inOuter && !e.data.doubleChargeUsed){
              e.data.doubleChargeUsed = true;
              e.data.doubleChargeReady = true;
              e.state = "windup";
              e.wind = 0.3;
            }else{
              if(e.tele?.ring){ world.remove(e.tele.ring); }
              e.tele = null;
              e.state="recover";
              e.wind = 0.25;
              e.data.doubleChargeReady = false;
              e.data.doubleChargeUsed = false;
            }

          }else if(e.kind==="ranged"){
            if(e.type==="drone"){
              e.burstLeft = e.burstLeft || 3;
              spawnEnemyBolt(e, me.x, me.y, me.z, { speed:20, color:0x22d3ee, rad:0.42, life:1.8 });
              e.burstLeft--;
              if(e.inOuter && d < e.range && e.burstLeft===1){
                e.mesh.position.x += (-dz/d)*2.6;
                e.mesh.position.z += (dx/d)*2.6;
              }
              if(e.burstLeft>0){
                e.state="recover";
                e.wind = 0.12;
              }else{
                e.burstLeft = 0;
                e.state="recover";
                e.wind = 0.3;
              }
            }else if(e.type==="sandwisp"){
              const fan = (e.inOuter ? [-0.26,0,0.26] : [0]);
              for(const aOff of fan){
                const tx = me.x + Math.cos(Math.atan2(dz,dx)+aOff)*d;
                const tz = me.z + Math.sin(Math.atan2(dz,dx)+aOff)*d;
                spawnEnemyBolt(e, tx, me.y, tz, { kind:"sandOrb", puddle:1.2, speed:8.2, color:0xfbbf24, life:4.5 });
              }
              e.state="recover";
              e.wind = 0.3;
            }else if(e.type==="spitter"){
              const shots = e.inOuter ? 3 : 1;
              for(let s=0;s<shots;s++){
                const off = (s-(shots-1)/2)*1.1;
                spawnEnemyBolt(e, me.x+off, me.y, me.z+off, { kind:"toxic", puddle:2.4, speed:15, color:0x84cc16, life:2.3 });
              }
              e.state="recover";
              e.wind = 0.28;
            }else if(e.type==="floater"){
              spawnEnemyBolt(e, me.x, me.y, me.z, { speed:14, color:0xa78bfa, rad:0.5, slow:0.22 });
              if(e.inOuter && !e.data.turretCd){
                e.data.turretCd = 6.0;
                const tx = e.mesh.position.x + (Math.random()-0.5)*5;
                const tz = e.mesh.position.z + (Math.random()-0.5)*5;
                spawnEnemy("drone", tx, tz, reg.id);
              }
              me.turnSlowT = Math.max(me.turnSlowT, 0.7);
              e.state="recover";
              e.wind = 0.3;
            }else if(e.type==="frostling"){
              spawnEnemyBolt(e, me.x, me.y, me.z, { kind:"iceShard", speed:21, color:0x93c5fd, life:1.7, slow:0.28 });
              if(e.inOuter){
                e.mesh.position.x += (-dz/d)*1.8;
                e.mesh.position.z += (dx/d)*1.8;
              }
              e.state="recover";
              e.wind = 0.23;
            }else{
              spawnEnemyBolt(e, me.x, me.y, me.z);
              e.state="recover";
              e.wind = 0.25;
            }
            if(e.tele?.ring){ world.remove(e.tele.ring); }
            e.tele = null;

          }else if(e.kind==="lobber"){
            const leadX = me.x + me.vx*0.55;
            const leadZ = me.z + me.vz*0.55;
            spawnGoblinSpear(leadX + (Math.random()-0.5)*1.3, leadZ + (Math.random()-0.5)*1.3, e.dmg*1.25);
            if(e.inOuter) spawnGoblinSpear(leadX + (Math.random()-0.5)*2.2, leadZ + (Math.random()-0.5)*2.2, e.dmg*1.15);
            e.mesh.position.x -= (dx/d)*1.8;
            e.mesh.position.z -= (dz/d)*1.8;
            e.state="recover";
            e.wind = 0.44;
            if(e.tele?.ring){ world.remove(e.tele.ring); }
            e.tele = null;

          }else if(e.kind==="mortar"){
            // handled via e.tele marker tick below
            e.state="recover";
            e.wind = 0.30;
          }
        }

        if(e.state==="recover"){
          e.wind -= dt;
          if(e.wind<=0) e.state="chase";
        }

        // mortar tele marker tick
        if(e.tele?.marker){
          e.tele.t += dt;
          const p = smoothstep(e.tele.t / e.tele.delay);
          e.tele.marker.material.opacity = 0.25 + 0.70*p;
          e.tele.marker.scale.set(1.0 + 0.6*p, 1.0 + 0.6*p, 1.0);

          if(e.tele.t >= e.tele.delay){
            const tx = e.tele.x, tz = e.tele.z;
            const reg2 = regionAt(tx,tz);
            const gy = heightAt(tx,tz, reg2.id)+0.25;
            world.remove(e.tele.marker);
            e.tele.marker = null;

            explodeAt(tx, gy, tz, 3.2, e.dmg*1.15, "enemy");
            e.tele = null;
          }
        }
        if(e.data.chargeState){
          const c = e.data.chargeState;
          c.t -= dt;
          if(c.line){ c.line.material.opacity = 0.25 + 0.5*Math.sin(now*0.02); }
          if(c.t<=0 && c.dash>0){
            e.mesh.position.x += c.dirx * (e.spd*7.0) * dt;
            e.mesh.position.z += c.dirz * (e.spd*7.0) * dt;
            c.dash -= dt;
            const pd2 = dist2(me.x,me.z,e.mesh.position.x,e.mesh.position.z);
            if(pd2 < 1.7*1.7){ takeDamage(c.dmg, "Boar Charge"); c.dash = 0; }
          }
          if(c.t<=0 && c.dash<=0){ if(c.line) world.remove(c.line); e.data.chargeState=null; e.cd = 1.8; }
        }

        // run custom enemy animations (wings, tails, rings, pulses)
e.mesh.userData.anim?.(e, dt, now);

        // movement integrate (with separation)
        const dirx = dx/d, dirz = dz/d;
        const moveScale = e.stunT>0 ? 0.08 : 1.0;
        if(e.type==="mirebat"){ rx += (-dirz)*0.9; rz += (dirx)*0.9; }
        if(e.type==="skitter"){ const jig = Math.sin(now*0.016 + e.id)*0.9; rx += (-dirz)*jig; rz += (dirx)*jig; }
        const vx = (dirx*go + rx*0.9) * e.spd * moveScale + (e.kbX||0);
        const vz = (dirz*go + rz*0.9) * e.spd * moveScale + (e.kbZ||0);

        e.mesh.position.x += vx*dt;
        e.mesh.position.z += vz*dt;
        e.kbX *= 0.84;
        e.kbZ *= 0.84;
        e.mesh.lookAt(me.x, e.mesh.position.y, me.z);

        // keep enemies in world
        const rr2 = e.mesh.position.x*e.mesh.position.x + e.mesh.position.z*e.mesh.position.z;
        if(rr2 > (WORLD_RADIUS-12)*(WORLD_RADIUS-12)){
          const rr = Math.sqrt(rr2)||1;
          const k = (WORLD_RADIUS-12)/rr;
          e.mesh.position.x *= k;
          e.mesh.position.z *= k;
        }
      }

      // remove dead enemies (cleanup)
      for(let i=enemies.length-1;i>=0;i--){
        const e = enemies[i];
        if(e.hp>0) continue;
        world.remove(e.mesh);
        enemies.splice(i,1);
      }
    }

    // ============================================================
    // Projectiles update (player + enemy + fx)
    // ============================================================
    function tickProjectiles(dt){
  if(paused) return;

  for(let i=projectiles.length-1;i>=0;i--){
    const p = projectiles[i];
    p.life -= dt;

    if(p.kind==="explosion"){
      // expand & fade
      const s = 1 + (1 - (p.life/0.22))*3.2;
      p.mesh.scale.set(s,s,s);
      p.mesh.material.opacity = Math.max(0, p.life/0.22);
      if(p.life<=0){
        world.remove(p.mesh);
        projectiles.splice(i,1);
      }
      continue;
    }

    if(p.kind==="fxLine"){
      p.mesh.material.opacity *= 0.85;
      if(p.life<=0){
        world.remove(p.mesh);
        projectiles.splice(i,1);
      }
      continue;
    }

    if(p.kind==="enemyDeathFx"){
      p.x += p.vx*dt;
      p.y += p.vy*dt;
      p.z += p.vz*dt;
      p.vx *= 0.9;
      p.vz *= 0.9;
      p.vy -= 9.8*dt*0.55;
      p.mesh.position.set(p.x,p.y,p.z);
      p.mesh.material.opacity *= 0.9;
      p.mesh.scale.multiplyScalar(0.985);
      if(p.life<=0 || p.y<=heightAt(p.x,p.z,regionAt(p.x,p.z).id)+0.05){
        world.remove(p.mesh);
        projectiles.splice(i,1);
      }
      continue;
    }

    if(p.kind==="bossFx" || p.kind==="shockwave"){
      p.x += (p.vx||0)*dt;
      p.y += (p.vy||0)*dt;
      p.z += (p.vz||0)*dt;
      if(p.drag!=null){ p.vx *= p.drag; p.vz *= p.drag; }
      if(p.grav) p.vy -= p.grav*dt;
      p.mesh.position.set(p.x,p.y,p.z);
      if(!p.mesh.isSprite){
        const t = 1 - (p.life/Math.max(0.0001,p.maxLife||p.life||1));
        if(p.maxScale) p.mesh.scale.setScalar(0.72 + t*p.maxScale);
      }
      if(p.mesh.material) p.mesh.material.opacity *= (p.kind==="shockwave" ? 0.9 : 0.88);
      if(p.life<=0){
        releaseBossFx(p.fxType || (p.mesh.isSprite ? 'spark':'ring'), p.mesh);
        projectiles.splice(i,1);
      }
      continue;
    }

    if(p.kind==="hazard"){
      if(p.mesh.material) p.mesh.material.opacity *= 0.985;
      if(p.mesh.children?.length){
        p.spin = (p.spin||0) + dt;
        for(let ci=0;ci<p.mesh.children.length;ci++){
          const ch = p.mesh.children[ci];
          if(ch.material?.opacity!=null) ch.material.opacity *= 0.992;
          if(ch.isSprite) ch.position.y += Math.sin(p.spin*2.4 + ci)*dt*0.03;
          if(ch.geometry?.type==="RingGeometry") ch.rotation.z += dt*(ci===0?1.8:-1.4);
        }
      }
      const dd2 = (me.x-p.x)*(me.x-p.x)+(me.z-p.z)*(me.z-p.z);
      if(dd2 < (p.aoe||1.1)*(p.aoe||1.1)){
        takeDamage((p.dmg||1.5)*dt, "Hazard");
        if(p.slow>0){ me.slowT = Math.max(me.slowT, 0.45); me.slowMul = Math.min(me.slowMul, 1.0-p.slow); }
      }
      if(p.life<=0){
        world.remove(p.mesh);
        projectiles.splice(i,1);
      }
      continue;
    }

    if(p.kind==="goblinSpear"){
      p.mesh.material.opacity = 0.35 + 0.45*Math.sin((1.1-p.life)*13.0);
      p.mesh.scale.setScalar(0.8 + (1.1-p.life)*0.45);
      if(p.life<=0){
        explodeAt(p.x, p.y+0.22, p.z, p.aoe||1.8, p.dmg||12, "enemy");
        world.remove(p.mesh);
        projectiles.splice(i,1);
      }
      continue;
    }

    if(p.kind==="meteor"){
      p.x += p.vx*dt;
      p.y += p.vy*dt;
      p.z += p.vz*dt;
      p.mesh.position.set(p.x,p.y,p.z);
      p.mesh.rotation.x += dt*4.2;
      p.mesh.rotation.y += dt*3.1;
      if(p.y <= p.targetY){
        explodeAt(p.x, p.targetY, p.z, p.aoe, p.hitDmg, "player");
        world.remove(p.mesh);
        projectiles.splice(i,1);
      }else if(p.life<=0){
        world.remove(p.mesh);
        projectiles.splice(i,1);
      }
      continue;
    }

    if(p.kind==="firebolt"){
      p.x += p.vx*dt; p.y += p.vy*dt; p.z += p.vz*dt;
      p.mesh.position.set(p.x,p.y,p.z);
      // collision with enemy
      let hit = null;
      for(const e of enemies){
        if(e.hp<=0) continue;
        const ex=e.mesh.position.x, ez=e.mesh.position.z, ey=e.mesh.position.y+(e.flying?0.15:0.65);
        const d2 = (ex-p.x)*(ex-p.x)+(ez-p.z)*(ez-p.z)+(ey-p.y)*(ey-p.y);
        if(p.hitIds && p.hitIds.has(e.id)) continue;
        if(d2 < (p.rad+0.55)*(p.rad+0.55)){ hit = e; break; }
      }
      if(hit){
        explodeAt(p.x, p.y, p.z, p.aoe, p.hitDmg, "player");
        if((p.pierceLeft||0) > 0){
          p.pierceLeft--;
          p.dmg *= 0.86;
          continue;
        }
        world.remove(p.mesh);
        projectiles.splice(i,1);
        continue;
      }
      if(p.life<=0){
        world.remove(p.mesh);
        projectiles.splice(i,1);
      }
      continue;
    }

    // normal bolt
    p.x += p.vx*dt;
    p.y += p.vy*dt;
    p.z += p.vz*dt;
    p.mesh.position.set(p.x,p.y,p.z);

    // ‚úÖ added: spin / shimmer for grouped projectiles + glow fade
    // (works with enemy projectile groups from the upgraded spawnEnemyBolt)
    if(p.spin && p.mesh){
      p.mesh.rotation.y += dt * p.spin;
      p.mesh.rotation.x += dt * p.spin * 0.35;
    }
    if(p.mesh?.userData?._glow){
      // very gentle fade so it feels like a hot core
      p.mesh.userData._glow.material.opacity *= 0.995;
    }

    if(p.from==="player"){
      let hit = null;
      for(const e of enemies){
        if(e.hp<=0) continue;
        const ex=e.mesh.position.x, ez=e.mesh.position.z, ey=e.mesh.position.y+(e.flying?0.2:0.65);
        const d2 = (ex-p.x)*(ex-p.x)+(ez-p.z)*(ez-p.z)+(ey-p.y)*(ey-p.y);
        if(p.hitIds && p.hitIds.has(e.id)) continue;
        if(d2 < (p.rad+0.55)*(p.rad+0.55)){ hit = e; break; }
      }
      if(!hit && alienBoss && alienBoss.hp>0){
        const bx=alienBoss.mesh.position.x, bz=alienBoss.mesh.position.z, by=alienBoss.mesh.position.y;
        const d2 = (bx-p.x)*(bx-p.x)+(bz-p.z)*(bz-p.z)+(by-p.y)*(by-p.y);
        if(d2 < (p.rad+3.4)*(p.rad+3.4)) hit = alienBoss;
      }
      if(!hit && regionBoss && regionBoss.hp>0){
        const bx=regionBoss.mesh.position.x, bz=regionBoss.mesh.position.z, by=regionBoss.mesh.position.y;
        const d2 = (bx-p.x)*(bx-p.x)+(bz-p.z)*(bz-p.z)+(by-p.y)*(by-p.y);
        if(d2 < (p.rad+2.2)*(p.rad+2.2)) hit = regionBoss;
      }
      if(!hit && titanBoss && titanBoss.hp>0){
        const bx=titanBoss.mesh.position.x, bz=titanBoss.mesh.position.z, by=titanBoss.mesh.position.y;
        const d2 = (bx-p.x)*(bx-p.x)+(bz-p.z)*(bz-p.z)+(by-p.y)*(by-p.y);
        if(d2 < (p.rad+3.0)*(p.rad+3.0)) hit = titanBoss;
      }
      if(hit){
        if(hit===alienBoss){
          damageAlienBoss(p.dmg);
        }else if(hit===regionBoss){
          damageRegionBoss(p.dmg);
        }else if(hit===titanBoss){
          damageTitanBoss(p.dmg);
        }else{
          if(p.hitIds) p.hitIds.add(hit.id);
          dealDamageEnemy(hit, p.dmg);
        }

        if(p.explode){
          explodeAt(p.x,p.y,p.z, p.aoe||2.4, p.dmg*0.75, "player");
        }

        if(hit!==alienBoss && hit!==regionBoss && hit!==titanBoss){
          applyBoltEffects(hit, p);

          if(p.chainBounces>0){
            chainLightningFrom(hit, p);
          }
        }

        if((p.splinterCount||0) > 0){
          const candidates = enemies
            .filter(e=>e.hp>0 && e!==hit)
            .sort((a,b)=>dist2(a.mesh.position.x,a.mesh.position.z,p.x,p.z)-dist2(b.mesh.position.x,b.mesh.position.z,p.x,p.z))
            .slice(0, p.splinterCount);
          for(const e2 of candidates){
            spawnBolt(p.x,p.y,p.z, e2.mesh.position.x, e2.mesh.position.y+0.65, e2.mesh.position.z, {
              dmg:p.dmg, color:p.color, poison:p.poison*0.8, stun:p.stun*0.75, knockback:p.knockback*0.75
            }, true);
          }
        }

        world.remove(p.mesh);
        projectiles.splice(i,1);
        continue;
      }
    }else if(p.from==="enemy"){
      // hit player
      const d2 = (me.x-p.x)*(me.x-p.x) + (me.z-p.z)*(me.z-p.z) + (me.y-p.y)*(me.y-p.y);
      if(d2 < 1.05*1.05){
        takeDamage(p.dmg, "Bolt");
        if(p.slow>0){
          me.slowT = Math.max(me.slowT, 1.5 + p.slow*2.0);
          me.slowMul = Math.min(me.slowMul, 1.0-p.slow);
        }
        world.remove(p.mesh);
        projectiles.splice(i,1);
        continue;
      }
      const preg = regionAt(p.x,p.z);
      const py = heightAt(p.x,p.z,preg.id);
      if(p.y <= py+0.1){
        if(p.puddle>0){
          const puddle = new THREE.Mesh(
            new THREE.RingGeometry(0.45, 0.95, 22),
            new THREE.MeshBasicMaterial({
              color:p.color||0xfbbf24,
              transparent:true,
              opacity:0.75,
              side:THREE.DoubleSide
            })
          );
          puddle.rotation.x = -Math.PI/2;
          puddle.position.set(p.x, py+0.04, p.z);
          world.add(puddle);
          projectiles.push({
            mesh:puddle, x:p.x, y:py+0.04, z:p.z,
            life:p.puddle, from:"fx", kind:"hazard",
            dmg:p.dmg*0.22, aoe:1.1,
            slow:p.kind==="toxic" ? 0.18 : 0.0
          });
        }
        world.remove(p.mesh);
        projectiles.splice(i,1);
        continue;
      }
    }

    if(p.life<=0){
      world.remove(p.mesh);
      projectiles.splice(i,1);
    }
  }
}

    // ============================================================
    // Player auto fire tick
    // ============================================================
    function tickPlayerFire(dt){
      if(paused || !alive) { beamGroup.visible=false; return; }

      const w = WEAPONS[me.weapon] || WEAPONS["Arc Bolt"];
      const range = (w.range ?? 24) * me.rangeMul;

      // find target in cone
      const t = pickTarget(range);

      if(!t){
        beamGroup.visible = false;
        return;
      }

      if(w.kind==="beam"){
        // continuous damage
        const fromX = me.x, fromY = me.y, fromZ = me.z;
        const toX = t.mesh.position.x;
        const toY = t.mesh.position.y + 0.65;
        const toZ = t.mesh.position.z;

        updateBeamVisual(fromX, fromY, fromZ, toX, toY, toZ, w.color);

        const dps = (w.dps||14) * me.damageMul;
        dealDamageEnemy(t, dps*dt);

      }else{
        beamGroup.visible = false;

        me.fireCd -= dt;
        const fireEvery = 1 / (w.fireRate || 6);
        if(me.fireCd <= 0){
          me.fireCd = fireEvery;

          if(w.kind==="bolt"){
            const targets = [t];
            if((w.volleyTargets||1)>1){
              const near = enemies
                .filter(e=>e.hp>0 && e!==t)
                .sort((a,b)=>dist2(a.mesh.position.x,a.mesh.position.z,t.mesh.position.x,t.mesh.position.z)-dist2(b.mesh.position.x,b.mesh.position.z,t.mesh.position.x,t.mesh.position.z))
                .slice(0, (w.volleyTargets||1)-1);
              targets.push(...near);
            }
            for(const tar of targets){
              spawnBolt(me.x, me.y, me.z, tar.mesh.position.x, tar.mesh.position.y+0.65, tar.mesh.position.z, {
                dmg: (w.dmg||10),
                color: w.color,
                splinterCount: (typeof w.splinter==="number") ? w.splinter : (w.splinter ? 3 : 0),
                explode: !!w.explode,
                aoe: w.aoe,
                poison: w.poison||0,
                stun: w.stun||0,
                knockback: w.knockback||0,
                chainBounces: w.chainBounces||0,
                chainRange: w.chainRange||7.0,
                pierce: w.pierce||0,
                irradiate: w.irradiate||null
              });
            }
          }else if(w.kind==="wave"){
            spawnWave({ dmg:w.dmg||14, range:(w.range||16), color:w.color });
          }
        }
      }
    }

    // wave tick + damage pass
    function tickWaves(dt){
      if(paused) return;

      for(let i=waves.length-1;i>=0;i--){
        const wv = waves[i];
        wv.life += dt;
        const t = wv.life / wv.maxLife;
        const r = lerp(0.6, wv.maxR, smoothstep(t));
        wv.mesh.scale.set(r, r, r);
        wv.mesh.material.opacity = Math.max(0, 0.8*(1-t));

        // forward-ish arc feel: only damage enemies in front cone a bit
        const fwd = cameraForward(_v1);
        for(const e of enemies){
          if(e.hp<=0 || wv.hit.has(e.id)) continue;
          const ex=e.mesh.position.x, ez=e.mesh.position.z;
          const dx=ex-me.x, dz=ez-me.z;
          const d = Math.hypot(dx,dz);
          if(d > r || d < r-1.2) continue;

          const v = _v3.set(dx, 0, dz).normalize();
          const dot = fwd.x*v.x + fwd.z*v.z;
          if(dot < 0.25) continue; // must be in front-ish

          wv.hit.add(e.id);
          dealDamageEnemy(e, wv.dmg);
        }

        if(wv.life >= wv.maxLife){
          world.remove(wv.mesh);
          waves.splice(i,1);
        }
      }
    }

    function takeAlienBossLaser(){
      const laser = ALIEN_BOSS_VFX_POOL.lasers.pop();
      if(laser){
        laser.visible = true;
        laser.userData.flick = Math.random()*10;
        return laser;
      }
      const G = bossGeoCache();
      const grp = new THREE.Group();
      const core = new THREE.Mesh(G.alienLaserCore, new THREE.MeshBasicMaterial({ color:0xff4fe1, transparent:true, opacity:0.8, blending:THREE.AdditiveBlending, depthWrite:false }));
      core.rotation.z = Math.PI/2;
      const auraA = new THREE.Mesh(G.alienLaserAura, new THREE.MeshBasicMaterial({ map:FX_TEX.softGlow, color:0xff8ae9, transparent:true, opacity:0.35, side:THREE.DoubleSide, blending:THREE.AdditiveBlending, depthWrite:false }));
      const auraB = auraA.clone();
      auraA.rotation.y = Math.PI*0.5;
      auraB.rotation.y = 0;
      grp.add(core, auraA, auraB);
      grp.userData = { core, auraA, auraB, flick:Math.random()*10 };
      return grp;
    }

    function releaseAlienBossLaser(laser){
      if(!laser) return;
      laser.visible = false;
      if(laser.parent) laser.parent.remove(laser);
      ALIEN_BOSS_VFX_POOL.lasers.push(laser);
    }

    function takeAlienStarTelegraph(){
      const vfx = ALIEN_BOSS_VFX_POOL.starTelegraphs.pop();
      if(vfx){
        const { marker, glow, rock, comet } = vfx;
        marker.visible = glow.visible = rock.visible = comet.visible = true;
        marker.scale.setScalar(1);
        marker.material.opacity = marker.material.userData?.baseOpacity ?? marker.material.opacity;
        glow.material.opacity = glow.material.userData?.baseOpacity ?? glow.material.opacity;
        comet.material.opacity = comet.material.userData?.baseOpacity ?? comet.material.opacity;
        return vfx;
      }
      const G = bossGeoCache();
      const marker = new THREE.Mesh(
        G.alienStarMarker,
        new THREE.MeshBasicMaterial({ map:FX_TEX.runeRing, color:0xff8ae9, transparent:true, opacity:0.55, side:THREE.DoubleSide, depthWrite:false, blending:THREE.AdditiveBlending })
      );
      marker.rotation.x = -Math.PI/2;
      marker.material.userData = { baseOpacity: marker.material.opacity };

      const glow = new THREE.Sprite(new THREE.SpriteMaterial({
        map: FX_TEX.softGlow,
        color:0x9be7ff,
        transparent:true,
        opacity:0.28,
        depthWrite:false,
        blending:THREE.AdditiveBlending
      }));
      glow.scale.set(1.8,1.8,1);
      glow.material.userData = { baseOpacity: glow.material.opacity };

      const rock = new THREE.Mesh(
        G.alienStarRock,
        new THREE.MeshStandardMaterial({ color:0x67e8f9, emissive:0x22d3ee, emissiveIntensity:0.8, roughness:0.35, metalness:0.15 })
      );
      const comet = makeBossFxSprite(FX_TEX.softGlow, 0x67e8f9, 0.9, 0.46);
      comet.material.userData = { baseOpacity: comet.material.opacity };
      return { marker, glow, rock, comet };
    }

    function releaseAlienStarTelegraph(t){
      if(!t) return;
      if(t.marker?.parent) t.marker.parent.remove(t.marker);
      if(t.glow?.parent) t.glow.parent.remove(t.glow);
      if(t.rock?.parent) t.rock.parent.remove(t.rock);
      if(t.comet?.parent) t.comet.parent.remove(t.comet);
      t.marker.visible = t.glow.visible = t.rock.visible = t.comet.visible = false;
      ALIEN_BOSS_VFX_POOL.starTelegraphs.push({ marker:t.marker, glow:t.glow, rock:t.rock, comet:t.comet });
    }

    function spawnAlienStarfallTelegraph(){
      if(!alienBoss) return;
      const bx = alienBoss.mesh.position.x;
      const bz = alienBoss.mesh.position.z;
      const a = Math.random()*Math.PI*2;
      const r = Math.random()*22;
      const tx = bx + Math.cos(a)*r;
      const tz = bz + Math.sin(a)*r;
      const reg = regionAt(tx,tz);
      const gy = heightAt(tx,tz,reg.id);

      const tele = takeAlienStarTelegraph();
      tele.marker.position.set(tx, gy+0.06, tz);
      tele.glow.position.set(tx, gy+2.3, tz);
      tele.rock.position.set(tx, gy+24, tz);
      tele.comet.position.set(tx, gy+24.8, tz);

      world.add(tele.marker, tele.glow, tele.rock, tele.comet);
      alienBoss.starTelegraphs.push({ marker:tele.marker, glow:tele.glow, rock:tele.rock, comet:tele.comet, x:tx, z:tz, y:gy, t:0, delay:2.0, done:false });
    }

    function tickAlienBoss(dt){
      if(!alienBoss || paused || !alive) return;

      const b = alienBoss;
      b.stateT += dt;
      b.spin += dt;
      b.mesh.rotation.y += dt*0.32;
      b.mesh.userData.boostThrusters = b.state === "laser";
      b.mesh.userData.animBoss?.(dt, performance.now()*0.001, { phase:b.state, hpNorm:b.maxHp>0 ? b.hp/b.maxHp : 1, isAttacking:b.state==="laser" });

      const bx = b.mesh.position.x;
      const bz = b.mesh.position.z;
      const byGround = heightAt(bx,bz,"alien");
      const targetY = b.state==="laser" ? byGround + 3.2 : byGround + b.lift;
      b.mesh.position.y += (targetY - b.mesh.position.y) * Math.min(1, dt*1.6);

      if(b.state==="starfall"){
        b.starCd -= dt;
        if(b.starCd<=0){
          b.starCd = 0.16 + Math.random()*0.2;
          spawnAlienStarfallTelegraph();
        }
        if(b.stateT >= 10.0){
          b.state = "laser";
          b.stateT = 0;
          b.spin = 0;
          b.starCd = 0;
          for(let i=0;i<4;i++){
            const grp = takeAlienBossLaser();
            world.add(grp);
            b.lasers.push(grp);
          }
        }
      }else if(b.state==="laser"){
        const centerY = b.mesh.position.y - 0.65;
        const cx = b.mesh.position.x;
        const cz = b.mesh.position.z;
        const spin = b.spin * 0.26;
        for(let i=0;i<b.lasers.length;i++){
          const beam = b.lasers[i];
          const ang = spin + i*(Math.PI*0.5);
          beam.position.set(cx, centerY, cz);
          beam.rotation.y = ang;
          const u = beam.userData;
          if(u?.core){
            u.core.material.opacity = 0.72 + 0.18*Math.sin(performance.now()*0.025 + u.flick + i);
            u.auraA.rotation.z += dt*3.2;
            u.auraB.rotation.z -= dt*2.8;
            u.auraA.material.opacity = 0.26 + 0.16*Math.sin(performance.now()*0.018 + i);
            u.auraB.material.opacity = 0.22 + 0.14*Math.cos(performance.now()*0.022 + i*0.9);
          }

          const vx = Math.cos(ang), vz = Math.sin(ang);
          const toPx = me.x-cx, toPz = me.z-cz;
          const proj = Math.abs(toPx*vz - toPz*vx);
          const along = toPx*vx + toPz*vz;
          if(Math.abs(along)<=31.0 && proj<=0.9){
            takeDamage(b.laserDps*dt, "Alien Laser");
          }
        }
        if(b.stateT >= 10.0){
          for(const l of b.lasers) releaseAlienBossLaser(l);
          b.lasers.length = 0;
          b.state = "starfall";
          b.stateT = 0;
          b.starCd = 0.25;
        }
      }

      for(let i=b.starTelegraphs.length-1;i>=0;i--){
        const t = b.starTelegraphs[i];
        t.t += dt;
        const p = Math.min(1, t.t/t.delay);
        t.marker.material.opacity = 0.35 + 0.5*p;
        t.marker.scale.setScalar(1 + p*0.35);
        t.glow.material.opacity = 0.2 + 0.3*Math.sin(p*Math.PI);
        t.rock.position.y = (t.y+24) - 24*p;
        t.rock.rotation.x += dt*4.0;
        t.rock.rotation.y += dt*5.2;
        if(t.comet){ t.comet.position.set(t.x, t.rock.position.y+0.65, t.z); t.comet.material.opacity = 0.28 + (1-p)*0.34; }
        if(t.t >= t.delay && !t.done){
          t.done = true;
          const d2 = (me.x-t.x)*(me.x-t.x)+(me.z-t.z)*(me.z-t.z);
          if(d2 <= 1.45*1.45){
            takeDamage(18 * b.projectileDmgScale, "Starfall");
          }
          explodeAt(t.x, t.y+0.3, t.z, 2.3, 14 * b.projectileDmgScale, "enemy");
          spawnBossFxRing(t.x, t.y+0.09, t.z, 0x9be7ff, 0.55, 4.2, "shockwave");
          spawnBossFxSparkBurst(t.x, t.y+0.2, t.z, 0xff8ae9, 10, 6.2, 0.7);
          const scorch = takeBossFx('glow', ()=>makeBossFxSprite(FX_TEX.softGlow,0x312e81,1.3,0.35));
          scorch.material.color.setHex(0x312e81);
          scorch.position.set(t.x,t.y+0.04,t.z);
          scorch.material.rotation = Math.random()*Math.PI;
          world.add(scorch);
          projectiles.push({mesh:scorch,kind:'bossFx',fxType:'glow',x:t.x,y:t.y+0.04,z:t.z,vx:0,vy:0,vz:0,life:0.85,maxLife:0.85});
          releaseAlienStarTelegraph(t);
          b.starTelegraphs.splice(i,1);
        }
      }
    }

    function tickRegionBoss(dt){
      if(!regionBoss || paused || !alive) return;
      const b = regionBoss;
      b.t += dt;
      const bx=b.mesh.position.x, bz=b.mesh.position.z;
      const dx=me.x-bx, dz=me.z-bz;
      const dd=Math.hypot(dx,dz)||1;
      const dirx=dx/dd, dirz=dz/dd;
      b.mesh.position.x += dirx * b.speed * dt;
      b.mesh.position.z += dirz * b.speed * dt;
      b.mesh.position.y = heightAt(b.mesh.position.x,b.mesh.position.z,b.regionId)+1.45;
      b.mesh.rotation.y = Math.atan2(dirx, dirz);
      b.mesh.userData.animBoss?.(dt, performance.now()*0.001, { regionId:b.regionId, isAttacking:b.cdA<=0.15 || b.cdB<=0.15 || b.cdC<=0.15, attackIntensity:Math.max(0, Math.min(1, 1 - Math.min(b.cdA, b.cdB, b.cdC))) });

      const outer = dangerBandAt(b.mesh.position.x,b.mesh.position.z).id === "outer";

      b.cdA -= dt; b.cdB -= dt; b.cdC -= dt;
      if(b.regionId==="desert"){
        if(b.cdA<=0){
          b.cdA = 1.0;
          const tx = me.x + me.vx*0.35, tz = me.z + me.vz*0.35;
          const whirl = new THREE.Group();
          const baseRing = new THREE.Mesh(new THREE.RingGeometry(0.3,1.0,18), new THREE.MeshBasicMaterial({map:FX_TEX.runeRing,color:0xf59e0b,transparent:true,opacity:0.34,side:THREE.DoubleSide,blending:THREE.AdditiveBlending,depthWrite:false}));
          baseRing.rotation.x=-Math.PI/2;
          const dustA = makeBossFxSprite(FX_TEX.softGlow, 0xfbbf24, 1.2, 0.22); dustA.position.y=0.18;
          const dustB = makeBossFxSprite(FX_TEX.spark, 0xfde68a, 0.9, 0.16); dustB.position.y=0.26;
          whirl.add(baseRing,dustA,dustB);
          whirl.position.set(tx,heightAt(tx,tz,"desert")+0.2,tz);
          world.add(whirl);
          projectiles.push({ x:tx, y:whirl.position.y, z:tz, vx:0,vy:0,vz:0, life:6+(outer?2:0), rad:1.35, dmg:4.5, from:"enemy", kind:"hazard", mesh:whirl, spin:0 });
        }
        if(b.cdB<=0){
          b.cdB = 3.0;
          const lanes = outer ? 4 : 2 + (Math.random()*3|0);
          for(let i=0;i<lanes;i++){
            const ang = Math.atan2(me.z-b.mesh.position.z, me.x-b.mesh.position.x) + (i-(lanes-1)/2)*(outer?0.55:0.35);
            const tx = b.mesh.position.x + Math.cos(ang)*6.5;
            const tz = b.mesh.position.z + Math.sin(ang)*6.5;
            const tele = makeMarker(0xfbbf24); tele.position.set(tx,heightAt(tx,tz,"desert")+0.06,tz); world.add(tele);
            b.telegraphs.push({mesh:tele,t:0,delay:0.8,do:()=>{ explodeAt(tx,heightAt(tx,tz,"desert")+0.2,tz,2.3,12,"enemy"); }});
          }
        }
        if(b.cdC<=0){ b.cdC=12.0; b.mesh.position.x -= dirx*9; b.mesh.position.z -= dirz*9; }
      }else if(b.regionId==="forest"){
        if(b.cdA<=0){ b.cdA=0.7; const tx=me.x+(Math.random()-0.5)*4.8, tz=me.z+(Math.random()-0.5)*4.8; const hy=heightAt(tx,tz,"forest")+0.2; const cloud=new THREE.Group(); const fog = new THREE.Mesh(bossGeoCache().forestFogRing, new THREE.MeshBasicMaterial({map:FX_TEX.softGlow,color:0x65a30d,transparent:true,opacity:0.32,side:THREE.DoubleSide,depthWrite:false,blending:THREE.AdditiveBlending})); fog.rotation.x=-Math.PI/2; cloud.add(fog); for(let j=0;j<4;j++){ const mote=makeBossFxSprite(FX_TEX.spark,0x86efac,0.28,0.45); mote.position.set((Math.random()-0.5)*0.8,0.2+Math.random()*0.35,(Math.random()-0.5)*0.8); cloud.add(mote);} cloud.position.set(tx,hy,tz); world.add(cloud); projectiles.push({mesh:cloud,x:tx,y:hy,z:tz,vx:0,vy:0,vz:0,life:outer?6:4.8,rad:1.2,dmg:3.8,from:"enemy",kind:"hazard"}); }
        if(b.cdB<=0){ b.cdB=7.0; const cx=b.mesh.position.x, cz=b.mesh.position.z; const pulse=makeTeleCircle(0x22c55e); pulse.position.set(cx,heightAt(cx,cz,"forest")+0.08,cz); world.add(pulse); b.burst.push({mesh:pulse,t:0,max:0.9,rad:7.2,dmg:13,slow:true}); }
        if(b.cdC<=0){ b.cdC=10.0; for(let i=0;i<4+(Math.random()*2|0);i++){ const tx=me.x + me.vx*(0.7+i*0.22) + (Math.random()-0.5)*2.2; const tz=me.z + me.vz*(0.7+i*0.22) + (Math.random()-0.5)*2.2; const mk=makeMarker(0x65a30d); mk.position.set(tx,heightAt(tx,tz,"forest")+0.05,tz); world.add(mk); b.telegraphs.push({mesh:mk,t:0,delay:0.9,do:()=>explodeAt(tx,heightAt(tx,tz,"forest")+0.1,tz,1.8,10,"enemy")}); } }
      }else if(b.regionId==="snow"){
        if(b.cdA<=0){ b.cdA=1.4; const ang=Math.random()*Math.PI*2; const x0=b.mesh.position.x+Math.cos(ang)*12, z0=b.mesh.position.z+Math.sin(ang)*12; const rib=new THREE.Mesh(bossGeoCache().snowRibbonPlane, new THREE.MeshBasicMaterial({color:0x93c5fd,transparent:true,opacity:0.28,side:THREE.DoubleSide,blending:THREE.AdditiveBlending,depthWrite:false})); rib.position.set(x0,heightAt(x0,z0,"snow")+1.0,z0); rib.rotation.y=ang+Math.PI/2; world.add(rib); b.ribbons.push({mesh:rib,ang,speed:outer?1.6:1.1,life:6,trail:0}); }
        if(b.cdB<=0){ b.cdB=6.0; const safe=(Math.random()*3)|0; for(let i=0;i<3;i++){ const a=i*Math.PI*2/3 + Math.random()*0.35; const tx=me.x+Math.cos(a)*4.8, tz=me.z+Math.sin(a)*4.8; const mk=makeTeleCircle(i===safe?0x22c55e:0x60a5fa); mk.position.set(tx,heightAt(tx,tz,"snow")+0.05,tz); mk.scale.set(i===safe?(outer?0.42:0.6):0.7,1,i===safe?(outer?0.42:0.6):0.7); world.add(mk); b.sigils.push({mesh:mk,t:0,delay:1.2,safe:i===safe,x:tx,z:tz}); } }
        if(b.cdC<=0){ b.cdC=9.0; b.mesh.position.x = me.x + (Math.random()-0.5)*9; b.mesh.position.z = me.z + (Math.random()-0.5)*9; explodeAt(b.mesh.position.x,heightAt(b.mesh.position.x,b.mesh.position.z,"snow")+0.2,b.mesh.position.z,2.4,12,"enemy"); }
      }else if(b.regionId==="hell"){
        if(b.cdA<=0){ b.cdA=2.5; const tx=me.x+me.vx*0.5, tz=me.z+me.vz*0.5; const mark=makeMarker(0xff3b1a); mark.position.set(tx,heightAt(tx,tz,"hell")+0.05,tz); world.add(mark); b.telegraphs.push({mesh:mark,t:0,delay:0.5,do:()=>{ const dx=me.x-b.mesh.position.x, dz=me.z-b.mesh.position.z, d=Math.hypot(dx,dz)||1; b.mesh.position.x += dx/d*7.5; b.mesh.position.z += dz/d*7.5; if((me.x-b.mesh.position.x)**2+(me.z-b.mesh.position.z)**2<2.5*2.5) takeDamage(22,"Hammer Chase"); if(outer) explodeAt(b.mesh.position.x,heightAt(b.mesh.position.x,b.mesh.position.z,"hell")+0.1,b.mesh.position.z,2.6,10,"enemy"); }}); }
        if(b.cdB<=0){ b.cdB=6.0; for(let i=0;i<3;i++){ const a=i*Math.PI*2/3; const tx=me.x+Math.cos(a)*4.8, tz=me.z+Math.sin(a)*4.8; const y=heightAt(tx,tz,"hell")+0.22; const an=new THREE.Group(); const ring=makeTeleCircle(0xf97316); an.add(ring); const ember=makeBossFxSprite(FX_TEX.spark,0xff7a1a,0.62,0.4); ember.position.y=0.25; an.add(ember); an.position.set(tx,y,tz); world.add(an); projectiles.push({mesh:an,x:tx,y,z:tz,vx:0,vy:0,vz:0,life:outer?9:7,rad:1.55,dmg:4.4,from:"enemy",kind:"hazard"}); } }
        if(b.cdC<=0){ b.cdC=4.2; const tx=me.x-me.vx*0.35, tz=me.z-me.vz*0.35; const mk=makeMarker(0xff8a65); mk.position.set(tx,heightAt(tx,tz,"hell")+0.05,tz); world.add(mk); b.telegraphs.push({mesh:mk,t:0,delay:0.5,do:()=>explodeAt(tx,heightAt(tx,tz,"hell")+0.12,tz,2.2,11,"enemy")}); }
      }

      for(let i=b.telegraphs.length-1;i>=0;i--){ const t=b.telegraphs[i]; t.t += dt; if(t.mesh.material) t.mesh.material.opacity = 0.3 + 0.55*Math.min(1,t.t/t.delay); if(t.t>=t.delay){ t.do?.(); world.remove(t.mesh); b.telegraphs.splice(i,1);} }
      for(let i=b.ribbons.length-1;i>=0;i--){ const r=b.ribbons[i]; r.life -= dt; r.mesh.position.x += Math.cos(r.ang+Math.PI/2)*r.speed; r.mesh.position.z += Math.sin(r.ang+Math.PI/2)*r.speed; r.trail=(r.trail||0)-dt; if(r.trail<=0){ r.trail=0.08; const tr=takeBossFx('spark', ()=>makeBossFxSprite(FX_TEX.softGlow,0x93c5fd,0.35,0.38)); tr.material.color.setHex(0x93c5fd); tr.position.set(r.mesh.position.x, r.mesh.position.y+0.35, r.mesh.position.z); world.add(tr); projectiles.push({mesh:tr,kind:'bossFx',fxType:'spark',x:tr.position.x,y:tr.position.y,z:tr.position.z,vx:(Math.random()-0.5)*0.5,vy:0.15,vz:(Math.random()-0.5)*0.5,life:0.45,maxLife:0.45}); } if((me.x-r.mesh.position.x)**2 + (me.z-r.mesh.position.z)**2 < 2.2*2.2){ me.slowT=Math.max(me.slowT,1.6); me.slowMul=Math.min(me.slowMul,0.58); takeDamage(6*dt,"Aurora Ribbon"); } if(r.life<=0){ world.remove(r.mesh); b.ribbons.splice(i,1);} }
      for(let i=b.sigils.length-1;i>=0;i--){ const r=b.sigils[i]; r.t+=dt; if(r.t>=r.delay){ if(!r.safe && (me.x-r.x)**2 + (me.z-r.z)**2 < 2.3*2.3) takeDamage(17,"Sigil Collapse"); if(!r.safe) explodeAt(r.x,heightAt(r.x,r.z,b.regionId)+0.2,r.z,2.2,12,"enemy"); world.remove(r.mesh); b.sigils.splice(i,1);} }
      for(let i=b.burst.length-1;i>=0;i--){ const r=b.burst[i]; r.t+=dt; const t=r.t/r.max; r.mesh.scale.setScalar(1+t*5.4); if(t<1 && Math.abs(Math.hypot(me.x-b.mesh.position.x,me.z-b.mesh.position.z)-t*r.rad)<0.55){ takeDamage(r.dmg*dt*2.2,"Bloom Pulse"); if(r.slow) me.turnSlowT=Math.max(me.turnSlowT,1.2); } if(r.t>=r.max){ world.remove(r.mesh); b.burst.splice(i,1);} }
    }

    function tickTitanBoss(dt){
      if(!titanBoss || paused || !alive) return;
      const b=titanBoss;
      b.coreCd -= dt; b.quakeCd -= dt; b.starCd -= dt; b.lastSpecial -= dt;
      const bx=b.mesh.position.x, bz=b.mesh.position.z;
      const dx=me.x-bx, dz=me.z-bz; const d=Math.hypot(dx,dz)||1;
      b.mesh.rotation.y = Math.atan2(dx,dz);
      b.mesh.userData.hpNorm = b.maxHp>0 ? b.hp/b.maxHp : 1;
      b.mesh.userData.specialPulse = Math.max(0, (b.lastSpecial||0)/2.0);
      b.mesh.userData.animBoss?.(dt, performance.now()*0.001, { phase:b.quakeTele>0 ? "quake" : (b.starPlan ? "starfall" : "core"), specialPulse:b.mesh.userData.specialPulse });
      if(d>9){ b.mesh.position.x += dx/d*2.1*dt; b.mesh.position.z += dz/d*2.1*dt; }
      b.mesh.position.y = heightAt(b.mesh.position.x,b.mesh.position.z,regionAt(b.mesh.position.x,b.mesh.position.z).id)+4.6;

      if(b.coreCd<=0){
        b.coreCd = 0.9 + Math.random()*0.3;
        const shots = ((Math.random()*4|0)===0) ? 2 : 1;
        for(let i=0;i<shots;i++){
          const tx = me.x + me.vx*(0.25+i*0.12), tz = me.z + me.vz*(0.25+i*0.12);
          spawnEnemyBolt({mesh:b.mesh,flying:true,dmg:16,type:"drone"}, tx, me.y, tz, { color:0xa78bfa, speed:30, rad:0.4, life:1.6 });
        }
      }

      const canSpecial = b.lastSpecial<=0;
      if(canSpecial && b.quakeCd<=0){
        b.quakeCd = 7 + Math.random()*3;
        b.lastSpecial = 2.0;
        const qy=heightAt(b.mesh.position.x,b.mesh.position.z,regionAt(b.mesh.position.x,b.mesh.position.z).id)+0.1; const ring=new THREE.Group(); const rune = new THREE.Mesh(bossGeoCache().titanQuakeRuneRing, new THREE.MeshBasicMaterial({map:FX_TEX.runeRing,color:0xc4b5fd,transparent:true,opacity:0.65,side:THREE.DoubleSide,depthWrite:false,blending:THREE.AdditiveBlending})); rune.rotation.x=-Math.PI/2; const crack = new THREE.Mesh(bossGeoCache().titanQuakeCrackPlane, new THREE.MeshBasicMaterial({map:FX_TEX.crack,color:0xa78bfa,transparent:true,opacity:0.48,side:THREE.DoubleSide,depthWrite:false,blending:THREE.AdditiveBlending})); crack.rotation.x=-Math.PI/2; crack.rotation.z=Math.random()*Math.PI; ring.add(rune,crack); ring.position.set(b.mesh.position.x,qy,b.mesh.position.z); world.add(ring);
        b.quakeTele = 0.85;
        b.burst.push({mesh:ring,t:0,max:0.85,rad:15,dmg:22,thin:true,double: b.hp <= b.maxHp*0.5,sparks:0});
      }else if(canSpecial && b.starCd<=0){
        b.starCd = 12 + Math.random()*4;
        b.lastSpecial = 2.0;
        const steps = 6 + (Math.random()*3|0);
        const dir = Math.random()<0.5 ? 1 : -1;
        b.starPlan = { t:0, idx:0, steps, dir, baseX:me.x, baseZ:me.z };
      }

      if(b.starPlan){
        b.starPlan.t += dt;
        if(b.starPlan.idx < b.starPlan.steps && b.starPlan.t >= b.starPlan.idx*0.22){
          const i=b.starPlan.idx++;
          const a = i*0.72*b.starPlan.dir;
          const r = 2.4 + i*1.25;
          const tx = b.starPlan.baseX + Math.cos(a)*r;
          const tz = b.starPlan.baseZ + Math.sin(a)*r;
          const mk=makeMarker(0xe9d5ff); mk.position.set(tx,heightAt(tx,tz,regionAt(tx,tz).id)+0.05,tz); world.add(mk);
          b.telegraphs.push({mesh:mk,t:0,delay:1.1+Math.random()*0.3,do:()=>{ const hy=heightAt(tx,tz,regionAt(tx,tz).id)+0.2; explodeAt(tx,hy,tz,2.1,14,"enemy"); spawnBossFxRing(tx,hy-0.08,tz,0xc084fc,0.65,4.8,"shockwave"); spawnBossFxSparkBurst(tx,hy+0.15,tz,0xe9d5ff,8,5.8,0.62); const hz=makeTeleCircle(0xc084fc); hz.position.set(tx,heightAt(tx,tz,regionAt(tx,tz).id)+0.08,tz); world.add(hz); projectiles.push({mesh:hz,x:tx,y:hz.position.y,z:tz,vx:0,vy:0,vz:0,life:1.2,rad:1.35,dmg:3.5,from:"enemy",kind:"hazard"}); const decal = new THREE.Mesh(bossGeoCache().titanStarCrackPlane, new THREE.MeshBasicMaterial({map:FX_TEX.crack,color:0xa78bfa,transparent:true,opacity:0.42,side:THREE.DoubleSide,depthWrite:false,blending:THREE.AdditiveBlending})); decal.rotation.x=-Math.PI/2; decal.rotation.z=Math.random()*Math.PI; decal.position.set(tx,hy-0.1,tz); world.add(decal); projectiles.push({mesh:decal,kind:"bossFx",fxType:"ring",x:tx,y:hy-0.1,z:tz,vx:0,vy:0,vz:0,life:1.4,maxLife:1.4}); }});
        }
        if(b.starPlan.idx>=b.starPlan.steps && b.starPlan.t > b.starPlan.steps*0.22 + 0.15){
          const tx = me.x + me.vx*0.65, tz = me.z + me.vz*0.65;
          const mk=makeMarker(0xf0abfc); mk.position.set(tx,heightAt(tx,tz,regionAt(tx,tz).id)+0.05,tz); world.add(mk);
          b.telegraphs.push({mesh:mk,t:0,delay:1.0,do:()=>explodeAt(tx,heightAt(tx,tz,regionAt(tx,tz).id)+0.2,tz,2.4,17,"enemy")});
          b.starPlan = null;
        }
      }

      for(let i=b.telegraphs.length-1;i>=0;i--){ const t=b.telegraphs[i]; t.t+=dt; if(t.mesh.material) t.mesh.material.opacity = 0.3 + 0.6*Math.min(1,t.t/t.delay); if(t.t>=t.delay){ t.do?.(); world.remove(t.mesh); b.telegraphs.splice(i,1);} }
      for(let i=b.burst.length-1;i>=0;i--){ const r=b.burst[i]; r.t+=dt; const t=r.t/r.max; const rr=0.6 + t*r.rad; r.mesh.scale.setScalar(rr); r.sparks=(r.sparks||0)-dt; if(r.sparks<=0){ r.sparks=0.09; const a=Math.random()*Math.PI*2; const sx=b.mesh.position.x+Math.cos(a)*rr, sz=b.mesh.position.z+Math.sin(a)*rr; spawnBossFxSparkBurst(sx, heightAt(sx,sz,regionAt(sx,sz).id)+0.2, sz, 0xe9d5ff, 2, 2.4, 0.35);} if(Math.abs(Math.hypot(me.x-b.mesh.position.x, me.z-b.mesh.position.z)-rr)<0.85){ takeDamage(r.dmg*dt*2.4,"Stomp Quake"); } if(r.t>=r.max){ if(r.double){ r.double=false; r.t=0; r.max=0.55; r.rad=18; continue; } world.remove(r.mesh); b.burst.splice(i,1);} }
    }

    // ============================================================
    // HUD update
    // ============================================================
    function fmtMats(){
      const m = me.mats;
      // compact quick view
      return `Fe:${m.iron} Hi:${m.hide} Es:${m.essence} Cr:${m.crystal} Em:${m.ember} üî±:${sigilsCollected}/5`;
    }

    let _hudAcc = 0;
let _lastRegId = "";
let _lastBandId = "";

function tickHUD(dt){
  _hudAcc += dt;
  if(_hudAcc < 0.10) return; // 10 Hz
  _hudAcc = 0;

  hpText.textContent = `${Math.ceil(me.hp)} / ${me.maxHp} (+${me.hpRegen.toFixed(1)}/s)`;
  lvlText.textContent = `Lv ${me.level} ‚Ä¢ XP ${Math.floor(me.xp)}/${me.nextXp}`;
  weaponText.textContent = me.weapon;
  matsText.textContent = fmtMats();

  const reg = regionAt(me.x, me.z);
  const band = dangerBandAt(me.x, me.z);
  regionText.textContent = `${reg.name} [${band.label}]`;
  showRegionBanner(reg, band);

  // only change fog/clear color when region actually changes
  if(reg.id !== _lastRegId){
    _lastRegId = reg.id;
    scene.fog.color.setHex(reg.fog);
    renderer.setClearColor(reg.sky, 1);
  }

  const nf = nearestForge();
  const canUseForge = !!(nf && nf.d <= 3.2 && phase==="play" && uiMode==="none");
  mobileInteract.style.display = (mobile.enabled && canUseForge) ? "block" : "none";
}
    // ============================================================
    // Spawn pacing
    // ============================================================
    let travelMeter = 0;
    let spawnCooldown = 4.8;

    function tickSpawning(dt){
      if(paused || !alive) return;

      const reg = regionAt(me.x, me.z);
      if(reg.id !== "alien"){
        alienRegionClock = 0;
      }else if(!alienBoss){
        alienRegionClock += dt;
        if(alienRegionClock >= alienBossSpawnAt){
          spawnAlienBoss();
        }
      }

      for(const k of Object.keys(regionBossClock)){
        if(reg.id===k && !regionBoss && !bossCycle[k]){
          regionBossClock[k] += dt;
          if(regionBossClock[k] >= regionBossSpawnAt[k]) spawnRegionBoss(k);
        }
      }
      if(!titanBoss && sigilsCollected>=5) spawnTitanBoss();

      spawnCooldown -= dt;

      // attempt spawn at a gentle cadence
      // (travelMeter gates actual spawns so it doesn't feel constant)
      if(spawnCooldown <= 0){
        spawnPack();
      }
    }

    // ============================================================
    // Forge proximity hint
    // ============================================================
    function tickForgeHint(){
      if(phase!=="play") return;
      if(uiMode!=="none") return;

      const nf = nearestForge();
      if(!nf) return;

      if(nf.d <= 3.2){
        showHintOnce("‚öíÔ∏è Forge nearby ‚Äî press E (or tap Use Forge) to craft. Game pauses inside.");
      }
    }
    const _hintSeen = new Set();
    function showHintOnce(msg){
      if(_hintSeen.has(msg)) return;
      _hintSeen.add(msg);
      showToast(msg, 2600);
    }

    // ============================================================
    // Autosave timer
    // ============================================================
    let saveT = 0;

    // ============================================================
    // Boot / phase
    // ============================================================
    let phase = "menu"; // menu | play
    let started = false;

    // lock button (desktop)
    lockBtn.addEventListener("click", ()=>requestLock());
    renderer.domElement.addEventListener("click", ()=>{
      if(phase==="play" && !pointerLocked && uiMode==="none"){
        lockBtn.style.display = "inline-block";
      }
    });

    // ============================================================
    // Resize
    // ============================================================
    addEventListener("resize", ()=>{
      renderer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
    });

    // ============================================================
    // Main loop
    // ============================================================
    const _v1 = new THREE.Vector3();
    const _v2 = new THREE.Vector3();
    const _v3 = new THREE.Vector3();

    let last = performance.now();
    function loop(now){
      const dt = Math.min(0.033, (now-last)/1000);
      last = now;

      if(phase==="play"){
        // world systems
        tickChunks();
        tickForges(now);

        // movement + camera
        tickMove(dt);

        // gameplay systems
        tickSpawning(dt);
        tickAbilities(dt);
        tickPlayerRegen(dt, now*0.001);
        tickEnemies(dt, now);
        tickAlienBoss(dt);
        tickRegionBoss(dt);
        tickTitanBoss(dt);
        tickPlayerFire(dt);
        tickWaves(dt);
        tickProjectiles(dt);
        pickupDrops(dt);
        tickForgeHint();
        tickHUD(dt);
        tickFloatingTexts(dt);

        // autosave
        if(!paused && alive){
          saveT -= dt;
          if(saveT <= 0){
            saveT = 18;
            saveGame(true);
          }
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }

    // ============================================================
    // Start
    // ============================================================
    function startPlay(){
      if(started) return;
      started = true;

      // attempt load for button visibility
      const hasSave = !!localStorage.getItem(SAVE_KEY);
      resumeBtn.style.display = hasSave ? "inline-block" : "none";

      // prime world
      genForges();
      tickChunks();
      tickHUD(0.16); // force an initial HUD paint (any number >= 0.10 works with your throttle)

      requestAnimationFrame(loop);
    }

    // Menu -> play transition
    function enterPlay(){
      phase="play";
      centerMsg.style.display="none";
      lockBtn.style.display = (!pointerLocked) ? "inline-block" : "none";
      saveT = 8;
    }

    // start loop immediately, keep menu up
    startPlay();

    // Clicking canvas in play locks pointer; menu already visible, so show lock button only once play begins
    // New/Resume buttons already call enterPlay via handlers above
    // We'll call enterPlay when those buttons run.

    // When user chooses New/Resume from the menu, handlers already set phase, hide center, etc.
    // But ensure enterPlay is triggered:
    const _wrapEnter = (fn)=>()=>{ fn(); enterPlay(); };
    newBtn.onclick = _wrapEnter(()=>{ resetRun(true); });
    resumeBtn.onclick = _wrapEnter(()=>{ const ok = loadGame(); if(!ok) resetRun(true); });
    loadBtn.onclick = _wrapEnter(()=>{ const ok = loadGame(); if(!ok) showToast("No save found."); });

    // If user clicks "Click to Play" on desktop during play
    lockBtn.addEventListener("click", ()=>{
      if(phase==="play" && uiMode==="none") requestLock();
    });

    // First run: don‚Äôt auto-start a run until user chooses; but generate seed/forges so visuals exist immediately.
    // Give a gentle default:
    worldSeed = (Math.random()*1e9)|0;
    genForges();

  </script>
</body>
</html>
