<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>üó∫Ô∏è CircleRogue ‚Äî First-Person Forge Run</title>
  <style>
    html, body{
      margin:0; height:100%; background:#000; overflow:hidden;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
    }

    canvas{ display:block; }

    #ui{
      position:fixed; inset:0; pointer-events:none; color:#fff;
    }
    .topbar{
      position:absolute; left:10px; right:10px; top:10px;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      flex-wrap:wrap; pointer-events:none;
    }
    .leftPills, .rightPills{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .pill{
      pointer-events:none;
      display:inline-flex; gap:8px; align-items:center;
      padding:8px 10px; border-radius:999px;
      background:rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.16);
      backdrop-filter:blur(8px);
      font-weight:900; font-size:13px;
      box-shadow:0 10px 22px rgba(0,0,0,.25);
      white-space:nowrap;
    }
    .pill b{ font-weight:1000; }

    #toast{
      position:absolute; left:50%; top:70px; transform:translateX(-50%);
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.18);
      border-radius:999px;
      padding:8px 12px;
      font-weight:900;
      pointer-events:none;
      backdrop-filter:blur(10px);
      opacity:0; transition:opacity .18s;
      max-width:min(820px,92vw);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }

    .hint{
      position:absolute; left:10px; right:10px; bottom:10px;
      background:rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.16);
      border-radius:14px;
      padding:10px 12px;
      pointer-events:none;
      backdrop-filter:blur(8px);
      max-width:820px;
    }
    .muted{ opacity:.78; font-weight:700; }

    #centerMsg{
      position:absolute; left:50%; top:50%;
      transform:translate(-50%,-50%);
      background:rgba(0,0,0,.58);
      border:1px solid rgba(255,255,255,.18);
      border-radius:16px;
      padding:14px 16px;
      font-weight:900;
      text-align:center;
      pointer-events:auto;
      backdrop-filter:blur(10px);
      min-width:min(560px,92vw);
      box-shadow:0 18px 60px rgba(0,0,0,.45);
    }
    #centerMsg .row{
      display:flex; gap:10px; justify-content:center; flex-wrap:wrap;
      margin-top:10px;
    }
    #centerMsg button{
      cursor:pointer; border:none;
      padding:10px 12px; border-radius:12px;
      font-weight:1000;
      background:#22c55e; color:#07110a;
      box-shadow:0 10px 22px rgba(0,0,0,.35);
    }
    #centerMsg button.alt{
      background:rgba(255,255,255,.12); color:#fff;
      border:1px solid rgba(255,255,255,.22);
    }

    #overlayVignette{
      position:absolute; inset:0;
      background:radial-gradient(circle at 50% 50%,
        rgba(0,0,0,0) 0%,
        rgba(0,0,0,.55) 60%,
        rgba(0,0,0,.82) 100%);
      pointer-events:none;
      opacity:.55;
    }

    #overlayDead{
      position:absolute; inset:0;
      background:radial-gradient(circle at 50% 35%,
        rgba(0,0,0,.15) 0%,
        rgba(0,0,0,.92) 70%);
      opacity:0; pointer-events:none; transition:opacity .12s linear;
    }

    #crosshair{
      position:absolute; left:50%; top:50%;
      width:14px; height:14px; transform:translate(-50%,-50%);
      pointer-events:none;
      filter:drop-shadow(0 2px 6px rgba(0,0,0,.6));
    }
    #crosshair:before, #crosshair:after{
      content:""; position:absolute; left:50%; top:50%;
      transform:translate(-50%,-50%);
      background:rgba(255,255,255,.92);
      border-radius:2px;
    }
    #crosshair:before{ width:2px; height:14px; }
    #crosshair:after{ width:14px; height:2px; }
    #crosshairDot{
      position:absolute; left:50%; top:50%;
      width:4px; height:4px; transform:translate(-50%,-50%);
      background:rgba(34,197,94,.95);
      border-radius:50%;
    }

    /* Buttons (fullscreen + load) */
    .topBtns{
      position:absolute;
      right:14px;
      top:84px;
      display:flex; gap:10px;
      pointer-events:auto;
    }
    .btn{
      pointer-events:auto;
      border:none;
      border-radius:14px;
      padding:12px 14px;
      font-weight:1000;
      font-size:15px;
      background:rgba(34,197,94,.95);
      color:#04120a;
      box-shadow:0 8px 18px rgba(0,0,0,.35);
      cursor:pointer;
    }
    .btn.secondary{
      background:rgba(255,255,255,.12);
      color:#fff;
      border:1px solid rgba(255,255,255,.22);
      box-shadow:0 8px 18px rgba(0,0,0,.35);
    }

    /* Forge / LevelUp modals */
    #modalShade{
      position:absolute; inset:0;
      background:rgba(0,0,0,.62);
      backdrop-filter:blur(8px);
      opacity:0;
      pointer-events:none;
      transition:opacity .12s linear;
    }
    #modal{
      position:absolute; left:50%; top:50%;
      transform:translate(-50%,-50%);
      width:min(980px,94vw);
      max-height:min(84vh,760px);
      overflow:auto;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.18);
      background:linear-gradient(180deg, rgba(15,23,42,.92), rgba(2,6,23,.92));
      box-shadow:0 20px 80px rgba(0,0,0,.55);
      padding:14px 14px 16px;
      opacity:0;
      pointer-events:none;
      transition:opacity .12s linear;
    }
    #modal h2{ margin:6px 6px 4px; font-size:16px; }
    #modal .sub{ margin:0 6px 10px; opacity:.75; font-weight:800; font-size:13px; }

    .grid2{
      display:grid;
      grid-template-columns: 1.05fr 1.4fr;
      gap:12px;
    }
    .panel{
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.14);
      border-radius:14px;
      padding:10px;
    }
    .panelTitle{
      font-weight:1000; margin-bottom:6px;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .chipRow{ display:flex; flex-wrap:wrap; gap:8px; }
    .chip{
      display:inline-flex; gap:8px; align-items:center;
      padding:7px 10px; border-radius:999px;
      background:rgba(0,0,0,.30);
      border:1px solid rgba(255,255,255,.12);
      font-weight:950; font-size:12px;
    }
    .recipes{ display:grid; grid-template-columns:repeat(2, minmax(0, 1fr)); gap:10px; }
    .card{
      background:rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.14);
      border-radius:14px;
      padding:10px;
    }
    .card .name{ font-weight:1000; }
    .card .desc{ margin-top:6px; opacity:.78; font-weight:800; font-size:12px; line-height:1.3; }
    .card .req{ margin-top:8px; display:flex; gap:6px; flex-wrap:wrap; }
    .req .reqItem{
      font-size:12px; font-weight:950; opacity:.9;
      padding:4px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
    }
    .card .rowBtns{ margin-top:10px; display:flex; gap:10px; flex-wrap:wrap; }
    .card button{
      cursor:pointer; border:none;
      padding:9px 10px; border-radius:12px;
      font-weight:1000;
      background:#22c55e; color:#07110a;
    }
    .card button.secondary{
      background:rgba(255,255,255,.12);
      color:#fff;
      border:1px solid rgba(255,255,255,.18);
    }
    .card button:disabled{
      opacity:.45; cursor:not-allowed;
    }

    /* Mobile controls */
    #mobileControls{
      position:absolute; inset:0;
      pointer-events:none;
      display:none;
    }
    .joystick{
      position:absolute;
      width:132px; height:132px;
      border-radius:50%;
      background:rgba(15,23,42,.36);
      border:2px solid rgba(255,255,255,.28);
      backdrop-filter:blur(8px);
      pointer-events:auto;
      touch-action:none;
    }
    #moveStick{ left:16px; bottom:20px; }
    #lookStick{ right:16px; bottom:20px; }
    .joystickKnob{
      position:absolute; left:50%; top:50%;
      width:64px; height:64px;
      margin-left:-32px; margin-top:-32px;
      border-radius:50%;
      background:rgba(255,255,255,.75);
      border:2px solid rgba(0,0,0,.2);
      box-shadow:0 8px 18px rgba(0,0,0,.4);
      transition:transform .05s linear;
      pointer-events:none;
    }

    /* Mobile interact button */
    #mobileInteract{
      position:absolute;
      left:50%;
      bottom:180px;
      transform:translateX(-50%);
      pointer-events:auto;
      display:none;
      border:none;
      border-radius:16px;
      padding:14px 16px;
      font-weight:1100;
      background:rgba(34,197,94,.95);
      color:#04120a;
      box-shadow:0 10px 24px rgba(0,0,0,.38);
      touch-action:manipulation;
    }

    @media (pointer: coarse){
      #mobileControls{ display:block; }
      .topBtns{ top:16px; }
      .btn{ padding:13px 15px; font-size:16px; }
      .hint{ bottom:170px; }
      #mobileInteract{ display:block; }
    }
  </style>
</head>
<body>
  <div id="ui">
    <div class="topbar">
      <div class="leftPills">
        <div class="pill">‚ù§Ô∏è <span id="hpText">‚Äî</span></div>
        <div class="pill">‚≠ê <span id="lvlText">‚Äî</span></div>
        <div class="pill">üß≠ <span id="regionText">‚Äî</span></div>
      </div>
      <div class="rightPills">
        <div class="pill">üó°Ô∏è <span id="weaponText">‚Äî</span></div>
        <div class="pill">üì¶ <span id="matsText">‚Äî</span></div>
      </div>
    </div>

    <div id="toast"></div>

    <div class="hint" id="hintBox">
      <div style="font-weight:1000">Controls</div>
      <div class="muted">Click to lock mouse ‚Ä¢ WASD move ‚Ä¢ Shift sprint ‚Ä¢ Space jump ‚Ä¢ ESC unlock</div>
      <div class="muted">Mobile: left stick moves (camera-relative) ‚Ä¢ right stick looks ‚Ä¢ center crosshair auto-fires when target is in-cone</div>
      <div class="muted">Find ‚öíÔ∏è Forges to craft. Level up pauses and offers 3 upgrades. Packs spawn by region ‚Äî travel to find them.</div>
    </div>

    <div class="topBtns">
      <button id="loadBtn" class="btn secondary" type="button">‚¨Ü Load</button>
      <button id="fsBtn" class="btn" type="button">‚õ∂ Fullscreen</button>
    </div>

    <div id="crosshair"><div id="crosshairDot"></div></div>

    <div id="mobileControls">
      <div id="moveStick" class="joystick" aria-label="Movement joystick">
        <div id="moveKnob" class="joystickKnob"></div>
      </div>
      <div id="lookStick" class="joystick" aria-label="Look joystick">
        <div id="lookKnob" class="joystickKnob"></div>
      </div>
      <button id="mobileInteract" type="button">‚öíÔ∏è Use Forge</button>
    </div>

    <div id="overlayVignette"></div>
    <div id="overlayDead"></div>

    <div id="modalShade"></div>
    <div id="modal"></div>

    <div id="centerMsg">
      <div id="centerTitle" style="font-size:18px">CircleRogue</div>
      <div id="centerSub" class="muted" style="margin-top:6px">
        Huge circular world ‚Ä¢ 5 regions ‚Ä¢ Forge crafting ‚Ä¢ Auto-fire aim cone ‚Ä¢ Packs scale with level ‚Ä¢ Local save/load
      </div>
      <div class="row">
        <button id="lockBtn" style="display:none">Click to Play</button>
        <button id="newBtn" class="alt">New Run</button>
        <button id="resumeBtn" class="alt">Resume (Load)</button>
      </div>
      <div class="muted" style="margin-top:10px; font-size:12px">
        Tip: Flying enemies require pitching the camera upward to keep them in the aim cone.
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js";

    // ============================================================
    // Small utilities
    // ============================================================
    const $ = (id)=>document.getElementById(id);

    const toast = $("toast");
    function showToast(msg, ms=2200){
      toast.textContent = msg;
      toast.style.opacity = "1";
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=>toast.style.opacity="0", ms);
    }

    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function smoothstep(t){ t=clamp(t,0,1); return t*t*(3-2*t); }
    function dist2(ax,az,bx,bz){ const dx=ax-bx, dz=az-bz; return dx*dx+dz*dz; }

    function xorshift32(seed){
      let x = (seed|0) || 123456789;
      return ()=>{ x^=x<<13; x^=x>>>17; x^=x<<5; return (x>>>0)/4294967296; };
    }
    function hash2i(x,z,seed){
      // stable 0..1
      const s = Math.sin((x*127.1 + z*311.7 + seed*74.7))*43758.5453123;
      return s - Math.floor(s);
    }

    // ============================================================
    // Renderer / scene
    // ============================================================
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(2, devicePixelRatio||1));
    renderer.setSize(innerWidth, innerHeight);
    renderer.setClearColor(0x070a10, 1);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x070a10, 0.010);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.05, 520);
    const world = new THREE.Group();
    scene.add(world);

    scene.add(new THREE.HemisphereLight(0xcfe3ff, 0x0b1020, 0.42));
    const dir = new THREE.DirectionalLight(0xffffff, 0.30);
    dir.position.set(10, 22, 14);
    scene.add(dir);

    // ============================================================
    // Game constants
    // ============================================================
    const SAVE_KEY = "circleRogueSave_v1";
    const WORLD_RADIUS = 2200;
    const SAFE_MARGIN  = 60;

    const PLAYER_H = 1.72;
    const PLAYER_R = 0.35;
    const GRAVITY  = 11.0;

    const CHUNK = 64;
    const CHUNK_R = 3; // render radius in chunks (7x7 = 49 chunks)
    const ENEMY_CAP_BASE = 18;

    // ============================================================
    // UI refs
    // ============================================================
    const centerMsg = $("centerMsg");
    const centerTitle = $("centerTitle");
    const centerSub = $("centerSub");
    const lockBtn = $("lockBtn");
    const newBtn = $("newBtn");
    const resumeBtn = $("resumeBtn");
    const overlayDead = $("overlayDead");
    const fsBtn = $("fsBtn");
    const loadBtn = $("loadBtn");
    const hintBox = $("hintBox");

    const hpText = $("hpText");
    const lvlText = $("lvlText");
    const regionText = $("regionText");
    const weaponText = $("weaponText");
    const matsText = $("matsText");

    const modalShade = $("modalShade");
    const modal = $("modal");

    const moveStick = $("moveStick");
    const moveKnob  = $("moveKnob");
    const lookStick = $("lookStick");
    const lookKnob  = $("lookKnob");
    const mobileInteract = $("mobileInteract");

    // ============================================================
    // Pointer lock + controls (same feel as your provided file)
    // ============================================================
    let pointerLocked = false;
    function requestLock(){ renderer.domElement.requestPointerLock?.(); }
    document.addEventListener("pointerlockchange", ()=>{
      pointerLocked = (document.pointerLockElement === renderer.domElement);
      lockBtn.style.display = (!pointerLocked && phase==="play") ? "inline-block" : "none";
    });

    // mouse look
    document.addEventListener("mousemove", (e)=>{
      if(!pointerLocked || paused || phase!=="play") return;
      const sens = 0.0022;
      me.yaw   -= e.movementX * sens;
      me.pitch -= e.movementY * sens;
      me.pitch = clamp(me.pitch, -1.32, 1.32);
    });

    // keys
    const keys = {};
    addEventListener("keydown", (e)=>{
      keys[e.key.toLowerCase()] = true;
      if(e.key===" ") e.preventDefault();
      if(e.key==="Escape" && phase==="play"){
        // let ESC unlock pointer; also closes modals
        if(uiMode !== "none") closeModal();
      }
      if((e.key==="e" || e.key==="E") && phase==="play"){
        if(uiMode==="forge") closeModal();
        else tryOpenForge();
      }
    });
    addEventListener("keyup", (e)=>{ keys[e.key.toLowerCase()] = false; });

    // fullscreen
    fsBtn.addEventListener("click", async ()=>{
      try{
        if(!document.fullscreenElement) await document.documentElement.requestFullscreen?.();
        else await document.exitFullscreen?.();
      }catch{}
    });

    // click to lock
    renderer.domElement.addEventListener("click", ()=>{
      if(phase==="play" && !pointerLocked && uiMode==="none") requestLock();
    });

    // ============================================================
    // Mobile dual joysticks (same logic as your file)
    // ============================================================
    const isCoarsePointer = matchMedia("(pointer: coarse)").matches;
    const mobile = {
      enabled: isCoarsePointer,
      moveX:0, moveY:0,
      lookX:0, lookY:0,
      movePointerId:null,
      lookPointerId:null,
    };

    function setJoystick(knob, dx, dy, r){
      if(r<=0) return {x:0,y:0};
      const len = Math.hypot(dx,dy);
      const k = (len>r && len>0) ? (r/len) : 1;
      const cx = dx*k, cy = dy*k;
      knob.style.transform = `translate(${cx}px, ${cy}px)`;
      return { x: clamp(cx/r, -1, 1), y: clamp(cy/r, -1, 1) };
    }
    function resetJoystick(knob){ knob.style.transform="translate(0px, 0px)"; }

    if(moveStick){
      moveStick.addEventListener("pointerdown", (e)=>{
        if(!mobile.enabled) return;
        mobile.movePointerId = e.pointerId;
        moveStick.setPointerCapture(e.pointerId);
        const r = moveStick.getBoundingClientRect();
        const joy = setJoystick(moveKnob, e.clientX-(r.left+r.width/2), e.clientY-(r.top+r.height/2), r.width*0.5);
        mobile.moveX = joy.x; mobile.moveY = joy.y;
      });
      moveStick.addEventListener("pointermove", (e)=>{
        if(!mobile.enabled || mobile.movePointerId!==e.pointerId) return;
        const r = moveStick.getBoundingClientRect();
        const joy = setJoystick(moveKnob, e.clientX-(r.left+r.width/2), e.clientY-(r.top+r.height/2), r.width*0.5);
        mobile.moveX = joy.x; mobile.moveY = joy.y;
      });
      const endJoy = (e)=>{
        if(mobile.movePointerId!==e.pointerId) return;
        mobile.movePointerId=null; mobile.moveX=0; mobile.moveY=0; resetJoystick(moveKnob);
      };
      moveStick.addEventListener("pointerup", endJoy);
      moveStick.addEventListener("pointercancel", endJoy);
      moveStick.addEventListener("lostpointercapture", ()=>{
        mobile.movePointerId=null; mobile.moveX=0; mobile.moveY=0; resetJoystick(moveKnob);
      });
    }

    if(lookStick){
      lookStick.addEventListener("pointerdown", (e)=>{
        if(!mobile.enabled) return;
        mobile.lookPointerId = e.pointerId;
        lookStick.setPointerCapture(e.pointerId);
        const r = lookStick.getBoundingClientRect();
        const joy = setJoystick(lookKnob, e.clientX-(r.left+r.width/2), e.clientY-(r.top+r.height/2), r.width*0.5);
        mobile.lookX = joy.x; mobile.lookY = joy.y;
      });
      lookStick.addEventListener("pointermove", (e)=>{
        if(!mobile.enabled || mobile.lookPointerId!==e.pointerId) return;
        const r = lookStick.getBoundingClientRect();
        const joy = setJoystick(lookKnob, e.clientX-(r.left+r.width/2), e.clientY-(r.top+r.height/2), r.width*0.5);
        mobile.lookX = joy.x; mobile.lookY = joy.y;
      });
      const endLook = (e)=>{
        if(mobile.lookPointerId!==e.pointerId) return;
        mobile.lookPointerId=null; mobile.lookX=0; mobile.lookY=0; resetJoystick(lookKnob);
      };
      lookStick.addEventListener("pointerup", endLook);
      lookStick.addEventListener("pointercancel", endLook);
      lookStick.addEventListener("lostpointercapture", ()=>{
        mobile.lookPointerId=null; mobile.lookX=0; mobile.lookY=0; resetJoystick(lookKnob);
      });
    }

    addEventListener("pointerup", (e)=>{
      if(mobile.movePointerId===e.pointerId){
        mobile.movePointerId=null; mobile.moveX=0; mobile.moveY=0; resetJoystick(moveKnob);
      }
      if(mobile.lookPointerId===e.pointerId){
        mobile.lookPointerId=null; mobile.lookX=0; mobile.lookY=0; resetJoystick(lookKnob);
      }
    });

    mobileInteract.addEventListener("click", ()=>{
      if(phase!=="play") return;
      if(uiMode==="forge") closeModal();
      else tryOpenForge();
    });

    // ============================================================
    // Procedural textures (fast + lightweight)
    // ============================================================
    function makeCanvasTexture(drawFn, size=256){
      const c=document.createElement("canvas"); c.width=c.height=size;
      const g=c.getContext("2d"); drawFn(g,size);
      const t=new THREE.CanvasTexture(c);
      t.colorSpace = THREE.SRGBColorSpace;
      t.wrapS=t.wrapT = THREE.RepeatWrapping;
      t.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy?.()||8);
      t.needsUpdate=true;
      return t;
    }

    const TEX = {
      desert: makeCanvasTexture((g,n)=>{
        g.fillStyle="#d7c08b"; g.fillRect(0,0,n,n);
        for(let i=0;i<5200;i++){
          const x=(Math.random()*n)|0, y=(Math.random()*n)|0;
          const a=0.04+Math.random()*0.12;
          const v=170+((Math.random()*40)|0);
          g.fillStyle=`rgba(${v},${v-6},${v-20},${a})`;
          g.fillRect(x,y,1,1);
        }
        for(let i=0;i<60;i++){
          const x=(Math.random()*n)|0;
          g.fillStyle=`rgba(90,60,20,${0.03+Math.random()*0.05})`;
          g.fillRect(x,0,1,n);
        }
      }),
      forest: makeCanvasTexture((g,n)=>{
        g.fillStyle="#2f6b3a"; g.fillRect(0,0,n,n);
        for(let i=0;i<5200;i++){
          const x=(Math.random()*n)|0, y=(Math.random()*n)|0;
          const a=0.04+Math.random()*0.10;
          const v=30+((Math.random()*40)|0);
          g.fillStyle=`rgba(${v},${80+((Math.random()*60)|0)},${v},${a})`;
          g.fillRect(x,y,1,1);
        }
        g.strokeStyle="rgba(255,255,255,0.05)";
        for(let i=0;i<16;i++){
          g.beginPath();
          g.moveTo(0, (i/16)*n);
          g.lineTo(n, (i/16)*n);
          g.stroke();
        }
      }),
      snow: makeCanvasTexture((g,n)=>{
        g.fillStyle="#e8f0ff"; g.fillRect(0,0,n,n);
        for(let i=0;i<6200;i++){
          const x=(Math.random()*n)|0, y=(Math.random()*n)|0;
          const a=0.03+Math.random()*0.08;
          const v=210+((Math.random()*35)|0);
          g.fillStyle=`rgba(${v},${v},${255},${a})`;
          g.fillRect(x,y,1,1);
        }
        for(let i=0;i<40;i++){
          const x=(Math.random()*n)|0, w=1+((Math.random()*2)|0);
          g.fillStyle=`rgba(120,170,255,${0.02+Math.random()*0.03})`;
          g.fillRect(x,0,w,n);
        }
      }),
      alien: makeCanvasTexture((g,n)=>{
        const grad=g.createLinearGradient(0,0,n,n);
        grad.addColorStop(0,"#ff3ad7");
        grad.addColorStop(1,"#22d3ee");
        g.fillStyle=grad; g.fillRect(0,0,n,n);
        for(let i=0;i<5000;i++){
          const x=(Math.random()*n)|0, y=(Math.random()*n)|0;
          const a=0.03+Math.random()*0.10;
          const r=140+((Math.random()*115)|0);
          const b=140+((Math.random()*115)|0);
          g.fillStyle=`rgba(${r},${60+((Math.random()*80)|0)},${b},${a})`;
          g.fillRect(x,y,1,1);
        }
        for(let i=0;i<90;i++){
          const x=(Math.random()*n)|0;
          g.fillStyle=`rgba(255,255,255,${0.02+Math.random()*0.03})`;
          g.fillRect(x,0,1,n);
        }
      }),
      hell: makeCanvasTexture((g,n)=>{
        g.fillStyle="#3b0a12"; g.fillRect(0,0,n,n);
        for(let i=0;i<5600;i++){
          const x=(Math.random()*n)|0, y=(Math.random()*n)|0;
          const a=0.04+Math.random()*0.12;
          g.fillStyle=`rgba(${140+((Math.random()*115)|0)},${20+((Math.random()*30)|0)},${20+((Math.random()*40)|0)},${a})`;
          g.fillRect(x,y,1,1);
        }
        // lava cracks
        g.strokeStyle="rgba(255,80,30,0.22)";
        g.lineWidth=2;
        for(let i=0;i<24;i++){
          g.beginPath();
          g.moveTo(Math.random()*n, Math.random()*n);
          for(let k=0;k<6;k++){
            g.lineTo(Math.random()*n, Math.random()*n);
          }
          g.stroke();
        }
      })
    };

    // ============================================================
    // Regions (big pie-slices around the circle)
    // ============================================================
    const REGIONS = [
      { id:"desert", name:"Desert Expanse",   fog:0xcaa46f, sky:0x0a1018, tex:"desert", ground:0xffffff,
        props:{ cactus:22, rock:16 }, drops:["iron","hide"], enemies:["scarab","scorpion","sandwisp"] },
      { id:"forest", name:"Verdant Wilds",    fog:0x224b31, sky:0x071018, tex:"forest", ground:0xffffff,
        props:{ tree:20, rock:10 }, drops:["hide","essence"], enemies:["boar","spriggan","spitter"] },
      { id:"snow",   name:"Frost Crown",      fog:0xbcd5ff, sky:0x050812, tex:"snow", ground:0xffffff,
        props:{ pine:20, rock:14 }, drops:["iron","crystal"], enemies:["icegolem","wolf","frostling"] },
      { id:"alien",  name:"Neon Bloom",       fog:0x5be3ff, sky:0x070610, tex:"alien", ground:0xffffff,
        props:{ crystal:22, shroom:14 }, drops:["crystal","essence"], enemies:["drone","floater","shardling"] },
      { id:"hell",   name:"Ash & Ember",      fog:0x4a0010, sky:0x050306, tex:"hell",  ground:0xffffff,
        props:{ spire:18, lava:14 }, drops:["ember","iron"], enemies:["imp","brute","mortar"] },
    ];

    function regionAt(x,z){
      const ang = Math.atan2(z, x); // -pi..pi
      let t = (ang + Math.PI) / (Math.PI*2); // 0..1
      const idx = Math.floor(t * REGIONS.length) % REGIONS.length;
      return REGIONS[idx];
    }

    // ============================================================
    // Height function (deterministic)
    // ============================================================
    let worldSeed = (Math.random()*1e9)|0;
    function heightAt(x,z, regId){
      // low-cost layered noise
      const s = worldSeed;
      const n1 = hash2i(Math.floor(x*0.20), Math.floor(z*0.20), s);
      const n2 = hash2i(Math.floor(x*0.07), Math.floor(z*0.07), s^0x9e3779b9);
      const n3 = hash2i(Math.floor(x*0.03), Math.floor(z*0.03), s^0x85ebca6b);

      let amp = 0.55;
      if(regId==="desert") amp = 1.05;
      if(regId==="forest") amp = 0.55;
      if(regId==="snow")   amp = 0.75;
      if(regId==="alien")  amp = 0.85;
      if(regId==="hell")   amp = 0.95;

      const h = (n1-0.5)*0.8 + (n2-0.5)*1.2 + (n3-0.5)*1.8;
      return h * amp;
    }

    // ============================================================
    // Shared geometries/materials for props
    // ============================================================
    const MAT = {
      cactus: new THREE.MeshStandardMaterial({ color:0x20c35a, roughness:0.95 }),
      wood:   new THREE.MeshStandardMaterial({ color:0x6b4f2a, roughness:0.95 }),
      leaf:   new THREE.MeshStandardMaterial({ color:0x16a34a, roughness:0.95 }),
      pine:   new THREE.MeshStandardMaterial({ color:0x1f7a4f, roughness:0.95 }),
      rock:   new THREE.MeshStandardMaterial({ color:0x6b7280, roughness:0.98 }),
      ice:    new THREE.MeshStandardMaterial({ color:0xdbeafe, roughness:0.55, metalness:0.05, emissive:0x0b1b3f, emissiveIntensity:0.15 }),
      crystal:new THREE.MeshStandardMaterial({ color:0xff3ad7, roughness:0.28, metalness:0.18, emissive:0x7c3aed, emissiveIntensity:0.35 }),
      shroom: new THREE.MeshStandardMaterial({ color:0x22d3ee, roughness:0.75, emissive:0x0ea5e9, emissiveIntensity:0.22 }),
      spire:  new THREE.MeshStandardMaterial({ color:0x1f0a10, roughness:0.95, emissive:0x3b0a12, emissiveIntensity:0.20 }),
      lava:   new THREE.MeshStandardMaterial({ color:0xff3b1a, roughness:0.35, emissive:0xff3b1a, emissiveIntensity:1.20 }),
      forge:  new THREE.MeshStandardMaterial({ color:0x111827, roughness:0.7, metalness:0.25, emissive:0x0b1020, emissiveIntensity:0.2 }),
      forgeGlow: new THREE.MeshStandardMaterial({ color:0x22c55e, roughness:0.25, metalness:0.0, emissive:0x22c55e, emissiveIntensity:1.2, transparent:true, opacity:0.7 }),
      drop:   new THREE.MeshStandardMaterial({ color:0xffffff, roughness:0.35, metalness:0.05, emissive:0xffffff, emissiveIntensity:0.45 }),
    };

    const GEO = {
      ground: (()=>{
        const g = new THREE.PlaneGeometry(CHUNK, CHUNK, 12, 12);
        g.rotateX(-Math.PI/2);
        return g;
      })(),
      cactus: new THREE.CylinderGeometry(0.15, 0.22, 2.2, 6),
      trunk:  new THREE.CylinderGeometry(0.12, 0.18, 2.2, 7),
      cone:   new THREE.ConeGeometry(0.9, 2.4, 8),
      pine:   new THREE.ConeGeometry(1.0, 2.6, 8),
      rock:   new THREE.DodecahedronGeometry(0.55, 0),
      ice:    new THREE.DodecahedronGeometry(0.7, 0),
      crystal:new THREE.OctahedronGeometry(0.75, 0),
      shroom: new THREE.CylinderGeometry(0.25, 0.35, 0.6, 8),
      cap:    new THREE.SphereGeometry(0.55, 10, 10),
      spire:  new THREE.ConeGeometry(0.55, 2.8, 7),
      lava:   new THREE.SphereGeometry(0.45, 12, 10),
      bolt:   new THREE.SphereGeometry(0.08, 10, 8),
      ember:  new THREE.SphereGeometry(0.12, 10, 8),
      drop:   new THREE.OctahedronGeometry(0.16, 0),
    };

    const groundMats = {};
    for(const r of REGIONS){
      const t = TEX[r.tex];
      const m = new THREE.MeshStandardMaterial({
        color: r.ground,
        map: t,
        roughness: 1.0,
        metalness: 0.0,
      });
      m.map.repeat.set(10, 10);
      groundMats[r.id] = m;
    }

    // ============================================================
    // Chunk system (procedural visuals within range)
    // ============================================================
    const chunks = new Map(); // key -> {group, ground, props[]}

    function chunkKey(cx,cz){ return cx + "," + cz; }

    function inWorldCircle(x,z){
      return (x*x + z*z) <= (WORLD_RADIUS*WORLD_RADIUS);
    }

    function deformGround(geo, cx, cz, regionId){
      // Modify position buffer to match heightAt for this chunk
      const pos = geo.attributes.position;
      for(let i=0;i<pos.count;i++){
        const vx = pos.getX(i);
        const vz = pos.getZ(i);
        const wx = cx*CHUNK + vx;
        const wz = cz*CHUNK + vz;
        const h = heightAt(wx, wz, regionId);
        pos.setY(i, h);
      }
      pos.needsUpdate = true;
      geo.computeVertexNormals();
    }

    function addInstanced(group, geo, mat, count, rnd, placeFn){
      const im = new THREE.InstancedMesh(geo, mat, count);
      im.castShadow = false;
      im.receiveShadow = true;
      const dummy = new THREE.Object3D();
      for(let i=0;i<count;i++){
        placeFn(dummy, i, rnd);
        dummy.updateMatrix();
        im.setMatrixAt(i, dummy.matrix);
      }
      group.add(im);
      return im;
    }

    function createChunk(cx, cz){
      const key = chunkKey(cx,cz);
      if(chunks.has(key)) return;

      const wx = cx*CHUNK, wz = cz*CHUNK;
      if(!inWorldCircle(wx, wz)) return;

      const reg = regionAt(wx, wz);
      const group = new THREE.Group();
      group.position.set(wx, 0, wz);

      // ground
      const g = GEO.ground.clone();
      deformGround(g, cx, cz, reg.id);
      const ground = new THREE.Mesh(g, groundMats[reg.id]);
      ground.receiveShadow = true;
      group.add(ground);

      const rnd = xorshift32(((worldSeed^0xA53A9B1D) + cx*928371 + cz*19349663)|0);

      // Props by region (instanced, low overhead)
      const prop = reg.props || {};
      const baseCount = (a)=>Math.max(0, (a + ((rnd()*6)|0))|0);

      if(reg.id==="desert"){
        addInstanced(group, GEO.cactus, MAT.cactus, baseCount(prop.cactus||18), rnd, (d,i,rr)=>{
          const px = (rr()-0.5)*(CHUNK*0.92);
          const pz = (rr()-0.5)*(CHUNK*0.92);
          const y  = heightAt(wx+px, wz+pz, reg.id);
          d.position.set(px, y+1.05, pz);
          d.rotation.y = rr()*Math.PI*2;
          const s = 0.7 + rr()*0.9;
          d.scale.set(s, 0.85 + rr()*0.9, s);
        });
        addInstanced(group, GEO.rock, MAT.rock, baseCount(prop.rock||14), rnd, (d,i,rr)=>{
          const px = (rr()-0.5)*(CHUNK*0.95);
          const pz = (rr()-0.5)*(CHUNK*0.95);
          const y  = heightAt(wx+px, wz+pz, reg.id);
          d.position.set(px, y+0.35, pz);
          d.rotation.y = rr()*Math.PI*2;
          const s = 0.35 + rr()*0.75;
          d.scale.set(s,s,s);
        });
      }

      if(reg.id==="forest"){
        // trunks
        addInstanced(group, GEO.trunk, MAT.wood, baseCount(prop.tree||18), rnd, (d,i,rr)=>{
          const px=(rr()-0.5)*(CHUNK*0.9), pz=(rr()-0.5)*(CHUNK*0.9);
          const y=heightAt(wx+px, wz+pz, reg.id);
          d.position.set(px, y+1.1, pz);
          d.rotation.y=rr()*Math.PI*2;
          const s=0.7+rr()*1.1;
          d.scale.set(s, 1.0+rr()*1.0, s);
        });
        // leaves cones
        addInstanced(group, GEO.cone, MAT.leaf, baseCount((prop.tree||18)), rnd, (d,i,rr)=>{
          const px=(rr()-0.5)*(CHUNK*0.9), pz=(rr()-0.5)*(CHUNK*0.9);
          const y=heightAt(wx+px, wz+pz, reg.id);
          d.position.set(px, y+3.0, pz);
          d.rotation.y=rr()*Math.PI*2;
          const s=0.7+rr()*1.2;
          d.scale.set(s, 0.9+rr()*1.0, s);
        });
        addInstanced(group, GEO.rock, MAT.rock, baseCount(prop.rock||10), rnd, (d,i,rr)=>{
          const px=(rr()-0.5)*(CHUNK*0.95), pz=(rr()-0.5)*(CHUNK*0.95);
          const y=heightAt(wx+px, wz+pz, reg.id);
          d.position.set(px, y+0.35, pz);
          d.rotation.y=rr()*Math.PI*2;
          const s=0.35+rr()*0.7;
          d.scale.set(s,s,s);
        });
      }

      if(reg.id==="snow"){
        addInstanced(group, GEO.trunk, MAT.wood, baseCount(prop.pine||18), rnd, (d,i,rr)=>{
          const px=(rr()-0.5)*(CHUNK*0.9), pz=(rr()-0.5)*(CHUNK*0.9);
          const y=heightAt(wx+px, wz+pz, reg.id);
          d.position.set(px, y+1.0, pz);
          d.rotation.y=rr()*Math.PI*2;
          const s=0.6+rr()*0.9;
          d.scale.set(s, 0.8+rr()*1.0, s);
        });
        addInstanced(group, GEO.pine, MAT.pine, baseCount(prop.pine||18), rnd, (d,i,rr)=>{
          const px=(rr()-0.5)*(CHUNK*0.9), pz=(rr()-0.5)*(CHUNK*0.9);
          const y=heightAt(wx+px, wz+pz, reg.id);
          d.position.set(px, y+2.8, pz);
          d.rotation.y=rr()*Math.PI*2;
          const s=0.8+rr()*1.1;
          d.scale.set(s, 0.9+rr()*1.0, s);
        });
        addInstanced(group, GEO.ice, MAT.ice, baseCount(prop.rock||12), rnd, (d,i,rr)=>{
          const px=(rr()-0.5)*(CHUNK*0.95), pz=(rr()-0.5)*(CHUNK*0.95);
          const y=heightAt(wx+px, wz+pz, reg.id);
          d.position.set(px, y+0.45, pz);
          d.rotation.y=rr()*Math.PI*2;
          const s=0.35+rr()*0.85;
          d.scale.set(s,s,s);
        });
      }

      if(reg.id==="alien"){
        addInstanced(group, GEO.crystal, MAT.crystal, baseCount(prop.crystal||18), rnd, (d,i,rr)=>{
          const px=(rr()-0.5)*(CHUNK*0.92), pz=(rr()-0.5)*(CHUNK*0.92);
          const y=heightAt(wx+px, wz+pz, reg.id);
          d.position.set(px, y+0.9, pz);
          d.rotation.y=rr()*Math.PI*2;
          const s=0.6+rr()*1.4;
          d.scale.set(s, 0.8+rr()*1.8, s);
        });
        addInstanced(group, GEO.shroom, MAT.shroom, baseCount(prop.shroom||12), rnd, (d,i,rr)=>{
          const px=(rr()-0.5)*(CHUNK*0.95), pz=(rr()-0.5)*(CHUNK*0.95);
          const y=heightAt(wx+px, wz+pz, reg.id);
          d.position.set(px, y+0.3, pz);
          d.rotation.y=rr()*Math.PI*2;
          const s=0.7+rr()*1.0;
          d.scale.set(s, 0.8+rr()*0.8, s);
        });
        addInstanced(group, GEO.cap, MAT.crystal, baseCount(prop.shroom||12), rnd, (d,i,rr)=>{
          const px=(rr()-0.5)*(CHUNK*0.95), pz=(rr()-0.5)*(CHUNK*0.95);
          const y=heightAt(wx+px, wz+pz, reg.id);
          d.position.set(px, y+0.9, pz);
          d.rotation.y=rr()*Math.PI*2;
          const s=0.7+rr()*1.0;
          d.scale.set(s, 0.55+rr()*0.6, s);
        });
      }

      if(reg.id==="hell"){
        addInstanced(group, GEO.spire, MAT.spire, baseCount(prop.spire||16), rnd, (d,i,rr)=>{
          const px=(rr()-0.5)*(CHUNK*0.92), pz=(rr()-0.5)*(CHUNK*0.92);
          const y=heightAt(wx+px, wz+pz, reg.id);
          d.position.set(px, y+1.35, pz);
          d.rotation.y=rr()*Math.PI*2;
          const s=0.7+rr()*1.2;
          d.scale.set(s, 0.9+rr()*1.2, s);
        });
        addInstanced(group, GEO.lava, MAT.lava, baseCount(prop.lava||12), rnd, (d,i,rr)=>{
          const px=(rr()-0.5)*(CHUNK*0.95), pz=(rr()-0.5)*(CHUNK*0.95);
          const y=heightAt(wx+px, wz+pz, reg.id);
          d.position.set(px, y+0.4, pz);
          d.rotation.y=rr()*Math.PI*2;
          const s=0.65+rr()*1.0;
          d.scale.set(s,s,s);
        });
      }

      world.add(group);
      chunks.set(key, { group, ground });
    }

    function disposeChunk(key){
      const c = chunks.get(key);
      if(!c) return;
      world.remove(c.group);
      c.group.traverse((o)=>{
        if(o.geometry?.dispose) o.geometry.dispose();
        const m = o.material;
        if(Array.isArray(m)) m.forEach(mm=>mm?.dispose?.());
        else m?.dispose?.();
      });
      chunks.delete(key);
    }

    function tickChunks(){
      const cx = Math.floor(me.x / CHUNK);
      const cz = Math.floor(me.z / CHUNK);

      // load
      for(let dz=-CHUNK_R; dz<=CHUNK_R; dz++){
        for(let dx=-CHUNK_R; dx<=CHUNK_R; dx++){
          createChunk(cx+dx, cz+dz);
        }
      }
      // unload
      for(const key of chunks.keys()){
        const [kx,kz] = key.split(",").map(Number);
        if(Math.abs(kx-cx)>CHUNK_R+1 || Math.abs(kz-cz)>CHUNK_R+1){
          disposeChunk(key);
        }
      }
    }

    // ============================================================
    // Forge placement (pre-generated, highlighted, interact pauses)
    // ============================================================
    const forges = []; // {x,z, regionId, mesh, beacon}
    function buildForgeMesh(){
      const g = new THREE.Group();
      const base = new THREE.Mesh(new THREE.CylinderGeometry(1.1, 1.2, 0.5, 16), MAT.forge);
      base.position.y = 0.25;
      g.add(base);

      const anvil = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.35, 0.9), MAT.forge);
      anvil.position.set(0, 0.78, 0);
      g.add(anvil);

      const horn = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.05, 0.9, 12), MAT.forge);
      horn.rotation.z = Math.PI/2;
      horn.position.set(0.85, 0.82, 0);
      g.add(horn);

      const glowRing = new THREE.Mesh(new THREE.TorusGeometry(1.35, 0.12, 12, 28), MAT.forgeGlow);
      glowRing.rotation.x = Math.PI/2;
      glowRing.position.y = 0.08;
      g.add(glowRing);

      const beacon = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 6.0, 10), MAT.forgeGlow);
      beacon.position.y = 3.2;
      beacon.material.transparent = true;
      beacon.material.opacity = 0.18;
      g.add(beacon);

      const light = new THREE.PointLight(0x22c55e, 1.25, 16, 2.0);
      light.position.set(0, 2.2, 0);
      g.add(light);

      g.userData.glowRing = glowRing;
      g.userData.beacon = beacon;
      g.userData.light = light;
      return g;
    }

    function genForges(){
      forges.length = 0;
      const rnd = xorshift32(worldSeed ^ 0xC0FFEE);
      const total = 34;

      let tries = 0;
      while(forges.length < total && tries < 8000){
        tries++;
        const r = (SAFE_MARGIN + rnd()*(WORLD_RADIUS-SAFE_MARGIN)) ** 1.0;
        const a = rnd()*Math.PI*2;
        const x = Math.cos(a)*r;
        const z = Math.sin(a)*r;

        // avoid too close to center (keep some travel)
        if((x*x+z*z) < 260*260) continue;

        // avoid clustering forges
        let ok = true;
        for(const f of forges){
          if(dist2(x,z,f.x,f.z) < 180*180){ ok=false; break; }
        }
        if(!ok) continue;

        const reg = regionAt(x,z);
        forges.push({ x, z, regionId: reg.id, mesh:null });
      }
    }

    function tickForges(now){
      // spawn / despawn forge meshes by distance
      const nearDist2 = 220*220;
      for(const f of forges){
        const d2 = dist2(me.x, me.z, f.x, f.z);
        if(d2 < nearDist2){
          if(!f.mesh){
            const m = buildForgeMesh();
            const y = heightAt(f.x, f.z, f.regionId);
            m.position.set(f.x, y, f.z);
            world.add(m);
            f.mesh = m;
          }
          // animate glow
          const t = now*0.001;
          const pulse = 0.65 + 0.35*Math.sin(t*2.2 + (f.x+f.z)*0.01);
          f.mesh.userData.glowRing.material.opacity = 0.30 + 0.55*pulse;
          f.mesh.userData.light.intensity = 0.7 + 0.9*pulse;
          f.mesh.rotation.y += 0.002;

        }else if(f.mesh){
          world.remove(f.mesh);
          f.mesh.traverse((o)=>{
            if(o.geometry?.dispose) o.geometry.dispose();
            const m = o.material;
            if(Array.isArray(m)) m.forEach(mm=>mm?.dispose?.());
            else m?.dispose?.();
          });
          f.mesh = null;
        }
      }
    }

    function nearestForge(){
      let best=null, bestD=1e18;
      for(const f of forges){
        const d2 = dist2(me.x, me.z, f.x, f.z);
        if(d2 < bestD){ bestD=d2; best=f; }
      }
      return best ? { forge:best, d:Math.sqrt(bestD) } : null;
    }

    // ============================================================
    // Weapons
    // ============================================================
    const WEAPONS = {
      "Arc Bolt": {
        kind:"bolt",
        desc:"Fast bolts. Reliable. Moderate range.",
        dmg: 10, range: 28, fireRate: 7.2,
        color: 0x60a5fa, splinter:false
      },
      "Sun Beam": {
        kind:"beam",
        desc:"Continuous beam. Melts single targets in-cone.",
        dps: 18, range: 24,
        color: 0xfff3a0
      },
      "Shock Wave": {
        kind:"wave",
        desc:"Forward wave that can hit multiple enemies.",
        dmg: 16, range: 18, fireRate: 2.2,
        color: 0x22c55e
      },
      "Shard Rifle": {
        kind:"bolt",
        desc:"Bolts that splinter to nearby enemies.",
        dmg: 9, range: 30, fireRate: 6.2,
        color: 0xff3ad7, splinter:true
      },
      "Ember Lance": {
        kind:"bolt",
        desc:"Slow heavy bolt with small explosion on hit.",
        dmg: 18, range: 26, fireRate: 3.0,
        color: 0xff3b1a, explode:true
      }
    };

    const RECIPES = [
      {
        type:"weapon",
        name:"Arc Bolt",
        req:{ iron:6, hide:4 },
        equip:true
      },
      {
        type:"weapon",
        name:"Sun Beam",
        req:{ essence:9, iron:6 },
        equip:true
      },
      {
        type:"weapon",
        name:"Shock Wave",
        req:{ hide:8, essence:6 },
        equip:true
      },
      {
        type:"weapon",
        name:"Shard Rifle",
        req:{ crystal:10, essence:6 },
        equip:true
      },
      {
        type:"weapon",
        name:"Ember Lance",
        req:{ ember:10, iron:8 },
        equip:true
      },
      {
        type:"upgrade",
        name:"Reinforced Plate (+Max HP)",
        req:{ iron:10, hide:10 },
        apply:(p)=>{ p.maxHp += 25; p.hp = Math.min(p.maxHp, p.hp+25); }
      },
      {
        type:"upgrade",
        name:"Tempered Core (+Damage)",
        req:{ iron:12, essence:8 },
        apply:(p)=>{ p.damageMul *= 1.12; }
      },
      {
        type:"upgrade",
        name:"Long Sight (+Range)",
        req:{ crystal:10, hide:6 },
        apply:(p)=>{ p.rangeMul *= 1.10; }
      },
    ];

    // ============================================================
    // Player state
    // ============================================================
    const me = {
      x: 0, z: 0,
      y: PLAYER_H,
      vx:0, vz:0, vy:0,
      yaw: 0,
      pitch: 0,
      grounded: true,

      // stats
      level: 1,
      xp: 0,
      nextXp: 18,

      maxHp: 100,
      hp: 100,

      speedMul: 1.0,
      damageMul: 1.0,
      rangeMul: 1.0,

      // gear
      weapon: "Arc Bolt",
      ownedWeapons: new Set(["Arc Bolt"]),

      // inventory materials
      mats: { iron:0, hide:0, essence:0, crystal:0, ember:0 },

      // abilities (unlocked flags)
      abil: {
        poisonAura:false,
        lifeGrip:false,
        meteorite:false,
        firebolt:false,
      },

      // cooldowns/timers
      fireCd: 0,
      fireboltCd: 0,
      lifeGripT: 0,
      meteorT: 0,
    };

    function resetRun(newSeed=true){
      if(newSeed) worldSeed = (Math.random()*1e9)|0;
      me.x = 0; me.z = 0;
      me.vx=me.vz=me.vy=0;
      me.yaw = 0; me.pitch = 0;

      me.level=1; me.xp=0; me.nextXp=18;

      me.maxHp=100; me.hp=100;
      me.speedMul=1.0; me.damageMul=1.0; me.rangeMul=1.0;

      me.weapon="Arc Bolt";
      me.ownedWeapons = new Set(["Arc Bolt"]);
      me.mats = { iron:0, hide:0, essence:0, crystal:0, ember:0 };

      me.abil = { poisonAura:false, lifeGrip:false, meteorite:false, firebolt:false };
      me.fireCd=0; me.fireboltCd=0; me.lifeGripT=0; me.meteorT=0;

      alive = true;
      overlayDead.style.opacity = "0";

      // clear entities
      clearEntities();

      // regen forges + chunks
      genForges();
      showToast("üü© New run started.");
      saveGame(true);
    }

    // ============================================================
    // Save / Load
    // ============================================================
    function saveGame(silent=false){
      const data = {
        v: 1,
        seed: worldSeed,
        t: Date.now(),
        player: {
          x: me.x, z: me.z,
          yaw: me.yaw, pitch: me.pitch,
          level: me.level, xp: me.xp, nextXp: me.nextXp,
          maxHp: me.maxHp, hp: me.hp,
          speedMul: me.speedMul, damageMul: me.damageMul, rangeMul: me.rangeMul,
          weapon: me.weapon,
          ownedWeapons: Array.from(me.ownedWeapons),
          mats: me.mats,
          abil: me.abil,
          cds: { fireboltCd: me.fireboltCd, lifeGripT: me.lifeGripT, meteorT: me.meteorT }
        }
      };
      try{
        localStorage.setItem(SAVE_KEY, JSON.stringify(data));
        if(!silent) showToast("üíæ Saved.");
      }catch{
        if(!silent) showToast("‚ö†Ô∏è Could not save (storage blocked).");
      }
    }

    function loadGame(){
      try{
        const raw = localStorage.getItem(SAVE_KEY);
        if(!raw){ showToast("No save found."); return false; }
        const data = JSON.parse(raw);
        if(!data || !data.player){ showToast("Save is invalid."); return false; }

        worldSeed = data.seed|0 || worldSeed;

        const p = data.player;
        me.x = +p.x || 0; me.z = +p.z || 0;
        me.yaw = +p.yaw || 0; me.pitch = clamp(+p.pitch||0, -1.32, 1.32);
        me.level = +p.level||1;
        me.xp = +p.xp||0;
        me.nextXp = +p.nextXp || Math.max(18, me.level*18);

        me.maxHp = +p.maxHp||100;
        me.hp = clamp(+p.hp||me.maxHp, 0, me.maxHp);

        me.speedMul = +p.speedMul||1;
        me.damageMul = +p.damageMul||1;
        me.rangeMul = +p.rangeMul||1;

        me.weapon = String(p.weapon||"Arc Bolt");
        me.ownedWeapons = new Set(Array.isArray(p.ownedWeapons)? p.ownedWeapons : ["Arc Bolt"]);
        if(!me.ownedWeapons.has(me.weapon)) me.ownedWeapons.add(me.weapon);

        me.mats = Object.assign({ iron:0, hide:0, essence:0, crystal:0, ember:0 }, p.mats||{});
        me.abil = Object.assign({ poisonAura:false, lifeGrip:false, meteorite:false, firebolt:false }, p.abil||{});

        me.fireboltCd = +(p.cds?.fireboltCd||0);
        me.lifeGripT  = +(p.cds?.lifeGripT||0);
        me.meteorT    = +(p.cds?.meteorT||0);

        alive = true;
        overlayDead.style.opacity = "0";

        clearEntities();
        genForges();
        showToast("‚¨Ü Loaded save.");
        return true;
      }catch{
        showToast("‚ö†Ô∏è Failed to load save.");
        return false;
      }
    }

    loadBtn.addEventListener("click", ()=>{
      if(loadGame()){
        phase = "play";
        centerMsg.style.display="none";
        hintBox.style.display = "block";
        uiMode="none";
        paused=false;
        saveGame(true);
      }
    });

    newBtn.addEventListener("click", ()=>{
      phase = "play";
      centerMsg.style.display="none";
      hintBox.style.display = "block";
      resetRun(true);
      paused=false; uiMode="none";
    });

    resumeBtn.addEventListener("click", ()=>{
      const ok = loadGame();
      phase = "play";
      centerMsg.style.display="none";
      hintBox.style.display = "block";
      if(!ok) resetRun(true);
      paused=false; uiMode="none";
    });

    // ============================================================
    // Enemies, projectiles, drops
    // ============================================================
    const enemies = [];     // {id,type,mesh,hp,maxHp,spd,dmg,range, yOff, flying, state, t, cd, wind, targetMarker}
    const projectiles = []; // {x,y,z,vx,vy,vz,life,rad,dmg,from,kind,color, splinter, explode, aoe}
    const drops = [];       // {x,y,z,mesh,mat,spin}

    let nextEnemyId = 1;

    function clearEntities(){
      for(const e of enemies) world.remove(e.mesh);
      for(const p of projectiles) world.remove(p.mesh);
      for(const d of drops) world.remove(d.mesh);
      enemies.length=0; projectiles.length=0; drops.length=0;
    }

    function makeHealthBar(){
      const g = new THREE.Group();
      const bg = new THREE.Mesh(new THREE.PlaneGeometry(1.1, 0.14), new THREE.MeshBasicMaterial({ color:0x000000, transparent:true, opacity:0.55 }));
      const fg = new THREE.Mesh(new THREE.PlaneGeometry(1.05, 0.10), new THREE.MeshBasicMaterial({ color:0x22c55e, transparent:true, opacity:0.92 }));
      bg.position.z = 0.001;
      fg.position.z = 0.002;
      fg.position.x = -0.025;
      g.add(bg, fg);
      g.userData.bg = bg;
      g.userData.fg = fg;
      return g;
    }

    function makeEnemyMesh(type, regId){
      const g = new THREE.Group();

      // default palette by region
      let baseCol = 0x94a3b8;
      let emisCol = 0x0b1020;
      if(regId==="desert"){ baseCol = 0x8b6b3a; emisCol=0x2a1a0b; }
      if(regId==="forest"){ baseCol = 0x2dd47a; emisCol=0x0b2a18; }
      if(regId==="snow"){ baseCol = 0xaad7ff; emisCol=0x0b1b3f; }
      if(regId==="alien"){ baseCol = 0xff3ad7; emisCol=0x7c3aed; }
      if(regId==="hell"){ baseCol = 0xff2a2a; emisCol=0x4a0010; }

      const mat = new THREE.MeshStandardMaterial({
        color: baseCol,
        roughness: 0.78,
        metalness: 0.06,
        emissive: emisCol,
        emissiveIntensity: 0.45
      });

      const dark = new THREE.MeshStandardMaterial({
        color: 0x111827,
        roughness: 0.9,
        metalness: 0.05,
        emissive: emisCol,
        emissiveIntensity: 0.15
      });

      // shape language by type (made of primitives)
      if(type==="scarab" || type==="beetle"){
        const body = new THREE.Mesh(new THREE.SphereGeometry(0.55, 12, 10), mat);
        body.position.y = 0.55;
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.35, 12, 10), dark);
        head.position.set(0,0.58,0.58);
        const horn = new THREE.Mesh(new THREE.ConeGeometry(0.16, 0.6, 10), mat);
        horn.position.set(0,0.76,0.90); horn.rotation.x = Math.PI/2;
        g.add(body, head, horn);
      } else if(type==="scorpion"){
        const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.35, 0.8, 6, 10), mat);
        body.position.y = 0.7;
        const tail = new THREE.Mesh(new THREE.ConeGeometry(0.18, 0.9, 10), dark);
        tail.position.set(0,1.0,-0.65); tail.rotation.x = -0.5;
        const clawL = new THREE.Mesh(new THREE.SphereGeometry(0.22, 10, 10), dark);
        const clawR = clawL.clone();
        clawL.position.set(-0.55,0.6,0.45);
        clawR.position.set( 0.55,0.6,0.45);
        g.add(body, tail, clawL, clawR);
      } else if(type==="sandwisp" || type==="floater"){
        const core = new THREE.Mesh(new THREE.SphereGeometry(0.35, 14, 12), mat);
        core.position.y=1.35;
        const ring = new THREE.Mesh(new THREE.TorusGeometry(0.55, 0.10, 10, 20), mat);
        ring.position.y=1.35;
        ring.rotation.x = Math.PI/2;
        g.add(core, ring);
      } else if(type==="boar"){
        const body = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.6, 0.7), mat);
        body.position.y=0.7;
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.45, 0.5), dark);
        head.position.set(0,0.75,0.6);
        const tuskL = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.28, 10), new THREE.MeshStandardMaterial({ color:0xffffff, roughness:0.4 }));
        const tuskR = tuskL.clone();
        tuskL.position.set(-0.25,0.62,0.9); tuskL.rotation.x = Math.PI/2;
        tuskR.position.set( 0.25,0.62,0.9); tuskR.rotation.x = Math.PI/2;
        g.add(body, head, tuskL, tuskR);
      } else if(type==="spriggan"){
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.35,0.48,1.2,10), MAT.wood);
        body.position.y=0.9;
        const crown = new THREE.Mesh(new THREE.ConeGeometry(0.7, 1.2, 10), MAT.leaf);
        crown.position.y=1.8;
        const armL = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,0.9,8), MAT.wood);
        const armR = armL.clone();
        armL.position.set(-0.65,1.05,0); armL.rotation.z=0.6;
        armR.position.set( 0.65,1.05,0); armR.rotation.z=-0.6;
        g.add(body, crown, armL, armR);
      } else if(type==="spitter"){
        const body = new THREE.Mesh(new THREE.SphereGeometry(0.5, 12, 10), mat);
        body.position.y=0.8;
        const snout = new THREE.Mesh(new THREE.CylinderGeometry(0.18,0.24,0.6,10), dark);
        snout.position.set(0,0.82,0.68); snout.rotation.x = Math.PI/2;
        g.add(body, snout);
      } else if(type==="wolf"){
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.95,0.45,0.55), mat);
        body.position.y=0.6;
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.35,0.42), dark);
        head.position.set(0,0.67,0.58);
        const earL = new THREE.Mesh(new THREE.ConeGeometry(0.12,0.28,10), dark);
        const earR = earL.clone();
        earL.position.set(-0.18,0.95,0.52);
        earR.position.set( 0.18,0.95,0.52);
        g.add(body, head, earL, earR);
      } else if(type==="icegolem"){
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.9, 1.2, 0.7), MAT.ice);
        body.position.y=1.0;
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.55, 0.55), MAT.ice);
        head.position.y=1.75;
        const armL = new THREE.Mesh(new THREE.BoxGeometry(0.25,0.8,0.25), MAT.ice);
        const armR = armL.clone();
        armL.position.set(-0.7,1.2,0); armL.rotation.z=0.25;
        armR.position.set( 0.7,1.2,0); armR.rotation.z=-0.25;
        g.add(body, head, armL, armR);
      } else if(type==="frostling"){
        const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.25, 0.7, 6, 10), mat);
        body.position.y=0.95;
        const spike = new THREE.Mesh(new THREE.ConeGeometry(0.22,0.7,10), MAT.ice);
        spike.position.set(0,1.55,0); spike.rotation.x = Math.PI;
        g.add(body, spike);
      } else if(type==="drone"){
        const core = new THREE.Mesh(new THREE.OctahedronGeometry(0.45,0), MAT.crystal);
        core.position.y=1.45;
        const finL = new THREE.Mesh(new THREE.BoxGeometry(0.65,0.08,0.18), MAT.shroom);
        const finR = finL.clone();
        finL.position.set(-0.55,1.45,0); finR.position.set(0.55,1.45,0);
        g.add(core, finL, finR);
      } else if(type==="shardling"){
        const body = new THREE.Mesh(new THREE.DodecahedronGeometry(0.52,0), MAT.crystal);
        body.position.y=0.85;
        const shard = new THREE.Mesh(new THREE.ConeGeometry(0.25,0.9,10), MAT.shroom);
        shard.position.set(0,1.35,0); shard.rotation.x = Math.PI;
        g.add(body, shard);
      } else if(type==="imp"){
        const body = new THREE.Mesh(new THREE.SphereGeometry(0.42, 12, 10), mat);
        body.position.y=0.75;
        const hornL = new THREE.Mesh(new THREE.ConeGeometry(0.12,0.38,10), dark);
        const hornR = hornL.clone();
        hornL.position.set(-0.22,1.15,0.1); hornL.rotation.z=0.25;
        hornR.position.set( 0.22,1.15,0.1); hornR.rotation.z=-0.25;
        g.add(body, hornL, hornR);
      } else if(type==="brute"){
        const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.55, 1.0, 8, 12), mat);
        body.position.y=1.15;
        const shoulders = new THREE.Mesh(new THREE.SphereGeometry(0.6, 12, 10), dark);
        shoulders.position.y=1.55;
        const club = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.14,1.3,10), MAT.spire);
        club.position.set(0.75,1.15,0); club.rotation.z = -0.8;
        g.add(body, shoulders, club);
      } else if(type==="mortar"){
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.45,0.55,1.0,12), mat);
        body.position.y=0.9;
        const tube = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.16,0.9,10), dark);
        tube.position.set(0,1.25,0.25); tube.rotation.x = 0.55;
        g.add(body, tube);
      } else {
        const body = new THREE.Mesh(new THREE.SphereGeometry(0.5, 12, 10), mat);
        body.position.y=0.8;
        g.add(body);
      }

      const bar = makeHealthBar();
      bar.position.y = 2.25;
      g.add(bar);
      g.userData.hpBar = bar;

      return g;
    }

    function enemyStats(type, level){
      // base stats per archetype
      let baseHp=26, baseDmg=8, spd=2.1, range=1.3, flying=false, yOff=0.0, kind="melee";
      if(type==="scarab"){ baseHp=22; baseDmg=7; spd=2.5; range=1.2; kind="melee"; }
      if(type==="scorpion"){ baseHp=28; baseDmg=9; spd=2.2; range=1.35; kind="melee"; }
      if(type==="sandwisp"){ baseHp=18; baseDmg=7; spd=2.6; range=10; kind="ranged"; flying=true; yOff=1.2; }
      if(type==="boar"){ baseHp=30; baseDmg=9; spd=2.4; range=1.35; kind="melee"; }
      if(type==="spriggan"){ baseHp=38; baseDmg=10; spd=1.9; range=1.45; kind="melee"; }
      if(type==="spitter"){ baseHp=24; baseDmg=8; spd=2.0; range=12; kind="ranged"; }
      if(type==="wolf"){ baseHp=22; baseDmg=8; spd=2.9; range=1.25; kind="melee"; }
      if(type==="icegolem"){ baseHp=52; baseDmg=12; spd=1.6; range=1.6; kind="melee"; }
      if(type==="frostling"){ baseHp=18; baseDmg=7; spd=3.1; range=1.15; kind="melee"; }
      if(type==="drone"){ baseHp=22; baseDmg=9; spd=2.3; range=12; kind="ranged"; flying=true; yOff=1.35; }
      if(type==="floater"){ baseHp=30; baseDmg=10; spd=2.0; range=14; kind="ranged"; flying=true; yOff=1.6; }
      if(type==="shardling"){ baseHp=26; baseDmg=9; spd=2.2; range=1.2; kind="melee"; }
      if(type==="imp"){ baseHp=24; baseDmg=9; spd=2.6; range=1.3; kind="melee"; }
      if(type==="brute"){ baseHp=72; baseDmg=15; spd=1.7; range=1.8; kind="melee"; }
      if(type==="mortar"){ baseHp=34; baseDmg=12; spd=1.7; range=18; kind="mortar"; }

      const hp = Math.round(baseHp * (1 + 0.14*(level-1)));
      const dmg = Math.round(baseDmg * (1 + 0.09*(level-1)));
      return { hp, dmg, spd: spd*(1+0.02*(level-1)), range, flying, yOff, kind };
    }

    function spawnEnemy(type, x, z, regId){
      const st = enemyStats(type, me.level);
      const mesh = makeEnemyMesh(type, regId);
      const y = heightAt(x,z, regId) + (st.flying ? (1.5+st.yOff) : 0.0);
      mesh.position.set(x, y, z);

      const e = {
        id: nextEnemyId++,
        type,
        regId,
        mesh,
        x, z,
        yBase: heightAt(x,z, regId),
        yOff: st.flying ? (1.4+st.yOff) : 0.0,
        flying: st.flying,
        hp: st.hp,
        maxHp: st.hp,
        spd: st.spd,
        dmg: st.dmg,
        range: st.range,
        kind: st.kind,

        state: "chase", // chase -> windup -> attack -> recover
        cd: 0,
        wind: 0,
        tele: null, // telegraph visual mesh (circle/marker)
        bob: Math.random()*10,
      };

      world.add(mesh);
      enemies.push(e);
      return e;
    }

    function spawnPack(){
      const reg = regionAt(me.x, me.z);
      const cap = ENEMY_CAP_BASE + Math.floor(me.level*1.35);
      if(enemies.length >= cap) return false;

      // require travel between spawns
      if(travelMeter < 22) return false;
      if(spawnCooldown > 0) return false;

      const rnd = xorshift32(((worldSeed^0xBADC0DE) + (me.level*99173)|0) ^ ((Date.now()/1000)|0));
      const packSize = clamp(3 + (rnd()*4|0) + Math.floor(me.level*0.22), 3, 14);

      // spawn 48..86 units away
      const dist = 48 + rnd()*38;
      const ang = rnd()*Math.PI*2;
      const cx = me.x + Math.cos(ang)*dist;
      const cz = me.z + Math.sin(ang)*dist;

      // keep inside world
      const rr = Math.hypot(cx,cz);
      if(rr > WORLD_RADIUS-40) return false;

      const types = reg.enemies;
      for(let i=0;i<packSize;i++){
        const t = types[(rnd()*types.length)|0];
        const a = rnd()*Math.PI*2;
        const r = 3 + rnd()*8; // spacing
        const x = cx + Math.cos(a)*r;
        const z = cz + Math.sin(a)*r;
        spawnEnemy(t, x, z, reg.id);
      }

      travelMeter = 0;
      spawnCooldown = 4.5 + rnd()*2.2;
      return true;
    }

    // ============================================================
    // Player firing / aim cone
    // ============================================================
    function cameraForward(out){
      out.set(0,0,-1).applyEuler(camera.rotation).normalize();
      return out;
    }

    function pickTarget(maxRange){
      const fwd = cameraForward(_v1);
      const ox = me.x, oy = me.y, oz = me.z;
      const range2 = maxRange*maxRange;

      let best = null;
      let bestScore = 1e18;

      const aimCone = 0.15; // radians-ish cone feel
      for(const e of enemies){
        if(e.hp<=0) continue;
        const ex = e.mesh.position.x;
        const ez = e.mesh.position.z;
        const ey = e.mesh.position.y + (e.flying?0.15:0.65);

        const dx = ex-ox, dy = ey-oy, dz = ez-oz;
        const d2 = dx*dx + dy*dy + dz*dz;
        if(d2 > range2) continue;

        const len = Math.sqrt(d2);
        const vx = dx/len, vy=dy/len, vz=dz/len;
        const dot = fwd.x*vx + fwd.y*vy + fwd.z*vz;
        const ang = Math.acos(clamp(dot, -1, 1));
        if(ang > aimCone) continue;

        // prefer smaller angle, then distance
        const score = ang*2.2 + len*0.02;
        if(score < bestScore){
          bestScore = score;
          best = e;
        }
      }
      return best;
    }

    function spawnBolt(fromX, fromY, fromZ, toX, toY, toZ, cfg, isSplinter=false){
      const dir = _v2.set(toX-fromX, toY-fromY, toZ-fromZ);
      const len = dir.length();
      if(len<=0.0001) return;
      dir.multiplyScalar(1/len);

      const speed = isSplinter ? 22 : 26;
      const vx = dir.x*speed, vy = dir.y*speed, vz = dir.z*speed;

      const mesh = new THREE.Mesh(GEO.bolt, new THREE.MeshStandardMaterial({
        color: cfg.color,
        emissive: cfg.color,
        emissiveIntensity: 1.2,
        roughness: 0.25,
        metalness: 0.05
      }));
      mesh.position.set(fromX, fromY, fromZ);
      world.add(mesh);

      projectiles.push({
        mesh,
        x:fromX, y:fromY, z:fromZ,
        vx, vy, vz,
        life: 1.6,
        rad: 0.45,
        dmg: cfg.dmg * me.damageMul * (isSplinter?0.65:1.0),
        from:"player",
        kind:"bolt",
        color: cfg.color,
        splinter: !!cfg.splinter && !isSplinter,
        explode: !!cfg.explode,
        aoe: cfg.explode ? 2.4 : 0.0
      });
    }

    // beam visual
    const beamGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
    const beamMat = new THREE.LineBasicMaterial({ color:0xfff3a0, transparent:true, opacity:0.85 });
    const beamLine = new THREE.Line(beamGeo, beamMat);
    beamLine.visible = false;
    world.add(beamLine);

    // wave visual pool
    const waves = []; // {mesh, life, maxLife, range, dmg}
    function spawnWave(cfg){
      const ring = new THREE.Mesh(
        new THREE.TorusGeometry(0.35, 0.08, 10, 26),
        new THREE.MeshStandardMaterial({
          color: cfg.color,
          emissive: cfg.color,
          emissiveIntensity: 1.0,
          transparent:true,
          opacity:0.8,
          roughness:0.3
        })
      );
      ring.position.set(me.x, heightAt(me.x,me.z,regionAt(me.x,me.z).id)+0.15, me.z);
      ring.rotation.x = Math.PI/2;
      ring.rotation.z = -me.yaw; // face forward-ish
      world.add(ring);
      waves.push({
        mesh:ring,
        life:0,
        maxLife:0.55,
        maxR: cfg.range * me.rangeMul,
        dmg: cfg.dmg * me.damageMul,
        hit: new Set()
      });
    }

    // ============================================================
    // Enemy attacks + telegraphs
    // ============================================================
    function makeTeleCircle(color=0xff2a2a){
      const m = new THREE.Mesh(
        new THREE.RingGeometry(0.6, 0.75, 28),
        new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.85, side:THREE.DoubleSide })
      );
      m.rotation.x = -Math.PI/2;
      return m;
    }

    function makeMarker(color=0xff3b1a){
      const m = new THREE.Mesh(
        new THREE.RingGeometry(0.7, 1.0, 28),
        new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.9, side:THREE.DoubleSide })
      );
      m.rotation.x = -Math.PI/2;
      return m;
    }

    function spawnEnemyBolt(e, toX, toY, toZ){
      const fromX = e.mesh.position.x;
      const fromZ = e.mesh.position.z;
      const fromY = e.mesh.position.y + (e.flying?0.2:0.9);

      const dir = _v2.set(toX-fromX, toY-fromY, toZ-fromZ);
      const len = dir.length(); if(len<=0.0001) return;
      dir.multiplyScalar(1/len);

      const speed = 18;
      const mesh = new THREE.Mesh(GEO.ember, new THREE.MeshStandardMaterial({
        color: 0xef4444,
        emissive: 0xef4444,
        emissiveIntensity: 1.3,
        roughness:0.25
      }));
      mesh.position.set(fromX, fromY, fromZ);
      world.add(mesh);

      projectiles.push({
        mesh,
        x:fromX, y:fromY, z:fromZ,
        vx:dir.x*speed, vy:dir.y*speed, vz:dir.z*speed,
        life: 2.2,
        rad: 0.55,
        dmg: e.dmg,
        from:"enemy",
        kind:"bolt",
        color:0xef4444,
        splinter:false,
        explode:false,
        aoe:0
      });
    }

    function spawnMortar(e, targetX, targetZ){
      // marker first
      const reg = regionAt(targetX, targetZ);
      const marker = makeMarker(0xff3b1a);
      marker.position.set(targetX, heightAt(targetX,targetZ, reg.id)+0.05, targetZ);
      world.add(marker);

      // schedule a projectile that "falls" after delay
      const delay = 0.95;
      e.tele = { marker, t:0, delay, x:targetX, z:targetZ };
    }

    function explodeAt(x,y,z, rad, dmg, from="player"){
      // quick visual: expanding sphere
      const s = new THREE.Mesh(
        new THREE.SphereGeometry(0.35, 10, 10),
        new THREE.MeshStandardMaterial({
          color: 0xff3b1a,
          emissive: 0xff3b1a,
          emissiveIntensity: 1.6,
          transparent:true,
          opacity:0.75,
          roughness:0.25
        })
      );
      s.position.set(x,y,z);
      world.add(s);
      projectiles.push({
        mesh:s,
        x,y,z,
        vx:0,vy:0,vz:0,
        life:0.22,
        rad:rad,
        dmg:dmg,
        from,
        kind:"explosion",
        aoe:rad,
        explode:false,
        splinter:false
      });

      const r2 = rad*rad;

      if(from==="player"){
        for(const e of enemies){
          if(e.hp<=0) continue;
          const ex=e.mesh.position.x, ez=e.mesh.position.z, ey=e.mesh.position.y+(e.flying?0.2:0.7);
          const d2 = (ex-x)*(ex-x) + (ez-z)*(ez-z) + (ey-y)*(ey-y);
          if(d2<=r2){
            const fall = 1 - Math.sqrt(d2)/rad;
            dealDamageEnemy(e, dmg*fall);
          }
        }
      }else{
        const px=me.x, pz=me.z, py=me.y;
        const d2 = (px-x)*(px-x)+(pz-z)*(pz-z)+(py-y)*(py-y);
        if(d2<=r2){
          const fall = 1 - Math.sqrt(d2)/rad;
          takeDamage(dmg*fall, "Explosion");
        }
      }
    }

    // ============================================================
    // Drops / inventory
    // ============================================================
    const MAT_COL = {
      iron:   0x93c5fd,
      hide:   0xf59e0b,
      essence:0x22c55e,
      crystal:0xff3ad7,
      ember:  0xff3b1a
    };

    function dropFromEnemy(e){
      const reg = regionAt(e.x, e.z);
      const dropsHere = reg.drops;
      // 1-2 items
      const rnd = xorshift32((worldSeed ^ (e.id*2654435761))|0);
      const count = (rnd()<0.65) ? 1 : 2;

      for(let i=0;i<count;i++){
        const matName = dropsHere[(rnd()*dropsHere.length)|0];
        const c = MAT_COL[matName] || 0xffffff;

        const m = new THREE.Mesh(GEO.drop, MAT.drop.clone());
        m.material.color.setHex(c);
        m.material.emissive.setHex(c);
        m.material.emissiveIntensity = 0.8;
        m.material.roughness = 0.35;

        const y = heightAt(e.x, e.z, reg.id);
        const ox = (rnd()-0.5)*1.6, oz=(rnd()-0.5)*1.6;
        m.position.set(e.x+ox, y+0.35, e.z+oz);
        world.add(m);

        drops.push({ x:e.x+ox, y:y+0.35, z:e.z+oz, mesh:m, mat:matName, spin: rnd()*10 });
      }
    }

    function pickupDrops(dt){
      for(let i=drops.length-1;i>=0;i--){
        const d = drops[i];
        d.spin += dt*3.2;
        d.mesh.rotation.y = d.spin;
        d.mesh.position.y = d.y + Math.sin(d.spin*1.2)*0.08;

        const dx = me.x - d.mesh.position.x;
        const dz = me.z - d.mesh.position.z;
        const dy = me.y - d.mesh.position.y;
        if(dx*dx+dz*dz+dy*dy < 1.55*1.55){
          me.mats[d.mat] = (me.mats[d.mat]||0) + 1;
          showToast(`+1 ${d.mat}`);
          world.remove(d.mesh);
          drops.splice(i,1);
        }
      }
    }

    // ============================================================
    // Damage / XP / leveling
    // ============================================================
    let alive = true;

    function takeDamage(dmg, why="Hit"){
      if(!alive) return;
      me.hp -= dmg;
      me.hp = Math.max(0, me.hp);
      if(me.hp <= 0){
        alive = false;
        overlayDead.style.opacity = "1";
        showToast("üíÄ You fell. Load a save or start a new run.", 2800);
        openDeathModal();
      }
    }

    function gainXp(xp){
      me.xp += xp;
      while(me.xp >= me.nextXp){
        me.xp -= me.nextXp;
        me.level++;
        me.nextXp = Math.round(18 + me.level*14 + me.level*me.level*0.8);
        // small heal on level
        me.hp = Math.min(me.maxHp, me.hp + 12);
        showToast(`‚≠ê Level ${me.level}! Choose an upgrade.`);
        saveGame(true);
        openLevelUpModal();
      }
    }

    function dealDamageEnemy(e, dmg){
      e.hp -= dmg;
      if(e.hp <= 0){
        e.hp = 0;
        // cleanup telegraphs
        if(e.tele?.marker){ world.remove(e.tele.marker); }
        if(e.tele?.ring){ world.remove(e.tele.ring); }
        // drops + xp
        dropFromEnemy(e);
        gainXp(6 + Math.floor(me.level*0.8));
      }
    }

    // ============================================================
    // Abilities (unlocked via level-up options)
    // ============================================================
    function tickAbilities(dt){
      if(!alive) return;
      // Poison aura: purple hue and drain near you
      if(me.abil.poisonAura){
        const rad = 6.0;
        const r2 = rad*rad;
        for(const e of enemies){
          if(e.hp<=0) continue;
          const dx = e.mesh.position.x-me.x;
          const dz = e.mesh.position.z-me.z;
          const d2 = dx*dx+dz*dz;
          if(d2<=r2){
            // tint enemy
            e.mesh.traverse((o)=>{
              if(o.material && o.material.emissive){
                o.material.emissive.setHex(0x7c3aed);
                o.material.emissiveIntensity = 0.7;
              }
            });
            dealDamageEnemy(e, dt * (3.0 + 0.35*me.level) );
          }
        }
      }

      // Life grip: periodically tether a random enemy and steal health
      if(me.abil.lifeGrip){
        me.lifeGripT -= dt;
        if(me.lifeGripT <= 0){
          me.lifeGripT = 5.2 + Math.random()*2.0;
          const candidates = enemies.filter(e=>e.hp>0 && dist2(me.x,me.z,e.mesh.position.x,e.mesh.position.z) < 22*22);
          if(candidates.length){
            const e = candidates[(Math.random()*candidates.length)|0];
            const steal = 8 + me.level*0.45;
            dealDamageEnemy(e, steal);
            me.hp = Math.min(me.maxHp, me.hp + steal*0.45);

            // line effect
            const pts = [new THREE.Vector3(me.x, me.y, me.z), new THREE.Vector3(e.mesh.position.x, e.mesh.position.y+0.6, e.mesh.position.z)];
            const geo = new THREE.BufferGeometry().setFromPoints(pts);
            const line = new THREE.Line(geo, new THREE.LineBasicMaterial({ color:0x7c3aed, transparent:true, opacity:0.9 }));
            world.add(line);
            projectiles.push({ mesh:line, x:0,y:0,z:0, vx:0,vy:0,vz:0, life:0.16, rad:0, dmg:0, from:"fx", kind:"fxLine" });
          }
        }
      }

      // Meteorite: periodically strike near a random enemy
      if(me.abil.meteorite){
        me.meteorT -= dt;
        if(me.meteorT <= 0){
          me.meteorT = 6.8 + Math.random()*2.8;
          const candidates = enemies.filter(e=>e.hp>0 && dist2(me.x,me.z,e.mesh.position.x,e.mesh.position.z) < 36*36);
          if(candidates.length){
            const e = candidates[(Math.random()*candidates.length)|0];
            const tx = e.mesh.position.x + (Math.random()-0.5)*2.0;
            const tz = e.mesh.position.z + (Math.random()-0.5)*2.0;
            const reg = regionAt(tx,tz);
            const gy = heightAt(tx,tz, reg.id);

            const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(0.35,0), new THREE.MeshStandardMaterial({
              color:0xffd37a,
              emissive:0xff3b1a,
              emissiveIntensity:1.4,
              roughness:0.35
            }));
            rock.position.set(tx, gy+18, tz);
            world.add(rock);
            projectiles.push({
              mesh:rock,
              x:tx, y:gy+18, z:tz,
              vx:0, vy:-26, vz:0,
              life:1.2,
              rad:0.5,
              dmg:0,
              from:"fx",
              kind:"meteor",
              targetY: gy+0.3,
              aoe: 3.2,
              hitDmg: 24 + me.level*1.2
            });
          }
        }
      }

      // Firebolt: cooldown; fires at target you're facing, big explosion
      if(me.abil.firebolt){
        me.fireboltCd -= dt;
        if(me.fireboltCd <= 0){
          const t = pickTarget(24*me.rangeMul);
          if(t){
            me.fireboltCd = 6.5;
            showToast("üî• Firebolt!");

            const fx = new THREE.Mesh(GEO.ember, new THREE.MeshStandardMaterial({
              color:0xff3b1a, emissive:0xff3b1a, emissiveIntensity:1.8, roughness:0.25
            }));
            const fromX=me.x, fromY=me.y, fromZ=me.z;
            const toX=t.mesh.position.x, toY=t.mesh.position.y+0.65, toZ=t.mesh.position.z;
            fx.position.set(fromX,fromY,fromZ);
            world.add(fx);

            const dir = _v2.set(toX-fromX, toY-fromY, toZ-fromZ);
            const len = dir.length() || 1;
            dir.multiplyScalar(1/len);
            const speed=34;

            projectiles.push({
              mesh:fx,
              x:fromX, y:fromY, z:fromZ,
              vx:dir.x*speed, vy:dir.y*speed, vz:dir.z*speed,
              life:1.1,
              rad:0.8,
              dmg: 0,
              from:"player",
              kind:"firebolt",
              aoe: 4.2,
              hitDmg: 32 + me.level*1.6
            });
          }
        }
      }
    }

    // ============================================================
    // Modals (forge / level-up / death)
    // ============================================================
    let uiMode = "none"; // none | forge | level | death
    let paused = false;

    function openModal(html){
      modal.innerHTML = html;
      modalShade.style.opacity = "1";
      modalShade.style.pointerEvents = "auto";
      modal.style.opacity = "1";
      modal.style.pointerEvents = "auto";
    }
    function closeModal(){
      uiMode = "none";
      paused = false;
      modalShade.style.opacity = "0";
      modalShade.style.pointerEvents = "none";
      modal.style.opacity = "0";
      modal.style.pointerEvents = "none";
      modal.innerHTML = "";
    }

    modalShade.addEventListener("click", ()=>{
      // click outside closes forge; level-up/death shouldn't close
      if(uiMode==="forge") closeModal();
    });

    function canAfford(req){
      for(const k in req){
        if((me.mats[k]||0) < req[k]) return false;
      }
      return true;
    }
    function payReq(req){
      for(const k in req){ me.mats[k] -= req[k]; }
    }

    function openForgeModal(){
      uiMode = "forge";
      paused = true;

      const inv = Object.entries(me.mats)
        .map(([k,v])=>`<span class="chip">${k}: <b>${v}</b></span>`)
        .join("");

      const owned = Array.from(me.ownedWeapons)
        .map(w=>`<span class="chip">üó°Ô∏è ${w}${w===me.weapon ? " (equipped)" : ""}</span>`)
        .join("");

      const recipesHtml = RECIPES.map((r)=>{
        const ok = canAfford(r.req);
        const reqHtml = Object.entries(r.req).map(([k,v])=>`<span class="reqItem">${k} √ó${v}</span>`).join("");
        const desc = (r.type==="weapon")
          ? (WEAPONS[r.name]?.desc || "Weapon")
          : "Forge upgrade";
        const extra = (r.type==="weapon")
          ? `<div class="desc"><b>Type:</b> ${WEAPONS[r.name].kind.toUpperCase()} ‚Ä¢ <b>Range:</b> ${WEAPONS[r.name].range ?? WEAPONS[r.name].range} ‚Ä¢ <b>Dmg:</b> ${WEAPONS[r.name].dmg ?? (WEAPONS[r.name].dps+" DPS")}</div>`
          : `<div class="desc">Permanent upgrade when crafted.</div>`;

        return `
          <div class="card">
            <div class="name">‚öíÔ∏è ${r.name}</div>
            <div class="desc">${desc}</div>
            ${extra}
            <div class="req">${reqHtml}</div>
            <div class="rowBtns">
              <button data-craft="${r.name}" ${ok ? "" : "disabled"}>${ok ? "Craft" : "Need Mats"}</button>
              ${r.type==="weapon" && me.ownedWeapons.has(r.name) ? `<button class="secondary" data-equip="${r.name}">Equip</button>` : ""}
            </div>
          </div>
        `;
      }).join("");

      openModal(`
        <h2>‚öíÔ∏è Forge</h2>
        <div class="sub">Paused. Craft weapons/upgrades with materials you collected.</div>
        <div class="grid2">
          <div class="panel">
            <div class="panelTitle">üì¶ Inventory <span class="muted">(materials)</span></div>
            <div class="chipRow">${inv || `<span class="muted">No materials yet.</span>`}</div>
            <div style="height:10px"></div>
            <div class="panelTitle">üó°Ô∏è Owned Weapons</div>
            <div class="chipRow">${owned || `<span class="muted">None</span>`}</div>
            <div style="height:10px"></div>
            <div class="muted" style="font-size:12px; line-height:1.3">
              Tip: Higher-level regions tend to spawn tougher packs, but also better drops.
            </div>
            <div style="height:10px"></div>
            <button class="btn secondary" id="closeForgeBtn" type="button" style="pointer-events:auto">Close (E / ESC)</button>
          </div>
          <div class="panel">
            <div class="panelTitle">üõ†Ô∏è Recipes</div>
            <div class="recipes">${recipesHtml}</div>
          </div>
        </div>
      `);

      $("closeForgeBtn").addEventListener("click", closeModal);

      modal.querySelectorAll("[data-craft]").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const name = btn.getAttribute("data-craft");
          const rec = RECIPES.find(r=>r.name===name);
          if(!rec) return;
          if(!canAfford(rec.req)) return;

          payReq(rec.req);

          if(rec.type==="weapon"){
            me.ownedWeapons.add(name);
            me.weapon = name;
            showToast(`üó°Ô∏è Crafted & equipped: ${name}`);
          }else{
            rec.apply?.(me);
            showToast(`‚ú® Crafted: ${name}`);
          }
          saveGame(true);
          openForgeModal(); // refresh
        });
      });

      modal.querySelectorAll("[data-equip]").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const name = btn.getAttribute("data-equip");
          if(!me.ownedWeapons.has(name)) return;
          me.weapon = name;
          showToast(`üó°Ô∏è Equipped: ${name}`);
          saveGame(true);
          openForgeModal();
        });
      });
    }

    function openLevelUpModal(){
      uiMode = "level";
      paused = true;

      const pool = [];

      pool.push({
        title:"‚ù§Ô∏è More Health",
        sub:`+20 Max HP (and heal 20)`,
        apply:()=>{ me.maxHp += 20; me.hp = Math.min(me.maxHp, me.hp+20); }
      });
      pool.push({
        title:"üó°Ô∏è More Damage",
        sub:`+15% damage`,
        apply:()=>{ me.damageMul *= 1.15; }
      });
      pool.push({
        title:"üéØ More Range",
        sub:`+12% weapon range`,
        apply:()=>{ me.rangeMul *= 1.12; }
      });
      pool.push({
        title:"üëü More Speed",
        sub:`+12% movement speed`,
        apply:()=>{ me.speedMul *= 1.12; }
      });

      // abilities (only if not owned)
      if(!me.abil.poisonAura){
        pool.push({
          title:"üü£ Poison Aura",
          sub:"Nearby enemies gain a purple hue and slowly lose health.",
          apply:()=>{ me.abil.poisonAura=true; }
        });
      }
      if(!me.abil.lifeGrip){
        pool.push({
          title:"üß¨ Life Grip",
          sub:"Periodically tethers a random enemy, steals health, heals you.",
          apply:()=>{ me.abil.lifeGrip=true; me.lifeGripT = 2.0; }
        });
      }
      if(!me.abil.meteorite){
        pool.push({
          title:"‚òÑÔ∏è Meteorite",
          sub:"Periodically calls down explosive meteorites on enemies.",
          apply:()=>{ me.abil.meteorite=true; me.meteorT = 2.6; }
        });
      }
      if(!me.abil.firebolt){
        pool.push({
          title:"üî• Firebolt",
          sub:"On cooldown, fires a bolt at the enemy you‚Äôre aiming at and explodes.",
          apply:()=>{ me.abil.firebolt=true; me.fireboltCd = 2.0; }
        });
      }

      // pick 3
      const rnd = xorshift32((worldSeed ^ (me.level*98731) ^ ((Date.now()/1000)|0))|0);
      const picks = [];
      const used = new Set();
      while(picks.length<3 && used.size<pool.length){
        const i = (rnd()*pool.length)|0;
        if(used.has(i)) continue;
        used.add(i);
        picks.push(pool[i]);
      }

      const cards = picks.map((p, idx)=>`
        <div class="card" style="min-height:140px">
          <div class="name">${p.title}</div>
          <div class="desc">${p.sub}</div>
          <div class="rowBtns">
            <button data-pick="${idx}">Choose</button>
          </div>
        </div>
      `).join("");

      openModal(`
        <h2>‚≠ê Level Up ‚Äî Choose 1</h2>
        <div class="sub">Game paused. Pick one upgrade to continue.</div>
        <div class="panel">
          <div class="recipes" style="grid-template-columns:repeat(3, minmax(0, 1fr))">${cards}</div>
        </div>
      `);

      modal.querySelectorAll("[data-pick]").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const idx = +btn.getAttribute("data-pick");
          picks[idx]?.apply?.();
          saveGame(true);
          closeModal();
        });
      });
    }

    function openDeathModal(){
      uiMode = "death";
      paused = true;
      openModal(`
        <h2>üíÄ You fell</h2>
        <div class="sub">Load your save, or start a fresh run.</div>
        <div class="panel">
          <div class="row" style="justify-content:flex-start">
            <button class="btn secondary" id="deathLoad">‚¨Ü Load Save</button>
            <button class="btn" id="deathNew">üü© New Run</button>
          </div>
          <div class="muted" style="margin-top:10px; font-size:12px">
            Tip: Use forges often ‚Äî crafting upgrades makes later packs much easier.
          </div>
        </div>
      `);
      $("deathLoad").addEventListener("click", ()=>{
        const ok = loadGame();
        if(!ok) resetRun(true);
        alive = true;
        overlayDead.style.opacity = "0";
        closeModal();
      });
      $("deathNew").addEventListener("click", ()=>{
        resetRun(true);
        alive = true;
        overlayDead.style.opacity = "0";
        closeModal();
      });
    }

    // ============================================================
    // Forge open logic
    // ============================================================
    function tryOpenForge(){
      if(paused || !alive) return;
      const nf = nearestForge();
      if(!nf) return;
      if(nf.d <= 3.2){
        openForgeModal();
      }
    }

    // ============================================================
    // Movement / camera / world boundary
    // ============================================================
    function tickMove(dt){
      if(phase!=="play") return;

      if(mobile.enabled && !paused){
        const turnRate = 2.8;
        const lookRate = 2.2;
        me.yaw   -= mobile.lookX * turnRate * dt;
        me.pitch -= mobile.lookY * lookRate * dt;
        me.pitch = clamp(me.pitch, -1.32, 1.32);
      }

      if(paused || !alive){
        // keep camera attached
        const reg = regionAt(me.x, me.z);
        const gy = heightAt(me.x, me.z, reg.id);
        me.y = gy + PLAYER_H;
        camera.position.set(me.x, me.y, me.z);
        camera.rotation.set(me.pitch, me.yaw, 0, "YXZ");
        return;
      }

      const forward = (keys["w"]||keys["arrowup"]) ? 1 : 0;
      const back    = (keys["s"]||keys["arrowdown"]) ? 1 : 0;
      const left    = (keys["a"]||keys["arrowleft"]) ? 1 : 0;
      const right   = (keys["d"]||keys["arrowright"]) ? 1 : 0;

      let mx = right - left;
      let mz = forward - back;

      const sprint = !!keys["shift"];
      const baseSpeed = sprint ? 5.6 : 4.0;
      const speed = baseSpeed * me.speedMul;

      if(mobile.enabled){
        mx = mobile.moveX;
        mz = -mobile.moveY;
      }

      const mlen = Math.hypot(mx, mz);
      if(mlen>0){ mx/=mlen; mz/=mlen; }

      const sy = Math.sin(me.yaw), cy = Math.cos(me.yaw);
      const targetVx = (mx*cy - mz*sy)*speed;
      const targetVz = (-mx*sy - mz*cy)*speed;

      const accel = 18;
      me.vx += (targetVx - me.vx) * Math.min(1, accel*dt);
      me.vz += (targetVz - me.vz) * Math.min(1, accel*dt);

      // gravity + jump
      const reg = regionAt(me.x, me.z);
      const groundY = heightAt(me.x, me.z, reg.id);

      if(keys[" "] && me.grounded){
        me.vy = 3.8;
        me.grounded = false;
      }

      me.vy -= GRAVITY*dt;
      me.y += me.vy*dt;

      const desiredGround = groundY + PLAYER_H;
      if(me.y <= desiredGround){
        me.y = desiredGround;
        me.vy = 0;
        me.grounded = true;
      }

      const nx = me.x + me.vx*dt;
      const nz = me.z + me.vz*dt;

      me.x = nx; me.z = nz;

      // world boundary push-back
      const rr = Math.hypot(me.x, me.z);
      if(rr > WORLD_RADIUS - 2){
        const k = (WORLD_RADIUS - 2) / rr;
        me.x *= k; me.z *= k;
        me.vx *= 0.2; me.vz *= 0.2;
        showToast("üß± World boundary.");
      }

      // travel meter for spawning pacing
      travelMeter += Math.hypot(me.vx*dt, me.vz*dt);

      camera.position.set(me.x, me.y, me.z);
      camera.rotation.set(me.pitch, me.yaw, 0, "YXZ");
    }

    // ============================================================
    // Enemy update
    // ============================================================
    function tickEnemies(dt, now){
      if(paused || !alive) return;

      // soft separation to prevent clumping
      const sepR = 2.5;
      const sepR2 = sepR*sepR;

      for(const e of enemies){
        if(e.hp<=0) continue;

        // update base ground y and flight bob
        const reg = regionAt(e.mesh.position.x, e.mesh.position.z);
        e.yBase = heightAt(e.mesh.position.x, e.mesh.position.z, reg.id);

        e.bob += dt * (e.flying ? 2.4 : 1.5);
        const flyY = e.flying ? (e.yBase + e.yOff + Math.sin(e.bob)*0.18) : (e.yBase + 0.0);
        e.mesh.position.y = flyY;

        // health bar faces camera
        const bar = e.mesh.userData.hpBar;
        if(bar){
          bar.lookAt(camera.position);
          const t = clamp(e.hp / e.maxHp, 0, 1);
          bar.userData.fg.scale.x = t;
          bar.userData.fg.position.x = -0.525 + (t*0.525);
          // color shift
          const col = (t>0.55) ? 0x22c55e : (t>0.25 ? 0xeab308 : 0xef4444);
          bar.userData.fg.material.color.setHex(col);
        }

        // remove poison tint fade (if aura not affecting)
        if(!me.abil.poisonAura){
          e.mesh.traverse((o)=>{
            if(o.material && o.material.emissive){
              // slight region emissive baseline
              o.material.emissiveIntensity = Math.max(0.25, o.material.emissiveIntensity*0.94);
            }
          });
        }

        // state machine
        e.cd -= dt;

        // separation force
        let rx=0, rz=0;
        for(const o of enemies){
          if(o===e || o.hp<=0) continue;
          const dx = e.mesh.position.x - o.mesh.position.x;
          const dz = e.mesh.position.z - o.mesh.position.z;
          const d2 = dx*dx + dz*dz;
          if(d2>0.0001 && d2<sepR2){
            const d = Math.sqrt(d2);
            const push = (sepR - d)/sepR;
            rx += (dx/d)*push;
            rz += (dz/d)*push;
          }
        }

        // chase player
        const px = me.x, pz = me.z;
        const ex = e.mesh.position.x, ez = e.mesh.position.z;
        const dx = px-ex, dz = pz-ez;
        const d = Math.hypot(dx,dz) || 1;

        // for ranged, stop a bit farther
        const want = (e.kind==="melee") ? 1.2 : (e.kind==="mortar" ? 14.5 : 10.5);
        const go = (d > want) ? 1 : 0;

        // attacks
        if(e.state==="chase"){
          // decide to attack
          if(e.cd <= 0){
            if(e.kind==="melee" && d <= e.range+0.6){
              e.state="windup";
              e.wind = 0.55;
              e.cd = 1.0 + Math.random()*0.6;
              const ring = makeTeleCircle(0xff2a2a);
              ring.position.set(ex, e.yBase+0.04, ez);
              world.add(ring);
              e.tele = { ring };
            }else if(e.kind==="ranged" && d <= e.range){
              e.state="windup";
              e.wind = 0.65;
              e.cd = 1.2 + Math.random()*0.8;
              const ring = makeTeleCircle(0x60a5fa);
              ring.position.set(ex, e.yBase+0.04, ez);
              ring.scale.set(0.8,0.8,0.8);
              world.add(ring);
              e.tele = { ring };
            }else if(e.kind==="mortar" && d <= e.range){
              e.state="windup";
              e.wind = 0.9;
              e.cd = 2.2 + Math.random()*0.9;
              // telegraph landing zone near player's current position
              const tx = me.x + (Math.random()-0.5)*2.2;
              const tz = me.z + (Math.random()-0.5)*2.2;
              spawnMortar(e, tx, tz);
            }
          }
        }

        if(e.state==="windup"){
          e.wind -= dt;
          // animate telegraph
          if(e.tele?.ring){
            e.tele.ring.position.set(e.mesh.position.x, e.yBase+0.04, e.mesh.position.z);
            const p = 1.0 + (0.3*Math.sin(now*0.02));
            e.tele.ring.scale.set(p,p,p);
            e.tele.ring.material.opacity = 0.55 + 0.35*Math.sin(now*0.014);
          }
          if(e.wind <= 0){
            e.state="attack";
          }
        }

        if(e.state==="attack"){
          // execute
          if(e.kind==="melee"){
            // if still close, hit
            if(d <= e.range+0.9){
              takeDamage(e.dmg, "Melee");
            }
            if(e.tele?.ring){ world.remove(e.tele.ring); }
            e.tele = null;
            e.state="recover";
            e.wind = 0.25;

          }else if(e.kind==="ranged"){
            spawnEnemyBolt(e, me.x, me.y, me.z);
            if(e.tele?.ring){ world.remove(e.tele.ring); }
            e.tele = null;
            e.state="recover";
            e.wind = 0.25;

          }else if(e.kind==="mortar"){
            // handled via e.tele marker tick below
            e.state="recover";
            e.wind = 0.30;
          }
        }

        if(e.state==="recover"){
          e.wind -= dt;
          if(e.wind<=0) e.state="chase";
        }

        // mortar tele marker tick
        if(e.tele?.marker){
          e.tele.t += dt;
          const p = smoothstep(e.tele.t / e.tele.delay);
          e.tele.marker.material.opacity = 0.25 + 0.70*p;
          e.tele.marker.scale.set(1.0 + 0.6*p, 1.0 + 0.6*p, 1.0);

          if(e.tele.t >= e.tele.delay){
            const tx = e.tele.x, tz = e.tele.z;
            const reg2 = regionAt(tx,tz);
            const gy = heightAt(tx,tz, reg2.id)+0.25;
            world.remove(e.tele.marker);
            e.tele.marker = null;

            explodeAt(tx, gy, tz, 3.2, e.dmg*1.15, "enemy");
            e.tele = null;
          }
        }

        // movement integrate (with separation)
        const dirx = dx/d, dirz = dz/d;
        const vx = (dirx*go + rx*0.9) * e.spd;
        const vz = (dirz*go + rz*0.9) * e.spd;

        e.mesh.position.x += vx*dt;
        e.mesh.position.z += vz*dt;

        // keep enemies in world
        const rr2 = e.mesh.position.x*e.mesh.position.x + e.mesh.position.z*e.mesh.position.z;
        if(rr2 > (WORLD_RADIUS-12)*(WORLD_RADIUS-12)){
          const rr = Math.sqrt(rr2)||1;
          const k = (WORLD_RADIUS-12)/rr;
          e.mesh.position.x *= k;
          e.mesh.position.z *= k;
        }
      }

      // remove dead enemies (cleanup)
      for(let i=enemies.length-1;i>=0;i--){
        const e = enemies[i];
        if(e.hp>0) continue;
        world.remove(e.mesh);
        enemies.splice(i,1);
      }
    }

    // ============================================================
    // Projectiles update (player + enemy + fx)
    // ============================================================
    function tickProjectiles(dt){
      if(paused) return;

      for(let i=projectiles.length-1;i>=0;i--){
        const p = projectiles[i];
        p.life -= dt;

        if(p.kind==="explosion"){
          // expand & fade
          const s = 1 + (1 - (p.life/0.22))*3.2;
          p.mesh.scale.set(s,s,s);
          p.mesh.material.opacity = Math.max(0, p.life/0.22);
          if(p.life<=0){
            world.remove(p.mesh);
            projectiles.splice(i,1);
          }
          continue;
        }

        if(p.kind==="fxLine"){
          p.mesh.material.opacity *= 0.85;
          if(p.life<=0){
            world.remove(p.mesh);
            projectiles.splice(i,1);
          }
          continue;
        }

        if(p.kind==="meteor"){
          p.x += p.vx*dt;
          p.y += p.vy*dt;
          p.z += p.vz*dt;
          p.mesh.position.set(p.x,p.y,p.z);
          p.mesh.rotation.x += dt*4.2;
          p.mesh.rotation.y += dt*3.1;
          if(p.y <= p.targetY){
            explodeAt(p.x, p.targetY, p.z, p.aoe, p.hitDmg, "player");
            world.remove(p.mesh);
            projectiles.splice(i,1);
          }else if(p.life<=0){
            world.remove(p.mesh);
            projectiles.splice(i,1);
          }
          continue;
        }

        if(p.kind==="firebolt"){
          p.x += p.vx*dt; p.y += p.vy*dt; p.z += p.vz*dt;
          p.mesh.position.set(p.x,p.y,p.z);
          // collision with enemy
          let hit = null;
          for(const e of enemies){
            if(e.hp<=0) continue;
            const ex=e.mesh.position.x, ez=e.mesh.position.z, ey=e.mesh.position.y+(e.flying?0.15:0.65);
            const d2 = (ex-p.x)*(ex-p.x)+(ez-p.z)*(ez-p.z)+(ey-p.y)*(ey-p.y);
            if(d2 < (p.rad+0.55)*(p.rad+0.55)){ hit = e; break; }
          }
          if(hit){
            explodeAt(p.x, p.y, p.z, p.aoe, p.hitDmg, "player");
            world.remove(p.mesh);
            projectiles.splice(i,1);
            continue;
          }
          if(p.life<=0){
            world.remove(p.mesh);
            projectiles.splice(i,1);
          }
          continue;
        }

        // normal bolt
        p.x += p.vx*dt;
        p.y += p.vy*dt;
        p.z += p.vz*dt;
        p.mesh.position.set(p.x,p.y,p.z);

        if(p.from==="player"){
          let hit = null;
          for(const e of enemies){
            if(e.hp<=0) continue;
            const ex=e.mesh.position.x, ez=e.mesh.position.z, ey=e.mesh.position.y+(e.flying?0.2:0.65);
            const d2 = (ex-p.x)*(ex-p.x)+(ez-p.z)*(ez-p.z)+(ey-p.y)*(ey-p.y);
            if(d2 < (p.rad+0.55)*(p.rad+0.55)){ hit = e; break; }
          }
          if(hit){
            dealDamageEnemy(hit, p.dmg);

            if(p.explode){
              explodeAt(p.x,p.y,p.z, 2.4, p.dmg*0.75, "player");
            }

            if(p.splinter){
              // find 2-3 nearby enemies and splinter
              const candidates = enemies
                .filter(e=>e.hp>0 && e!==hit)
                .sort((a,b)=>dist2(a.mesh.position.x,a.mesh.position.z,p.x,p.z)-dist2(b.mesh.position.x,b.mesh.position.z,p.x,p.z))
                .slice(0,3);
              const cfg = WEAPONS[me.weapon];
              for(const e2 of candidates){
                spawnBolt(p.x,p.y,p.z, e2.mesh.position.x, e2.mesh.position.y+0.65, e2.mesh.position.z, cfg, true);
              }
            }

            world.remove(p.mesh);
            projectiles.splice(i,1);
            continue;
          }
        }else if(p.from==="enemy"){
          // hit player
          const d2 = (me.x-p.x)*(me.x-p.x) + (me.z-p.z)*(me.z-p.z) + (me.y-p.y)*(me.y-p.y);
          if(d2 < 1.05*1.05){
            takeDamage(p.dmg, "Bolt");
            world.remove(p.mesh);
            projectiles.splice(i,1);
            continue;
          }
        }

        if(p.life<=0){
          world.remove(p.mesh);
          projectiles.splice(i,1);
        }
      }
    }

    // ============================================================
    // Player auto fire tick
    // ============================================================
    function tickPlayerFire(dt){
      if(paused || !alive) { beamLine.visible=false; return; }

      const w = WEAPONS[me.weapon] || WEAPONS["Arc Bolt"];
      const range = (w.range ?? 24) * me.rangeMul;

      // find target in cone
      const t = pickTarget(range);

      if(!t){
        beamLine.visible = false;
        return;
      }

      if(w.kind==="beam"){
        // continuous damage
        const fromX = me.x, fromY = me.y, fromZ = me.z;
        const toX = t.mesh.position.x;
        const toY = t.mesh.position.y + 0.65;
        const toZ = t.mesh.position.z;

        beamLine.visible = true;
        beamLine.material.color.setHex(w.color);
        beamLine.material.opacity = 0.65 + 0.25*Math.sin(performance.now()*0.02);

        const arr = beamLine.geometry.attributes.position;
        arr.setXYZ(0, fromX, fromY, fromZ);
        arr.setXYZ(1, toX,   toY,   toZ);
        arr.needsUpdate = true;

        const dps = (w.dps||14) * me.damageMul;
        dealDamageEnemy(t, dps*dt);

      }else{
        beamLine.visible = false;

        me.fireCd -= dt;
        const fireEvery = 1 / (w.fireRate || 6);
        if(me.fireCd <= 0){
          me.fireCd = fireEvery;

          if(w.kind==="bolt"){
            spawnBolt(me.x, me.y, me.z, t.mesh.position.x, t.mesh.position.y+0.65, t.mesh.position.z, {
              dmg: (w.dmg||10),
              color: w.color,
              splinter: !!w.splinter,
              explode: !!w.explode
            });
          }else if(w.kind==="wave"){
            spawnWave({ dmg:w.dmg||14, range:(w.range||16), color:w.color });
          }
        }
      }
    }

    // wave tick + damage pass
    function tickWaves(dt){
      if(paused) return;

      for(let i=waves.length-1;i>=0;i--){
        const wv = waves[i];
        wv.life += dt;
        const t = wv.life / wv.maxLife;
        const r = lerp(0.6, wv.maxR, smoothstep(t));
        wv.mesh.scale.set(r, r, r);
        wv.mesh.material.opacity = Math.max(0, 0.8*(1-t));

        // forward-ish arc feel: only damage enemies in front cone a bit
        const fwd = cameraForward(_v1);
        for(const e of enemies){
          if(e.hp<=0 || wv.hit.has(e.id)) continue;
          const ex=e.mesh.position.x, ez=e.mesh.position.z;
          const dx=ex-me.x, dz=ez-me.z;
          const d = Math.hypot(dx,dz);
          if(d > r || d < r-1.2) continue;

          const v = _v3.set(dx, 0, dz).normalize();
          const dot = fwd.x*v.x + fwd.z*v.z;
          if(dot < 0.25) continue; // must be in front-ish

          wv.hit.add(e.id);
          dealDamageEnemy(e, wv.dmg);
        }

        if(wv.life >= wv.maxLife){
          world.remove(wv.mesh);
          waves.splice(i,1);
        }
      }
    }

    // ============================================================
    // HUD update
    // ============================================================
    function fmtMats(){
      const m = me.mats;
      // compact quick view
      return `Fe:${m.iron} Hi:${m.hide} Es:${m.essence} Cr:${m.crystal} Em:${m.ember}`;
    }

    function tickHUD(){
      hpText.textContent = `${Math.ceil(me.hp)} / ${me.maxHp}`;
      lvlText.textContent = `Lv ${me.level} ‚Ä¢ XP ${Math.floor(me.xp)}/${me.nextXp}`;
      weaponText.textContent = me.weapon;

      const reg = regionAt(me.x, me.z);
      regionText.textContent = reg.name;

      matsText.textContent = fmtMats();

      // region fog / sky feel
      scene.fog.color.setHex(reg.fog);
      renderer.setClearColor(reg.sky, 1);

      // forge prompt for mobile button text
      const nf = nearestForge();
      if(nf && nf.d <= 3.2 && phase==="play" && uiMode==="none"){
        mobileInteract.style.opacity = "1";
        mobileInteract.textContent = "‚öíÔ∏è Use Forge";
      }else{
        mobileInteract.style.opacity = "0.55";
        mobileInteract.textContent = "‚öíÔ∏è Use Forge";
      }
    }

    // ============================================================
    // Spawn pacing
    // ============================================================
    let travelMeter = 0;
    let spawnCooldown = 2.0;

    function tickSpawning(dt){
      if(paused || !alive) return;

      spawnCooldown -= dt;

      // attempt spawn at a gentle cadence
      // (travelMeter gates actual spawns so it doesn't feel constant)
      if(spawnCooldown <= 0){
        spawnPack();
      }
    }

    // ============================================================
    // Forge proximity hint
    // ============================================================
    function tickForgeHint(){
      if(phase!=="play") return;
      if(uiMode!=="none") return;

      const nf = nearestForge();
      if(!nf) return;

      if(nf.d <= 3.2){
        showHintOnce("‚öíÔ∏è Forge nearby ‚Äî press E (or tap Use Forge) to craft. Game pauses inside.");
      }
    }
    const _hintSeen = new Set();
    function showHintOnce(msg){
      if(_hintSeen.has(msg)) return;
      _hintSeen.add(msg);
      showToast(msg, 2600);
    }

    // ============================================================
    // Autosave timer
    // ============================================================
    let saveT = 0;

    // ============================================================
    // Boot / phase
    // ============================================================
    let phase = "menu"; // menu | play
    let started = false;

    // lock button (desktop)
    lockBtn.addEventListener("click", ()=>requestLock());
    renderer.domElement.addEventListener("click", ()=>{
      if(phase==="play" && !pointerLocked && uiMode==="none"){
        lockBtn.style.display = "inline-block";
      }
    });

    // ============================================================
    // Resize
    // ============================================================
    addEventListener("resize", ()=>{
      renderer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
    });

    // ============================================================
    // Main loop
    // ============================================================
    const _v1 = new THREE.Vector3();
    const _v2 = new THREE.Vector3();
    const _v3 = new THREE.Vector3();

    let last = performance.now();
    function loop(now){
      const dt = Math.min(0.033, (now-last)/1000);
      last = now;

      if(phase==="play"){
        // world systems
        tickChunks();
        tickForges(now);

        // movement + camera
        tickMove(dt);

        // gameplay systems
        tickSpawning(dt);
        tickAbilities(dt);
        tickEnemies(dt, now);
        tickPlayerFire(dt);
        tickWaves(dt);
        tickProjectiles(dt);
        pickupDrops(dt);
        tickForgeHint();
        tickHUD();

        // autosave
        if(!paused && alive){
          saveT -= dt;
          if(saveT <= 0){
            saveT = 18;
            saveGame(true);
          }
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }

    // ============================================================
    // Start
    // ============================================================
    function startPlay(){
      if(started) return;
      started = true;

      // attempt load for button visibility
      const hasSave = !!localStorage.getItem(SAVE_KEY);
      resumeBtn.style.display = hasSave ? "inline-block" : "none";

      // prime world
      genForges();
      tickChunks();
      tickHUD();

      requestAnimationFrame(loop);
    }

    // Menu -> play transition
    function enterPlay(){
      phase="play";
      centerMsg.style.display="none";
      hintBox.style.display="block";
      lockBtn.style.display = (!pointerLocked) ? "inline-block" : "none";
      saveT = 8;
    }

    // start loop immediately, keep menu up
    startPlay();

    // Clicking canvas in play locks pointer; menu already visible, so show lock button only once play begins
    // New/Resume buttons already call enterPlay via handlers above
    // We'll call enterPlay when those buttons run.

    // When user chooses New/Resume from the menu, handlers already set phase, hide center, etc.
    // But ensure enterPlay is triggered:
    const _wrapEnter = (fn)=>()=>{ fn(); enterPlay(); };
    newBtn.onclick = _wrapEnter(()=>{ resetRun(true); });
    resumeBtn.onclick = _wrapEnter(()=>{ const ok = loadGame(); if(!ok) resetRun(true); });
    loadBtn.onclick = _wrapEnter(()=>{ const ok = loadGame(); if(!ok) showToast("No save found."); });

    // If user clicks "Click to Play" on desktop during play
    lockBtn.addEventListener("click", ()=>{
      if(phase==="play" && uiMode==="none") requestLock();
    });

    // First run: don‚Äôt auto-start a run until user chooses; but generate seed/forges so visuals exist immediately.
    // Give a gentle default:
    worldSeed = (Math.random()*1e9)|0;
    genForges();

  </script>
</body>
</html>
