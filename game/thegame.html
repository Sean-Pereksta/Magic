<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>The Game ‚Äî Vote ‚Ä¢ Classic ‚Ä¢ 2.0 (Minimal)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<style>
  :root{
    --bg:#ffffff; --ink:#111827; --muted:#6b7280; --line:#e5e7eb;
    --accent:#2563eb; --good:#16a34a; --bad:#ef4444; --soft:#f8fafc;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0; background:var(--bg); color:var(--ink); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  header{position:sticky; top:0; z-index:20; background:#fff; border-bottom:1px solid var(--line); padding:8px 10px}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .players{display:flex; gap:8px; flex-wrap:wrap}
  .chip{padding:6px 10px; border:1px solid var(--line); border-radius:999px; font-size:14px; background:#fff; cursor:default}
  .chip.live{outline:2px solid var(--accent)}
  .chip.me{border-color:#60a5fa}
  .chip.clickable{cursor:pointer}
  .spacer{flex:1}
  .btn{appearance:none; border:1px solid #d1d5db; background:#111827; color:#fff; padding:10px 14px; border-radius:10px; font-weight:700; cursor:pointer}
  .btn[disabled]{opacity:.5; cursor:not-allowed}

  .wrap{max-width:860px; margin:8px auto; padding:0 10px; display:grid; gap:10px}
  /* Vote */
  .vote{border:1px solid var(--line); background:#fff; border-radius:12px; padding:10px}
  .vote .title{font-weight:900; margin-bottom:6px}
  .vote .opt{display:flex; gap:10px; align-items:center; border:1px solid var(--line); border-radius:10px; padding:10px; cursor:pointer; background:#fff}
  .vote .opt.sel{outline:2px solid var(--accent)}
  .timer{font-weight:800; color:#ca8a04}
  /* Piles */
  .piles{display:grid; grid-template-columns:repeat(2,1fr); gap:10px}
  .pile{user-select:none; padding:12px; background:#fff; border:1px solid var(--line); border-radius:12px; text-align:center}
  .pile .dir{font-size:12px; color:var(--muted)}
  .pile .top{font-weight:900; font-size:28px; margin:6px 0; padding:6px 10px; border:2px solid #e5e7eb; border-radius:10px; display:inline-block}
  .pile .eff{font-size:12px; color:#0f172a; min-height:16px}
  .pile.can{outline:2px solid var(--good); outline-offset:2px}
  .pile.cannot{opacity:.7}
  /* Hand */
  .hand{display:flex; gap:8px; flex-wrap:wrap; justify-content:center; padding:8px 0 16px}
  .card{position:relative; min-width:56px; height:74px; border-radius:12px; border:2px solid rgba(0,0,0,.08); display:flex; align-items:center; justify-content:center;
         font-weight:900; font-size:18px; cursor:pointer; background:#f3f4f6; color:#111827; user-select:none; touch-action:manipulation}
  .card.power{background:#0ea5e9; color:#fff; border-color:#0284c7; font-size:14px}
  .card.selected{outline:3px solid var(--accent); outline-offset:2px}
  .card.ghost{opacity:.45; filter:grayscale(.4); cursor:not-allowed}
  .band{position:absolute; left:0; right:0; bottom:0; height:6px; border-bottom-left-radius:10px; border-bottom-right-radius:10px; opacity:.85}
  /* Log */
  .log{font-size:12px; color:#374151; background:#fff; border:1px solid var(--line); border-radius:10px; padding:8px; max-height:120px; overflow:auto}
  @media (min-width:700px){ .piles{grid-template-columns:repeat(4,1fr)} }
</style>
</head>
<body>
<header>
  <div class="row">
    <div id="players" class="players"></div>
    <div class="spacer"></div>
    <button id="endBtn" class="btn" disabled>End Turn (draw)</button>
  </div>
</header>

<div class="wrap">
  <!-- Vote box (shown during voting) -->
  <div id="voteBox" class="vote" style="display:none">
    <div class="row" style="justify-content:space-between">
      <div class="title">Vote which mode to play</div>
      <div class="timer" id="voteTimer">‚è≥ 20s</div>
    </div>
    <div class="row">
      <div id="optClassic" class="opt">üÉè The Game (Classic)</div>
      <div id="optNew" class="opt">üß™ The Game 2.0</div>
    </div>
    <div class="row" style="justify-content:space-between; margin-top:6px">
      <div>Votes: <b id="voteCount">0/0</b></div>
      <div id="voteHint" class="muted" style="color:#6b7280">Starts when all vote or time runs out.</div>
    </div>
  </div>

  <div id="piles" class="piles"></div>
  <div id="hand" class="hand"></div>
  <div id="log" class="log"></div>
</div>

<script type="module">
/* ---------------- Firestore ---------------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, runTransaction } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);

/* ---------------- Params & refs ---------------- */
const qp = new URLSearchParams(location.search);
const roomId = qp.get("gameId") || qp.get("room") || "";
const me = (qp.get("username") || "").trim();
if(!roomId || !me){ alert("Missing gameId or username."); }
const lobbyRef = doc(db, "lobbies", roomId);
const gameRef  = doc(db, "thegameRooms", roomId);

/* ---------------- State ---------------- */
let LOBBY=null, G=null, mySelected=null, pending=null, myHand=[], isMyTurn=false;
const $players = document.getElementById('players');
const $piles   = document.getElementById('piles');
const $hand    = document.getElementById('hand');
const $log     = document.getElementById('log');
const $end     = document.getElementById('endBtn');
const $voteBox = document.getElementById('voteBox');
const $optClassic = document.getElementById('optClassic');
const $optNew  = document.getElementById('optNew');
const $voteCount = document.getElementById('voteCount');
const $voteTimer = document.getElementById('voteTimer');

/* ---------------- Constants & helpers ---------------- */
const UP='up', DOWN='down';
const POWERS = { FLIP:'FLIP', SWAP:'SWAP', TRADE:'TRADE', BUNGEE:'BUNGEE', TIMEWARP:'TIMEWARP' };
const LABEL = { FLIP:'üîÅ Flip', SWAP:'üîÑ Swap', TRADE:'ü§ù Trade', BUNGEE:'ü™¢ Bungee', TIMEWARP:'‚è≥ Time Warp' };

const isNumber = x => typeof x === 'number';
const isPower  = x => typeof x === 'string';
const sortCards=(a,b)=> (isNumber(a)&&isNumber(b)) ? a-b : (isNumber(a)?-1:(isNumber(b)?1:String(a).localeCompare(String(b))));
function handCap(n){ if(n<=1) return 7; if(n===2) return 6; return 5; }
function minBase(deckLen){ return deckLen>0 ? 2 : 1; }
function minRequiredFor(player, deckLen, debts){ return minBase(deckLen) + ((debts&&debts[player])||0); }

function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function dealToCap(hands, deck, players){
  const cap = handCap(players.length);
  for(let r=0;r<cap;r++){ for(const p of players){ if(deck.length) hands[p].push(deck.pop()); } }
  for(const p of players){ hands[p].sort(sortCards); }
}

function hueForValue(v,max){ return Math.round((v-1)/(max-1)*300); }
function colorForValue(v,max){
  const h=hueForValue(v,max); const l=55+((v%10)-5)*1.2; return `hsl(${h} 75% ${l}%)`;
}
function bandForValue(v,max){
  const decade=Math.ceil(v/10); const hue=Math.round((decade-1)/(max===120?12:10)*300);
  return `linear-gradient(90deg, hsl(${hue} 80% 55%), hsl(${hue} 80% 45%))`;
}

function canPlayOnNumber(card, pile, hasBungee){
  if(pile.dir===UP){
    if(card>pile.top) return true;
    if(pile.top-card===10) return true;
    if(hasBungee && pile.top-card===20) return true;
  }else{
    if(card<pile.top) return true;
    if(card-pile.top===10) return true;
    if(hasBungee && card-pile.top===20) return true;
  }
  return false;
}

/* ---------------- Vote or resume ---------------- */
async function ensureRoomVotingOrResume(){
  const [lob, game] = await Promise.all([getDoc(lobbyRef), getDoc(gameRef)]);
  if(!lob.exists()){ alert("Lobby not found."); return; }
  LOBBY = lob.data();
  if(game.exists()) return; // someone already created

  // Host seeds vote doc
  if(LOBBY.host !== me) return;
  const players = (LOBBY.players||[]).slice(0,5);
  const startedAt = Date.now();
  const deadline = startedAt + 20000; // 20s
  await setDoc(gameRef, {
    phase:'voting', host: LOBBY.host, players,
    votes:{}, startedAt, deadline, choice:null,
    log:[`Voting started ‚Äî choose <b>Classic</b> or <b>Game 2.0</b>.`]
  });
}

/* ---------------- Build set-ups ---------------- */
function buildClassic(players, host){
  const deck=[]; for(let v=2; v<=99; v++) deck.push(v);
  shuffle(deck);
  const hands={}; players.forEach(p=>hands[p]=[]);
  dealToCap(hands, deck, players);
  const piles={
    U1:{id:'U1',dir:UP,top:1,effects:[]}, U2:{id:'U2',dir:UP,top:1,effects:[]},
    D1:{id:'D1',dir:DOWN,top:100,effects:[]}, D2:{id:'D2',dir:DOWN,top:100,effects:[]}
  };
  return { phase:'game', host, players, piles, deck, hands,
    placed:0, turnIndex:0, turnNum:1, turnPlays:0, debts:{}, timewarpPass:null,
    log:[`Vote ended. Starting <b>Classic</b> with ${players.length} player(s).`] };
}
function buildGame2(players, host){
  const deck=[]; for(let v=2; v<=119; v++) deck.push(v);
  // powers (omit trade if solo)
  const addTrade = players.length>=2;
  const powers = [
    POWERS.FLIP, POWERS.FLIP, POWERS.FLIP,
    POWERS.BUNGEE, POWERS.BUNGEE,
    POWERS.SWAP, POWERS.SWAP,
    POWERS.TIMEWARP, POWERS.TIMEWARP
  ];
  if(addTrade){ powers.push(POWERS.TRADE, POWERS.TRADE); }
  deck.push(...powers); shuffle(deck);
  const hands={}; players.forEach(p=>hands[p]=[]);
  dealToCap(hands, deck, players);
  const piles={
    U1:{id:'U1',dir:UP,top:1,effects:[]}, U2:{id:'U2',dir:UP,top:1,effects:[]},
    D1:{id:'D1',dir:DOWN,top:120,effects:[]}, D2:{id:'D2',dir:DOWN,top:120,effects:[]}
  };
  return { phase:'game2', host, players, piles, deck, hands,
    placed:0, turnIndex:0, turnNum:1, turnPlays:0, debts:{}, timewarpPass:null,
    log:[`Vote ended. Starting <b>Game 2.0</b> with ${players.length} player(s).`] };
}

/* ---------------- Voting UI ---------------- */
let voteTick=null;
function renderVote(){
  if(!G || G.phase!=='voting'){ $voteBox.style.display='none'; return; }
  $voteBox.style.display='block';
  const players = G.players||[]; const votes=G.votes||{};
  $voteCount.textContent = `${Object.keys(votes).length}/${players.length}`;
  $optClassic.classList.toggle('sel', votes[me]==='classic');
  $optNew.classList.toggle('sel', votes[me]==='game2');

  const remain = Math.max(0,(G.deadline||0)-Date.now());
  const secs = Math.ceil(remain/1000);
  $voteTimer.textContent = `‚è≥ ${secs}s`;

  $optClassic.onclick = ()=> castVote('classic');
  $optNew.onclick     = ()=> castVote('game2');

  if(voteTick) clearTimeout(voteTick);
  voteTick = setTimeout(renderVote, 300);
}
async function castVote(choice){
  await runTransaction(db, async tx=>{
    const snap = await tx.get(gameRef); if(!snap.exists()) throw new Error('gone');
    const S = snap.data(); if(S.phase!=='voting') return;
    const votes = { ...(S.votes||{}), [me]: choice };
    const players=S.players||[]; const allVoted = players.every(p=>votes[p]);
    const timeUp = Date.now()>=(S.deadline||0);
    const update={ votes };
    // Only host resolves
    if((allVoted||timeUp) && LOBBY && LOBBY.host===me){
      const tally = { classic:0, game2:0 };
      Object.values(votes).forEach(v=>{ if(v==='classic') tally.classic++; else if(v==='game2') tally.game2++; });
      const win = (tally.classic>=tally.game2)?'classic':'game2';
      Object.assign(update, win==='classic' ? buildClassic(players, LOBBY.host) : buildGame2(players, LOBBY.host));
      update.choice = win;
    }
    tx.update(gameRef, update);
  });
}

/* ---------------- Subscriptions ---------------- */
onSnapshot(lobbyRef, snap=>{ if(snap.exists()) LOBBY=snap.data(); });
onSnapshot(gameRef, snap=>{
  if(!snap.exists()) return;
  G=snap.data();
  if(G.phase==='voting'){ renderVote(); return; }
  $voteBox.style.display='none';
  renderPlayers(); renderPiles(); renderHand(); renderLog(); gateEnd();
});

/* ---------------- UI render ---------------- */
function renderPlayers(){
  const P = G.players||[]; const idx=G.turnIndex||0; const hands=G.hands||{};
  $players.innerHTML='';
  P.forEach((p,i)=>{
    const el=document.createElement('div'); el.className='chip';
    if(p===me) el.classList.add('me');
    if(i===idx) el.classList.add('live');
    el.textContent = `${p} (${(hands[p]||[]).length})`;
    // trade target
    if(pending && pending.type==='TRADE' && p!==me){
      el.classList.add('clickable');
      el.addEventListener('click', ()=> playTradeTx(p));
    }
    $players.appendChild(el);
  });
  const cur = P[idx]||''; isMyTurn = (cur===me);
}

function renderPiles(){
  const max = (G.phase==='game2') ? 120 : 100;
  $piles.innerHTML='';
  ['U1','U2','D1','D2'].forEach(id=>{
    const p=G.piles[id]; if(!p) return;
    const div=document.createElement('div'); div.className='pile'; div.dataset.id=id;
    const dir=document.createElement('div'); dir.className='dir'; dir.textContent = p.dir===UP?'UP ‚ñ≤':'DOWN ‚ñº';
    const top=document.createElement('div'); top.className='top'; top.textContent = p.top;
    top.style.borderColor=`hsl(${hueForValue(p.top,max)} 80% 55%)`;
    top.style.background=`hsl(${hueForValue(p.top,max)} 90% 96%)`;
    const eff=document.createElement('div'); eff.className='eff';
    const b=(p.effects||[]).find(e=>e.type==='bungee');
    eff.textContent = b ? `ü™¢ x${b.charges}` : '';

    if(isMyTurn && mySelected!=null){
      if(isNumber(mySelected)){
        const hasB=!!(p.effects||[]).find(e=>e.type==='bungee'&&e.charges>0);
        if(canPlayOnNumber(mySelected,p,hasB)) div.classList.add('can'); else div.classList.add('cannot');
      }else{
        if(mySelected===POWERS.FLIP || mySelected===POWERS.BUNGEE || mySelected===POWERS.SWAP) div.classList.add('can');
      }
    }
    div.addEventListener('click', ()=> onPileTap(id));
    div.append(dir,top,eff);
    $piles.appendChild(div);
  });
}

function renderHand(){
  $hand.innerHTML='';
  myHand = (G.hands && G.hands[me]) ? [...G.hands[me]] : [];
  const max = (G.phase==='game2') ? 120 : 100;
  const nums = myHand.filter(isNumber).sort((a,b)=>a-b);
  const pows = myHand.filter(isPower);

  const add=(v)=>{
    const btn=document.createElement('button'); btn.type='button'; btn.className='card';
    if(isNumber(v)){
      btn.style.background=colorForValue(v,max);
      const band=document.createElement('div'); band.className='band'; band.style.background=bandForValue(v,max); btn.appendChild(band);
      btn.textContent=v;
      const playable = Object.values(G.piles||{}).some(p=>{
        const b=!!(p.effects||[]).find(e=>e.type==='bungee'&&e.charges>0);
        return canPlayOnNumber(v,p,b);
      });
      if(!playable) btn.classList.add('ghost');
    }else{
      btn.classList.add('power'); btn.textContent = LABEL[v]||v;
    }
    if(mySelected===v) btn.classList.add('selected');

    // Double-tap behavior for powers (works on phones)
    let lastTap=0;
    const onTap=()=>{
      const now=Date.now(), dbl=(now-lastTap)<300; lastTap=now;
      if(!isPower(v)){
        mySelected=(mySelected===v?null:v); pending=null; renderPiles(); renderHand(); return;
      }
      // powers
      if(!dbl){ mySelected=(mySelected===v?null:v); pending=null; renderPiles(); renderHand(); return; }
      mySelected=v;
      if(v===POWERS.TIMEWARP) { playTimeWarpTx(); return; }
      if(v===POWERS.TRADE)   { pending={type:'TRADE'}; renderPlayers(); return; }
      pending = (v===POWERS.SWAP) ? {type:'SWAP'} : null; renderPiles();
    };
    btn.addEventListener('click', onTap);
    btn.addEventListener('touchend', (e)=>{ e.preventDefault(); onTap(); }, {passive:false});
    $hand.appendChild(btn);
  };

  nums.forEach(add); pows.forEach(add);
}

function renderLog(){
  const L = (G.log||[]).slice(-80);
  $log.innerHTML = L.map(x=>`<div>${x}</div>`).reverse().join('');
}

/* ---------------- Interactions ---------------- */
function onPileTap(id){
  if(!isMyTurn || mySelected==null) return;
  if(isNumber(mySelected)){ playNumberTx(mySelected,id); return; }
  if(mySelected===POWERS.FLIP)   return playFlipTx(id);
  if(mySelected===POWERS.BUNGEE) return playBungeeTx(id);
  if(mySelected===POWERS.SWAP){
    if(!pending || pending.type!=='SWAP' || !pending.first){ pending={type:'SWAP', first:id}; renderPiles(); return; }
    if(pending.first===id){ pending=null; return; }
    const a=pending.first; pending=null; return playSwapTx(a,id);
  }
}

function anyMoves(hand, piles){
  for(const c of hand){
    if(isPower(c) && G.phase==='game2') return true;
    if(isNumber(c)){
      for(const p of piles){
        const b=!!(p.effects||[]).find(e=>e.type==='bungee'&&e.charges>0);
        if(canPlayOnNumber(c,p,b)) return true;
      }
    }
  } return false;
}
function gateEnd(){
  if(!G){ $end.disabled=true; return; }
  const players=G.players||[]; const current=players[G.turnIndex||0]||'';
  const req=minRequiredFor(current,(G.deck||[]).length,G.debts||{});
  const movesRemain = anyMoves(myHand, Object.values(G.piles||{}));
  const earlyPass = (G.timewarpPass && G.timewarpPass===current);
  $end.disabled = !(isMyTurn && ((G.turnPlays||0)>=req || !movesRemain || earlyPass));
}
document.getElementById('endBtn').addEventListener('click', ()=>{ if(isMyTurn) endTurnTx(); });

/* ---------------- TX: numbers ---------------- */
async function playNumberTx(card, pileId){
  await runTransaction(db, async tx=>{
    const snap=await tx.get(gameRef); if(!snap.exists()) throw new Error('gone');
    const S=snap.data(); const P=S.players||[]; const cur=P[S.turnIndex||0]||''; if(cur!==me) throw new Error('turn');
    const piles=S.piles||{}; const p=piles[pileId]; if(!p) throw new Error('pile');
    const my=[...(S.hands?.[me]||[])]; const idx=my.indexOf(card); if(idx<0) throw new Error('no card');

    const hasB=!!(p.effects||[]).find(e=>e.type==='bungee'&&e.charges>0);
    if(!canPlayOnNumber(card,p,hasB)) throw new Error('illegal');

    const prev=p.top; p.top=card;
    if(hasB && Math.abs(prev-card)===20){
      const ef=p.effects.find(e=>e.type==='bungee'&&e.charges>0);
      if(ef){ ef.charges--; if(ef.charges<=0) p.effects=p.effects.filter(e=>!(e.type==='bungee'&&e.charges<=0)); }
    }

    my.splice(idx,1); my.sort(sortCards);
    const hands={...S.hands,[me]:my};
    const log=(S.log||[]).slice(-200);
    const backwards=(p.dir===UP && prev-card===10) || (p.dir===DOWN && card-prev===10);
    const b20=(Math.abs(prev-card)===20);
    log.push(`${me} played <b>${card}</b> on ${p.id} ${p.dir===UP?'‚ñ≤':'‚ñº'}${backwards?' via <b>¬±10</b>':''}${b20?' with <b>ü™¢ ¬±20</b>':''} (${prev}‚Üí${card}).`);

    tx.update(gameRef,{piles, hands, turnPlays:(S.turnPlays||0)+1, placed:(S.placed||0)+1, log});
  }).catch(console.warn);
}

/* ---------------- TX: powers ---------------- */
async function playFlipTx(pileId){
  await runTransaction(db, async tx=>{
    const snap=await tx.get(gameRef); if(!snap.exists()) throw new Error('gone');
    const S=snap.data(); if(S.phase!=='game2') throw new Error('only 2.0');
    const P=S.players||[]; const cur=P[S.turnIndex||0]||''; if(cur!==me) throw new Error('turn');
    const p=S.piles?.[pileId]; if(!p) throw new Error('pile');

    const my=[...(S.hands?.[me]||[])]; const i=my.indexOf(POWERS.FLIP); if(i<0) throw new Error('no flip');
    my.splice(i,1); p.dir=(p.dir===UP?DOWN:UP);

    const hands={...S.hands,[me]:my};
    const log=(S.log||[]).slice(-200); log.push(`${me} used <b>üîÅ Flip</b> on ${p.id} ‚Äî now <b>${p.dir===UP?'UP':'DOWN'}</b>.`);
    tx.update(gameRef,{piles:S.piles, hands, turnPlays:(S.turnPlays||0)+1, log});
  }).catch(console.warn);
}

async function playBungeeTx(pileId){
  await runTransaction(db, async tx=>{
    const snap=await tx.get(gameRef); if(!snap.exists()) throw new Error('gone');
    const S=snap.data(); if(S.phase!=='game2') throw new Error('only 2.0');
    const P=S.players||[]; const cur=P[S.turnIndex||0]||''; if(cur!==me) throw new Error('turn');
    const p=S.piles?.[pileId]; if(!p) throw new Error('pile');

    const my=[...(S.hands?.[me]||[])]; const i=my.indexOf(POWERS.BUNGEE); if(i<0) throw new Error('no bungee');
    my.splice(i,1);
    const effs=p.effects||[]; const ex=effs.find(e=>e.type==='bungee'); if(ex) ex.charges++; else effs.push({type:'bungee',charges:1});
    p.effects=effs;

    const hands={...S.hands,[me]:my};
    const log=(S.log||[]).slice(-200); log.push(`${me} armed <b>ü™¢ Bungee</b> on ${p.id}.`);
    tx.update(gameRef,{piles:S.piles, hands, turnPlays:(S.turnPlays||0)+1, log});
  }).catch(console.warn);
}

async function playSwapTx(aId,bId){
  await runTransaction(db, async tx=>{
    const snap=await tx.get(gameRef); if(!snap.exists()) throw new Error('gone');
    const S=snap.data(); if(S.phase!=='game2') throw new Error('only 2.0');
    const P=S.players||[]; const cur=P[S.turnIndex||0]||''; if(cur!==me) throw new Error('turn');
    const A=S.piles?.[aId], B=S.piles?.[bId]; if(!A||!B) throw new Error('pile');

    const my=[...(S.hands?.[me]||[])]; const i=my.indexOf(POWERS.SWAP); if(i<0) throw new Error('no swap');
    my.splice(i,1);

    const t=A.top; A.top=B.top; B.top=t;

    const hands={...S.hands,[me]:my};
    const log=(S.log||[]).slice(-200); log.push(`${me} used <b>üîÑ Swap</b> on ${aId}‚Üî${bId}.`);
    tx.update(gameRef,{piles:S.piles, hands, turnPlays:(S.turnPlays||0)+1, log});
  }).catch(console.warn);
}

async function playTradeTx(target){
  await runTransaction(db, async tx=>{
    const snap=await tx.get(gameRef); if(!snap.exists()) throw new Error('gone');
    const S=snap.data(); if(S.phase!=='game2') throw new Error('only 2.0');
    const P=S.players||[]; const cur=P[S.turnIndex||0]||''; if(cur!==me) throw new Error('turn');
    if(target===me) throw new Error('self');

    const my=[...(S.hands?.[me]||[])]; const his=[...(S.hands?.[target]||[])];
    const pi=my.indexOf(POWERS.TRADE); if(pi<0) throw new Error('no trade');
    if(his.length===0 || my.length<=1) throw new Error('no cards');

    my.splice(pi,1);
    const mi=Math.floor(Math.random()*my.length), hi=Math.floor(Math.random()*his.length);
    const myCard=my.splice(mi,1)[0]; const hisCard=his.splice(hi,1)[0];
    my.push(hisCard); his.push(myCard);
    my.sort(sortCards); his.sort(sortCards);

    const hands={...S.hands,[me]:my,[target]:his};
    const log=(S.log||[]).slice(-200); log.push(`${me} used <b>ü§ù Trade</b> with <b>${target}</b>.`);
    tx.update(gameRef,{hands,turnPlays:(S.turnPlays||0)+1,log});
  }).then(()=>{ pending=null; mySelected=null; renderPlayers(); renderHand(); }).catch(console.warn);
}

async function playTimeWarpTx(){
  await runTransaction(db, async tx=>{
    const snap=await tx.get(gameRef); if(!snap.exists()) throw new Error('gone');
    const S=snap.data(); if(S.phase!=='game2') throw new Error('only 2.0');
    const P=S.players||[]; const cur=P[S.turnIndex||0]||''; if(cur!==me) throw new Error('turn');

    const my=[...(S.hands?.[me]||[])]; const i=my.indexOf(POWERS.TIMEWARP); if(i<0) throw new Error('no tw');
    my.splice(i,1);

    const debts={...(S.debts||{})}; debts[me]=(debts[me]||0)+1;
    const hands={...S.hands,[me]:my};
    const log=(S.log||[]).slice(-200); log.push(`${me} used <b>‚è≥ Time Warp</b> (may end early; next turn +1 min).`);
    tx.update(gameRef,{hands,debts,timewarpPass:me,turnPlays:(S.turnPlays||0)+1,log});
  }).then(()=>{ mySelected=null; renderHand(); }).catch(console.warn);
}

/* ---------------- End Turn ---------------- */
async function endTurnTx(){
  await runTransaction(db, async tx=>{
    const snap=await tx.get(gameRef); if(!snap.exists()) throw new Error('gone');
    const S=snap.data();
    const P=S.players||[]; const idx=S.turnIndex||0; const cur=P[idx]||''; if(cur!==me) throw new Error('turn');

    const deck=[...(S.deck||[])]; const hands={...(S.hands||{})};
    const req=minRequiredFor(cur, deck.length, S.debts||{});
    const early=(S.timewarpPass && S.timewarpPass===cur);
    if((S.turnPlays||0) < req && !early) throw new Error('need more');

    const cap=handCap(P.length);
    const mine=[...(hands[me]||[])];
    while(mine.length<cap && deck.length){ mine.push(deck.pop()); }
    mine.sort(sortCards); hands[me]=mine;

    const next=(idx+1)%P.length; const turnNum = (next===0)?(S.turnNum||1)+1:(S.turnNum||1);
    const log=(S.log||[]).slice(-200); const drew=Math.max(0, cap - ((S.hands?.[me]?.length)||0));
    log.push(`${me} ended turn. Drew ${drew}. Next: <b>${P[next]||''}</b>.`);

    const debts={...(S.debts||{})}; let pass=S.timewarpPass;
    if(pass===cur) pass=null;
    if((S.debts||{})[cur]>0){ debts[cur]=Math.max(0,(debts[cur]||0)-1); if(debts[cur]===0) delete debts[cur]; }

    tx.update(gameRef,{deck,hands,turnIndex:next,turnNum,turnPlays:0,log,debts,timewarpPass:pass});
  }).catch(console.warn);
}
document.getElementById('endBtn').addEventListener('click', ()=>{ if(isMyTurn) endTurnTx(); });

/* ---------------- Kickoff ---------------- */
ensureRoomVotingOrResume();
</script>
</body>
</html>


