<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>The Game ‚Äî Vote ‚Ä¢ Classic ‚Ä¢ 2.0 (Mobile Powers Popup)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<style>
  :root{
    --bg:#ffffff; --ink:#111827; --muted:#6b7280; --line:#e5e7eb;
    --accent:#2563eb; --good:#16a34a; --bad:#ef4444; --soft:#f8fafc;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0; background:var(--bg); color:var(--ink); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}

  /* Top bar */
  header{position:sticky; top:0; z-index:30; background:#fff; border-bottom:1px solid var(--line); padding:6px 8px}
  .row{display:flex; gap:6px; align-items:center; flex-wrap:wrap}
  .players{display:flex; gap:6px; flex-wrap:wrap; max-width:65vw}
  .chip{padding:6px 10px; border:1px solid var(--line); border-radius:999px; font-size:13px; background:#fff; cursor:default; white-space:nowrap}
  .chip.live{outline:2px solid var(--accent)}
  .chip.me{border-color:#60a5fa}
  .chip.clickable{cursor:pointer}
  .spacer{flex:1}
  .btn{appearance:none; border:1px solid #d1d5db; background:#111827; color:#fff; padding:9px 12px; border-radius:10px; font-weight:700; cursor:pointer; font-size:14px}
  .btn[disabled]{opacity:.5; cursor:not-allowed}
  .btn.secondary{background:#fff; color:#111827}
  .btn.ghost{background:#f3f4f6; color:#111827; border-color:#d1d5db}
  #playBtn{display:none} /* legacy inline play button (kept for safety) */
  .chip.fs{background:#eef2ff; border-color:#c7d2fe; color:#1e40af}

  /* Content */
  .wrap{max-width:860px; margin:8px auto; padding:0 8px; display:grid; gap:8px}

  /* Vote box */
  .vote{border:1px solid var(--line); background:#fff; border-radius:12px; padding:10px}
  .vote .title{font-weight:900; margin-bottom:6px}
  .vote .opt{display:flex; gap:10px; align-items:center; border:1px solid var(--line); border-radius:10px; padding:10px; cursor:pointer; background:#fff; font-weight:700}
  .vote .opt.sel{outline:2px solid var(--accent)}
  .timer{font-weight:800; color:#ca8a04}

  /* Piles */
  .piles{display:grid; grid-template-columns:repeat(2,1fr); gap:8px}
  .pile{user-select:none; padding:10px; background:#fff; border:1px solid var(--line); border-radius:12px; text-align:center}
  .pile .dir{font-size:12px; color:var(--muted)}
  .pile .top{font-weight:900; font-size:26px; margin:6px 0; padding:6px 10px; border:2px solid #e5e7eb; border-radius:10px; display:inline-block}
  .pile .eff{font-size:12px; color:#0f172a; min-height:16px}
  .pile.can{outline:2px solid var(--good); outline-offset:2px}
  .pile.cannot{opacity:.7}

  /* Hand */
  .hand{display:flex; gap:6px; flex-wrap:wrap; justify-content:center; padding:8px 0 14px}
  .card{position:relative; min-width:52px; height:70px; border-radius:12px; border:2px solid rgba(0,0,0,.08); display:flex; align-items:center; justify-content:center;
         font-weight:900; font-size:17px; cursor:pointer; background:#f3f4f6; color:#111827; user-select:none; touch-action:manipulation}
  .card.power{background:#0ea5e9; color:#fff; border-color:#0284c7; font-size:13px}
  .card.selected{outline:3px solid var(--accent); outline-offset:2px}
  .card.ghost{opacity:.45; filter:grayscale(.4); cursor:not-allowed}
  .band{position:absolute; left:0; right:0; bottom:0; height:6px; border-bottom-left-radius:10px; border-bottom-right-radius:10px; opacity:.85}

  /* Hint / Log */
  .hint{font-size:12px; color:#374151; background:#fff; border:1px solid var(--line); border-radius:10px; padding:6px 8px}
  .log{font-size:12px; color:#374151; background:#fff; border:1px solid var(--line); border-radius:10px; padding:8px; max-height:120px; overflow:auto}

  @media (min-width:700px){ .piles{grid-template-columns:repeat(4,1fr)} }
  /* Fullscreen tweaks */
  .full header{position:fixed; top:0; left:0; right:0}
  .full .wrap{padding-top:2px}

  /* ===== Powers Bottom Sheet (mobile-friendly, fullscreen-safe) ===== */
  .sheet-backdrop{
    position:fixed; inset:0; background:rgba(0,0,0,.35);
    display:none; align-items:flex-end; justify-content:center; z-index:1000;
  }
  .sheet{ width:100%; max-width:860px; background:#fff; border-top-left-radius:16px; border-top-right-radius:16px;
          box-shadow:0 -10px 30px rgba(0,0,0,.2); padding:10px; }
  .sheet .grab{width:44px; height:5px; border-radius:99px; background:#e5e7eb; margin:0 auto 8px;}
  .sheet h3{margin:0 0 8px 0; font-size:16px}
  .powers-grid{display:grid; grid-template-columns:repeat(2,1fr); gap:8px}
  .power-item{border:1px solid var(--line); border-radius:12px; padding:10px; display:flex; flex-direction:column; gap:6px}
  .power-item .label{font-weight:800}
  .power-item .desc{font-size:12px; color:#4b5563; min-height:28px}
  .power-actions{display:flex; gap:6px; justify-content:flex-end}
  .inline-pill{display:inline-block; font-size:11px; background:#eef2ff; color:#1e40af; padding:2px 6px; border-radius:999px; border:1px solid #c7d2fe}

  .toast{
    position:fixed; left:50%; transform:translateX(-50%);
    bottom:12px; background:#111827; color:#fff; padding:10px 14px; border-radius:12px;
    font-size:13px; z-index:1100; display:none;
  }
</style>
</head>
<body>
<header>
  <div class="row">
    <div id="players" class="players"></div>
    <span id="fsChip" class="chip fs" style="display:none">FS ON</span>
    <div class="spacer"></div>
    <button id="powersBtn" class="btn secondary" type="button" title="Open powers">‚ú® Powers</button>
    <button id="playBtn" class="btn" type="button">Play</button>
    <button id="endBtn" class="btn" type="button" disabled>End Turn</button>
    <button id="fsBtn" class="btn" type="button" title="Toggle Full Screen">‚õ∂</button>
  </div>
</header>

<div class="wrap">
  <!-- Vote -->
  <div id="voteBox" class="vote" style="display:none">
    <div class="row" style="justify-content:space-between">
      <div class="title">Vote which mode to play</div>
      <div class="timer" id="voteTimer">‚è≥ 20s</div>
    </div>
    <div class="row">
      <div id="optClassic" class="opt">üÉè The Game (Classic)</div>
      <div id="optNew" class="opt">üß™ The Game 2.0</div>
    </div>
    <div class="row" style="justify-content:space-between; margin-top:6px">
      <div>Votes: <b id="voteCount">0/0</b></div>
      <div id="voteHint" class="muted" style="color:#6b7280">Starts when all vote or time runs out.</div>
    </div>
  </div>

  <div id="piles" class="piles"></div>
  <div id="hand" class="hand"></div>
  <div id="hint" class="hint" style="display:none"></div>
  <div id="log" class="log"></div>
</div>

<!-- ===== Powers Bottom Sheet ===== -->
<div id="sheetWrap" class="sheet-backdrop" role="dialog" aria-modal="true">
  <div class="sheet" role="document">
    <div class="grab"></div>
    <h3>Choose a Power <span id="powerCount" class="inline-pill">0</span></h3>
    <div id="powersGrid" class="powers-grid"></div>
    <div class="row" style="justify-content:flex-end; margin-top:8px">
      <button id="closeSheet" class="btn ghost" type="button">Close</button>
    </div>
  </div>
</div>

<div id="toast" class="toast"></div>

<script type="module">
/* ---------------- Firestore ---------------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, runTransaction } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);

/* ---------------- Params & refs ---------------- */
const qp = new URLSearchParams(location.search);
const roomId = qp.get("gameId") || qp.get("room") || "";
const me = (qp.get("username") || "").trim();
if(!roomId || !me){ alert("Missing gameId or username."); }
const lobbyRef = doc(db, "lobbies", roomId);
const gameRef  = doc(db, "thegameRooms", roomId);

/* ---------------- State ---------------- */
let LOBBY=null, G=null, mySelected=null, pending=null, myHand=[], isMyTurn=false;
const $players = document.getElementById('players');
const $piles   = document.getElementById('piles');
const $hand    = document.getElementById('hand');
const $log     = document.getElementById('log');
const $hint    = document.getElementById('hint');
const $end     = document.getElementById('endBtn');
const $play    = document.getElementById('playBtn'); // legacy inline trigger
const $fsBtn   = document.getElementById('fsBtn');
const $fsChip  = document.getElementById('fsChip');
const $voteBox = document.getElementById('voteBox');
const $optClassic = document.getElementById('optClassic');
const $optNew  = document.getElementById('optNew');
const $voteCount = document.getElementById('voteCount');
const $voteTimer = document.getElementById('voteTimer');
const $powersBtn = document.getElementById('powersBtn');
const $sheetWrap = document.getElementById('sheetWrap');
const $powersGrid= document.getElementById('powersGrid');
const $powerCount= document.getElementById('powerCount');
const $closeSheet= document.getElementById('closeSheet');
const $toast = document.getElementById('toast');

/* ---------------- Constants & helpers ---------------- */
const UP='up', DOWN='down';
const POWERS = { FLIP:'FLIP', SWAP:'SWAP', TRADE:'TRADE', BUNGEE:'BUNGEE', TIMEWARP:'TIMEWARP' };
const LABEL = { FLIP:'üîÅ Flip', SWAP:'üîÑ Swap', TRADE:'ü§ù Trade', BUNGEE:'ü™¢ Bungee', TIMEWARP:'‚è≥ Time Warp' };
const DESC  = {
  FLIP: 'Flip the pile direction (UP ‚áÑ DOWN). Tap a pile after choosing.',
  SWAP: 'Swap the top numbers of two piles. Tap two piles.',
  TRADE:'Trade a random card with a player. Tap a player.',
  BUNGEE:'Arm a pile with one ¬±20 jump. Tap a pile.',
  TIMEWARP:'End early this turn (adds +1 required on a future turn).'
};

const isNumber = x => typeof x === 'number';
const isPower  = x => typeof x === 'string';
const sortCards=(a,b)=> (isNumber(a)&&isNumber(b)) ? a-b : (isNumber(a)?-1:(isNumber(b)?1:String(a).localeCompare(String(b))));
function handCap(n){ if(n<=1) return 7; if(n===2) return 6; return 5; }
function minBase(deckLen){ return deckLen>0 ? 2 : 1; }
function minRequiredFor(player, deckLen, debts){ return minBase(deckLen) + ((debts&&debts[player])||0); }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

function hueForValue(v,max){ return Math.round((v-1)/(max-1)*300); }
function colorForValue(v,max){
  const h=hueForValue(v,max); const l=55+((v%10)-5)*1.2; return `hsl(${h} 75% ${l}%)`;
}
function bandForValue(v,max){
  const decade=Math.ceil(v/10); const hue=Math.round((decade-1)/(max===120?12:10)*300);
  return `linear-gradient(90deg, hsl(${hue} 80% 55%), hsl(${hue} 80% 45%))`;
}

function canPlayOnNumber(card, pile, hasBungee){
  if(pile.dir===UP){
    if(card>pile.top) return true;
    if(pile.top-card===10) return true;
    if(hasBungee && pile.top-card===20) return true;
  }else{
    if(card<pile.top) return true;
    if(card-pile.top===10) return true;
    if(hasBungee && card-pile.top===20) return true;
  }
  return false;
}

function toast(msg, ms=1400){
  $toast.textContent = msg;
  $toast.style.display='block';
  clearTimeout(toast._t);
  toast._t = setTimeout(()=>{ $toast.style.display='none'; }, ms);
}

/* ---------------- Vote or resume ---------------- */
async function ensureRoomVotingOrResume(){
  const [lob, game] = await Promise.all([getDoc(lobbyRef), getDoc(gameRef)]);
  if(!lob.exists()){ alert("Lobby not found."); return; }
  LOBBY = lob.data();
  if(game.exists()) return; // already seeded

  // Host seeds vote doc
  if(LOBBY.host !== me) return;
  const players = (LOBBY.players||[]).slice(0,5);
  const startedAt = Date.now();
  const deadline = startedAt + 20000; // 20s
  await setDoc(gameRef, {
    phase:'voting', host: LOBBY.host, players,
    votes:{}, startedAt, deadline, choice:null,
    log:[`Voting started ‚Äî choose <b>Classic</b> or <b>Game 2.0</b>.`]
  });
}

/* ---------------- Build set-ups ---------------- */
function dealToCap(hands, deck, players){
  const cap = handCap(players.length);
  for(let r=0;r<cap;r++){ for(const p of players){ if(deck.length) hands[p].push(deck.pop()); } }
  for(const p of players){ hands[p].sort(sortCards); }
}
function buildClassic(players, host){
  const deck=[]; for(let v=2; v<=99; v++) deck.push(v);
  shuffle(deck);
  const hands={}; players.forEach(p=>hands[p]=[]);
  dealToCap(hands, deck, players);
  const piles={
    U1:{id:'U1',dir:UP,top:1,effects:[]}, U2:{id:'U2',dir:UP,top:1,effects:[]},
    D1:{id:'D1',dir:DOWN,top:100,effects:[]}, D2:{id:'D2',dir:DOWN,top:100,effects:[]}
  };
  return { phase:'game', host, players, piles, deck, hands,
    placed:0, turnIndex:0, turnNum:1, turnPlays:0, debts:{}, timewarpPass:null,
    log:[`Vote ended. Starting <b>Classic</b> with ${players.length} player(s).`] };
}
function buildGame2(players, host){
  const deck=[]; for(let v=2; v<=119; v++) deck.push(v);
  // powers (omit Trade if solo)
  const addTrade = players.length>=2;
  const powers = [
    POWERS.FLIP, POWERS.FLIP, POWERS.FLIP,
    POWERS.BUNGEE, POWERS.BUNGEE,
    POWERS.SWAP, POWERS.SWAP,
    POWERS.TIMEWARP, POWERS.TIMEWARP
  ];
  if(addTrade){ powers.push(POWERS.TRADE, POWERS.TRADE); }
  deck.push(...powers); shuffle(deck);
  const hands={}; players.forEach(p=>hands[p]=[]);
  dealToCap(hands, deck, players);
  const piles={
    U1:{id:'U1',dir:UP,top:1,effects:[]}, U2:{id:'U2',dir:UP,top:1,effects:[]},
    D1:{id:'D1',dir:DOWN,top:120,effects:[]}, D2:{id:'D2',dir:DOWN,top:120,effects:[]}
  };
  return { phase:'game2', host, players, piles, deck, hands,
    placed:0, turnIndex:0, turnNum:1, turnPlays:0, debts:{}, timewarpPass:null,
    log:[`Vote ended. Starting <b>Game 2.0</b> with ${players.length} player(s).`] };
}

/* ---------------- Voting UI ---------------- */
let voteTick=null;
function renderVote(){
  if(!G || G.phase!=='voting'){ $voteBox.style.display='none'; return; }
  $voteBox.style.display='block';
  const players = G.players||[]; const votes=G.votes||{};
  $voteCount.textContent = `${Object.keys(votes).length}/${players.length}`;
  document.getElementById('optClassic').classList.toggle('sel', votes[me]==='classic');
  document.getElementById('optNew').classList.toggle('sel', votes[me]==='game2');

  const remain = Math.max(0,(G.deadline||0)-Date.now());
  const secs = Math.ceil(remain/1000);
  $voteTimer.textContent = `‚è≥ ${secs}s`;

  $optClassic.onclick = ()=> castVote('classic');
  $optNew.onclick     = ()=> castVote('game2');

  if(voteTick) clearTimeout(voteTick);
  voteTick = setTimeout(renderVote, 300);
}
async function castVote(choice){
  await runTransaction(db, async tx=>{
    const snap = await tx.get(gameRef); if(!snap.exists()) throw new Error('gone');
    const S = snap.data(); if(S.phase!=='voting') return;
    const votes = { ...(S.votes||{}), [me]: choice };
    const players=S.players||[]; const allVoted = players.every(p=>votes[p]);
    const timeUp = Date.now()>=(S.deadline||0);
    const update={ votes };
    if((allVoted||timeUp) && LOBBY && LOBBY.host===me){
      const tally = { classic:0, game2:0 };
      Object.values(votes).forEach(v=>{ if(v==='classic') tally.classic++; else if(v==='game2') tally.game2++; });
      const win = (tally.classic>=tally.game2)?'classic':'game2';
      Object.assign(update, win==='classic' ? buildClassic(players, LOBBY.host) : buildGame2(players, LOBBY.host));
      update.choice = win;
    }
    tx.update(gameRef, update);
  });
}

/* ---------------- Subscriptions ---------------- */
onSnapshot(lobbyRef, snap=>{ if(snap.exists()) LOBBY=snap.data(); });
onSnapshot(gameRef, snap=>{
  if(!snap.exists()) return;
  G=snap.data();
  if(G.phase==='voting'){ renderVote(); updateActions(); gateEnd(); return; }
  $voteBox.style.display='none';
  renderPlayers(); renderPiles(); renderHand(); renderLog(); gateEnd(); updateActions();
});

/* ---------------- UI render ---------------- */
function renderPlayers(){
  const P = G.players||[]; const idx=G.turnIndex||0; const hands=G.hands||{};
  $players.innerHTML='';
  P.forEach((p,i)=>{
    const el=document.createElement('div'); el.className='chip';
    if(p===me) el.classList.add('me');
    if(i===idx) el.classList.add('live');
    el.textContent = `${p} (${(hands[p]||[]).length})`;
    // trade target
    if(pending && pending.type==='TRADE' && p!==me){
      el.classList.add('clickable');
      el.addEventListener('click', ()=> playTradeTx(p), {once:true});
    }
    $players.appendChild(el);
  });
  const cur = P[idx]||''; isMyTurn = (cur===me);
}

function renderPiles(){
  const max = (G.phase==='game2') ? 120 : 100;
  $piles.innerHTML='';
  ['U1','U2','D1','D2'].forEach(id=>{
    const p=G.piles[id]; if(!p) return;
    const div=document.createElement('div'); div.className='pile'; div.dataset.id=id;
    const dir=document.createElement('div'); dir.className='dir'; dir.textContent = p.dir===UP?'UP ‚ñ≤':'DOWN ‚ñº';
    const top=document.createElement('div'); top.className='top'; top.textContent = p.top;
    top.style.borderColor=`hsl(${hueForValue(p.top,max)} 80% 55%)`;
    top.style.background=`hsl(${hueForValue(p.top,max)} 90% 96%)`;
    const eff=document.createElement('div'); eff.className='eff';
    const b=(p.effects||[]).find(e=>e.type==='bungee'); eff.textContent = b ? `ü™¢ x${b.charges}` : '';

    if(isMyTurn && mySelected!=null){
      if(isNumber(mySelected)){
        const hasB=!!(p.effects||[]).find(e=>e.type==='bungee'&&e.charges>0);
        if(canPlayOnNumber(mySelected,p,hasB)) div.classList.add('can'); else div.classList.add('cannot');
      }else{
        if(mySelected===POWERS.FLIP || mySelected===POWERS.BUNGEE || mySelected===POWERS.SWAP) div.classList.add('can');
      }
    }
    div.addEventListener('click', ()=> onPileTap(id));
    div.append(dir,top,eff);
    $piles.appendChild(div);
  });
}

function renderHand(){
  $hand.innerHTML='';
  myHand = (G.hands && G.hands[me]) ? [...G.hands[me]] : [];
  const max = (G.phase==='game2') ? 120 : 100;
  const nums = myHand.filter(isNumber).sort((a,b)=>a-b);
  const pows = myHand.filter(isPower);

  const add=(v)=>{
    const btn=document.createElement('button'); btn.type='button'; btn.className='card';
    if(isNumber(v)){
      btn.style.background=colorForValue(v,max);
      const band=document.createElement('div'); band.className='band'; band.style.background=bandForValue(v,max); btn.appendChild(band);
      btn.textContent=v;
      const playable = Object.values(G.piles||{}).some(p=>{
        const b=!!(p.effects||[]).find(e=>e.type==='bungee'&&e.charges>0);
        return canPlayOnNumber(v,p,b);
      });
      if(!playable) btn.classList.add('ghost');
    }else{
      btn.classList.add('power'); btn.textContent = LABEL[v]||v;
    }
    if(mySelected===v) btn.classList.add('selected');

    btn.addEventListener('click', ()=>{
      if(!isNumber(v)){
        // For powers, open sheet and preselect that power for guidance
        openPowersSheet(v);
        return;
      }
      mySelected=(mySelected===v?null:v); pending=null; renderPiles(); updateActions(); renderHand(); gateEnd();
    });
    $hand.appendChild(btn);
  };

  nums.forEach(add); pows.forEach(add);

  // Update powers sheet counter
  $powerCount.textContent = pows.length.toString();
}

/* ---------------- Hints & actions ---------------- */
function targetHintFor(v){
  if(v===POWERS.FLIP) return 'Tap a pile to flip direction.';
  if(v===POWERS.BUNGEE) return 'Tap a pile to arm Bungee (¬±20 once).';
  if(v===POWERS.SWAP) return 'Tap two piles to swap their tops.';
  if(v===POWERS.TRADE) return 'Tap a player to trade.';
  if(v===POWERS.TIMEWARP) return 'Time Warp played. You may end early this turn.';
  return '';
}
function showHint(msg){
  if(!msg){ $hint.style.display='none'; $hint.textContent=''; return; }
  $hint.style.display='block'; $hint.textContent=msg;
}

function updateActions(){
  // legacy play button (hidden by default)
  const powerSel = isPower(mySelected) && (G && G.phase==='game2');
  $play.style.display = powerSel ? 'inline-block' : 'none';
  $play.disabled = !powerSel || !isMyTurn;
  if(powerSel){ $play.textContent = `Play ${LABEL[mySelected] || 'Power'}`; }
  // FS chip
  $fsChip.style.display = document.fullscreenElement ? 'inline-block' : 'none';
}

/* ---------------- Powers Sheet ---------------- */
function openPowersSheet(preselect=null){
  if(!G || G.phase!=='game2'){ toast('Powers only in Game 2.0'); return; }
  const pows = (G.hands?.[me]||[]).filter(isPower);
  $powersGrid.innerHTML = '';
  if(pows.length===0){
    const empty=document.createElement('div');
    empty.textContent='You have no power cards.';
    $powersGrid.appendChild(empty);
  }else{
    // Aggregate by type for clean UI
    const counts = pows.reduce((m,p)=> (m[p]=(m[p]||0)+1, m), {});
    Object.keys(counts).sort().forEach(k=>{
      const cardType = k;
      const item = document.createElement('div'); item.className='power-item';
      const label = document.createElement('div'); label.className='label'; label.textContent = `${LABEL[cardType]||cardType} √ó${counts[cardType]}`;
      const desc  = document.createElement('div'); desc.className='desc'; desc.textContent = DESC[cardType] || '';
      const actions = document.createElement('div'); actions.className='power-actions';
      const useBtn = document.createElement('button'); useBtn.className='btn'; useBtn.type='button';
      useBtn.textContent = `Use ${LABEL[cardType]||cardType}`;
      useBtn.addEventListener('click', ()=>{
        if(!isMyTurn){ toast('Not your turn.'); return; }
        mySelected = cardType;
        // Start targeting guidance immediately
        if(cardType===POWERS.TIMEWARP){ playTimeWarpTx(); closeSheet(); return; }
        if(cardType===POWERS.TRADE){ pending={type:'TRADE'}; showHint('Tap a player to trade.'); renderPlayers(); updateActions(); closeSheet(); return; }
        if(cardType===POWERS.SWAP){ pending={type:'SWAP'}; showHint('Tap two piles to swap their tops.'); renderPiles(); updateActions(); closeSheet(); return; }
        if(cardType===POWERS.FLIP){ showHint('Tap a pile to flip direction.'); renderPiles(); updateActions(); closeSheet(); return; }
        if(cardType===POWERS.BUNGEE){ showHint('Tap a pile to arm Bungee (¬±20 once).'); renderPiles(); updateActions(); closeSheet(); return; }
      });
      actions.appendChild(useBtn);
      item.append(label, desc, actions);
      $powersGrid.appendChild(item);
    });
  }
  $sheetWrap.style.display='flex';
}
function closeSheet(){ $sheetWrap.style.display='none'; }

$powersBtn.addEventListener('click', ()=> openPowersSheet());
$closeSheet.addEventListener('click', closeSheet);
$sheetWrap.addEventListener('click', (e)=>{ if(e.target===$sheetWrap) closeSheet(); });

/* ---------------- Interactions ---------------- */
function onPileTap(id){
  if(!isMyTurn || mySelected==null) return;
  if(isNumber(mySelected)){ playNumberTx(mySelected,id); return; }
  if(mySelected===POWERS.FLIP)   return playFlipTx(id);
  if(mySelected===POWERS.BUNGEE) return playBungeeTx(id);
  if(mySelected===POWERS.SWAP){
    if(!pending || pending.type!=='SWAP' || !pending.first){ pending={type:'SWAP', first:id}; showHint('Now tap a second pile.'); renderPiles(); return; }
    if(pending.first===id){ pending=null; showHint(''); return; }
    const a=pending.first; pending=null; showHint(''); return playSwapTx(a,id);
  }
}

/* Legacy inline play (kept, but Powers Sheet is primary) */
$play.addEventListener('click', ()=>{
  if(!isMyTurn || !G || G.phase!=='game2' || !isPower(mySelected)) return;
  if(mySelected===POWERS.TIMEWARP){ playTimeWarpTx(); return; }
  if(mySelected===POWERS.TRADE){ pending={type:'TRADE'}; showHint('Tap a player to trade.'); renderPlayers(); updateActions(); return; }
  if(mySelected===POWERS.SWAP){ pending={type:'SWAP'}; showHint('Tap two piles to swap their tops.'); renderPiles(); updateActions(); return; }
  if(mySelected===POWERS.FLIP){ showHint('Tap a pile to flip direction.'); renderPiles(); return; }
  if(mySelected===POWERS.BUNGEE){ showHint('Tap a pile to arm Bungee (¬±20 once).'); renderPiles(); return; }
});

/* End Turn gating ‚Äî only NUMBER plays count as ‚Äúmoves remain‚Äù */
function anyNumberMoves(hand, piles){
  for (const c of hand){
    if (!isNumber(c)) continue;
    for (const p of piles){
      const b = !!(p.effects||[]).find(e=>e.type==='bungee' && e.charges>0);
      if (canPlayOnNumber(c, p, b)) return true;
    }
  }
  return false;
}
function gateEnd(){
  if(!G){ $end.disabled=true; return; }
  const players=G.players||[]; const current=players[G.turnIndex||0]||'';
  const req=minRequiredFor(current,(G.deck||[]).length,G.debts||{});
  const movesRemain = anyNumberMoves(myHand, Object.values(G.piles||{}));
  const earlyPass = (G.timewarpPass && G.timewarpPass===current);
  $end.disabled = !(isMyTurn && ((G.turnPlays||0)>=req || !movesRemain || earlyPass));
}
$end.addEventListener('click', ()=>{ if(isMyTurn) endTurnTx(); });

/* Fullscreen toggle + chip */
$fsBtn.addEventListener('click', ()=>{
  if(!document.fullscreenElement){
    document.documentElement.requestFullscreen?.();
    document.documentElement.classList.add('full');
  }else{
    document.exitFullscreen?.();
    document.documentElement.classList.remove('full');
  }
  setTimeout(()=>{ updateActions(); }, 50);
});
document.addEventListener('fullscreenchange', ()=>{ 
  document.documentElement.classList.toggle('full', !!document.fullscreenElement);
  updateActions();
});

/* ---------------- TX: numbers ---------------- */
async function playNumberTx(card, pileId){
  await runTransaction(db, async tx=>{
    const snap=await tx.get(gameRef); if(!snap.exists()) throw new Error('gone');
    const S=snap.data(); const P=S.players||[]; const cur=P[S.turnIndex||0]||''; if(cur!==me) throw new Error('turn');
    const piles=S.piles||{}; const p=piles[pileId]; if(!p) throw new Error('pile');
    const my=[...(S.hands?.[me]||[])]; const idx=my.indexOf(card); if(idx<0) throw new Error('no card');

    const hasB=!!(p.effects||[]).find(e=>e.type==='bungee'&&e.charges>0);
    if(!canPlayOnNumber(card,p,hasB)) throw new Error('illegal');

    const prev=p.top; p.top=card;
    if(hasB && Math.abs(prev-card)===20){
      const ef=p.effects.find(e=>e.type==='bungee'&&e.charges>0);
      if(ef){ ef.charges--; if(ef.charges<=0) p.effects=p.effects.filter(e=>!(e.type==='bungee'&&e.charges<=0)); }
    }

    my.splice(idx,1); my.sort(sortCards);
    const hands={...S.hands,[me]:my};
    const log=(S.log||[]).slice(-200);
    const backwards=(p.dir===UP && prev-card===10) || (p.dir===DOWN && card-prev===10);
    const b20=(Math.abs(prev-card)===20);
    log.push(`${me} played <b>${card}</b> on ${p.id} ${p.dir===UP?'‚ñ≤':'‚ñº'}${backwards?' via <b>¬±10</b>':''}${b20?' with <b>ü™¢ ¬±20</b>':''} (${prev}‚Üí${card}).`);

    tx.update(gameRef,{piles, hands, turnPlays:(S.turnPlays||0)+1, placed:(S.placed||0)+1, log});
  }).then(()=>{ mySelected=null; pending=null; showHint(''); updateActions(); gateEnd(); }).catch(e=>toast(e.message||'Error'));
}

/* ---------------- TX: powers ---------------- */
async function playFlipTx(pileId){
  await runTransaction(db, async tx=>{
    const snap=await tx.get(gameRef); if(!snap.exists()) throw new Error('gone');
    const S=snap.data(); if(S.phase!=='game2') throw new Error('only 2.0');
    const P=S.players||[]; const cur=P[S.turnIndex||0]||''; if(cur!==me) throw new Error('turn');
    const p=S.piles?.[pileId]; if(!p) throw new Error('pile');

    const my=[...(S.hands?.[me]||[])]; const i=my.indexOf(POWERS.FLIP); if(i<0) throw new Error('no flip');
    my.splice(i,1); p.dir=(p.dir===UP?DOWN:UP);

    const hands={...S.hands,[me]:my};
    const log=(S.log||[]).slice(-200); log.push(`${me} used <b>üîÅ Flip</b> on ${p.id} ‚Äî now <b>${p.dir===UP?'UP':'DOWN'}</b>.`);
    tx.update(gameRef,{piles:S.piles, hands, turnPlays:(S.turnPlays||0)+1, log});
  }).then(()=>{ mySelected=null; showHint(''); updateActions(); gateEnd(); }).catch(e=>toast(e.message||'Error'));
}

async function playBungeeTx(pileId){
  await runTransaction(db, async tx=>{
    const snap=await tx.get(gameRef); if(!snap.exists()) throw new Error('gone');
    const S=snap.data(); if(S.phase!=='game2') throw new Error('only 2.0');
    const P=S.players||[]; const cur=P[S.turnIndex||0]||''; if(cur!==me) throw new Error('turn');
    const p=S.piles?.[pileId]; if(!p) throw new Error('pile');

    const my=[...(S.hands?.[me]||[])]; const i=my.indexOf(POWERS.BUNGEE); if(i<0) throw new Error('no bungee');
    my.splice(i,1);
    const effs=p.effects||[]; const ex=effs.find(e=>e.type==='bungee'); if(ex) ex.charges++; else effs.push({type:'bungee',charges:1});
    p.effects=effs;

    const hands={...S.hands,[me]:my};
    const log=(S.log||[]).slice(-200); log.push(`${me} armed <b>ü™¢ Bungee</b> on ${p.id}.`);
    tx.update(gameRef,{piles:S.piles, hands, turnPlays:(S.turnPlays||0)+1, log});
  }).then(()=>{ mySelected=null; showHint(''); updateActions(); gateEnd(); }).catch(e=>toast(e.message||'Error'));
}

async function playSwapTx(aId,bId){
  await runTransaction(db, async tx=>{
    const snap=await tx.get(gameRef); if(!snap.exists()) throw new Error('gone');
    const S=snap.data(); if(S.phase!=='game2') throw new Error('only 2.0');
    const P=S.players||[]; const cur=P[S.turnIndex||0]||''; if(cur!==me) throw new Error('turn');
    const A=S.piles?.[aId], B=S.piles?.[bId]; if(!A||!B) throw new Error('pile');

    const my=[...(S.hands?.[me]||[])]; const i=my.indexOf(POWERS.SWAP); if(i<0) throw new Error('no swap');
    my.splice(i,1);

    const t=A.top; A.top=B.top; B.top=t;

    const hands={...S.hands,[me]:my};
    const log=(S.log||[]).slice(-200); log.push(`${me} used <b>üîÑ Swap</b> on ${aId}‚Üî${bId}.`);
    tx.update(gameRef,{piles:S.piles, hands, turnPlays:(S.turnPlays||0)+1, log});
  }).then(()=>{ mySelected=null; showHint(''); updateActions(); gateEnd(); }).catch(e=>toast(e.message||'Error'));
}

async function playTradeTx(target){
  await runTransaction(db, async tx=>{
    const snap=await tx.get(gameRef); if(!snap.exists()) throw new Error('gone');
    const S=snap.data(); if(S.phase!=='game2') throw new Error('only 2.0');
    const P=S.players||[]; const cur=P[S.turnIndex||0]||''; if(cur!==me) throw new Error('turn');
    if(target===me) throw new Error('self');

    const my=[...(S.hands?.[me]||[])]; const his=[...(S.hands?.[target]||[])];
    const pi=my.indexOf(POWERS.TRADE); if(pi<0) throw new Error('no trade');
    if(his.length===0 || my.length<=1) throw new Error('no cards');

    my.splice(pi,1);
    const mi=Math.floor(Math.random()*my.length), hi=Math.floor(Math.random()*his.length);
    const myCard=my.splice(mi,1)[0]; const hisCard=his.splice(hi,1)[0];
    my.push(hisCard); his.push(myCard);
    my.sort(sortCards); his.sort(sortCards);

    const hands={...S.hands,[me]:my,[target]:his};
    const log=(S.log||[]).slice(-200); log.push(`${me} used <b>ü§ù Trade</b> with <b>${target}</b>.`);
    tx.update(gameRef,{hands,turnPlays:(S.turnPlays||0)+1,log});
  }).then(()=>{ pending=null; mySelected=null; showHint(''); renderPlayers(); renderHand(); updateActions(); gateEnd(); }).catch(e=>toast(e.message||'Error'));
}

async function playTimeWarpTx(){
  await runTransaction(db, async tx=>{
    const snap=await tx.get(gameRef); if(!snap.exists()) throw new Error('gone');
    const S=snap.data(); if(S.phase!=='game2') throw new Error('only 2.0');
    const P=S.players||[]; const cur=P[S.turnIndex||0]||''; if(cur!==me) throw new Error('turn');

    const my=[...(S.hands?.[me]||[])]; const i=my.indexOf(POWERS.TIMEWARP); if(i<0) throw new Error('no tw');
    my.splice(i,1);

    const debts={...(S.debts||{})}; debts[me]=(debts[me]||0)+1;
    const hands={...S.hands,[me]:my};
    const log=(S.log||[]).slice(-200); log.push(`${me} used <b>‚è≥ Time Warp</b> (may end early; future requirement +1).`);
    tx.update(gameRef,{hands,debts,timewarpPass:me,turnPlays:(S.turnPlays||0)+1,log});
  }).then(()=>{ mySelected=null; showHint(''); updateActions(); renderHand(); gateEnd(); toast('Time Warp ready: you may End Turn now.'); }).catch(e=>toast(e.message||'Error'));
}

/* ---------------- End Turn ---------------- */
async function endTurnTx(){
  await runTransaction(db, async tx=>{
    const snap=await tx.get(gameRef); if(!snap.exists()) throw new Error('gone');
    const S=snap.data();
    const P=S.players||[]; const idx=S.turnIndex||0; const cur=P[idx]||''; if(cur!==me) throw new Error('turn');

    const deck=[...(S.deck||[])]; const hands={...(S.hands||{})};
    const req=minRequiredFor(cur, deck.length, S.debts||{});
    const early=(S.timewarpPass && S.timewarpPass===cur);
    if((S.turnPlays||0) < req && !early) throw new Error('need more');

    const cap=handCap(P.length);
    const mine=[...(hands[me]||[])];
    const before=mine.length;
    while(mine.length<cap && deck.length){ mine.push(deck.pop()); }
    mine.sort(sortCards); hands[me]=mine;

    const next=(idx+1)%P.length; const turnNum = (next===0)?(S.turnNum||1)+1:(S.turnNum||1);
    const log=(S.log||[]).slice(-200); const drew=Math.max(0, cap - before);
    log.push(`${me} ended turn. Drew ${drew}. Next: <b>${P[next]||''}</b>.`);

    const debts={...(S.debts||{})}; let pass=S.timewarpPass;
    if(pass===cur) pass=null;
    if((S.debts||{})[cur]>0){ debts[cur]=Math.max(0,(debts[cur]||0)-1); if(debts[cur]===0) delete debts[cur]; }

    tx.update(gameRef,{deck,hands,turnIndex:next,turnNum,turnPlays:0,log,debts,timewarpPass:pass});
  }).then(()=>{
    mySelected = null;
    pending = null;
    showHint('');
    updateActions();
    gateEnd();
  }).catch(e=>toast(e.message||'Error'));
}

/* ---------------- Log ---------------- */
function renderLog(){
  const log=(G.log||[]).slice(-200);
  $log.innerHTML = log.map(x=>`<div>${x}</div>`).join('');
  $log.scrollTop=$log.scrollHeight;
}

/* ---------------- Kickoff ---------------- */
ensureRoomVotingOrResume();
</script>
</body>
</html>


