<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>üóª Mountain Blade ‚Äî Smooth Net + Arrive</title>
<style>
  :root{ --win-w: 1024px; --win-h: 640px; }
  *{ box-sizing:border-box }
  body{ margin:0; background:#0d1117; color:#eef; font-family:system-ui,Segoe UI,Arial; display:flex; align-items:center; justify-content:center; min-height:100vh; }
  .game-wrap{ width:var(--win-w); }
  .frame{ position:relative; width:var(--win-w); height:var(--win-h); border:1px solid #2b3b54; border-radius:12px; overflow:hidden; box-shadow:0 10px 40px rgba(0,0,0,.35); background:#0f1521; }
  .titlebar{ height:38px; display:flex; align-items:center; padding:0 10px; gap:8px; background:#101826; border-bottom:1px solid #203049; font-weight:700; }
  .titlebar .dot{ width:10px; height:10px; border-radius:50%; }
  .dot.red{ background:#ff5f57 } .dot.yellow{ background:#ffbd2e } .dot.green{ background:#28c840 }
  .viewport{ position:absolute; inset:38px 0 0 0; }
  canvas{ width:100%; height:100%; display:block; background:#112238; cursor:crosshair; }

  /* UI overlay */
  #ui{ pointer-events:none; position:absolute; inset:0; }
  #timerBox{ position:absolute; top:8px; left:50%; transform:translateX(-50%); background:#101826cc; border:1px solid #2c3f5a; border-radius:10px; padding:6px 12px; font-weight:700; }
  #leader{ position:absolute; top:8px; right:8px; min-width:220px; background:#101826cc; border:1px solid #2c3f5a; border-radius:10px; padding:8px 10px; }
  #leader h3{ margin:0 0 6px 0; font-size:14px; color:#cfe; }
  #leader .row{ display:flex; justify-content:space-between; padding:2px 0; font-size:13px; color:#bcd; }
  #hint{ position:absolute; top:44px; left:50%; transform:translateX(-50%); background:#18243acc; border:1px solid #355; border-radius:10px; padding:6px 10px; font-size:13px; display:none; }
  #banner{ position:absolute; left:50%; top:24%; transform:translateX(-50%); font-size:28px; padding:10px 16px; background:#102030aa; border:1px solid #345; border-radius:12px; display:none; }

  #cpPanel{ position:absolute; right:10px; top:64px; background:#0d1423e6; border:1px solid #345; border-radius:12px; padding:8px; display:none; pointer-events:auto; }
  #cpPanel h3{ margin:0 0 6px 0; font-size:14px; }
  #cpPanel .row{ display:flex; gap:6px; flex-wrap:wrap; }
  .cpBtn{ padding:6px 10px; border:1px solid #456; background:#1a2436; color:#cde; border-radius:8px; cursor:pointer; }

  #hud{ position:absolute; left:0; right:0; bottom:0; height:108px; background:rgba(0,0,0,.35); backdrop-filter:blur(4px); border-top:1px solid #263042; display:flex; align-items:center; gap:16px; padding:10px 16px; pointer-events:auto; }
  #selInfo{ min-width:280px; line-height:1.25; }
  #abilities{ display:flex; gap:10px; }
  .slot{ width:72px; height:72px; border:1px solid #445; border-radius:10px; display:flex; flex-direction:column; align-items:center; justify-content:center; background:#1a2232; position:relative; }
  .slot .key{ position:absolute; right:6px; bottom:4px; font-size:12px; color:#9ab; }
  .slot .emoji{ font-size:24px; }
  .slot .name{ font-size:11px; color:#c9d4e3; margin-top:4px; text-align:center; }
  .slot.oncd::after{ content:""; position:absolute; inset:0; background:rgba(0,0,0,.45); border-radius:10px; }
  .cd-badge{ position:absolute; top:4px; right:6px; font-size:11px; color:#cfe; background:#0008; border:1px solid #345; border-radius:6px; padding:1px 5px; }
  .chip{ display:inline-block; padding:4px 8px; border:1px solid #3a4a62; border-radius:8px; font-size:12px; margin-top:6px; background:#0f1828; }
</style>
</head>
<body>
  <div class="game-wrap">
    <div class="frame">
      <div class="titlebar">
        <span class="dot red"></span><span class="dot yellow"></span><span class="dot green"></span>
        <span>üóª Mountain Blade</span>
      </div>
      <div class="viewport">
        <canvas id="cv" width="1024" height="602"></canvas>
        <div id="ui">
          <div id="timerBox">‚è±Ô∏è 05:00</div>
          <div id="leader"><h3>Units on field</h3><div id="leaderRows"></div></div>
          <div id="hint"></div>
          <div id="banner"></div>

          <div id="cpPanel">
            <h3>Spawn from <span id="cpName">CP</span></h3>
            <div class="row" id="cpBtns"></div>
          </div>

          <div id="hud">
            <div id="selInfo">Select units</div>
            <div id="abilities"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script type="module">
/* ---------------- Firebase ---------------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, collection, addDoc, onSnapshot,
  query, orderBy, limit, getDocs, deleteDoc
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);

/* ---------------- Params & routes ---------------- */
const Q = new URLSearchParams(location.search);
const GAME_ID  = Q.get("gameId");
const ME       = Q.get("username") || "anon";
const HUB_ROUTE = "/game/index.html"; // change if needed

/* ---------------- Canvas & windowed camera ---------------- */
const cv = document.getElementById("cv");
const ctx = cv.getContext("2d");
const viewportEl = document.querySelector(".viewport");

const WORLD = { w: 2400, h: 2400 };
const cam = { x:0, y:0, speed: 1400 };
function clampCam(){ cam.x=Math.max(0,Math.min(WORLD.w-cv.width,cam.x)); cam.y=Math.max(0,Math.min(WORLD.h-cv.height,cam.y)); }

/* ---------------- Data ---------------- */
const COLORS = ["#5bd","#e86","#7f7","#fc5","#c7f","#f77"];
const AGGRO_RANGE = 260;
const STOP_DIST   = 14;
const MATCH_MS    = 5*60*1000;

// --- Arrive + hysteresis constants (Option A) ---
const ARRIVE_ENTER = 42;     // within this ‚Üí can settle
const ARRIVE_EXIT  = 68;     // beyond this ‚Üí break settle
const SETTLE_MS    = 180;    // must stay inside ENTER for this long
const SLOW_RADIUS  = 180;    // start slowing down when near goal

const TYPES = {
  guardian: { name:"Guardian", emoji:"üõ°Ô∏è", hp:110, dmg:10, range:46, atkSpd:1.0, moveSpd:260, armor:5, size:13,
    abilities:[{slot:1,key:"Q",id:"shieldwall",label:"Shield Wall",target:"self",cd:12,dur:5}]},
  lancer:   { name:"Lancer",   emoji:"üó°Ô∏è", hp:85,  dmg:9,  range:64, atkSpd:1.2, moveSpd:270, armor:3, size:12,
    abilities:[{slot:2,key:"W",id:"brace",label:"Brace",target:"self",cd:10,dur:4}]},
  archer:   { name:"Archer",   emoji:"üèπ", hp:65,  dmg:7,  range:220,atkSpd:1.0, moveSpd:250, armor:1, size:11,
    abilities:[{slot:1,key:"Q",id:"volley",label:"Volley",target:"point",cd:12,radius:120, channel:6000}]},
  cavalry:  { name:"Cavalry",  emoji:"üêé", hp:95,  dmg:12, range:46, atkSpd:0.9, moveSpd:440, armor:2, size:14,
    abilities:[{slot:1,key:"Q",id:"charge",label:"Charge",target:"pointOrUnit",cd:12}]},
  mage:     { name:"Mage",     emoji:"üîÆ", hp:55,  dmg:15, range:190,atkSpd:0.7, moveSpd:255, armor:0, size:11,
    abilities:[{slot:1,key:"Q",id:"fireburst",label:"Fireburst",target:"point",cd:12,radius:90}]},
  priest:   { name:"Priest",   emoji:"‚úùÔ∏è", hp:70,  dmg:3,  range:84, atkSpd:0.7, moveSpd:252, armor:1, size:11,
    abilities:[{slot:1,key:"Q",id:"mend",label:"Mend",target:"self",cd:10,dur:5,healPerSec:8}]},
};
const SPAWN_CHOICES = Object.keys(TYPES);

const TEAM_SPAWNS = [
  { x:160, y:160 }, { x: WORLD.w-160, y:160 }, { x:160, y:WORLD.h-160 }, { x:WORLD.w-160, y:WORLD.h-160 }
];
const CMD_POINTS = [
  { id:"P1", x: WORLD.w*0.25, y: WORLD.h*0.30, r: 140 },
  { id:"P2", x: WORLD.w*0.70, y: WORLD.h*0.32, r: 140 },
  { id:"P3", x: WORLD.w*0.50, y: WORLD.h*0.62, r: 140 },
];

/* ---------------- Spatial hash ---------------- */
const SPATIAL = { cell: 64 };
const toCell = v => (v / SPATIAL.cell) | 0;
const cellKey = (cx, cy) => cx + "|" + cy;
function buildHash(units){ const map=new Map(); for(let i=0;i<units.length;i++){ const u=units[i], k=cellKey(toCell(u.x),toCell(u.y)); (map.get(k)||map.set(k,[]).get(k)).push(i);} return { map }; }
function forNeighbors(hash,x,y,r,cb){ const c=SPATIAL.cell, rc=Math.ceil(r/c), cx=toCell(x), cy=toCell(y); for(let gy=cy-rc;gy<=cy+rc;gy++) for(let gx=cx-rc;gx<=cx+rc;gx++){ const a=hash.map.get(cellKey(gx,gy)); if(!a) continue; for(const i of a) cb(i); }}

/* ---------------- Local state ---------------- */
let isHost=false, lobbyPlayers=[], myTeamIdx=0, state=null;
let selection=new Set();
let dragging=false, dragStart=null;
let targeting=null; // {slot,ability,ids,type}
const groups={};

// --- Interpolation buffer (client) ---
let snapBuf = [];                     // ascending by ts
let hostClockOffset = 0;              // hostTs - localTs EMA
const INTERP_DELAY = 140;             // ms client playback delay

// Firestore refs
const lobbyRef = doc(db,"lobbies",GAME_ID);
const gameRef  = doc(db,"games",GAME_ID,"meta","state");
const snapsCol = collection(db,"games",GAME_ID,"snaps");

async function pushIntent(kind,payload){
  const col=collection(db,"games",GAME_ID,"intents");
  await addDoc(col,{ts:Date.now(),user:ME,kind,payload});
}

/* ---------------- Init ---------------- */
(async function init(){
  const s=await getDoc(lobbyRef); if(!s.exists()){ alert("Lobby not found"); return; }
  const L=s.data(); isHost=(L.host===ME);
  lobbyPlayers = (Array.isArray(L.players) ? L.players.slice(0,4) : []); // max 4
  myTeamIdx = Math.max(0, lobbyPlayers.indexOf(ME));

  const sp=TEAM_SPAWNS[myTeamIdx%TEAM_SPAWNS.length]; cam.x=sp.x-cv.width/2; cam.y=sp.y-cv.height/2; clampCam();

  const g=await getDoc(gameRef);
  if(isHost && !g.exists()){
    const units=[];
    lobbyPlayers.forEach((name,idx)=>{
      const base=TEAM_SPAWNS[idx], pack=["guardian","lancer","archer","cavalry","mage","priest"];
      for(let i=0;i<10;i++){
        const t=pack[i%pack.length], jit=n=>Math.random()*n-n/2;
        units.push(mkUnit(t,name, base.x+(i%5)*24+jit(8), base.y+Math.floor(i/5)*24+jit(8)));
      }
    });
    const points=CMD_POINTS.map(p=>({...p,owner:null,cap:0,spawnType:"guardian",nextSpawnAt:0}));
    const now=Date.now();
    // initial meta with full arrays (host will switch to compact streaming)
    await setDoc(gameRef,{tick:0,startedAt:now,endAt:now+MATCH_MS,winner:null,map:{w:WORLD.w,h:WORLD.h},players:lobbyPlayers,points,units,effects:[]});
  }

  // Listen to meta (timer, points, winner, etc.)
  onSnapshot(gameRef,(snap)=>{ if(!snap.exists()) return; state=snap.data(); renderHUD(); renderTimer(); renderBoard(); maybeWinner(); });

  // Listen to motion snapshots and buffer them
  onSnapshot(query(snapsCol, orderBy("ts","asc"), limit(32)), (qs) => {
    snapBuf = qs.docs.map(d=>d.data());
    if (snapBuf.length){
      // update host clock offset (EMA)
      const hostTs = snapBuf[snapBuf.length-1].ts;
      const sample = hostTs - Date.now();
      hostClockOffset = hostClockOffset===0 ? sample : (hostClockOffset*0.9 + sample*0.1);
    }
  });

  if(isHost) hostLoop();
})();

/* ---------------- Units & helpers ---------------- */
function mkUnit(type,owner,x,y){
  const b=TYPES[type], id=owner.slice(0,2).toUpperCase()+Math.random().toString(36).slice(2,7);
  return {
    id, tt:type, o:owner,
    x:Math.round(x), y:Math.round(y), vx:0, vy:0,
    hp:b.hp, maxHp:b.hp, cd:0, acd:{},
    _order:null, _aura:null, _charge:null, _channel:null, _brake:0, _hold:false,
    _arrive: { at:false, anchorX:0, anchorY:0, lastIn:0 } // Arrive/settle state
  };
}
function d2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }
function clampMag(x,y,m){ const l=Math.hypot(x,y)||1; if(l>m){ x=x/l*m; y=y/l*m; } return [x,y]; }

/* ---------------- Input ---------------- */
const mouse={x:0,y:0,worldX:0,worldY:0,inside:false, clientX:0, clientY:0, inViewport:false};
function relTo(el,e){ const r=el.getBoundingClientRect(); return { x:e.clientX-r.left, y:e.clientY-r.top, w:r.width, h:r.height }; }

window.addEventListener("mousemove",(e)=>{
  mouse.clientX=e.clientX; mouse.clientY=e.clientY;
  const vr=viewportEl.getBoundingClientRect();
  mouse.inViewport = e.clientX>=vr.left && e.clientX<=vr.right && e.clientY>=vr.top && e.clientY<=vr.bottom;
});
cv.addEventListener("mousemove",(e)=>{
  const r=relTo(cv,e);
  mouse.inside = r.x>=0&&r.y>=0&&r.x<=r.w&&r.y<=r.h;
  mouse.x=r.x; mouse.y=r.y; mouse.worldX=cam.x+mouse.x; mouse.worldY=cam.y+mouse.y;
});

cv.addEventListener("mousedown",(e)=>{
  if(e.button===2){
    e.preventDefault();
    if(targeting && (targeting.type==="point"||targeting.type==="pointOrUnit")) return finalizeTarget(mouse.worldX,mouse.worldY);
    const ids=Array.from(selection);
    if(ids.length){
      const enemy=pickClosestEnemy(mouse.worldX,mouse.worldY,28);
      if(enemy){ pushIntent("order",{type:"attackUnit",ids,targetId:enemy.id,wipe:true}); return; }
      pushIntent("order",{type:"attackMove",ids,x:Math.round(mouse.worldX),y:Math.round(mouse.worldY),wipe:true});
    }
    return;
  }
  if(targeting && (targeting.type==="point"||targeting.type==="pointOrUnit")) return finalizeTarget(mouse.worldX,mouse.worldY);
  dragging=true; dragStart={x:mouse.x,y:mouse.y};
});

addEventListener("mouseup",(e)=>{
  if(!dragging) return; dragging=false;
  const dx=mouse.x-dragStart.x, dy=mouse.y-dragStart.y, tiny=Math.hypot(dx,dy)<6;
  if(tiny){
    const picked = pickClosestFriendly(mouse.worldX,mouse.worldY,18);
    if(picked){ if(!e.shiftKey) selection.clear(); selection.add(picked.id); renderHUD(); }
  }else{
    const minx=Math.min(dragStart.x,mouse.x)+cam.x, maxx=Math.max(dragStart.x,mouse.x)+cam.x;
    const miny=Math.min(dragStart.y,mouse.y)+cam.y, maxy=Math.max(dragStart.y,mouse.y)+cam.y;
    const ids = pickInRect(minx,miny,maxx,maxy,ME);
    if(!e.shiftKey) selection.clear();
    for(const id of ids) selection.add(id);
    renderHUD();
  }
});
cv.addEventListener("contextmenu",e=>e.preventDefault());

addEventListener("keydown",(e)=>{
  const k=e.key.toLowerCase();
  if(k==="escape"){ setTarget(null); return; }
  if(["q","w","e","r"].includes(k)){ e.preventDefault(); return castSlot({q:1,w:2,e:3,r:4}[k]); }
  if(k==="a"){ // Attack Nearest
    e.preventDefault();
    const ids=Array.from(selection); if(!ids.length) return;
    pushIntent("orderNearest",{ids});
    return;
  }
  if(k==="h"){ // Hold toggle
    e.preventDefault();
    const ids=Array.from(selection); if(!ids.length) return;
    pushIntent("hold",{ids,toggle:true});
    return;
  }
  if(k>="1"&&k<="9"){
    e.preventDefault();
    if(e.ctrlKey){ groups[k]=new Set(Array.from(selection)); }
    else if(e.shiftKey){ if(groups[k]) for(const id of groups[k]) selection.add(id); }
    else { selection.clear(); if(groups[k]) for(const id of groups[k]) selection.add(id); }
    renderHUD();
  }
});

/* ---------------- Selection helpers (use interpolated view) ---------------- */
function getUnitsView(){
  const iu = interpolateUnits();
  if (iu && iu.length) return iu;
  return state?.units || []; // fallback during initial boot
}
function pickClosestFriendly(wx,wy,rad){
  const units = getUnitsView(); let best=null, bd=rad*rad;
  for(const u of units){ if(u.o!==ME) continue; const d=d2(wx,wy,u.x,u.y); if(d<=bd){ bd=d; best=u; } }
  return best;
}
function pickClosestEnemy(wx,wy,rad){
  const units = getUnitsView(); let best=null, bd=rad*rad;
  for(const u of units){ if(u.o===ME) continue; const d=d2(wx,wy,u.x,u.y); if(d<=bd){ bd=d; best=u; } }
  return best;
}
function pickInRect(x0,y0,x1,y1,owner){
  const units = getUnitsView(); const out=[];
  for(const u of units){ if(u.o!==owner) continue; if(u.x>=x0&&u.x<=x1&&u.y>=y0&&u.y<=y1) out.push(u.id); }
  return out;
}

/* ---------------- Orders & abilities ---------------- */
async function orderAttackMove(wx,wy){
  const ids=Array.from(selection); if(!ids.length) return;
  await pushIntent("order",{type:"attackMove",ids,x:Math.round(wx),y:Math.round(wy),wipe:true});
}
function slotAbility(slot){
  const sel=getUnitsView().filter(u=>selection.has(u.id));
  for(const u of sel){ const t=TYPES[u.tt]; const a=t?.abilities?.find(x=>x.slot===slot); if(a) return a; }
  return null;
}
function setTarget(info){
  targeting=info;
  const hint=document.getElementById("hint");
  if(!info){ hint.style.display="none"; return; }
  hint.textContent=`üéØ ${info.label}: click a target (Esc to cancel)`;
  hint.style.display="block";
}
async function castSlot(slot){
  const ids=Array.from(selection); if(!ids.length) return;
  const ab=slotAbility(slot); if(!ab) return;
  if(ab.target==="self"){ await pushIntent("ability",{slot,ids,mode:"self",wipe:true}); }
  else { setTarget({slot,ability:ab,label:ab.label,type:ab.target,ids}); }
}
async function finalizeTarget(x,y){
  if(!targeting) return;
  const {slot,ids,type}=targeting;
  if(type==="pointOrUnit"){
    const enemy = pickClosestEnemy(x,y,24);
    if(enemy){ await pushIntent("ability",{slot,ids,mode:"unit",targetId:enemy.id,wipe:true}); setTarget(null); return; }
  }
  await pushIntent("ability",{slot,ids,mode:"point",x:Math.round(x),y:Math.round(y),wipe:true});
  setTarget(null);
}

/* ---------------- Ability engine ---------------- */
const AbilityHandlers = {
  shieldwall: { cast(g,u,ab,{mode},now){ if(mode!=="self") return false; u._aura={kind:"shield", until: now + ab.dur*1000}; return true; } },
  brace:      { cast(g,u,ab,{mode},now){ if(mode!=="self") return false; u._aura={kind:"brace",  until: now + ab.dur*1000}; return true; } },
  mend:       { cast(g,u,ab,{mode},now){ if(mode!=="self") return false; u._aura={kind:"mend",   until: now + ab.dur*1000, healPerSec: ab.healPerSec||8}; return true; } },

  // Volley: 6s channel, 3 pulses (1s,3s,5s); archer rooted during channel
  volley:     { cast(g,u,ab,{mode,x,y},now){
                  if(mode!=="point") return false;
                  const until = now + (ab.channel || 6000);
                  u._channel = { kind:"volley", until };
                  g.effects.push({ type:"volleyZone", who:u.o, casterId:u.id, x,y, r:ab.radius||120, pulses:[now+1000,now+3000,now+5000], next:0, until, color:"#aef" });
                  return true;
                } },

  fireburst:  { cast(g,u,ab,{mode,x,y},now){ if(mode!=="point") return false; g.effects.push({type:"fireburst", who:u.o, x,y, r:ab.radius||90, when:now+120, did:false, until:now+500, color:"#f88"}); return true; } },
  charge:     { cast(g,u,ab,{mode,x,y,targetId},now){ if(mode!=="point"&&mode!=="unit") return false; u._order=null; u._charge = mode==="unit" ? {targetId, until:now+1100, impacted:false} : {x,y, until:now+1100, impacted:false}; return true; } },
};

/* ---------------- CP panel ---------------- */
const cpPanel=document.getElementById("cpPanel"), cpName=document.getElementById("cpName"), cpBtns=document.getElementById("cpBtns");
function showCP(point){
  if(!point){ cpPanel.style.display="none"; return; }
  cpName.textContent=point.id; cpBtns.innerHTML="";
  for(const t of SPAWN_CHOICES){
    const b=document.createElement("button"); b.className="cpBtn"; b.textContent=`${TYPES[t].emoji} ${TYPES[t].name}`;
    b.onclick=()=>pushIntent("spawnChoice",{pointId:point.id,troop:t});
    cpBtns.appendChild(b);
  }
  cpPanel.style.display="block";
}
cv.addEventListener("click",()=>{
  if(!state) return;
  for(const p of state.points){
    const dx=p.x-(cam.x+mouse.x), dy=p.y-(cam.y+mouse.y);
    if(dx*dx+dy*dy<=p.r*p.r){ return p.owner===ME ? showCP(p) : showCP(null); }
  }
  showCP(null);
});

/* ---------------- Edge pan (larger zones) ---------------- */
function edgePan(dt){
  if(!mouse.inViewport) return;
  const r=viewportEl.getBoundingClientRect();
  const mx=mouse.clientX, my=mouse.clientY;
  const marginX = 60;  // wider left/right pan zones
  const marginTop = 80;
  const marginBot = 160;

  let vx=0, vy=0;
  if(mx<=r.left+marginX) vx-=1; else if(mx>=r.right-marginX) vx+=1;
  if(my<=r.top+marginTop) vy-=1; else if(my>=r.bottom-marginBot) vy+=1;

  cam.x += vx*cam.speed*dt; cam.y += vy*cam.speed*dt; clampCam();
}

/* ---------------- Host loop: fixed sim + tiny snaps + periodic meta ---------------- */
async function hostLoop(){
  const intentsCol = collection(db,"games",GAME_ID,"intents");

  // Prime once; keep g in RAM
  let s = await getDoc(gameRef); if(!s.exists()) return;
  let g = s.data();

  let last = performance.now(), acc = 0;
  const FIXED = 1/60;                 // 60 Hz
  const PUB_MS = 90;                  // ~11 Hz motion publish
  const META_MS = 250;                // 4 Hz meta publish
  let lastPub = performance.now();
  let lastMeta = performance.now();
  const MAX_SNAPS = 8;

  function compactUnits(units){
    return units.map(u=>({
      id:u.id, tt:u.tt, o:u.o,
      x:Math.round(u.x), y:Math.round(u.y),
      vx:Math.round(u.vx), vy:Math.round(u.vy),
      hp:Math.round(u.hp)
    }));
  }

  async function publishSnapshot(){
    await addDoc(snapsCol, { ts: Date.now(), tick: g.tick|0, units: compactUnits(g.units) });
    const qSn = await getDocs(query(snapsCol, orderBy("ts","desc"), limit(MAX_SNAPS+4)));
    const extras = qSn.docs.slice(MAX_SNAPS);
    for (const d of extras) await deleteDoc(d.ref);
  }
  async function publishMeta(){
    const meta = {
      tick:g.tick|0, startedAt:g.startedAt, endAt:g.endAt, winner:g.winner,
      map:g.map, players:g.players, points:g.points, effects:g.effects
    };
    await setDoc(gameRef, meta, { merge:false }); // overwrite without large 'units'
  }

  async function consumeIntents(){
    const snap = await getDocs(query(intentsCol, orderBy("ts","asc"), limit(200)));
    if (!snap.size) return;
    const intents = snap.docs.map(d=>({id:d.id, ...d.data()}));
    g = applyIntents(g, intents);
    for (const d of snap.docs) await deleteDoc(d.ref);
  }

  async function step(){
    const now = performance.now();
    acc += Math.min(0.25, (now - last)/1000);
    last = now;

    await consumeIntents();

    while (acc >= FIXED){
      g = simulate(g, FIXED);
      g.tick++;
      acc -= FIXED;
    }

    if (now - lastPub >= PUB_MS){ await publishSnapshot(); lastPub = now; }
    if (now - lastMeta >= META_MS){ await publishMeta(); lastMeta = now; }

    requestAnimationFrame(step);
  }
  step();
}

/* ---------------- Formation helper ---------------- */
function ringOffsets(n, spacing=20){
  if(n<=1) return [{x:0,y:0}];
  const r = Math.max(spacing, Math.sqrt(n)*spacing*0.5);
  const out=[]; for(let i=0;i<n;i++){ const a=(i/n)*Math.PI*2; out.push({x:Math.cos(a)*r, y:Math.sin(a)*r}); }
  return out;
}

/* ---------------- Apply intents (also sets arrive anchors) ---------------- */
function applyIntents(g,intents){
  const byId=new Map(g.units.map(u=>[u.id,u]));
  for(const it of intents){
    const {kind,user,payload}=it;

    if(kind==="hold"){
      const {ids,toggle,enabled}=payload;
      for(const id of ids){
        const u=byId.get(id); if(!u||u.o!==user) continue;
        u._hold = toggle ? !u._hold : !!enabled;
      }
    }

    if(kind==="order"){
      const {ids,wipe}=payload;
      for(const id of ids){
        const u=byId.get(id); if(!u||u.o!==user) continue;
        if(u._charge || u._channel) continue;
        if(wipe){ u._aura=null; u._order=null; }
      }
      if(payload.type==="attackMove"){
        const {x,y}=payload;
        const offs = ringOffsets(ids.length, 18);
        ids.forEach((id,i)=>{
          const u=byId.get(id); if(!u||u.o!==user) return;
          if(u._channel) return;
          u._order={type:"attackMove",x,y, offX:offs[i].x|0, offY:offs[i].y|0, ts:Date.now()};
          u._arrive = { at:false, anchorX:x+(u._order.offX||0), anchorY:y+(u._order.offY||0), lastIn:0 };
        });
      }
      if(payload.type==="attackUnit"){
        const {targetId}=payload;
        for(const id of ids){ const u=byId.get(id); if(!u||u.o!==user) continue; if(u._channel) continue; u._order={type:"attackUnit",targetId,ts:Date.now()}; }
      }
    }

    if(kind==="orderNearest"){
      const {ids}=payload;
      for(const id of ids){
        const u=byId.get(id); if(!u||u.o!==user) continue; if(u._channel) continue;
        let best=null, bd=Infinity;
        for(const v of g.units){ if(v.o===u.o) continue; const d=d2(u.x,u.y,v.x,v.y); if(d<bd){ bd=d; best=v; } }
        if(best){ u._order={type:"attackUnit",targetId:best.id,ts:Date.now()}; }
      }
    }

    if(kind==="ability"){
      const {slot,ids,mode,x,y,targetId,wipe}=payload;
      for(const id of ids){
        const u=byId.get(id); if(!u||u.o!==user) continue;
        if(u._channel) continue;
        const t=TYPES[u.tt]; const ab=t?.abilities?.find(a=>a.slot===slot); if(!ab) continue;
        const ready=!(u.acd && u.acd[slot]>0); if(!ready) continue;
        if(wipe){ u._order=null; }
        const handler = AbilityHandlers[ab.id];
        const ok = handler && handler.cast(g,u,ab,{mode,x,y,targetId},Date.now());
        if(ok){ u.acd[slot]=ab.cd; }
      }
    }

    if(kind==="spawnChoice"){
      const {pointId,troop}=payload; const p=g.points.find(p=>p.id===pointId);
      if(p && p.owner===user && TYPES[troop]) p.spawnType=troop;
    }
  }
  return g;
}

/* ---------------- Effects ---------------- */
function processEffects(g, now){
  for(const e of (g.effects||[])){
    if(e.type==="volleyZone"){
      while(e.next < e.pulses.length && now >= e.pulses[e.next]){
        const DMG = 7;
        for(const v of g.units){
          if(v.o === e.who) continue;
          if(d2(v.x,v.y,e.x,e.y) <= e.r*e.r){
            const armor = (TYPES[v.tt].armor||0);
            v.hp -= Math.max(1, DMG - armor);
          }
        }
        e.next++;
      }
    } else if (e.type==="fireburst"){
      if(!e.did && now >= e.when){
        const DMG = 20;
        for(const v of g.units){
          if(v.o === e.who) continue;
          if(d2(v.x,v.y,e.x,e.y) <= e.r*e.r){
            const armor = (TYPES[v.tt].armor||0);
            v.hp -= Math.max(1, DMG - armor);
          }
        }
        e.did = true;
      }
    }
  }
  g.effects = g.effects.filter(e=>e.until > now);
}

/* ---------------- Simulation (Option A settle + gentler steering) ---------------- */
function simulate(g,dt){
  const now=Date.now(), endAt=g.endAt || (g.startedAt+MATCH_MS);

  // cooldowns & auras/channels/brakes
  for(const u of g.units){
    if(u.cd>0) u.cd=Math.max(0,u.cd-dt);
    for(const k in (u.acd||{})) u.acd[k]=Math.max(0,u.acd[k]-dt);
    if(u._aura && u._aura.until<=now) u._aura=null;
    if(u._aura?.kind==="mend"){ u.hp = Math.min(u.maxHp, u.hp + (u._aura.healPerSec||8)*dt); }
    if(u._charge && u._charge.until<=now) u._charge=null;
    if(u._channel && u._channel.until<=now) u._channel=null;
    if(u._brake>0) u._brake=Math.max(0,u._brake-dt);
  }

  processEffects(g, now);

  // spatial hash
  let hash=buildHash(g.units);

  // capture + spawn (CPs glow and spawn steadily while owned)
  for(const p of g.points){
    const teams=new Map();
    forNeighbors(hash,p.x,p.y,p.r,(i)=>{ const u=g.units[i]; const dx=u.x-p.x,dy=u.y-p.y; if(dx*dx+dy*dy<=p.r*p.r) teams.set(u.o,(teams.get(u.o)||0)+1); });
    const present=[...teams.keys()];
    if(present.length===1){ const owner=present[0]; if(p.owner===owner) p.cap=Math.min(1,p.cap+dt*.25); else { p.cap+=dt*.25; if(p.cap>=1){ p.owner=owner; p.cap=1; p.nextSpawnAt=0; }}}
    else if(present.length>1){ p.cap=Math.max(0,p.cap-dt*.08); if(p.cap===0) p.owner=null; }
    else { p.cap=Math.max(0,p.cap-dt*.02); }

    // steady base-rate spawn while owned
    if(p.owner){
      const period=12000; // base rate
      if(!p.nextSpawnAt) p.nextSpawnAt=now+period;
      if(now>=p.nextSpawnAt){
        const t=p.spawnType||"guardian", j=n=>Math.random()*n-n/2;
        g.units.push(mkUnit(t,p.owner, p.x+j(20), p.y+j(20)));
        p.nextSpawnAt=now+period;
      }
    }
  }

  // orders/AI/combat
  for(const u of g.units){
    const t=TYPES[u.tt], baseRange=t.range;

    // channel root
    if(u._channel?.kind==="volley"){ u.vx=0; u.vy=0; continue; }

    // charge target tracking
    if(u._charge && u._charge.targetId){
      const tgt=g.units.find(x=>x.id===u._charge.targetId);
      if(tgt){ u._charge.x=tgt.x; u._charge.y=tgt.y; }
    }

    // target selection
    let target=null, targetD2=Infinity;
    if(u._order?.type==="attackUnit"){
      const tgt=g.units.find(x=>x.id===u._order.targetId);
      if(tgt){ target=tgt; targetD2=d2(u.x,u.y,tgt.x,tgt.y); } else { u._order=null; }
    }
    if(!target){
      const lookR=Math.max(AGGRO_RANGE, baseRange+60);
      forNeighbors(hash,u.x,u.y,lookR,(i)=>{ const v=g.units[i]; if(!v||v.o===u.o) return; const d=d2(u.x,u.y,v.x,v.y); if(d<targetD2){ targetD2=d; target=v; } });
    }

    // attack
    const inRange = target && targetD2 <= baseRange*baseRange;
    if(inRange && u.cd<=0){
      const armor=(TYPES[target.tt].armor||0) + (target._aura?.kind==="shield" ? 3 : 0);
      const dmg=Math.max(1,t.dmg - armor);
      target.hp -= dmg;
      u.cd = Math.max(.05, 1/t.atkSpd);
    }

    // movement goal with HOLD + arrive hysteresis
    let goal=null;
    if(u._charge){ goal={x:u._charge.x ?? u.x, y:u._charge.y ?? u.y}; }
    else if(u._order?.type==="attackMove"){
      // stick to arrive anchor
      goal = u._arrive.at ? null : { x:u._arrive.anchorX, y:u._arrive.anchorY };
    }
    else if(target && !inRange && !u._hold){ goal={x:target.x, y:target.y}; }

    // ARRIVE: hysteresis + settle timer
    if(u._order?.type==="attackMove"){
      const dxA = (u._arrive.anchorX - u.x), dyA = (u._arrive.anchorY - u.y);
      const distA = Math.hypot(dxA, dyA);

      if(!u._arrive.at){
        if(distA <= ARRIVE_ENTER){
          u._arrive.lastIn = (u._arrive.lastIn || 0) + (dt*1000);
          if(u._arrive.lastIn >= SETTLE_MS){
            u._arrive.at = true;
            u._brake = 0.8; // strong one-time brake
            goal = null;    // stop moving; remain planted
          }
        }else{
          u._arrive.lastIn = 0;
        }
      }else{
        if(distA > ARRIVE_EXIT){
          u._arrive.at = false;
          u._arrive.lastIn = 0;
          goal = { x:u._arrive.anchorX, y:u._arrive.anchorY };
        }else{
          goal = null;
        }
      }
    }

    // desired speed with near-goal slowdown
    let desiredSpeed = t.moveSpd * (u._charge ? 1.7 : 1.0) * ((u._aura?.kind==="brace") ? 0.75 : 1.0);
    if(goal){
      const gx = goal.x - u.x, gy = goal.y - u.y, d = Math.hypot(gx,gy);
      if(d < SLOW_RADIUS) desiredSpeed *= Math.max(0.15, d / SLOW_RADIUS);
    }

    // steering base
    let dx=0,dy=0;
    if(goal && u._brake<=0){
      const gx=goal.x-u.x, gy=goal.y-u.y, dist=Math.hypot(gx,gy);
      if(dist>STOP_DIST){ dx=gx/dist; dy=gy/dist; }
    }

    // separation (gentler to avoid shove-backs)
    let sx=0,sy=0; const sep=24, sepWeight = inRange ? 0.12 : 0.30;
    forNeighbors(hash,u.x,u.y,sep,(i)=>{ const v=g.units[i]; if(!v||v===u) return; const rx=u.x-v.x, ry=u.y-v.y, d2v=rx*rx+ry*ry; if(d2v===0||d2v>sep*sep) return; const d=Math.sqrt(d2v), push=(sep-d)/sep; sx+=(rx/d)*push; sy+=(ry/d)*push; });

    let desX=dx + sepWeight*sx, desY=dy + sepWeight*sy; [desX,desY]=clampMag(desX,desY,1);

    // velocity update (gentler lerp)
    const targetVX=desX*desiredSpeed, targetVY=desY*desiredSpeed;
    const LERP = 0.12; // softer
    u.vx += (targetVX-u.vx)*LERP;
    u.vy += (targetVY-u.vy)*LERP;

    // anti-swirl: damp small tangential component (very mild)
    if(target){
      const dxT = target.x - u.x, dyT = target.y - u.y, d = Math.hypot(dxT,dyT) || 1;
      const nx = dxT/d, ny = dyT/d; const tx = -ny, ty = nx;
      const tang = u.vx*tx + u.vy*ty;
      const damp = inRange ? 0.18 : 0.08;
      u.vx -= tx*tang*damp;
      u.vy -= ty*tang*damp;
    }

    // crowd friction
    let crowd=0; forNeighbors(hash,u.x,u.y,22,(i)=>{ if(g.units[i]!==u) crowd++; });
    const fric = 1/(1+crowd*0.12);
    u.vx *= fric; u.vy *= fric;

    if(u._brake>0){ u.vx*=0.6; u.vy*=0.6; }

    u.x += u.vx*dt; u.y += u.vy*dt;

    // CHARGE impact
    if(u._charge && !u._charge.impacted){
      let impact=false, ix=u.x, iy=u.y;
      if(target && Math.sqrt(targetD2)<=28){ impact=true; ix=target.x; iy=target.y; }
      if(!impact){
        const tx=u._charge.x ?? u.x, ty=u._charge.y ?? u.y;
        if(Math.hypot(tx-u.x,ty-u.y) <= 20) { impact=true; ix=tx; iy=ty; }
      }
      if(impact){
        u._charge.impacted=true;
        const R=42, DMG=14;
        forNeighbors(hash,ix,iy,R,(i)=>{
          const v=g.units[i]; if(!v || v.o===u.o) return;
          const dist=Math.hypot(v.x-ix, v.y-iy);
          if(dist<=R){
            const armor=(TYPES[v.tt].armor||0);
            v.hp -= Math.max(1, DMG - armor);
            const nx=(v.x-ix)/(dist||1), ny=(v.y-iy)/(dist||1);
            v.x += nx*12; v.y += ny*12;
          }
        });
      }
    }
  }

  // collisions (softer push to avoid ping-pong)
  hash=buildHash(g.units); resolveCollisionsHash(g.units,hash);
  g.units=g.units.filter(u=>u.hp>0);

  // victory
  const alive=countByOwner(g.units), owners=Object.keys(alive).filter(o=>alive[o]>0);
  if(!g.winner && owners.length===1) g.winner=owners[0];
  if(!g.winner && now>=endAt){ const w=decideWinner(g,alive); g.winner=w||owners.sort()[0]||(g.players?.[0]??null); }

  return g;
}
function resolveCollisionsHash(units,hash){
  for(let pass=0;pass<2;pass++){
    for(let i=0;i<units.length;i++){
      const u=units[i], ru=(TYPES[u.tt].size||12), rad=ru+18;
      forNeighbors(hash,u.x,u.y,rad,(j)=>{ if(j===i) return; const v=units[j], rv=(TYPES[v.tt].size||12), min=ru+rv+2; const dx=v.x-u.x, dy=v.y-u.y, d2=dx*dx+dy*dy; if(d2===0){ const ang=Math.random()*6.283, off=min/2; u.x-=Math.cos(ang)*off; u.y-=Math.sin(ang)*off; v.x+=Math.cos(ang)*off; v.y+=Math.sin(ang)*off; return;} if(d2<min*min){ const d=Math.sqrt(d2), o=min-d, nx=dx/d, ny=dy/d; const push=0.40; u.x-=nx*o*push*.5; u.y-=ny*o*push*.5; v.x+=nx*o*push*.5; v.y+=ny*o*push*.5; }});
    }
    hash=buildHash(units);
  }
}

/* ---------------- Small helpers ---------------- */
function countByOwner(units){ const m={}; for(const u of units) m[u.o]=(m[u.o]||0)+1; return m; }
function hpByOwner(units){ const m={}; for(const u of units) m[u.o]=(m[u.o]||0)+u.hp; return m; }
function cps(g){ const m={}; for(const p of g.points) if(p.owner) m[p.owner]=(m[p.owner]||0)+1; return m; }
function decideWinner(g,cnt){
  const owners=Object.keys(cnt); if(!owners.length) return null;
  let max=Math.max(...owners.map(o=>cnt[o])), tied=owners.filter(o=>cnt[o]===max);
  if(tied.length===1) return tied[0];
  const hp=hpByOwner(g.units); let best=Math.max(...tied.map(o=>hp[o]||0)); tied=tied.filter(o=>(hp[o]||0)===best); if(tied.length===1) return tied[0];
  const cp=cps(g); best=Math.max(...tied.map(o=>cp[o]||0)); tied=tied.filter(o=>(cp[o]||0)===best); return tied.length===1?tied[0]:tied.sort()[0];
}
function tint(owner){ return COLORS[(hash(owner)%COLORS.length)]; }
function hash(s){ let h=0; for(let i=0;i<s.length;i++) h=(h*31 + s.charCodeAt(i))|0; return Math.abs(h); }
function short(n){ return n.length>8? n.slice(0,8)+"‚Ä¶" : n; }

/* ---------------- Interpolation (client render) ---------------- */
function getRenderTime(){ return Date.now() + hostClockOffset - INTERP_DELAY; }
function indexForTime(t){
  for(let i=1;i<snapBuf.length;i++){
    if (snapBuf[i-1].ts <= t && t <= snapBuf[i].ts) return i;
  }
  return -1;
}
function interpolateUnits(){
  if (!snapBuf.length) return state?.units || [];
  const t = getRenderTime();
  if (t <= snapBuf[0].ts) return snapBuf[0].units;

  const idx = indexForTime(t);
  if (idx !== -1){
    const a = snapBuf[idx-1], b = snapBuf[idx];
    const span = Math.max(1, b.ts - a.ts);
    const alpha = Math.max(0, Math.min(1, (t - a.ts) / span));

    const A = new Map(a.units.map(u=>[u.id,u]));
    const B = new Map(b.units.map(u=>[u.id,u]));
    const all = new Set([...A.keys(), ...B.keys()]);
    const out = [];
    for(const id of all){
      const u0=A.get(id), u1=B.get(id);
      if(!u0 && u1){ out.push(u1); continue; }
      if(u0 && !u1){ out.push(u0); continue; }
      const x0=u0.x, y0=u0.y, x1=u1.x, y1=u1.y;
      const vx0=u0.vx||0, vy0=u0.vy||0, vx1=u1.vx||0, vy1=u1.vy||0;
      const t2=alpha*alpha, t3=t2*alpha;
      const h00= 2*t3-3*t2+1, h10=t3-2*t2+alpha, h01=-2*t3+3*t2, h11=t3-t2;
      const dt = span/1000;
      const x = h00*x0 + h10*(vx0*dt) + h01*x1 + h11*(vx1*dt);
      const y = h00*y0 + h10*(vy0*dt) + h01*y1 + h11*(vy1*dt);
      out.push({ ...u1, x, y });
    }
    return out;
  }

  // short extrapolation
  const last = snapBuf[snapBuf.length-1];
  const dtMs = Math.min(100, t - last.ts);
  return last.units.map(u=>({ ...u, x: u.x + (u.vx||0)*(dtMs/1000), y: u.y + (u.vy||0)*(dtMs/1000) }));
}

/* ---------------- Render ---------------- */
function draw(){
  const dt=16/1000; edgePan(dt);
  ctx.clearRect(0,0,cv.width,cv.height);

  // background + grid
  ctx.fillStyle="#122238"; ctx.fillRect(0,0,cv.width,cv.height);
  ctx.strokeStyle="#1a2b40"; ctx.lineWidth=1; const grid=100;
  for(let x=-cam.x%grid; x<cv.width; x+=grid){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cv.height); ctx.stroke(); }
  for(let y=-cam.y%grid; y<cv.height; y+=grid){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cv.width,y); ctx.stroke(); }

  if(state){
    // Control Points
    for(const p of state.points){
      const sx=p.x-cam.x, sy=p.y-cam.y;
      ctx.beginPath(); ctx.arc(sx,sy,p.r,0,Math.PI*2);
      ctx.strokeStyle="#556f9a"; ctx.lineWidth=2; ctx.stroke();

      if(p.owner){
        const color=tint(p.owner);
        ctx.save();
        ctx.shadowColor=color; ctx.shadowBlur=18;
        ctx.beginPath(); ctx.arc(sx,sy,p.r,0,Math.PI*2);
        ctx.strokeStyle=color; ctx.lineWidth=6; ctx.stroke();
        ctx.restore();

        ctx.beginPath(); ctx.arc(sx,sy,p.r*Math.max(.12,p.cap),0,Math.PI*2);
        ctx.fillStyle=color+"44";
        ctx.fill();
      }

      if(p.owner && p.nextSpawnAt){
        const period=12000, rem=Math.max(0,p.nextSpawnAt-Date.now()), prog=1-(rem/period);
        ctx.beginPath(); ctx.arc(sx,sy,24,-Math.PI/2,-Math.PI/2+prog*2*Math.PI);
        ctx.strokeStyle="#aef"; ctx.lineWidth=4; ctx.stroke();
      }

      ctx.fillStyle="#cde"; ctx.fillText(p.id+(p.owner?` (${short(p.owner)})`:""), sx-18, sy-(p.r+6));
    }

    // effects
    for(const e of (state.effects||[])){
      if(e.type==="volleyZone" || e.type==="fireburst"){
        const sx=e.x-cam.x, sy=e.y-cam.y;
        ctx.beginPath(); ctx.arc(sx,sy,e.r,0,Math.PI*2);
        ctx.strokeStyle=e.color||"#fff"; ctx.lineWidth=3; ctx.stroke();
      }
    }

    // interpolated units
    const units = getUnitsView();
    ctx.textAlign="center"; ctx.textBaseline="middle";
    for(const u of units){
      const t=TYPES[u.tt]; const sx=u.x-cam.x, sy=u.y-cam.y;
      const color=tint(u.o);

      // team ring
      ctx.beginPath(); ctx.arc(sx,sy, t.size+10, 0, Math.PI*2);
      ctx.fillStyle = color + "44"; ctx.fill();
      ctx.lineWidth = 2; ctx.strokeStyle = color; ctx.stroke();

      // (no aura/channel from snaps; visuals come from meta/effects)

      // emoji
      ctx.font=`${Math.max(18,t.size*2)}px system-ui`; ctx.fillText(t.emoji, sx, sy);

      // selection ring
      if(selection.has(u.id)){ ctx.strokeStyle="#fffa"; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(sx,sy,t.size+18,0,Math.PI*2); ctx.stroke(); }

      // hp
      ctx.fillStyle="#111"; ctx.fillRect(sx-18, sy-24, 36, 6);
      const hpw=Math.max(0,36*Math.min(1,(u.hp/(TYPES[u.tt].hp||1)))); ctx.fillStyle="#4f8"; ctx.fillRect(sx-18, sy-24, hpw, 6);
    }
  }

  // drag box
  if(dragging){ const x=Math.min(dragStart.x,mouse.x), y=Math.min(dragStart.y,mouse.y), w=Math.abs(mouse.x-dragStart.x), h=Math.abs(mouse.y-dragStart.y); ctx.strokeStyle="#9bf"; ctx.lineWidth=1.5; ctx.strokeRect(x,y,w,h); }

  requestAnimationFrame(draw);
}
draw();

/* ---------------- Timer & leaderboard & winner ---------------- */
function renderTimer(){
  if(!state) return;
  const box=document.getElementById("timerBox");
  const end=state.endAt || (state.startedAt+MATCH_MS);
  let sec=Math.max(0,Math.floor((end-Date.now())/1000));
  const m=String(Math.floor(sec/60)).padStart(2,"0"), s=String(sec%60).padStart(2,"0");
  box.textContent=`‚è±Ô∏è ${m}:${s}`;
}
function renderBoard(){
  // use interpolated units for counts
  const units = getUnitsView();
  const rows=document.getElementById("leaderRows");
  const counts={}; for(const n of (state?.players||[])) counts[n]=0; for(const u of units) counts[u.o]=(counts[u.o]||0)+1;
  const sorted=Object.entries(counts).sort((a,b)=>b[1]-a[1]||a[0].localeCompare(b[0]));
  rows.innerHTML=""; for(const [n,c] of sorted){ const d=document.createElement("div"); d.className="row"; d.innerHTML=`<span>${short(n)}</span><span>${c}</span>`; rows.appendChild(d); }
}
function maybeWinner(){
  if(!state?.winner) return;
  const b=document.getElementById("banner");
  b.textContent=`üèÜ ${state.winner} wins! Returning to lobby‚Ä¶`;
  b.style.display="block";
  setTimeout(()=>{ location.href=`${HUB_ROUTE}?username=${encodeURIComponent(ME)}`; }, 4500);
}

/* ---------------- Abilities HUD + Hold status ---------------- */
function renderHUD(){
  if(!state) return;
  const abil=document.getElementById("abilities"), selInfo=document.getElementById("selInfo");
  const sel=getUnitsView().filter(u=>selection.has(u.id));
  const anyHold = false; // not synced to client; purely cosmetic
  selInfo.innerHTML = sel.length
    ? `${sel.length} unit(s) selected ‚Äî <strong>A</strong>: attack nearest, <strong>H</strong>: toggle HOLD` + (anyHold? ` <span class="chip">HOLD ON</span>`:` <span class="chip">HOLD OFF</span>`)
    : "Select units";

  const slotMap = new Map(); const slotCd  = new Map();
  for(const u of sel){
    const t=TYPES[u.tt];
    (t.abilities||[]).forEach(a=>{
      slotMap.set(a.slot,{ name:a.label, key:a.key, emoji:t.emoji });
      const rem = 0; // (cooldowns not mirrored in snaps)
      const cur = slotCd.get(a.slot);
      if(cur==null || rem<cur) slotCd.set(a.slot, rem);
    });
  }
  const keys={1:"Q",2:"W",3:"E",4:"R"}; abil.innerHTML="";
  for(let s=1;s<=4;s++){
    const spec=slotMap.get(s);
    const div=document.createElement("div"); div.className="slot";
    div.innerHTML = spec
      ? `<div class="emoji">${spec.emoji}</div><div class="name">${spec.name}</div><span class="key">${keys[s]}</span>`
      : `<div class="emoji">‚Äî</div><div class="name">‚Äî</div><span class="key">${keys[s]}</span>`;
    if(spec){
      const rem = slotCd.get(s) || 0;
      if(rem>0){ div.classList.add("oncd"); const b=document.createElement("div"); b.className="cd-badge"; b.textContent=String(Math.ceil(rem)); div.appendChild(b); }
      div.onclick=()=>castSlot(s);
    }
    abil.appendChild(div);
  }
}
</script>
</body>
</html>





