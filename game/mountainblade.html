<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>üóª Mountain Blade ‚Äî Grid Tactics (POP Units + Short Aggro)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{ --win-w: 1024px; --win-h: 640px; }
  *{ box-sizing:border-box }
  body{ margin:0; background:#0b1014; color:#eef; font-family:system-ui,Segoe UI,Arial; display:flex; align-items:center; justify-content:center; min-height:100vh; }
  .game-wrap{ width:var(--win-w); }
  .frame{ position:relative; width:var(--win-w); height:var(--win-h); border:1px solid #21324a; border-radius:12px; overflow:hidden; box-shadow:0 10px 40px rgba(0,0,0,.35); background:#0e1726; }
  .titlebar{ height:38px; display:flex; align-items:center; gap:8px; padding:0 10px; background:#0f1a2b; border-bottom:1px solid #203049; font-weight:700; }
  .titlebar .dot{ width:10px; height:10px; border-radius:50%; }
  .dot.red{ background:#ff5f57 } .dot.yellow{ background:#ffbd2e } .dot.green{ background:#28c840 }
  .viewport{ position:absolute; inset:38px 0 0 0; }
  canvas{ width:100%; height:100%; display:block; background:#0e2a19; cursor:crosshair; }

  /* Grass + fine grid overlay */
  .viewport::before{
    content:""; position:absolute; inset:0;
    background:
      linear-gradient(90deg, rgba(255,255,255,.03) 1px, transparent 1px) 0 0/48px 48px,
      linear-gradient(0deg,  rgba(255,255,255,.03) 1px, transparent 1px) 0 0/48px 48px,
      radial-gradient(closest-side, #1f6a35 0, #135d2e 100%);
    pointer-events:none;
    opacity:.9;
  }

  /* UI overlay */
  #ui{ pointer-events:none; position:absolute; inset:0; }
  #timerBox{ position:absolute; top:8px; left:50%; transform:translateX(-50%); background:#0f1a2bcc; border:1px solid #2c3f5a; border-radius:10px; padding:6px 12px; font-weight:700; }
  #leader{ position:absolute; top:8px; right:8px; min-width:220px; background:#0f1a2bcc; border:1px solid #2c3f5a; border-radius:10px; padding:8px 10px; }
  #leader h3{ margin:0 0 6px 0; font-size:14px; color:#cfe; }
  #leader .row{ display:flex; justify-content:space-between; padding:2px 0; font-size:13px; color:#bcd; }
  #hint{ position:absolute; top:44px; left:50%; transform:translateX(-50%); background:#15243dcc; border:1px solid #355; border-radius:10px; padding:6px 10px; font-size:13px; display:none; }
  #banner{ position:absolute; left:50%; top:24%; transform:translateX(-50%); font-size:28px; padding:10px 16px; background:#102030aa; border:1px solid #345; border-radius:12px; display:none; }

  #cpPanel{ position:absolute; right:10px; top:64px; background:#0d1423e6; border:1px solid #345; border-radius:12px; padding:8px; display:none; pointer-events:auto; }
  #cpPanel h3{ margin:0 0 6px 0; font-size:14px; }
  #cpPanel .row{ display:flex; gap:6px; flex-wrap:wrap; }
  .cpBtn{ padding:6px 10px; border:1px solid #456; background:#1a2436; color:#cde; border-radius:8px; cursor:pointer; }

  #hud{ position:absolute; left:0; right:0; bottom:0; height:108px; background:rgba(0,0,0,.35); backdrop-filter:blur(4px); border-top:1px solid #263042; display:flex; align-items:center; gap:16px; padding:10px 16px; pointer-events:auto; }
  #selInfo{ min-width:280px; line-height:1.25; }
  #abilities{ display:flex; gap:10px; }
  .slot{ width:72px; height:72px; border:1px solid #445; border-radius:10px; display:flex; flex-direction:column; align-items:center; justify-content:center; background:#1a2232; position:relative; }
  .slot .key{ position:absolute; right:6px; bottom:4px; font-size:12px; color:#9ab; }
  .slot .emoji{ font-size:24px; }
  .slot .name{ font-size:11px; color:#c9d4e3; margin-top:4px; text-align:center; }
  .slot.oncd::after{ content:""; position:absolute; inset:0; background:rgba(0,0,0,.45); border-radius:10px; }
  .cd-badge{ position:absolute; top:4px; right:6px; font-size:11px; color:#cfe; background:#0008; border:1px solid #345; border-radius:6px; padding:1px 5px; }
  .chip{ display:inline-block; padding:4px 8px; border:1px solid #3a4a62; border-radius:8px; font-size:12px; margin-top:6px; background:#0f1828; }

  .legend{ position:absolute; left:8px; top:8px; background:#0f1a2bcc; border:1px solid #2c3f5a; border-radius:10px; padding:6px 10px; font-size:12px; }
</style>
</head>
<body>
  <div class="game-wrap">
    <div class="frame">
      <div class="titlebar">
        <span class="dot red"></span><span class="dot yellow"></span><span class="dot green"></span>
        <span>üóª Mountain Blade ‚Äî Grid</span>
      </div>
      <div class="viewport">
        <canvas id="cv" width="1024" height="602"></canvas>
        <div id="ui">
          <div id="timerBox">‚è±Ô∏è 05:00</div>
          <div class="legend">Left-drag: select ‚Ä¢ Right-click: attack-move ‚Ä¢ Q/W/E: abilities ‚Ä¢ A: attack nearest ‚Ä¢ H: hold</div>
          <div id="leader"><h3>Units on field</h3><div id="leaderRows"></div></div>
          <div id="hint"></div>
          <div id="banner"></div>

          <div id="cpPanel">
            <h3>Spawn at <span id="cpName">CP</span></h3>
            <div class="row" id="cpBtns"></div>
          </div>

          <div id="hud">
            <div id="selInfo">Select units</div>
            <div id="abilities"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script type="module">
/* --------------- Firebase --------------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, collection, addDoc, onSnapshot,
  query, orderBy, limit, getDocs, deleteDoc
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);

/* --------------- Params --------------- */
const Q = new URLSearchParams(location.search);
const GAME_ID  = Q.get("gameId") || "local";
const ME       = Q.get("username") || "anon";
const HUB_ROUTE = "/game/index.html";

/* --------------- Canvas & camera --------------- */
const cv = document.getElementById("cv");
const ctx = cv.getContext("2d", { alpha: false });
const viewportEl = document.querySelector(".viewport");

const TILE = 48;
const GRID_W = 50, GRID_H = 50;
const WORLD = { w: GRID_W*TILE, h: GRID_H*TILE };
const cam = { x:0, y:0, speed: 1400 };
function clampCam(){ cam.x=Math.max(0,Math.min(WORLD.w-cv.width,cam.x)); cam.y=Math.max(0,Math.min(WORLD.h-cv.height,cam.y)); }

/* --------------- Colors & helpers --------------- */
const TEAM_COLORS = ["#5bd","#e86","#7f7","#fc5","#c7f","#f77"];
function tint(owner){ return TEAM_COLORS[(hash(owner)%TEAM_COLORS.length)]; }
function hash(s){ let h=0; for(let i=0;i<s.length;i++) h=(h*31 + s.charCodeAt(i))|0; return Math.abs(h); }
function short(n){ return n.length>8? n.slice(0,8)+"‚Ä¶" : n; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function manhattan(ax,ay,bx,by){ return Math.abs(ax-bx)+Math.abs(ay-by); }
function cheby(ax,ay,bx,by){ return Math.max(Math.abs(ax-bx),Math.abs(ay-by)); }

/* --------------- Game constants --------------- */
const MATCH_MS = 5*60*1000;
const INTERP_DELAY = 100; // intentionally low; jumpy look
const CP_CAPTURE_SETTLE_MS = 500; // must be uncontested this long to flip

// NEW: keep units from auto-chasing too far
const AGGRO_TILES = 7;

/* --------------- Units / Types (grid tuned) --------------- */
const PX_PER_S_TO_SQUARES_PER_S = 1 / (TILE * 0.9); // ~52 px = 1 square (slightly slower than exact)
const TYPES = {
  guardian: { name:"Guardian", emoji:"üõ°Ô∏è", hp:110, dmg:10, rangeTiles:1, atkSpd:1.0, moveSpd:260, armor:5,
    abilities:[{slot:1,key:"Q",id:"shieldwall",label:"Shield Wall",target:"self",cd:12,dur:5}]},
  lancer:   { name:"Lancer",   emoji:"üó°Ô∏è", hp:85,  dmg:9,  rangeTiles:1, atkSpd:1.2, moveSpd:270, armor:3,
    abilities:[{slot:2,key:"W",id:"brace",label:"Brace",target:"self",cd:10,dur:4}]},
  archer:   { name:"Archer",   emoji:"üèπ", hp:65,  dmg:7,  rangeTiles:4, atkSpd:1.0, moveSpd:250, armor:1,
    abilities:[{slot:1,key:"Q",id:"volley",label:"Volley (3 pulses)",target:"point",cd:12,size:3,channel:6000}]},
  cavalry:  { name:"Cavalry",  emoji:"üêé", hp:95,  dmg:12, rangeTiles:1, atkSpd:0.9, moveSpd:440, armor:2,
    abilities:[{slot:1,key:"Q",id:"charge",label:"Charge (line)",target:"pointOrUnit",cd:6}]},
  mage:     { name:"Mage",     emoji:"üîÆ", hp:55,  dmg:15, rangeTiles:3, atkSpd:0.7, moveSpd:255, armor:0,
    abilities:[
      {slot:1,key:"Q",id:"fireburst",label:"Fireburst (square)",target:"point",cd:12,size:2},
      {slot:2,key:"W",id:"arcaneBolt",label:"Arcane Bolt (line)",target:"pointOrUnit",cd:6,speedTiles:10,rangeTiles:10, dmg:34, armorPierce:0.5}
    ]},
  priest:   { name:"Priest",   emoji:"‚úùÔ∏è", hp:70,  dmg:3,  rangeTiles:2, atkSpd:0.7, moveSpd:252, armor:1,
    abilities:[{slot:1,key:"Q",id:"mend",label:"Mend (self)",target:"self",cd:10,dur:5,healPerSec:8}]},
};
const SPAWN_CHOICES = Object.keys(TYPES);

/* --------------- Spawns & Control Points (grid coords) --------------- */
const TEAM_SPAWNS = [
  { gx:2, gy:2 }, { gx: GRID_W-3, gy:2 }, { gx:2, gy:GRID_H-3 }, { gx:GRID_W-3, gy:GRID_H-3 }
];

const CTRL_POINTS = [
  { id:"CP1", gx:12, gy:12 },
  { id:"CP2", gx:GRID_W-13, gy:12 },
  { id:"CP3", gx:Math.floor(GRID_W/2), gy:Math.floor(GRID_H/2) },
  { id:"CP4", gx:12, gy:GRID_H-13 },
  { id:"CP5", gx:GRID_W-13, gy:GRID_H-13 },
];

/* --------------- State / networking --------------- */
let isHost=false, lobbyPlayers=[], myTeamIdx=0, state=null;
let selection=new Set();
let dragging=false, dragStart=null;
let targeting=null;
const groups={};

let snapBuf = [];
let hostClockOffset = 0;

// Firestore refs
const lobbyRef = doc(db,"lobbies",GAME_ID);
const gameRef  = doc(db,"games",GAME_ID,"meta","state");
const snapsCol = collection(db,"games",GAME_ID,"snaps");

async function pushIntent(kind,payload){
  const col=collection(db,"games",GAME_ID,"intents");
  await addDoc(col,{ts:Date.now(),user:ME,kind,payload});
}

/* --------------- Init --------------- */
(async function init(){
  const s=await getDoc(lobbyRef); if(!s.exists()){ alert("Lobby not found"); return; }
  const L=s.data(); isHost=(L.host===ME);
  lobbyPlayers = (Array.isArray(L.players) ? L.players.slice(0,4) : []);
  myTeamIdx = Math.max(0, lobbyPlayers.indexOf(ME));

  const sp=TEAM_SPAWNS[myTeamIdx%TEAM_SPAWNS.length]; // center cam on spawn
  cam.x = sp.gx*TILE - cv.width/2 + TILE/2; cam.y = sp.gy*TILE - cv.height/2 + TILE/2; clampCam();

  const g=await getDoc(gameRef);
  if(isHost && !g.exists()){
    const units=[];
    lobbyPlayers.forEach((name,idx)=>{
      const base=TEAM_SPAWNS[idx];
      const pack=["guardian","lancer","archer","cavalry","mage","priest"];
      for(let i=0;i<8;i++){
        const t=pack[i%pack.length];
        const offx=(i%4), offy=Math.floor(i/4);
        units.push(mkUnit(t,name, base.gx+offx, base.gy+offy));
      }
    });

    const points=CTRL_POINTS.map(p=>({
      id:p.id, gx:p.gx, gy:p.gy,
      owner:null, // team name
      uncontestedSince: 0,
      spawnType:"guardian", nextSpawnAt:0
    }));

    const now=Date.now();
    await setDoc(gameRef,{
      tick:0, startedAt:now, endAt:now+MATCH_MS, winner:null,
      map:{w:WORLD.w, h:WORLD.h, tile:TILE, gridW:GRID_W, gridH:GRID_H},
      players:lobbyPlayers, points, units, effects:[]
    });
  }

  // meta
  onSnapshot(gameRef,(snap)=>{ if(!snap.exists()) return; state=snap.data(); renderHUD(); renderTimer(); renderBoard(); maybeWinner(); });

  // motion
  onSnapshot(query(snapsCol, orderBy("ts","asc"), limit(32)), (qs) => {
    snapBuf = qs.docs.map(d=>d.data());
    if (snapBuf.length){
      const hostTs = snapBuf[snapBuf.length-1].ts;
      const sample = hostTs - Date.now();
      hostClockOffset = hostClockOffset===0 ? sample : (hostClockOffset*0.9 + sample*0.1);
    }
  });

  if(isHost) hostLoop();
})();

/* --------------- Units --------------- */
function mkUnit(type,owner,gx,gy){
  const b=TYPES[type], id=owner.slice(0,2).toUpperCase()+Math.random().toString(36).slice(2,7);
  return {
    id, tt:type, o:owner,
    gx: clamp(gx,0,GRID_W-1), gy: clamp(gy,0,GRID_H-1),
    x: 0, y: 0, // derived pixel centers during publish
    hp:b.hp, maxHp:b.hp,
    cd:0, acd:{}, _aura:null, _channel:null, _charge:null, _hold:false,
    goalGX:null, goalGY:null,
    nextStepAt:0, axisPref: (Math.random()<.5)?"x":"y" // tie-breaker to reduce swirl
  };
}
function unitCenterPx(u){ return { x: u.gx*TILE + TILE/2, y: u.gy*TILE + TILE/2 }; }

/* --------------- Input --------------- */
const mouse={x:0,y:0,worldX:0,worldY:0,inside:false, clientX:0, clientY:0, inViewport:false};
const viewportElRect = ()=>viewportEl.getBoundingClientRect();
function relTo(el,e){ const r=el.getBoundingClientRect(); return { x:e.clientX-r.left, y:e.clientY-r.top, w:r.width, h:r.height }; }
function worldToGrid(wx,wy){ return { gx: clamp(Math.floor(wx/TILE),0,GRID_W-1), gy: clamp(Math.floor(wy/TILE),0,GRID_H-1) }; }

window.addEventListener("mousemove",(e)=>{
  mouse.clientX=e.clientX; mouse.clientY=e.clientY;
  const vr=viewportElRect();
  mouse.inViewport = e.clientX>=vr.left && e.clientX<=vr.right && e.clientY<=vr.bottom && e.clientY>=vr.top;
});
cv.addEventListener("mousemove",(e)=>{
  const r=relTo(cv,e);
  mouse.inside = r.x>=0&&r.y>=0&&r.x<=r.w&&r.y<=r.h;
  mouse.x=r.x; mouse.y=r.y; mouse.worldX=cam.x+mouse.x; mouse.worldY=cam.y+mouse.y;
});

cv.addEventListener("mousedown",(e)=>{
  if(e.button===2){
    e.preventDefault();
    const ids=Array.from(selection); if(!ids.length) return;
    const {gx,gy} = worldToGrid(mouse.worldX, mouse.worldY);
    pushIntent("order",{type:"attackMove",ids,gx,gy,wipe:true});
    return;
  }
  dragging=true; dragStart={x:mouse.x,y:mouse.y};
});
addEventListener("mouseup",(e)=>{
  if(!dragging) return; dragging=false;
  const dx=mouse.x-dragStart.x, dy=mouse.y-dragStart.y, tiny=Math.hypot(dx,dy)<6;
  if(tiny){
    const picked = pickUnitAt(mouse.worldX,mouse.worldY, ME);
    if(picked){ if(!e.shiftKey) selection.clear(); selection.add(picked.id); renderHUD(); }
  }else{
    const minx=Math.min(dragStart.x,mouse.x)+cam.x, maxx=Math.max(dragStart.x,mouse.x)+cam.x;
    const miny=Math.min(dragStart.y,mouse.y)+cam.y, maxy=Math.max(dragStart.y,mouse.y)+cam.y;
    const ids = pickInRect(minx,miny,maxx,maxy,ME);
    if(!e.shiftKey) selection.clear();
    for(const id of ids) selection.add(id);
    renderHUD();
  }
});
cv.addEventListener("contextmenu",e=>e.preventDefault());

addEventListener("keydown",(e)=>{
  const k=e.key.toLowerCase();
  if(k==="escape"){ targeting=null; document.getElementById("hint").style.display="none"; return; }
  if(["q","w","e","r"].includes(k)){ e.preventDefault(); return castSlot({q:1,w:2,e:3,r:4}[k]); }
  if(k==="a"){
    e.preventDefault();
    const ids=Array.from(selection); if(!ids.length) return;
    pushIntent("orderNearest",{ids});
    return;
  }
  if(k==="h"){
    e.preventDefault();
    const ids=Array.from(selection); if(!ids.length) return;
    pushIntent("hold",{ids,toggle:true});
    return;
  }
  if(k>="1"&&k<="9"){
    e.preventDefault();
    if(e.ctrlKey){ groups[k]=new Set(Array.from(selection)); }
    else if(e.shiftKey){ if(groups[k]) for(const id of groups[k]) selection.add(id); }
    else { selection.clear(); if(groups[k]) for(const id of groups[k]) selection.add(id); }
    renderHUD();
  }
});

/* --------------- Picking --------------- */
function getUnitsView(){
  if (snapBuf.length){
    const last = snapBuf[snapBuf.length-1];
    return last.units || [];
  }
  return state?.units || [];
}
function pickUnitAt(wx,wy, ownerFilter){
  const units=getUnitsView();
  const {gx,gy}=worldToGrid(wx,wy);
  for(const u of units){
    if(ownerFilter && u.o!==ownerFilter) continue;
    if(u.gx===gx && u.gy===gy) return u;
  }
  return null;
}
function pickInRect(x0,y0,x1,y1,owner){
  const units=getUnitsView();
  const g0=worldToGrid(x0,y0), g1=worldToGrid(x1,y1);
  const minGX=Math.min(g0.gx,g1.gx), maxGX=Math.max(g0.gx,g1.gx);
  const minGY=Math.min(g0.gy,g1.gy), maxGY=Math.max(g0.gy,g1.gy);
  const out=[];
  for(const u of units){ if(u.o!==owner) continue; if(u.gx>=minGX&&u.gx<=maxGX&&u.gy>=minGY&&u.gy<=maxGY) out.push(u.id); }
  return out;
}

/* --------------- Orders & abilities --------------- */
function slotAbility(slot){
  const sel=getUnitsView().filter(u=>selection.has(u.id));
  for(const u of sel){ const t=TYPES[u.tt]; const a=t?.abilities?.find(x=>x.slot===slot); if(a) return a; }
  return null;
}
async function castSlot(slot){
  const ids=Array.from(selection); if(!ids.length) return;
  const ab=slotAbility(slot); if(!ab) return;
  if(ab.target==="self"){ await pushIntent("ability",{slot,ids,mode:"self",wipe:true}); }
  else {
    targeting={slot,ability:ab,ids,type:ab.target,label:ab.label};
    const hint=document.getElementById("hint");
    hint.textContent=`üéØ ${ab.label}: click a tile (Esc to cancel)`;
    hint.style.display="block";
    const once=(e)=>{
      if(e.button!==0){ cv.removeEventListener("click",once); document.getElementById("hint").style.display="none"; targeting=null; return; }
      const {gx,gy}=worldToGrid(mouse.worldX,mouse.worldY);
      finalizeTarget(slot, ab, ids, {gx,gy});
      cv.removeEventListener("click",once);
      document.getElementById("hint").style.display="none";
      targeting=null;
    };
    cv.addEventListener("click",once);
  }
}
async function finalizeTarget(slot,ab,ids,{gx,gy}){
  if(ab.target==="pointOrUnit"){
    const enemy = nearestEnemyAtOrNear(gx,gy, 1.5);
    if(enemy){ await pushIntent("ability",{slot,ids,mode:"unit",targetId:enemy.id,wipe:true}); return; }
  }
  await pushIntent("ability",{slot,ids,mode:"point",gx,gy,wipe:true});
}
function nearestEnemyAtOrNear(gx,gy, rTiles){
  const units=getUnitsView(); let best=null, bd=1e9;
  for(const u of units){ if(u.o===ME) continue; const d=manhattan(gx,gy,u.gx,u.gy); if(d<=rTiles && d<bd){ bd=d; best=u; } }
  return best;
}

/* --------------- Ability handlers (grid AOE) --------------- */
const AbilityHandlers = {
  shieldwall: { cast(g,u,ab,{mode},now){ if(mode!=="self") return false; u._aura={kind:"shield", until: now + ab.dur*1000}; return true; } },
  brace:      { cast(g,u,ab,{mode},now){ if(mode!=="self") return false; u._aura={kind:"brace",  until: now + ab.dur*1000}; return true; } },
  mend:       { cast(g,u,ab,{mode},now){ if(mode!=="self") return false; u._aura={kind:"mend",   until: now + ab.dur*1000, healPerSec: ab.healPerSec||8}; return true; } },

  // Volley: 6s channel, 3 pulses at t=1s,3s,5s ‚Üí affects square (size x size tiles)
  volley: { cast(g,u,ab,{mode,gx,gy},now){
    if(mode!=="point") return false;
    const size = ab.size||3;
    const until = now + (ab.channel||6000);
    u._channel = { kind:"volley", until };
    g.effects.push({
      type:"squarePulse", who:u.o, xgx:gx, xgy:gy, size, pulses:[now+1000, now+3000, now+5000], next:0, until,
      color:"#aef", dmg:7, pierce:0
    });
    return true;
  }},

  // Fireburst: quick AOE square
  fireburst: { cast(g,u,ab,{mode,gx,gy},now){
    if(mode!=="point") return false;
    const size=ab.size||2;
    g.effects.push({ type:"squareOnce", who:u.o, xgx:gx, xgy:gy, size, when:now+120, did:false, until:now+500, color:"#f88", dmg:20, pierce:0 });
    return true;
  }},

  // Arcane bolt: Bresenham line to tile / unit; damages first enemy hit
  arcaneBolt: { cast(g,u,ab,{mode,gx,gy,targetId},now){
    let tx=gx, ty=gy;
    if(mode==="unit"){
      const tgt=g.units.find(v=>v.id===targetId);
      if(!tgt) return false;
      tx=tgt.gx; ty=tgt.gy;
    }
    const range=ab.rangeTiles||10, speed=ab.speedTiles||10;
    const line = bresenham(u.gx,u.gy,tx,ty).slice(1, range+1); // path of tiles
    g.projs = g.projs || [];
    g.projs.push({
      type:"bolt", who:u.o, path: line, idx:0, speedTiles:speed, nextHopAt: now, hopMs: Math.max(40, Math.floor(1000/speed)),
      dmg:ab.dmg||34, ap:ab.armorPierce??0.5, color:"#baf"
    });
    return true;
  }},

  // Charge: dash line; small AOE when reaching target tile
  charge: { cast(g,u,ab,{mode,gx,gy,targetId},now){
    let tx=gx, ty=gy;
    if(mode==="unit"){
      const tgt=g.units.find(v=>v.id===targetId); if(!tgt) return false; tx=tgt.gx; ty=tgt.gy;
    }
    u._charge = { path: bresenham(u.gx,u.gy,tx,ty).slice(1,6), idx:0, until: now+2500, impacted:false };
    return true;
  }},
};

/* --------------- CP panel --------------- */
const cpPanel=document.getElementById("cpPanel"), cpName=document.getElementById("cpName"), cpBtns=document.getElementById("cpBtns");
function showCP(point){
  if(!point){ cpPanel.style.display="none"; return; }
  cpName.textContent=point.id; cpBtns.innerHTML="";
  for(const t of SPAWN_CHOICES){
    const b=document.createElement("button"); b.className="cpBtn"; b.textContent=`${TYPES[t].emoji} ${TYPES[t].name}`;
    b.onclick=()=>pushIntent("spawnChoice",{pointId:point.id,troop:t});
    cpBtns.appendChild(b);
  }
  cpPanel.style.display="block";
}
cv.addEventListener("click",()=>{
  if(!state) return;
  const {gx,gy}=worldToGrid(mouse.worldX,mouse.worldY);
  for(const p of state.points){
    if(p.gx===gx && p.gy===gy){ return p.owner===ME ? showCP(p) : showCP(null); }
  }
  showCP(null);
});

/* --------------- Edge pan --------------- */
function edgePan(dt){
  if(!mouse.inViewport) return;
  const r=viewportEl.getBoundingClientRect();
  const mx=mouse.clientX, my=mouse.clientY;
  const marginX = 60, marginTop = 80, marginBot = 160;

  let vx=0, vy=0;
  if(mx<=r.left+marginX) vx-=1; else if(mx>=r.right-marginX) vx+=1;
  if(my<=r.top+marginTop) vy-=1; else if(my>=r.bottom-marginBot) vy+=1;

  cam.x += vx*cam.speed*dt; cam.y += vy*cam.speed*dt; clampCam();
}

/* --------------- Host loop --------------- */
async function hostLoop(){
  const intentsCol = collection(db, "games", GAME_ID, "intents");
  const snapsCol   = collection(db, "games", GAME_ID, "snaps");

  const s = await getDoc(gameRef); if (!s.exists()) return;
  let g = s.data();
  g.projs = g.projs || [];

  let last = performance.now(), acc = 0;
  const FIXED   = 1/20;   // 20 Hz grid sim (chunky on purpose)
  const PUB_MS  = 120;    // motion publish
  const META_MS = 250;    // meta publish
  let lastPub  = performance.now();
  let lastMeta = performance.now();

  const MAX_SNAPS = 8;

  function compactUnits(units){
    return units.map(u => {
      const c = unitCenterPx(u);
      return { id:u.id, tt:u.tt, o:u.o, gx:u.gx, gy:u.gy, x:Math.round(c.x), y:Math.round(c.y), hp:Math.round(u.hp) };
    });
  }
  function compactProjs(projs){ return (projs||[]).map(p=>({ ...p })); }

  async function consumeIntents(){
    const snap = await getDocs(query(intentsCol, orderBy("ts","asc"), limit(200)));
    if (!snap.size) return;
    const intents = snap.docs.map(d => ({ id:d.id, ...d.data() }));
    g = applyIntents(g, intents);
    for (const d of snap.docs) await deleteDoc(d.ref);
  }

  async function publishSnapshot(){
    await addDoc(snapsCol, {
      ts: Date.now(),
      tick: g.tick|0,
      units: compactUnits(g.units),
      projs: compactProjs(g.projs)
    });
    const qSn = await getDocs(query(snapsCol, orderBy("ts","desc"), limit(MAX_SNAPS + 4)));
    const extras = qSn.docs.slice(MAX_SNAPS);
    for (const d of extras) await deleteDoc(d.ref);
  }
  async function publishMeta(){
    const meta = { tick:g.tick|0, startedAt:g.startedAt, endAt:g.endAt, winner:g.winner, map:g.map, players:g.players, points:g.points, effects:g.effects };
    await setDoc(gameRef, meta, { merge:false });
  }

  if (window.__MB_GRID_HOST_LOOP_RUNNING__) return;
  window.__MB_GRID_HOST_LOOP_RUNNING__ = true;

  async function step(){
    const now = performance.now();
    acc += Math.min(0.25, (now - last)/1000);
    last = now;

    await consumeIntents();
    while (acc >= FIXED){
      g = simulate(g, FIXED);
      g.tick++;
      acc -= FIXED;
    }

    if (now - lastPub >= PUB_MS){ await publishSnapshot(); lastPub = now; }
    if (now - lastMeta >= META_MS){ await publishMeta(); lastMeta = now; }

    requestAnimationFrame(step);
  }
  step();
}

/* --------------- Intent application --------------- */
function bresenham(x0,y0,x1,y1){
  // integer grid line
  const pts=[]; let dx=Math.abs(x1-x0), sx=x0<x1?1:-1; let dy=-Math.abs(y1-y0), sy=y0<y1?1:-1; let err=dx+dy, x=x0,y=y0;
  while(true){ pts.push({gx:x,gy:y}); if(x===x1&&y===y1) break; const e2=2*err; if(e2>=dy){ err+=dy; x+=sx; } if(e2<=dx){ err+=dx; y+=sy; } }
  return pts;
}
function assignFormationTargets(g, ids, centerGX, centerGY){
  // BFS spiral outwards: pick nearest free tiles; reserve per-unit
  const occ = occupancyFromUnits(g.units);
  const reserved = new Set();
  const result = new Map();
  const q = [{gx:centerGX, gy:centerGY}];
  const seen = new Set([centerGX+"|"+centerGY]);

  function push(gx,gy){
    if(gx<0||gy<0||gx>=GRID_W||gy>=GRID_H) return;
    const k=gx+"|"+gy; if(seen.has(k)) return; seen.add(k); q.push({gx,gy});
  }

  let qi=0;
  while(result.size < ids.length && qi<q.length+GRID_W*GRID_H){
    const cur = q[qi++] || {gx:centerGX, gy:centerGY};
    // neighbors (diamond)
    push(cur.gx+1,cur.gy); push(cur.gx-1,cur.gy); push(cur.gx,cur.gy+1); push(cur.gx,cur.gy-1);

    const k = cur.gx+"|"+cur.gy;
    if(occ.has(k) || reserved.has(k)) continue;
    // assign next unassigned unit
    const nextId = ids[result.size];
    result.set(nextId, {gx:cur.gx, gy:cur.gy});
    reserved.add(k);
  }
  return result;
}
function applyIntents(g,intents){
  const byId=new Map(g.units.map(u=>[u.id,u]));
  for(const it of intents){
    const {kind,user,payload}=it;

    if(kind==="hold"){
      const {ids,toggle,enabled}=payload;
      for(const id of ids){ const u=byId.get(id); if(!u||u.o!==user) continue; u._hold = toggle ? !u._hold : !!enabled; }
    }

    if(kind==="order"){
      const {ids,wipe}=payload;
      if(payload.type==="attackMove"){
        const {gx,gy}=payload;
        const targets = assignFormationTargets(g, ids, gx, gy);
        for(const id of ids){
          const u=byId.get(id); if(!u||u.o!==user) continue;
          if(wipe){ u._aura=null; u._channel=null; }
          const t=targets.get(id) || {gx,gy};
          u.goalGX=t.gx; u.goalGY=t.gy;
        }
      }
    }

    if(kind==="orderNearest"){
      const {ids}=payload;
      for(const id of ids){
        const u=byId.get(id); if(!u||u.o!==user) continue;
        let best=null, bd=1e9;
        for(const v of g.units){ if(v.o===u.o) continue; const d=manhattan(u.gx,u.gy,v.gx,v.gy); if(d<bd){ bd=d; best=v; } }
        if(best){ u.goalGX=best.gx; u.goalGY=best.gy; }
      }
    }

    if(kind==="ability"){
      const {slot,ids,mode,gx,gy,targetId,wipe}=payload;
      for(const id of ids){
        const u=byId.get(id); if(!u||u.o!==user) continue;
        if(u._channel) continue;
        const t=TYPES[u.tt]; const ab=t?.abilities?.find(a=>a.slot===slot); if(!ab) continue;
        const ready=!(u.acd && u.acd[slot]>0); if(!ready) continue;
        if(wipe){ /* no-op on grid */ }
        const handler = AbilityHandlers[ab.id];
        const ok = handler && handler.cast(g,u,ab,{mode,gx,gy,targetId},Date.now());
        if(ok){ u.acd[slot]=ab.cd; }
      }
    }

    if(kind==="spawnChoice"){
      const {pointId,troop}=payload; const p=g.points.find(p=>p.id===pointId);
      if(p && p.owner===user && TYPES[troop]) p.spawnType=troop;
    }
  }
  return g;
}

/* --------------- Effects & projectiles --------------- */
function processEffects(g, now){
  for(const e of (g.effects||[])){
    if(e.type==="squarePulse"){
      while(e.next < e.pulses.length && now >= e.pulses[e.next]){
        pulseSquareDamage(g, e.xgx, e.xgy, e.size, e.who, e.dmg, e.pierce||0);
        e.next++;
      }
    } else if (e.type==="squareOnce"){
      if(!e.did && now >= e.when){
        pulseSquareDamage(g, e.xgx, e.xgy, e.size, e.who, e.dmg, e.pierce||0);
        e.did = true;
      }
    }
  }
  g.effects = (g.effects||[]).filter(e=>e.until > now);
}
function pulseSquareDamage(g, cx, cy, size, owner, dmg, pierce){
  const half = Math.floor(size/2);
  for(const v of g.units){
    if(v.o===owner) continue;
    if(Math.abs(v.gx - cx)<=half && Math.abs(v.gy - cy)<=half){
      const baseArmor = (TYPES[v.tt].armor || 0);
      const auraArmor =
        (v._aura?.kind === "shield" ? 3 : 0) +
        (v._aura?.kind === "brace"  ? 2 : 0);
      const totalArmor = baseArmor + auraArmor;
      const effArmor = Math.max(0, totalArmor - totalArmor*(pierce||0));
      v.hp -= Math.max(1, dmg - effArmor);
    }
  }
}

/* --------------- Simulation (grid) --------------- */
function occupancyFromUnits(units){
  const m=new Map();
  for(const u of units){
    const k=u.gx+"|"+u.gy;
    if(!m.has(k)) m.set(k, []);
    m.get(k).push(u);
  }
  return m;
}
function neighborStepToward(u, goalGX, goalGY, occ, reserved){
  if(u.gx===goalGX && u.gy===goalGY) return null;
  const dx = goalGX - u.gx, dy = goalGY - u.gy;
  const cand = [];
  // four cardinal
  cand.push({gx:u.gx+Math.sign(dx), gy:u.gy});
  cand.push({gx:u.gx, gy:u.gy+Math.sign(dy)});
  // prefer axisPref first
  cand.sort((a,b)=>{
    const pa = (u.axisPref==="x" ? (a.gx!==u.gx?0:1) : (a.gy!==u.gy?0:1));
    const pb = (u.axisPref==="x" ? (b.gx!==u.gx?0:1) : (b.gy!==u.gy?0:1));
    return pa - pb;
  });
  // choose that reduces Manhattan the most and is free/unreserved
  let best=null, bd=1e9;
  for(const c of cand){
    if(c.gx<0||c.gy<0||c.gx>=GRID_W||c.gy>=GRID_H) continue;
    const k=c.gx+"|"+c.gy;
    if(occ.has(k) || reserved.has(k)) continue;
    const d = manhattan(c.gx,c.gy, goalGX, goalGY);
    if(d<bd){ bd=d; best=c; }
  }
  return best;
}
function simulate(g, dt){
  const now = Date.now(), endAt = g.endAt || (g.startedAt + MATCH_MS);

  // cooldowns / auras
  for(const u of g.units){
    if(u.cd>0) u.cd = Math.max(0, u.cd - dt);
    for(const k in (u.acd||{})) u.acd[k] = Math.max(0, u.acd[k] - dt);
    if(u._aura && u._aura.until <= now) u._aura = null;
    if(u._aura?.kind === "mend"){ u.hp = Math.min(u.maxHp, u.hp + (u._aura.healPerSec||8)*dt); }
    if(u._channel && u._channel.until <= now) u._channel = null;
  }

  processEffects(g, now);

  // CP capture & spawns
  const occ = occupancyFromUnits(g.units);
  for(const p of g.points){
    const k=p.gx+"|"+p.gy;
    const present = (occ.get(k)||[]);
    const teams = Array.from(new Set(present.map(u=>u.o)));
    if(teams.length===1){
      p.uncontestedSince = p.uncontestedSince ? p.uncontestedSince : now;
      if(now - p.uncontestedSince >= CP_CAPTURE_SETTLE_MS){ p.owner = teams[0]; }
    }else{
      p.uncontestedSince = 0;
    }

    // steady spawn if owned
    if(p.owner){
      const period=12000;
      if(!p.nextSpawnAt) p.nextSpawnAt=now+period;
      if(now>=p.nextSpawnAt){
        const t=p.spawnType||"guardian";
        g.units.push(mkUnit(t,p.owner, p.gx, p.gy));
        p.nextSpawnAt=now+period;
      }
    }
  }

  // Projectiles (arcane bolt): hop along path
  {
    const keep=[];
    for(const pr of (g.projs||[])){
      if(pr.type==="bolt"){
        if(now >= pr.nextHopAt){
          const hops = 1 + Math.floor((now - pr.nextHopAt)/pr.hopMs);
          pr.nextHopAt += hops*pr.hopMs;
          pr.idx = Math.min(pr.idx + hops, pr.path.length-1);
        }
        const tile = pr.path[pr.idx] || pr.path[pr.path.length-1];
        // check hit
        let hit=null;
        for(const u of g.units){
          if(u.o===pr.who) continue;
          if(u.gx===tile.gx && u.gy===tile.gy){ hit=u; break; }
        }
        if(hit){
          const baseArmor=(TYPES[hit.tt].armor||0);
          const auraArmor=(hit._aura?.kind==="shield"?3:0)+(hit._aura?.kind==="brace"?2:0);
          const totalArmor=baseArmor+auraArmor;
          const effArmor=Math.max(0,totalArmor-totalArmor*(pr.ap||0));
          const dmg=Math.max(1, (pr.dmg||30)-effArmor);
          hit.hp -= dmg;
          continue; // consumed
        }
        if(pr.idx < pr.path.length-1){ keep.push(pr); }
      } else keep.push(pr);
    }
    g.projs = keep;
  }

  // Movement reservations (avoid collisions)
  const reserved = new Set();

  // Charge handling (short path)
  for(const u of g.units){
    if(u._channel) continue;
    if(u._charge && u._charge.until > now){
      const step = u._charge.path[u._charge.idx];
      if(step){
        if(!occupiedOrReserved(step.gx,step.gy, occ, reserved)){
          moveTo(u, step.gx, step.gy, occ, reserved);
          u._charge.idx++;
        }else{
          u._charge.until = now; // end charge early if blocked
        }
      }else{
        u._charge.until = now;
      }
      // impact small AOE on landing
      if(!u._charge || u._charge.idx>= (u._charge.path?.length||0)){
        const DMG=14;
        for(const v of g.units){
          if(v.o===u.o) continue;
          if(manhattan(v.gx,v.gy,u.gx,u.gy)<=1){
            const baseArmor=(TYPES[v.tt].armor||0);
            const auraArmor=(v._aura?.kind==="shield"?3:0)+(v._aura?.kind==="brace"?2:0);
            v.hp -= Math.max(1, DMG - (baseArmor+auraArmor));
          }
        }
      }
    }
  }

  // Target selection & attacks
  for(const u of g.units){
    if(u._channel) continue;
    // find nearest enemy
    let target=null, bd=1e9;
    for(const v of g.units){ if(v.o===u.o) continue; const d=manhattan(u.gx,u.gy,v.gx,v.gy); if(d<bd){ bd=d; target=v; } }
    const tSpec=TYPES[u.tt]; const rng=tSpec.rangeTiles||1;
    const inRange = target && (tSpec.rangeTiles>1 ? cheby(u.gx,u.gy,target.gx,target.gy) <= rng : manhattan(u.gx,u.gy,target.gx,target.gy)<=rng);
    if(inRange && u.cd<=0){
      const baseArmor=(TYPES[target.tt].armor||0);
      const auraArmor=(target._aura?.kind==="shield"?3:0)+(target._aura?.kind==="brace"?2:0);
      const armor=baseArmor+auraArmor;
      target.hp -= Math.max(1, (tSpec.dmg||5) - armor);
      u.cd = Math.max(.05, 1/tSpec.atkSpd);
    }
    // auto-goal toward target only if within aggro radius
    const distToTarget = target ? manhattan(u.gx,u.gy,target.gx,target.gy) : 999;
    if(!u._hold && target && !inRange && distToTarget <= AGGRO_TILES && (u.goalGX==null || u.goalGY==null)){
      u.goalGX = target.gx;
      u.goalGY = target.gy;
    }
  }

  // Move step by step (discrete)
  for(const u of g.units){
    if(u._channel) continue;
    if(u.goalGX==null || u.goalGY==null) continue;
    const speedSquares = (TYPES[u.tt].moveSpd || 200) * PX_PER_S_TO_SQUARES_PER_S * (u._aura?.kind==="brace"?0.75:1);
    const stepEveryMs = Math.max(80, Math.floor(1000/Math.max(0.5,speedSquares)));
    if(now < u.nextStepAt) continue;
    u.nextStepAt = now + stepEveryMs;

    // already at goal?
    if(u.gx===u.goalGX && u.gy===u.goalGY){ u.goalGX=null; u.goalGY=null; continue; }

    // try to move one tile that reduces distance
    const step = neighborStepToward(u, u.goalGX, u.goalGY, occ, reserved);
    if(step){
      moveTo(u, step.gx, step.gy, occ, reserved);
    }
  }

  // Resolve double-occupancy (push outwards)
  const occ2 = occupancyFromUnits(g.units);
  for(const [k, list] of occ2){
    if(list.length<=1) continue;
    const keep = list[0];
    for(let i=1;i<list.length;i++){
      const u = list[i];
      const free = nearestFree(u.gx,u.gy, occ2);
      if(free){ u.gx=free.gx; u.gy=free.gy; const nk=free.gx+"|"+free.gy; occ2.set(nk,(occ2.get(nk)||[]).concat(u)); }
    }
    occ2.set(k,[keep]);
  }

  // Kill dead
  g.units = g.units.filter(u => u.hp>0);

  // Victory
  const alive = countByOwner(g.units);
  const owners = Object.keys(alive).filter(o => alive[o]>0);
  if(!g.winner && owners.length===1) g.winner = owners[0];
  if(!g.winner && now>=endAt){
    g.winner = owners.sort((a,b)=>(alive[b]-alive[a])||(b>a?1:-1))[0] || (g.players?.[0] ?? null);
  }

  return g;
}
function occupiedOrReserved(gx,gy, occ, reserved){ return occ.has(gx+"|"+gy) || reserved.has(gx+"|"+gy); }
function moveTo(u, gx, gy, occ, reserved){
  const fromK = u.gx+"|"+u.gy; const list = occ.get(fromK)||[];
  const idx = list.indexOf(u); if(idx>=0){ list.splice(idx,1); if(!list.length) occ.delete(fromK); }
  u.gx=gx; u.gy=gy;
  const toK = gx+"|"+gy; (occ.get(toK)||occ.set(toK,[]).get(toK)).push(u); reserved.add(toK);
}
function nearestFree(gx,gy, occ){
  const seen = new Set([gx+"|"+gy]); const q=[{gx,gy}];
  let qi=0;
  while(qi<q.length && q.length<GRID_W*GRID_H){
    const cur=q[qi++], neigh=[[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dx,dy] of neigh{
      const nx=cur.gx+dx, ny=cur.gy+dy;
      if(nx<0||ny<0||nx>=GRID_W||ny>=GRID_H) continue;
      const k=nx+"|"+ny; if(seen.has(k)) continue; seen.add(k);
      if(!occ.get(k) || occ.get(k).length===0) return {gx:nx,gy:ny};
      q.push({gx:nx,gy:ny});
    }
  }
  return null;
}
function countByOwner(units){ const m={}; for(const u of units) m[u.o]=(m[u.o]||0)+1; return m; }

/* --------------- Render Helpers --------------- */
function roundedRectPath(ctx, x, y, w, h, r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
}

/* --------------- Render --------------- */
function renderTimer(){
  if(!state) return;
  const box=document.getElementById("timerBox");
  const end=state.endAt || (state.startedAt+MATCH_MS);
  let sec=Math.max(0,Math.floor((end-Date.now())/1000));
  const m=String(Math.floor(sec/60)).padStart(2,"0"), s=String(sec%60).padStart(2,"0");
  box.textContent=`‚è±Ô∏è ${m}:${s}`;
}
function renderBoard(){
  if(!state) return;
  const units = getUnitsView();
  const rows=document.getElementById("leaderRows");
  const counts={}; for(const n of (state?.players||[])) counts[n]=0; for(const u of units) counts[u.o]=(counts[u.o]||0)+1;
  const sorted=Object.entries(counts).sort((a,b)=>b[1]-a[1]||a[0].localeCompare(b[0]));
  rows.innerHTML=""; for(const [n,c] of sorted){ const d=document.createElement("div"); d.className="row"; d.innerHTML=`<span>${short(n)}</span><span>${c}</span>`; rows.appendChild(d); }
}
function maybeWinner(){
  if(!state?.winner) return;
  const b=document.getElementById("banner");
  b.textContent=`üèÜ ${state.winner} wins! Returning to lobby‚Ä¶`;
  b.style.display="block";
  setTimeout(()=>{ location.href=`${HUB_ROUTE}?username=${encodeURIComponent(ME)}`; }, 4500);
}
function renderHUD(){
  if(!state) return;
  const abil=document.getElementById("abilities"), selInfo=document.getElementById("selInfo");
  const sel=getUnitsView().filter(u=>selection.has(u.id));
  selInfo.innerHTML = sel.length
    ? `${sel.length} unit(s) selected ‚Äî <strong>A</strong>: attack nearest, <strong>H</strong>: toggle HOLD`
    : "Select units";

  const slotMap = new Map(); const slotCd  = new Map();
  for(const u of sel){
    const t=TYPES[u.tt];
    (t.abilities||[]).forEach(a=>{
      slotMap.set(a.slot,{ name:a.label, key:a.key, emoji:t.emoji });
      const rem = 0;
      const cur = slotCd.get(a.slot);
      if(cur==null || rem<cur) slotCd.set(a.slot, rem);
    });
  }
  const keys={1:"Q",2:"W",3:"E",4:"R"}; abil.innerHTML="";
  for(let s=1;s<=4;s++){
    const spec=slotMap.get(s);
    const div=document.createElement("div"); div.className="slot";
    div.innerHTML = spec
      ? `<div class="emoji">${spec.emoji}</div><div class="name">${spec.name}</div><span class="key">${keys[s]}</span>`
      : `<div class="emoji">‚Äî</div><div class="name">‚Äî</div><span class="key">${keys[s]}</span>`;
    if(spec){ div.onclick=()=>castSlot(s); }
    abil.appendChild(div);
  }
}

function draw(){
  const dt=16/1000; edgePan(dt);

  // base clear
  ctx.fillStyle="#0e2a19"; ctx.fillRect(0,0,cv.width,cv.height);

  // major grid lines
  ctx.strokeStyle="rgba(255,255,255,.06)"; ctx.lineWidth=1;
  for(let x=-cam.x%(TILE*4); x<cv.width; x+=TILE*4){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cv.height); ctx.stroke(); }
  for(let y=-cam.y%(TILE*4); y<cv.height; y+=TILE*4){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cv.width,y); ctx.stroke(); }

  if(state){
    // Control points (PURPLE)
    for(const p of state.points){
      const sx=p.gx*TILE - cam.x, sy=p.gy*TILE - cam.y;
      ctx.fillStyle = "#7a3cff";
      ctx.globalAlpha = .6; ctx.fillRect(sx,sy, TILE, TILE); ctx.globalAlpha=1;
      ctx.strokeStyle="#ad82ff"; ctx.lineWidth=2; ctx.strokeRect(sx+.5,sy+.5,TILE-1,TILE-1);

      if(p.owner){
        const color=tint(p.owner);
        ctx.save();
        ctx.shadowColor=color; ctx.shadowBlur=16;
        ctx.strokeStyle=color; ctx.lineWidth=4; ctx.strokeRect(sx+3,sy+3,TILE-6,TILE-6);
        ctx.restore();
      }

      ctx.fillStyle="#cde"; ctx.font="12px system-ui";
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText(p.id+(p.owner?` (${short(p.owner)})`:""), sx+TILE/2, sy-6);
    }

    // effects (square outlines)
    for(const e of (state.effects||[])){
      const size = (e.size||2), half=Math.floor(size/2);
      const sx=(e.xgx-half)*TILE - cam.x, sy=(e.xgy-half)*TILE - cam.y;
      ctx.strokeStyle = e.color||"#fff"; ctx.lineWidth=3; ctx.strokeRect(sx, sy, size*TILE, size*TILE);
    }

    // projectiles as tile-highlights
    const projs = snapBuf.length ? (snapBuf[snapBuf.length-1].projs||[]) : (state.projs||[]);
    for(const p of projs){
      if(p.type==="bolt"){
        const step = p.path[Math.min(p.idx, p.path.length-1)] || p.path[p.path.length-1];
        const sx=step.gx*TILE - cam.x, sy=step.gy*TILE - cam.y;
        ctx.fillStyle = p.color || "#baf"; ctx.globalAlpha=.85;
        ctx.fillRect(sx+TILE*0.25, sy+TILE*0.25, TILE*0.5, TILE*0.5);
        ctx.globalAlpha=1;
      }
    }

    // ===== POP UNIT CARDS =====
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    const units = getUnitsView();
    for(const u of units){
      const t = TYPES[u.tt];
      const teamColor = tint(u.o);
      const sx = u.gx*TILE + TILE/2 - cam.x;
      const sy = u.gy*TILE + TILE/2 - cam.y;

      const cardW = TILE * 0.96;
      const cardH = TILE * 0.96;
      const x0 = sx - cardW/2;
      const y0 = sy - cardH/2;

      // Drop shadow to lift off grass
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.6)";
      ctx.shadowBlur = 12;
      ctx.shadowOffsetY = 2;

      // Base white card
      roundedRectPath(ctx, x0, y0, cardW, cardH, 8);
      ctx.fillStyle = "#ffffff";
      ctx.fill();

      ctx.restore();

      // Team-color border + subtle inner tint band
      roundedRectPath(ctx, x0, y0, cardW, cardH, 8);
      ctx.lineWidth = 3;
      ctx.strokeStyle = teamColor;
      ctx.stroke();

      // Team banner stripe (top)
      ctx.fillStyle = teamColor + "66";
      const stripeH = Math.max(10, Math.floor(TILE*0.18));
      roundedRectPath(ctx, x0+4, y0+4, cardW-8, stripeH, 6);
      ctx.fill();

      // Emoji/unit icon centered
      ctx.font = "24px system-ui";
      ctx.fillStyle = "#0a0a0a";
      ctx.fillText(t.emoji, sx, sy+2);

      // Selection glow
      if(selection.has(u.id)){
        ctx.save();
        ctx.shadowColor = "#ffffff";
        ctx.shadowBlur = 14;
        roundedRectPath(ctx, x0, y0, cardW, cardH, 8);
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#ffffff";
        ctx.stroke();
        ctx.restore();
      }

      // HP bar inside the card bottom
      const maxHp = (TYPES[u.tt].hp || 1);
      const hpFrac = Math.max(0, Math.min(1, u.hp / maxHp));
      const barPad = 8;
      const barW = cardW - barPad*2;
      const barH = 6;
      const barX = x0 + barPad;
      const barY = y0 + cardH - barPad - barH;

      ctx.fillStyle = "#e7e7e7";
      roundedRectPath(ctx, barX, barY, barW, barH, 3);
      ctx.fill();
      ctx.fillStyle = hpFrac > 0.5 ? "#35d07f" : (hpFrac > 0.25 ? "#ffd166" : "#ff6b6b");
      roundedRectPath(ctx, barX, barY, barW*hpFrac, barH, 3);
      ctx.fill();
    }
  }

  // drag box (grid-aware)
  if(dragging){
    const x=Math.min(dragStart.x,mouse.x), y=Math.min(dragStart.y,mouse.y), w=Math.abs(mouse.x-dragStart.x), h=Math.abs(mouse.y-dragStart.y);
    ctx.strokeStyle="#9bf"; ctx.lineWidth=1.5; ctx.strokeRect(x,y,w,h);
  }

  renderTimer();
  requestAnimationFrame(draw);
}
draw();

function renderHUD(){ /* already defined above, called elsewhere */ }

/* --------------- UI board already wired in --------------- */
function maybeWinner(){ /* already defined above */ }

/* --------------- Helpers used above but ensured defined --------------- */
function renderBoard(){ /* already defined above */ }
function renderTimer(){ /* already defined above */ }

</script>
</body>
</html>













