<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>üè° Estate Defense</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#f7f8fb; --ink:#1f2937; --muted:#6b7280; --card:#ffffff; --line:#e5e7eb;
      --accent:#2e7d32; --danger:#c62828; --violet:#7c3aed;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:Segoe UI,Arial,Helvetica,sans-serif;background:var(--bg);color:var(--ink);display:flex;gap:10px;height:100vh;overflow:hidden}
    #left{flex:0 0 250px;background:var(--card);border-right:1px solid var(--line);padding:12px;display:flex;flex-direction:column;gap:10px}
    #center{flex:1;display:flex;flex-direction:column;gap:8px;min-width:0}
    header{display:flex;align-items:center;justify-content:space-between;padding:8px 12px;background:var(--card);border-bottom:1px solid var(--line)}
    header .tag{font-size:12px;color:#fff;background:var(--accent);padding:2px 8px;border-radius:999px}
    #stats{display:flex;gap:16px;font-size:14px;color:var(--muted)}
    #canvasWrap{position:relative;flex:1;background:#eef3f7;border:1px solid var(--line);display:flex;align-items:center;justify-content:center}
    canvas{display:block;width:720px;height:560px;max-width:100%;max-height:100%}
    #right{flex:0 0 260px;background:var(--card);border-left:1px solid var(--line);padding:12px;display:flex;flex-direction:column;gap:10px}
    .panel h3{margin:0 0 6px 0;font-size:16px}
    .players{display:flex;flex-direction:column;gap:6px;max-height:35vh;overflow:auto}
    .playerRow{display:flex;align-items:center;justify-content:space-between;padding:6px 8px;border:1px solid var(--line);border-radius:8px}
    .dot{width:10px;height:10px;border-radius:50%;display:inline-block;margin-right:6px}
    .shop{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .card{border:1px solid var(--line);border-radius:10px;padding:8px;cursor:pointer;background:#fff}
    .card .emoji{font-size:20px}
    .card.disabled{ opacity:.55; pointer-events:none }
    .btn{padding:8px 10px;border:1px solid var(--line);border-radius:8px;background:#fff;cursor:pointer}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .row{display:flex;gap:8px;align-items:center}
    .small{font-size:12px;color:var(--muted)}
    .toast{position:absolute;left:50%;transform:translateX(-50%);top:10px;background:#111;color:#fff;padding:6px 10px;border-radius:8px;font-size:13px;opacity:.95}
    .chip{background:#fff;border:1px solid var(--line);padding:4px 8px;border-radius:999px;font-size:12px}
    #vScroll {
      position: absolute;
      right: 8px;
      top: 12px;
      height: calc(100% - 24px);
      width: 18px;
      writing-mode: vertical-lr;
      direction: rtl;
      appearance: none;
      background: transparent;
    }
    #vScroll::-webkit-slider-runnable-track { background: #dbe5ff; border-radius: 12px; width: 100%; height: 100%; }
    #vScroll::-moz-range-track { background: #dbe5ff; border-radius: 12px; width: 100%; height: 100%; }
    #vScroll::-webkit-slider-thumb { appearance: none; width: 16px; height: 16px; border-radius: 50%; background: var(--violet); border: none; }
    #vScroll::-moz-range-thumb { width: 16px; height: 16px; border-radius: 50%; background: var(--violet); border: none; }
    #centerBtn{ position:absolute; left:12px; bottom:12px; }
    #leaveBtn{color:#fff;background:var(--danger);border:none}
    @media (max-width: 1200px){
      #left{display:none}
      #right{display:none}
      #center{gap:0}
      header{flex-wrap:wrap;gap:6px}
    }
  </style>
</head>
<body>
  <div id="left">
    <div class="panel">
      <h3>Session</h3>
      <div class="row small"><span id="hostLbl">Host: ‚Ä¶</span><span id="leaseLbl" class="chip">lease ‚Ä¶</span></div>
      <div class="row small">Lobby: <span id="lobbyId">‚Ä¶</span></div>
      <div class="row small">You: <b id="youName">‚Ä¶</b></div>
      <div class="row"><button id="leaveBtn" class="btn">Leave</button></div>
    </div>
    <div class="panel">
      <h3>Players</h3>
      <div id="playersBox" class="players"></div>
    </div>
    <div class="panel">
      <h3>Level</h3>
      <div class="row"><div>Level:</div><b id="levelLbl">1</b></div>
      <div class="row"><div>Kills to next:</div><b id="killsLbl">‚Äî</b></div>
      <div class="row"><div>Core HP:</div><b id="coreHpLbl">‚Äî</b></div>
    </div>
    <div class="panel">
      <h3>Enemies this level</h3>
      <div id="levelEnemies" class="shop"></div>
    </div>
  </div>

  <div id="center">
    <header>
      <div class="row">
        <span class="tag">üè° Estate Defense</span>
        <div id="stats" class="row">
          <div>Funds: <b id="fundsLbl">0</b></div>
          <div>Base income: <b id="baseLbl">0</b> /30s</div>
        </div>
      </div>
      <div class="small">Scroll: wheel / ‚Üë‚Üì / W‚ÄìS or use the slider. ‚ÄúCenter on Core‚Äù jumps to the crystal.</div>
    </header>
    <div id="canvasWrap">
      <canvas id="game" width="720" height="560"></canvas>
      <div id="toast" class="toast" style="display:none"></div>
      <input id="vScroll" type="range" min="0" value="0" step="1">
      <button id="centerBtn" class="chip">Center on Core</button>
    </div>
  </div>

  <div id="right">
    <div class="panel">
      <h3>Build</h3>
      <div class="shop" id="shop"></div>
      <div class="small">Click a card to buy. Towers place near the crystal. Upgrades are owner-only.</div>
    </div>
    <div class="panel">
      <h3>Selected</h3>
      <div id="selInfo" class="small">None</div>
      <div class="row">
        <button id="upgradeBtn" class="btn" disabled>Upgrade</button>
        <button id="sellBtn" class="btn" disabled>Sell</button>
      </div>
    </div>
  </div>

  <script type="module">
    // ----- Firebase -----
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import {
      getFirestore, doc, getDoc, setDoc, updateDoc, runTransaction,
      collection, addDoc, query, orderBy, limit, getDocs, onSnapshot, deleteDoc,
      serverTimestamp, arrayUnion, arrayRemove
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
    import { writeBatch } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";


    const firebaseConfig = {
      apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
      authDomain: "bible-game-246c0.firebaseapp.com",
      projectId: "bible-game-246c0",
      storageBucket: "bible-game-246c0.appspot.com",
      messagingSenderId: "959619818996",
      appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
    };
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // ----- Params -----
    const LOBBY_ROUTE = "/lobby.html";
    const params = new URLSearchParams(location.search);
    const lobbyId = params.get("gameId");
    const me = params.get("username") || "anon";
    document.getElementById('youName').textContent = me;
    document.getElementById('lobbyId').textContent = lobbyId || '‚Äî';

    // ----- Canvas / Map -----
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const TILE = 32, COLS = 20, ROWS = 75;
    const MAP_W = COLS * TILE, MAP_H = ROWS * TILE;
    let camY = MAP_H - H; // start near bottom
    let initialCentered = false;

    // ----- UI -----
    const fundsLbl = document.getElementById('fundsLbl');
    const baseLbl  = document.getElementById('baseLbl');
    const hostLbl  = document.getElementById('hostLbl');
    const leaseLbl = document.getElementById('leaseLbl');
    const levelLbl = document.getElementById('levelLbl');
    const killsLbl = document.getElementById('killsLbl');
    const coreHpLbl= document.getElementById('coreHpLbl');
    const playersBox = document.getElementById('playersBox');
    const shopBox = document.getElementById('shop');
    const selInfo = document.getElementById('selInfo');
    const upgradeBtn = document.getElementById('upgradeBtn');
    const sellBtn = document.getElementById('sellBtn');
    const leaveBtn = document.getElementById('leaveBtn');
    const vScroll = document.getElementById('vScroll');
    const centerBtn = document.getElementById('centerBtn');
    // --- Intents (single, self-contained) ---
const enqueueIntent = (() => {
  const btnsLocal = [upgradeBtn, sellBtn].filter(Boolean);
  let _intentBusy = false;

  return async function(type, payload = {}) {
    if (_intentBusy) return;
    _intentBusy = true;
    btnsLocal.forEach(b => b.disabled = true);
    try {
      await addDoc(intentsCol, {
        ts: Date.now(),
        actor: me,
        type,
        payload: { ...payload, baseIncome: myBaseIncome }
      });
    } finally {
      setTimeout(() => { _intentBusy = false; }, 250);
      btnsLocal.forEach(b => b.disabled = false);
    }
  };
})();


    let amSeeded = false;
    let _buyBusy = false;
    let _actionBusy = false;
    let lastShop = { funds:-1, seeded:false, active:true };

    const toast = (msg, ms=1500) => {
      const t=document.getElementById('toast');
      t.textContent=msg; t.style.display='block';
      setTimeout(()=>t.style.display='none', ms);
    };
    const ELEMENT_EMOJI = { fire:"üî•", frost:"‚ùÑÔ∏è", volt:"‚ö°", nature:"üåø" };

    // ----- Data -----
    const palette = ["#ef4444","#3b82f6","#10b981","#f59e0b","#8b5cf6","#06b6d4","#f97316","#84cc16"];
    const ELEM_COL = {fire:"#ef4444", frost:"#60a5fa", volt:"#f59e0b", nature:"#22c55e"};
    const TOWER_TYPES = [
      { key:"ember",  name:"Ember",  emoji:"üî•", el:"fire",  cost:1, dmg:5,  range:40, rate:1.2, hp:5 },
      { key:"frost",  name:"Frost",  emoji:"‚ùÑÔ∏è", el:"frost", cost:4, dmg:4,  range:50, rate:1.0, hp:5 },
      { key:"volt",   name:"Volt",   emoji:"‚ö°", el:"volt",  cost:5, dmg:6,  range:30, rate:0.9, hp:5 },
      { key:"nature", name:"Thorn",  emoji:"üåø", el:"nature",cost:4, dmg:4,  range:40, rate:1.3, hp:5 },
    ];
    const ELEM_MULT = {
      fire:   { nature:1.5, frost:0.8, volt:1.0, fire:1.0 },
      nature: { volt:1.5, fire:0.8, frost:1.0, nature:1.0 },
      volt:   { frost:1.5, nature:0.8, fire:1.0, volt:1.0 },
      frost:  { fire:1.5, nature:0.8, volt:1.0, frost:1.0 }
    };
    const ENEMY_TYPES = [
      { key:"slime", el:"nature", hp:20, dmg:2, spd:0.8, range:0, target:"core",  minLevel:1 },
      { key:"gob",   el:"fire",   hp:28, dmg:3, spd:1.0, range:0, target:"core",  minLevel:2 },
      { key:"arch",  el:"frost",  hp:22, dmg:2, spd:0.9, range:5, target:"tower", minLevel:3 },
      { key:"brute", el:"volt",   hp:45, dmg:5, spd:0.6, range:0, target:"tower", minLevel:5 },
    ];

    const fmt3 = (n)=> (Math.round((+n||0)*1000)/1000).toFixed(3);


    // ----- State -----
    let state = null;
    let myFunds = 0;
    let myBaseIncome = 0;
    let mySelectedTowerId = null;

    // Track status/epoch for UI transitions
    let _lastStatus = null;
    let _lastEpoch = -1;

    // ----- Host & Firestore -----
    const LEASE_MS = 5000;
    let isHost = false;
    let simInt = null;
    const lobbyRef  = doc(db, "lobbies", lobbyId);
    const intentsCol = collection(db, "lobbies", lobbyId, "intents");

    if (!lobbyId) throw new Error("Missing gameId in URL");

    // Presence
    const presenceCol = collection(db, "lobbies", lobbyId, "presence");
    let presentNames = [];
    const STALE_MS = 45_000;

    onSnapshot(presenceCol, snap => {
      const nowMs = Date.now();
      presentNames = snap.docs
        .filter(d => {
          const ts = d.data()?.lastSeen;
          const ms = ts?.toMillis ? ts.toMillis() : 0;
          return nowMs - ms < STALE_MS;
        })
        .map(d => d.id)
        .sort();
    });

    await setDoc(doc(presenceCol, me), { name: me, lastSeen: serverTimestamp() }, { merge: true });
    const _presenceBeat = setInterval(() => {
      updateDoc(doc(presenceCol, me), { lastSeen: serverTimestamp() }).catch(()=>{});
    }, 15000);

    // Also mirror to root `players`
    await setDoc(lobbyRef, { players: arrayUnion(me) }, { merge: true });

    function cleanupPresence(){
      try { clearInterval(_presenceBeat); } catch {}
      deleteDoc(doc(presenceCol, me)).catch(()=>{});
      updateDoc(lobbyRef, { players: arrayRemove(me) }).catch(()=>{});
    }
    window.addEventListener('beforeunload', cleanupPresence);
    window.addEventListener('pagehide', cleanupPresence);

    // Helpers
    const now = () => Date.now();
    const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
    const dist2 = (x1,y1,x2,y2)=>((x1-x2)**2+(y1-y2)**2);
    const rnd = (a,b)=>a+Math.random()*(b-a);
    const round2=(n)=>Math.round(n*100)/100;
    const playerColor=(name,list)=>palette[Math.max(0,(list||[]).indexOf(name))%palette.length];

    function nearestFreeTile(fromX, fromY, occ){
      const maxR = Math.max(COLS, ROWS);
      for(let r=0; r<maxR; r++){
        for(let dy=-r; dy<=r; dy++){
          for(let dx=-r; dx<=r; dx++){
            if (Math.abs(dx)!==r && Math.abs(dy)!==r) continue;
            const x=fromX+dx, y=fromY+dy;
            if (x<0||x>=COLS||y<0||y>=ROWS) continue;
            if (!occ[y*COLS+x]) return {x,y};
          }
        }
      }
      return null;
    }

 // --- Shop ---
function renderShop(){
  const gameActive = state?.status === 'active'; // only active when state exists & is active
  shopBox.innerHTML = TOWER_TYPES.map(t=>{
    const disabled = !amSeeded || !gameActive || (myFunds < t.cost);
    return `
      <div class="card${disabled ? ' disabled':''}" data-key="${t.key}">
        <div class="row"><span class="emoji">${t.emoji}</span><b>${t.name}</b></div>
        <div class="small">Element: ${t.el}</div>
        <div class="small">Cost: ${t.cost}</div>
        <div class="small">Dmg ${t.dmg} ‚Ä¢ Range ${t.range} ‚Ä¢ Rate ${t.rate}/s</div>
      </div>
    `;
  }).join('');
}

(function bindShopDelegation(){
  let _shopTapLock = false; // local, not shared with intents

  shopBox.addEventListener('pointerdown', async (e)=>{
    if (e.button != null && e.button !== 0) return; // ignore right/middle clicks
    const card = e.target.closest('.card[data-key]');
    if (!card) return;
    if (card.classList.contains('disabled')) return;
    if (!state || state.status !== 'active') return;
    if (!amSeeded){ toast("Joining‚Ä¶ one moment ‚è≥"); return; }
    if (_shopTapLock) return;

    _shopTapLock = true;
    e.preventDefault(); // do this before awaiting; needs {passive:false} below
    try{
      await tryBuy(card.dataset.key); // will call enqueueIntent
    } finally {
      setTimeout(()=>{ _shopTapLock = false; }, 200); // light de-dupe
    }
  }, { passive:false }); // allow preventDefault on touch
})();

    // Which two enemy types spawn this level (deterministic, honors minLevel)
function getLevelEnemyPair(lvl){
  const unlocked = ENEMY_TYPES.filter(t => lvl >= (t.minLevel || 1));
  if (unlocked.length === 0) return [ENEMY_TYPES[0], ENEMY_TYPES[0]];
  if (unlocked.length === 1) return [unlocked[0], unlocked[0]];
  const i1 = lvl % unlocked.length;
  const offset = Math.max(1, Math.floor(unlocked.length / 2));
  const i2 = (i1 + offset) % unlocked.length;
  return [unlocked[i1], unlocked[i2]];
}

// For a defender element, list attacker elements that are >1 (weak) or <1 (resist)
function getWeakResFor(defEl){
  const out = { weakTo: [], resists: [] };
  for (const atkEl of Object.keys(ELEM_MULT)){
    const mult = (ELEM_MULT[atkEl] && ELEM_MULT[atkEl][defEl]) || 1;
    if (mult > 1) out.weakTo.push(atkEl);
    else if (mult < 1) out.resists.push(atkEl);
  }
  return out;
}

const levelEnemiesBox = document.getElementById('levelEnemies');
let _lastLevelShown = -1;

function renderLevelEnemies(g){
  if (!g || !levelEnemiesBox) return;
  const lvl = g.level || 1;
  const pair = getLevelEnemyPair(lvl);
  const fmtList = arr => arr.map(el => `${ELEMENT_EMOJI[el]||''} ${el}`).join(', ') || '‚Äî';

  levelEnemiesBox.innerHTML = pair.map(t => {
    const wr = getWeakResFor(t.el);
    return `
      <div class="card">
        <div class="row">
          <span class="emoji">${ELEMENT_EMOJI[t.el]||''}</span>
          <b>${t.name}</b>
        </div>
        <div class="small">Element: ${t.el}</div>
        <div class="small">Weak to: ${fmtList(wr.weakTo)}</div>
        <div class="small">Resists: ${fmtList(wr.resists)}</div>
      </div>
    `;
  }).join('');
}

function maybeRenderShop(){
  const active = state?.status === 'active';
  if (lastShop.funds !== myFunds || lastShop.seeded !== amSeeded || lastShop.active !== active){
    lastShop = { funds: myFunds, seeded: amSeeded, active };
    renderShop();
  }
}
    async function tryBuy(tKey){
      if (!state || state.status !== 'active') return;
      const def = TOWER_TYPES.find(x => x.key === tKey); if (!def) return;
      if (!amSeeded){ toast("Joining‚Ä¶ one moment ‚è≥"); return; }
      if (myFunds < def.cost){ toast("Not enough funds"); return; }
      await enqueueIntent("BUY", { tKey });
    }

    // Buttons
    upgradeBtn.onclick = async () => {
      if (!state || state.status !== 'active') return;
      if (!mySelectedTowerId) return;
      await enqueueIntent("UPGRADE", { id: mySelectedTowerId });
    };
    sellBtn.onclick = async () => {
      if (!state || state.status !== 'active') return;
      if (!mySelectedTowerId) return;
      await enqueueIntent("SELL", { id: mySelectedTowerId });
    };

    // Leave (manual)
    let _leaving = false;
    leaveBtn.onclick = async ()=>{
      if (_leaving) return;
      _leaving = true;
      leaveBtn.disabled = true;
      try{
        if (typeof cleanupPresence === 'function') {
          cleanupPresence();
        } else {
          await deleteDoc(doc(presenceCol, me)).catch(()=>{});
          await updateDoc(lobbyRef, { players: arrayRemove(me) }).catch(()=>{});
        }
        const pres = await getDocs(presenceCol);
        if (pres.empty){
          try{ await deleteDoc(lobbyRef); }catch(e){}
        }
      } finally {
        location.href = `${LOBBY_ROUTE}?username=${encodeURIComponent(me)}`;
      }
    };

    // Ensure income & announce JOINED
    async function ensureUserIncome(){
      try{
        const uref = doc(db, 'users', me);
        const us   = await getDoc(uref);
        if (!us.exists()){
          myBaseIncome = 1;
          await setDoc(uref, { estate: { baseIncome: myBaseIncome } }, { merge: true });
        } else {
          const estate = us.data()?.estate || {};
          myBaseIncome = (typeof estate.baseIncome === 'number') ? estate.baseIncome : 1;
          if (!us.data().estate){
            await updateDoc(uref, { estate: { baseIncome: myBaseIncome } }).catch(()=>{});
          }
        }
        baseLbl.textContent = round2(myBaseIncome);
        await addDoc(intentsCol, { ts: now(), actor: me, type: "JOINED", payload: { baseIncome: myBaseIncome } });
      } catch(e){
        myBaseIncome = 1;
        await addDoc(intentsCol, { ts: now(), actor: me, type: "JOINED", payload: { baseIncome: myBaseIncome } }).catch(()=>{});
      }
    }

  onSnapshot(lobbyRef, async (docSnap) => {
  if (!docSnap.exists()) {
    location.href = `${LOBBY_ROUTE}?username=${encodeURIComponent(me)}`;
    return;
  }

  const d = docSnap.data() || {};
  hostLbl.textContent = `Host: ${d.host || '‚Äî'}`;
  if (d.host === me && !isHost) beginHosting();

  // Adopt latest game, but keep last good one if field briefly missing
  const nextState = d.game || state;

  // Detect epoch change (for re-centering + toast)
  const epochChanged = !!(nextState && typeof nextState._epoch === 'number' && nextState._epoch !== _lastEpoch);

  // Detect level change (to refresh the "Enemies this level" panel)
  const levelChanged = !!(nextState && (nextState.level || 1) !== (_lastLevelShown || -1));

  state = nextState;

  // Re-center once per epoch
  if (epochChanged) {
    _lastEpoch = nextState._epoch;
    initialCentered = false;
    toast("üîÅ New run!");
  }

  // First-time centering on the core for this epoch
  if (state && state.crystal && !initialCentered) {
    initialCentered = true;
    centerOnCore();
  }

  if (state) {
    // Top-level labels
    levelLbl.textContent = state.level || 1;
    const killsLeft = Math.max(0, (state.killsToAdvance || 10) - (state.killsThisLevel || 0));
    killsLbl.textContent = `${killsLeft}`;
    coreHpLbl.textContent = `${Math.max(0, Math.round(state.crystal?.hp || 0))}/${Math.round(state.crystal?.maxHp || 0)}`;

    // Me / funds / base income
    const meP = (state.players || []).find(p => p.name === me) || null;
    if (meP) {
      myFunds = meP.funds || 0;
      if (typeof meP.baseIncome === 'number') myBaseIncome = meP.baseIncome;
      const myInc = (myBaseIncome || 1) + (meP.baseIncomeDelta || 0);
      baseLbl.textContent = fmt3(myInc);
    }
    fundsLbl.textContent = Math.floor(myFunds);

    // Seed gate + shop refresh
    const wasSeeded = amSeeded;
    amSeeded = !!(meP && meP._seeded);
    if (!wasSeeded && amSeeded) toast("Joined! Shop unlocked.");
    maybeRenderShop();

    // Players list (unchanged)
    playersBox.innerHTML = "";
    (state.players || []).forEach((p, i) => {
      const base = (typeof p.baseIncome === 'number') ? p.baseIncome : 1;
      const inc  = base + (p.baseIncomeDelta || 0);
      const row = document.createElement('div');
      row.className = 'playerRow';
      row.innerHTML = `
        <div><span class="dot" style="background:${palette[i % palette.length]}"></span>${p.name}</div>
        <div class="small">Inc: ${fmt3(inc)} | $${Math.floor(p.funds || 0)}</div>
      `;
      playersBox.appendChild(row);
    });

    // Status toast
    if (_lastStatus !== state.status) {
      if (state.status === 'defeat') toast("üí• Core destroyed! Restarting‚Ä¶", 1500);
      _lastStatus = state.status;
    }

    // üî∏ Refresh the "Enemies this level" panel when level changes
    if (levelChanged) {
      _lastLevelShown = state.level || 1;
      renderLevelEnemies(state); // <- uses your helper from earlier
    }
  }

  // Host election check
  if (shouldClaimHost(docSnap)) await tryClaimHost();
});

    function shouldClaimHost(docSnap){
      const d = docSnap.data() || {};
      const leaseUntil = d.leaseUntil || 0;
      if (!presentNames.includes(me)) return false;
      if (!d.host) return true;
      const expired = (now() > leaseUntil);
      const next = (presentNames[0] || '');
      return expired && (next === me);
    }
function beginHosting(){
  if (isHost) return;
  isHost = true;
  leaseLbl.textContent = "lease: host";
  startHostLoop();
}
    async function tryClaimHost(){
  // quick read: if I already hold a valid lease, just start the loop
  const s0 = await getDoc(lobbyRef);
  if (!s0.exists()) return;
  const d0 = s0.data() || {};
  if (!presentNames.includes(me)) return;

  const leaseUntil0 = d0.leaseUntil || 0;
  const leaseAlive0 = Date.now() <= leaseUntil0;

  if (d0.host === me && leaseAlive0){
    beginHosting();               // ‚Üê start loop on fresh load
    return;
  }
  if (d0.host && leaseAlive0){
    isHost = false;
    leaseLbl.textContent = "lease: client";
    return;                       // someone else is host
  }

  // take over via txn
  let took = false;
  await runTransaction(db, async (tx)=>{
    const s = await tx.get(lobbyRef); if (!s.exists()) return;
    const d = s.data() || {};
    const players = d.players || [];
    if (!players.includes(me)) return;

    const leaseAlive = Date.now() <= (d.leaseUntil || 0);
    if (!d.host || !leaseAlive){
      let game = d.game;
      if (!game) game = buildFreshGameFromPlayers(players);
      tx.update(lobbyRef, { host: me, leaseUntil: Date.now() + LEASE_MS, game });
      took = true;
    }
  }).catch(()=>{});

  if (took) beginHosting();       // ‚Üê start loop after successful claim
}


    function buildFreshGameFromPlayers(players){
      const cx = Math.floor(COLS/2), cy = ROWS-3;
      const seededPlayers = [];
      for (const [i, n] of players.entries()) {
        // Base income is loaded by seeding; default 1 if missing
        seededPlayers.push({ name:n, color:palette[i%palette.length], funds: 0, baseIncome: 1, baseIncomeDelta:0, _seeded:false });
      }
      // The host loop will immediately seed on JOINED/implicit intents; for a brand-new lobby, we'll pre-seed with stored baseIncome:
      // We uplift baseIncome from /users on first JOINED per player; OK to start funds at 0 here.
      return {
        _epoch: 0,
           ver: 0,
        status:'active',
        level:1, killsThisLevel:0, killsToAdvance:20,
        lastTick:now(), nextSpawnAt:now()+1000,
        crystal:{ x:cx, y:cy, hp:1000, maxHp:1000 },
        players: seededPlayers,
        towers:[], enemies:[], projectiles:[]
      };
    }

    function startHostLoop(){ if (simInt) clearInterval(simInt); simInt = setInterval(simulateStepAsHost, 200); }
    setInterval(async ()=>{
      if (isHost) return;
      const s = await getDoc(lobbyRef); if (!s.exists()) return;
      if (shouldClaimHost(s)) await tryClaimHost();
      leaseLbl.textContent = "lease: client";
    }, 2500);

    // Make enemy movement tick-rate independent but similar speed to before.
// You were doing e.y += e.spd every ~0.2s ‚áí ~5 tiles/sec at spd=1.
// SCALE keeps that feel while using dt-based motion.
const ENEMY_MOVE_SCALE = 5;

function stepToward(e, tx, ty, dt){
  // center-to-center vector (tiles are unit grid)
  const dx = (tx + 0.5) - (e.x + 0.5);
  const dy = (ty + 0.5) - (e.y + 0.5);
  const m  = Math.hypot(dx, dy) || 1;
  const v  = e.spd * ENEMY_MOVE_SCALE; // tiles/sec
  e.x += (dx / m) * v * dt;
  e.y += (dy / m) * v * dt;
}

// "Nearest tower anywhere" (no range gate)
function nearestTower(g, e){
  let best = null, bd = Infinity;
  for (const t of g.towers){
    const d = dist2(e.x, e.y, t.x, t.y);
    if (d < bd){ bd = d; best = t; }
  }
  return best;
}


    // ----- Intents + Sim (host) -----
    async function simulateStepAsHost(){
  // Ensure I'm still host
  const s = await getDoc(lobbyRef); if (!s.exists()) return;
  const d = s.data() || {};
  if (d.host !== me){ isHost = false; if (simInt) clearInterval(simInt); return; }

  // If no one present anymore, tear down the lobby
  const presSnap = await getDocs(presenceCol);
  if (presSnap.empty){ try{ await deleteDoc(lobbyRef); }catch(e){} return; }

  // Load or bootstrap game
  let g = d.game;
  if (!g){
    g = buildFreshGameFromPlayers(d.players || []);
  }

  // Auto-restart window
  if (g.status === 'defeat' && g._finalized && g._restartAt && now() >= g._restartAt){
    g = restartGameInPlace(g, d.players || []);
    incomeTickAt = 0; // reset local income cadence
  }

  // ---- Read & apply intents (do NOT delete yet) ----
  const Q = query(intentsCol, orderBy('ts','asc'), limit(100));
  const snap = await getDocs(Q);
  const processedIds = [];
  for (const docu of snap.docs){
    const mv = docu.data();
    try { g = await applyIntent(g, mv); } catch {}
    processedIds.push(docu.id);
  }

  // Tick the sim
  if (g.status === 'active'){
    g = simulate(g);
  }

  // ---- Compare-and-set write with version + host check ----
  const verStart = (typeof g.ver === 'number') ? g.ver : 0;
  const gNext = { ...g, ver: verStart + 1 };

  let wrote = false;
  try{
    await runTransaction(db, async (tx) => {
      const curSnap = await tx.get(lobbyRef); if (!curSnap.exists()) return;
      const cur = curSnap.data() || {};

      // Only current host writes
      if (cur.host !== me) return;

      const curVer = (cur.game && typeof cur.game.ver === 'number') ? cur.game.ver : 0;
      if (curVer !== verStart) return; // someone else advanced; abort

      tx.update(lobbyRef, { game: gNext, leaseUntil: now() + LEASE_MS });
      wrote = true;
    });
  } catch {
    wrote = false;
  }

  // Keep lease fresh even if we lost the race
  if (!wrote){
    try { await updateDoc(lobbyRef, { leaseUntil: now() + LEASE_MS }); } catch {}
  }

  // ---- Only delete intents AFTER a successful write ----
  if (wrote && processedIds.length){
    try{
      const batch = writeBatch(db);
      for (const id of processedIds){
        batch.delete(doc(db, 'lobbies', lobbyId, 'intents', id));
      }
      await batch.commit();
    } catch {}
  }
}


    // Restart builder: keep same players + baseIncome, reset everything else
    function restartGameInPlace(g, rootPlayers){
      // Build a set of current/known players (prefer those already in g.players to preserve colors)
      const presentSet = new Set(rootPlayers || []);
      const nextPlayers = (g.players || [])
        .filter(p => presentSet.has(p.name))
        .map((p,i) => ({
          name: p.name,
          color: p.color || palette[i%palette.length],
          baseIncome: (typeof p.baseIncome==='number') ? p.baseIncome : 1,
          baseIncomeDelta: 0,
          funds: ( (typeof p.baseIncome==='number') ? p.baseIncome : 1 ) * 10, // starting cash = baseIncome * 10
          _seeded: true
        }));

      const cx = Math.floor(COLS/2), cy = ROWS-3;
      return {
        _epoch: (typeof g._epoch==='number'? g._epoch : 0) + 1, // bump epoch so clients re-center
        ver: 0,
        status:'active',
        level:1, killsThisLevel:0, killsToAdvance:20,
        lastTick:now(), nextSpawnAt:now()+1000,
        crystal:{ x:cx, y:cy, hp:1000, maxHp:1000 },
        players: nextPlayers,
        towers:[], enemies:[], projectiles:[]
      };
    }

    async function applyIntent(g, mv){
      const actor = mv.actor;

      // Explicit join ‚Üí seed funds on first time
      if (mv.type === 'JOINED'){
        const base = mv.payload?.baseIncome ?? 1;
        let p = g.players.find(p => p.name === actor);
        if (!p){
          const color = palette[g.players.length % palette.length];
          p = { name: actor, color, funds: base * 10, baseIncome: base, baseIncomeDelta: 0, _seeded: true };
          g.players.push(p);
        } else if (!p._seeded){
          p.funds += base * 10;
          p.baseIncome = base;
          p._seeded = true;
        }
        return g;
      }

      // Implicit join from gameplay intent
      if (mv.type === 'BUY' || mv.type === 'UPGRADE' || mv.type === 'SELL'){
        if (!g.players.some(p => p.name === actor)){
          const base = mv.payload?.baseIncome ?? 1;
          g.players.push({
            name: actor,
            color: palette[g.players.length % palette.length],
            funds: base * 10,
            baseIncome: base,
            baseIncomeDelta: 0,
            _seeded: true
          });
        }
      }

      if (mv.type === 'BUY'){
        if (g.status !== 'active') return g;
        const def = TOWER_TYPES.find(x => x.key === mv.payload?.tKey); if (!def) return g;
        const p = g.players.find(p => p.name === actor); if (!p || p.funds < def.cost) return g;
      
        const occ = new Array(COLS * ROWS).fill(false);
        occ[g.crystal.y * COLS + g.crystal.x] = true;
        g.towers.forEach(t => { occ[t.y * COLS + t.x] = true; });
      
        const spot = nearestFreeTile(g.crystal.x, g.crystal.y - 1, occ); if (!spot) return g;
      
        const id = 't' + Math.random().toString(36).slice(2);
        g.towers.push({
          id, x: spot.x, y: spot.y, owner: actor,
          ownerColor: p.color || '#888',            // <-- store owner color
          emoji: def.emoji, el: def.el,
          hp: def.hp, maxHp: def.hp, level: 1,
          dmg: def.dmg, range: def.range, rate: def.rate, cd: 0
        });
        p.funds -= def.cost;
        return g;
      }


      if (mv.type === 'UPGRADE'){
        if (g.status !== 'active') return g;
        const t = g.towers.find(z => z.id === mv.payload?.id); if (!t || t.owner !== actor) return g;
        const p = g.players.find(p => p.name === actor);
        const cost = 15 + t.level * 10;
        if (!p || p.funds < cost) return g;

        p.funds -= cost;
        t.level += 1;
        t.dmg = Math.round(t.dmg * 1.25);
        t.range += (t.level % 2 === 0 ? 1 : 0);
        t.rate = +(t.rate * 1.05).toFixed(2);
        t.maxHp += 6;
        t.hp = Math.min(t.maxHp, t.hp + 6);
        return g;
      }

      if (mv.type === 'SELL'){
        if (g.status !== 'active') return g;
        const idx = g.towers.findIndex(z => z.id === mv.payload?.id); if (idx < 0) return g;
        const t = g.towers[idx]; if (t.owner !== actor) return g;
        const p = g.players.find(p => p.name === actor);
        if (p) p.funds += 10 + Math.max(0, (t.level - 1)) * 6;
        g.towers.splice(idx, 1);
        return g;
      }

      return g;
    }

    let incomeTickAt = 0;
    let _finalizeOnce = false;
    
function getLevelEnemyPair(lvl){
  const unlocked = ENEMY_TYPES.filter(t => lvl >= (t.minLevel || 1));
  if (unlocked.length === 0) return [ENEMY_TYPES[0], ENEMY_TYPES[0]];
  if (unlocked.length === 1) return [unlocked[0], unlocked[0]];

  // Deterministic, level-based selection so it‚Äôs consistent all level long
  const i1 = lvl % unlocked.length;
  const offset = Math.max(1, Math.floor(unlocked.length / 2));
  const i2 = (i1 + offset) % unlocked.length;

  return [unlocked[i1], unlocked[i2]];
}
    function getOrMakePair(g){
      const lvl = g.level || 1;
      if (g._pairLevel !== lvl){
        g._pair = getLevelEnemyPair(lvl);
        g._pairLevel = lvl;
      }
      return g._pair;
    }
    
  function simulate(g){
  const tNow = now();
  const dt   = (tNow - (g.lastTick ?? tNow)) / 1000;
  g.lastTick = tNow;

      // ---- Spawns ----
      if (now() >= (g.nextSpawnAt || 0)) {
        const lvl   = g.level || 1;
        const count = 2 + Math.floor(lvl * 0.6);
      
        const pair = getOrMakePair(g); // or getLevelEnemyPair(lvl) if you skipped caching
      
        for (let i = 0; i < count; i++) {
          // Alternate to keep a 50/50 split; you could also use Math.random()<0.5
          const base = pair[i & 1];
      
          const mult = Math.pow(1.25, lvl - 1);
          const HP  = Math.round(base.hp  * mult);
          const DMG = Math.round(base.dmg * mult);
          const x = Math.floor(rnd(2, COLS - 3)), y = 0;
      
          g.enemies.push({
            id:'e'+Math.random().toString(36).slice(2),
            x, y,
            el: base.el, type: base.key,
            hp: HP, maxHp: HP, dmg: DMG,
            spd: base.spd, range: base.range,
            target: base.target, cd: 0
          });
        }
      
        g.nextSpawnAt = now() + Math.max(600, 1600 - lvl * 40);
      }

 // ---- Enemies ----
for (const e of g.enemies){
  const cx = g.crystal.x, cy = g.crystal.y;

  if (e.target === 'tower'){
    // If a tower is within attack range, attack; else move toward nearest tower (or crystal if none)
    const inRangeTgt = nearestTowerInRange(g, e, e.range);
    if (inRangeTgt){
      e.cd -= dt;
      if (e.cd <= 0){
        inRangeTgt.hp -= e.dmg;
        e.cd = 1.2;
        if (inRangeTgt.hp <= 0){
          const i = g.towers.findIndex(t => t.id === inRangeTgt.id);
          if (i >= 0) g.towers.splice(i, 1);
        }
      }
    } else {
      const chase = (typeof nearestTower === 'function' ? nearestTower(g, e) : null) || { x: cx, y: cy };
      stepToward(e, chase.x, chase.y, dt);
    }
  } else {
    // "core" enemies: beeline to the crystal
    stepToward(e, cx, cy, dt);
  }

  // After movement, resolve collisions:

  // 1) Tower collision first (tile match): enemy dies, tower takes damage
  const ex = Math.floor(e.x), ey = Math.floor(e.y);
  const tIdx = g.towers.findIndex(t => t.x === ex && t.y === ey);
  if (tIdx >= 0){
    const t = g.towers[tIdx];
    t.hp -= e.dmg;
    if (t.hp <= 0) g.towers.splice(tIdx, 1);
    e.hp = 0;
    continue; // don't also hit the crystal this frame
  }

  // 2) Crystal collision next (tile match): enemy dies, crystal takes damage
  if (ex === cx && ey === cy){
    g.crystal.hp -= e.dmg;
    e.hp = 0;
  }
}



  // ---- Towers (fire projectiles) ----
  for (const t of g.towers){
    t.cd -= dt;
    const tgt = nearestEnemyInRange(g, t, t.range);
    if (tgt && t.cd <= 0){
      const spd = 14;
      const sx = t.x + 0.5, sy = t.y + 0.5;
      const dx = (tgt.x + 0.5) - sx, dy = (tgt.y + 0.5) - sy;
      const m  = Math.hypot(dx, dy) || 1;
      g.projectiles.push({
        id:'p'+Math.random().toString(36).slice(2),
        x:sx, y:sy, vx:dx/m*spd, vy:dy/m*spd,
        dmg:t.dmg, el:t.el, owner:t.owner
      });
      t.cd = 1 / Math.max(0.2, t.rate);
    }
  }

  // ---- Projectiles ----
  for (const p of g.projectiles){
    p.x += p.vx * dt;
    p.y += p.vy * dt;

    if (p.x < 0 || p.x > COLS || p.y < 0 || p.y > ROWS) { p._dead = true; continue; }

    const ex = Math.floor(p.x), ey = Math.floor(p.y);
    const hit = g.enemies.find(e => Math.floor(e.x) === ex && Math.floor(e.y) === ey && e.hp > 0);
    if (!hit) continue;

    const mult = (ELEM_MULT[p.el] && ELEM_MULT[p.el][hit.el]) || 1.0;
    hit.hp -= Math.round(p.dmg * mult);
    p._dead = true;

    if (hit.hp <= 0){
      // ‚ùå no funds on kill
      const lvlGain = Math.pow(1.1, (g.level || 1) - 1);
      const owner = g.players.find(z => z.name === p.owner);
      if (owner){
        // keep long-term growth
        owner.baseIncomeDelta = (owner.baseIncomeDelta || 0) + (0.05 * lvlGain);
      }
      g.killsThisLevel = (g.killsThisLevel || 0) + 1;
      if (g.killsThisLevel >= (g.killsToAdvance || 20)){
        g.level = (g.level || 1) + 1;
        g.killsThisLevel = 0;
        g.killsToAdvance = Math.round((g.killsToAdvance || 20) * 1.25);
      }
    }
  }
  g.projectiles = g.projectiles.filter(p => !p._dead);
  g.enemies     = g.enemies.filter(e => e.hp > 0);

  // ---- Periodic income (every 30s) ----
  if (!incomeTickAt) incomeTickAt = tNow + 30000;
  if (tNow >= incomeTickAt){
    for (const p of g.players){
      const base = (typeof p.baseIncome === 'number' ? p.baseIncome : 1);
      const inc  = base + (p.baseIncomeDelta || 0);
      p.funds += inc;
    }
    incomeTickAt = tNow + 30000;
  }

  // ---- Defeat handling (call finalizer once) ----
  if (g.crystal.hp <= 0 && g.status === 'active' && !_finalizeOnce){
    g.crystal.hp = 0;
    g.status = 'defeat';
    _finalizeOnce = true;                // prevent duplicate finalize calls
    finalizeAndMarkDefeat(g).catch(()=>{});
  }

  return g;
}
    function nearestEnemyInRange(g, t, range){
      let best=null, bd=1e9;
      for (const e of g.enemies){ const d = dist2(t.x,t.y, e.x,e.y); if (d <= (range+0.5)**2 && d<bd){ bd=d; best=e; } }
      return best;
    }
    function nearestTowerInRange(g, e, range){
      let best=null, bd=1e9;
      for (const t of g.towers){ const d = dist2(t.x,t.y, e.x,e.y); if (d <= (range+0.5)**2 && d<bd){ bd=d; best=t; } }
      return best;
    }

    // Persist baseIncome deltas and schedule restart (no lobby deactivation)
    async function finalizeAndMarkDefeat(g){
      try{
        await runTransaction(db, async (tx)=>{
          const s = await tx.get(lobbyRef); if (!s.exists()) return;
          const d = s.data(); if (d.host !== me) return;
          const cur = d.game || g; if (cur._finalized) return;

          // Persist baseIncome gains
          for (const p of (cur.players||[])){
            const delta = round2(p.baseIncomeDelta||0);
            if (delta>0){
              const uref = doc(db, 'users', p.name);
              const us = await tx.get(uref);
              let curBase = 1;
              if (us.exists()){ const estate = us.data().estate || {}; curBase = (typeof estate.baseIncome==='number') ? estate.baseIncome : 1; }
              const next = round2(curBase + delta);
              tx.set(uref, { estate:{ baseIncome: next } }, { merge:true });
            }
          }

          // Mark finalized + set restart time; DO NOT flip root active/status
          cur.status = 'defeat';
          cur._finalized = true;
          cur._restartAt = now() + 2500; // ~2.5s pause before restart
          tx.update(lobbyRef, { game: cur });
        });
      }catch(e){}
    }

    // ----- Scrolling -----
    function syncSlider(){ vScroll.value = Math.round(camY); }
    function centerOnCore(){ if (!state || !state.crystal) return; camY = clamp(state.crystal.y * TILE - H/2, 0, MAP_H - H); syncSlider(); }
    vScroll.max = Math.max(0, MAP_H - H); vScroll.value = camY;
    vScroll.addEventListener('input', ()=>{ camY = clamp(parseInt(vScroll.value,10)||0, 0, MAP_H - H); });
    centerBtn.onclick = centerOnCore;
    canvas.addEventListener('wheel', (ev)=>{ ev.preventDefault(); camY = clamp(camY + ev.deltaY, 0, MAP_H - H); syncSlider(); }, { passive:false });
    window.addEventListener('keydown', (e)=>{ if (e.key==='ArrowUp'||e.key==='w'||e.key==='W') camY=clamp(camY-50,0,MAP_H-H); if (e.key==='ArrowDown'||e.key==='s'||e.key==='S') camY=clamp(camY+50,0,MAP_H-H); if (e.key==='c'||e.key==='C') centerOnCore(); syncSlider(); });

    // ----- Render -----
    function draw(){
      ctx.clearRect(0,0,W,H);
      const offY = camY;
      ctx.fillStyle="#e9eef3"; ctx.fillRect(0,0,W,H);
      ctx.strokeStyle="#d7dee6"; ctx.lineWidth=1;
      for (let y=0;y<=H;y+=TILE){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
      for (let x=0;x<=W;x+=TILE){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
      if (!state) return;

      // crystal
      const cx = state.crystal.x*TILE + TILE/2, cy = state.crystal.y*TILE - offY + TILE/2;
      ctx.strokeStyle="#a78bfa"; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(cx,cy,16,0,Math.PI*2); ctx.stroke();
      ctx.fillStyle="#7c3aed"; ctx.beginPath(); ctx.arc(cx,cy,12,0,Math.PI*2); ctx.fill();
      ctx.fillStyle="#111"; ctx.font="12px Segoe UI"; ctx.textAlign="center"; ctx.fillText("CRYSTAL", cx, cy-28);
      const hpw=80, hpx=cx-hpw/2, hpy=cy-24, pct=Math.max(0,(state.crystal.hp/state.crystal.maxHp));
      ctx.fillStyle="#222"; ctx.fillRect(hpx,hpy,hpw,6);
      ctx.fillStyle=pct>0.5?"#22c55e":pct>0.25?"#f59e0b":"#ef4444"; ctx.fillRect(hpx,hpy,hpw*pct,6);

      // towers
      for (const t of (state.towers||[])){
        const x = t.x*TILE+TILE/2, y = t.y*TILE - offY + TILE/2;
      
        // colored base square (owner color)
        const col = t.ownerColor || (state.players||[]).find(p=>p.name===t.owner)?.color || '#000';
        ctx.save();
        ctx.globalAlpha = 0.25;         // nice translucent pad
        ctx.fillStyle = col;
        ctx.fillRect(t.x*TILE, t.y*TILE - offY, TILE, TILE);
        ctx.restore();
      
        // the tower itself
        ctx.font="20px Segoe UI Emoji"; ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText(t.emoji, x, y);
      
        // hp bar
        ctx.fillStyle="#111"; ctx.fillRect(x-14,y+12,28,4);
        ctx.fillStyle="#16a34a"; ctx.fillRect(x-14,y+12, 28*(t.hp/t.maxHp), 4);
      }


      // enemies
      for (const e of (state.enemies||[])){
        const x=e.x*TILE+TILE/2, y=e.y*TILE - offY + TILE/2;
        const col=ELEM_COL[e.el]||"#999";
        ctx.strokeStyle=col; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(x,y,12,0,Math.PI*2); ctx.stroke();
        ctx.fillStyle="#111"; ctx.beginPath(); ctx.arc(x,y,10,0,Math.PI*2); ctx.fill();
        const EMO = { slime:"üü¢", gob:"üë∫", arch:"üèπ", brute:"üí¢" }[e.type] || "‚ö´";
        ctx.font="16px Segoe UI Emoji"; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText(EMO, x, y);
        const w=22, h=4, p = Math.max(0, Math.min(1, (e.hp||0) / (e.maxHp||e.hp||1)));
        ctx.fillStyle="#111"; ctx.fillRect(x-w/2, y+14, w, h);
        ctx.fillStyle=p>0.5?"#22c55e":p>0.25?"#f59e0b":"#ef4444"; ctx.fillRect(x-w/2, y+14, w*p, h);
      }

      // projectiles
      for (const p of (state.projectiles||[])){
        const x=p.x*TILE+TILE/2, y=p.y*TILE - offY + TILE/2;
        ctx.fillStyle=ELEM_COL[p.el]||"#111"; ctx.beginPath(); ctx.arc(x,y,4,0,Math.PI*2); ctx.fill();
      }
    }

    renderShop();
    setInterval(draw, 1000/30);
    await ensureUserIncome();
  </script>
</body>
</html>



























