<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>üè° Estate Defense</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#f7f8fb; --ink:#1f2937; --muted:#6b7280; --card:#ffffff; --line:#e5e7eb;
      --accent:#2e7d32; --danger:#c62828; --violet:#7c3aed;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:Segoe UI,Arial,Helvetica,sans-serif;background:var(--bg);color:var(--ink);display:flex;gap:10px;height:100vh;overflow:hidden}
    #left{flex:0 0 250px;background:var(--card);border-right:1px solid var(--line);padding:12px;display:flex;flex-direction:column;gap:10px}
    #center{flex:1;display:flex;flex-direction:column;gap:8px;min-width:0}
    header{display:flex;align-items:center;justify-content:space-between;padding:8px 12px;background:var(--card);border-bottom:1px solid var(--line)}
    header .tag{font-size:12px;color:#fff;background:var(--accent);padding:2px 8px;border-radius:999px}
    #stats{display:flex;gap:16px;font-size:14px;color:var(--muted)}
    #canvasWrap{position:relative;flex:1;background:#eef3f7;border:1px solid var(--line);display:flex;align-items:center;justify-content:center}
    canvas{display:block;width:720px;height:560px;max-width:100%;max-height:100%}
    #right{flex:0 0 260px;background:var(--card);border-left:1px solid var(--line);padding:12px;display:flex;flex-direction:column;gap:10px; min-height: 0; overflow: hidden;}
    .panel{
          display:flex;
          flex-direction:column;
          gap:8px;
          min-height:0;
        }
        
        /* Let the Build panel claim remaining height */
        .panel.flex1{
          flex:1;
          min-height:0;
        }
        
        /* Scroll container just for the shop grid */
        .shopScroller{
          flex:1;
          min-height:0;
          overflow:auto;
        }
      /* Optional: tiny right padding so cards don't hug the scrollbar */
      .shop{ padding-right:4px; }
    .panel h3{margin:0 0 6px 0;font-size:16px}
    .players{display:flex;flex-direction:column;gap:6px;max-height:35vh;overflow:auto}
    .playerRow{display:flex;align-items:center;justify-content:space-between;padding:6px 8px;border:1px solid var(--line);border-radius:8px}
    .dot{width:10px;height:10px;border-radius:50%;display:inline-block;margin-right:6px}
    .shop{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .card{border:1px solid var(--line);border-radius:10px;padding:8px;cursor:pointer;background:#fff}
    .card .emoji{font-size:20px}
    .card.disabled{ opacity:.55; pointer-events:none }
    .card .titleRow { display:flex; align-items:center; justify-content:space-between; gap:8px }
    .card .statRow { font-size:12px; color:var(--ink); display:flex; gap:10px; flex-wrap:wrap }
    .card .chipRow { display:flex; gap:6px; flex-wrap:wrap }
    .btn{padding:8px 10px;border:1px solid var(--line);border-radius:8px;background:#fff;cursor:pointer}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .row{display:flex;gap:8px;align-items:center}
    .small{font-size:12px;color:var(--muted)}
    .toast{position:absolute;left:50%;transform:translateX(-50%);top:10px;background:#111;color:#fff;padding:6px 10px;border-radius:8px;font-size:13px;opacity:.95}
    .chip{background:#fff;border:1px solid var(--line);padding:4px 8px;border-radius:999px;font-size:12px}
    #vScroll {
      position: absolute;
      right: 8px;
      top: 12px;
      height: calc(100% - 24px);
      width: 18px;
      writing-mode: vertical-lr;
      direction: rtl;
      appearance: none;
      background: transparent;
    }
    #vScroll::-webkit-slider-runnable-track { background: #dbe5ff; border-radius: 12px; width: 100%; height: 100%; }
    #vScroll::-moz-range-track { background: #dbe5ff; border-radius: 12px; width: 100%; height: 100%; }
    #vScroll::-webkit-slider-thumb { appearance: none; width: 16px; height: 16px; border-radius: 50%; background: var(--violet); border: none; }
    #vScroll::-moz-range-thumb { width: 16px; height: 16px; border-radius: 50%; background: var(--violet); border: none; }
    #centerBtn{ position:absolute; left:12px; bottom:12px; }
    #mobileHud{display:none;position:absolute;left:10px;right:10px;bottom:10px;z-index:5;pointer-events:none}
    #mobileIncomeBar,#mobileActions{pointer-events:auto;display:flex;align-items:center;justify-content:space-between;gap:8px;background:rgba(255,255,255,.92);border:1px solid var(--line);border-radius:12px;padding:8px 10px;backdrop-filter:blur(4px)}
    #mobileIncomeBar{margin-bottom:8px}
    #mobileIncomeBar .item{font-size:13px;color:var(--muted)}
    #mobileIncomeBar b{color:var(--ink)}
    .mobileBtn{flex:1;border:1px solid var(--line);border-radius:10px;background:#fff;padding:8px 10px;font-weight:600;font-size:13px}
    #leaveBtn{color:#fff;background:var(--danger);border:none}
    @media (max-width: 1200px){
      body{height:100dvh;overflow:hidden;background:#e9eef3}
      #left{display:none}
      #right{display:none}
      #center{gap:0;height:100%}
      header{position:absolute;top:0;left:0;right:0;z-index:4;background:linear-gradient(to bottom, rgba(255,255,255,.98), rgba(255,255,255,.85));gap:6px}
      header .small{display:none}
      #stats{font-size:15px;font-weight:600}
      #canvasWrap{border:none;height:100%;padding-top:68px}
      #vScroll{right:6px;top:76px;height:calc(100% - 168px)}
      #centerBtn{display:none}
      #mobileHud{display:block}
    }
  </style>
</head>
<body>
  <div id="left">
    <div class="panel">
      <h3>Session</h3>
      <div class="row small"><span id="hostLbl">Host: ‚Ä¶</span><span id="leaseLbl" class="chip">lease ‚Ä¶</span></div>
      <div class="row small">Lobby: <span id="lobbyId">‚Ä¶</span></div>
      <div class="row small">You: <b id="youName">‚Ä¶</b></div>
      <div class="row"><button id="leaveBtn" class="btn">Leave</button></div>
    </div>
    <div class="panel">
      <h3>Players</h3>
      <div id="playersBox" class="players"></div>
    </div>
    <div class="panel">
      <h3>Level</h3>
      <div class="row"><div>Level:</div><b id="levelLbl">1</b></div>
      <div class="row"><div>Kills to next:</div><b id="killsLbl">‚Äî</b></div>
      <div class="row"><div>Core HP:</div><b id="coreHpLbl">‚Äî</b></div>
      <div class="row"><div>High Score:</div><b id="highScoreLbl">0</b></div>
    </div>
    <div class="panel">
      <h3>Enemies this level</h3>
      <div id="levelEnemies" class="shop"></div>
    </div>
  </div>

  <div id="center">
    <header>
      <div class="row">
        <span class="tag">üè° Estate Defense</span>
        <div id="stats" class="row">
          <div>Funds: <b id="fundsLbl">0</b></div>
          <div>Base income: <b id="baseLbl">0</b> /15s</div>
        </div>
      </div>
      <div class="small">Scroll: wheel / ‚Üë‚Üì / W‚ÄìS or use the slider. ‚ÄúCenter on Core‚Äù jumps to the crystal.</div>
    </header>
    <div id="canvasWrap">
      <canvas id="game" width="720" height="560"></canvas>
      <div id="toast" class="toast" style="display:none"></div>
      <input id="vScroll" type="range" min="0" value="0" step="1">
      <button id="centerBtn" class="chip">Center on Core</button>
      <div id="mobileHud">
        <div id="mobileIncomeBar">
          <div class="item">Funds <b id="mobileFundsLbl">0</b></div>
          <div class="item">Income <b id="mobileIncomeLbl">0</b>/15s</div>
        </div>
        <div id="mobileActions">
          <button id="mobileTowerBtn" class="mobileBtn">üóº Next Tower</button>
          <button id="mobileCoreBtn" class="mobileBtn">üíé Core</button>
          <button id="mobileFullscreenBtn" class="mobileBtn">‚õ∂ Fullscreen</button>
        </div>
      </div>
    </div>
  </div>

  <div id="right">
      <div class="panel flex1">
    <h3>Build</h3>
    <div class="shopScroller">
      <div class="shop" id="shop"></div>
    </div>
    <div class="small">Click a card to buy. Towers place near the crystal. Upgrades are owner-only.</div>
  </div>

    <div class="panel">
      <h3>Selected</h3>
      <div id="selInfo" class="small">None</div>
      <div class="row">
        <button id="upgradeBtn" class="btn" disabled>Upgrade</button>
        <button id="sellBtn" class="btn" disabled>Sell</button>
      </div>
    </div>
  </div>

  <script type="module">
    // ----- Firebase -----
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import {
      getFirestore, doc, getDoc, setDoc, updateDoc, runTransaction,
      collection, addDoc, query, orderBy, limit, getDocs, onSnapshot,
      serverTimestamp, arrayUnion, arrayRemove, where
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
    import { writeBatch } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";


    const firebaseConfig = {
      apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
      authDomain: "bible-game-246c0.firebaseapp.com",
      projectId: "bible-game-246c0",
      storageBucket: "bible-game-246c0.appspot.com",
      messagingSenderId: "959619818996",
      appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
    };
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // ----- Params -----
    const LOBBY_ROUTE = "/lobby.html";
    const SHARED_LOBBY_ID = "estate-defense-global";
    const params = new URLSearchParams(location.search);
    const lobbyId = SHARED_LOBBY_ID;
    const me = params.get("username") || "anon";
    document.getElementById('youName').textContent = me;
    document.getElementById('lobbyId').textContent = lobbyId || '‚Äî';

    // ----- Canvas / Map -----
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const TILE = 32, COLS = 20, ROWS = 75;
    const MAP_W = COLS * TILE, MAP_H = ROWS * TILE;
    let camY = MAP_H - H; // start near bottom
    let initialCentered = false;

    // ----- UI -----
    const fundsLbl = document.getElementById('fundsLbl');
    const baseLbl  = document.getElementById('baseLbl');
    const mobileFundsLbl = document.getElementById('mobileFundsLbl');
    const mobileIncomeLbl = document.getElementById('mobileIncomeLbl');
    const hostLbl  = document.getElementById('hostLbl');
    const leaseLbl = document.getElementById('leaseLbl');
    const levelLbl = document.getElementById('levelLbl');
    const killsLbl = document.getElementById('killsLbl');
    const coreHpLbl= document.getElementById('coreHpLbl');
    const highScoreLbl= document.getElementById('highScoreLbl');
    const playersBox = document.getElementById('playersBox');
    const shopBox = document.getElementById('shop');
    const selInfo = document.getElementById('selInfo');
    const upgradeBtn = document.getElementById('upgradeBtn');
    const sellBtn = document.getElementById('sellBtn');
    const leaveBtn = document.getElementById('leaveBtn');
    const vScroll = document.getElementById('vScroll');
    const centerBtn = document.getElementById('centerBtn');
    const mobileTowerBtn = document.getElementById('mobileTowerBtn');
    const mobileCoreBtn = document.getElementById('mobileCoreBtn');
    const mobileFullscreenBtn = document.getElementById('mobileFullscreenBtn');
    const CRYSTAL_HIT_R_T = 0.65;
    const RENDER_DELAY_MS = 100;   // how far behind "now" we render
const MAX_EXTRAP_MS   = 120;   // tiny safety extrapolation window
const SNAPBUF_MAX     = 14;    // keep ~3‚Äì4s of snapshots at 3‚Äì5 Hz
let _snapBuf = [];             // [{ at, ver, enemies:Map, projectiles:Map }]
    // --- Physics / collision tuning ---
const PROJECTILE_SPEED_TPS   = 14;   // tiles per second (was 14 inline)
const PROJECTILE_RADIUS_T    = 0.28; // projectile "size" in tiles
const ENEMY_RADIUS_T         = 0.48; // enemy "size" in tiles
const PHYS_MAX_ADVANCE_T     = 0.40; // max tiles advanced per micro-step (prevents tunneling)
const PHYS_MAX_DT            = 0.35; // clamp dt to avoid giant jumps on hiccups
    // Host publish tuning
    const PUBLISH_MIN_MS = 350;  // publish at ~2.8 Hz (lighter Firebase load)
const MAX_PROJECTILES_PUBLISH = 120; // cap transmitted bullets to keep doc small
let _lastPublishAt = 0;
    const USER_GROW_MS = 15000;  // every 15s
let _nextGrowAt = 0;

    let _snapPrev = { at: Date.now(), ver: -1, enemies: new Map(), projectiles: new Map() };
let _snapCurr = { at: Date.now(), ver: -1, enemies: new Map(), projectiles: new Map() };

    // --- Intents (single, self-contained) ---
const enqueueIntent = (() => {
  const btnsLocal = [upgradeBtn, sellBtn].filter(Boolean);
  let _intentBusy = false;

  return async function(type, payload = {}) {
    if (_intentBusy) return;
    _intentBusy = true;
    btnsLocal.forEach(b => b.disabled = true);
    try {
      await addDoc(intentsCol, {
        ts: Date.now(),
        actor: me,
        type,
        payload: { ...payload, baseIncome: myBaseIncome }
      });
    } finally {
      setTimeout(() => { _intentBusy = false; }, 250);
      btnsLocal.forEach(b => b.disabled = false);
    }
  };
})();


    let amSeeded = false;
    let _buyBusy = false;
    let _actionBusy = false;
    let lastShop = { funds:-1, seeded:false, active:true };
    let _projPrev = new Map();   // id -> {x,y}
    let _projCurr = new Map();   // id -> {x,y}
    let _towerCycleIndex = 0;
    let _lastSnapAt = Date.now();
    let _lastVer = -1;


    const toast = (msg, ms=1500) => {
      const t=document.getElementById('toast');
      t.textContent=msg; t.style.display='block';
      setTimeout(()=>t.style.display='none', ms);
    };
    const ELEMENT_EMOJI = { fire:"üî•", frost:"‚ùÑÔ∏è", volt:"‚ö°", nature:"üåø" };

    // ----- Data -----
    const palette = ["#ef4444","#3b82f6","#10b981","#f59e0b","#8b5cf6","#06b6d4","#f97316","#84cc16"];
    const ELEM_COL = {fire:"#ef4444", frost:"#60a5fa", volt:"#f59e0b", nature:"#22c55e"};
const TOWER_TYPES = [
  // --- Early tier (cheap): short range, very slow rate ---
  { key:"ember",   name:"Ember",        emoji:"üî•",  el:"fire",   cost:1,   dmg:5,   range:15, rate:0.22, hp:5,
    beam:{ mode:"normal" }, prioritize:"closest" },
  { key:"cinder",  name:"Cinder",       emoji:"üß®",  el:"fire",   cost:3,   dmg:7,   range:17, rate:0.24, hp:6,
    beam:{ mode:"smart" },  prioritize:"closest" },
  { key:"frost",   name:"Frost",        emoji:"‚ùÑÔ∏è",  el:"frost",  cost:4,   dmg:4,   range:16, rate:0.26, hp:5,
    beam:{ mode:"normal" }, prioritize:"closest" },
  { key:"nature",  name:"Thorn",        emoji:"üåø",  el:"nature", cost:4,   dmg:4,   range:15, rate:0.28, hp:5,
    beam:{ mode:"smart" },  prioritize:"closest" },
  { key:"volt",    name:"Volt",         emoji:"‚ö°",   el:"volt",   cost:4,   dmg:6,   range:14, rate:0.30, hp:5,
    beam:{ mode:"normal" }, prioritize:"closest" },

  // --- Low-mid tier ---
  { key:"flame",   name:"Flame",        emoji:"üî•",  el:"fire",   cost:15,  dmg:10,  range:19, rate:0.32, hp:12,
    beam:{ mode:"splash", radiusT:1.4, falloff:0.55 }, prioritize:"lowestHp" },
  { key:"shard",   name:"Shard",        emoji:"üßä",  el:"frost",  cost:15,  dmg:6,   range:20, rate:0.34, hp:12,
    beam:{ mode:"smart" },  prioritize:"elementWeak" },
  { key:"bramble", name:"Bramble",      emoji:"üå±",  el:"nature", cost:15,  dmg:6,   range:21, rate:0.36, hp:12,
    beam:{ mode:"smart" },  prioritize:"closest" },
  { key:"arc",     name:"Arc",          emoji:"ü™´",  el:"volt",   cost:15,  dmg:8,   range:19, rate:0.38, hp:12,
    beam:{ mode:"chain", bounces:1, radiusT:2.6, falloff:0.60 }, prioritize:"furthest" },

  // --- Mid tier ---
  { key:"blaze",   name:"Blaze",        emoji:"üî•",  el:"fire",   cost:25,  dmg:14,  range:24, rate:0.40, hp:18,
    beam:{ mode:"splash", radiusT:1.6, falloff:0.60 }, prioritize:"lowestHp" },
  { key:"glacier", name:"Glacier",      emoji:"ü•∂",  el:"frost",  cost:25,  dmg:8,   range:25, rate:0.42, hp:24,
    beam:{ mode:"smart" },  prioritize:"elementWeak" },
  { key:"grove",   name:"Grove",        emoji:"üå≥",  el:"nature", cost:25,  dmg:9,   range:24, rate:0.44, hp:22,
    beam:{ mode:"smart" },  prioritize:"closest" },
  { key:"tesla",   name:"Tesla",        emoji:"üß≤",  el:"volt",   cost:25,  dmg:11,  range:26, rate:0.46, hp:15,
    beam:{ mode:"chain", bounces:2, radiusT:3.0, falloff:0.60 }, prioritize:"furthest" },

  // --- Upper mid ---
  { key:"inferno", name:"Inferno",      emoji:"üåã",  el:"fire",   cost:50,  dmg:19,  range:30, rate:0.48, hp:30,
    beam:{ mode:"splash", radiusT:2.0, falloff:0.60 }, prioritize:"lowestHp" },
  { key:"blizzard",name:"Blizzard",     emoji:"üå®Ô∏è", el:"frost",  cost:50,  dmg:10,  range:30, rate:0.50, hp:35,
    beam:{ mode:"smart" },  prioritize:"elementWeak" },
  { key:"wrathwood",name:"Wrathwood",   emoji:"üå≤",  el:"nature", cost:50,  dmg:12,  range:30, rate:0.52, hp:30,
    beam:{ mode:"smart" },  prioritize:"closest" },
  { key:"tempest", name:"Tempest",      emoji:"üå©Ô∏è", el:"volt",   cost:50,  dmg:15,  range:30, rate:0.54, hp:25,
    beam:{ mode:"chain", bounces:2, radiusT:3.2, falloff:0.60 }, prioritize:"furthest" },

  // --- High tier ---
  { key:"phoenix", name:"Phoenix",      emoji:"ü™∂",  el:"fire",   cost:100, dmg:25,  range:36, rate:0.56, hp:50,
    beam:{ mode:"pierce", max:3, radiusT:0.55, falloff:0.85 }, prioritize:"furthest" },
  { key:"absolutezero", name:"Absolute Zero", emoji:"üßä", el:"frost", cost:100, dmg:13, range:36, rate:0.58, hp:55,
    beam:{ mode:"smart" },  prioritize:"elementWeak" },
  { key:"verdant", name:"Verdant",      emoji:"üçÉ",  el:"nature", cost:100, dmg:16,  range:36, rate:0.60, hp:50,
    beam:{ mode:"smart" },  prioritize:"lowestHp" },
  { key:"stormcaller", name:"Stormcaller", emoji:"‚õàÔ∏è", el:"volt", cost:100, dmg:20,  range:36, rate:0.62, hp:35,
    beam:{ mode:"chain", bounces:3, radiusT:3.5, falloff:0.65 }, prioritize:"furthest" },

  // --- Late game ---
  { key:"solarflare", name:"Solar Flare", emoji:"‚òÄÔ∏è", el:"fire",  cost:150, dmg:26,  range:50, rate:0.64, hp:80,
    beam:{ mode:"splash", radiusT:2.2, falloff:0.62 }, prioritize:"lowestHp" },
  { key:"permafrost", name:"Permafrost",  emoji:"üßä", el:"frost", cost:150, dmg:27,  range:68, rate:0.66, hp:80,
    beam:{ mode:"pierce", max:3, radiusT:0.58, falloff:0.85 }, prioritize:"elementWeak" },
  { key:"worldroot",  name:"Worldroot",   emoji:"üçÄ", el:"nature",cost:150, dmg:30,  range:58, rate:0.68, hp:80,
    beam:{ mode:"smart" },  prioritize:"closest" },
  { key:"thunderlord",name:"Thunderlord", emoji:"‚ö°",  el:"volt",  cost:150, dmg:26,  range:52, rate:0.70, hp:80,
    beam:{ mode:"chain", bounces:3, radiusT:3.6, falloff:0.65 }, prioritize:"furthest" },

  // --- Endgame ---
  { key:"supernova",  name:"Supernova",   emoji:"üí•", el:"fire",  cost:200, dmg:70,  range:56, rate:0.72, hp:120,
    beam:{ mode:"pierce", max:4, radiusT:0.60, falloff:0.85 }, prioritize:"furthest" },
  { key:"cryostorm",  name:"Cryostorm",   emoji:"üå¨Ô∏è", el:"frost", cost:200, dmg:65,  range:74, rate:0.74, hp:120,
    beam:{ mode:"chain", bounces:3, radiusT:3.8, falloff:0.65 }, prioritize:"elementWeak" },
  { key:"wildheart",  name:"Wildheart",   emoji:"ü™¥", el:"nature", cost:200, dmg:75,  range:64, rate:0.76, hp:120,
    beam:{ mode:"smart" },  prioritize:"lowestHp" },
  { key:"ionstorm",   name:"Ion Storm",   emoji:"üîå", el:"volt",  cost:200, dmg:90,  range:56, rate:0.78, hp:120,
    beam:{ mode:"chain", bounces:4, radiusT:4.0, falloff:0.68 }, prioritize:"furthest" },

  // --- Legendary ---
  { key:"aurora",     name:"Aurora",       emoji:"üåå", el:"frost",  cost:300, dmg:70,  range:78, rate:1.40, hp:200,
    beam:{ mode:"chain", bounces:4, radiusT:4.2, falloff:0.68 }, prioritize:"elementWeak" },
  { key:"worldtree",  name:"World Tree",   emoji:"ü™µ", el:"nature", cost:300, dmg:130, range:70, rate:0.82, hp:200,
    beam:{ mode:"smart" },  prioritize:"closest" },
  { key:"overcharge", name:"Overcharge",   emoji:"üîã", el:"volt",   cost:300, dmg:500, range:90, rate:0.2, hp:200,
    beam:{ mode:"chain", bounces:5, radiusT:4.0, falloff:0.70 }, prioritize:"furthest" },

  // Mythic-ish
  { key:"cataclysm",  name:"Cataclysm",   emoji:"‚òÑÔ∏è", el:"fire",   cost:500, dmg:150, range:70, rate:0.86, hp:150,
    beam:{ mode:"splash", radiusT:2.6, falloff:0.65 }, prioritize:"lowestHp" },
  { key:"eventide",   name:"Eventide",    emoji:"üåí", el:"frost",  cost:500, dmg:120, range:92, rate:0.88, hp:180,
    beam:{ mode:"pierce", max:3, radiusT:0.62, falloff:0.85 }, prioritize:"elementWeak" },
  { key:"evergrowth", name:"Evergrowth",  emoji:"üçÄ", el:"nature", cost:500, dmg:140, range:76, rate:0.90, hp:160,
    beam:{ mode:"smart" },  prioritize:"closest" },
  { key:"zeusforge",  name:"Zeusforge",   emoji:"‚ö°Ô∏è", el:"volt",  cost:500, dmg:200, range:70, rate:0.92, hp:140,
    beam:{ mode:"chain", bounces:4, radiusT:4.0, falloff:0.68 }, prioritize:"furthest" },

  // Relic
  { key:"sunspike",   name:"Sunspike",    emoji:"üåû", el:"fire",   cost:800, dmg:200, range:90, rate:0.94, hp:220,
    beam:{ mode:"pierce", max:4, radiusT:0.62, falloff:0.86 }, prioritize:"furthest" },
  { key:"cryocrown",  name:"Cryocrown",   emoji:"üëë", el:"frost",  cost:800, dmg:150, range:110,rate:0.96, hp:240,
    beam:{ mode:"pierce", max:3, radiusT:0.60, falloff:0.86 }, prioritize:"elementWeak" },
  { key:"worldspine", name:"Worldspine",  emoji:"ü™®", el:"nature", cost:800, dmg:170, range:96, rate:0.98, hp:230,
    beam:{ mode:"smart" },  prioritize:"closest" },
  { key:"ionemperor", name:"Ion Emperor", emoji:"‚ö°üëë", el:"volt",  cost:800, dmg:260, range:85, rate:1.00, hp:200,
    beam:{ mode:"chain", bounces:5, radiusT:4.2, falloff:0.70 }, prioritize:"furthest" },

  // Eternal
  { key:"supercritical", name:"Supercritical", emoji:"üß™", el:"fire",   cost:1200, dmg:300, range:112, rate:1.02, hp:300,
    beam:{ mode:"splash", radiusT:2.8, falloff:0.66 }, prioritize:"lowestHp" },
  { key:"absolutezero_plus", name:"Absolute Zero+", emoji:"‚ùÑÔ∏è‚ûï", el:"frost", cost:1200, dmg:220, range:120, rate:1.04, hp:320,
    beam:{ mode:"pierce", max:4, radiusT:0.64, falloff:0.86 }, prioritize:"elementWeak" },
  { key:"verdantking", name:"Verdant King", emoji:"üëëüåø", el:"nature", cost:1200, dmg:260, range:110, rate:1.06, hp:300,
    beam:{ mode:"smart" },  prioritize:"lowestHp" },
  { key:"overcharge_mk2", name:"Overcharge Mk II", emoji:"üîã2", el:"volt", cost:1200, dmg:500, range:100, rate:1.08, hp:260,
    beam:{ mode:"chain", bounces:6, radiusT:4.4, falloff:0.70 }, prioritize:"furthest" },

  // Transcendent
  { key:"quasar",     name:"Quasar",      emoji:"‚ú®",  el:"fire",   cost:2000, dmg:400, range:124, rate:1.5, hp:360,
    beam:{ mode:"splash", radiusT:3.0, falloff:0.68 }, prioritize:"lowestHp" },
  { key:"cryosingularity", name:"Cryo Singularity", emoji:"üåÄ", el:"frost", cost:2000, dmg:300, range:136, rate:1.6, hp:360,
    beam:{ mode:"chain", bounces:6, radiusT:4.6, falloff:0.70 }, prioritize:"elementWeak" },
  { key:"worldheart_prime", name:"Worldheart Prime", emoji:"üíö", el:"nature", cost:2000, dmg:350, range:126, rate:1.55, hp:360,
    beam:{ mode:"smart" },  prioritize:"lowestHp" },
  { key:"ion_god",    name:"Ion God",     emoji:"‚ö°üïá", el:"volt",  cost:2000, dmg:700, range:116, rate:1.16, hp:320,
    beam:{ mode:"chain", bounces:7, radiusT:4.8, falloff:0.72 }, prioritize:"furthest" },

    // --- Eldritch (post-Transcendent) ---
  { key:"cinder_god",    name:"Cinder God",    emoji:"üî•üïØÔ∏è", el:"fire",
    cost:3000, dmg:520,  range:132, rate:1.62, hp:420,
    beam:{ mode:"splash", radiusT:3.2, falloff:0.68 }, prioritize:"lowestHp" },

  { key:"entropy_crown", name:"Entropy Crown", emoji:"üßäüëë", el:"frost",
    cost:3000, dmg:380,  range:144, rate:1.72, hp:420,
    beam:{ mode:"pierce", max:5, radiusT:0.66, falloff:0.86 }, prioritize:"elementWeak" },

  { key:"evergloom",     name:"Evergloom",     emoji:"üåøüåë", el:"nature",
    cost:3000, dmg:460,  range:134, rate:1.60, hp:420,
    beam:{ mode:"smart" }, prioritize:"lowestHp" },

  { key:"arc_overlord",  name:"Arc Overlord",  emoji:"‚ö°üëÅÔ∏è", el:"volt",
    cost:3000, dmg:900,  range:122, rate:1.20, hp:380,
    beam:{ mode:"chain", bounces:8, radiusT:4.9, falloff:0.72 }, prioritize:"furthest" },

  // --- Paradox ---
  { key:"timeflare",       name:"Timeflare",       emoji:"üî•‚è≥", el:"fire",
    cost:4500, dmg:680,  range:140, rate:1.74, hp:480,
    beam:{ mode:"splash", radiusT:3.4, falloff:0.70 }, prioritize:"lowestHp" },

  { key:"chrono_glacier",  name:"Chrono Glacier",  emoji:"üßä‚è±Ô∏è", el:"frost",
    cost:4500, dmg:480,  range:150, rate:1.84, hp:500,
    beam:{ mode:"pierce", max:6, radiusT:0.68, falloff:0.86 }, prioritize:"elementWeak" },

  { key:"paradox_grove",   name:"Paradox Grove",   emoji:"üå≥‚ôæÔ∏è", el:"nature",
    cost:4500, dmg:560,  range:142, rate:1.70, hp:500,
    beam:{ mode:"smart" }, prioritize:"closest" },

  { key:"omega_coil",      name:"Omega Coil",      emoji:"‚ö°Œ©", el:"volt",
    cost:4500, dmg:1150, range:128, rate:1.24, hp:420,
    beam:{ mode:"chain", bounces:9, radiusT:5.1, falloff:0.73 }, prioritize:"furthest" },

  // --- Omega ---
  { key:"ragnarok_sun",   name:"Ragnarok Sun",   emoji:"üåûüíÄ", el:"fire",
    cost:6500, dmg:1100, range:150, rate:1.88, hp:560,
    beam:{ mode:"pierce", max:6, radiusT:0.70, falloff:0.86 }, prioritize:"furthest" },

  { key:"cold_entropy",   name:"Cold Entropy",   emoji:"üßäüåÄ", el:"frost",
    cost:6500, dmg:620,  range:160, rate:1.95, hp:560,
    beam:{ mode:"pierce", max:6, radiusT:0.70, falloff:0.86 }, prioritize:"elementWeak" },

  { key:"verdant_omega",  name:"Verdant Œ©",      emoji:"üåøŒ©",  el:"nature",
    cost:6500, dmg:700,  range:152, rate:1.80, hp:560,
    beam:{ mode:"smart" }, prioritize:"lowestHp" },

  { key:"ion_singularity",name:"Ion Singularity",emoji:"‚ö°üåÄ", el:"volt",
    cost:6500, dmg:1500, range:132, rate:1.30, hp:500,
    beam:{ mode:"chain", bounces:12, radiusT:5.6, falloff:0.75 }, prioritize:"furthest" }

];




    const ELEM_MULT = {
      fire:   { nature:1.5, frost:0.8, volt:1.0, fire:1.0 },
      nature: { volt:1.5, fire:0.8, frost:1.0, nature:1.0 },
      volt:   { frost:1.5, nature:0.8, fire:1.0, volt:1.0 },
      frost:  { fire:1.5, nature:0.8, volt:1.0, frost:1.0 }
    };

    // ---------- Beam presets & defaults ----------
const BEAM_DEFAULTS = {
  normal: { },
  smart:  { },                               // avoids overkill using a per-tick focus map
  splash: { radiusT: 1.6, falloff: 0.60 },   // 60% dmg to neighbors in radius
  chain:  { bounces: 2, radiusT: 3.0, falloff: 0.60 }, // 2 extra jumps with falloff
  pierce: { max: 3, radiusT: 0.48, falloff: 0.85 }     // hit up to 3 along line
};

// Optionally map certain tower keys to default modes (fallback to "normal")
const TOWER_BEAM_PRESETS = {
  arc: 'chain', tesla: 'chain', tempest: 'chain', stormcaller: 'chain', ionstorm: 'chain',
  blaze: 'splash', inferno: 'splash', solarflare: 'splash',
  phoenix: 'pierce', supernova: 'pierce'
};

// Optional per-tower prioritization (fallback to 'closest')
const TOWER_PRIORITY_PRESETS = {
  // examples; tweak freely
  tesla: 'furthest',  // zap things deeper in lane
  blaze: 'lowestHp',  // pop weaklings to proc splash
  stormcaller: 'elementWeak' // pick enemies weak to this element multiplier
};

    const ENEMY_TYPES = [
  // --- Early game (Lv 1‚Äì5) ---
  { key:"slime",   el:"nature", hp:20, dmg:2, spd:0.8, range:0,  target:"core",  minLevel:1, tags:["swarm"] },
  { key:"sprout",  el:"nature", hp:16, dmg:1, spd:1.15,range:0,  target:"core",  minLevel:1, tags:["swarm"] },
  { key:"gob",     el:"fire",   hp:28, dmg:3, spd:1.0, range:0,  target:"core",  minLevel:2 },
  { key:"imp",     el:"fire",   hp:18, dmg:3, spd:1.25,range:0,  target:"core",  minLevel:2, tags:["swift"] },
  { key:"bat",     el:"volt",   hp:14, dmg:2, spd:1.5, range:0,  target:"core",  minLevel:2, tags:["flying","fragile"] },

  { key:"arch",    el:"frost",  hp:22, dmg:2, spd:0.9, range:15, target:"tower", minLevel:3 },
  { key:"ashling", el:"fire",   hp:10, dmg:1, spd:1.3, range:0,  target:"core",  minLevel:3, tags:["swarm"] },
  { key:"bomber",  el:"fire",   hp:24, dmg:4, spd:0.9, range:0,  target:"tower", minLevel:3, tags:["explodes"], deathExplosion:{dmg:10, radius:40} },

  { key:"sapper",  el:"volt",   hp:22, dmg:5, spd:1.1, range:0,  target:"tower", minLevel:4, tags:["siege"] },
  { key:"shaman",  el:"nature", hp:26, dmg:1, spd:0.85,range:26, target:"core",  minLevel:4, tags:["healer"], healRate:1.5, healRange:70 },
  { key:"sniper",  el:"frost",  hp:20, dmg:5, spd:0.8, range:40, target:"tower", minLevel:4, tags:["pierce"] },

  { key:"brute",   el:"volt",   hp:45, dmg:5, spd:0.6, range:0,  target:"tower", minLevel:5 },
  { key:"shield",  el:"frost",  hp:32, dmg:3, spd:0.75,range:0,  target:"core",  minLevel:5, tags:["shielded"], shield:14 },

  // --- Mid game (Lv 6‚Äì12) ---
  { key:"witch",   el:"fire",   hp:24, dmg:4, spd:0.9, range:20, target:"tower", minLevel:6, tags:["curse"] },
  { key:"crawler", el:"volt",   hp:15, dmg:2, spd:1.6, range:0,  target:"core",  minLevel:6, tags:["swarm"] },
  { key:"druid",   el:"nature", hp:30, dmg:2, spd:0.95,range:0,  target:"core",  minLevel:6, tags:["healer","regen"], healRate:1.0, healRange:55 },

  { key:"cata",    el:"fire",   hp:34, dmg:7, spd:0.6, range:30, target:"tower", minLevel:7, tags:["siege"] },
  { key:"wolf",    el:"nature", hp:18, dmg:3, spd:1.35,range:0,  target:"core",  minLevel:7, tags:["swift"] },

  { key:"golem",   el:"frost",  hp:72, dmg:7, spd:0.5, range:0,  target:"core",  minLevel:8, tags:["armored"], armor:2 },
  { key:"specter", el:"frost",  hp:22, dmg:3, spd:1.1, range:0,  target:"core",  minLevel:8, tags:["stealth"] },

  { key:"pyro",    el:"fire",   hp:26, dmg:5, spd:0.9, range:60, target:"tower", minLevel:9 },
  { key:"cryo",    el:"frost",  hp:26, dmg:3, spd:0.9, range:60, target:"tower", minLevel:9, tags:["slow"] },

  { key:"runner",  el:"volt",   hp:28, dmg:4, spd:1.3, range:0,  target:"tower", minLevel:10, tags:["stun"] },
  { key:"thornlr", el:"nature", hp:48, dmg:5, spd:0.7, range:0,  target:"core",  minLevel:10, tags:["regen"], healRate:1.2 },

  { key:"assassin",el:"volt",   hp:24, dmg:9, spd:1.35,range:0,  target:"tower", minLevel:11, tags:["stealth","backstab"] },

  { key:"warlock", el:"fire",   hp:36, dmg:6, spd:0.8, range:70, target:"tower", minLevel:12 },
  { key:"dryad",   el:"nature", hp:28, dmg:2, spd:0.95,range:55, target:"core",  minLevel:12, tags:["healer"], healRate:1.2, healRange:65 },

  // --- Upper mid (Lv 13‚Äì18) ---
  { key:"icebrk",  el:"frost",  hp:84, dmg:8, spd:0.55,range:0,  target:"tower", minLevel:13, tags:["armored"], armor:3 },
  { key:"thunder", el:"volt",   hp:40, dmg:7, spd:1.0, range:65, target:"tower", minLevel:14, tags:["chain"] },
  { key:"basilisk",el:"nature", hp:62, dmg:6, spd:0.65,range:0,  target:"core",  minLevel:15, tags:["poison"] },

  { key:"demo",    el:"fire",   hp:58, dmg:10,spd:0.7, range:0,  target:"tower", minLevel:16, tags:["siege"] },
  { key:"tempest", el:"volt",   hp:36, dmg:5, spd:1.15,range:45, target:"tower", minLevel:16, tags:["chain"] },

  { key:"banshee", el:"frost",  hp:32, dmg:4, spd:1.2, range:40, target:"tower", minLevel:17, tags:["armorShred"] },
  { key:"jugger",  el:"volt",   hp:110,dmg:12,spd:0.45,range:0,  target:"core",  minLevel:18, tags:["armored","shielded"], armor:4, shield:18 },

  // --- Late game (Lv 19‚Äì26) ---
  { key:"lich",    el:"frost",  hp:42, dmg:7, spd:0.85,range:50, target:"tower", minLevel:19, tags:["summoner"], summon:{key:"slime", count:2, cd:12} },
  { key:"behemoth",el:"nature", hp:95, dmg:11,spd:0.55,range:0,  target:"core",  minLevel:20, tags:["regen","armored"], healRate:1.0, armor:2 },
  { key:"phoenix", el:"fire",   hp:60, dmg:8, spd:1.0, range:0,  target:"core",  minLevel:20, tags:["rebirth"], splitInto:"ashling", splitCount:2 },

  { key:"warden",  el:"frost",  hp:70, dmg:8, spd:0.9, range:60, target:"tower", minLevel:21, tags:["slow"] },
  { key:"ancient", el:"nature", hp:120,dmg:14,spd:0.4, range:0,  target:"core",  minLevel:22, tags:["armored","regen"], armor:3, healRate:1.5 },

  { key:"stormwyrm",el:"volt",  hp:82, dmg:9, spd:0.85,range:60, target:"tower", minLevel:23, tags:["aoe","chain"] },
  { key:"frostqn", el:"frost",  hp:72, dmg:8, spd:0.9, range:60, target:"tower", minLevel:24, tags:["slow","aura"] },

  { key:"infernal",el:"fire",   hp:140,dmg:15,spd:0.5, range:0,  target:"core",  minLevel:25, tags:["explodes","armored"], armor:2, deathExplosion:{dmg:18, radius:55} },
  { key:"treant",  el:"nature", hp:90, dmg:10,spd:0.6, range:30, target:"tower", minLevel:26, tags:["siege"] },

  // --- Endgame (Lv 27+) ---
  { key:"overseer",el:"volt",   hp:100,dmg:12,spd:0.8, range:70, target:"tower", minLevel:27, tags:["summoner"], summon:{key:"bat", count:3, cd:10} },
  { key:"glacier", el:"frost",  hp:130,dmg:13,spd:0.55,range:0,  target:"core",  minLevel:28, tags:["armored","slowAura"] },
  { key:"hellkite",el:"fire",   hp:85, dmg:10,spd:1.05,range:70, target:"tower", minLevel:29, tags:["flying","burn"] },
  { key:"titan",   el:"volt",   hp:180,dmg:20,spd:0.45,range:0,  target:"core",  minLevel:30, tags:["armored","shielded","boss"], armor:5, shield:30 }
];

    const fmt3 = (n)=> (Math.round((+n||0)*100)/100).toFixed(3);


    // ----- State -----
    let state = null;
    let myFunds = 0;
    let myBaseIncome = 0;
    let mySelectedTowerId = null;

    // Track status/epoch for UI transitions
    let _lastStatus = null;
    let _lastEpoch = -1;

    // ----- Host & Firestore -----
    const LEASE_MS = 5000;
    let isHost = false;
    let simInt = null;
    const lobbyRef  = doc(db, "lobbies", lobbyId);
    // Firestore rules only allow lobby subcollection access under /crowncouncil/*.
    // Estate Defense stores both intents and presence docs in this shared channel.
    const syncCol = collection(db, "lobbies", lobbyId, "crowncouncil");
    const intentsCol = syncCol;

    // Presence
    const presenceCol = syncCol;
    let presentNames = [];
    const STALE_MS = 45_000;

    const presenceDocId = (name) => `presence_${name}`;

    onSnapshot(presenceCol, snap => {
      const nowMs = Date.now();
      presentNames = snap.docs
        .filter(d => {
          if (!d.id.startsWith("presence_")) return false;
          const data = d.data() || {};
          const ts = data.lastSeen;
          const ms = ts?.toMillis ? ts.toMillis() : 0;
          return data.active !== false && (nowMs - ms < STALE_MS);
        })
        .map(d => d.id.slice("presence_".length))
        .sort();
    });

    await setDoc(doc(presenceCol, presenceDocId(me)), { name: me, lastSeen: serverTimestamp(), active: true }, { merge: true });
    const _presenceBeat = setInterval(() => {
      updateDoc(doc(presenceCol, presenceDocId(me)), { lastSeen: serverTimestamp(), active: true }).catch(()=>{});
    }, 15000);

    // Also mirror to root `players`
    await setDoc(lobbyRef, { players: arrayUnion(me) }, { merge: true });

    function cleanupPresence(){
      try { clearInterval(_presenceBeat); } catch {}
      updateDoc(doc(presenceCol, presenceDocId(me)), { active: false, leftAt: serverTimestamp() }).catch(()=>{});
      updateDoc(lobbyRef, { players: arrayRemove(me) }).catch(()=>{});
    }
    window.addEventListener('beforeunload', cleanupPresence);
    window.addEventListener('pagehide', cleanupPresence);

    // Helpers
    const now = () => Date.now();
    const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
    const dist2 = (x1,y1,x2,y2)=>((x1-x2)**2+(y1-y2)**2);
    const rnd = (a,b)=>a+Math.random()*(b-a);
    const round2=(n)=>Math.round(n*100)/100;
    const playerColor=(name,list)=>palette[Math.max(0,(list||[]).indexOf(name))%palette.length];

    function nearestFreeTile(fromX, fromY, occ){
      const maxR = Math.max(COLS, ROWS);
      for(let r=0; r<maxR; r++){
        for(let dy=-r; dy<=r; dy++){
          for(let dx=-r; dx<=r; dx++){
            if (Math.abs(dx)!==r && Math.abs(dy)!==r) continue;
            const x=fromX+dx, y=fromY+dy;
            if (x<0||x>=COLS||y<0||y>=ROWS) continue;
            if (!occ[y*COLS+x]) return {x,y};
          }
        }
      }
      return null;
    }

    function fmtRate(r){ return (Math.round((+r||0)*100)/100).toFixed(2); }

function abilityLabel(t){
  const beam = t?.beam || {};
  const mode = beam.mode || "normal";
  switch(mode){
    case "smart":  return "üß† Smart (avoid overkill)";
    case "splash": return `üí´ Splash r=${(beam.radiusT??1.6).toFixed(1)} ‚Ä¢ ${Math.round((beam.falloff??0.6)*100)}% dmg`;
    case "chain":  {
      const b = beam.bounces ?? 2, r = (beam.radiusT??3.0).toFixed(1);
      return `‚ö° Chain x${b} ‚Ä¢ r=${r}`;
    }
    case "pierce": {
      const m = beam.max ?? 3, r = (beam.radiusT??0.55).toFixed(2);
      return `‚û≥ Pierce x${m} ‚Ä¢ r=${r}`;
    }
    default:       return "‚Äî Normal";
  }
}

function priorityLabel(p){
  const map = {
    closest:"üéØ Closest", furthest:"üéØ Furthest",
    lowestHp:"üéØ Lowest HP", highestHp:"üéØ Highest HP",
    elementWeak:"üéØ Element-weak"
  };
  return map[p||"closest"] || `üéØ ${p}`;
}


function makeWritableGame(g){
  const clone = {
    ...g,
    projectiles: [],                             // üö´ no bullets on the wire
    enemies: Array.isArray(g.enemies) ? g.enemies : [],
    towers:  Array.isArray(g.towers)  ? g.towers  : []
    // keep underscore keys if you previously chose to
  };
  return sanitizeForFirestore(clone);
}

 const _tracers = [];
function addTracer(x1,y1,x2,y2, durMs=90, col="#222", w=2.5, alpha=0.85){
  _tracers.push({ x1, y1, x2, y2, until: Date.now() + durMs, col, w, alpha });
}

// Nice mapping: 1.5px min up to 10px max, mostly linear to dmg
function beamWidthFromDamage(dmg){
  const d = Math.max(0, Number(dmg) || 0);
  const w = 1.5 + d * 0.20;      // 5 dmg ‚Üí 2.5px, 25 dmg ‚Üí 6.5px, 50 dmg ‚Üí 11.5px (then capped)
  return Math.min(10, w);
}
// --- Planned-damage helpers (for smart/overkill avoidance) ---
// You already reset this each tick with: g._focusMap = new Map();
function getPlannedDamage(g, e){
  if (!g._focusMap) g._focusMap = new Map();
  return g._focusMap.get(e.id) || 0;
}

function addPlannedDamage(g, e, dmg){
  if (!g._focusMap) g._focusMap = new Map();
  const cur = g._focusMap.get(e.id) || 0;
  const add = Math.max(0, Math.round(dmg || 0));
  g._focusMap.set(e.id, cur + add);
}

function isOverkilled(g, e){
  const planned = getPlannedDamage(g, e);
  // If planned damage from other towers this tick will finish the enemy, skip it
  return (e.hp - planned) <= 0;
}


 // --- Shop ---
function renderShop(){
  const gameActive = state?.status === 'active';
  shopBox.innerHTML = TOWER_TYPES.map(t=>{
    const disabled = !amSeeded || !gameActive || (myFunds < t.cost);
    const elChip = `<span class="chip">${ELEMENT_EMOJI[t.el]||''} ${t.el}</span>`;
    const abil   = abilityLabel(t);
    const prio   = priorityLabel(t.prioritize);

    return `
      <div class="card${disabled ? ' disabled':''}" data-key="${t.key}">
        <div class="titleRow">
          <div class="row">
            <span class="emoji">${t.emoji}</span>
            <b style="margin-left:6px">${t.name}</b>
          </div>
          <span class="chip">$${t.cost}</span>
        </div>

        <div class="chipRow" style="margin-top:6px">
          ${elChip}
          <span class="chip">${abil}</span>
          <span class="chip">${prio}</span>
        </div>

        <div class="statRow" style="margin-top:6px">
          <span title="HP">‚ù§Ô∏è <b>${t.hp}</b></span>
          <span title="Damage">üí• <b>${t.dmg}</b></span>
          <span title="Rate (shots/sec)">‚è±Ô∏è <b>${fmtRate(t.rate)}</b>/s</span>
          <span title="Range (tiles)">üì° <b>${t.range}</b></span>
        </div>
      </div>
    `;
  }).join('');
}


(function bindShopDelegation(){
  let _shopTapLock = false; // local, not shared with intents

  shopBox.addEventListener('pointerdown', async (e)=>{
    if (e.button != null && e.button !== 0) return; // ignore right/middle clicks
    const card = e.target.closest('.card[data-key]');
    if (!card) return;
    if (card.classList.contains('disabled')) return;
    if (!state || state.status !== 'active') return;
    if (!amSeeded){ toast("Joining‚Ä¶ one moment ‚è≥"); return; }
    if (_shopTapLock) return;

    _shopTapLock = true;
    e.preventDefault(); // do this before awaiting; needs {passive:false} below
    try{
      await tryBuy(card.dataset.key); // will call enqueueIntent
    } finally {
      setTimeout(()=>{ _shopTapLock = false; }, 200); // light de-dupe
    }
  }, { passive:false }); // allow preventDefault on touch
})();

    // Which two enemy types spawn this level (deterministic, honors minLevel)
function getLevelEnemyPair(lvl){
  const unlocked = ENEMY_TYPES.filter(t => lvl >= (t.minLevel || 1));
  if (unlocked.length === 0) return [ENEMY_TYPES[0], ENEMY_TYPES[0]];
  if (unlocked.length === 1) return [unlocked[0], unlocked[0]];
  const i1 = lvl % unlocked.length;
  const offset = Math.max(1, Math.floor(unlocked.length / 2));
  const i2 = (i1 + offset) % unlocked.length;
  return [unlocked[i1], unlocked[i2]];
}

// For a defender element, list attacker elements that are >1 (weak) or <1 (resist)
function getWeakResFor(defEl){
  const out = { weakTo: [], resists: [] };
  for (const atkEl of Object.keys(ELEM_MULT)){
    const mult = (ELEM_MULT[atkEl] && ELEM_MULT[atkEl][defEl]) || 1;
    if (mult > 1) out.weakTo.push(atkEl);
    else if (mult < 1) out.resists.push(atkEl);
  }
  return out;
}

const levelEnemiesBox = document.getElementById('levelEnemies');
let _lastLevelShown = -1;

function renderLevelEnemies(g){
  if (!g || !levelEnemiesBox) return;
  const lvl = g.level || 1;
  const pair = getLevelEnemyPair(lvl);
  const fmtList = arr => arr.map(el => `${ELEMENT_EMOJI[el]||''} ${el}`).join(', ') || '‚Äî';

  levelEnemiesBox.innerHTML = pair.map(t => {
    const wr = getWeakResFor(t.el);
    return `
      <div class="card">
        <div class="row">
          <span class="emoji">${ELEMENT_EMOJI[t.el]||''}</span>
          <b>${t.name}</b>
        </div>
        <div class="small">Element: ${t.el}</div>
        <div class="small">Weak to: ${fmtList(wr.weakTo)}</div>
        <div class="small">Resists: ${fmtList(wr.resists)}</div>
      </div>
    `;
  }).join('');
}
    function canTowerTargetEnemy(nowMs, e){
  if (!e) return false;
  const stealth = Array.isArray(e.tags) && e.tags.includes('stealth');
  return stealth ? ((e.revealedUntil || 0) > nowMs) : true;
}


function maybeRenderShop(){
  const active = state?.status === 'active';
  if (lastShop.funds !== myFunds || lastShop.seeded !== amSeeded || lastShop.active !== active){
    lastShop = { funds: myFunds, seeded: amSeeded, active };
    renderShop();
  }
}
    async function tryBuy(tKey){
      if (!state || state.status !== 'active') return;
      const def = TOWER_TYPES.find(x => x.key === tKey); if (!def) return;
      if (!amSeeded){ toast("Joining‚Ä¶ one moment ‚è≥"); return; }
      if (myFunds < def.cost){ toast("Not enough funds"); return; }
      await enqueueIntent("BUY", { tKey });
    }

    // Buttons
    upgradeBtn.onclick = async () => {
      if (!state || state.status !== 'active') return;
      if (!mySelectedTowerId) return;
      await enqueueIntent("UPGRADE", { id: mySelectedTowerId });
    };
    sellBtn.onclick = async () => {
      if (!state || state.status !== 'active') return;
      if (!mySelectedTowerId) return;
      await enqueueIntent("SELL", { id: mySelectedTowerId });
    };

    // Leave (manual)
    let _leaving = false;
    leaveBtn.onclick = async ()=>{
      if (_leaving) return;
      _leaving = true;
      leaveBtn.disabled = true;
      try{
        cleanupPresence();
      } finally {
        location.href = `${LOBBY_ROUTE}?username=${encodeURIComponent(me)}`;
      }
    };

    // Ensure income & announce JOINED
    async function ensureUserIncome(){
      try{
        const uref = doc(db, 'users', me);
        const us   = await getDoc(uref);
        if (!us.exists()){
          myBaseIncome = 1;
          await setDoc(uref, { estate: { baseIncome: myBaseIncome } }, { merge: true });
        } else {
          const estate = us.data()?.estate || {};
          myBaseIncome = (typeof estate.baseIncome === 'number') ? estate.baseIncome : 1;
          if (!us.data().estate){
            await updateDoc(uref, { estate: { baseIncome: myBaseIncome } }).catch(()=>{});
          }
        }
        baseLbl.textContent = round2(myBaseIncome);
        await addDoc(intentsCol, { ts: now(), actor: me, type: "JOINED", payload: { baseIncome: myBaseIncome } });
      } catch(e){
        myBaseIncome = 1;
        await addDoc(intentsCol, { ts: now(), actor: me, type: "JOINED", payload: { baseIncome: myBaseIncome } }).catch(()=>{});
      }
    }

 onSnapshot(lobbyRef, async (docSnap) => {
  if (!docSnap.exists()) {
    location.href = `${LOBBY_ROUTE}?username=${encodeURIComponent(me)}`;
    return;
  }

  const d = docSnap.data() || {};
  hostLbl.textContent = `Host: ${d.host || '‚Äî'}`;
  if (d.host === me && !isHost) beginHosting?.();

  // Adopt latest game (fall back to last good if missing briefly)
  const nextState = d.game || state || null;

  // Change detection
  const epochChanged = !!(nextState && typeof nextState._epoch === 'number' && nextState._epoch !== _lastEpoch);
  const levelChanged = !!(nextState && (nextState.level || 1) !== (_lastLevelShown || -1));
  const lastVerInBuf = (_snapBuf.length ? _snapBuf[_snapBuf.length - 1].ver : -1);
  const verChanged   = !!(nextState && typeof nextState.ver === 'number' && nextState.ver > lastVerInBuf);

  // Commit state (for UI)
  state = nextState;

  // If a new run started, reset visual buffer and recenter
  if (epochChanged && state) {
    _lastEpoch = state._epoch;
    initialCentered = false;
    _snapBuf.length = 0; // clear buffer so we don't blend across runs
    toast("üîÅ New run!");
  }

  // Push a visual snapshot into the buffer when the sim version advances
  if (verChanged && state) {
    const nowMs = Date.now();
    const enemies = new Map();
    const projectiles = new Map();

    for (const e of (state.enemies || [])) {
      enemies.set(e.id, {
        id: e.id, x: e.x, y: e.y, el: e.el, type: e.type,
        hp: e.hp, maxHp: e.maxHp
      });
    }
    for (const p of (state.projectiles || [])) {
      projectiles.set(p.id, { id: p.id, x: p.x, y: p.y, el: p.el, owner: p.owner });
    }

    // Append in order (ignore out-of-order repeats)
    if (!_snapBuf.length || state.ver > _snapBuf[_snapBuf.length - 1].ver) {
      _snapBuf.push({ at: nowMs, ver: state.ver, enemies, projectiles });
      if (_snapBuf.length > SNAPBUF_MAX) _snapBuf.shift();
    }
  }

  // First-time centering for this epoch
  if (state && state.crystal && !initialCentered) {
    initialCentered = true;
    centerOnCore();
  }

  // ----- UI -----
  if (state) {
    // Top stats
    levelLbl.textContent = state.level || 1;
    const killsLeft = Math.max(0, (state.killsToAdvance || 10) - (state.killsThisLevel || 0));
    killsLbl.textContent = `${killsLeft}`;
    coreHpLbl.textContent = `${Math.max(0, Math.round(state.crystal?.hp || 0))}/${Math.round(state.crystal?.maxHp || 0)}`;
    highScoreLbl.textContent = Math.max(0, Math.round(state.highScore || 0));

    // Me / funds / base income
    const meP = (state.players || []).find(p => p.name === me) || null;
    if (meP) {
      myFunds = meP.funds || 0;
      if (typeof meP.baseIncome === 'number') myBaseIncome = meP.baseIncome;
      const myInc = (myBaseIncome || 1) + (meP.baseIncomeDelta || 0);
      baseLbl.textContent = fmt3(myInc);
      if (mobileIncomeLbl) mobileIncomeLbl.textContent = fmt3(myInc);
    }
    fundsLbl.textContent = Math.floor(myFunds);
    if (mobileFundsLbl) mobileFundsLbl.textContent = Math.floor(myFunds);

    // Seed gate + shop refresh
    const wasSeeded = amSeeded;
    amSeeded = !!(meP && meP._seeded);
    if (!wasSeeded && amSeeded) toast("Joined! Shop unlocked.");
    maybeRenderShop();

    // Players list
    playersBox.innerHTML = "";
    (state.players || []).forEach((p, i) => {
      const base = (typeof p.baseIncome === 'number') ? p.baseIncome : 1;
      const inc  = base + (p.baseIncomeDelta || 0);
      const row = document.createElement('div');
      row.className = 'playerRow';
      row.innerHTML = `
        <div><span class="dot" style="background:${palette[i % palette.length]}"></span>${p.name}</div>
        <div class="small">Inc: ${fmt3(inc)} | $${Math.floor(p.funds || 0)}</div>
      `;
      playersBox.appendChild(row);
    });

    // Status toast
    if (_lastStatus !== state.status) {
      if (state.status === 'defeat') toast("üí• Core destroyed! Restarting‚Ä¶", 1500);
      _lastStatus = state.status;
    }

    // Level panel refresh
    if (levelChanged) {
      _lastLevelShown = state.level || 1;
      renderLevelEnemies(state);
    }
  }

  // Host election check
  if (shouldClaimHost(docSnap)) await tryClaimHost();
});




    function shouldClaimHost(docSnap){
      const d = docSnap.data() || {};
      const leaseUntil = d.leaseUntil || 0;
      if (!presentNames.includes(me)) return false;
      if (!d.host) return true;
      const expired = (now() > leaseUntil);
      const next = (presentNames[0] || '');
      return expired && (next === me);
    }
function beginHosting(){
  if (isHost) return;
  isHost = true;
  leaseLbl.textContent = "lease: host";
  startHostLoop();
}
    async function tryClaimHost(){
  // quick read: if I already hold a valid lease, just start the loop
  const s0 = await getDoc(lobbyRef);
  if (!s0.exists()) return;
  const d0 = s0.data() || {};
  if (!presentNames.includes(me)) return;

  const leaseUntil0 = d0.leaseUntil || 0;
  const leaseAlive0 = Date.now() <= leaseUntil0;

  if (d0.host === me && leaseAlive0){
    beginHosting();               // ‚Üê start loop on fresh load
    return;
  }
  if (d0.host && leaseAlive0){
    isHost = false;
    leaseLbl.textContent = "lease: client";
    return;                       // someone else is host
  }

  // take over via txn
  let took = false;
  await runTransaction(db, async (tx)=>{
    const s = await tx.get(lobbyRef); if (!s.exists()) return;
    const d = s.data() || {};
    const players = d.players || [];
    if (!players.includes(me)) return;

    const leaseAlive = Date.now() <= (d.leaseUntil || 0);
    if (!d.host || !leaseAlive){
      let game = d.game;
      if (!game) game = buildFreshGameFromPlayers(players);
      tx.update(lobbyRef, { host: me, leaseUntil: Date.now() + LEASE_MS, game });
      took = true;
    }
  }).catch(()=>{});

  if (took) beginHosting();       // ‚Üê start loop after successful claim
}


    function buildFreshGameFromPlayers(players){
      const cx = Math.floor(COLS/2), cy = ROWS-3;
      const seededPlayers = [];
      for (const [i, n] of players.entries()) {
        // Base income is loaded by seeding; default 1 if missing
        seededPlayers.push({ name:n, color:palette[i%palette.length], funds: 0, baseIncome: 1, baseIncomeDelta:0, _seeded:false });
      }
      // The host loop will immediately seed on JOINED/implicit intents; for a brand-new lobby, we'll pre-seed with stored baseIncome:
      // We uplift baseIncome from /users on first JOINED per player; OK to start funds at 0 here.
      return {
        _epoch: 0,
           ver: 0,
        nextIncomeAt: now() + 15000,
        status:'active',
        level:1, killsThisLevel:0, killsToAdvance:20,
        lastTick:now(), nextSpawnAt:now()+1000,
        crystal:{ x:cx, y:cy, hp:100, maxHp:100 },
        highScore: 0,
        players: seededPlayers,
        towers:[], enemies:[], projectiles:[]
      };
    }

    function startHostLoop(){ if (simInt) clearInterval(simInt); simInt = setInterval(simulateStepAsHost, 200); }
    setInterval(async ()=>{
      if (isHost) return;
      const s = await getDoc(lobbyRef); if (!s.exists()) return;
      if (shouldClaimHost(s)) await tryClaimHost();
      leaseLbl.textContent = "lease: client";
    }, 2500);

    // Make enemy movement tick-rate independent but similar speed to before.
// You were doing e.y += e.spd every ~0.2s ‚áí ~5 tiles/sec at spd=1.
// SCALE keeps that feel while using dt-based motion.
const ENEMY_MOVE_SCALE = 5;

function stepToward(e, tx, ty, dt){
  // center-to-center vector (tiles are unit grid)
  const dx = (tx + 0.5) - (e.x + 0.5);
  const dy = (ty + 0.5) - (e.y + 0.5);
  const m  = Math.hypot(dx, dy) || 1;
  const v  = e.spd * ENEMY_MOVE_SCALE; // tiles/sec
  e.x += (dx / m) * v * dt;
  e.y += (dy / m) * v * dt;
}

// "Nearest tower anywhere" (no range gate)
function nearestTower(g, e){
  let best = null, bd = Infinity;
  for (const t of g.towers){
    const d = dist2(e.x, e.y, t.x, t.y);
    if (d < bd){ bd = d; best = t; }
  }
  return best;
}


// ----- Intents + Sim (host) -----
// Same behavior as before, but sanitizer NO LONGER removes underscore-prefixed fields.
// This preserves flags like _epoch / _seeded / etc. that your store logic depends on.

async function simulateStepAsHost(){
  // --- publish throttling + payload trim (local to this fn) ---
  const MAX_PROJECTILES_PUBLISH = 120; // cap bullets in the doc (unchanged)
  if (typeof window._lastPublishAt !== 'number') window._lastPublishAt = 0;

  // ---- Helpers: sanitize for Firestore (no undefined/NaN/Infinity/functions/cycles)
  // IMPORTANT: we KEEP underscore keys now.
  // ---- Helpers: sanitize for Firestore (no undefined/NaN/Infinity/functions/cycles)
// IMPORTANT: KEEP underscore-prefixed keys (e.g., _seeded, _epoch)
function sanitizeForFirestore(input){
  const seen = new WeakSet();
  const walk = (v) => {
    if (v === null) return null;
    const t = typeof v;

    if (t === 'number'){
      if (!Number.isFinite(v)) return 0;     // clamp NaN/¬±Infinity
      return Object.is(v, -0) ? 0 : v;
    }
    if (t === 'string' || t === 'boolean') return v;

    if (Array.isArray(v)){
      const out = [];
      for (let i=0;i<v.length;i++){
        const item = v[i];
        if (item === undefined || typeof item === 'function') { out.push(null); continue; }
        out.push(walk(item));
      }
      return out;
    }

    if (t === 'object'){
      if (seen.has(v)) return null; // break cycles
      seen.add(v);
      const out = {};
      for (const [k,val] of Object.entries(v)){
        if (val === undefined || typeof val === 'function') continue; // drop only truly unsafe values
        // NOTE: DO NOT strip underscore keys
        const w = walk(val);
        if (w !== undefined) out[k] = w;
      }
      return out;
    }
    // symbol/bigint/function -> drop
    return undefined;
  };
  return walk(input);
}


  // Make a copy of the game that's safe to send to Firestore
  function makeWritableGame(g){
    // Option B (safe): cap projectile count to keep doc small
    const proj = Array.isArray(g.projectiles) ? g.projectiles : [];
    const trimmedProj = proj.length > MAX_PROJECTILES_PUBLISH
      ? proj.slice(0, MAX_PROJECTILES_PUBLISH)
      : proj;

    // Ensure arrays exist and strip top-level transient fields
    const clone = {
      ...g,
      projectiles: trimmedProj,
      enemies: Array.isArray(g.enemies) ? g.enemies : [],
      towers:  Array.isArray(g.towers)  ? g.towers  : []
      // NOTE: we do NOT strip underscore keys anymore
    };

    // Deep sanitize EVERYTHING (objects inside enemies/towers/crystal included)
    return sanitizeForFirestore(clone);
  }

  // --- Ensure I'm still host ---
  const s = await getDoc(lobbyRef); if (!s.exists()) return;
  const d = s.data() || {};
  if (d.host !== me){ isHost = false; if (simInt) clearInterval(simInt); return; }

  // --- Presence freshness: NEVER delete the lobby; just pause when empty/stale ---
  const presSnap = await getDocs(presenceCol);
  {
    const nowMs = Date.now();
    let anyFresh = false;
    presSnap.forEach(docu => {
      const pdata = docu.data() || {};
      const ts = pdata.lastSeen;
      const ms = ts?.toMillis ? ts.toMillis() : 0;
      if (pdata.active !== false && (nowMs - ms < STALE_MS)) anyFresh = true;
    });

    if (!anyFresh){
      // Optional: keep the lease warm so host doesn't churn while idle
      try { await updateDoc(lobbyRef, { leaseUntil: now() + LEASE_MS }); } catch {}
      return; // pause sim; lobby remains intact
    }
  }

  // --- Load or bootstrap game ---
  let g = d.game;
  if (!g){
    g = buildFreshGameFromPlayers(d.players || []);
  }

  // --- Auto-restart window ---
  if (g.status === 'defeat' && g._finalized && g._restartAt && now() >= g._restartAt){
    const rootPlayers = (typeof presentNames !== 'undefined' && presentNames && presentNames.length)
      ? presentNames
      : (d.players || []);
    g = restartGameInPlace(g, rootPlayers);
    incomeTickAt = 0;      // reset local income cadence
    _finalizeOnce = false; // allow next defeat to finalize again
  }

  // --- Read & apply intents (do NOT delete yet) ---
  const lastIntentTs = Number(g._lastIntentTs || 0);
  const Q = query(
    intentsCol,
    where('ts', '>', lastIntentTs),
    orderBy('ts','asc'),
    limit(100)
  );
  const snap = await getDocs(Q);
  let newestIntentTs = lastIntentTs;
  for (const docu of snap.docs){
    const mv = docu.data();
    try { g = await applyIntent(g, mv); } catch {}
    newestIntentTs = Math.max(newestIntentTs, Number(mv?.ts || 0));
  }
  g._lastIntentTs = newestIntentTs;

  // --- Tick the sim ---
  if (g.status === 'active'){
    g = simulate(g);   // your simulate() already contains abilities + slower spawns
  }

  if (g.status === 'defeat' && !g._finalized && !_finalizeOnce){
    _finalizeOnce = true;
    await finalizeAndMarkDefeat(g);
    return;
  }

  // --- Throttled publish to Firestore (CAS with throw-to-abort) ---
  const nowMs = now();
  const shouldPublish = (nowMs - window._lastPublishAt) >= PUBLISH_MIN_MS;
  if (!shouldPublish) return;

  const verStart = (typeof g.ver === 'number') ? g.ver : 0;

  // IMPORTANT: increment ver BEFORE sanitize so CAS compares the same value we persist
  const gForWrite = { ...g, ver: verStart + 1 };
  const gNext = makeWritableGame(gForWrite);

  let wrote = false;
  try {
    await runTransaction(db, async (tx) => {
      const curSnap = await tx.get(lobbyRef);
      if (!curSnap.exists()) throw new Error('ABORT_NO_DOC');

      const cur = curSnap.data() || {};
      if (cur.host !== me) throw new Error('ABORT_NOT_HOST');

      const curVer = (cur.game && typeof cur.game.ver === 'number') ? cur.game.ver : 0;
      if (curVer !== verStart) throw new Error('ABORT_STALE'); // someone else advanced

      // ‚úÖ Only if still current do we write
      tx.update(lobbyRef, { game: gNext, leaseUntil: now() + LEASE_MS });
      wrote = true;
    });
  } catch (e) {
    const msg = String((e && e.message) || e);
    if (!msg.startsWith('ABORT_')) {
      console.warn('simulateStepAsHost txn error:', e);
    }
  }

 if (wrote){
  window._lastPublishAt = now();

  // üß† LIVE, PERMANENT INCOME GROWTH (host-only, every USER_GROW_MS)
  try {
    const tnow = now();
    if (!_nextGrowAt) _nextGrowAt = tnow + USER_GROW_MS;

    if (tnow >= _nextGrowAt) {
      const batch = writeBatch(db);

      for (const p of g.players || []) {
        const grow = round2(p.baseIncomeDelta || 0);
        if (grow > 0) {
          // fold delta into base, zero delta, then persist permanently
          const base0 = (typeof p.baseIncome === 'number') ? p.baseIncome : 1;
          const base1 = round2(base0 + grow);

          p.baseIncome = base1;
          p.baseIncomeDelta = 0;

          const uref = doc(db, 'users', p.name);
          batch.set(uref, {
            estate: {
              baseIncome: base1,            // üîí permanent bump
              updatedAt: serverTimestamp()  // nice-to-have
            }
          }, { merge: true });
        }
      }

      await batch.commit();
      _nextGrowAt = tnow + USER_GROW_MS;
    }
  } catch (e) {
    console.warn('live income growth error', e);
  }

}
}

// ===== Enemy damage & death (GLOBAL, shared by sim + beam funcs) =====
const REVEAL_ON_HIT_MS = 3000;       // was COOLDOWNS.revealSecsOnHit * 1000
const SUMMON_SCATTER_T = 1.25;       // used for split/rebirth scatter

function onEnemyDeath(g, e){
  // Death explosion (radius provided in PX in defs; convert to tiles)
  if (e.deathExplosion){
    const rT = (e.deathExplosion.radius || 0) / TILE;
    const dmg = e.deathExplosion.dmg || 0;
    for (const t of g.towers){
      const dx=(t.x+0.5)-(e.x+0.5), dy=(t.y+0.5)-(e.y+0.5);
      if (dx*dx + dy*dy <= rT*rT) t.hp -= dmg;
    }
  }

  // Split / Rebirth
  if (e.splitInto && e.splitCount){
    const baseType = ENEMY_TYPES.find(z => z.key === e.splitInto);
    if (baseType){
      for (let i=0;i<e.splitCount;i++){
        const lvl  = g.level || 1;
        const mult = Math.pow(1.25, lvl - 1);           // match your spawn scaling
        const nx = Math.max(1, Math.min(COLS-2, Math.round(e.x + rnd(-SUMMON_SCATTER_T, SUMMON_SCATTER_T))));
        const ny = Math.max(0, Math.min(ROWS-2, Math.round(e.y + rnd(-SUMMON_SCATTER_T, SUMMON_SCATTER_T))));
        const HP  = Math.round((baseType.hp || 10) * mult);
        const DMG = Math.round((baseType.dmg|| 2) * mult);
        g.enemies.push({
          id:'e'+Math.random().toString(36).slice(2),
          x:nx, y:ny, el: baseType.el, type: baseType.key,
          hp: HP, maxHp: HP, dmg: DMG,
          spd: baseType.spd, range: baseType.range,
          target: baseType.target, cd: 0,
          tags: baseType.tags||[],
          armor: baseType.armor||0, shield: baseType.shield||0,
          healRate: baseType.healRate, healRange: baseType.healRange,
          summon: baseType.summon
        });
      }
    }
  }
}

function applyEnemyDamage(g, e, rawDmg, elem){
  // element multiplier
  const mult = (elem && ELEM_MULT[elem] && ELEM_MULT[elem][e.el]) ? ELEM_MULT[elem][e.el] : 1.0;
  let dmg = Math.max(0, Math.round((rawDmg||0) * mult));

  // armor
  const armor = e.armor || 0;
  if (armor > 0) dmg = Math.max(0, dmg - armor);

  // shield (soaks first)
  if (e.shield && e.shield > 0){
    const use = Math.min(e.shield, dmg);
    e.shield -= use;
    dmg -= use;
  }

  // apply
  if (dmg > 0){
    e.hp -= dmg;
    // reveal stealth on hit
    if (Array.isArray(e.tags) && e.tags.includes('stealth')){
      e.revealedUntil = Math.max(e.revealedUntil || 0, now() + REVEAL_ON_HIT_MS);
    }
  }

  // death
  if (e.hp <= 0){
    onEnemyDeath(g, e);
    return true;
  }
  return false;
}


    // Restart builder: keep same players + baseIncome, reset everything else
    function restartGameInPlace(g, rootPlayers){
      // Build a set of current/known players (prefer those already in g.players to preserve colors)
      const presentSet = new Set(rootPlayers || []);
      const nextPlayers = (g.players || [])
        .filter(p => presentSet.has(p.name))
        .map((p,i) => ({
          name: p.name,
          color: p.color || palette[i%palette.length],
          baseIncome: (typeof p.baseIncome==='number') ? p.baseIncome : 1,
          baseIncomeDelta: 0,
          funds: ( (typeof p.baseIncome==='number') ? p.baseIncome : 1 ) * 10, // starting cash = baseIncome * 10
          _seeded: true
        }));

      const cx = Math.floor(COLS/2), cy = ROWS-3;
      return {
        _epoch: (typeof g._epoch==='number'? g._epoch : 0) + 1, // bump epoch so clients re-center
        ver: 0,
        status:'active',
        nextIncomeAt: now() + 15000,
        level:1, killsThisLevel:0, killsToAdvance:20,
        lastTick:now(), nextSpawnAt:now()+1000,
        crystal:{ x:cx, y:cy, hp:100, maxHp:100 },
        highScore: Math.max(g?.highScore || 0, g?.level || 1),
        players: nextPlayers,
        towers:[], enemies:[], projectiles:[]
      };
    }

    async function applyIntent(g, mv){
      const actor = mv.actor;

      // Explicit join ‚Üí seed funds on first time
      if (mv.type === 'JOINED'){
        const base = mv.payload?.baseIncome ?? 1;
        let p = g.players.find(p => p.name === actor);
        if (!p){
          const color = palette[g.players.length % palette.length];
          p = { name: actor, color, funds: base * 10, baseIncome: base, baseIncomeDelta: 0, _seeded: true };
          g.players.push(p);
        } else if (!p._seeded){
          p.funds += base * 10;
          p.baseIncome = base;
          p._seeded = true;
        }
        return g;
      }

      // Implicit join from gameplay intent
      if (mv.type === 'BUY' || mv.type === 'UPGRADE' || mv.type === 'SELL'){
        if (!g.players.some(p => p.name === actor)){
          const base = mv.payload?.baseIncome ?? 1;
          g.players.push({
            name: actor,
            color: palette[g.players.length % palette.length],
            funds: base * 10,
            baseIncome: base,
            baseIncomeDelta: 0,
            _seeded: true
          });
        }
      }

      if (mv.type === 'BUY'){
        if (g.status !== 'active') return g;
        const def = TOWER_TYPES.find(x => x.key === mv.payload?.tKey); if (!def) return g;
        const p = g.players.find(p => p.name === actor); if (!p || p.funds < def.cost) return g;

        const occ = new Array(COLS * ROWS).fill(false);
        occ[g.crystal.y * COLS + g.crystal.x] = true;
        g.towers.forEach(t => { occ[t.y * COLS + t.x] = true; });

        const spot = nearestFreeTile(g.crystal.x, g.crystal.y - 1, occ); if (!spot) return g;

        const id = 't' + Math.random().toString(36).slice(2);
       g.towers.push({
        id, x: spot.x, y: spot.y, owner: actor,
        ownerColor: p.color || '#888',
        emoji: def.emoji, el: def.el,
        hp: def.hp, maxHp: def.hp, level: 1,
        dmg: def.dmg, range: def.range, rate: def.rate, cd: 0,
        beam: def.beam || { mode:"normal" },
        prioritize: def.prioritize || "closest"
      });
        p.funds -= def.cost;
        return g;
      }


      if (mv.type === 'UPGRADE'){
        if (g.status !== 'active') return g;
        const t = g.towers.find(z => z.id === mv.payload?.id); if (!t || t.owner !== actor) return g;
        const p = g.players.find(p => p.name === actor);
        const cost = 15 + t.level * 10;
        if (!p || p.funds < cost) return g;

        p.funds -= cost;
        t.level += 1;
        t.dmg = Math.round(t.dmg * 1.25);
        t.range += (t.level % 2 === 0 ? 1 : 0);
        t.rate = +(t.rate * 1.05).toFixed(2);
        t.maxHp += 6;
        t.hp = Math.min(t.maxHp, t.hp + 6);
        return g;
      }

      if (mv.type === 'SELL'){
        if (g.status !== 'active') return g;
        const idx = g.towers.findIndex(z => z.id === mv.payload?.id); if (idx < 0) return g;
        const t = g.towers[idx]; if (t.owner !== actor) return g;
        const p = g.players.find(p => p.name === actor);
        if (p) p.funds += 10 + Math.max(0, (t.level - 1)) * 6;
        g.towers.splice(idx, 1);
        return g;
      }

      return g;
    }

    let incomeTickAt = 0;
    let _finalizeOnce = false;


    function getOrMakePair(g){
      const lvl = g.level || 1;
      if (g._pairLevel !== lvl){
        g._pair = getLevelEnemyPair(lvl);
        g._pairLevel = lvl;
      }
      return g._pair;
    }
    function clamp01(v){ return v<0?0:v>1?1:v; }

// Distance from segment (x1,y1)-(x2,y2) to point (cx,cy) <= r ?
function segmentHitsCircle(x1,y1,x2,y2, cx,cy, r){
  const dx = x2 - x1, dy = y2 - y1;
  const L2 = dx*dx + dy*dy;
  let t = 0;
  if (L2 > 0) t = ((cx - x1)*dx + (cy - y1)*dy) / L2;
  t = clamp01(t);
  const nx = x1 + t*dx, ny = y1 + t*dy;
  const dd = (nx - cx)*(nx - cx) + (ny - cy)*(ny - cy);
  return dd <= r*r;
}

// Find the first enemy a segment will hit (returns enemy or null)
function findEnemyHitAlongSegment(g, x1,y1,x2,y2, radius){
  // Simple linear scan; if this grows, consider spatial hashing/buckets.
  for (const e of g.enemies){
    if (e.hp <= 0) continue;
    if (segmentHitsCircle(x1,y1,x2,y2, e.x+0.5, e.y+0.5, radius)) return e;
  }
  return null;
}
function hardResetRun(g){
  const tNow = now();
  const cx = Math.floor(COLS/2), cy = ROWS - 3;

  // Rebuild players with funds = (baseIncome + delta) * 10
  const nextPlayers = (g.players || []).map((p, i) => {
    const base  = (typeof p.baseIncome === 'number') ? p.baseIncome : 1;
    const delta = +p.baseIncomeDelta || 0;
    const inc   = base + delta;
    return {
      name: p.name,
      color: p.color || palette[i % palette.length],
      baseIncome: base,
      baseIncomeDelta: delta,   // keep delta as-is so growth continues
      funds: Math.floor(inc * 10),
      _seeded: true
    };
  });

  return {
    _epoch: (typeof g._epoch === 'number' ? g._epoch : 0) + 1, // triggers client re-center
    ver: (typeof g.ver === 'number' ? g.ver : 0),              // txn will bump this
    status: 'active',
    level: 1, killsThisLevel: 0, killsToAdvance: 20,
    lastTick: tNow,
    nextSpawnAt: tNow + 1000,
    nextIncomeAt: tNow + 30000,
    crystal: { x: cx, y: cy, hp: 100, maxHp: 100 },
    players: nextPlayers,
    towers: [],           // üî• wipe towers
    enemies: [],          // üî• wipe enemies
    projectiles: []
  };
}

function elemMultFor(attEl, defEl){
  return (ELEM_MULT?.[attEl]?.[defEl]) ?? 1.0;
}
function enemyDistance2(t, e){
  const dx=(t.x+0.5)-(e.x+0.5), dy=(t.y+0.5)-(e.y+0.5);
  return dx*dx+dy*dy;
}
function enemiesInRange(g, t, r){
  const r2 = r*r;
  const out=[];
  for (const e of g.enemies){
    if (e.hp <= 0) continue;
    if (!canTowerTargetEnemy(now(), e)) continue; // your stealth-check
    if (enemyDistance2(t,e) <= r2) out.push(e);
  }
  return out;
}
function priorityScore(prio, t, e){
  switch(prio){
    case 'furthest':   return -(e.y); // bigger y first
    case 'lowestHp':   return e.hp;
    case 'highestHp':  return -e.hp;
    case 'elementWeak':return -elemMultFor(t.el, e.el); // higher multiplier -> more negative (sort asc)
    case 'closest':
    default:           return enemyDistance2(t,e);
  }
}
function estimateHitDamage(t, e){
  // Mirror applyEnemyDamage order: element ‚Üí shield ‚Üí armor
  let dmg = Math.max(0, Math.round((t.dmg||1) * elemMultFor(t.el, e.el)));
  if (e.shield && e.shield > 0){
    const used = Math.min(e.shield, dmg);
    dmg -= used;
  }
  if (e.armor && e.armor > 0){
    dmg = Math.max(0, dmg - e.armor);
  }
  return dmg;
}
function sortByScoreAsc(arr, scoreFn){
  return arr.sort((a,b)=>scoreFn(a)-scoreFn(b));
}

    function fire_normal(g, t, tNow, cand){
  if (!cand) return false;
  const died = applyEnemyDamage(g, cand, t.dmg, t.el);
  addPlannedDamage(g, cand, estimateHitDamage(t, cand));
  return died;
}

function fire_smart(g, t, tNow, candidates){
  // Skip enemies that already have enough planned damage this tick
  for (const e of candidates){
    if (!isOverkilled(g, e)){
      const died = applyEnemyDamage(g, e, t.dmg, t.el);
      addPlannedDamage(g, e, estimateHitDamage(t, e));
      return died;
    }
  }
  // Fall back to the first if all "overkilled"
  const e = candidates[0];
  if (e){
    const died = applyEnemyDamage(g, e, t.dmg, t.el);
    addPlannedDamage(g, e, estimateHitDamage(t, e));
    return died;
  }
  return false;
}

function fire_splash(g, t, tNow, main, opt){
  if (!main) return false;
  const { radiusT=1.6, falloff=0.6 } = opt || {};
  let anyKill = false;
  // primary
  if (applyEnemyDamage(g, main, t.dmg, t.el)) anyKill = true;
  addPlannedDamage(g, main, estimateHitDamage(t, main));

  // neighbors
  const r2 = radiusT*radiusT;
  for (const e of g.enemies){
    if (e === main || e.hp <= 0) continue;
    const dx=(main.x+0.5)-(e.x+0.5), dy=(main.y+0.5)-(e.y+0.5);
    if (dx*dx+dy*dy <= r2){
      const d = Math.max(1, Math.round(t.dmg * falloff));
      if (applyEnemyDamage(g, e, d, t.el)) anyKill = true;
      addPlannedDamage(g, e, estimateHitDamage({ ...t, dmg:d }, e));
    }
  }
  return anyKill;
}

function fire_chain(g, t, tNow, start, opt){
  if (!start) return false;
  const { bounces=2, radiusT=3.0, falloff=0.6 } = opt || {};
  let anyKill = false;
  let cur = start;
  let curDmg = t.dmg;

  for (let i=0; i<=bounces; i++){
    if (!cur || cur.hp <= 0) break;
    // hit current
    if (applyEnemyDamage(g, cur, Math.max(1, Math.round(curDmg)), t.el)) anyKill = true;
    addPlannedDamage(g, cur, estimateHitDamage({ ...t, dmg: curDmg }, cur));

    // find next target in bounce radius around current (excluding already hit ones by ID)
    if (i === bounces) break;
    let best=null, bd2=Infinity;
    for (const e of g.enemies){
      if (e.hp <= 0 || e.id === cur.id) continue;
      const dx=(cur.x+0.5)-(e.x+0.5), dy=(cur.y+0.5)-(e.y+0.5);
      const d2=dx*dx+dy*dy;
      if (d2 <= radiusT*radiusT && d2 < bd2){ best=e; bd2=d2; }
    }
    cur = best;
    curDmg = Math.max(1, Math.round(curDmg * falloff));
  }
  return anyKill;
}

function fire_pierce(g, t, tNow, target, opt){
  if (!target) return false;
  const { max=3, radiusT=0.48, falloff=0.85 } = opt || {};
  // Define line from tower to selected target and hit along path
  const x1=t.x+0.5, y1=t.y+0.5, x2=target.x+0.5, y2=target.y+0.5;

  // Collect all intersections; compute distance along beam
  const hits=[];
  for (const e of g.enemies){
    if (e.hp <= 0) continue;
    if (segmentHitsCircle(x1, y1, x2, y2, e.x+0.5, e.y+0.5, radiusT)){
      const dx=e.x+0.5 - x1, dy=e.y+0.5 - y1;
      const d2=dx*dx+dy*dy;
      hits.push({ e, d2 });
    }
  }
  hits.sort((a,b)=>a.d2-b.d2);

  let anyKill=false, curDmg=t.dmg, count=0;
  for (const h of hits){
    if (count >= max) break;
    const e = h.e;
    if (applyEnemyDamage(g, e, Math.max(1, Math.round(curDmg)), t.el)) anyKill = true;
    addPlannedDamage(g, e, estimateHitDamage({ ...t, dmg:curDmg }, e));
    curDmg = Math.max(1, Math.round(curDmg * falloff));
    count++;
  }
  return anyKill;
}


  // Drop-in replacement: slower spawning + enemy abilities (heals, summons, shields, armor, explode-on-death, chain shots, slow/stun auras, stealth reveal, regen, DoTs)

function simulate(g){
  const tNow = now();
  let dt = (tNow - (g.lastTick ?? tNow)) / 1000;
  if (!isFinite(dt) || dt < 0) dt = 0;
  dt = Math.min(dt, PHYS_MAX_DT);
  g.lastTick = tNow;

  // -----------------------------
  // Tunables
  // -----------------------------
  const SPAWN = {
    BASE_MS: 5000,
    MIN_MS:  2500,
    DECAY_MS_PER_LVL: 30,
    PACK_BASE: 1,
    PACK_PER_LVL: 0.35,
    PACK_CAP:  8
  };

  const AURAS = {
    slowAuraFactor: 0.7,
    slowAuraRangeT:  4.5,
    slowAuraTickMs:  250
  };

  const SUMMON = { scatterRadiusT: 1.25 };

  const CHAIN = {
    bounces: 2,
    radiusT: 3.5,
    falloff: 0.6
  };

  const DOTS = {
    burnDps: 1.5,
    poisonDpsCrystal: 2.0
  };

  const COOLDOWNS = {
    enemyMelee: 1.2,
    enemyRanged: 1.4,
    revealSecsOnHit: 3.0
  };

  // -----------------------------
  // Helpers
  // -----------------------------
  const dist2 = (x1,y1,x2,y2)=>{ const dx=x1-x2, dy=y1-y2; return dx*dx+dy*dy; };




  function nearestEnemyInRangeVisible(g, t, range){
    let best = null, bestD2 = Infinity;
    for (const e of g.enemies){
      if (!canTowerTargetEnemy(tNow, e)) continue;
      const d2 = dist2(t.x+0.5,t.y+0.5, e.x+0.5,e.y+0.5);
      if (d2 <= (range*range) && d2 < bestD2){ best = e; bestD2 = d2; }
    }
    return best;
  }

  function enemyRangedTargets(g, e, primary, baseDmg){
    const results = [];
    if (!primary) return results;
    results.push({ target: primary, dmg: baseDmg });

    if (e.tags && e.tags.includes('chain')){
      let prev = primary;
      let dmg = baseDmg * CHAIN.falloff;
      for (let b=0; b<CHAIN.bounces; b++){
        let best=null, bestD2=Infinity;
        for (const other of g.towers){
          if (other === prev) continue;
          const d2=dist2(prev.x+0.5,prev.y+0.5, other.x+0.5,other.y+0.5);
          if (d2 <= CHAIN.radiusT*CHAIN.radiusT && d2<bestD2){
            best=other; bestD2=d2;
          }
        }
        if (!best) break;
        results.push({ target: best, dmg: Math.max(1, Math.round(dmg)) });
        prev = best;
        dmg = Math.max(1, Math.round(dmg * CHAIN.falloff));
      }
    }
    return results;
  }

  // -----------------------------
  // Spawns (slower)
  // -----------------------------
  if (tNow >= (g.nextSpawnAt || 0)) {
    const lvl = g.level || 1;

    const count = Math.min(
      SPAWN.PACK_CAP,
      Math.max(1, SPAWN.PACK_BASE + Math.floor(lvl * SPAWN.PACK_PER_LVL))
    );

    const pair = getOrMakePair(g);

    for (let i = 0; i < count; i++) {
      const base = pair[i & 1];
      const mult = Math.pow(1.25, lvl - 1);
      const HP  = Math.round(base.hp  * mult);
      const DMG = Math.round(base.dmg * mult);
      const x = Math.floor(rnd(2, COLS - 3)), y = 0;

      g.enemies.push({
        id:'e'+Math.random().toString(36).slice(2),
        x, y, el: base.el, type: base.key,
        hp: HP, maxHp: HP, dmg: DMG,
        spd: base.spd, range: base.range,
        target: base.target, cd: 0,
        tags: base.tags||[],
        armor: base.armor||0,
        shield: base.shield||0,
        healRate: base.healRate,
        healRange: base.healRange,
        summon: base.summon
      });
    }

    const interval = Math.max(SPAWN.MIN_MS, SPAWN.BASE_MS - lvl * SPAWN.DECAY_MS_PER_LVL);
    g.nextSpawnAt = tNow + interval;
  }

  // -----------------------------
  // Enemy passives (regen, healer aura, slow aura, summoners)
  // -----------------------------
  for (const e of g.enemies){
    if (e.tags && e.tags.includes('regen') && e.healRate){
      e.hp = Math.min(e.maxHp || e.hp, e.hp + e.healRate * dt);
    }

    if (e.tags && e.tags.includes('healer') && e.healRate && e.healRange){
      const r2 = e.healRange * e.healRange;
      for (const ally of g.enemies){
        if (ally === e || ally.hp <= 0) continue;
        if (dist2(e.x+0.5,e.y+0.5, ally.x+0.5,ally.y+0.5) <= r2){
          ally.hp = Math.min(ally.maxHp || ally.hp, ally.hp + e.healRate * dt);
        }
      }
    }

    if (e.tags && e.tags.includes('slowAura')){
      const r2 = AURAS.slowAuraRangeT * AURAS.slowAuraRangeT;
      for (const t of g.towers){
        if (dist2(e.x+0.5,e.y+0.5, t.x+0.5,t.y+0.5) <= r2){
          t._slowedUntil = Math.max(t._slowedUntil || 0, tNow + AURAS.slowAuraTickMs);
          t._slowFactor = Math.min(t._slowFactor ?? 1, AURAS.slowAuraFactor);
        }
      }
    }

    if (e.summon){
      e._sumCd = (typeof e._sumCd === 'number') ? e._sumCd - dt : 0;
      if (e._sumCd <= 0){
        const base = ENEMY_TYPES.find(z => z.key === e.summon.key);
        if (base){
          const lvl = g.level || 1;
          for (let i=0;i<e.summon.count;i++){
            const nx = Math.max(1, Math.min(COLS-2, Math.round(e.x + rnd(-SUMMON.scatterRadiusT, SUMMON.scatterRadiusT))));
            const ny = Math.max(0, Math.min(ROWS-2, Math.round(e.y + rnd(-SUMMON.scatterRadiusT, SUMMON.scatterRadiusT))));
            const mult = Math.pow(1.25, lvl - 1);
            const HP  = Math.round((base.hp||10) * mult);
            const DMG = Math.round((base.dmg||2) * mult);
            g.enemies.push({
              id:'e'+Math.random().toString(36).slice(2),
              x:nx, y:ny, el: base.el, type: base.key, hp: HP, maxHp: HP, dmg: DMG,
              spd: base.spd, range: base.range, target: base.target, cd: 0,
              tags: base.tags||[], armor: base.armor||0, shield: base.shield||0,
              healRate: base.healRate, healRange: base.healRange, summon: base.summon
            });
          }
        }
        e._sumCd = (e.summon.cd ?? 10);
      }
    }
  }

  // -----------------------------
  // Enemies (movement & attacks)
  // -----------------------------
  for (const e of g.enemies){
    if (e.hp <= 0) continue;

    const cx = g.crystal.x, cy = g.crystal.y;
    const bx = e.x, by = e.y;

    if (e.target === 'tower'){
      const inRangeTgt = nearestTowerInRange(g, e, e.range);
      if (inRangeTgt){
        e.cd -= dt;
        if (e.cd <= 0){
          const ranged = e.range && e.range > 0;
          const baseDmg = e.dmg;
          const siegeMult = (e.tags && e.tags.includes('siege')) ? 1.4 : 1.0;
          const shots = ranged
            ? enemyRangedTargets(g, e, inRangeTgt, Math.round(baseDmg * siegeMult))
            : [{ target: inRangeTgt, dmg: Math.round(baseDmg * siegeMult) }];

          for (const s of shots){
            s.target.hp -= s.dmg;

            if (e.tags){
              if (e.tags.includes('slow')){
                s.target._slowedUntil = Math.max(s.target._slowedUntil || 0, tNow + 900);
                s.target._slowFactor = Math.min(s.target._slowFactor ?? 1, 0.8);
              }
              if (e.tags.includes('stun')){
                s.target._stunnedUntil = Math.max(s.target._stunnedUntil || 0, tNow + 600);
              }
              if (e.tags.includes('burn')){
                s.target._burnUntil = Math.max(s.target._burnUntil || 0, tNow + 1500);
                s.target._burnDps = DOTS.burnDps;
              }
              if (e.tags.includes('armorShred')){
                s.target._vulnUntil = Math.max(s.target._vulnUntil || 0, tNow + 1200);
                s.target._vulnMult = Math.max(s.target._vulnMult || 1, 1.15);
              }
            }

            if (s.target.hp <= 0){
              const idx = g.towers.findIndex(t => t.id === s.target.id);
              if (idx >= 0) g.towers.splice(idx, 1);
            }
          }

          e.cd = ranged ? COOLDOWNS.enemyRanged : COOLDOWNS.enemyMelee;
        }
      } else {
        const chase = (typeof nearestTower === 'function' ? nearestTower(g, e) : null) || { x: cx, y: cy };
        stepToward(e, chase.x, chase.y, dt);
      }
    } else {
      stepToward(e, cx, cy, dt);
    }

    // Collisions after movement
    const ex = Math.floor(e.x), ey = Math.floor(e.y);
    const tIdx = g.towers.findIndex(t => t.x === ex && t.y === ey);
    if (tIdx >= 0){
      const t = g.towers[tIdx];
      const siegeMult = (e.tags && e.tags.includes('siege')) ? 1.4 : 1.0;
      t.hp -= Math.round(e.dmg * siegeMult);
      if (t.hp <= 0) g.towers.splice(tIdx, 1);
      e.hp = 0;
      continue;
    }

    const hitCrystal =
      segmentHitsCircle(bx+0.5, by+0.5, e.x+0.5, e.y+0.5, cx+0.5, cy+0.5, CRYSTAL_HIT_R_T)
      || (ex === cx && ey === cy);

    if (hitCrystal){
      if (e.tags && e.tags.includes('poison')){
        g.crystal._poisonUntil = Math.max(g.crystal._poisonUntil||0, tNow + 2000);
        g.crystal._poisonDps = DOTS.poisonDpsCrystal;
      }
      g.crystal.hp -= e.dmg;
      e.hp = 0;
      g.crystal._flashUntil = now() + 200;
      continue;
    }
  }

  // -----------------------------
  // Tower status upkeep
  // -----------------------------
  for (const t of g.towers){
    t._rateMult = 1;

    if ((t._slowedUntil||0) > tNow){
      t._rateMult = Math.min(t._rateMult, t._slowFactor ?? 0.8);
    } else {
      t._slowFactor = 1;
    }

    if ((t._stunnedUntil||0) > tNow){
      t._stunned = true;
    } else {
      t._stunned = false;
    }

    if ((t._burnUntil||0) > tNow){
      const d = (t._burnDps || DOTS.burnDps) * dt;
      t.hp -= d;
    }

    if (t._vulnUntil && t._vulnUntil <= tNow){
      t._vulnMult = 1;
    }

    if (t.hp <= 0){
      const i = g.towers.findIndex(z => z.id === t.id);
      if (i >= 0) g.towers.splice(i, 1);
    }
  }

  // Crystal DoT upkeep
  if ((g.crystal._poisonUntil||0) > tNow){
    g.crystal.hp -= (g.crystal._poisonDps || DOTS.poisonDpsCrystal) * dt;
  }

  // -----------------------------
  // Towers (HITSCAN ‚Äî instant damage)
  // -----------------------------
 // ---------- Towers (HITSCAN with modes) ----------
g._focusMap = new Map(); // reset planned damage each tick

for (const t of g.towers){
  const rate = Math.max(0.05, (t.rate || 1) * (t._rateMult || 1));
  t.cd = (typeof t.cd === 'number') ? t.cd - dt : 0;

  if (t._stunned) continue;
  if (t.cd > 0) continue;

  // Ensure tower has beam config (backfill for old towers)
  if (!t.beam || !t.beam.mode){
    const m = TOWER_BEAM_PRESETS[t._key || t.key] || 'normal';
    t.beam = { mode: m, ...BEAM_DEFAULTS[m] };
  }
  if (!t.prioritize) t.prioritize = TOWER_PRIORITY_PRESETS[t._key || t.key] || 'closest';

  // Acquire candidates and/or primary target based on priority
  const cand = enemiesInRange(g, t, t.range);
  if (cand.length === 0){ t.cd = 0.1; continue; }

  const sorted = cand.sort((a,b)=> priorityScore(t.prioritize, t, a) - priorityScore(t.prioritize, t, b));
  const primary = sorted[0];

  let killed = false;
  switch(t.beam.mode){
    case 'smart':
      killed = fire_smart(g, t, tNow, sorted);
      break;
    case 'splash':
      killed = fire_splash(g, t, tNow, primary, t.beam);
      break;
    case 'chain':
      killed = fire_chain(g, t, tNow, primary, t.beam);
      break;
    case 'pierce':
      killed = fire_pierce(g, t, tNow, primary, t.beam);
      break;
    case 'normal':
    default:
      killed = fire_normal(g, t, tNow, primary);
      break;
  }

  // Economy / level-up on kill (unchanged)
  if (killed){
    const lvlGain = Math.pow(1.1, (g.level || 1) - 1);
    const owner = g.players.find(z => z.name === t.owner);
    if (owner){
      owner.baseIncomeDelta = (owner.baseIncomeDelta || 0) + (0.05 * lvlGain);
    }
    g.killsThisLevel = (g.killsThisLevel || 0) + 1;
    if (g.killsThisLevel >= (g.killsToAdvance || 20)){
      g.level = (g.level || 1) + 1;
      g.killsThisLevel = 0;
      g.killsToAdvance = Math.round((g.killsToAdvance || 20) * 1.25);
    }
  }

  // Cooldown (same cadence as you had)
  t.cd = 1 / Math.max(0.2, rate);
}


  // Cleanup dead enemies (in case anything went ‚â§0 outside applyEnemyDamage)
  g.enemies = g.enemies.filter(e => e.hp > 0);

  // -----------------------------
  // Periodic income (every 30s)
  // -----------------------------
 // Periodic income (every 30s) ‚Äî persisted and catch-up safe
if (!g.nextIncomeAt) g.nextIncomeAt = tNow + 15000;

let safety = 0;
while (tNow >= g.nextIncomeAt && safety < 10) { // catch up if host stalled
  for (const p of g.players){
    const base = (typeof p.baseIncome === 'number' ? p.baseIncome : 1);
    const inc  = base + (p.baseIncomeDelta || 0);
    p.funds += inc;
  }
  g.nextIncomeAt += 15000;
  safety++;
}
// Mark defeat. Host loop finalizes and restarts after a short pause.
if (g.crystal.hp < 1) {
  return {
    ...g,
    status: 'defeat',
    highScore: Math.max(g.highScore || 0, g.level || 1)
  };
}
  return g;
}


    function nearestEnemyInRange(g, t, range){
      let best=null, bd=1e9;
      for (const e of g.enemies){ const d = dist2(t.x,t.y, e.x,e.y); if (d <= (range+0.5)**2 && d<bd){ bd=d; best=e; } }
      return best;
    }
    function nearestTowerInRange(g, e, range){
      let best=null, bd=1e9;
      for (const t of g.towers){ const d = dist2(t.x,t.y, e.x,e.y); if (d <= (range+0.5)**2 && d<bd){ bd=d; best=t; } }
      return best;
    }

    // Persist baseIncome deltas and schedule restart (no lobby deactivation)
  async function finalizeAndMarkDefeat(g){
  try{
    await runTransaction(db, async (tx)=>{
      // Read lobby doc inside the txn
      const s = await tx.get(lobbyRef);
      if (!s.exists()) throw new Error('ABORT_NO_DOC');

      const d = s.data() || {};
      if (d.host !== me) throw new Error('ABORT_NOT_HOST');

      // Use the server copy if present; otherwise the passed-in snapshot
      const cur = d.game || g;
      if (cur && cur._finalized) throw new Error('ABORT_ALREADY_FINALIZED');

      // ---- Persist baseIncome gains (idempotent per run) ----
      const players = Array.isArray(cur?.players) ? cur.players : [];
      for (const p of players){
        const delta = round2(p.baseIncomeDelta || 0);
        if (delta > 0){
          const uref = doc(db, 'users', p.name);
          const us   = await tx.get(uref);

          let curBase = 1;
          if (us.exists()){
            const estate = us.data().estate || {};
            curBase = (typeof estate.baseIncome === 'number') ? estate.baseIncome : 1;
          }
          const next = round2(curBase + delta);
          tx.set(uref, { estate: { baseIncome: next } }, { merge: true });
        }
      }

      // ---- Mark defeat + schedule restart (do not deactivate lobby) ----
      const runHigh = Math.max(cur?.highScore || 0, cur?.level || 1);
      const updated = {
        ...cur,
        status: 'defeat',
        highScore: runHigh,
        _finalized: true,
        _restartAt: now() + 2500, // ~2.5s pause before restart
      };

      tx.update(lobbyRef, { game: updated, estateHighScore: runHigh });

      for (const p of players){
        const uref = doc(db, 'users', p.name);
        const us = await tx.get(uref);
        const estate = us.exists() ? (us.data().estate || {}) : {};
        const prevHigh = (typeof estate.highScore === 'number') ? estate.highScore : 0;
        if (runHigh > prevHigh){
          tx.set(uref, { estate: { highScore: runHigh } }, { merge: true });
        }
      }
    });
  } catch(e){
    // Only log unexpected issues; "ABORT_*" are normal control-flow exits
    const msg = String((e && e.message) || e);
    if (!msg.startsWith('ABORT_')){
      console.warn('finalizeAndMarkDefeat txn error:', e);
    }
  }
}
// --- FX registries ---
const _fxRings = [];   // expanding shockwaves
const _fxSparks = [];  // tiny particles

function addShockwaveRing(xT,yT, rT0=0.3, rT1=2.0, dur=220, color="#fff", w=2){
  const now = Date.now();
  _fxRings.push({x:xT,y:yT,rT0,rT1,start:now,until:now+dur,color,alpha0:0.6,alpha1:0.0,w});
}

function addSparkBurst(xT,yT, n=8, speedT=6, dur=180, color="#fff"){
  const now = Date.now();
  for (let i=0;i<n;i++){
    const a = Math.random()*Math.PI*2;
    const s = (0.4+0.6*Math.random())*speedT;
    _fxSparks.push({x:xT,y:yT,vx:Math.cos(a)*s,vy:Math.sin(a)*s,start:now,until:now+dur,color});
  }
}

// Lightning polyline built from little tracer segments with jitter
function addLightningArc(x1,y1,x2,y2, segs=4, jitterT=0.25, dur=90, color="#ffd54f", w=3){
  let px=x1, py=y1;
  for (let i=1;i<=segs;i++){
    const t = i/segs;
    const bx = x1 + (x2-x1)*t;
    const by = y1 + (y2-y1)*t;
    const nx = bx + (Math.random()*2-1)*jitterT;
    const ny = by + (Math.random()*2-1)*jitterT;
    addTracer(px,py,nx,ny,dur,color,w,0.9);
    px=nx; py=ny;
  }
}


    // ----- Scrolling -----
    function syncSlider(){ vScroll.value = Math.round(camY); }
    function centerOnCore(){ if (!state || !state.crystal) return; camY = clamp(state.crystal.y * TILE - H/2, 0, MAP_H - H); syncSlider(); }
    function centerOnTowerCycle(){
      if (!state || !state.towers || !state.towers.length) { toast('No towers yet'); return; }
      const myTowers = state.towers.filter(t => t.owner === me);
      const towers = myTowers.length ? myTowers : state.towers;
      const t = towers[_towerCycleIndex % towers.length];
      _towerCycleIndex++;
      camY = clamp(t.y * TILE - H/2, 0, MAP_H - H);
      syncSlider();
      toast(`Viewing ${t.name || t.key || 'tower'}`);
    }
    async function toggleFullscreen(){
      try {
        if (!document.fullscreenElement) {
          await document.documentElement.requestFullscreen();
          if (mobileFullscreenBtn) mobileFullscreenBtn.textContent = 'üóó Exit';
        } else {
          await document.exitFullscreen();
          if (mobileFullscreenBtn) mobileFullscreenBtn.textContent = '‚õ∂ Fullscreen';
        }
      } catch {
        toast('Fullscreen unavailable');
      }
    }
    vScroll.max = Math.max(0, MAP_H - H); vScroll.value = camY;
    vScroll.addEventListener('input', ()=>{ camY = clamp(parseInt(vScroll.value,10)||0, 0, MAP_H - H); });
    centerBtn.onclick = centerOnCore;
    if (mobileCoreBtn) mobileCoreBtn.onclick = centerOnCore;
    if (mobileTowerBtn) mobileTowerBtn.onclick = centerOnTowerCycle;
    if (mobileFullscreenBtn) mobileFullscreenBtn.onclick = toggleFullscreen;
    canvas.addEventListener('wheel', (ev)=>{ ev.preventDefault(); camY = clamp(camY + ev.deltaY, 0, MAP_H - H); syncSlider(); }, { passive:false });
    window.addEventListener('keydown', (e)=>{ if (e.key==='ArrowUp'||e.key==='w'||e.key==='W') camY=clamp(camY-50,0,MAP_H-H); if (e.key==='ArrowDown'||e.key==='s'||e.key==='S') camY=clamp(camY+50,0,MAP_H-H); if (e.key==='c'||e.key==='C') centerOnCore(); syncSlider(); });

// ----- Render -----
function draw(){
  ctx.clearRect(0,0,W,H);
  const offY = camY;
  const nowMs = Date.now();

  // helper for beam thickness by damage (tweak to taste)
  const beamWidthFromDamage = (dmg)=> Math.max(2, Math.sqrt(Math.max(1, dmg)) * 0.6);

  // Background + grid
  ctx.fillStyle = "#e9eef3";
  ctx.fillRect(0,0,W,H);
  ctx.strokeStyle = "#d7dee6";
  ctx.lineWidth = 1;
  for (let y = 0; y <= H; y += TILE){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
  for (let x = 0; x <= W; x += TILE){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }

  if (!state || !state.crystal) return;

  // Crystal (with hit flash)
  {
    const cx = state.crystal.x*TILE + TILE/2;
    const cy = state.crystal.y*TILE - offY + TILE/2;

    if (state.crystal._flashUntil && nowMs < state.crystal._flashUntil){
      ctx.save();
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = "#ef4444";
      ctx.beginPath(); ctx.arc(cx, cy, 28, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    ctx.strokeStyle="#a78bfa"; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(cx,cy,16,0,Math.PI*2); ctx.stroke();
    ctx.fillStyle="#7c3aed"; ctx.beginPath(); ctx.arc(cx,cy,12,0,Math.PI*2); ctx.fill();
    ctx.fillStyle="#111"; ctx.font="12px Segoe UI"; ctx.textAlign="center"; ctx.textBaseline="alphabetic";
    ctx.fillText("CRYSTAL", cx, cy-28);

    const hpw=80, hpx=cx-hpw/2, hpy=cy-24;
    const pct=Math.max(0, Math.min(1, (state.crystal.hp/state.crystal.maxHp)));
    ctx.fillStyle="#222"; ctx.fillRect(hpx,hpy,hpw,6);
    ctx.fillStyle = pct>0.5 ? "#22c55e" : pct>0.25 ? "#f59e0b" : "#ef4444";
    ctx.fillRect(hpx,hpy,hpw*pct,6);
  }

  // Towers
  for (const t of (state.towers||[])){
    const x = t.x*TILE+TILE/2, y = t.y*TILE - offY + TILE/2;
    const col = t.ownerColor || (state.players||[]).find(p=>p.name===t.owner)?.color || '#000';
    ctx.save();
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = col;
    ctx.fillRect(t.x*TILE, t.y*TILE - offY, TILE, TILE);
    ctx.restore();

    ctx.font="20px Segoe UI Emoji"; ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText(t.emoji, x, y);

    const tpct = Math.max(0, Math.min(1, (t.hp / t.maxHp)));
    ctx.fillStyle="#111"; ctx.fillRect(x-14,y+12,28,4);
    ctx.fillStyle="#16a34a"; ctx.fillRect(x-14,y+12, 28*tpct, 4);
    ctx.fillStyle = "#111";
    ctx.font = "11px Segoe UI";
    ctx.textAlign = "center";
    ctx.fillText(`üë∑ ${t.owner || 'unknown'}`, x, y - 16);
  }

  // ===== Buffered rendering (enemies only) =====
  const renderDelay = (typeof RENDER_DELAY_MS === 'number') ? RENDER_DELAY_MS : 220;
  const targetMs = nowMs - renderDelay;

  let a = null, b = null;
  if (_snapBuf && _snapBuf.length){
    for (let i = _snapBuf.length - 1; i >= 0; i--){
      const s = _snapBuf[i];
      if (s.at <= targetMs){ a = s; b = _snapBuf[i+1] || s; break; }
    }
    if (!a){
      if (_snapBuf.length >= 2){ a = _snapBuf[0]; b = _snapBuf[1]; }
      else if (_snapBuf.length === 1){ a = b = _snapBuf[0]; }
    }
  }

  function interpEntity(aMap, bMap, t0, t1, tTarget, drawFn){
    const dt = Math.max(1, t1 - t0);
    const alpha = Math.max(0, Math.min(1, (tTarget - t0) / dt));
    const keys = new Set([...(aMap?.keys?.() || []), ...(bMap?.keys?.() || [])]);
    for (const id of keys){
      const A = aMap?.get?.(id) || bMap?.get?.(id);
      const B = bMap?.get?.(id) || aMap?.get?.(id);
      if (!A || !B) continue;
      const x = A.x + (B.x - A.x) * alpha;
      const y = A.y + (B.y - A.y) * alpha;
      drawFn(id, { x, y, A, B, alpha });
    }
  }

  const ENOJI = {
    slime:"üü¢", sprout:"üå±", gob:"üë∫", imp:"üòà", bat:"ü¶á",
    arch:"üèπ", ashling:"üü§", bomber:"üí£", sapper:"üß®", shaman:"üßô‚Äç‚ôÇÔ∏è", sniper:"üéØ",
    brute:"üí¢", shield:"üõ°Ô∏è", witch:"üßô‚Äç‚ôÄÔ∏è", crawler:"üêõ", druid:"üçÉ",
    cata:"ü™®", wolf:"üê∫", golem:"üóø", specter:"üëª", pyro:"üî•", cryo:"üßä",
    runner:"üèÉ‚Äç‚ôÇÔ∏è", thornlr:"üåµ", assassin:"üó°Ô∏è", warlock:"ü™Ñ", dryad:"üßù‚Äç‚ôÄÔ∏è",
    icebrk:"üßä", thunder:"üå©Ô∏è", basilisk:"üêç", demo:"üõ†Ô∏è", tempest:"üå™Ô∏è",
    banshee:"üò±", jugger:"üß±", lich:"üíÄ", behemoth:"üêò", phoenix:"ü¶Ö",
    warden:"üóùÔ∏è", ancient:"üè∫", stormwyrm:"üêâ", frostqn:"üëë", infernal:"üî•",
    treant:"üå≤", overseer:"üëÅÔ∏è", glacier:"üèîÔ∏è", hellkite:"üê≤", titan:"üóº"
  };

  if (a && b){
    interpEntity(a.enemies, b.enemies, a.at, b.at, targetMs, (id, pos) => {
      const ent = b.enemies.get(id) || a.enemies.get(id);
      const X = pos.x*TILE + TILE/2;
      const Y = pos.y*TILE - offY + TILE/2;
      const col = ELEM_COL[ent.el] || "#999";
      ctx.strokeStyle=col; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(X,Y,12,0,Math.PI*2); ctx.stroke();
      ctx.fillStyle="#111"; ctx.beginPath(); ctx.arc(X,Y,10,0,Math.PI*2); ctx.fill();
      const EMO = ENOJI[ent.type] || "‚ö´";
      ctx.font="16px Segoe UI Emoji"; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText(EMO, X, Y);

      const hpNow = (typeof ent.hp === 'number') ? ent.hp : 1;
      const hpMax = (typeof ent.maxHp === 'number') ? ent.maxHp : Math.max(1, hpNow);
      const p = Math.max(0, Math.min(1, hpNow / hpMax));
      const w=22, h=4;
      ctx.fillStyle="#111"; ctx.fillRect(X-w/2, Y+14, w, h);
      ctx.fillStyle = p>0.5?"#22c55e":p>0.25?"#f59e0b":"#ef4444";
      ctx.fillRect(X-w/2, Y+14, w*p, h);
    });
  } else {
    for (const e of (state.enemies||[])){
      const X=e.x*TILE+TILE/2, Y=e.y*TILE - offY + TILE/2;
      const col=ELEM_COL[e.el]||"#999";
      ctx.strokeStyle=col; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(X,Y,12,0,Math.PI*2); ctx.stroke();
      ctx.fillStyle="#111"; ctx.beginPath(); ctx.arc(X,Y,10,0,Math.PI*2); ctx.fill();
      const EMO = ENOJI[e.type] || "‚ö´";
      ctx.font="16px Segoe UI Emoji"; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText(EMO, X, Y);
      const w=22, h=4, p = Math.max(0, Math.min(1, (e.hp||0) / (e.maxHp||e.hp||1)));
      ctx.fillStyle="#111"; ctx.fillRect(X-w/2, Y+14, w, h);
      ctx.fillStyle=p>0.5?"#22c55e":p>0.25?"#f59e0b":"#ef4444"; ctx.fillRect(X-w/2, Y+14, w*p, h);
    }
  }

  // ----- Local visual fire (client-only beams) -----
 // ----- Local visual fire (client-only beams) -----
if (!window._vizCd) window._vizCd = new Map();
const enMap = (b && b.enemies && b.enemies.size) ? b.enemies : null;

// helpers scoped to draw()
const elCol = (el)=> (ELEM_COL && ELEM_COL[el]) || "#222";
function neighborsInRadius(ent, rT){
  const out=[]; if (!enMap || !ent) return out;
  const r2 = rT*rT;
  for (const e of enMap.values()){
    if (!e || e.id===ent.id) continue;
    const dx = (ent.x - e.x), dy = (ent.y - e.y);
    if (dx*dx + dy*dy <= r2) out.push(e);
  }
  return out;
}
function buildChainPath(start, bounces, rT){
  if (!enMap || !start) return [];
  const path=[start]; let cur=start;
  for (let i=0;i<bounces;i++){
    let best=null, bd=Infinity;
    for (const e of enMap.values()){
      if (!e || path.some(p=>p.id===e.id)) continue;
      const dx = (cur.x - e.x), dy = (cur.y - e.y);
      const d2 = dx*dx + dy*dy;
      if (d2 <= rT*rT && d2 < bd){ best=e; bd=d2; }
    }
    if (!best) break;
    path.push(best); cur=best;
  }
  return path;
}
function hitsAlongLine(x1,y1,x2,y2, radiusT, max=4){
  const out=[];
  for (const e of (enMap?.values?.() || [])){
    if (!e) continue;
    if (segmentHitsCircle(x1,y1,x2,y2, e.x+0.5, e.y+0.5, radiusT)){
      const dx=(e.x+0.5)-x1, dy=(e.y+0.5)-y1;
      out.push({ e, d2: dx*dx+dy*dy });
    }
  }
  out.sort((a,b)=>a.d2-b.d2);
  return out.slice(0,max);
}

for (const t of (state.towers || [])){
  const key = t.id;
  const cur = window._vizCd.get(key) || { cd: 0, rate: Math.max(0.2, t.rate || 1) };

  // respect slows/stuns so we don't draw ‚Äúghost‚Äù beams
  const rateMult = (t._rateMult || 1);
  const effectiveRate = Math.max(0.05, (t.rate || 1) * rateMult);
  cur.cd -= 1/30;
  if (t._stunned) { cur.cd = 0.2; window._vizCd.set(key, cur); continue; }

  // pick target roughly like the sim
  let pick = null;
  if (enMap){
    let best=null, bd=1e9;
    for (const e of enMap.values()){
      const dx=(t.x+0.5)-e.x, dy=(t.y+0.5)-e.y; const d2=dx*dx+dy*dy;
      if (d2 <= (t.range*t.range) && d2 < bd){ best=e; bd=d2; }
    }
    pick = best;
  } else {
    pick = (state.enemies||[]).reduce((best,e)=>{
      const dx=(t.x+0.5)-e.x, dy=(t.y+0.5)-e.y; const d2=dx*dx+dy*dy;
      return (d2 <= (t.range*t.range) && (!best || d2 < best.d2)) ? {e,d2} : best;
    }, null)?.e || null;
  }

  if (cur.cd <= 0){
    const mode = (t.beam && t.beam.mode) || "normal";
    const col  = elCol(t.el);
    const w    = beamWidthFromDamage(t.dmg || 5);
    const tx = t.x+0.5, ty = t.y+0.5;

    if (!pick){
      cur.cd = 0.1;
      window._vizCd.set(key, cur);
      continue;
    }

    // NORMAL / SMART: single clean beam
    if (mode === "normal" || mode === "smart"){
      addTracer(tx,ty, (pick.x||pick.X)+0.5, (pick.y||pick.Y)+0.5, 90, col, w, 0.9);
      // tiny muzzle flash
      addShockwaveRing(tx,ty, 0.2, 0.55, 110, col, 1.5);
    }

    // SPLASH: impact shockwave + spokes to neighbors
    else if (mode === "splash"){
      const ix = (pick.x||pick.X)+0.5, iy = (pick.y||pick.Y)+0.5;
      addTracer(tx,ty, ix,iy, 90, col, w, 0.9);
      const rT = Math.max(1.0, (t.beam.radiusT || 1.6));
      const neigh = neighborsInRadius(pick, rT).slice(0, 4);
      for (const n of neigh){
        addTracer(ix,iy, n.x+0.5, n.y+0.5, 80, col, Math.max(2, w*0.6), 0.6);
      }
      addShockwaveRing(ix,iy, 0.4, rT, 160, col, 2.2);
      if (t.dmg >= 150) addSparkBurst(ix,iy, 10, 7, 220, col);
    }

    // CHAIN: jittery lightning that bounces
    else if (mode === "chain"){
      const bounces = Math.max(1, t.beam.bounces || 2);
      const rT      = Math.max(2.4, t.beam.radiusT || 3.0);
      const path = buildChainPath(pick, bounces, rT);
      // draw first leg from tower
      if (path.length){
        addLightningArc(tx,ty, path[0].x+0.5, path[0].y+0.5, 5, 0.25, 95, col, Math.max(3, w*0.9));
        addShockwaveRing(tx,ty, 0.2, 0.6, 110, col, 1.4);
      }
      // draw bounces
      for (let i=0;i<path.length-1;i++){
        const a = path[i], b2 = path[i+1];
        addLightningArc(a.x+0.5,a.y+0.5, b2.x+0.5,b2.y+0.5, 5, 0.30, 95, col, Math.max(2.5, w*0.8));
        addSparkBurst(b2.x+0.5,b2.y+0.5, 6, 5, 160, col);
      }
    }

    // PIERCE: long line through many, with rings on each hit
    else if (mode === "pierce"){
      const ix = (pick.x||pick.X)+0.5, iy = (pick.y||pick.Y)+0.5;
      const max = Math.max(2, t.beam.max || 3);
      const rT  = Math.max(0.48, t.beam.radiusT || 0.55);
      addTracer(tx,ty, ix,iy, 95, col, w+1, 0.95);

      const hits = hitsAlongLine(tx,ty, ix,iy, rT, max);
      for (const h of hits){
        addShockwaveRing(h.e.x+0.5, h.e.y+0.5, 0.3, 0.9, 140, col, 2.0);
        if (t.dmg >= 200) addSparkBurst(h.e.x+0.5, h.e.y+0.5, 8, 6, 180, col);
      }
    }

    cur.cd = 1 / effectiveRate;
  }

  window._vizCd.set(key, cur);
}

  // ----- Beams on top -----
  for (let i=_tracers.length-1; i>=0; i--){
    const tr=_tracers[i];
    if (nowMs > tr.until){ _tracers.splice(i,1); continue; }
    const x1 = tr.x1 * TILE, y1 = tr.y1 * TILE - camY;
    const x2 = tr.x2 * TILE, y2 = tr.y2 * TILE - camY;
    ctx.save();
    ctx.globalAlpha = tr.alpha ?? 0.85;
    ctx.strokeStyle = tr.col || "#222";
    ctx.lineWidth   = tr.w || 2.5;
    ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
    ctx.restore();
  }
  // ----- Shockwaves (rings) -----
for (let i=_fxRings.length-1; i>=0; i--){
  const f = _fxRings[i];
  const nowMs2 = Date.now();
  const life = f.until - f.start;
  const t = (nowMs2 - f.start) / Math.max(1, life);
  if (t >= 1){ _fxRings.splice(i,1); continue; }
  const rT = f.rT0 + (f.rT1 - f.rT0) * t;
  const alpha = f.alpha0 + (f.alpha1 - f.alpha0) * t;

  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.strokeStyle = f.color;
  ctx.lineWidth = f.w;
  ctx.beginPath();
  ctx.arc(f.x * TILE, f.y * TILE - camY, rT * TILE, 0, Math.PI*2);
  ctx.stroke();
  ctx.restore();
}

// ----- Sparks -----
for (let i=_fxSparks.length-1; i>=0; i--){
  const p = _fxSparks[i];
  const nowMs2 = Date.now();
  const life = p.until - p.start;
  const t = (nowMs2 - p.start) / Math.max(1, life);
  if (t >= 1){ _fxSparks.splice(i,1); continue; }

  const dt = (nowMs2 - p.start) / 1000;
  const x = (p.x + p.vx * dt) * TILE;
  const y = (p.y + p.vy * dt) * TILE - camY;

  ctx.save();
  ctx.globalAlpha = 1 - t;
  ctx.fillStyle = p.color;
  ctx.fillRect(x-1, y-1, 2, 2);
  ctx.restore();
}

}


    renderShop();
    setInterval(draw, 1000/30);
    await ensureUserIncome();
  </script>
</body>
</html>






















