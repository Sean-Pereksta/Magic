<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Dutch Blitz ‚Äî Arena (Realtime, One-Screen Auto-Fit)</title>
<style>
  :root{
    --bg:#0b1014; --panel:#0e1726; --ink:#e6efff; --muted:#a8b3c7; --edge:#26334f; --accent:#8b5cf6;
    --y:#facc15; --o:#fb923c; --g:#22c55e; --b:#60a5fa;
    --gap: clamp(6px, 1vw, 12px);
    --cardW: clamp(118px, 36vw, 220px);
    --cardH: clamp(58px, 18vw, 98px);
    --radius: 12px;

    /* center piles (base; auto-resized; then whole stage is auto-scaled) */
    --pileSize: 64px; 
    --pileGap: 8px;
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  html, body{
    margin:0;background:var(--bg);color:var(--ink);
    font-family:system-ui,Segoe UI,Roboto,Arial;
    -webkit-tap-highlight-color: transparent;
    overflow:hidden;             /* no page scroll */
    overscroll-behavior:none;
  }

  /* ===== Auto-Fit Shell =====
     #fitRoot fills the window. #stage is measured at scale(1). We compute a scale
     so #stage fits and apply transform to #stage. This guarantees one screen, no clipping. */
  #fitRoot{
    position:fixed; inset:0;       /* fill the viewport */
    display:flex; align-items:center; justify-content:center;
    overflow:hidden;
  }
  #stageWrap{
    width:100%; height:100%;
    display:flex; align-items:center; justify-content:center;
    overflow:hidden;               /* never allow scrollbars */
  }
  #stage{
    transform-origin: top center;  /* scale from top center so layout feels natural */
    will-change: transform;
  }

  /* ===== Stage layout (natural size; then auto-scaled) ===== */
  #screen{
    display:grid;
    grid-template-rows: auto auto 1fr auto;  /* HUD, Store, Center, Bottom */
    gap: var(--gap);
    padding: var(--gap);
    max-width: 820px;           /* natural max width; feel free to tweak */
    min-width: 320px;           /* keeps chips/cards readable pre-scale */
    /* natural height is whatever the sections need; we‚Äôll scale to fit */
    background: transparent;
  }

  /* ===== HUD ===== */
  #hud{
    display:flex; flex-direction:column; gap:8px; align-items:center; justify-content:center;
    padding:10px 12px;
    background:linear-gradient(180deg, rgba(15,23,42,.9), rgba(14,21,35,.9));
    border:1px solid #24324c; border-radius:12px; box-shadow:0 8px 24px rgba(0,0,0,.34);
    backdrop-filter: blur(3px);
  }
  .hudRow{display:flex;gap:6px;flex-wrap:wrap;align-items:center;justify-content:center}
  .stat{
    display:inline-flex;align-items:center;gap:6px;
    background:#0c1423;border:1px solid #1d2840;border-radius:999px;
    padding:6px 10px; min-width:80px; justify-content:center;
  }
  .stat .val{font-weight:900;font-size:16px;line-height:1}
  .stat .lbl{font-size:10px;color:#a9b6cc;letter-spacing:.3px;text-transform:uppercase}
  .timerbar{height:8px;background:#0c1423;border:1px solid #17223a;border-radius:999px;overflow:hidden;min-width:220px;width:100%}
  .timerbar>div{height:100%;background:var(--accent);width:0%}

  #playersMini{display:flex; gap:6px; flex-wrap:nowrap; overflow:hidden}
  .chip{
    display:inline-flex; align-items:center; gap:6px;
    padding:4px 8px; border:1px solid #1d2840; border-radius:999px; background:#0c1423; font-size:12px;
    white-space:nowrap;
  }
  .dot{width:10px;height:10px;border-radius:50%}
  .legend{color:#c6d0e0;font-size:11px;text-align:center}

  /* ===== Store (always 3 items on top) ===== */
  #storeTop{
    display:flex; gap:8px; align-items:center; justify-content:space-between;
    padding:10px; background:var(--panel); border:1px solid #1a243a; border-radius:var(--radius);
  }
  #storeItems{display:flex; gap:8px; align-items:center; justify-content:center; flex:1; flex-wrap:nowrap}
  .storeCol{display:flex;flex-direction:column;align-items:center;gap:6px}
  .btn{
    padding:8px 10px;border-radius:10px;border:1px solid #223252;background:#13223a;color:#e6efff;cursor:pointer;font-weight:800;text-align:center;touch-action:manipulation;
    min-height:36px;
  }
  .btn:disabled{opacity:.5;cursor:not-allowed}

  /* ===== Center Piles (auto layout; then whole stage scales) ===== */
  #centerBand{
    border:1px dashed #20304f; border-radius:10px; padding:8px;
    background:#0e1626; min-height:140px; height:100%; overflow:hidden;
    display:flex; align-items:center; justify-content:center;
  }
  #piles{
    display:grid;
    grid-auto-rows:var(--pileSize);
    grid-template-columns:repeat(10, var(--pileSize));
    gap:var(--pileGap);
    place-content:start center;
  }
  .tile{
    width:var(--pileSize); height:var(--pileSize);
    border:2px solid var(--edge); border-radius:12px;
    display:flex; align-items:center; justify-content:center; gap:2px;
    font-weight:900; color:#0b0b0b; box-shadow:0 6px 16px rgba(0,0,0,.28);
    cursor:pointer; user-select:none; touch-action:manipulation;
    position:relative; outline-offset:-5px; min-height:44px;
  }
  .tile.valid{ outline:6px solid #84cc16; box-shadow:0 0 0 6px rgba(132,204,22,.35), 0 12px 22px rgba(0,0,0,.3); }
  .own{
    position:absolute; bottom:2px; right:4px; font-size:11px;
    color:#0b1014; background:rgba(255,255,255,.92); padding:2px 8px; border-radius:999px; font-weight:800;
    pointer-events:none;
  }

  /* ===== Card chip ===== */
  .rect{
    width:var(--cardW); height:var(--cardH); border-radius:12px; border:2px solid var(--edge);
    display:flex; align-items:center; justify-content:space-between; padding:0 12px;
    color:#0b0b0b; font-weight:900; box-shadow:0 5px 18px rgba(0,0,0,.26);
    user-select:none; -webkit-user-select:none; touch-action:manipulation; cursor:pointer;
    outline-offset:-6px; min-height:44px;
  }
  .rect.sel{ outline:4px solid #ef4444; }

  .c-yellow{background:linear-gradient(135deg,var(--y),#fee780);border-color:#eab308}
  .c-orange{background:linear-gradient(135deg,var(--o),#fed7aa);border-color:#fb923c}
  .c-green{background:linear-gradient(135deg,var(--g),#bbf7d0);border-color:#22c55e}
  .c-blue{background:linear-gradient(135deg,var(--b),#bae6fd);border-color:#60a5fa}

  /* ===== Bottom bar: Hand + Counts ===== */
  #bottomBar{
    display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center;
  }
  #handWrap{display:flex; gap:8px; align-items:center}
  #counts{
    display:flex; gap:10px; align-items:center; justify-content:flex-end;
    background:#0c1423;border:1px solid #1d2840;border-radius:12px;padding:8px 10px; min-width:160px;
  }
  .countItem{display:flex; gap:6px; align-items:center; font-weight:800}

  /* Overlay */
  .overlay{position:fixed;inset:0;background:rgba(0,0,0,.65);display:none;align-items:center;justify-content:center;z-index:40}
  .dialog{background:#0f172a;border:1px solid #243754;border-radius:16px;padding:16px;min-width:min(720px,95vw);max-width:95vw;max-height:92vh;overflow:auto;box-shadow:0 18px 44px rgba(0,0,0,.45)}
  .dialog .big{font-size:24px;font-weight:900;margin-bottom:6px}
  .dialog .sub{font-size:14px;color:#c2cee3;margin-bottom:10px}
  .dialog .actions{display:flex;gap:10px;justify-content:center;margin-top:8px}
</style>
</head>
<body>
  <!-- Auto-fit shell -->
  <div id="fitRoot">
    <div id="stageWrap">
      <!-- Everything inside #stage is measured/scaled to fit the window -->
      <main id="stage">
        <section id="screen" role="application">
          <!-- HUD -->
          <section id="hud" aria-live="polite">
            <div class="hudRow">
              <div class="stat"><span class="lbl">HP</span><span class="val" id="youHP">100</span></div>
              <div class="stat"><span class="lbl">Heal</span><span class="val" id="youHeal">0</span></div>
              <div class="stat"><span class="lbl">Damage</span><span class="val" id="youAtk">0</span></div>
              <div class="stat"><span class="lbl">Ward</span><span class="val" id="youWard">0</span></div>
              <div class="stat"><span class="lbl">Gold</span><span class="val" id="youGold">0</span></div>
            </div>
            <div class="timerbar" title="Tick"><div id="tickBar"></div></div>
            <div id="playersMini"></div>
            <div class="legend">üí∞ Gold ‚Ä¢ ‚öîÔ∏è Damage ‚Ä¢ ‚ù§Ô∏è Heal ‚Ä¢ üõ°Ô∏è Ward</div>
          </section>

          <!-- Store (top, exactly 3 items) -->
          <section id="storeTop" aria-label="Store">
            <strong>Store</strong>
            <div id="storeItems"></div>
            <div style="display:flex; align-items:center; gap:8px">
              <span>Gold: <b id="gold2">0</b></span>
            </div>
          </section>

          <!-- Center piles -->
          <section id="centerBand" aria-label="Center Piles">
            <div id="piles"></div>
          </section>

          <!-- Bottom bar: hand + counts -->
          <section id="bottomBar">
            <div id="handWrap">
              <button class="btn" id="flipBtn">üîÅ Flip</button>
              <button class="btn" id="fsBtn" title="Toggle Fullscreen" aria-pressed="false">‚õ∂ FS</button>
              <div id="hand" class="rect" style="pointer-events:none; opacity:.4; justify-content:center">‚Äî</div>
            </div>
            <div id="counts">
              <div class="countItem">Deck: <span id="deckCount">0</span></div>
              <div class="countItem">Discard: <span id="discardCount">0</span></div>
              <div class="countItem">Tick: <span id="tickIn">10.0</span>s</div>
            </div>
          </section>
        </section>
      </main>
    </div>
  </div>

  <!-- Overlay -->
  <div id="overlay" class="overlay" aria-hidden="true">
    <div class="dialog">
      <div id="ovTitle" class="big"></div>
      <div id="ovMsg" class="sub"></div>
      <div id="ovBtns" class="actions"></div>
    </div>
  </div>

<script type="module">
/* ========= Firebase ========= */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, onSnapshot,
  collection, addDoc, serverTimestamp, runTransaction,
  query, orderBy, deleteDoc
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);

/* ========= URL / Routing ========= */
const url   = new URL(window.location.href);
const gameId   = url.searchParams.get("gameId");
const username = (url.searchParams.get("username")||"").trim();
const HUB_URL = "/"; // change if your hub path differs
if(!gameId || !username){ alert("Missing gameId or username in URL."); }

/* ========= Utils ========= */
const COLORS=["yellow","orange","green","blue"];
const ICON={yellow:"üí∞",orange:"‚öîÔ∏è",green:"‚ù§Ô∏è",blue:"üõ°Ô∏è"};
const CCLS={yellow:"c-yellow",orange:"c-orange",green:"c-green",blue:"c-blue"};
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
const uid=(()=>{let i=1;return()=> "id"+(i++)})();
const nowMs=()=>Date.now();

const $=sel=>document.querySelector(sel);

/* ========= Auto-Fit (ALWAYS fits to one screen) ========= */
function fitToViewport(){
  const wrap  = document.getElementById('stageWrap');
  const stage = document.getElementById('stage');
  if(!wrap || !stage) return;

  // Reset transform to measure natural size
  stage.style.transform = 'none';

  // Force layout read
  const rect = stage.getBoundingClientRect();
  const naturalW = rect.width  || 1;
  const naturalH = rect.height || 1;

  const vw = wrap.clientWidth  || window.innerWidth;
  const vh = wrap.clientHeight || window.innerHeight;

  // Tiny padding to avoid edge clipping
  const padW = 8, padH = 8;

  // Scale down to fit, never upscale above 1 to keep sharp
  const scale = Math.min(vw / (naturalW + padW), vh / (naturalH + padH), 1);

  stage.style.transform = `scale(${scale})`;
}

/* Re-fit on window changes */
addEventListener('resize', fitToViewport, { passive:true });
addEventListener('orientationchange', ()=> setTimeout(fitToViewport, 150), { passive:true });

/* ========= Firestore refs ========= */
const lobbyRef = doc(db, "lobbies", gameId);
const gameRef  = doc(db, "dutchblitz_games", gameId);
const actionsCol = collection(db, "dutchblitz_games", gameId, "actions");

/* ========= Local ========= */
let L = {
  me: username,
  isHost: false,
  game: null,
  selectedCardId: null,
  colorMap: new Map()
};

/* ========= Colors ========= */
const PLAYER_PALETTE = ["#ef4444", "#22d3ee", "#f59e0b", "#8b5cf6"];
function computeColorMap(players){
  L.colorMap.clear();
  players.forEach((name, idx)=>{
    const col = PLAYER_PALETTE[idx % PLAYER_PALETTE.length];
    L.colorMap.set(name, { label: name === L.me ? "You" : name, color: col });
  });
}
function ownerMeta(name){ return L.colorMap.get(name) || {label:name, color:"#999"}; }
function ownerColor(name){ return ownerMeta(name).color; }

/* ========= Game Builders (host) ========= */
function makeCard(color,val){ return { id: uid(), color, val }; }
function baseDeck(){
  const d=[]; for(const c of COLORS){ for(let v=1; v<=5; v++) d.push(makeCard(c,v)); }
  for(let i=d.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [d[i],d[j]]=[d[j],d[i]]; }
  return d;
}
function buildStoreDeck(){
  const d=[]; for(let k=0;k<4;k++){ for(const c of COLORS){ for(let v=6; v<=10; v++) d.push(makeCard(c,v)); } }
  for(let i=d.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [d[i],d[j]]=[d[j],d[i]]; }
  return d;
}
function refillStore(G){ while(G.storeVis.length < 5 && G.storeDeck.length>0) G.storeVis.push(G.storeDeck.pop()); }
function newGameDoc(host, players){
  const P = {};
  players.forEach(name => {
    P[name] = { name, alive: true, health: 100, maxHealth: 100, gold: 0, deck: baseDeck(), discard: [], viewIndex: 0, reshuffleAt: 0 };
  });
  const G = {
    type:"dutchblitz", host, players, status:"playing", winner:null,
    piles: [], storeDeck: buildStoreDeck(), storeVis: [],
    tickEndsAt: nowMs() + 10000, awarded:false,
    createdAt: serverTimestamp(), updatedAt: serverTimestamp()
  };
  refillStore(G); return {G,P};
}

/* ========= Derived ========= */
function handCard(G, P, who){ const pl=P[who]; if(!pl) return null; if(pl.viewIndex>=pl.deck.length) return null; return pl.deck[pl.viewIndex]||null; }
function sumsFor(G,P,who){
  let atk=0, heal=0, ward=0, gold=0;
  for(const pile of G.piles){
    if(pile.owner !== who) continue;
    const v=pile.topVal;
    if(pile.color==='orange') atk+=v;
    else if(pile.color==='green') heal+=v;
    else if(pile.color==='blue') ward+=v;
    else if(pile.color==='yellow') gold+=v;
  }
  return {atk,heal,ward,gold};
}
function livingPlayers(G,P){ return G.players.filter(n => P[n]?.alive); }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }

/* ========= Host: apply action ========= */
async function hostApplyAction(act){
  await runTransaction(db, async (tx) => {
    const snap = await tx.get(gameRef);
    if(!snap.exists()) return;
    const root = snap.data();
    if(root.status !== "playing") return;

    const G = { ...root };
    const P = { ...root.P };
    G.players = [...G.players];
    G.piles   = G.piles.map(p=>({...p, cards:[...p.cards]}));
    G.storeDeck = [...G.storeDeck];
    G.storeVis  = [...G.storeVis];
    for(const k of Object.keys(P)){ const pl=P[k]; P[k] = { ...pl, deck:[...pl.deck], discard:[...pl.discard] }; }

    const who = act.by, me = P[who]; if(!me?.alive) return;
    const tnow = nowMs();

    if(act.type === "flip"){
      if(!(me.reshuffleAt && tnow < me.reshuffleAt)){
        me.viewIndex += 3;
        if(me.viewIndex >= me.deck.length) me.reshuffleAt = tnow + 3000;
      }
    }
    else if(act.type === "start"){
      const c = handCard(G,P,who); if(!c || c.id!==act.cardId || c.val!==1) return;
      me.deck.splice(me.viewIndex,1);
      G.piles.push({ id:uid(), color:c.color, topVal:c.val, owner:who, cards:[{player:who,card:c}] });
      if(c.color==="yellow") me.gold+=c.val;
      if(me.viewIndex>=me.deck.length) me.reshuffleAt = tnow + 3000;
    }
    else if(act.type === "playOn"){
      const c = handCard(G,P,who); if(!c || c.id!==act.cardId) return;
      const pile = G.piles.find(p=>p.id===act.pileId); if(!pile) return;
      if(pile.color!==c.color || pile.topVal!==c.val-1) return;
      pile.cards.push({player:who, card:c}); pile.topVal=c.val; pile.owner=who;
      me.deck.splice(me.viewIndex,1);
      if(c.color==="yellow") me.gold+=c.val;

      if(c.val===10){
        for(const n of G.players){
          const t=P[n]; if(!t?.alive) continue;
          const s=sumsFor(G,P,n), eff=Math.max(0, 10-(s.ward||0));
          t.health=Math.max(0, t.health-eff); if(t.health===0) t.alive=false;
        }
        for(const entry of pile.cards){ const o=P[entry.player]; if(o) o.discard.push(entry.card); }
        G.piles=G.piles.filter(p=>p.id!==pile.id);
      }
      if(me.viewIndex>=me.deck.length) me.reshuffleAt = tnow + 3000;
    }
    else if(act.type === "buy"){
      const card=G.storeVis.find(c=>c.id===act.cardId); if(!card) return;
      if(me.gold<card.val) return; me.gold-=card.val; me.discard.push(card);
      const idx = G.storeVis.findIndex(c=>c.id===card.id);
      if(idx>=0) G.storeVis.splice(idx,1);
      while(G.storeVis.length<5 && G.storeDeck.length>0) G.storeVis.push(G.storeDeck.pop());
    }

    // resolve due reshuffles
    for(const n of G.players){
      const p=P[n];
      if(p.reshuffleAt && tnow>=p.reshuffleAt){
        p.deck = shuffle(p.deck.concat(p.discard.splice(0)));
        p.viewIndex=0; p.reshuffleAt=0;
      }
    }

    const aliveList = G.players.filter(n=>P[n]?.alive);
    if(aliveList.length<=1){ G.status="finished"; G.winner=aliveList[0]||null; }

    G.updatedAt = serverTimestamp();
    await tx.update(gameRef, { ...G, P });
  });
}

/* ========= Host: 10s tick ========= */
async function hostTickIfNeeded(){
  await runTransaction(db, async (tx) => {
    const snap = await tx.get(gameRef);
    if(!snap.exists()) return; const root=snap.data();
    if(root.status!=="playing") return;
    const tnow=nowMs(); if(tnow<root.tickEndsAt) return;

    const G={...root}, P={...root.P}; G.piles=G.piles.map(p=>({...p, cards:[...p.cards]}));
    const alive=livingPlayers(G,P);
    const sums=new Map(alive.map(n=>[n, sumsFor(G,P,n)]));

    const atkBy=new Map();
    for(const n of alive){
      const p=P[n], s=sums.get(n)||{atk:0,heal:0,ward:0,gold:0};
      p.health = clamp(p.health+(s.heal||0), 0, p.maxHealth);
      p.gold   = (p.gold||0)+(s.gold||0);
      atkBy.set(n, s.atk||0);
    }
    for(const n of alive){
      const p=P[n]; const ward=(sums.get(n)?.ward)||0;
      let sumA=0; for(const [pid,A] of atkBy){ if(pid!==n) sumA+=A; }
      const eff=Math.max(0,sumA-ward); if(eff>0){ p.health=Math.max(0,p.health-eff); if(p.health===0) p.alive=false; }
    }
    for(const n of G.players){
      const p=P[n]; if(p.reshuffleAt && nowMs()>=p.reshuffleAt){
        p.deck=shuffle(p.deck.concat(p.discard.splice(0))); p.viewIndex=0; p.reshuffleAt=0;
      }
    }
    const aliveAfter=livingPlayers(G,P);
    if(aliveAfter.length<=1){ G.status="finished"; G.winner=aliveAfter[0]||null; }

    G.tickEndsAt = nowMs()+10000; G.updatedAt=serverTimestamp();
    await tx.update(gameRef, { ...G, P });
  });
}

/* ========= Host action queue (guarded) ========= */
function startHostActionPump(){
  if (window.__DB_ACTIONS_UNSUB) { return; }
  const qy=query(actionsCol, orderBy("ts","asc"));
  const unsub = onSnapshot(qy, async (qs)=>{
    for(const d of qs.docChanges()){
      if(d.type!=="added") continue;
      const act=d.doc.data();
      await hostApplyAction(act);
      await deleteDoc(doc(db, "dutchblitz_games", gameId, "actions", d.doc.id));
    }
  });
  window.__DB_ACTIONS_UNSUB = unsub;
}

/* ========= UI helpers ========= */
function fitPilesToBand(){
  const wrap=document.getElementById("centerBand"); const grid=document.getElementById("piles");
  if(!wrap || !grid || !L.game) return;
  const n=(L.game.piles?.length)||1;
  const wrapW=wrap.clientWidth, wrapH=wrap.clientHeight;
  const maxSize = 96, minSize = 44, gap = 8;
  let size=Math.min(maxSize, Math.max(minSize, Math.floor(Math.sqrt((wrapW*wrapH)/(n*1.25)) )));
  function layoutFor(sz){
    const cols = Math.max(1, Math.floor((wrapW + gap) / (sz + gap)));
    const rows = Math.ceil(n / cols);
    const height = rows * (sz + gap) - gap;
    return {cols, rows, height};
  }
  let Lp = layoutFor(size);
  while (Lp.height > wrapH && size > minSize){ size -= 2; Lp = layoutFor(size); }
  document.documentElement.style.setProperty("--pileSize", size + "px");
  document.documentElement.style.setProperty("--pileGap", gap + "px");
  grid.style.gridTemplateColumns = `repeat(${Lp.cols}, var(--pileSize))`;
}

function render(){
  const root=L.game; if(!root) return; const me=root.P[L.me];
  const s=(who=>sumsFor(root, root.P, who));

  // HUD
  document.getElementById("youHP").textContent   = Math.round(me.health);
  document.getElementById("youGold").textContent = me.gold;
  document.getElementById("gold2").textContent   = me.gold;
  document.getElementById("youWard").textContent = s(L.me).ward;
  document.getElementById("youAtk").textContent  = s(L.me).atk;
  document.getElementById("youHeal").textContent = s(L.me).heal;

  const left = Math.max(0, root.tickEndsAt - nowMs());
  document.getElementById("tickIn").textContent = (left/1000).toFixed(1);
  document.getElementById("tickBar").style.width = (100 - Math.min(100, (left/100))) + "%";

  // Players mini
  const mini=document.getElementById("playersMini"); mini.innerHTML="";
  root.players.forEach(name=>{
    const p=root.P[name], m=ownerMeta(name);
    const chip=document.createElement("div");
    chip.className="chip";
    chip.innerHTML=`<span class="dot" style="background:${m.color}"></span>${m.label}&nbsp;<b>${Math.round(p.health)}</b>`;
    mini.appendChild(chip);
  });

  // Center piles
  const grid=document.getElementById("piles"); grid.innerHTML="";
  root.piles.forEach(pile=>{
    const top=pile.cards[pile.cards.length-1].card;
    const m=ownerMeta(pile.owner);
    const tile=document.createElement("div");
    tile.className=`tile ${CCLS[top.color]}`;
    const sel=L.selectedCardId && handCard(root, root.P, L.me);
    const selected=sel && sel.id===L.selectedCardId ? sel : null;
    if(selected && selected.color===pile.color && pile.topVal===selected.val-1) tile.classList.add("valid");
    tile.innerHTML = `<span style="font-weight:900">${top.val}</span>&nbsp;<span>${ICON[top.color]}</span><span class="own">${m.label}</span>`;
    tile.style.borderColor = m.color;
    tile.style.boxShadow = `0 0 0 4px ${m.color}, 0 6px 16px rgba(0,0,0,.3)`;
    tile.addEventListener("pointerup",(e)=>{
      e.preventDefault();
      if(!selected){ return; }
      sendAction("playOn", { pileId:pile.id, cardId:selected.id });
      L.selectedCardId=null;
    });
    grid.appendChild(tile);
  });
  fitPilesToBand();

  // Hand card
  const hand=document.getElementById("hand");
  const c=handCard(root, root.P, L.me);
  if(c){
    const myColor=ownerColor(L.me);
    hand.className=`rect ${CCLS[c.color]}${L.selectedCardId===c.id?' sel':''}`;
    hand.style.opacity = "1"; hand.style.pointerEvents="auto";
    hand.style.borderColor = myColor;
    hand.style.boxShadow = `0 0 0 4px ${myColor}, 0 5px 18px rgba(0,0,0,.26)`;
    hand.innerHTML=`<span style="font-weight:900;font-size:22px">${c.val}</span><span style="font-size:22px">${ICON[c.color]}</span>`;
    hand.onclick = ()=>{
      if(c.val===1){ sendAction("start", { cardId:c.id }); L.selectedCardId=null; }
      else { L.selectedCardId = (L.selectedCardId===c.id) ? null : c.id; render(); }
    };
  } else {
    hand.className="rect";
    hand.style.opacity=".4"; hand.style.pointerEvents="none";
    hand.innerHTML="‚Äî";
  }

  // Store ‚Äî exactly 3
  const store=document.getElementById("storeItems"); store.innerHTML="";
  const visibleCards = root.storeVis.slice(0, 3);
  visibleCards.forEach((card)=>{
    const col=document.createElement("div"); col.className="storeCol";
    const btn=document.createElement("button"); btn.className="btn"; btn.textContent=`Buy $${card.val}`;
    if(me.gold < card.val || !me.alive) btn.disabled=true;
    btn.addEventListener("pointerup",(e)=>{ e.preventDefault(); sendAction("buy", { cardId: card.id }); });
    col.appendChild(btn);
    const r=document.createElement("div"); r.className=`rect ${CCLS[card.color]}`;
    r.innerHTML=`<span style="font-weight:900;font-size:18px">${card.val}</span><span style="font-size:18px">${ICON[card.color]}</span>`;
    r.style.borderColor = "#334155";
    r.style.boxShadow = "0 0 0 3px rgba(148,163,184,.35)";
    col.appendChild(r);
    store.appendChild(col);
  });

  // Counts
  document.getElementById("deckCount").textContent    = root.P[L.me].deck.length;
  document.getElementById("discardCount").textContent = root.P[L.me].discard.length;

  // Fit entire stage to the viewport (final step!)
  fitToViewport();

  // Game over
  if(root.status === "finished"){
    const winner = root.winner;
    const title = winner ? `üèÜ Winner: ${ownerMeta(winner).label}` : "Game Over";
    showOverlay(title, "Returning to lobby will keep your username.", [
      { label:"Return to Lobby", onClick: ()=> window.location.href = `${HUB_URL}?username=${encodeURIComponent(L.me)}` }
    ]);
  } else {
    document.getElementById("overlay").style.display="none";
  }
}

/* ========= Client actions ========= */
async function sendAction(type, payload={}){
  const root=L.game; if(!root || root.status!=="playing") return;
  const me=root.P[L.me]; if(!me?.alive) return;
  if(type==="flip" && me.reshuffleAt && nowMs()<me.reshuffleAt){ return; }
  await addDoc(actionsCol, { by:L.me, type, ...payload, ts: serverTimestamp() });
}

/* ========= Overlay helpers ========= */
function showOverlay(title, msg, buttons=[{label:"OK", onClick: ()=> hideOverlay()}]){
  document.getElementById("ovTitle").textContent=title;
  document.getElementById("ovMsg").textContent=msg||"";
  const btns=document.getElementById("ovBtns"); btns.innerHTML="";
  buttons.forEach(b=>{
    const el=document.createElement("button");
    el.className="btn"; el.textContent=b.label;
    el.addEventListener("pointerup", ()=>{ b.onClick?.(); });
    btns.appendChild(el);
  });
  document.getElementById("overlay").style.display="flex";
}
function hideOverlay(){ document.getElementById("overlay").style.display="none"; }

/* ========= Fullscreen ========= */
function isFullscreen(){ return document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement; }
async function enterFullscreen(el){
  const target = el || document.documentElement;
  const req = target.requestFullscreen || target.webkitRequestFullscreen || target.msRequestFullscreen;
  if(req) await req.call(target);
}
async function exitFullscreen(){
  const ex = document.exitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen;
  if(ex) await ex.call(document);
}
async function toggleFullscreen(){ if(isFullscreen()) await exitFullscreen(); else await enterFullscreen(document.documentElement); }

/* ========= Boot ========= */
async function boot(){
  // lobby ‚Üí players/host
  const lSnap = await getDoc(lobbyRef);
  if(!lSnap.exists()){ alert("Lobby not found."); return; }
  const lobby = lSnap.data();
  const players = (lobby.players || []).slice(0,4);
  const host = lobby.host || players[0];
  L.isHost = (username === host);
  computeColorMap(players);

  // create game if absent
  const gSnap = await getDoc(gameRef);
  if(L.isHost && !gSnap.exists()){
    const {G,P} = newGameDoc(host, players);
    await setDoc(gameRef, { ...G, P });
  }

  // subscribe
  onSnapshot(gameRef, async (snap)=>{
    if(!snap.exists()) return;
    L.game=snap.data();

    // award once
    if(L.isHost && L.game.status==="finished" && L.game.winner && !L.game.awarded){
      await runTransaction(db, async (tx)=>{
        const cur = await tx.get(gameRef); const root=cur.data();
        if(root.awarded) return;
        const wRef = doc(db, "users", L.game.winner);
        const wSnap = await tx.get(wRef);
        if(wSnap.exists()){
          const prev = wSnap.data().wins || 0;
          tx.update(wRef, { wins: prev + 1 });
        } else {
          tx.set(wRef, { wins: 1 });
        }
        tx.update(gameRef, { awarded: true, updatedAt: serverTimestamp() });
      });
    }
    render();
  });

  // host pumps
  if(L.isHost){
    startHostActionPump();
    setInterval(hostTickIfNeeded, 250);
  }

  // controls
  document.getElementById("flipBtn").addEventListener("pointerup", (e)=>{ e.preventDefault(); sendAction("flip"); });
  window.addEventListener("keydown", (e)=>{ if(e.key===" "){ e.preventDefault(); sendAction("flip"); } });

  // fullscreen
  const fsBtn = document.getElementById("fsBtn");
  if(fsBtn){
    fsBtn.addEventListener("click", toggleFullscreen);
    document.addEventListener("fullscreenchange", ()=>{
      const fs = !!isFullscreen();
      fsBtn.textContent = fs ? "‚õ∂ Exit" : "‚õ∂ FS";
      fsBtn.setAttribute("aria-pressed", String(fs));
      fitToViewport();
    });
  }

  // Refits
  new ResizeObserver(()=>{ fitPilesToBand(); fitToViewport(); }).observe(document.getElementById("centerBand"));
  new ResizeObserver(()=>{ fitToViewport(); }).observe(document.getElementById("stage"));

  // First fit
  fitToViewport();
}
boot();
</script>
</body>
</html>




