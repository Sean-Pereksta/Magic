<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Dutch Blitz ‚Äî Arena (Realtime, One-Screen Mobile)</title>
<style>
  :root{
    --bg:#0b1014; --panel:#0e1726; --ink:#e6efff; --muted:#a8b3c7; --edge:#26334f; --accent:#8b5cf6;
    --y:#facc15; --o:#fb923c; --g:#22c55e; --b:#60a5fa;
    --gap: clamp(6px, 1vw, 12px);
    --cardW: clamp(138px, 32vw, 220px);
    --cardH: clamp(66px, 16vw, 98px);
    --radius: 12px; --maxw: 1200px;

    /* Piles band */
    --pileSize: 74px; --pileGap: 8px; --pilesHeight: 290px;

    /* Player swatches (dots only; outlines set inline) */
    --own-you:#ef4444; --own-a:#22d3ee; --own-b:#f59e0b; --own-c:#8b5cf6;
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;background:var(--bg);color:var(--ink);
    font-family:system-ui,Segoe UI,Roboto,Arial;
    -webkit-tap-highlight-color: transparent;
  }

  /* ===== Base Layout ===== */
  #app{max-width:var(--maxw);margin:0 auto;display:grid;grid-template-rows:1fr;min-height:100vh;padding:var(--gap);gap:var(--gap)}
  #board{display:grid;gap:var(--gap);align-items:start}
  @media (min-width: 920px){
    #board{grid-template-columns: 1fr 1.2fr 1fr; grid-template-areas:
      "left center right"
      "you  center right";}
  }
  @media (max-width: 919.9px){
    #board{grid-template-columns: 1fr; grid-template-areas:"center" "you" "right";}
  }

  section{background:var(--panel);border:1px solid #1a243a;border-radius:var(--radius);padding:10px}
  #left{grid-area:left} #center{grid-area:center} #right{grid-area:right}
  #you{grid-area:you;background:linear-gradient(180deg,#131b2c,#0e172a);border-color:#3b1116; box-shadow:0 0 0 3px rgba(239,68,68,.28) inset}

  h2,h3{margin:0 0 6px 0;font-weight:800;letter-spacing:.2px}
  .legend{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;color:#c6d0e0;font-size:12px;margin:6px 0}
  .wrap{display:flex;flex-wrap:wrap;gap:10px;justify-content:center}

  /* ===== HUD ===== */
  #hud{
    position:sticky; top:0; z-index:5;
    display:flex; flex-direction:column; gap:8px; align-items:center; justify-content:center;
    margin:0 auto 6px auto; padding:10px 12px; max-width:min(100%, 920px);
    background:linear-gradient(180deg, rgba(15,23,42,.9), rgba(14,21,35,.9));
    border:1px solid #24324c; border-radius:12px; box-shadow:0 8px 24px rgba(0,0,0,.34);
    backdrop-filter: blur(3px);
  }
  .hudRow{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:center}
  .stat{
    display:flex;align-items:center;gap:6px;
    background:#0c1423;border:1px solid #1d2840;border-radius:10px;padding:6px 10px;min-width:92px;justify-content:center
  }
  .stat .val{font-weight:900;font-size:18px}
  .stat .lbl{font-size:11px;color:#a9b6cc;letter-spacing:.3px;text-transform:uppercase}
  .timerbar{height:8px;background:#0c1423;border:1px solid #17223a;border-radius:999px;overflow:hidden;min-width:210px;width:100%}
  .timerbar>div{height:100%;background:var(--accent);width:0%}

  /* Players (desktop left card list) */
  #playersStatus{
    display:grid; gap:8px; width:100%; margin-top:4px;
    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
  }
  .pStatus{ background:#0c1423;border:1px solid #1d2840;border-radius:10px;padding:8px }
  .pTop{display:flex;justify-content:space-between;align-items:center;margin-bottom:4px}
  .pName{font-weight:900; display:flex; align-items:center; gap:8px}
  .dot{width:12px;height:12px;border-radius:50%}
  .hpBig{font-size:18px;font-weight:900}
  .pSmall{display:flex;gap:8px;flex-wrap:wrap;color:#b8c3d8;font-size:12px}

  /* Players Mini (mobile HUD chips) */
  .miniRow{display:none}
  .chip{
    display:inline-flex; align-items:center; gap:6px;
    padding:4px 8px; border:1px solid #1d2840; border-radius:999px; background:#0c1423; font-size:12px;
    white-space:nowrap;
  }

  /* ===== Hand card (owner outline inline) ===== */
  .rect{
    width:var(--cardW); height:var(--cardH); border-radius:12px; border:2px solid var(--edge);
    display:flex; align-items:center; justify-content:space-between; padding:0 12px;
    color:#0b0b0b; font-weight:900; box-shadow:0 5px 18px rgba(0,0,0,.26);
    user-select:none; -webkit-user-select:none; touch-action:manipulation; cursor:pointer;
    outline-offset:-6px; min-height:44px;
  }
  .rect.sel{ outline:4px solid #ef4444; }

  .c-yellow{background:linear-gradient(135deg,var(--y),#fee780);border-color:#eab308}
  .c-orange{background:linear-gradient(135deg,var(--o),#fed7aa);border-color:#fb923c}
  .c-green{background:linear-gradient(135deg,var(--g),#bbf7d0);border-color:#22c55e}
  .c-blue{background:linear-gradient(135deg,var(--b),#bae6fd);border-color:#60a5fa}

  /* ===== Center piles ===== */
  #center{display:flex;flex-direction:column;min-height:0}
  #pilesWrap{
    flex:1; /* TAKE remaining space */
    overflow:hidden; border:1px dashed #20304f; border-radius:10px; padding:8px;
    background:#0e1626; min-height:140px;
  }
  #piles{
    display:grid;
    grid-auto-rows:var(--pileSize);
    grid-template-columns:repeat(10, var(--pileSize));
    gap:var(--pileGap);
    place-content:start center;
  }
  .tile{
    width:var(--pileSize); height:var(--pileSize);
    border:2px solid var(--edge); border-radius:12px;
    display:flex; align-items:center; justify-content:center; gap:2px;
    font-weight:900; color:#0b0b0b; box-shadow:0 6px 16px rgba(0,0,0,.28);
    cursor:pointer; touch-action:manipulation; user-select:none;
    position:relative; outline-offset:-5px; min-height:44px;
  }
  .tile .v, .tile .ico, .tile .own { pointer-events:none; }
  .tile.valid{ outline:6px solid #84cc16; box-shadow:0 0 0 6px rgba(132,204,22,.35), 0 12px 22px rgba(0,0,0,.3); }
  .own{
    position:absolute; bottom:2px; right:4px; font-size:11px;
    color:#0b1014; background:rgba(255,255,255,.92); padding:2px 8px; border-radius:999px;
    font-weight:800;
  }

  /* ===== Store / buttons ===== */
  .storeCol{display:flex;flex-direction:column;align-items:center;gap:6px}
  .btn{
    padding:8px 10px;border-radius:10px;border:1px solid #223252;background:#13223a;color:#e6efff;cursor:pointer;font-weight:800;text-align:center;touch-action:manipulation;
    min-height:38px;
  }
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .log{margin-top:6px;text-align:center;color:#cbd5e1;font-size:12px}

  /* ===== Overlay ===== */
  .overlay{position:fixed;inset:0;background:rgba(0,0,0,.65);display:none;align-items:center;justify-content:center;z-index:40}
  .dialog{background:#0f172a;border:1px solid #243754;border-radius:16px;padding:16px;min-width:min(720px,95vw);max-width:95vw;max-height:92vh;overflow:auto;box-shadow:0 18px 44px rgba(0,0,0,.45)}
  .dialog .big{font-size:24px;font-weight:900;margin-bottom:6px}
  .dialog .sub{font-size:14px;color:#c2cee3;margin-bottom:10px}
  .dialog .actions{display:flex;gap:10px;justify-content:center;margin-top:8px}

  /* ===== One-screen Mobile Mode ===== */
  @media (max-width:700px){
    html,body{ height:100svh; overflow:hidden; }
    #app{ min-height:100svh; }
    #board{
      height:100%; 
      grid-template-rows: auto 1fr auto; /* HUD in #center (auto), piles flex (1fr), you+store auto stacked below via #you and #right */
    }

    /* hide desktop players panel */
    #left{ display:none; }

    /* HUD ultra-compact: only HP, Gold, Tick + chips */
    .stat.hp, .stat.gold, .stat.tick{ display:flex; }
    .stat.atk, .stat.ward{ display:none; }

    /* show player mini chips in HUD */
    .miniRow{ display:flex; gap:6px; flex-wrap:nowrap; overflow:hidden; }

    /* shrink piles & cards slightly */
    :root{
      --pileSize: 62px;
      --pilesHeight: auto;
      --cardW: clamp(128px, 44vw, 200px);
      --cardH: clamp(60px, 20vw, 90px);
    }

    /* hand: hide extra legends, stacks, log */
    .legend.compact-hide, .stacks, #log{ display:none !important; }

    /* store: cap to 3 items; smaller visuals */
    #right .wrap{ gap:6px; }
    #storeRow .storeCol{ transform: scale(.9); transform-origin: center; }
  }

  @supports (height: 100svh){ body{ min-height: 100svh; } }
</style>
</head>
<body>
<div id="app">
  <div id="board">
    <!-- Desktop-only players list -->
    <section id="left">
      <h2>Players</h2>
      <div id="playersStatus"></div>
    </section>

    <section id="center">
      <!-- HUD lives here so it can be auto-height on mobile -->
      <div id="hud" aria-live="polite">
        <div class="hudRow">
          <div class="stat hp"><span class="lbl">HP</span><span class="val" id="youHP">100</span></div>
          <div class="stat atk"><span class="lbl">Attack</span><span class="val" id="youAtk">0</span></div>
          <div class="stat ward"><span class="lbl">Ward</span><span class="val" id="youWard">0</span></div>
          <div class="stat gold"><span class="lbl">Gold</span><span class="val" id="youGold">0</span></div>
          <div class="stat tick"><span class="lbl">Tick</span><span class="val" id="tickIn">10.0</span></div>
        </div>
        <div class="timerbar"><div id="tickBar"></div></div>
        <!-- Mini chips (mobile only) -->
        <div id="playersMini" class="miniRow"></div>
        <div class="legend compact-hide">üí∞ Yellow = Gold ‚Ä¢ ‚öîÔ∏è Orange = Damage ‚Ä¢ ‚ù§Ô∏è Green = Heal ‚Ä¢ üõ°Ô∏è Blue = Ward</div>
      </div>

      <h3 style="text-align:center;margin:2px 0 6px 0">Center Piles</h3>
      <div id="pilesWrap"><div id="piles"></div></div>
    </section>

    <section id="you">
      <div class="wrap" style="justify-content:center">
        <button class="btn" id="flipBtn">üîÅ Flip</button>
        <button class="btn" id="fsBtn" title="Toggle Fullscreen" aria-pressed="false">‚õ∂ FS</button>
      </div>
      <div id="hand" class="wrap"></div>
      <div class="stacks" style="margin-top:6px">
        <div class="stack"><span>Deck</span><div id="deckCount" class="count">0</div></div>
        <div class="stack"><span>Discard</span><div id="discardCount" class="count">0</div></div>
      </div>
      <div id="log" class="log">Last action: ‚Äî</div>
    </section>

    <section id="right">
      <div class="wrap" style="justify-content:space-between;align-items:center">
        <h3>Store</h3>
        <span class="legend">Gold: <b id="gold2">0</b></span>
      </div>
      <div id="storeRow" class="wrap"></div>
    </section>
  </div>
</div>

<!-- Overlay -->
<div id="overlay" class="overlay" aria-hidden="true">
  <div class="dialog">
    <div id="ovTitle" class="big"></div>
    <div id="ovMsg" class="sub"></div>
    <div id="ovBtns" class="actions"></div>
  </div>
</div>

<script type="module">
/* ========= Firebase ========= */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, onSnapshot,
  collection, addDoc, serverTimestamp, runTransaction,
  query, orderBy, deleteDoc
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);

/* ========= URL / Routing ========= */
const url   = new URL(window.location.href);
const gameId   = url.searchParams.get("gameId");
const username = (url.searchParams.get("username")||"").trim();
const HUB_URL = "/"; // change if needed

if(!gameId || !username){ alert("Missing gameId or username in URL."); }

/* ========= Utils ========= */
const COLORS=["yellow","orange","green","blue"];
const ICON={yellow:"üí∞",orange:"‚öîÔ∏è",green:"‚ù§Ô∏è",blue:"üõ°Ô∏è"};
const CCLS={yellow:"c-yellow",orange:"c-orange",green:"c-green",blue:"c-blue"};
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
const uid=(()=>{let i=1;return()=> "id"+(i++)})();
const nowMs=()=>Date.now();
const isPhone = ()=> matchMedia("(max-width:700px)").matches;

const $=sel=>document.querySelector(sel);
function showError(msg){ $("#log").textContent = "Last action: " + msg; }

/* ========= Firestore refs ========= */
const lobbyRef = doc(db, "lobbies", gameId);
const gameRef  = doc(db, "dutchblitz_games", gameId);
const actionsCol = collection(db, "dutchblitz_games", gameId, "actions");

/* ========= Local ========= */
let L = {
  me: username,
  isHost: false,
  game: null,
  selectedCardId: null,
  colorMap: new Map()
};

/* ========= Player colors (join-order deterministic) ========= */
const PLAYER_PALETTE = ["#ef4444", "#22d3ee", "#f59e0b", "#8b5cf6"];
const DOT_CLASSES = ["dot-you","dot-a","dot-b","dot-c"];
function computeColorMap(players){
  L.colorMap.clear();
  players.forEach((name, idx)=>{
    const col = PLAYER_PALETTE[idx % PLAYER_PALETTE.length];
    L.colorMap.set(name, {
      label: name === L.me ? "You" : name,
      color: col,
      dot: DOT_CLASSES[idx] || DOT_CLASSES[DOT_CLASSES.length-1]
    });
  });
}
function ownerMeta(name){ return L.colorMap.get(name) || {label:name, color:"#999", dot:""}; }
function ownerColor(name){ return ownerMeta(name).color; }

/* ========= Game Builders (host) ========= */
function makeCard(color,val){ return { id: uid(), color, val }; }
function baseDeck(){
  const d=[]; for(const c of COLORS){ for(let v=1; v<=5; v++) d.push(makeCard(c,v)); }
  for(let i=d.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [d[i],d[j]]=[d[j],d[i]]; }
  return d;
}
function buildStoreDeck(){
  const d=[]; for(let k=0;k<4;k++){ for(const c of COLORS){ for(let v=6; v<=10; v++) d.push(makeCard(c,v)); } }
  for(let i=d.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [d[i],d[j]]=[d[j],d[i]]; }
  return d;
}
function refillStore(G){ while(G.storeVis.length < 5 && G.storeDeck.length>0) G.storeVis.push(G.storeDeck.pop()); }
function newGameDoc(host, players){
  const P = {};
  players.forEach(name => {
    P[name] = { name, alive: true, health: 100, maxHealth: 100, gold: 0, deck: baseDeck(), discard: [], viewIndex: 0, reshuffleAt: 0 };
  });
  const G = {
    type:"dutchblitz", host, players, status:"playing", winner:null,
    piles: [], storeDeck: buildStoreDeck(), storeVis: [],
    tickEndsAt: nowMs() + 10000, awarded:false,
    createdAt: serverTimestamp(), updatedAt: serverTimestamp()
  };
  refillStore(G); return {G,P};
}

/* ========= Derived ========= */
function handCard(G, P, who){ const pl=P[who]; if(!pl) return null; if(pl.viewIndex>=pl.deck.length) return null; return pl.deck[pl.viewIndex]||null; }
function sumsFor(G,P,who){
  let atk=0, heal=0, ward=0, gold=0;
  for(const pile of G.piles){
    if(pile.owner !== who) continue;
    const v=pile.topVal;
    if(pile.color==='orange') atk+=v;
    else if(pile.color==='green') heal+=v;
    else if(pile.color==='blue') ward+=v;
    else if(pile.color==='yellow') gold+=v;
  }
  return {atk,heal,ward,gold};
}
function livingPlayers(G,P){ return G.players.filter(n => P[n]?.alive); }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }

/* ========= Host: apply action ========= */
async function hostApplyAction(act){
  await runTransaction(db, async (tx) => {
    const snap = await tx.get(gameRef);
    if(!snap.exists()) return;
    const root = snap.data();
    if(root.status !== "playing") return;

    const G = { ...root };
    const P = { ...root.P };
    G.players = [...G.players];
    G.piles   = G.piles.map(p=>({...p, cards:[...p.cards]}));
    G.storeDeck = [...G.storeDeck];
    G.storeVis  = [...G.storeVis];
    for(const k of Object.keys(P)){ const pl=P[k]; P[k] = { ...pl, deck:[...pl.deck], discard:[...pl.discard] }; }

    const who = act.by, me = P[who]; if(!me?.alive) return;
    const tnow = nowMs();

    if(act.type === "flip"){
      if(!(me.reshuffleAt && tnow < me.reshuffleAt)){
        me.viewIndex += 3;
        if(me.viewIndex >= me.deck.length) me.reshuffleAt = tnow + 3000;
      }
    }
    else if(act.type === "start"){
      const c = handCard(G,P,who); if(!c || c.id!==act.cardId || c.val!==1) return;
      me.deck.splice(me.viewIndex,1);
      G.piles.push({ id:uid(), color:c.color, topVal:c.val, owner:who, cards:[{player:who,card:c}] });
      if(c.color==="yellow") me.gold+=c.val;
      if(me.viewIndex>=me.deck.length) me.reshuffleAt = tnow + 3000;
    }
    else if(act.type === "playOn"){
      const c = handCard(G,P,who); if(!c || c.id!==act.cardId) return;
      const pile = G.piles.find(p=>p.id===act.pileId); if(!pile) return;
      if(pile.color!==c.color || pile.topVal!==c.val-1) return;
      pile.cards.push({player:who, card:c}); pile.topVal=c.val; pile.owner=who;
      me.deck.splice(me.viewIndex,1);
      if(c.color==="yellow") me.gold+=c.val;

      if(c.val===10){
        for(const n of G.players){
          const t=P[n]; if(!t?.alive) continue;
          const s=sumsFor(G,P,n), eff=Math.max(0, 10-(s.ward||0));
          t.health=Math.max(0, t.health-eff); if(t.health===0) t.alive=false;
        }
        for(const entry of pile.cards){ const o=P[entry.player]; if(o) o.discard.push(entry.card); }
        G.piles=G.piles.filter(p=>p.id!==pile.id);
      }
      if(me.viewIndex>=me.deck.length) me.reshuffleAt = tnow + 3000;
    }
    else if(act.type === "buy"){
      const idx=act.storeIndex|0; const card=G.storeVis[idx]; if(!card) return;
      if(me.gold<card.val) return; me.gold-=card.val; me.discard.push(card);
      G.storeVis.splice(idx,1); while(G.storeVis.length<5 && G.storeDeck.length>0) G.storeVis.push(G.storeDeck.pop());
    }

    // resolve due reshuffles
    for(const n of G.players){
      const p=P[n];
      if(p.reshuffleAt && tnow>=p.reshuffleAt){
        p.deck = shuffle(p.deck.concat(p.discard.splice(0)));
        p.viewIndex=0; p.reshuffleAt=0;
      }
    }

    const aliveList = G.players.filter(n=>P[n]?.alive);
    if(aliveList.length<=1){ G.status="finished"; G.winner=aliveList[0]||null; }

    G.updatedAt = serverTimestamp();
    await tx.update(gameRef, { ...G, P });
  });
}

/* ========= Host: 10s tick ========= */
async function hostTickIfNeeded(){
  await runTransaction(db, async (tx) => {
    const snap = await tx.get(gameRef);
    if(!snap.exists()) return; const root=snap.data();
    if(root.status!=="playing") return;
    const tnow=nowMs(); if(tnow<root.tickEndsAt) return;

    const G={...root}, P={...root.P}; G.piles=G.piles.map(p=>({...p, cards:[...p.cards]}));
    const alive=livingPlayers(G,P);
    const sums=new Map(alive.map(n=>[n, sumsFor(G,P,n)]));

    const atkBy=new Map();
    for(const n of alive){
      const p=P[n], s=sums.get(n)||{atk:0,heal:0,ward:0,gold:0};
      p.health = clamp(p.health+(s.heal||0), 0, p.maxHealth);
      p.gold   = (p.gold||0)+(s.gold||0);
      atkBy.set(n, s.atk||0);
    }
    for(const n of alive){
      const p=P[n]; const ward=(sums.get(n)?.ward)||0;
      let sumA=0; for(const [pid,A] of atkBy){ if(pid!==n) sumA+=A; }
      const eff=Math.max(0,sumA-ward); if(eff>0){ p.health=Math.max(0,p.health-eff); if(p.health===0) p.alive=false; }
    }
    for(const n of G.players){
      const p=P[n]; if(p.reshuffleAt && nowMs()>=p.reshuffleAt){
        p.deck=shuffle(p.deck.concat(p.discard.splice(0))); p.viewIndex=0; p.reshuffleAt=0;
      }
    }
    const aliveAfter=livingPlayers(G,P);
    if(aliveAfter.length<=1){ G.status="finished"; G.winner=aliveAfter[0]||null; }

    G.tickEndsAt = nowMs()+10000; G.updatedAt=serverTimestamp();
    await tx.update(gameRef, { ...G, P });
  });
}

/* ========= Host: action queue ========= */
let actionsUnsub=null;
function startHostActionPump(){
  if(actionsUnsub) actionsUnsub();
  const qy=query(actionsCol, orderBy("ts","asc"));
  actionsUnsub=onSnapshot(qy, async (qs)=>{
    for(const d of qs.docChanges()){
      if(d.type!=="added") continue;
      const act=d.doc.data();
      await hostApplyAction(act);
      await deleteDoc(doc(db, "dutchblitz_games", gameId, "actions", d.doc.id));
    }
  });
}

/* ========= Client: send action ========= */
async function sendAction(type, payload={}){
  const root=L.game; if(!root || root.status!=="playing") return;
  const me=root.P[L.me]; if(!me?.alive) return;
  if(type==="flip" && me.reshuffleAt && nowMs()<me.reshuffleAt){ showError("Reshuffling‚Ä¶"); return; }
  await addDoc(actionsCol, { by:L.me, type, ...payload, ts: serverTimestamp() });
}

/* ========= UI ========= */
function render(){
  const root=L.game; if(!root) return; const me=root.P[L.me];

  const s=sumsFor(root, root.P, L.me);
  $("#youHP").textContent   = Math.round(me.health);
  $("#youGold").textContent = me.gold; $("#gold2").textContent = me.gold;
  $("#youWard").textContent = s.ward; $("#youAtk").textContent = s.atk;

  const left = Math.max(0, root.tickEndsAt - nowMs());
  $("#tickIn").textContent = (left/1000).toFixed(1);
  $("#tickBar").style.width = (100 - Math.min(100, (left/100))) + "%";

  // Desktop players panel
  const wrap=$("#playersStatus"); wrap.innerHTML="";
  root.players.forEach(name=>{
    const p=root.P[name], m=ownerMeta(name);
    const card=document.createElement("div");
    card.className="pStatus";
    card.innerHTML=`
      <div class="pTop">
        <div class="pName"><i class="dot ${m.dot}" style="background:${m.color}"></i> ${m.label}</div>
        <div class="hpBig">${Math.round(p.health)}${p.alive?"":" (out)"}</div>
      </div>
      <div class="pSmall">
        <span>‚öîÔ∏è ${sumsFor(root, root.P, name).atk}</span>
        <span>üí∞ ${sumsFor(root, root.P, name).gold}</span>
        <span>üõ°Ô∏è ${sumsFor(root, root.P, name).ward}</span>
      </div>`;
    wrap.appendChild(card);
  });

  // Mobile players mini chips
  const mini=$("#playersMini"); mini.innerHTML="";
  if(isPhone()){
    root.players.forEach(name=>{
      const p=root.P[name], m=ownerMeta(name);
      const chip=document.createElement("div");
      chip.className="chip";
      chip.innerHTML=`<span class="dot" style="background:${m.color};width:10px;height:10px;border-radius:50%"></span>${m.label}&nbsp;<b>${Math.round(p.health)}</b>`;
      mini.appendChild(chip);
    });
  }

  // Center piles with owner-colored outlines
  const grid=$("#piles"); grid.innerHTML="";
  root.piles.forEach(pile=>{
    const top=pile.cards[pile.cards.length-1].card;
    const m=ownerMeta(pile.owner);
    const tile=document.createElement("div");
    tile.className=`tile ${CCLS[top.color]}`;
    const sel=L.selectedCardId && handCard(root, root.P, L.me);
    const selected=sel && sel.id===L.selectedCardId ? sel : null;
    if(selected && selected.color===pile.color && pile.topVal===selected.val-1) tile.classList.add("valid");
    tile.innerHTML = `<span class="v">${top.val}</span><span class="ico">${ICON[top.color]}</span><span class="own">${m.label}</span>`;
    tile.style.borderColor = m.color;
    tile.style.boxShadow = `0 0 0 4px ${m.color}, 0 6px 16px rgba(0,0,0,.3)`;
    tile.addEventListener("pointerup",(e)=>{
      e.preventDefault();
      if(!selected){ showError("Select a card first."); return; }
      sendAction("playOn", { pileId:pile.id, cardId:selected.id });
      L.selectedCardId=null;
    });
    grid.appendChild(tile);
  });
  fitPilesToBand();

  // Hand (your color outline)
  const hand=$("#hand"); hand.innerHTML="";
  const c=handCard(root, root.P, L.me);
  if(c){
    const myColor=ownerColor(L.me);
    const d=document.createElement("div");
    const isSel=(L.selectedCardId===c.id);
    d.className=`rect ${CCLS[c.color]}${isSel?' sel':''}`;
    d.innerHTML=`<span style="font-weight:900;font-size:22px">${c.val}</span><span style="font-size:22px">${ICON[c.color]}</span>`;
    d.style.borderColor = myColor;
    d.style.boxShadow = `0 0 0 4px ${myColor}, 0 5px 18px rgba(0,0,0,.26)`;
    d.addEventListener("pointerup",(e)=>{
      e.preventDefault();
      if(c.val===1){ sendAction("start", { cardId:c.id }); L.selectedCardId=null; }
      else { L.selectedCardId = isSel ? null : c.id; }
      render();
    });
    d.setAttribute("role","button"); d.tabIndex=0;
    hand.appendChild(d);
  } else {
    const slot=document.createElement("div"); slot.className="rect"; slot.style.opacity=".4"; slot.innerHTML="<span>‚Äî</span><span>‚Äî</span>";
    hand.appendChild(slot);
  }

  // Store ‚Äî cap to 3 items on phone, all on desktop
  const store=$("#storeRow"); store.innerHTML="";
  const visibleCards = isPhone() ? root.storeVis.slice(0,3) : root.storeVis;
  visibleCards.forEach((card, idx)=>{
    const globalIdx = isPhone() ? idx : idx; // identical since direct vis slice
    const col=document.createElement("div"); col.className="storeCol";
    const btn=document.createElement("button"); btn.className="btn"; btn.textContent=`Buy $${card.val}`;
    if(me.gold < card.val || !me.alive) btn.disabled=true;
    btn.addEventListener("pointerup",(e)=>{ e.preventDefault(); 
      // compute real index in storeVis when sliced
      const realIndex = isPhone() ? root.storeVis.findIndex(c=>c.id===card.id) : globalIdx;
      sendAction("buy", { storeIndex: realIndex }); 
    });
    col.appendChild(btn);
    const r=document.createElement("div"); r.className=`rect ${CCLS[card.color]}`;
    r.innerHTML=`<span style="font-weight:900;font-size:18px">${card.val}</span><span style="font-size:18px">${ICON[card.color]}</span>`;
    r.style.borderColor = "#334155";
    r.style.boxShadow = "0 0 0 3px rgba(148,163,184,.35)";
    col.appendChild(r);
    store.appendChild(col);
  });

  $("#deckCount").textContent    = root.P[L.me].deck.length;
  $("#discardCount").textContent = root.P[L.me].discard.length;

  if(root.status === "finished"){
    const winner = root.winner;
    const title = winner ? `üèÜ Winner: ${ownerMeta(winner).label}` : "Game Over";
    showOverlay(title, "Return to the lobby below.", [
      { label:"Return to Lobby", onClick: ()=> window.location.href = `${HUB_URL}?username=${encodeURIComponent(L.me)}` }
    ]);
  } else {
    hideOverlay();
  }
}

/* ===== Fit center to band (keeps piles in view) ===== */
function fitPilesToBand(){
  const wrap=$("#pilesWrap"); const grid=$("#piles");
  const n=(L.game?.piles?.length)||1;
  const wrapW=wrap.clientWidth, wrapH=wrap.clientHeight;

  const maxSize = isPhone()? 70 : 96, minSize = 48, gap = 8;
  let size=Math.min(maxSize, Math.max(minSize, Math.floor(Math.sqrt((wrapW*wrapH)/(n*1.25)) )));
  function layoutFor(sz){
    const cols = Math.max(1, Math.floor((wrapW + gap) / (sz + gap)));
    const rows = Math.ceil(n / cols);
    const height = rows * (sz + gap) - gap;
    return {cols, rows, height};
  }
  let Lp = layoutFor(size);
  while (Lp.height > wrapH && size > minSize){ size -= 2; Lp = layoutFor(size); }
  document.documentElement.style.setProperty("--pileSize", size + "px");
  document.documentElement.style.setProperty("--pileGap", gap + "px");
  grid.style.gridTemplateColumns = `repeat(${Lp.cols}, var(--pileSize))`;
}

/* ========= Overlay ========= */
function showOverlay(title, msg, buttons=[{label:"OK", onClick: ()=> hideOverlay()}]){
  $("#ovTitle").textContent=title;
  $("#ovMsg").textContent=msg||"";
  const btns=$("#ovBtns"); btns.innerHTML="";
  buttons.forEach(b=>{
    const el=document.createElement("button");
    el.className="btn"; el.textContent=b.label;
    el.addEventListener("pointerup", ()=>{ b.onClick?.(); });
    btns.appendChild(el);
  });
  $("#overlay").style.display="flex";
}
function hideOverlay(){ $("#overlay").style.display="none"; }

/* ========= Fullscreen ========= */
function isFullscreen(){ return document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement; }
async function enterFullscreen(el){
  const target = el || document.documentElement;
  const req = target.requestFullscreen || target.webkitRequestFullscreen || target.msRequestFullscreen;
  if(req) await req.call(target);
}
async function exitFullscreen(){
  const ex = document.exitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen;
  if(ex) await ex.call(document);
}
async function toggleFullscreen(){ if(isFullscreen()) await exitFullscreen(); else await enterFullscreen(document.documentElement); }

/* ========= Boot ========= */
let actionsUnsub=null;
async function boot(){
  // lobby ‚Üí players/host
  const lSnap = await getDoc(lobbyRef);
  if(!lSnap.exists()){ alert("Lobby not found."); return; }
  const lobby = lSnap.data();
  const players = (lobby.players || []).slice(0,4);
  const host = lobby.host || players[0];
  L.isHost = (username === host);
  computeColorMap(players);

  // create game if absent
  const gSnap = await getDoc(gameRef);
  if(L.isHost && !gSnap.exists()){
    const {G,P} = newGameDoc(host, players);
    await setDoc(gameRef, { ...G, P });
  }

  // subscribe
  onSnapshot(gameRef, async (snap)=>{
    if(!snap.exists()) return;
    const data=snap.data(); L.game=data;

    // award once
    if(L.isHost && data.status==="finished" && data.winner && !data.awarded){
      await runTransaction(db, async (tx)=>{
        const cur = await tx.get(gameRef); const root=cur.data();
        if(root.awarded) return;
        const wRef = doc(db, "users", data.winner);
        const wSnap = await tx.get(wRef);
        if(wSnap.exists()){
          const prev = wSnap.data().wins || 0;
          tx.update(wRef, { wins: prev + 1 });
        } else {
          tx.set(wRef, { wins: 1 });
        }
        tx.update(gameRef, { awarded: true, updatedAt: serverTimestamp() });
      });
    }
    render();
  });

  // host pumps
  if(L.isHost){
    startHostActionPump();
    setInterval(hostTickIfNeeded, 250);
  }

  // controls
  $("#flipBtn").addEventListener("pointerup", (e)=>{ e.preventDefault(); sendAction("flip"); });
  window.addEventListener("keydown", (e)=>{ if(e.key===" "){ e.preventDefault(); sendAction("flip"); } });

  // fullscreen
  const fsBtn = document.getElementById("fsBtn");
  if(fsBtn){
    fsBtn.addEventListener("click", toggleFullscreen);
    document.addEventListener("fullscreenchange", ()=>{
      const fs = !!isFullscreen();
      fsBtn.textContent = fs ? "‚õ∂ Exit" : "‚õ∂ FS";
      fsBtn.setAttribute("aria-pressed", String(fs));
      if(typeof fitPilesToBand === "function") fitPilesToBand();
    });
    const supportsFS = !!(document.documentElement.requestFullscreen || document.documentElement.webkitRequestFullscreen);
    const isiOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    if(!supportsFS && isiOS){
      fsBtn.disabled = false;
      fsBtn.title = "For true fullscreen on iOS: Share ‚Üí Add to Home Screen";
    }
  }

  // refit on size/orientation
  new ResizeObserver(fitPilesToBand).observe($("#pilesWrap"));
  addEventListener("orientationchange", ()=> setTimeout(fitPilesToBand, 100));
}
boot();
</script>
</body>
</html>


