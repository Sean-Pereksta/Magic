<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Dutch Blitz ‚Äî Arena (Realtime, Auto-Fit + Fixed Discard/Reshuffle)</title>
<style>
  :root{
    --bg:#020617; --panel:#020819; --ink:#e6efff; --muted:#a8b3c7; --edge:#26334f; --accent:#8b5cf6;
    --y:#facc15; --o:#fb923c; --g:#22c55e; --b:#60a5fa;
    --gap: clamp(6px, 1vw, 12px);
    --cardW: clamp(118px, 36vw, 220px);
    --cardH: clamp(58px, 18vw, 98px);
    --radius: 12px;

    --pileSize: 64px;
    --pileGap: 8px;
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  html, body{
    margin:0;
    background:
      radial-gradient(circle at top,#0b1120 0,#020617 55%);
    color:var(--ink);
    font-family:system-ui,Segoe UI,Roboto,Arial;
    -webkit-tap-highlight-color: transparent;
    overflow:hidden;
    overscroll-behavior:none;
  }

  /* ===== Auto-Fit Shell ===== */
  #fitRoot{
    position:fixed; inset:0;
    display:flex; align-items:center; justify-content:center;
    overflow:hidden;
  }
  #stageWrap{
    width:100%; height:100%;
    display:flex; align-items:center; justify-content:center;
    overflow:hidden;
    padding:4px;
  }
  #stage{ transform-origin: top center; will-change: transform; }

  /* ===== Stage layout (natural size; then auto-scaled) ===== */
  #screen{
    display:grid;
    grid-template-rows: auto auto 1fr auto;
    gap: var(--gap);
    padding: var(--gap);
    max-width: 820px;
    min-width: 320px;
  }

  /* ===== HUD ===== */
  #hud{
    display:flex; flex-direction:column; gap:8px; align-items:center; justify-content:center;
    padding:10px 12px;
    background:linear-gradient(180deg, rgba(15,23,42,.96), rgba(2,6,23,.96));
    border:1px solid #1f2937; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.6);
    backdrop-filter: blur(4px);
  }
  .hudRow{display:flex;gap:6px;flex-wrap:wrap;align-items:center;justify-content:center}
  .stat{
    display:inline-flex;align-items:center;gap:6px;
    background:#020617;border:1px solid #1e293b;border-radius:999px;
    padding:6px 10px; min-width:80px; justify-content:center;
  }
  .stat .val{font-weight:900;font-size:16px;line-height:1}
  .stat .lbl{font-size:10px;color:#a9b6cc;letter-spacing:.3px;text-transform:uppercase}
  .timerRow{display:flex; gap:10px; align-items:center; width:100%; max-width:560px}
  .timerbar{
    height:10px;background:#020617;border:1px solid #17223a;border-radius:999px;overflow:hidden;flex:1;
    box-shadow:0 0 0 1px rgba(15,23,42,.8),0 0 18px rgba(139,92,246,.25) inset;
  }
  .timerbar>div{
    height:100%;
    background:linear-gradient(90deg,#22c55e,#8b5cf6,#f97316);
    width:0%;
  }
  .tickLbl{font-weight:800; font-size:12px; opacity:.9; min-width:62px; text-align:right}

  #playersMini{display:flex; gap:6px; flex-wrap:nowrap; overflow:hidden}
  .chip{
    display:inline-flex; align-items:center; gap:6px;
    padding:4px 8px; border:1px solid #1d2840; border-radius:999px; background:#020617; font-size:12px;
    white-space:nowrap;
  }
  .chip b{font-weight:900}
  .dot{width:10px;height:10px;border-radius:50%}
  .legend{color:#c6d0e0;font-size:11px;text-align:center;opacity:.9}

  /* ===== Store (always 3 items on top) ===== */
  #storeTop{
    display:flex; gap:8px; align-items:center; justify-content:space-between;
    padding:10px; background:var(--panel); border:1px solid #111827; border-radius:var(--radius);
    box-shadow:0 12px 30px rgba(0,0,0,.6);
  }
  #storeItems{display:flex; gap:8px; align-items:center; justify-content:center; flex:1; flex-wrap:nowrap}
  .storeCol{display:flex;flex-direction:column;align-items:center;gap:6px}
  .btn{
    padding:8px 10px;border-radius:10px;border:1px solid #223252;background:#111827;color:#e6efff;cursor:pointer;font-weight:800;text-align:center;touch-action:manipulation;
    min-height:36px;
    box-shadow:0 6px 18px rgba(0,0,0,.5);
    font-size:13px;
  }
  .btn:disabled{opacity:.4;cursor:not-allowed;box-shadow:none}
  .btn:active{
    transform:translateY(1px) scale(.97);
    box-shadow:0 2px 8px rgba(0,0,0,.7);
  }

  /* ===== Center Piles ===== */
  #centerBand{
    border:1px dashed #1f2937; border-radius:10px; padding:8px;
    background:radial-gradient(circle at top,#020617,#020617 55%,#000 100%);
    min-height:140px; height:100%; overflow:hidden;
    display:flex; align-items:center; justify-content:center;
  }
  #piles{
    display:grid;
    grid-auto-rows:var(--pileSize);
    grid-template-columns:repeat(10, var(--pileSize));
    gap:var(--pileGap);
    place-content:start center;
  }

  .tile{
    width:var(--pileSize); height:var(--pileSize);
    border:2px solid var(--edge); border-radius:12px;
    display:flex; align-items:center; justify-content:center; gap:2px;
    font-weight:900; color:#020617; box-shadow:0 6px 16px rgba(0,0,0,.7);
    cursor:pointer; user-select:none; touch-action:manipulation;
    position:relative; outline-offset:-5px; min-height:44px;
    transition: transform .12s ease-out, box-shadow .18s ease-out, outline-color .18s ease-out, border-color .18s ease-out;
  }
  .tile.mine{
    outline:2px solid rgba(96,165,250,.95);
  }
  .tile.valid{
    outline:4px solid #84cc16;
    box-shadow:0 0 0 4px rgba(132,204,22,.45), 0 14px 26px rgba(0,0,0,.7);
  }
  .tile:active{
    transform:translateY(1px) scale(.97);
    box-shadow:0 3px 10px rgba(0,0,0,.7);
  }

  .own{
    position:absolute; bottom:2px; right:4px; font-size:11px;
    color:#020617; background:rgba(248,250,252,.95); padding:2px 8px; border-radius:999px; font-weight:800;
    pointer-events:none;
  }
  .trail{position:absolute; left:4px; bottom:4px; display:flex; gap:3px}
  .trail i{display:block; width:8px; height:8px; border-radius:50%}

  /* ===== Card chip ===== */
  .rect{
    width:var(--cardW); height:var(--cardH); border-radius:12px; border:2px solid var(--edge);
    display:flex; align-items:center; justify-content:space-between; padding:0 12px;
    color:#020617; font-weight:900; box-shadow:0 5px 18px rgba(0,0,0,.7);
    user-select:none; -webkit-user-select:none; touch-action:manipulation; cursor:pointer;
    outline-offset:-6px; min-height:44px;
    transition: transform .12s ease-out, box-shadow .18s ease-out, outline-color .18s ease-out, border-color .18s ease-out;
  }
  .rect.sel{ outline:4px solid #f97316; }
  .rect:active{
    transform:translateY(1px) scale(.97);
    box-shadow:0 3px 10px rgba(0,0,0,.7);
  }

  .c-yellow{background:linear-gradient(135deg,var(--y),#fee780);border-color:#eab308}
  .c-orange{background:linear-gradient(135deg,var(--o),#fed7aa);border-color:#fb923c}
  .c-green{background:linear-gradient(135deg,var(--g),#bbf7d0);border-color:#22c55e}
  .c-blue{background:linear-gradient(135deg,var(--b),#bae6fd);border-color:#60a5fa}

  /* ===== Bottom bar: hand + counts ===== */
  #bottomBar{
    display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center;
  }
  #handWrap{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  #counts{
    display:flex; gap:10px; align-items:center; justify-content:flex-end;
    background:#020617;border:1px solid #1d2840;border-radius:12px;padding:8px 10px; min-width:190px;
    box-shadow:0 8px 20px rgba(0,0,0,.7);
    font-size:12px;
  }
  .countItem{display:flex; gap:6px; align-items:center; font-weight:700}

  /* Reshuffle bar (local 1s) */
  #reshuffleWrap{
    display:none; flex-direction:column; gap:4px;
    margin-left:8px; min-width:140px;
  }
  #reshuffleWrap label{font-size:11px;color:#cbd5e1;opacity:.8}
  #reshuffleBar{
    height:8px; border-radius:999px; overflow:hidden; border:1px solid #334155; background:#020617;
    width:140px;
  }
  #reshuffleBar>div{height:100%; width:0%; background:#22c55e}

  /* Overlay */
  .overlay{position:fixed;inset:0;background:rgba(0,0,0,.78);display:none;align-items:center;justify-content:center;z-index:40}
  .dialog{
    background:#020617;border:1px solid #243754;border-radius:16px;padding:16px;
    min-width:min(780px,95vw);max-width:95vw;max-height:92vh;overflow:auto;
    box-shadow:0 22px 60px rgba(0,0,0,.9)
  }
  .dialog .big{font-size:24px;font-weight:900;margin-bottom:6px}
  .dialog .sub{font-size:14px;color:#c2cee3;margin-bottom:10px}
  .dialog .actions{display:flex;gap:10px;justify-content:center;margin-top:12px}
  .chartBox{background:#020617;border:1px solid #26334f;border-radius:12px;padding:10px;margin-top:8px}
  .chartTitle{font-weight:800;margin-bottom:6px}
  .legendRow{display:flex; gap:10px; flex-wrap:wrap; font-size:12px; color:#cbd5e1; margin-top:4px}
  .legendSwatch{width:12px;height:12px;border-radius:3px;display:inline-block;margin-right:6px}
</style>
</head>
<body>
  <!-- Auto-fit shell -->
  <div id="fitRoot">
    <div id="stageWrap">
      <!-- Everything inside #stage is measured/scaled to fit the window -->
      <main id="stage">
        <section id="screen" role="application">
          <!-- HUD -->
          <section id="hud" aria-live="polite">
            <div class="hudRow">
              <div class="stat"><span class="lbl">HP</span><span class="val" id="youHP">100</span></div>
              <div class="stat"><span class="lbl">Heal</span><span class="val" id="youHeal">0</span></div>
              <div class="stat"><span class="lbl">Damage</span><span class="val" id="youAtk">0</span></div>
              <div class="stat"><span class="lbl">Ward</span><span class="val" id="youWard">0</span></div>
              <div class="stat"><span class="lbl">Gold</span><span class="val" id="youGold">0</span></div>
              <div class="stat"><span class="lbl">Role</span><span class="val" id="youRole">Player</span></div>
            </div>
            <div class="timerRow">
              <div class="timerbar" title="Tick"><div id="tickBar"></div></div>
              <div class="tickLbl"><span id="tickIn">10.0</span>s</div>
            </div>
            <div id="playersMini"></div>
            <div class="legend" id="legendText">üí∞ Gold ‚Ä¢ ‚öîÔ∏è Damage ‚Ä¢ ‚ù§Ô∏è Heal ‚Ä¢ üõ°Ô∏è Ward</div>
          </section>

          <!-- Store (top, exactly 3 items) -->
          <section id="storeTop" aria-label="Store">
            <strong>Store</strong>
            <div id="storeItems"></div>
            <div style="display:flex; align-items:center; gap:8px; font-size:13px">
              <span>Gold: <b id="gold2">0</b></span>
            </div>
          </section>

          <!-- Center piles -->
          <section id="centerBand" aria-label="Center Piles">
            <div id="piles"></div>
          </section>

          <!-- Bottom bar: hand + counts -->
          <section id="bottomBar">
            <div id="handWrap">
              <button class="btn" id="flipBtn">üîÅ Flip</button>
              <button class="btn" id="fsBtn" title="Toggle Fullscreen" aria-pressed="false">‚õ∂ FS</button>
              <div id="hand" class="rect" style="pointer-events:none; opacity:.4; justify-content:center">‚Äî</div>

              <!-- Local reshuffle UI -->
              <div id="reshuffleWrap" aria-hidden="true">
                <label>Reshuffling‚Ä¶</label>
                <div id="reshuffleBar"><div></div></div>
              </div>
            </div>
            <div id="counts">
              <div class="countItem">Deck: <span id="deckCount">0</span></div>
              <div class="countItem">Discard: <span id="discardCount">0</span></div>
              <div class="countItem">Tick: <span id="tickMini">10.0</span>s</div>
            </div>
          </section>
        </section>
      </main>
    </div>
  </div>

  <!-- Overlay (also used for end-of-game graphs) -->
  <div id="overlay" class="overlay" aria-hidden="true">
    <div class="dialog">
      <div id="ovTitle" class="big"></div>
      <div id="ovMsg" class="sub"></div>
      <div id="ovCharts"></div>
      <div id="ovBtns" class="actions"></div>
    </div>
  </div>

<script type="module">
/* ========= Firebase ========= */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, onSnapshot,
  collection, addDoc, serverTimestamp, runTransaction,
  query, orderBy, deleteDoc
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);

/* ========= URL / Routing ========= */
const url   = new URL(window.location.href);
const gameId   = url.searchParams.get("gameId");
const username = (url.searchParams.get("username")||"").trim();
const HUB_URL = "/"; // change if your hub path differs
if(!gameId || !username){ alert("Missing gameId or username in URL."); }

/* ========= Constants ========= */
const COLORS=["yellow","orange","green","blue"];
const ICON={yellow:"üí∞",orange:"‚öîÔ∏è",green:"‚ù§Ô∏è",blue:"üõ°Ô∏è"};
const CCLS={yellow:"c-yellow",orange:"c-orange",green:"c-green",blue:"c-blue"};
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
const uid=(()=>{let i=1;return()=> "id"+(i++)})();
const nowMs=()=>Date.now();
const TICK_MS = 10000;           // 10s server tick
const BASE_GOLD_PER_TICK = 1;    // passive gold for everyone every tick (LOW but steady)

const $=sel=>document.querySelector(sel);

/* Unique per-device id so only ONE host device processes actions/ticks */
const clientId = (crypto.randomUUID ? crypto.randomUUID() : "c"+Math.random().toString(36).slice(2));
let hostPumpStarted = false;
let hostTickTimer = null;

/* ========= Auto-Fit (ALWAYS fits to one screen) ========= */
function fitToViewport(){
  const wrap  = document.getElementById('stageWrap');
  const stage = document.getElementById('stage');
  if(!wrap || !stage) return;

  stage.style.transform = 'none';
  const rect = stage.getBoundingClientRect();
  const naturalW = rect.width  || 1;
  const naturalH = rect.height || 1;
  const vw = wrap.clientWidth  || window.innerWidth;
  const vh = wrap.clientHeight || window.innerHeight;

  const padW = 8, padH = 8;
  const scale = Math.min(vw / (naturalW + padW), vh / (naturalH + padH), 1);
  stage.style.transform = `scale(${scale})`;
}
addEventListener('resize', fitToViewport, { passive:true });
addEventListener('orientationchange', ()=> setTimeout(fitToViewport, 150), { passive:true });

/* ========= Firestore refs ========= */
const lobbyRef = doc(db, "lobbies", gameId);
const gameRef  = doc(db, "dutchblitz_games", gameId);
const actionsCol = collection(db, "dutchblitz_games", gameId, "actions");

/* ========= Local ========= */
let L = {
  me: username,
  isHost: false,
  game: null,
  selectedCardId: null,
  colorMap: new Map(),
  // reshuffle UI
  reshuffling: false,
  reshuffleEnd: 0,
  waitingReshuffle: false,
  reshufRAF: null,
  // timeseries
  ts: [],       // timestamps (ms since start)
  hp: {},       // name -> []
  gold: {},     // name -> []
  atk: {},      // name -> []
  t0: nowMs()
};

/* ========= Colors for players ========= */
const PLAYER_PALETTE = ["#ef4444", "#22d3ee", "#f59e0b", "#8b5cf6"];
function computeColorMap(players){
  L.colorMap.clear();
  players.forEach((name, idx)=>{
    const col = PLAYER_PALETTE[idx % PLAYER_PALETTE.length];
    L.colorMap.set(name, { label: name === L.me ? "You" : name, color: col });
  });
}
function ownerMeta(name){ return L.colorMap.get(name) || {label:name, color:"#999"}; }
function ownerColor(name){ return ownerMeta(name).color; }

/* ========= Game Builders (host) ========= */
function makeCard(color,val){ return { id: uid(), color, val }; }
function baseDeck(){
  const d=[]; for(const c of COLORS){ for(let v=1; v<=5; v++) d.push(makeCard(c,v)); }
  for(let i=d.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [d[i],d[j]]=[d[j],d[i]]; }
  return d;
}
function buildStoreDeck(){
  const d=[]; for(let k=0;k<4;k++){ for(const c of COLORS){ for(let v=6; v<=10; v++) d.push(makeCard(c,v)); } }
  for(let i=d.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [d[i],d[j]]=[d[j],d[i]]; }
  return d;
}
function refillStore(G){ while(G.storeVis.length < 5 && G.storeDeck.length>0) G.storeVis.push(G.storeDeck.pop()); }
function newGameDoc(host, players, hostClientId){
  const P = {};
  players.forEach(name => {
    P[name] = { name, alive: true, health: 100, maxHealth: 100, gold: 0, deck: baseDeck(), discard: [], viewIndex: 0 };
  });
  const G = {
    type:"dutchblitz", host, players, status:"playing", winner:null,
    piles: [], storeDeck: buildStoreDeck(), storeVis: [],
    tickEndsAt: nowMs() + TICK_MS, awarded:false,
    hostClientId,                        // which device is the host authority
    createdAt: serverTimestamp(), updatedAt: serverTimestamp()
  };
  refillStore(G); return {G,P};
}

/* ========= Derived ========= */
function handCard(G, P, who){
  const pl=P[who]; if(!pl) return null;
  const vi = Math.max(0, Math.min(pl.viewIndex||0, pl.deck.length-1));
  if(pl.deck.length===0) return null;
  return pl.deck[vi]||null;
}
function sumsFor(G,P,who){
  let atk=0, heal=0, ward=0, gold=0;
  for(const pile of G.piles){
    if(pile.owner !== who) continue;
    const v=pile.topVal;
    if(pile.color==='orange') atk+=v;
    else if(pile.color==='green') heal+=v;
    else if(pile.color==='blue') ward+=v;
    else if(pile.color==='yellow') gold+=v;
  }
  return {atk,heal,ward,gold};
}
function livingPlayers(G,P){ return G.players.filter(n => P[n]?.alive); }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }

/* ========= Host: apply action ========= */
/* Actions are always tagged with .by (the username),
   so each player's clicks only mutate THEIR deck/state.
   The host device just applies them to the shared game. */
async function hostApplyAction(act){
  await runTransaction(db, async (tx) => {
    const snap = await tx.get(gameRef);
    if(!snap.exists()) return;
    const root = snap.data();
    if(root.status !== "playing") return;

    // clone
    const G = { ...root };
    const P = { ...root.P };
    G.players   = [...G.players];
    G.piles     = G.piles.map(p=>({...p, cards:[...p.cards]}));
    G.storeDeck = [...G.storeDeck];
    G.storeVis  = [...G.storeVis];
    for(const k of Object.keys(P)){ const pl=P[k]; P[k] = { ...pl, deck:[...pl.deck], discard:[...pl.discard] }; }

    const who = act.by, me = P[who]; if(!me?.alive) return;

    if(act.type === "flip"){
      const vi = me.viewIndex||0;
      const n = Math.min(3, me.deck.length - vi);
      for(let i=0;i<n;i++){
        const [moved] = me.deck.splice(vi,1);
        if(moved) me.discard.push(moved);
      }
      me.viewIndex = Math.min(vi, Math.max(0, me.deck.length-1));
    }
    else if(act.type === "start"){
      const c = handCard(G,P,who); if(!c || c.id!==act.cardId || c.val!==1) return;
      me.deck.splice(me.viewIndex||0,1);
      G.piles.push({ id:uid(), color:c.color, topVal:c.val, owner:who, cards:[{player:who,card:c}] });
      if(c.color==="yellow") me.gold=(me.gold||0)+c.val;
    }
    else if(act.type === "playOn"){
      const c = handCard(G,P,who); if(!c || c.id!==act.cardId) return;
      const pile = G.piles.find(p=>p.id===act.pileId); if(!pile) return;
      if(pile.color!==c.color || pile.topVal!==c.val-1) return;

      pile.cards.push({player:who, card:c});
      pile.topVal=c.val; pile.owner=who;
      me.deck.splice(me.viewIndex||0,1);
      if(c.color==="yellow") me.gold=(me.gold||0)+c.val;

      if(c.val===10){
        // Resolve "burst"
        for(const n of G.players){
          const t=P[n]; if(!t?.alive) continue;
          const s=sumsFor(G,P,n), eff=Math.max(0, 10-(s.ward||0));
          t.health=Math.max(0, (t.health||0)-eff); if(t.health===0) t.alive=false;
        }
        for(const entry of pile.cards){
          const o=P[entry.player];
          if(o) o.discard.push(entry.card);
        }
        G.piles=G.piles.filter(p=>p.id!==pile.id);
      }
    }
    else if(act.type === "buy"){
      const card=G.storeVis.find(c=>c.id===act.cardId); if(!card) return;
      if((me.gold||0) < card.val) return;
      me.gold -= card.val;
      me.discard.push(card);
      const idx = G.storeVis.findIndex(c=>c.id===card.id);
      if(idx>=0) G.storeVis.splice(idx,1);
      while(G.storeVis.length<5 && G.storeDeck.length>0) G.storeVis.push(G.storeDeck.pop());
    }
    else if(act.type === "reshuffle"){
      const refill = me.discard.splice(0);
      if(refill.length>0){
        me.deck = shuffle(me.deck.concat(refill));
      }
      me.viewIndex = 0;
    }

    const aliveList = G.players.filter(n=>P[n]?.alive);
    if(aliveList.length<=1){ G.status="finished"; G.winner=aliveList[0]||null; }

    G.updatedAt = serverTimestamp();
    await tx.update(gameRef, { ...G, P });
  });
}

/* ========= Host: tick ========= */
async function hostTickIfNeeded(){
  // Only the authoritative host device should ever run this
  await runTransaction(db, async (tx) => {
    const snap = await tx.get(gameRef);
    if(!snap.exists()) return; const root=snap.data();
    if(root.status!=="playing") return;
    if(root.hostClientId && root.hostClientId !== clientId) return; // not my job

    const tnow=nowMs(); if(tnow<root.tickEndsAt) return;

    const G={...root}, P={...root.P}; G.piles=G.piles.map(p=>({...p, cards:[...p.cards]}));
    const alive=livingPlayers(G,P);
    const sums=new Map(alive.map(n=>[n, sumsFor(G,P,n)]));

    const atkBy=new Map();
    for(const n of alive){
      const p=P[n], s=sums.get(n)||{atk:0,heal:0,ward:0,gold:0};
      p.health = clamp((p.health||0)+(s.heal||0), 0, (p.maxHealth||100));
      // ===== PASSIVE GOLD INCOME (per tick, low) =====
      p.gold   = (p.gold||0) + BASE_GOLD_PER_TICK + (s.gold||0);
      atkBy.set(n, s.atk||0);
    }
    for(const n of alive){
      const p=P[n]; const ward=(sums.get(n)?.ward)||0;
      let sumA=0; for(const [pid,A] of atkBy){ if(pid!==n) sumA+=A; }
      const eff=Math.max(0,sumA-ward); if(eff>0){ p.health=Math.max(0,(p.health||0)-eff); if(p.health===0) p.alive=false; }
    }

    const aliveAfter=livingPlayers(G,P);
    if(aliveAfter.length<=1){ G.status="finished"; G.winner=aliveAfter[0]||null; }

    G.tickEndsAt = nowMs()+TICK_MS; G.updatedAt=serverTimestamp();
    await tx.update(gameRef, { ...G, P });
  });
}

/* ========= Host action queue (guarded by hostClientId) ========= */
function startHostActionPump(){
  if (window.__DB_ACTIONS_UNSUB) { return; }
  const qy=query(actionsCol, orderBy("ts","asc"));
  const unsub = onSnapshot(qy, async (qs)=>{
    for(const d of qs.docChanges()){
      if(d.type!=="added") continue;
      const act=d.doc.data();
      await hostApplyAction(act);
      await deleteDoc(doc(db, "dutchblitz_games", gameId, "actions", d.doc.id));
    }
  });
  window.__DB_ACTIONS_UNSUB = unsub;
}

/* ========= Timeseries logging ========= */
function logSnapshot(root){
  const t = nowMs() - L.t0;
  L.ts.push(t);
  if (L.ts.length > 300) { L.ts.shift(); }

  for(const name of root.players){
    const p = root.P[name];
    const s = sumsFor(root, root.P, name);
    if(!L.hp[name])   L.hp[name]=[];
    if(!L.gold[name]) L.gold[name]=[];
    if(!L.atk[name])  L.atk[name]=[];
    L.hp[name].push(p.health||0);
    L.gold[name].push(p.gold||0);
    L.atk[name].push(s.atk||0);

    if (L.hp[name].length   > 300) L.hp[name].shift();
    if (L.gold[name].length > 300) L.gold[name].shift();
    if (L.atk[name].length  > 300) L.atk[name].shift();
  }
}

/* ========= UI helpers ========= */
function fitPilesToBand(){
  const wrap=document.getElementById("centerBand"); const grid=document.getElementById("piles");
  if(!wrap || !grid || !L.game) return;
  const n=(L.game.piles?.length)||1;
  const wrapW=wrap.clientWidth, wrapH=wrap.clientHeight;
  const maxSize = 96, minSize = 44, gap = 8;
  let size=Math.min(maxSize, Math.max(minSize, Math.floor(Math.sqrt((wrapW*wrapH)/(n*1.25)) )));
  function layoutFor(sz){
    const cols = Math.max(1, Math.floor((wrapW + gap) / (sz + gap)));
    const rows = Math.ceil(n / cols);
    const height = rows * (sz + gap) - gap;
    return {cols, rows, height};
  }
  let Lp = layoutFor(size);
  while (Lp.height > wrapH && size > minSize){ size -= 2; Lp = layoutFor(size); }
  document.documentElement.style.setProperty("--pileSize", size + "px");
  document.documentElement.style.setProperty("--pileGap", gap + "px");
  grid.style.gridTemplateColumns = `repeat(${Lp.cols}, var(--pileSize))`;
}

/* ========= Local reshuffle ========= */
function startLocalReshuffle(){
  if (L.reshuffling || L.waitingReshuffle) return;
  L.reshuffling = true;
  L.waitingReshuffle = true;
  L.reshuffleEnd = nowMs() + 1000;

  const wrap = $("#reshuffleWrap");
  const bar  = $("#reshuffleBar>div");
  wrap.style.display = "flex";
  wrap.setAttribute("aria-hidden","false");

  function step(){
    const left = L.reshuffleEnd - nowMs();
    const pct  = Math.max(0, Math.min(1, 1 - (left/1000)));
    bar.style.width = (pct*100).toFixed(1) + "%";
    if (left <= 0){
      cancelAnimationFrame(L.reshufRAF);
      addDoc(actionsCol, { by:L.me, type:"reshuffle", ts: serverTimestamp() });
      L.reshuffling = false;
      return;
    }
    L.reshufRAF = requestAnimationFrame(step);
  }
  L.reshufRAF = requestAnimationFrame(step);
}
function stopLocalReshuffleUI(){
  const wrap = $("#reshuffleWrap");
  const bar  = $("#reshuffleBar>div");
  wrap.style.display = "none";
  wrap.setAttribute("aria-hidden","true");
  bar.style.width = "0%";
  L.reshuffling = false;
  L.waitingReshuffle = false;
  if (L.reshufRAF) cancelAnimationFrame(L.reshufRAF);
  L.reshufRAF = null;
}

/* ========= Render ========= */
function render(){
  const root=L.game; if(!root) return; const me=root.P[L.me];
  const s=(who)=>sumsFor(root, root.P, who);

  // HUD stats
  $("#youHP").textContent   = Math.round(me.health||0);
  $("#youGold").textContent = me.gold||0; $("#gold2").textContent = me.gold||0;
  $("#youWard").textContent = s(L.me).ward||0;
  $("#youAtk").textContent  = s(L.me).atk||0;
  $("#youHeal").textContent = s(L.me).heal||0;
  $("#youRole").textContent = (L.isHost && root.host === L.me) ? "Host" : "Player";

  // Tick countdown and progress
  const left = Math.max(0, (root.tickEndsAt||0) - nowMs());
  const prog = Math.max(0, Math.min(1, (TICK_MS - left) / TICK_MS));
  const secs = (left/1000);
  $("#tickIn").textContent   = secs.toFixed(1);
  $("#tickMini").textContent = secs.toFixed(1);
  $("#tickBar").style.width  = (prog*100).toFixed(1) + "%";

  // Players mini
  const mini=$("#playersMini"); mini.innerHTML="";
  root.players.forEach(name=>{
    const p=root.P[name], m=ownerMeta(name);
    const chip=document.createElement("div");
    chip.className="chip";
    chip.innerHTML=`<span class="dot" style="background:${m.color}"></span>${m.label}&nbsp;<b>${Math.round(p.health||0)}</b>`;
    mini.appendChild(chip);
  });

  // Center piles (with owner trail)
  const grid=$("#piles"); grid.innerHTML="";
  root.piles.forEach(pile=>{
    const top=pile.cards[pile.cards.length-1].card;
    const m=ownerMeta(pile.owner);
    const tile=document.createElement("div");
    tile.className=`tile ${CCLS[top.color]}`;
    if(pile.owner === L.me) tile.classList.add("mine");

    // selection validity (current player's hand)
    const sel=L.selectedCardId && handCard(root, root.P, L.me);
    const selected=sel && sel.id===L.selectedCardId ? sel : null;
    if(selected && selected.color===pile.color && pile.topVal===selected.val-1) tile.classList.add("valid");

    tile.innerHTML = `
      <span style="font-weight:900">${top.val}</span>&nbsp;<span>${ICON[top.color]}</span>
      <span class="own">${m.label}</span>
      <div class="trail">${pile.cards.map(en=>{
        const mm = ownerMeta(en.player);
        return `<i style="background:${mm.color}" title="${en.player}"></i>`;
      }).join("")}</div>
    `;
    tile.style.borderColor = m.color;
    tile.addEventListener("pointerup",(e)=>{
      e.preventDefault();
      if(!selected){ return; }
      addDoc(actionsCol, { by:L.me, type:"playOn", pileId:pile.id, cardId:selected.id, ts: serverTimestamp() });
      L.selectedCardId=null;
    });
    grid.appendChild(tile);
  });
  fitPilesToBand();

  // Hand card (+ local reshuffle trigger when deck exhausted)
  const hand=$("#hand");
  const c=handCard(root, root.P, L.me);
  if(c){
    const myColor=ownerColor(L.me);
    hand.className=`rect ${CCLS[c.color]}${L.selectedCardId===c.id?' sel':''}`;
    hand.style.opacity = "1"; hand.style.pointerEvents="auto";
    hand.style.borderColor = myColor;
    hand.innerHTML=`<span style="font-weight:900;font-size:22px">${c.val}</span><span style="font-size:22px">${ICON[c.color]}</span>`;
    hand.onclick = ()=>{
      if(c.val===1){
        addDoc(actionsCol, { by:L.me, type:"start", cardId:c.id, ts: serverTimestamp() });
        L.selectedCardId=null;
      } else {
        L.selectedCardId = (L.selectedCardId===c.id) ? null : c.id;
        render();
      }
    };
    if (L.waitingReshuffle) stopLocalReshuffleUI();
  } else {
    hand.className="rect";
    hand.style.opacity=".4"; hand.style.pointerEvents="none";
    hand.innerHTML="‚Äî";

    if (!L.reshuffling && !L.waitingReshuffle &&
        (root.P[L.me].deck.length===0) && ((root.P[L.me].discard?.length||0) > 0)){
      startLocalReshuffle();
    }
  }

  // Store ‚Äî exactly 3 visible slots
  const store=$("#storeItems"); store.innerHTML="";
  const visibleCards = root.storeVis.slice(0, 3);
  visibleCards.forEach((card)=>{
    const col=document.createElement("div"); col.className="storeCol";
    const btn=document.createElement("button"); btn.className="btn"; btn.textContent=`Buy $${card.val}`;
    if((me.gold||0) < card.val || !me.alive) btn.disabled=true;
    btn.addEventListener("pointerup",(e)=>{ e.preventDefault(); addDoc(actionsCol, { by:L.me, type:"buy", cardId: card.id, ts: serverTimestamp() }); });
    col.appendChild(btn);
    const r=document.createElement("div"); r.className=`rect ${CCLS[card.color]}`;
    r.innerHTML=`<span style="font-weight:900;font-size:18px">${card.val}</span><span style="font-size:18px">${ICON[card.color]}</span>`;
    r.style.borderColor = "#334155";
    col.appendChild(r);
    store.appendChild(col);
  });

  $("#deckCount").textContent    = root.P[L.me].deck.length;
  $("#discardCount").textContent = root.P[L.me].discard.length;

  logSnapshot(root);
  fitToViewport();

  if(root.status === "finished"){
    showGameOverWithCharts(root);
  } else {
    $("#overlay").style.display="none";
  }
}

/* ========= Charts (SVG sparklines) ========= */
function makeSparklineSVG(seriesMap, title, height=120, width=720, padding=24){
  const t = L.ts;
  if (t.length < 2) return `<div class="chartBox"><div class="chartTitle">${title}</div><div style="opacity:.7">Not enough data.</div></div>`;

  let maxV = 1;
  for (const k in seriesMap){
    const arr = seriesMap[k].values;
    for (let i=0;i<arr.length;i++) if (arr[i] > maxV) maxV = arr[i];
  }

  const W = width, H = height;
  const x0 = padding, y0 = padding, x1 = W - padding, y1 = H - padding;
  const spanX = x1 - x0, spanY = y1 - y0;
  const tMin = t[0], tMax = t[t.length-1] || (t[0]+1);

  const paths = [];
  const legends = [];

  for (const name in seriesMap){
    const {color, values} = seriesMap[name];
    if (!values || values.length !== t.length) continue;
    let d = "";
    for (let i=0;i<t.length;i++){
      const x = x0 + ((t[i]-tMin)/(tMax - tMin)) * spanX;
      const v = Math.max(0, values[i]);
      const y = y1 - (v / maxV) * spanY;
      d += (i===0 ? `M ${x},${y}` : ` L ${x},${y}`);
    }
    paths.push(`<path d="${d}" fill="none" stroke="${color}" stroke-width="2"/>`);
    legends.push(`<span><i class="legendSwatch" style="background:${color}"></i>${name}</span>`);
  }

  return `
  <div class="chartBox">
    <div class="chartTitle">${title}</div>
    <svg viewBox="0 0 ${W} ${H}" width="100%" height="${H}">
      <rect x="${x0}" y="${y0}" width="${spanX}" height="${spanY}" fill="none" stroke="#334155" stroke-width="1"/>
      ${paths.join("")}
    </svg>
    <div class="legendRow">${legends.join("")}</div>
  </div>`;
}

function showGameOverWithCharts(root){
  const ov=$("#overlay"), title=$("#ovTitle"), msg=$("#ovMsg"), btns=$("#ovBtns"), charts=$("#ovCharts");
  const winner = root.winner ? ownerMeta(root.winner).label : "Game Over";
  title.textContent = `üèÜ Winner: ${winner}`;
  msg.textContent   = "Match summary";

  const hpMap   = {};
  const goldMap = {};
  const atkMap  = {};
  for (const name of root.players){
    const meta = ownerMeta(name);
    hpMap[name]   = { color: meta.color, values: L.hp[name]   || [] };
    goldMap[name] = { color: meta.color, values: L.gold[name] || [] };
    atkMap[name]  = { color: meta.color, values: L.atk[name]  || [] };
  }

  charts.innerHTML =
    makeSparklineSVG(hpMap,   "Health over time") +
    makeSparklineSVG(goldMap, "Gold over time")   +
    makeSparklineSVG(atkMap,  "Attack over time");

  btns.innerHTML = "";
  const back = document.createElement("button");
  back.className="btn"; back.textContent="Return to Lobby";
  back.addEventListener("pointerup", ()=> window.location.href = `${HUB_URL}?username=${encodeURIComponent(L.me)}`);
  btns.appendChild(back);

  ov.style.display="flex";
}

/* ========= Overlay helpers ========= */
function showOverlay(title, msg, buttons=[{label:"OK", onClick: ()=> hideOverlay()}]){
  $("#ovTitle").textContent=title;
  $("#ovMsg").textContent=msg||"";
  const btns=$("#ovBtns"); btns.innerHTML="";
  buttons.forEach(b=>{
    const el=document.createElement("button");
    el.className="btn"; el.textContent=b.label;
    el.addEventListener("pointerup", ()=>{ b.onClick?.(); });
    btns.appendChild(el);
  });
  $("#overlay").style.display="flex";
}
function hideOverlay(){ $("#overlay").style.display="none"; }

/* ========= Fullscreen ========= */
function isFullscreen(){ return document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement; }
async function enterFullscreen(el){
  const target = el || document.documentElement;
  const req = target.requestFullscreen || target.webkitRequestFullscreen || target.msRequestFullscreen;
  if(req) await req.call(target);
}
async function exitFullscreen(){
  const ex = document.exitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen;
  if(ex) await ex.call(document);
}
async function toggleFullscreen(){ if(isFullscreen()) await exitFullscreen(); else await enterFullscreen(document.documentElement); }

/* ========= Boot ========= */
async function boot(){
  // Set legend text to show passive income clearly
  const legendEl = document.getElementById("legendText");
  if(legendEl){
    legendEl.textContent = `üí∞ Gold (includes passive +${BASE_GOLD_PER_TICK}/tick) ‚Ä¢ ‚öîÔ∏è Damage ‚Ä¢ ‚ù§Ô∏è Heal ‚Ä¢ üõ°Ô∏è Ward`;
  }

  // lobby ‚Üí players/host
  const lSnap = await getDoc(lobbyRef);
  if(!lSnap.exists()){ alert("Lobby not found."); return; }
  const lobby = lSnap.data();
  const players = (lobby.players || []).slice(0,4);
  const host = lobby.host || players[0];
  L.isHost = (username === host);
  computeColorMap(players);

  // create game if absent
  const gSnap = await getDoc(gameRef);
  if(L.isHost && !gSnap.exists()){
    const {G,P} = newGameDoc(host, players, clientId);
    await setDoc(gameRef, { ...G, P });
  } else if(L.isHost && gSnap.exists()){
    const data = gSnap.data();
    // If no hostClientId yet (old game), claim it from this device
    if(!data.hostClientId){
      try{
        await runTransaction(db, async (tx)=>{
          const cur = await tx.get(gameRef);
          if(!cur.exists()) return;
          const root = cur.data();
          if(root.hostClientId) return; // someone else already claimed
          tx.update(gameRef, { hostClientId: clientId, updatedAt: serverTimestamp() });
        });
      }catch(err){
        console.error("Failed to claim hostClientId", err);
      }
    }
  }

  // subscribe
  onSnapshot(gameRef, async (snap)=>{
    if(!snap.exists()) return;
    L.game=snap.data();

    // If I'm the host and THIS device owns hostClientId, start pumps once
    const isAuthority = L.isHost && L.game.hostClientId === clientId;

    if(isAuthority && !hostPumpStarted){
      startHostActionPump();
      hostTickTimer = setInterval(hostTickIfNeeded, 250);
      hostPumpStarted = true;
    }

    // Award once ‚Äî only the authoritative host device does it
    if(isAuthority && L.game.status==="finished" && L.game.winner && !L.game.awarded){
      await runTransaction(db, async (tx)=>{
        const cur = await tx.get(gameRef); if(!cur.exists()) return;
        const root=cur.data();
        if(root.awarded) return;
        const wRef = doc(db, "users", L.game.winner);
        const wSnap = await tx.get(wRef);
        if(wSnap.exists()){
          const prev = wSnap.data().wins || 0;
          tx.update(wRef, { wins: prev + 1 });
        } else {
          tx.set(wRef, { wins: 1 });
        }
        tx.update(gameRef, { awarded: true, updatedAt: serverTimestamp() });
      });
    }

    render();
  });

  // controls
  $("#flipBtn").addEventListener("pointerup", (e)=>{
    e.preventDefault();
    if (L.reshuffling || L.waitingReshuffle) return;
    addDoc(actionsCol, { by:L.me, type:"flip", ts: serverTimestamp() });
  });
  window.addEventListener("keydown", (e)=>{ if(e.key===" "){ e.preventDefault(); $("#flipBtn").click(); } });

  // fullscreen
  const fsBtn = document.getElementById("fsBtn");
  if(fsBtn){
    fsBtn.addEventListener("click", toggleFullscreen);
    document.addEventListener("fullscreenchange", ()=>{
      const fs = !!isFullscreen();
      fsBtn.textContent = fs ? "‚õ∂ Exit" : "‚õ∂ FS";
      fsBtn.setAttribute("aria-pressed", String(fs));
      fitToViewport();
    });
  }

  // Refits
  new ResizeObserver(()=>{ fitPilesToBand(); fitToViewport(); }).observe(document.getElementById("centerBand"));
  new ResizeObserver(()=>{ fitToViewport(); }).observe(document.getElementById("stage"));

  // First fit
  fitToViewport();
}
boot();
</script>
</body>
</html>










