<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>üóø Stoney's Relic ‚Äî Dungeon Master</title>
  <style>
    :root{
      --bg:#0b1220; --panel:#111a2e; --panel2:#0f1730;
      --ink:#e7eefc; --muted:rgba(231,238,252,.72);
      --good:#22c55e; --bad:#ef4444; --warn:#f59e0b;
      --br:rgba(255,255,255,.10); --shadow:0 18px 55px rgba(0,0,0,.35);
      --r:16px;

      --sel:#a855f7;
      --sel2:#3b82f6;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background:
        radial-gradient(900px 520px at 20% -10%, rgba(168,85,247,.22), transparent 55%),
        radial-gradient(900px 520px at 90% 0%, rgba(59,130,246,.18), transparent 55%),
        radial-gradient(900px 520px at 55% 120%, rgba(34,197,94,.10), transparent 60%),
        var(--bg);
      color:var(--ink);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      min-height:100svh;
    }
    header{
      padding:14px 14px 10px;
      position:sticky; top:0; z-index:10;
      background:linear-gradient(180deg, rgba(11,18,32,.96), rgba(11,18,32,.65));
      backdrop-filter: blur(10px);
      border-bottom:1px solid var(--br);
    }
    .top{
      max-width:1200px; margin:0 auto; display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap;
    }
    .brand{ display:flex; gap:10px; align-items:center; }
    .logo{
      width:44px; height:44px; display:grid; place-items:center; border-radius:14px;
      background:rgba(255,255,255,.08);
      border:1px solid var(--br);
      box-shadow:var(--shadow);
      font-size:22px;
      position:relative;
      overflow:hidden;
    }
    .logo:after{
      content:"";
      position:absolute; inset:-40%;
      background:conic-gradient(from 180deg, rgba(168,85,247,.22), rgba(59,130,246,.20), rgba(34,197,94,.12), rgba(168,85,247,.22));
      filter:blur(14px);
      opacity:.55;
    }
    .logo > span{ position:relative; z-index:2; }
    .title{ font-weight:900; letter-spacing:.2px; }
    .sub{ color:var(--muted); font-size:.9rem; }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px; border-radius:999px;
      background:rgba(255,255,255,.06); border:1px solid var(--br);
      font-weight:800; font-size:.85rem;
    }
    .wrap{ max-width:1200px; margin:12px auto 22px; padding:0 12px calc(18px + env(safe-area-inset-bottom)); }
    .grid{ display:grid; grid-template-columns: 1.45fr .85fr; gap:14px; }
    @media (max-width:980px){ .grid{ grid-template-columns:1fr; } }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.04));
      border:1px solid var(--br);
      border-radius:var(--r);
      box-shadow:var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .card:before{
      content:"";
      position:absolute; inset:0;
      background:
        radial-gradient(700px 260px at 30% 0%, rgba(168,85,247,.10), transparent 60%),
        radial-gradient(620px 240px at 85% 10%, rgba(59,130,246,.10), transparent 60%);
      pointer-events:none;
      opacity:.7;
    }
    .head{
      padding:12px 14px; border-bottom:1px solid var(--br);
      display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;
      background:rgba(0,0,0,.18);
      position:relative;
      z-index:1;
    }
    .head b{ font-size:.98rem; }
    .body{ padding:12px 14px; position:relative; z-index:1; }
    canvas{
      width:100%; height:auto; aspect-ratio: 1 / 1;
      display:block;
      border-radius:14px;
      background:
        linear-gradient(180deg, #ffffff, #fbfdff);
      border:1px solid rgba(0,0,0,.12);
      box-shadow: 0 14px 35px rgba(0,0,0,.25);
      touch-action:none;
      max-height:min(76vh, 82svh);
    }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .btn{
      cursor:pointer; user-select:none;
      padding:10px 12px; border-radius:12px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.06);
      color:var(--ink); font-weight:900;
      transition:.15s transform, .15s background, .15s box-shadow, .15s border-color;
      position:relative;
    }
    .btn:hover{ background:rgba(255,255,255,.10); transform:translateY(-1px); }
    .btn:active{ transform:translateY(0); }
    .btn.good{
      background:linear-gradient(180deg, rgba(34,197,94,.92), rgba(22,163,74,.92));
      border-color:rgba(255,255,255,.22);
      box-shadow: 0 10px 26px rgba(34,197,94,.18);
    }
    .btn:disabled{ opacity:.55; cursor:not-allowed; transform:none; }
    .muted{ color:var(--muted); font-size:.9rem; line-height:1.35; }

    .bar{
      height:10px; border-radius:999px; background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.14);
      overflow:hidden;
    }
    .bar > i{
      display:block; height:100%; width:0%;
      background:linear-gradient(90deg, rgba(34,197,94,.95), rgba(245,158,11,.95), rgba(239,68,68,.95));
      transition:width .12s linear;
    }
    .small{ font-size:.82rem; }
    .kv{
      display:grid; grid-template-columns: 1fr auto; gap:8px;
      padding:10px 0; border-bottom:1px dashed rgba(255,255,255,.10);
    }
    .kv:last-child{ border-bottom:none; }
    .tag{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.18);
      font-weight:900; font-size:.78rem;
      white-space:nowrap;
    }
    #statusLine{ font-weight:900; }
    #warnLine{ color:#ffd1d1; font-weight:900; min-height: 1.2em; }

    .mode-grid{
      display:grid;
      grid-template-columns:repeat(3,minmax(0,1fr));
      gap:8px;
      margin:10px 0 6px;
    }
    .mode-btn{
      text-align:center;
      min-height:46px;
      font-size:.95rem;
      padding:10px 10px;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
    }
    .mode-btn .cost{
      font-size:.78rem;
      font-weight:1000;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.18);
      opacity:.95;
    }
    .mode-btn.selected{
      border-color: rgba(255,255,255,.28);
      box-shadow:
        0 0 0 2px rgba(255,255,255,.12),
        0 14px 34px rgba(0,0,0,.26);
      transform: translateY(-1px);
    }
    .mode-btn.selected::after{
      content:"‚úì";
      position:absolute;
      top:6px;
      right:8px;
      width:18px; height:18px;
      border-radius:6px;
      display:grid; place-items:center;
      font-size:12px;
      font-weight:1000;
      color:#061018;
      background: rgba(255,255,255,.92);
      box-shadow: 0 10px 20px rgba(0,0,0,.25);
    }

    /* Per-mode selection color */
    .mode-btn.selected[data-set-mode="crown"]{
      background: linear-gradient(180deg, rgba(168,85,247,.92), rgba(139,92,246,.90));
      border-color: rgba(255,255,255,.26);
    }
    .mode-btn.selected[data-set-mode="fire"]{
      background: linear-gradient(180deg, rgba(245,158,11,.94), rgba(239,68,68,.88));
      border-color: rgba(255,255,255,.22);
    }
    .mode-btn.selected[data-set-mode="fog"]{
      background: linear-gradient(180deg, rgba(148,163,184,.45), rgba(100,116,139,.38));
      border-color: rgba(255,255,255,.20);
    }
    .mode-btn.selected[data-set-mode="ghost"]{
      background: linear-gradient(180deg, rgba(34,211,238,.46), rgba(14,165,233,.40));
      border-color: rgba(255,255,255,.20);
    }
    .mode-btn.selected[data-set-mode="demon"]{
      background: linear-gradient(180deg, rgba(251,113,133,.48), rgba(239,68,68,.40));
      border-color: rgba(255,255,255,.20);
    }

    .mode-btn.cantAfford{
      opacity:.68;
      border-color: rgba(239,68,68,.28);
      box-shadow: inset 0 0 0 1px rgba(239,68,68,.22);
    }
    .mode-btn.cantAfford .cost{
      background: rgba(239,68,68,.18);
      border-color: rgba(239,68,68,.28);
    }

    .mobile-toolbar{
      display:none;
      margin-top:12px;
      padding:10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(15,23,48,.65);
    }
    @media (max-width:720px){
      header{ padding:10px 10px 8px; }
      .wrap{ margin-top:8px; padding:0 8px calc(16px + env(safe-area-inset-bottom)); }
      .body{ padding:10px; }
      .head{ padding:10px; }
      .pill{ font-size:.78rem; padding:7px 9px; }
      .logo{ width:38px; height:38px; border-radius:12px; font-size:20px; }
      .title{ font-size:1rem; }
      .sub{ font-size:.8rem; }
      .btn{ min-height:44px; }
      .mode-grid{ grid-template-columns:repeat(2,minmax(0,1fr)); }
      .mobile-toolbar{ display:block; position:sticky; bottom:8px; z-index:8; backdrop-filter:blur(8px); }
      .desktop-modes{ display:none; }
    }
  </style>
</head>

<body>
<header>
  <div class="top">
    <div class="brand">
      <div class="logo"><span>üó∫Ô∏è</span></div>
      <div>
        <div class="title">Dungeon Master</div>
        <div class="sub">Place the crown + traps. Traps can‚Äôt be placed near online living players.</div>
      </div>
    </div>
    <div class="row">
      <div class="pill">‚è±Ô∏è <span id="setupT">‚Äî</span></div>
      <div class="pill">üî• Energy: <span id="energyT">‚Äî</span></div>
      <button id="readyBtn" class="btn good">‚úÖ Ready</button>
    </div>
  </div>
</header>

<div class="wrap">
  <div class="grid">
    <div class="card">
      <div class="head">
        <b>Maze Map</b>
        <span class="tag" id="modeTag">Mode: ‚Äî</span>
      </div>
      <div class="body">
        <canvas id="map" width="900" height="900"></canvas>

        <div class="muted" style="margin-top:10px">
          Tap a mode, then tap the map. Traps placed during setup will <b>arm when the dungeon opens</b>.
          <span class="muted small" style="display:inline-block; margin-left:6px">Red rings show the <b>no-trap zone</b> around living players.</span>
        </div>

        <div class="mobile-toolbar">
          <div class="small muted" style="margin-bottom:8px">Tap a power, then tap the map.</div>
          <div class="mode-grid" style="margin:0">
            <button class="btn mode-btn" data-set-mode="crown">üëë Crown <span class="cost">FREE</span></button>
            <button class="btn mode-btn" data-set-mode="fire">üî• Fire <span class="cost">20</span></button>
            <button class="btn mode-btn" data-set-mode="fog">üå´Ô∏è Fog <span class="cost">15</span></button>
            <button class="btn mode-btn" data-set-mode="ghost">üëª Ghost <span class="cost">50</span></button>
            <button class="btn mode-btn" data-set-mode="demon">üòà Demon <span class="cost">75</span></button>
          </div>
        </div>

        <div id="warnLine" style="margin-top:8px"></div>
      </div>
    </div>

    <div class="card">
      <div class="head">
        <b>Controls</b>
        <span id="statusLine" class="small">Connecting‚Ä¶</span>
      </div>
      <div class="body">
        <div class="kv">
          <div>
            <div style="font-weight:900">Placement</div>
            <div class="muted">Crown is the win objective. Traps arm when play begins (or immediately if already playing).</div>
          </div>
          <div class="tag">üß† DM</div>
        </div>

        <div class="mode-grid desktop-modes">
          <button class="btn mode-btn" data-set-mode="crown">üëë Crown <span class="cost">FREE</span></button>
          <button class="btn mode-btn" data-set-mode="fire">üî• Fire <span class="cost">20</span></button>
          <button class="btn mode-btn" data-set-mode="fog">üå´Ô∏è Fog <span class="cost">15</span></button>
          <button class="btn mode-btn" data-set-mode="ghost">üëª Ghost <span class="cost">50</span></button>
          <button class="btn mode-btn" data-set-mode="demon">üòà Demon <span class="cost">75</span></button>
        </div>

        <div class="muted small" id="costLine">Costs: ‚Äî</div>

        <div style="margin:12px 0 8px; font-weight:900">Energy</div>
        <div class="bar"><i id="energyBar"></i></div>
        <div class="row" style="margin-top:8px; justify-content:space-between">
          <div class="muted small" id="regenLine">Regen: ‚Äî ‚Ä¢ Max: 100</div>
          <div class="tag" id="phaseTag">Phase: ‚Äî</div>
        </div>

        <div style="margin-top:14px; font-weight:900">Legend</div>
        <div class="muted small" style="margin-top:6px; line-height:1.5">
          <div>üü¶ Players (online)</div>
          <div>‚≠ï No-trap zone (‚âà 4 squares)</div>
          <div>üëë Crown</div>
          <div>üî• Fire</div>
          <div>üå´Ô∏è Fog</div>
          <div>üëª Ghost</div>
          <div>üòà Demon</div>
        </div>

        <div style="margin-top:14px; font-weight:900">Notes</div>
        <div class="muted small" style="margin-top:6px">
          Players win if they carry the crown out of the maze within 5 minutes.
          If a player is hit by fire/ghost/demon, they drop the crown and respawn after 15s at the entrance.
        </div>
      </div>
    </div>
  </div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import {
    getFirestore, doc, setDoc, runTransaction,
    collection, onSnapshot, addDoc, deleteDoc
  } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
  import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

  const firebaseConfig = {
    apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
    authDomain: "bible-game-246c0.firebaseapp.com",
    projectId: "bible-game-246c0",
    storageBucket: "bible-game-246c0.appspot.com",
    messagingSenderId: "959619818996",
    appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const auth = getAuth(app);

  const qs = new URLSearchParams(location.search);
  const gameId = (qs.get("gameId") || "").trim();
  const usernameRaw = (qs.get("username") || "").trim();
  const username = usernameRaw.length ? usernameRaw.slice(0, 22) : "Dungeon Master";

  const $ = (id)=>document.getElementById(id);
  const statusLine = $("statusLine");
  const warnLine = $("warnLine");
  const setupT = $("setupT");
  const energyT = $("energyT");
  const energyBar = $("energyBar");
  const phaseTag = $("phaseTag");
  const modeTag = $("modeTag");
  const readyBtn = $("readyBtn");
  const costLine = $("costLine");
  const regenLine = $("regenLine");

  const canvas = $("map");
  const ctx = canvas.getContext("2d");

  // ---------- Maze helpers (must match stoney.html) ----------
  function xorshift32(seed){
    let x = (seed|0) || 123456789;
    return ()=> {
      x ^= x << 13; x ^= x >>> 17; x ^= x << 5;
      return ((x>>>0) / 4294967296);
    };
  }
  function makeMaze(w,h,seed){
    const rnd = xorshift32(seed);
    const N=1,E=2,S=4,W=8;
    const dx = { [N]:0,[E]:1,[S]:0,[W]:-1 };
    const dy = { [N]:-1,[E]:0,[S]:1,[W]:0 };
    const opp= { [N]:S,[E]:W,[S]:N,[W]:E };

    const cells = Array.from({length:w*h}, ()=> ({v:false, walls:N|E|S|W}));
    const idx = (x,y)=> y*w+x;

    const stack=[];
    let cx=0, cy=0;
    cells[idx(cx,cy)].v=true;
    stack.push([cx,cy]);

    const dirs=[N,E,S,W];
    while(stack.length){
      const [x,y]=stack[stack.length-1];
      const options=[];
      for(const d of dirs){
        const nx=x+dx[d], ny=y+dy[d];
        if(nx<0||ny<0||nx>=w||ny>=h) continue;
        if(!cells[idx(nx,ny)].v) options.push(d);
      }
      if(!options.length){ stack.pop(); continue; }
      const d = options[Math.floor(rnd()*options.length)];
      const nx=x+dx[d], ny=y+dy[d];
      const a=cells[idx(x,y)], b=cells[idx(nx,ny)];
      a.walls &= ~d;
      b.walls &= ~opp[d];
      b.v=true;
      stack.push([nx,ny]);
    }

    const ex = Math.floor(w/2), ey = h-1;
    cells[idx(ex,ey)].walls &= ~S;
    return { w,h, cells, entrance:{x:ex,y:ey} };
  }
  function cellCenterWorld(maze, cellSize, cx, cy){
    const ox = -maze.w*cellSize/2;
    const oz = -maze.h*cellSize/2;
    const x = ox + (cx+0.5)*cellSize;
    const z = oz + (cy+0.5)*cellSize;
    return {x,z};
  }

  // ---------- Energy model (stored only when spending) ----------
  const ENERGY_MAX=100;
  // slowed down a bit (was 8/sec)
  const ENERGY_REGEN_PER_SEC=6;

  function energyNow(stoney){
    const base = Number(stoney?.dmEnergyBase ?? 0);
    const stamp = Number(stoney?.dmEnergyStamp ?? Date.now());
    const dt = Math.max(0, Date.now() - stamp) / 1000;
    return Math.min(ENERGY_MAX, base + dt*ENERGY_REGEN_PER_SEC);
  }

  // ---------- Costs + TTL ----------
  const COST = { fire:20, fog:15, ghost:50, demon:75 };
  const TTL  = { fire:10_000, fog:18_000, ghost:300_000, demon:300_000 };

  // No-trap zone: ~4 squares (cells) radius
  const NO_TRAP_RADIUS_CELLS = 4;

  const ONLINE_GRACE_MS = 12000;

  // ---------- State ----------
  let lobbyRef=null, playersCol=null, trapsCol=null;
  let lobbyData=null, stoney=null, maze=null;
  let players = new Map(); // uid -> {name,x,z,alive,deadUntil,updatedAt}
  let traps = []; // [{id,type,x,z,placedAt,ttlMs}]
  let mode="crown";

  let amDM=false;
  let purgeAt=0;

  const modeButtons = [...document.querySelectorAll("[data-set-mode]")];

  function snapshotError(where, err){
    console.error(`[dungeonmaster] ${where} snapshot error`, err);
    statusLine.textContent = "Error";
    warnLine.textContent = "‚ùå " + (err?.message || "Unknown error");
  }

  async function ensureAuthed(){
    if(auth.currentUser){
      await auth.currentUser.getIdToken();
      return auth.currentUser;
    }
    await signInAnonymously(auth).catch(()=>{});
    return await new Promise((resolve, reject)=>{
      let unsub=null;
      const timeout=setTimeout(()=>{
        unsub?.(); reject(new Error("Anonymous auth timed out."));
      }, 12000);
      unsub=onAuthStateChanged(auth, async (user)=>{
        if(!user) return;
        clearTimeout(timeout);
        unsub();
        try{
          await user.getIdToken();
          resolve(user);
        }catch(e){ reject(e); }
      });
    });
  }

  function modeLabel(m){
    return m === "crown" ? "Crown" : m[0].toUpperCase() + m.slice(1);
  }

  function updateModeTag(){
    if(mode === "crown"){
      modeTag.textContent = `Mode: Crown (FREE)`;
    } else {
      modeTag.textContent = `Mode: ${modeLabel(mode)} (${COST[mode] ?? "?"})`;
    }
  }

  function updateCostLine(){
    costLine.textContent = `Costs: Fire ${COST.fire} ‚Ä¢ Fog ${COST.fog} ‚Ä¢ Ghost ${COST.ghost} ‚Ä¢ Demon ${COST.demon}`;
    regenLine.textContent = `Regen: ${ENERGY_REGEN_PER_SEC}/sec ‚Ä¢ Max: ${ENERGY_MAX}`;
  }

  function updateAffordability(){
    const e = energyNow(stoney);
    for(const btn of modeButtons){
      const m = btn.dataset.setMode;
      if(m === "crown"){
        btn.classList.remove("cantAfford");
        continue;
      }
      const need = COST[m] || 0;
      btn.classList.toggle("cantAfford", (stoney && e < need));
    }
  }

  function setMode(m){
    mode=m;

    for(const btn of modeButtons){
      btn.classList.toggle("selected", btn.dataset.setMode === m);
    }
    updateModeTag();
    updateAffordability();
    warnLine.textContent = "";
  }

  function dist2(ax,az,bx,bz){ const dx=ax-bx, dz=az-bz; return dx*dx+dz*dz; }

  function noTrapRadiusWorld(){
    const cellSize = Number(stoney?.cellSize || 4);
    return NO_TRAP_RADIUS_CELLS * cellSize;
  }
  function getCrownWorldPos(){
  if(!stoney) return null;

  // If someone is carrying it, use the carrier position
  if(stoney.carrierId){
    const p = players.get(stoney.carrierId);
    if(p) return { x: Number(p.x||0), z: Number(p.z||0), carried:true };
  }

  // Otherwise use the crown ground position
  if(stoney.crown && typeof stoney.crown.x==="number" && typeof stoney.crown.z==="number"){
    return { x: Number(stoney.crown.x), z: Number(stoney.crown.z), carried:false };
  }

  return null;
}


 function isTooCloseToAnyPlayer(wx,wz){
  const now = Date.now();
  const R = noTrapRadiusWorld();
  const R2 = R*R;

  // Block near ONLINE + ALIVE players
  for(const [pid,p] of players){
    const online = now - (p.updatedAt||0) <= ONLINE_GRACE_MS;
    if(!online) continue;
    const alive = !!p.alive && (p.deadUntil||0) < now;
    if(!alive) continue;
    if(dist2(wx,wz, p.x||0, p.z||0) <= R2) return p.name || "Player";
  }

  // Block near the crown (ground or carried)
  const crownPos = getCrownWorldPos();
  if(crownPos){
    if(dist2(wx,wz, crownPos.x, crownPos.z) <= R2) return "Crown";
  }

  return null;
}


  function computeTrapWindow(t){
    if(!stoney) return {armedAt: t.placedAt||0, expiresAt: (t.placedAt||0) + (t.ttlMs||0)};
    const placedAt = Number(t.placedAt||0);
    const ttlMs = Number(t.ttlMs||TTL[t.type]||15000);

    const startAt = Number(stoney.startAt||0);
    const setupDeadline = Number(stoney.setupDeadline||0);
    const phaseNow = stoney.phase || "setup";

    let armedAt = 0;
    if(startAt > 0) armedAt = placedAt < startAt ? startAt : placedAt;
    else if(phaseNow === "setup" && setupDeadline > 0) armedAt = setupDeadline;
    else armedAt = placedAt;

    return { armedAt, expiresAt: armedAt + ttlMs };
  }

  // ---------- Drawing ----------
  function worldToCell(wx,wz){
    if(!maze || !stoney) return null;
    const cellSize = stoney.cellSize;
    const ox = -maze.w*cellSize/2;
    const oz = -maze.h*cellSize/2;
    const cx = Math.floor((wx - ox) / cellSize);
    const cy = Math.floor((wz - oz) / cellSize);
    if(cx<0||cy<0||cx>=maze.w||cy>=maze.h) return null;
    return {cx,cy};
  }

  function drawMap(){
    if(!maze){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      return;
    }
    const W=canvas.width, H=canvas.height;
    ctx.fillStyle="#fff";
    ctx.fillRect(0,0,W,H);

    const pad=18;
    const availW=W-pad*2, availH=H-pad*2;
    const cellPx = Math.min(availW/maze.w, availH/maze.h);

    const x0 = (W - maze.w*cellPx)/2;
    const y0 = (H - maze.h*cellPx)/2;

    // soft paper grid
    ctx.save();
    ctx.globalAlpha = 0.10;
    ctx.strokeStyle = "#0b1220";
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let i=0;i<=maze.w;i++){
      const x = x0 + i*cellPx;
      ctx.moveTo(x, y0);
      ctx.lineTo(x, y0 + maze.h*cellPx);
    }
    for(let i=0;i<=maze.h;i++){
      const y = y0 + i*cellPx;
      ctx.moveTo(x0, y);
      ctx.lineTo(x0 + maze.w*cellPx, y);
    }
    ctx.stroke();
    ctx.restore();

    // maze walls
    ctx.strokeStyle="#000";
    ctx.lineWidth = Math.max(2, cellPx*0.12);
    ctx.lineCap="square";

    const N=1,E=2,S=4,Ww=8;
    const idx=(x,y)=>y*maze.w+x;

    ctx.beginPath();
    for(let y=0;y<maze.h;y++){
      for(let x=0;x<maze.w;x++){
        const c = maze.cells[idx(x,y)];
        const px=x0+x*cellPx, py=y0+y*cellPx;

        if(c.walls & N){ ctx.moveTo(px,py); ctx.lineTo(px+cellPx,py); }
        if(c.walls & Ww){ ctx.moveTo(px,py); ctx.lineTo(px,py+cellPx); }
        if(y===maze.h-1 && (c.walls & S)){ ctx.moveTo(px,py+cellPx); ctx.lineTo(px+cellPx,py+cellPx); }
        if(x===maze.w-1 && (c.walls & E)){ ctx.moveTo(px+cellPx,py); ctx.lineTo(px+cellPx,py+cellPx); }
      }
    }
    ctx.stroke();

    // entrance marker
    const ex=maze.entrance.x, ey=maze.entrance.y;
    const epx=x0+ex*cellPx, epy=y0+ey*cellPx;
    ctx.fillStyle="rgba(34,197,94,.18)";
    ctx.fillRect(epx+cellPx*0.2, epy+cellPx*0.8, cellPx*0.6, cellPx*0.25);

    // NO-TRAP ZONES (circles around online living players)
    const now2 = Date.now();
    const rPx = cellPx * NO_TRAP_RADIUS_CELLS;

    for(const [pid,p] of players){
      const online = now2 - (p.updatedAt||0) <= ONLINE_GRACE_MS;
      if(!online) continue;
      const alive = !!p.alive && (p.deadUntil||0) < now2;
      if(!alive) continue;

      const c = worldToCell(p.x||0, p.z||0);
      if(!c) continue;
      const px = x0 + c.cx*cellPx + cellPx*0.5;
      const py = y0 + c.cy*cellPx + cellPx*0.5;

      ctx.save();
      ctx.globalAlpha = 1;

      // subtle fill
      ctx.fillStyle = "rgba(239,68,68,.08)";
      ctx.beginPath();
      ctx.arc(px, py, rPx, 0, Math.PI*2);
      ctx.fill();

      // dashed ring
      ctx.strokeStyle = "rgba(239,68,68,.35)";
      ctx.lineWidth = Math.max(2, cellPx*0.06);
      ctx.setLineDash([Math.max(6, cellPx*0.18), Math.max(6, cellPx*0.18)]);
      ctx.beginPath();
      ctx.arc(px, py, rPx, 0, Math.PI*2);
      ctx.stroke();

      // inner ring
      ctx.setLineDash([]);
      ctx.strokeStyle = "rgba(239,68,68,.22)";
      ctx.lineWidth = Math.max(1.5, cellPx*0.04);
      ctx.beginPath();
      ctx.arc(px, py, rPx*0.82, 0, Math.PI*2);
      ctx.stroke();

      ctx.restore();
    }

    // CROWN NO-TRAP ZONE (4-cell radius)
const crownPos = getCrownWorldPos();
if(crownPos){
  const cCrown = worldToCell(crownPos.x, crownPos.z);
  if(cCrown){
    const px = x0 + cCrown.cx*cellPx + cellPx*0.5;
    const py = y0 + cCrown.cy*cellPx + cellPx*0.5;

    const rPx = cellPx * NO_TRAP_RADIUS_CELLS;

    ctx.save();

    // soft gold fill
    ctx.fillStyle = "rgba(245,158,11,.10)";
    ctx.beginPath();
    ctx.arc(px, py, rPx, 0, Math.PI*2);
    ctx.fill();

    // dashed gold ring
    ctx.strokeStyle = "rgba(245,158,11,.55)";
    ctx.lineWidth = Math.max(2, cellPx*0.06);
    ctx.setLineDash([Math.max(6, cellPx*0.18), Math.max(6, cellPx*0.18)]);
    ctx.beginPath();
    ctx.arc(px, py, rPx, 0, Math.PI*2);
    ctx.stroke();

    // small inner ring
    ctx.setLineDash([]);
    ctx.strokeStyle = "rgba(245,158,11,.25)";
    ctx.lineWidth = Math.max(1.5, cellPx*0.04);
    ctx.beginPath();
    ctx.arc(px, py, rPx*0.82, 0, Math.PI*2);
    ctx.stroke();

    ctx.restore();
  }
}


    // traps
    const now=Date.now();
    for(const t of traps){
      const {armedAt, expiresAt} = computeTrapWindow(t);
      if(expiresAt < now) continue;

      const c = worldToCell(t.x,t.z);
      if(!c) continue;

      const px = x0 + c.cx*cellPx + cellPx*0.5;
      const py = y0 + c.cy*cellPx + cellPx*0.5;

      let fill="#000";
      if(t.type==="fire") fill="#ef4444";
      if(t.type==="fog") fill="#94a3b8";
      if(t.type==="ghost") fill="#22d3ee";
      if(t.type==="demon") fill="#fb7185";

      const armed = now >= armedAt;

      ctx.beginPath();
      ctx.fillStyle = armed ? fill : "rgba(0,0,0,.22)";
      ctx.arc(px,py, Math.max(3, cellPx*(armed ? 0.18 : 0.14)), 0, Math.PI*2);
      ctx.fill();

      // subtle ring to indicate "planned"
      if(!armed){
        ctx.strokeStyle="rgba(0,0,0,.35)";
        ctx.lineWidth=Math.max(1.5, cellPx*0.06);
        ctx.beginPath();
        ctx.arc(px,py, Math.max(5, cellPx*0.28), 0, Math.PI*2);
        ctx.stroke();
      }
    }

    // crown (on ground)
    if(stoney?.crown && !stoney?.carrierId){
      const c = worldToCell(stoney.crown.x, stoney.crown.z);
      if(c){
        const px = x0 + c.cx*cellPx + cellPx*0.5;
        const py = y0 + c.cy*cellPx + cellPx*0.5;
        ctx.font = `${Math.max(14, cellPx*0.6)}px system-ui`;
        ctx.textAlign="center";
        ctx.textBaseline="middle";
        ctx.fillText("üëë", px, py);
      }
    }

    // players
    for(const [pid,p] of players){
      const online = now2 - (p.updatedAt||0) <= ONLINE_GRACE_MS;
      if(!online) continue;

      const alive = !!p.alive && (p.deadUntil||0) < now2;
      const c = worldToCell(p.x||0, p.z||0);
      if(!c) continue;

      const px = x0 + c.cx*cellPx + cellPx*0.5;
      const py = y0 + c.cy*cellPx + cellPx*0.5;

      ctx.beginPath();
      ctx.fillStyle = alive ? "#2563eb" : "rgba(37,99,235,.35)";
      ctx.arc(px,py, Math.max(3, cellPx*0.20), 0, Math.PI*2);
      ctx.fill();

      // label
      ctx.font = `${Math.max(9, cellPx*0.22)}px system-ui`;
      ctx.textAlign="center";
      ctx.textBaseline="top";
      ctx.fillStyle="rgba(0,0,0,.75)";
      ctx.fillText(p.name || "Player", px, py + Math.max(5, cellPx*0.22));
    }

    // carrier marker
    if(stoney?.carrierId){
      const p = players.get(stoney.carrierId);
      if(p){
        const c = worldToCell(p.x||0,p.z||0);
        if(c){
          const px = x0 + c.cx*cellPx + cellPx*0.5;
          const py = y0 + c.cy*cellPx + cellPx*0.5;
          ctx.font = `${Math.max(14, cellPx*0.55)}px system-ui`;
          ctx.textAlign="center";
          ctx.textBaseline="bottom";
          ctx.fillText("üëë", px, py - Math.max(4, cellPx*0.18));
        }
      }
    }
  }

  // ---------- Setup / Init ----------
  async function ensureInit(){
    if(!gameId){
      statusLine.textContent = "Missing gameId";
      throw new Error("Missing gameId. Use ?gameId=YOURLOBBYID&username=NAME");
    }

    lobbyRef = doc(db, "lobbies", gameId);
    playersCol = collection(db, "lobbies", gameId, "players");
    trapsCol = collection(db, "lobbies", gameId, "traps");

    await runTransaction(db, async (tx)=>{
      const snap = await tx.get(lobbyRef);
      const now = Date.now();

      const seedDefault = Math.floor(Math.random()*2_000_000_000);
      const w=21, h=21, cellSize=4;

      if(!snap.exists()){
        tx.set(lobbyRef, {
          createdAt: now,
          gameType: "stoney",
          dm: username,
          stoney: {
            seed: seedDefault,
            w, h, cellSize,
            phase: "setup",
            setupDeadline: now + 30_000,
            crown: null,
            carrierId: null,
            carrierName: null,
            dmEnergyBase: 0,
            dmEnergyStamp: now,
            startAt: null,
            endAt: null,
            winner: null,
            winnerName: null,
            lastEvent: "Dungeon Master is preparing the dungeon‚Ä¶",
            lastEventAt: now
          }
        }, { merge: true });
        return;
      }

      const d = snap.data() || {};
      const patch = {};

      if(!d.dm) patch["dm"] = username;

      if(!d.stoney){
        patch["stoney"] = {
          seed: seedDefault,
          w, h, cellSize,
          phase: "setup",
          setupDeadline: now + 30_000,
          crown: null,
          carrierId: null,
          carrierName: null,
          dmEnergyBase: 0,
          dmEnergyStamp: now,
          startAt: null,
          endAt: null,
          winner: null,
          winnerName: null,
          lastEvent: "Dungeon Master is preparing the dungeon‚Ä¶",
          lastEventAt: now
        };
      } else {
        const s = d.stoney;
        if(typeof s.seed!=="number") patch["stoney.seed"]=seedDefault;
        if(typeof s.w!=="number") patch["stoney.w"]=w;
        if(typeof s.h!=="number") patch["stoney.h"]=h;
        if(typeof s.cellSize!=="number") patch["stoney.cellSize"]=cellSize;
        if(typeof s.phase!=="string") patch["stoney.phase"]="setup";
        if(typeof s.setupDeadline!=="number") patch["stoney.setupDeadline"]=now+30_000;
        if(typeof s.dmEnergyBase!=="number") patch["stoney.dmEnergyBase"]=0;
        if(typeof s.dmEnergyStamp!=="number") patch["stoney.dmEnergyStamp"]=now;
        if(s.carrierId === undefined) patch["stoney.carrierId"]=null;
        if(s.carrierName === undefined) patch["stoney.carrierName"]=null;
      }

      if(Object.keys(patch).length) tx.set(lobbyRef, patch, { merge: true });
    });
  }

  async function forceReady(){
    if(!amDM){ warnLine.textContent = "‚ùå Only the DM can start the dungeon."; return; }

    await runTransaction(db, async (tx)=>{
      const snap = await tx.get(lobbyRef);
      if(!snap.exists()) return;
      const d = snap.data() || {};
      const s = d.stoney;
      if(!s) return;
      if(s.phase !== "setup") return;

      const m = makeMaze(s.w, s.h, s.seed);
      let crown = s.crown;

      if(!crown){
        const center = { x: Math.floor(s.w/2), y: Math.floor(s.h/2) };
        const centerWorld = cellCenterWorld(m, s.cellSize, center.x, center.y);
        crown = { x: centerWorld.x, z: centerWorld.z };
      }

      const startAt = Date.now();
      const endAt = startAt + 5*60*1000;

      tx.update(lobbyRef, {
        "stoney.phase": "play",
        "stoney.crown": crown,
        "stoney.carrierId": null,
        "stoney.carrierName": null,
        "stoney.startAt": startAt,
        "stoney.endAt": endAt,
        "stoney.lastEvent": "The dungeon doors open‚Ä¶ Find the crown!",
        "stoney.lastEventAt": startAt
      });
    });
  }

  // ---------- Placement ----------
  async function placeAtCell(cx,cy){
    if(!amDM){ warnLine.textContent = "‚ùå Only the DM can place items."; return; }
    if(!stoney || !maze) return;

    if(stoney.phase !== "setup" && stoney.phase !== "play"){
      warnLine.textContent = "Game is not active.";
      return;
    }

    const cellSize = stoney.cellSize;
    const {x,z} = cellCenterWorld(maze, cellSize, cx, cy);

    if(mode !== "crown"){
      const who = isTooCloseToAnyPlayer(x,z);
      if(who){
        warnLine.textContent = `‚ùå Too close to player "${who}". Place farther away.`;
        return;
      }
    }

    if(mode==="crown"){
      await setDoc(lobbyRef, {
        stoney: {
          crown: { x, z },
          carrierId: null,
          carrierName: null,
          lastEvent: `${username} placed the crown.`,
          lastEventAt: Date.now()
        }
      }, { merge:true });
      warnLine.textContent = "";
      return;
    }

    // energy spend (transaction)
    const need = COST[mode] || 0;
    await runTransaction(db, async (tx)=>{
      const snap = await tx.get(lobbyRef);
      if(!snap.exists()) throw new Error("Lobby missing");
      const d = snap.data() || {};
      const s = d.stoney || {};
      const curE = energyNow(s);
      if(curE < need) throw new Error(`Not enough energy (${Math.floor(curE)}/${need}).`);

      const remain = curE - need;
      tx.update(lobbyRef, {
        "stoney.dmEnergyBase": remain,
        "stoney.dmEnergyStamp": Date.now()
      });
    }).catch((e)=>{
      warnLine.textContent = "‚ùå " + (e?.message || "Energy spend failed");
      throw e;
    });

    // place trap doc
    const placedAt = Date.now();
    const ttlMs = TTL[mode] || 15000;

    await addDoc(trapsCol, {
      type: mode,
      x, z,
      placedBy: username,
      placedAt,
      ttlMs
    });

    warnLine.textContent = "";
  }

  // ---------- HUD + purge ----------
  function tickHUD(){
    if(!stoney){
      setupT.textContent="‚Äî";
      energyT.textContent="‚Äî";
      energyBar.style.width="0%";
      phaseTag.textContent="Phase: ‚Äî";
      return;
    }

    phaseTag.textContent = "Phase: " + stoney.phase;

    const e = energyNow(stoney);
    energyT.textContent = Math.floor(e) + "/" + ENERGY_MAX;
    energyBar.style.width = Math.round((e/ENERGY_MAX)*100) + "%";

    updateAffordability();

    if(stoney.phase==="setup"){
      const t = Math.max(0, (stoney.setupDeadline||0) - Date.now());
      setupT.textContent = t>0 ? (t/1000).toFixed(0) + "s" : "0s";
      if(t<=0 && amDM){
        forceReady().catch(()=>{});
      }
    } else if(stoney.phase==="play"){
      const endAt = stoney.endAt || (Date.now()+1);
      const t = Math.max(0, endAt - Date.now());
      setupT.textContent = "üïî " + Math.floor(t/60000) + "m " + Math.floor((t%60000)/1000) + "s";
    } else {
      setupT.textContent="‚Äî";
    }

    // purge expired traps periodically (DM only)
    const now = Date.now();
    if(amDM && now > purgeAt){
      purgeAt = now + 12_000;
      purgeExpiredTraps().catch(()=>{});
    }
  }

  async function purgeExpiredTraps(){
    if(!stoney) return;
    const now = Date.now();
    const kill = [];

    for(const t of traps){
      const {expiresAt} = computeTrapWindow(t);
      if(expiresAt < now - 1500) kill.push(t.id);
      if(kill.length >= 24) break;
    }

    await Promise.all(kill.map((id)=> deleteDoc(doc(db,"lobbies",gameId,"traps",id)).catch(()=>{})));
  }

  // ---------- Live listeners ----------
  function listen(){
    onSnapshot(lobbyRef, (snap)=>{
      if(!snap.exists()) return;
      lobbyData = snap.data() || {};
      stoney = lobbyData.stoney || null;

      if(stoney && !maze && typeof stoney.seed === "number"){
        maze = makeMaze(stoney.w, stoney.h, stoney.seed);
      }

      const dmName = lobbyData.dm;
      amDM = !dmName || dmName === username;
      statusLine.textContent = amDM ? `Online ‚Ä¢ DM: ${username}` : `Viewer ‚Ä¢ DM is ${dmName || "?"}`;
      readyBtn.disabled = !amDM;

      updateModeTag();
      tickHUD();
      drawMap();
    }, (err)=>snapshotError("lobby", err));

    onSnapshot(playersCol, (snap)=>{
      players.clear();
      snap.forEach(d=>{
        const v = d.data() || {};
        players.set(d.id, {
          name: String(v.name || "Player").slice(0,22),
          x: Number(v.x||0),
          z: Number(v.z||0),
          alive: v.alive !== false,
          deadUntil: Number(v.deadUntil||0),
          updatedAt: Number(v.updatedAt||0),
        });
      });
      drawMap();
    }, (err)=>snapshotError("players", err));

    onSnapshot(trapsCol, (snap)=>{
      traps = [];
      snap.forEach(d=>{
        const v = d.data() || {};
        traps.push({
          id:d.id,
          type:v.type,
          x:Number(v.x||0),
          z:Number(v.z||0),
          placedAt:Number(v.placedAt||0),
          ttlMs:Number(v.ttlMs||TTL[v.type]||15000),
        });
      });
      drawMap();
    }, (err)=>snapshotError("traps", err));
  }

  // ---------- UI wiring ----------
  for(const btn of modeButtons){
    btn.addEventListener("click", ()=> setMode(btn.dataset.setMode));
  }

  updateCostLine();
  setMode("crown");

  readyBtn.onclick=()=>forceReady().catch(e=> warnLine.textContent = "‚ùå " + (e?.message||"Ready failed"));

  function getCanvasCell(clientX, clientY){
    if(!maze || !stoney) return null;
    const rect = canvas.getBoundingClientRect();
    const mx = (clientX - rect.left) * (canvas.width / rect.width);
    const my = (clientY - rect.top) * (canvas.height / rect.height);

    const pad=18;
    const availW=canvas.width-pad*2, availH=canvas.height-pad*2;
    const cellPx = Math.min(availW/maze.w, availH/maze.h);
    const x0 = (canvas.width - maze.w*cellPx)/2;
    const y0 = (canvas.height - maze.h*cellPx)/2;

    const cx = Math.floor((mx - x0) / cellPx);
    const cy = Math.floor((my - y0) / cellPx);
    if(cx<0||cy<0||cx>=maze.w||cy>=maze.h) return null;
    return {cx, cy};
  }

  async function tryPlaceFromEvent(ev){
    const cell = getCanvasCell(ev.clientX, ev.clientY);
    if(!cell) return;
    try{
      await placeAtCell(cell.cx, cell.cy);
    }catch(e){
      // warnLine already set
    }
  }

  canvas.addEventListener("click", (ev)=>{ tryPlaceFromEvent(ev); });
  canvas.addEventListener("pointerdown", (ev)=>{
    if(ev.pointerType === "touch"){
      ev.preventDefault();
      tryPlaceFromEvent(ev);
    }
  }, { passive:false });

  // ---------- Boot ----------
  ensureAuthed()
    .then(async ()=>{
      statusLine.textContent = "Signing in‚Ä¶";
      await ensureInit();
      statusLine.textContent = "Online";
      listen();
      setInterval(()=>{ tickHUD(); drawMap(); }, 160);
    })
    .catch((e)=>{
      statusLine.textContent = "Auth failed";
      warnLine.textContent = "‚ùå Enable anonymous sign-in in Firebase Authentication. " + (e?.message || "");
    });
</script>
</body>
</html>


