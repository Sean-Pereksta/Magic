<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>‚úäüìÑ‚úÇÔ∏è Rock Paper Scissors MMO</title>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<style>
  :root{
    --ink:#0f172a; --muted:#6b7280; --panel:#ffffff; --br:#e5e7eb;
    --shadow:0 10px 30px rgba(15,23,42,.08); --radius:16px; --tap:56px;
    --green:#d9f99d; --yellow:#fde68a; --red:#fecaca; --purple:#e9d5ff;
    --wall:#9ca3af; --house:#b45309; --shop:#16a34a;
    --guild:#2563eb; --chatH:140px; --hudH:64px;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Arial;color:var(--ink);background:#fafafa;}
  .topbar{
    position:fixed; top:0; left:0; right:0; height:var(--hudH);
    background:#fff; border-bottom:1px solid var(--br); display:flex; align-items:center; gap:12px; padding:10px 12px; z-index:20;
  }
  .stat{display:flex;align-items:center;gap:6px;background:#fff;border:1px solid var(--br);border-radius:12px;padding:8px 10px}
  .xpbar{position:relative;height:8px;background:#f3f4f6;border-radius:999px;overflow:hidden;min-width:140px;border:1px solid var(--br)}
  .xpbar>i{display:block;height:100%;width:0;background:linear-gradient(90deg,#a7f3d0,#22c55e)}
  .regionTag{margin-left:auto;font-weight:800;padding:8px 12px;border-radius:999px;border:1px solid var(--br);background:#fff}
  .logout{margin-left:6px;border:1px solid var(--br);background:#fff;border-radius:10px;padding:8px 10px;cursor:pointer}

  /* Viewport window (center, phone-friendly) */
  .frameWrap{
    position:fixed; top:calc(var(--hudH) + 8px); left:0; right:0; bottom:calc(var(--chatH) + env(safe-area-inset-bottom) + 8px);
    display:grid; place-items:center;
  }
  .frame{
    width:min(100vw, 820px);
    height:min( calc(100vh - var(--hudH) - var(--chatH) - 24px), 820px );
    background:#fff; border:1px solid var(--br); border-radius:20px; box-shadow:var(--shadow); overflow:hidden; position:relative;
    touch-action:manipulation;
  }
  /* Map canvas (virtual grid) */
  .map{
    position:absolute; inset:0; overflow:hidden; background:#eef2ff;
    image-rendering:pixelated;
    font-size:14px;
  }
  /* Tiles rendered as divs for simplicity */
  .tile{
    position:absolute; width:32px; height:32px; display:grid; place-items:center; user-select:none;
  }
  .t-green{ background:var(--green) }
  .t-yellow{ background:var(--yellow) }
  .t-red{ background:var(--red) }
  .t-purple{ background:var(--purple) }
  .t-wall{ background:#e5e7eb; outline:2px solid var(--wall) }
  .t-house::after{ content:"üè†"; }
  .t-shop::after{ content:"üí∞"; }
  .t-guild::after{ content:"üèõÔ∏è"; }
  .t-village{ outline: 1px dashed #6b7280 }

  /* Player & NPC */
  .actor{ position:absolute; width:32px; height:32px; display:grid; place-items:center; pointer-events:none }
  .me::after{ content:"üßô"; font-size:22px }
  .player::after{ content:"üßô"; opacity:.85 }
  .npc-rock::after{ content:"ü™®"; }
  .npc-paper::after{ content:"üìÑ"; }
  .npc-scissors::after{ content:"‚úÇÔ∏è"; }
  .inactive{ display:none }

  /* Chat panel */
  .chat{
    position:fixed; left:0; right:0; bottom:0; height:var(--chatH);
    border-top:1px solid var(--br); background:#fff; display:grid; grid-template-rows:1fr auto; z-index:15;
  }
  .msgs{ padding:8px 10px; overflow:auto }
  .msg{ font-size:14px; margin:4px 0; }
  .msg small{ color:var(--muted) }
  .chatForm{ display:flex; gap:8px; padding:8px; border-top:1px solid var(--br) }
  .input{ flex:1; padding:12px; border:1px solid var(--br); border-radius:12px; outline:none }
  .btn{ padding:12px 14px; border:1px solid var(--br); background:#111827; color:#fff; border-radius:12px; cursor:pointer; font-weight:800 }
  .btn.secondary{ background:#fff; color:#111827 }

  /* Modal */
  .modalBack{ position:fixed; inset:0; background:rgba(0,0,0,.25); display:none; align-items:center; justify-content:center; z-index:30 }
  .modal{ width:min(92vw, 720px); max-height:80vh; overflow:auto; background:#fff; border-radius:16px; box-shadow:var(--shadow); border:1px solid var(--br) }
  .modal-head{ padding:12px 14px; border-bottom:1px solid var(--br); font-weight:900; display:flex; align-items:center; justify-content:space-between }
  .modal-body{ padding:12px 14px; display:grid; gap:10px }
  .row{ display:flex; gap:10px; flex-wrap:wrap }
  .pill{ display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid var(--br); border-radius:999px; background:#fff }

  /* Shop/guild/trade content */
  .invGrid{ display:grid; grid-template-columns:repeat(auto-fill, minmax(120px,1fr)); gap:10px }
  .card{ border:1px solid var(--br); border-radius:12px; padding:10px; background:#fff; display:flex; flex-direction:column; gap:6px }
  .card b{ font-size:14px }
  .card small{ color:var(--muted) }
  .danger{ color:#b91c1c; font-weight:800 }
  .ok{ color:#16a34a; font-weight:800 }
</style>
</head>
<body>
  <div class="topbar">
    <div class="stat">üßô <b id="usernameLbl">Player</b></div>
    <div class="stat">üí∞ Gold: <b id="goldLbl">0</b></div>
    <div class="stat">‚≠ê Lv <b id="levelLbl">1</b></div>
    <div class="stat xp">
      <div class="xpbar"><i id="xpFill"></i></div>
      <small id="xpLbl" style="margin-left:6px;color:var(--muted)">0/0</small>
    </div>
    <div class="regionTag" id="regionLbl">Rocky Roads</div>
    <button id="logoutBtn" class="logout">Logout</button>
  </div>

  <div class="frameWrap">
    <div id="frame" class="frame">
      <div id="map" class="map" aria-label="map"></div>
    </div>
  </div>

  <!-- Chat -->
  <div class="chat">
    <div id="messages" class="msgs"></div>
    <form id="chatForm" class="chatForm">
      <input id="chatInput" class="input" maxlength="160" placeholder="Say something to players within 15 tiles..." />
      <button class="btn" type="submit">Send</button>
      <button id="shopBtn" class="btn secondary" type="button">Shop</button>
      <button id="guildBtn" class="btn secondary" type="button">Guild</button>
      <button id="invBtn" class="btn secondary" type="button">Inventory</button>
    </form>
  </div>

  <!-- Modals -->
  <div id="modalBack" class="modalBack">
    <div class="modal">
      <div class="modal-head">
        <div id="modalTitle">Title</div>
        <button id="modalClose" class="btn secondary" type="button">Close</button>
      </div>
      <div id="modalBody" class="modal-body"></div>
    </div>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import {
    getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot, serverTimestamp,
    collection, addDoc, query, where, limit, orderBy, getDocs, runTransaction
  } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

  // -------- Firebase --------
  const firebaseConfig = {
    apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
    authDomain: "bible-game-246c0.firebaseapp.com",
    projectId: "bible-game-246c0",
    storageBucket: "bible-game-246c0.appspot.com",
    messagingSenderId: "959619818996",
    appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // -------- URL / Session --------
  const params = new URLSearchParams(location.search);
  let username = (params.get("username") || localStorage.getItem("gh.username") || "").trim();
  if (!username) {
    alert("Missing username. Returning to lobby.");
    location.href = "/"; // fallback
  }
  document.getElementById("usernameLbl").textContent = username;

  // -------- Map / Regions --------
  const TILE = 32;
  const VIEW_W = 23;  // tiles visible horizontally
  const VIEW_H = 23;  // tiles vertically
  const MAP_W = 120;
  const MAP_H = 120;

  // Regions (rects): [x0,y0,x1,y1, key, title, class]
  const REGIONS = [
    [0,0, 59,59, "green","Rocky Roads","t-green"],
    [60,0, 119,59,"yellow","Parchment Plateau","t-yellow"],
    [0,60, 59,119,"red","Scissors Point","t-red"],
    [60,60,119,119,"purple","Probabilities Plain","t-purple"]
  ];

  // Villages: each with walls (perimeter), interior decor
  const VILLAGES = [
    { name:"Westhold", x:14, y:14, w:10, h:10, region:"green" },
    { name:"Sunfold", x:80, y:10, w:10, h:10, region:"yellow" },
    { name:"Edgekeep", x:16, y:86, w:10, h:10, region:"red" },
    { name:"Mystvale", x:88, y:88, w:10, h:10, region:"purple" },
  ];

  // Static walls from villages
  const walls = new Set();
  function coordKey(x,y){ return `${x},${y}`; }

  function inRect(x,y, r){
    return x>=r[0] && x<=r[2] && y>=r[1] && y<=r[3];
  }

  function regionOf(x,y){
    for(const r of REGIONS){ if (inRect(x,y,r)) return r; }
    return REGIONS[0];
  }

  function isVillageTile(x,y){
    for(const v of VILLAGES){
      if (x>=v.x && x< v.x+v.w && y>=v.y && y< v.y+v.h) return v;
    }
    return null;
  }
  function isVillageWall(x,y){
    const v = isVillageTile(x,y);
    if (!v) return false;
    const onEdge = (x===v.x || y===v.y || x===v.x+v.w-1 || y===v.y+v.h-1);
    return onEdge;
  }

  // Fill walls and decor
  const houses = new Set();
  const shops  = new Set();
  const guilds = new Set();
  for(const v of VILLAGES){
    for(let y=v.y; y<v.y+v.h; y++){
      for(let x=v.x; x<v.x+v.w; x++){
        if (isVillageWall(x,y)) walls.add(coordKey(x,y));
      }
    }
    // interiors: 2 houses + 1 shop + 1 guild
    houses.add(coordKey(v.x+2, v.y+2));
    houses.add(coordKey(v.x+v.w-3, v.y+2));
    shops.add(coordKey(v.x+Math.floor(v.w/2), v.y+Math.floor(v.h/2)));
    guilds.add(coordKey(v.x+2, v.y+v.h-3));
  }

  function passable(x,y){
    if (x<0||y<0||x>=MAP_W||y>=MAP_H) return false;
    if (walls.has(coordKey(x,y))) return false;
    return true;
  }

  // -------- Player State --------
  const playerRef = doc(db, "players", username);
  const othersRef = collection(db, "players");
  let me = {
    name: username,
    x: 8, y: 8, level:1, xp:0, gold: 30, // a little start cash
    guild: "", inventory: [],
    active: true, lastLoginDay: "", lastSeen: serverTimestamp()
  };
  const BASE_START = { level:1, xp:0, gold:30,
    inventory: [
      {id:crypto.randomUUID(), name:"Rock", type:"rock", lvlReq:1},
      {id:crypto.randomUUID(), name:"Rock", type:"rock", lvlReq:1},
      {id:crypto.randomUUID(), name:"Rock", type:"rock", lvlReq:1},
      {id:crypto.randomUUID(), name:"Paper", type:"paper", lvlReq:1},
      {id:crypto.randomUUID(), name:"Paper", type:"paper", lvlReq:1},
      {id:crypto.randomUUID(), name:"Paper", type:"paper", lvlReq:1},
      {id:crypto.randomUUID(), name:"Scissors", type:"scissors", lvlReq:1},
      {id:crypto.randomUUID(), name:"Scissors", type:"scissors", lvlReq:1},
      {id:crypto.randomUUID(), name:"Scissors", type:"scissors", lvlReq:1},
    ]
  };

  // Card catalog
  const SHOP_ITEMS = [
    // base
    {name:"Rock", type:"rock", cost:10, lvlReq:1},
    {name:"Paper", type:"paper", cost:10, lvlReq:1},
    {name:"Scissors", type:"scissors", cost:10, lvlReq:1},
    // effects
    {name:"Draw", type:"effect-draw", cost:20, lvlReq:2, desc:"Draw an extra card"},
    {name:"Reveal", type:"effect-reveal", cost:25, lvlReq:3, desc:"Peek opponent choice"},
    {name:"Block Rock", type:"block-rock", cost:25, lvlReq:3, desc:"Rock ineffective"},
    {name:"Block Paper", type:"block-paper", cost:25, lvlReq:3, desc:"Paper ineffective"},
    {name:"Block Scissors", type:"block-scissors", cost:25, lvlReq:3, desc:"Scissors ineffective"},
    // higher tiers
    {name:"Crystal", type:"crystal", cost:60, lvlReq:4},
    {name:"Diamond", type:"diamond", cost:80, lvlReq:5},
    {name:"Match", type:"match", cost:90, lvlReq:6},
    {name:"Water", type:"water", cost:110, lvlReq:7},
    {name:"Slime", type:"slime", cost:130, lvlReq:8},
    {name:"Dark Matter", type:"dark", cost:160, lvlReq:9}
  ];
  function invCap(){ return 9 + (me.level||1); }

  function xpNeededFor(level){ return 100 + 50*level; }

  // -------- UI helpers --------
  const goldLbl = document.getElementById("goldLbl");
  const levelLbl = document.getElementById("levelLbl");
  const xpLbl = document.getElementById("xpLbl");
  const xpFill = document.getElementById("xpFill");
  const regionLbl = document.getElementById("regionLbl");

  function updateHUD(){
    goldLbl.textContent = me.gold|0;
    levelLbl.textContent = me.level|0;
    const need = xpNeededFor(me.level|0);
    xpLbl.textContent = `${me.xp|0}/${need}`;
    xpFill.style.width = Math.max(0, Math.min(100, Math.round((me.xp/need)*100)))+"%";
    const r = regionOf(me.x, me.y);
    regionLbl.textContent = r[5];
  }

  // -------- Presence & login bonus --------
  async function ensurePlayer(){
    const snap = await getDoc(playerRef);
    const today = new Date().toISOString().slice(0,10);
    if (!snap.exists()){
      me = { ...me, ...BASE_START, x: 8, y: 8, lastLoginDay: today, active:true };
      await setDoc(playerRef, me);
      showModal("Welcome!", `<div class='row'><div class='pill'>üéÅ Login Bonus: +5 gold</div></div>`);
      me.gold += 5;
      await updateDoc(playerRef, { gold: me.gold });
    } else {
      me = { ...me, ...snap.data() };
      // daily login bonus
      if (me.lastLoginDay !== today){
        me.gold = (me.gold|0) + 5;
        me.lastLoginDay = today;
        await updateDoc(playerRef, { gold: me.gold, lastLoginDay: today });
        showModal("Daily Bonus", `<div class='row'><div class='pill'>+5 gold</div><small>Thanks for logging in!</small></div>`);
      }
      // became active
      await updateDoc(playerRef, { active:true, lastSeen: serverTimestamp() });
    }
    updateHUD();
    checkLevelUp(); // in case xp carried over
  }

  window.addEventListener("beforeunload", async ()=>{
    try{ await updateDoc(playerRef, { active:false, lastSeen: serverTimestamp() }); }catch(e){}
  });

  document.getElementById("logoutBtn").addEventListener("click", async ()=>{
    try{ await updateDoc(playerRef, { active:false, lastSeen: serverTimestamp() }); }catch(e){}
    location.href = "/"; // back to hub
  });

  // -------- Rendering viewport --------
  const mapEl = document.getElementById("map");
  const frame = document.getElementById("frame");
  const tilesDom = new Map(); // key->div
  const actorsDom = new Map(); // key->div for others and npcs
  const meEl = document.createElement("div");
  meEl.className = "actor me";
  mapEl.appendChild(meEl);

  function screenOrigin(){
    // center me within viewport
    const halfW = Math.floor(VIEW_W/2);
    const halfH = Math.floor(VIEW_H/2);
    const ox = me.x - halfW;
    const oy = me.y - halfH;
    return {ox, oy};
  }

  function tileClassFor(x,y){
    // base by region
    const r = regionOf(x,y);
    let cls = r[6];
    // village visuals inside interior
    const v = isVillageTile(x,y);
    if (v){
      if (isVillageWall(x,y)) return "t-wall";
      if (shops.has(coordKey(x,y))) return "t-shop t-village";
      if (guilds.has(coordKey(x,y))) return "t-guild t-village";
      if (houses.has(coordKey(x,y))) return "t-house t-village";
      return cls+" t-village";
    }
    return cls;
  }

  function renderTiles(){
    const {ox,oy} = screenOrigin();
    const startX = Math.max(0, ox-1);
    const startY = Math.max(0, oy-1);
    const endX = Math.min(MAP_W-1, ox + VIEW_W + 1);
    const endY = Math.min(MAP_H-1, oy + VIEW_H + 1);

    // prune old tiles
    for(const [k, el] of tilesDom){
      const [x,y]=k.split(',').map(Number);
      if (x<startX||y<startY||x>endX||y>endY){ el.remove(); tilesDom.delete(k); }
    }
    // draw window
    for(let y=startY; y<=endY; y++){
      for(let x=startX; x<=endX; x++){
        const key = coordKey(x,y);
        if (!tilesDom.has(key)){
          const t = document.createElement("div");
          t.className = "tile " + tileClassFor(x,y);
          mapEl.appendChild(t);
          tilesDom.set(key,t);
        }
        const t = tilesDom.get(key);
        const sx = (x - ox)*TILE;
        const sy = (y - oy)*TILE;
        t.style.transform = `translate(${sx}px, ${sy}px)`;
      }
    }
    // position me
    meEl.style.transform = `translate(${Math.floor(VIEW_W/2)*TILE}px, ${Math.floor(VIEW_H/2)*TILE}px)`;
  }

  // -------- Pathfinding (A*) --------
  function neighbors(x,y){
    const out=[];
    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
      const nx=x+dx, ny=y+dy;
      if (passable(nx,ny)) out.push([nx,ny]);
    });
    return out;
  }
  function heuristic(a,b){ return Math.abs(a[0]-b[0])+Math.abs(a[1]-b[1]); }
  function aStar(sx,sy, tx,ty){
    if (!passable(tx,ty)) return [];
    const open = new Set([coordKey(sx,sy)]);
    const came = new Map();
    const g = new Map([[coordKey(sx,sy),0]]);
    const f = new Map([[coordKey(sx,sy), heuristic([sx,sy],[tx,ty])]]);

    function lowestF(){
      let bestK=null, best=Infinity;
      for(const k of open){
        const val = f.get(k) ?? Infinity;
        if (val<best){ best=val; bestK=k; }
      }
      return bestK;
    }
    while(open.size){
      const curK = lowestF();
      const [cx,cy]=curK.split(',').map(Number);
      if (cx===tx && cy===ty){
        // reconstruct
        const path = [];
        let k = curK;
        while(came.has(k)){
          const [px,py] = k.split(',').map(Number);
          path.push([px,py]);
          k = came.get(k);
        }
        path.reverse();
        return path;
      }
      open.delete(curK);
      for(const [nx,ny] of neighbors(cx,cy)){
        const nk = coordKey(nx,ny);
        const tentative = (g.get(curK)??Infinity) + 1;
        if (tentative < (g.get(nk)??Infinity)){
          came.set(nk, curK);
          g.set(nk, tentative);
          f.set(nk, tentative + heuristic([nx,ny],[tx,ty]));
          if (!open.has(nk)) open.add(nk);
        }
      }
    }
    return [];
  }

  // Movement handling
  let moveQueue = [];
  let stepping = false;

  function setDestination(tx,ty){
    // blocked by village walls?
    const path = aStar(me.x, me.y, tx, ty);
    moveQueue = path;
  }

  function tickMove(){
    if (stepping || moveQueue.length===0) return;
    stepping = true;
    const [nx,ny] = moveQueue.shift();
    me.x = nx; me.y = ny;
    // Update DB position
    updateDoc(playerRef, { x: me.x, y: me.y, lastSeen: serverTimestamp() }).catch(()=>{});
    // Render
    renderTiles(); updateHUD();
    // Collision checks
    if (!isVillageTile(me.x,me.y)){ // no combat inside villages
      checkEnemyCollision();
      checkPlayerCollision();
    }
    stepping = false;
  }
  setInterval(tickMove, 120); // smoothish

  // Click-to-move
  frame.addEventListener("click",(e)=>{
    const rect = frame.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;
    const gx = Math.floor(cx / TILE);
    const gy = Math.floor(cy / TILE);
    const {ox,oy}=screenOrigin();
    const tx = ox + gx;
    const ty = oy + gy;
    setDestination(tx,ty);
  });

  // -------- Local NPCs (no Firebase writes) --------
  const npcs = []; // {type:'rock'|'paper'|'scissors', x,y, regionKey}
  function spawnNPCs(){
    // per region caps
    const caps = { green:12, yellow:18, red:24, purple:30 };
    const existing = {green:0,yellow:0,red:0,purple:0};
    for(const n of npcs){ existing[n.regionKey]++; }

    function randInt(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }

    for(const r of REGIONS){
      const regionKey = r[4];
      const need = Math.max(0, (caps[regionKey]||0) - (existing[regionKey]||0));
      for(let i=0;i<need;i++){
        // pick type by region
        let pool=["rock"];
        if (regionKey!=="green") pool.push("paper");
        if (regionKey==="red" || regionKey==="purple") pool.push("scissors");
        const type = pool[Math.floor(Math.random()*pool.length)];
        let x, y;
        for(let tries=0;tries<100;tries++){
          x = randInt(r[0], r[2]); y = randInt(r[1], r[3]);
          if (passable(x,y) && !isVillageTile(x,y)) break;
        }
        npcs.push({type, x, y, regionKey});
      }
    }
  }
  spawnNPCs();

  function npcClass(t){
    if (t==="rock") return "npc-rock";
    if (t==="paper") return "npc-paper";
    return "npc-scissors";
  }

  function moveNPCs(){
    for(const n of npcs){
      // chase if within 3
      const d = Math.abs(n.x - me.x) + Math.abs(n.y - me.y);
      let dx = 0, dy = 0;
      if (d<=3){
        if (n.x < me.x) dx=1; else if (n.x > me.x) dx=-1;
        else if (n.y < me.y) dy=1; else if (n.y > me.y) dy=-1;
      } else {
        // wander
        const dir = [[1,0],[-1,0],[0,1],[0,-1]][Math.floor(Math.random()*4)];
        dx = dir[0]; dy = dir[1];
      }
      const nx = n.x + dx, ny = n.y + dy;
      // keep inside region and avoid walls/villages
      const r = REGIONS.find(R=>R[4]===n.regionKey);
      if (nx>=r[0] && nx<=r[2] && ny>=r[1] && ny<=r[3] && passable(nx,ny) && !isVillageTile(nx,ny)){
        n.x = nx; n.y = ny;
      }
    }
  }
  setInterval(()=>{ moveNPCs(); renderActors(); }, 600);

  function renderActors(){
    // remove previous npc dom
    for(const [k, el] of actorsDom){
      if (k.startsWith("npc:")) { el.remove(); actorsDom.delete(k); }
    }
    // draw npcs in viewport
    const {ox,oy}=screenOrigin();
    for(const n of npcs){
      if (n.x<ox-1||n.y<oy-1||n.x>ox+VIEW_W+1||n.y>oy+VIEW_H+1) continue;
      const el = document.createElement("div");
      el.className = `actor ${npcClass(n.type)}`;
      el.style.transform = `translate(${(n.x-ox)*TILE}px, ${(n.y-oy)*TILE}px)`;
      mapEl.appendChild(el);
      actorsDom.set(`npc:${n.x},${n.y}`, el);
    }
    // others are handled via subscription render
  }

  function checkEnemyCollision(){
    // If on same tile as any npc
    const hit = npcs.find(n=> n.x===me.x && n.y===me.y);
    if (!hit) return;
    // create encounter and redirect
    runEncounter(hit.type);
  }

  async function runEncounter(enemyType){
    try{
      const ref = await addDoc(collection(db,"encounters"), {
        type: enemyType, x: me.x, y: me.y, player: username, createdAt: serverTimestamp()
      });
      location.href = `/game/rockbattle.html?encounter=${ref.id}&username=${encodeURIComponent(username)}`;
    }catch(e){ console.error(e); }
  }

  // -------- Other Players (active only) --------
  const others = new Map(); // name -> data
  onSnapshot(query(othersRef, where("active","==",true)), (snap)=>{
    // rebuild
    const present = new Set();
    snap.forEach(d=>{
      const pl = d.data();
      if (pl.name===username) return; // skip self
      others.set(pl.name, pl);
      present.add(pl.name);
    });
    // remove missing
    for(const k of Array.from(others.keys())){
      if (!present.has(k)) others.delete(k);
    }
    drawOthers();
  });

  function drawOthers(){
    // prune old player dom
    for(const [k, el] of actorsDom){
      if (k.startsWith("p:")){ el.remove(); actorsDom.delete(k); }
    }
    const {ox,oy}=screenOrigin();
    for(const [name,pl] of others){
      if (!pl || typeof pl.x!=="number") continue;
      if (pl.active!==true) continue;
      if (pl.x<ox-1||pl.y<oy-1||pl.x>ox+VIEW_W+1||pl.y>oy+VIEW_H+1) continue;
      const el = document.createElement("div");
      el.className = "actor player";
      el.title = `${name}${pl.guild?(" ¬∑ "+pl.guild):""}`;
      el.style.transform = `translate(${(pl.x-ox)*TILE}px, ${(pl.y-oy)*TILE}px)`;
      mapEl.appendChild(el);
      actorsDom.set(`p:${name}`, el);
    }
  }

  async function checkPlayerCollision(){
    for(const [name,pl] of others){
      if (!pl) continue;
      if (pl.x===me.x && pl.y===me.y){
        if (me.guild && pl.guild && me.guild===pl.guild){
          // open trade
          openTrade(name, pl);
        } else {
          // duel
          try{
            const ref = await addDoc(collection(db,"duels"), {
              a: username, b: name, x: me.x, y: me.y, createdAt: serverTimestamp()
            });
            location.href = `/game/rockduel.html?duel=${ref.id}&username=${encodeURIComponent(username)}`;
          }catch(e){ console.error(e); }
        }
        break;
      }
    }
  }

  // -------- Chat (15-tile radius) --------
  const msgsEl = document.getElementById("messages");
  const chatForm = document.getElementById("chatForm");
  const chatInput = document.getElementById("chatInput");
  chatForm.addEventListener("submit", async (e)=>{
    e.preventDefault();
    const text = chatInput.value.trim();
    if (!text) return;
    const r = regionOf(me.x, me.y);
    await addDoc(collection(db,"messages"), {
      user: username, text, x: me.x, y: me.y, region: r[4], createdAt: serverTimestamp()
    });
    chatInput.value = "";
  });

  // read latest nearby messages (simple polling with onSnapshot on recent)
  onSnapshot(query(collection(db,"messages"), orderBy("createdAt","desc"), limit(60)), (snap)=>{
    const rows=[];
    snap.forEach(d=>{
      const m=d.data();
      if (typeof m.x!=="number"||typeof m.y!=="number") return;
      const dist = Math.abs(m.x - me.x) + Math.abs(m.y - me.y);
      if (dist<=15){
        rows.push(m);
      }
    });
    rows.sort((a,b)=> (a.createdAt?.seconds||0)-(b.createdAt?.seconds||0));
    msgsEl.innerHTML = rows.map(r=>(
      `<div class="msg"><b>${r.user}</b>: ${escapeHtml(r.text)} <small>(${r.x},${r.y})</small></div>`
    )).join("");
    msgsEl.scrollTop = msgsEl.scrollHeight;
  });

  function escapeHtml(s){ return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])) }

  // -------- Shop / Guild / Inventory --------
  const modalBack = document.getElementById("modalBack");
  const modalTitle = document.getElementById("modalTitle");
  const modalBody = document.getElementById("modalBody");
  const modalClose = document.getElementById("modalClose");
  modalClose.addEventListener("click", ()=> closeModalAndStepAway());

  function showModal(title, html){
    modalTitle.textContent = title;
    modalBody.innerHTML = html;
    modalBack.style.display="flex";
  }
  function closeModal(){
    modalBack.style.display="none";
    modalBody.innerHTML = "";
  }
  function closeModalAndStepAway(){
    closeModal();
    // move 1 step away from where we opened
    const options = [[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dx,dy] of options){
      const nx = me.x+dx, ny = me.y+dy;
      if (passable(nx,ny)) { me.x=nx; me.y=ny; updateDoc(playerRef,{x:me.x,y:me.y}); break; }
    }
    renderTiles(); updateHUD();
  }

  document.getElementById("shopBtn").addEventListener("click", ()=>{
    if (!shops.has(coordKey(me.x,me.y))) return showModal("Shop", "<div>Stand on üí∞ to open the shop.</div>");
    openShop();
  });
  document.getElementById("guildBtn").addEventListener("click", ()=>{
    if (!guilds.has(coordKey(me.x,me.y))) return showModal("Guild Hall", "<div>Stand on üèõÔ∏è to visit the guild hall.</div>");
    openGuild();
  });
  document.getElementById("invBtn").addEventListener("click", openInventory);

  function cardTile(c, idx, controls=true){
    const lock = (me.level < (c.lvlReq||1)) ? `<span class="pill danger">Lvl ${c.lvlReq||1}</span>` : "";
    const extra = c.desc ? `<small>${c.desc}</small>` : "";
    const idLine = c.id ? `<small style="color:#94a3b8">#${c.id.slice(0,6)}</small>` : "";
    const removeBtn = controls ? `<button class="btn secondary" data-remove="${idx}">Remove</button>` : "";
    return `<div class="card">
      <b>${c.name}</b>${idLine}
      <div class="row">
        <span class="pill">Type: ${c.type}</span>
        ${lock}
      </div>
      ${extra}
      ${controls? removeBtn:""}
    </div>`;
  }

  function openInventory(){
    const html = `
      <div class="row"><div class="pill">Capacity: ${me.inventory.length}/${invCap()}</div></div>
      <div class="invGrid">
        ${me.inventory.map((c,i)=> cardTile(c,i,true)).join("")}
      </div>
    `;
    showModal("Inventory", html);
    // wire remove
    modalBody.querySelectorAll("[data-remove]").forEach(btn=>{
      btn.addEventListener("click", async ()=>{
        const idx = +btn.getAttribute("data-remove");
        const [c] = me.inventory.splice(idx,1);
        await updateDoc(playerRef, { inventory: me.inventory });
        openInventory();
      });
    });
  }

  function openShop(){
    const items = SHOP_ITEMS.map((it, i)=>(
      `<div class="card">
        <b>${it.name}</b>
        <div class="row">
          <span class="pill">Lvl ${it.lvlReq}</span>
          <span class="pill">üí∞ ${it.cost}</span>
        </div>
        ${it.desc? `<small>${it.desc}</small>`:""}
        <button class="btn" data-buy="${i}">Buy</button>
      </div>`
    )).join("");
    const html = `
      <div class="row">
        <div class="pill">Gold: ${me.gold}</div>
        <div class="pill">Inv: ${me.inventory.length}/${invCap()}</div>
      </div>
      <div class="invGrid">${items}</div>
    `;
    showModal("Shop", html);
    modalBody.querySelectorAll("[data-buy]").forEach(btn=>{
      btn.addEventListener("click", async ()=>{
        const i = +btn.getAttribute("data-buy");
        const it = SHOP_ITEMS[i];
        if (me.level < it.lvlReq) return alert("Level too low.");
        if (me.gold < it.cost) return alert("Not enough gold.");
        if (me.inventory.length >= invCap()) return alert("Inventory full.");
        const card = { id: crypto.randomUUID(), name: it.name, type: it.type, lvlReq: it.lvlReq };
        me.gold -= it.cost; me.inventory.push(card);
        await updateDoc(playerRef, { gold: me.gold, inventory: me.inventory });
        openShop(); updateHUD();
      });
    });
  }

  function openGuild(){
    const html = `
      <div class="row">
        <div class="pill">Your Level: ${me.level}</div>
        <div class="pill">Current Guild: ${me.guild||"‚Äî"}</div>
      </div>
      <div class="invGrid">
        ${["rock","paper","scissors"].map(g=>`
          <div class="card">
            <b>${g[0].toUpperCase()+g.slice(1)} Guild</b>
            <small>Requires Level 5+</small>
            <button class="btn" data-join="${g}">Join</button>
          </div>`).join("")}
      </div>
    `;
    showModal("Guild Hall", html);
    modalBody.querySelectorAll("[data-join]").forEach(btn=>{
      btn.addEventListener("click", async ()=>{
        const g = btn.getAttribute("data-join");
        if (me.level < 5) return alert("You must be level 5 or higher.");
        me.guild = g;
        await updateDoc(playerRef, { guild: g });
        openGuild(); // refresh
      });
    });
  }

  // -------- Level-up flow --------
  async function checkLevelUp(){
    const need = xpNeededFor(me.level);
    if (me.xp >= need){
      // level up: offer 2 random items with lvlReq <= newLevel
      const newLevel = me.level + 1;
      const pool = SHOP_ITEMS.filter(i=> i.lvlReq <= newLevel);
      function pick(){ return pool[Math.floor(Math.random()*pool.length)]; }
      const a = pick(), b = pick();
      const html = `
        <div class="row"><div class="pill ok">Level Up! ‚Üí ${newLevel}</div></div>
        <p>Pick one reward:</p>
        <div class="invGrid">
          <div class="card">
            <b>${a.name}</b><small>Lvl ${a.lvlReq} ¬∑ ${a.cost}g</small>
            <button class="btn" id="pickA">Choose</button>
          </div>
          <div class="card">
            <b>${b.name}</b><small>Lvl ${b.lvlReq} ¬∑ ${b.cost}g</small>
            <button class="btn" id="pickB">Choose</button>
          </div>
        </div>`;
      showModal("Level Up!", html);
      const choose = async (it)=>{
        if (me.inventory.length >= invCap()) { alert("Inventory full, reward dropped."); }
        else me.inventory.push({ id: crypto.randomUUID(), name: it.name, type: it.type, lvlReq: it.lvlReq });
        me.level = newLevel; me.xp = 0;
        await updateDoc(playerRef, { level: me.level, xp: 0, inventory: me.inventory });
        closeModal();
        updateHUD();
      };
      modalBody.querySelector("#pickA").addEventListener("click", ()=> choose(a));
      modalBody.querySelector("#pickB").addEventListener("click", ()=> choose(b));
    }
  }

  // -------- Trade flow (same guild collision) --------
  async function openTrade(otherName, otherData){
    // simple two-party handshake in Firestore: trades/{id}
    const myOffer = { cardId:"" };
    const theirOffer = { cardId:"" };
    const html = `
      <div class="row"><div class="pill">Trading with <b>${otherName}</b></div></div>
      <div class="row">
        <div style="flex:1">
          <b>Your Offer</b>
          <div class="invGrid">
            ${me.inventory.map(c=>`
              <div class="card">
                <b>${c.name}</b><small>#${c.id.slice(0,6)}</small>
                <button class="btn secondary" data-choose="${c.id}">Offer</button>
              </div>`).join("")}
          </div>
          <div id="youOfferView" class="row"><div class="pill">Selected: ‚Äî</div></div>
        </div>
        <div style="flex:1">
          <b>${otherName}'s Inventory</b>
          <div id="otherInv" class="invGrid"><small>Waiting...</small></div>
          <div id="themOfferView" class="row"><div class="pill">Selected: ‚Äî</div></div>
        </div>
      </div>
      <div class="row">
        <button id="acceptBtn" class="btn">Accept</button>
        <button id="cancelBtn" class="btn secondary">Cancel</button>
      </div>
    `;
    showModal("Guild Trade", html);

    // Load other's inventory on demand (snapshot read)
    const otherSnap = await getDoc(doc(db,"players",otherName));
    const otherInv = (otherSnap.exists() ? (otherSnap.data().inventory || []) : []);
    const otherInvBox = document.getElementById("otherInv");
    otherInvBox.innerHTML = otherInv.map(c=>`
      <div class="card">
        <b>${c.name}</b><small>#${(c.id||'').slice(0,6)}</small>
        <button class="btn secondary" data-choose-them="${c.id}">Offer</button>
      </div>`).join("");

    const youView = document.getElementById("youOfferView");
    const themView = document.getElementById("themOfferView");

    modalBody.querySelectorAll("[data-choose]").forEach(b=>{
      b.addEventListener("click", ()=>{
        myOffer.cardId = b.getAttribute("data-choose");
        youView.innerHTML = `<div class="pill">Selected: ${myOffer.cardId.slice(0,6)}</div>`;
      });
    });
    modalBody.querySelectorAll("[data-choose-them]").forEach(b=>{
      b.addEventListener("click", ()=>{
        theirOffer.cardId = b.getAttribute("data-choose-them");
        themView.innerHTML = `<div class="pill">Selected: ${theirOffer.cardId.slice(0,6)}</div>`;
      });
    });

    document.getElementById("cancelBtn").addEventListener("click", closeModalAndStepAway);
    document.getElementById("acceptBtn").addEventListener("click", async ()=>{
      if (!myOffer.cardId || !theirOffer.cardId) return alert("Select offers on both sides.");
      // Perform swap with transaction
      try{
        await runTransaction(db, async (tx)=>{
          const meSnap = await tx.get(playerRef);
          const otRef = doc(db,"players",otherName);
          const otSnap = await tx.get(otRef);
          if (!meSnap.exists() || !otSnap.exists()) throw new Error("Missing players");
          const mine = meSnap.data();
          const othr = otSnap.data();
          const myIdx = (mine.inventory||[]).findIndex(c=> c.id===myOffer.cardId);
          const thIdx = (othr.inventory||[]).findIndex(c=> c.id===theirOffer.cardId);
          if (myIdx<0 || thIdx<0) throw new Error("Item missing");
          const myCard = mine.inventory[myIdx];
          const thCard = othr.inventory[thIdx];
          if ((mine.inventory.length -1 + 1) > invCap()) throw new Error("Your inventory would overflow.");
          if ((othr.inventory.length -1 + 1) > (9 + (othr.level||1))) throw new Error("Their inventory would overflow.");
          mine.inventory.splice(myIdx,1); othr.inventory.splice(thIdx,1);
          mine.inventory.push(thCard); othr.inventory.push(myCard);
          tx.update(playerRef, { inventory: mine.inventory });
          tx.update(otRef, { inventory: othr.inventory });
        });
        alert("Trade complete!");
        closeModalAndStepAway();
        // push each away 1 step
        const options = [[1,0],[-1,0],[0,1],[0,-1]];
        const nx = me.x + options[Math.floor(Math.random()*4)][0];
        const ny = me.y + options[Math.floor(Math.random()*4)][1];
        if (passable(nx,ny)){ me.x=nx; me.y=ny; updateDoc(playerRef,{x:me.x,y:me.y}); renderTiles(); }
      }catch(e){
        alert("Trade failed: " + e.message);
      }
    });
  }

  // -------- Opening shop/guild by stepping on them --------
  let lastStructure = "";
  function structureCheckOpen(){
    const key = coordKey(me.x,me.y);
    if (shops.has(key)) openShop();
    else if (guilds.has(key)) openGuild();
    lastStructure = key;
  }

  // -------- Boot --------
  await ensurePlayer();
  renderTiles(); renderActors(); updateHUD();

  // reflect movement to open shop/guild if stepping
  setInterval(structureCheckOpen, 300);

  // Draw others periodically centered
  setInterval(drawOthers, 400);

  // -------- Utility to grant XP (for testing; remove in prod) --------
  // window.giveXP = async (n)=>{ me.xp+=n; await updateDoc(playerRef,{xp:me.xp}); updateHUD(); checkLevelUp(); };

</script>
</body>
</html>
