<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>‚úäüìÑ‚úÇÔ∏è Rock Paper Scissors MMO</title>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<style>
  :root{
    --ink:#0f172a; --muted:#6b7280; --panel:#ffffff; --br:#e5e7eb;
    --shadow:0 10px 30px rgba(15,23,42,.08); --radius:16px; --tap:56px;
    --green:#10b981; --yellow:#d97706; --red:#ef4444; --purple:#8b5cf6;
    --wall:#9ca3af; --house:#b45309; --shop:#16a34a;
    --guild:#2563eb; --chatH:140px; --hudH:64px;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Arial;color:var(--ink);background:#fafafa;}
  button{font-family:inherit}

  /* Top HUD */
  .topbar{
    position:fixed; top:0; left:0; right:0; min-height:var(--hudH);
    background:#fff; border-bottom:1px solid var(--br);
    display:flex; align-items:center; gap:10px; padding:8px 10px; z-index:20; flex-wrap:wrap;
  }
  .stat{display:flex;align-items:center;gap:6px;background:#fff;border:1px solid var(--br);border-radius:12px;padding:8px 10px}
  .xpbar{position:relative;height:8px;background:#f3f4f6;border-radius:999px;overflow:hidden;min-width:140px;border:1px solid var(--br)}
  .xpbar>i{display:block;height:100%;width:0;background:linear-gradient(90deg,#a7f3d0,#22c55e)}
  .regionTag{margin-left:auto;font-weight:800;padding:8px 12px;border-radius:999px;border:1px solid var(--br);background:#fff}
  .logout{border:1px solid var(--br);background:#fff;border-radius:10px;padding:8px 10px;cursor:pointer}
  .fsbtn{border:1px solid var(--br);background:#111827;color:#fff;border-radius:10px;padding:8px 10px;cursor:pointer;font-weight:800}

  /* Layout frame */
  .frameWrap{
    position:fixed; top:calc(var(--hudH) + 8px); left:0; right:0; bottom:calc(var(--chatH) + env(safe-area-inset-bottom) + 8px);
    display:grid; place-items:center;
  }
  .frame{
    width:min(100vw, 820px);
    height:min( calc(100vh - var(--hudH) - var(--chatH) - 24px), 820px );
    background:#fff; border:1px solid var(--br); border-radius:20px; box-shadow:var(--shadow);
    overflow:hidden; position:relative; touch-action:manipulation;
  }
  .coords{
    position:absolute; top:6px; left:8px; background:rgba(255,255,255,.9); border:1px solid var(--br);
    border-radius:8px; padding:4px 8px; font-size:12px; z-index:4;
  }

  /* Map (grid outlines per region) */
  .map{ position:absolute; inset:0; overflow:hidden; background:#ffffff; image-rendering:pixelated; font-size:14px }
  .tile{
    position:absolute; width:32px; height:32px; user-select:none; background:transparent; z-index:1;
    box-shadow: inset 0 0 0 1px rgba(0,0,0,.06);
  }
  .t-green { box-shadow: inset 0 0 0 1px var(--green); }
  .t-yellow{ box-shadow: inset 0 0 0 1px var(--yellow); }
  .t-red   { box-shadow: inset 0 0 0 1px var(--red); }
  .t-purple{ box-shadow: inset 0 0 0 1px var(--purple); }

  /* Village overlays */
  .t-wall{ background:#f3f4f6; outline:2px solid var(--wall); }
  .t-village { background:rgba(0,0,0,0.02); }
  .t-house::after{ content:"üè†"; position:absolute; inset:0; display:grid; place-items:center; font-size:16px }
  .t-shop::after{ content:"üí∞"; position:absolute; inset:0; display:grid; place-items:center; font-size:16px }
  .t-guild::after{ content:"üèõÔ∏è"; position:absolute; inset:0; display:grid; place-items:center; font-size:16px }

  /* Decorative emoji ‚Äî non-interactive */
  .tile[data-deco]::before{
    content: attr(data-deco);
    position:absolute; inset:0; display:grid; place-items:center;
    font-size:16px; opacity:.85; pointer-events:none;
  }

  /* Actors (above tiles) */
  .actor{ position:absolute; width:32px; height:32px; display:grid; place-items:center; pointer-events:none; z-index:3 }
  .label{
    position:absolute; top:-14px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,.7); color:#fff;
    font-size:10px; padding:2px 6px; border-radius:999px; white-space:nowrap; z-index:4;
  }
  .me::after{ content:"üßô"; font-size:22px }
  .player::after{ content:"üßô"; opacity:.9 }
  .npc-rock::after{ content:"ü™®"; }
  .npc-paper::after{ content:"üìÑ"; }
  .npc-scissors::after{ content:"‚úÇÔ∏è"; }
  .npc-sprite::after{ content:"üßö"; }
  .npc-golem::after{ content:"üóø"; }
  .npc-lizard::after{ content:"ü¶é"; }
  .npc-dragon::after{ content:"üêâ"; }
  .npc-knight::after{ content:"üõ°Ô∏è"; }
  .inactive{ display:none }

  /* Chat panel */
  .chat{
    position:fixed; left:0; right:0; bottom:0; height:var(--chatH);
    border-top:1px solid var(--br); background:#fff; display:grid; grid-template-rows:1fr auto; z-index:15;
    padding-bottom:max(0px, env(safe-area-inset-bottom));
  }
  .msgs{ padding:8px 10px; overflow:auto }
  .msg{ font-size:14px; margin:4px 0; }
  .msg small{ color:var(--muted) }
  .chatForm{ display:flex; gap:8px; padding:8px; border-top:1px solid var(--br) }
  .input{ flex:1; padding:12px; border:1px solid var(--br); border-radius:12px; outline:none; min-width:0 }
  .btn{ padding:12px 14px; border:1px solid var(--br); background:#111827; color:#fff; border-radius:12px; cursor:pointer; font-weight:800; min-width:0 }
  .btn.secondary{ background:#fff; color:#111827 }

  /* Modal */
  .modalBack{ position:fixed; inset:0; background:rgba(0,0,0,.25); display:none; align-items:center; justify-content:center; z-index:30 }
  .modal{ width:min(92vw, 720px); max-height:80vh; overflow:auto; background:#fff; border-radius:16px; box-shadow:var(--shadow); border:1px solid var(--br) }
  .modal-head{ padding:12px 14px; border-bottom:1px solid var(--br); font-weight:900; display:flex; align-items:center; justify-content:space-between }
  .modal-body{ padding:12px 14px; display:grid; gap:10px }
  .row{ display:flex; gap:10px; flex-wrap:wrap }
  .pill{ display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid var(--br); border-radius:999px; background:#fff }
  .invGrid{ display:grid; grid-template-columns:repeat(auto-fill, minmax(120px,1fr)); gap:10px }
  .card{ border:1px solid var(--br); border-radius:12px; padding:10px; background:#fff; display:flex; flex-direction:column; gap:6px }
  .card b{ font-size:14px }
  .card small{ color:#6b7280 }
  .danger{ color:#b91c1c; font-weight:800 }
  .ok{ color:#16a34a; font-weight:800 }

  /* Mobile polish */
  @media (max-width:720px){
    .xpbar{ min-width:110px }
  }
  @media (max-width:520px){
    .chatForm{ flex-wrap:wrap }
    .chatForm .input{ flex:1 1 100% }
    .chatForm .btn{ flex:1 1 calc(50% - 4px) }
  }
</style>
</head>
<body>
  <!-- TOP HUD -->
  <div class="topbar">
    <div class="stat">üßô <b id="usernameLbl">Player</b></div>
    <div class="stat">üí∞ Gold: <b id="goldLbl">0</b></div>
    <div class="stat">‚≠ê Lv <b id="levelLbl">1</b></div>
    <div class="stat" id="guildStat" style="display:none">üè∞ Guild: <b id="guildLbl">‚Äî</b></div>
    <div class="stat xp">
      <div class="xpbar"><i id="xpFill"></i></div>
      <small id="xpLbl" style="margin-left:6px;color:var(--muted)">0/0</small>
    </div>
    <div class="regionTag" id="regionLbl">Rocky Roads</div>
    <button id="fsBtn" class="fsbtn" title="Fullscreen">‚õ∂ Fullscreen</button>
    <button id="logoutBtn" class="logout">Logout</button>
  </div>

  <!-- VIEWPORT / MAP -->
  <div class="frameWrap">
    <div id="frame" class="frame">
      <div class="coords" id="coordLbl">X:0 Y:0</div>
      <div id="map" class="map" aria-label="map"></div>
    </div>
  </div>

  <!-- CHAT + ACTIONS -->
  <div class="chat">
    <div id="messages" class="msgs"></div>
    <form id="chatForm" class="chatForm">
      <input id="chatInput" class="input" maxlength="160" placeholder="Say something to players within 15 tiles..." />
      <button class="btn" type="submit">Send</button>
      <button id="shopBtn" class="btn secondary" type="button">Shop</button>
      <button id="guildBtn" class="btn secondary" type="button">Guild</button>
      <button id="invBtn" class="btn secondary" type="button">Inventory</button>
    </form>
  </div>

  <!-- Modals -->
  <div id="modalBack" class="modalBack">
    <div class="modal">
      <div class="modal-head">
        <div id="modalTitle">Title</div>
        <button id="modalClose" class="btn secondary" type="button">Close</button>
      </div>
      <div id="modalBody" class="modal-body"></div>
    </div>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import {
    getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot, serverTimestamp,
    collection, addDoc, query, where, limit, orderBy, runTransaction
  } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

  // -------- Firebase --------
  const firebaseConfig = {
    apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
    authDomain: "bible-game-246c0.firebaseapp.com",
    projectId: "bible-game-246c0",
    storageBucket: "bible-game-246c0.appspot.com",
    messagingSenderId: "959619818996",
    appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // -------- URL / Session --------
  const params = new URLSearchParams(location.search);
  let username = (params.get("username") || localStorage.getItem("gh.username") || "").trim();
  if (!username) {
    alert("Missing username. Returning to lobby.");
    location.href = "/"; // fallback
  }
  document.getElementById("usernameLbl").textContent = username;

  // -------- Map / Regions --------
  let TILE = 32;                // tile size in pixels
  let viewW = 23, viewH = 23;   // visible tiles (dynamic)
  const MAP_W = 120;
  const MAP_H = 120;

  // [x1,y1,x2,y2, key, name, cssClass]
  const REGIONS = [
    [0,0, 59,59, "green","Rocky Roads","t-green"],
    [60,0, 119,59,"yellow","Parchment Plateau","t-yellow"],
    [0,60, 59,119,"red","Scissors Point","t-red"],
    [60,60,119,119,"purple","Probabilities Plain","t-purple"]
  ];

  const VILLAGES = [
    { name:"Westhold", x:14, y:14, w:10, h:10, region:"green" },
    { name:"Sunfold",  x:80, y:10, w:10, h:10, region:"yellow" },
    { name:"Edgekeep", x:16, y:86, w:10, h:10, region:"red" },
    { name:"Mystvale", x:88, y:88, w:10, h:10, region:"purple" },
  ];

  const walls = new Set();
  const houses = new Set();
  const shops  = new Set();
  const guilds = new Set();
  const entrances = new Set(); // carved openings

  // Decorative positions (purely visual)
  const deco = new Map(); // key -> emoji
  const DECO_EMOJI = { green:"ü™®", red:"ü™µ", yellow:"üíß", purple:"üå≥" };

  const coordKey = (x,y)=> `${x},${y}`;
  const inRect = (x,y,r)=> x>=r[0] && x<=r[2] && y>=r[1] && y<=r[3];
  const regionOf = (x,y)=> REGIONS.find(r=> inRect(x,y,r)) || REGIONS[0];

  function isVillageTile(x,y){
    for(const v of VILLAGES){
      if (x>=v.x && x< v.x+v.w && y>=v.y && y< v.y+v.h) return v;
    }
    return null;
  }
  function isVillageWall(x,y){
    const v = isVillageTile(x,y);
    if (!v) return false;
    const onEdge = (x===v.x || y===v.y || x===v.x+v.w-1 || y===v.y+v.h-1);
    if (!onEdge) return false;
    return !entrances.has(coordKey(x,y)); // entrance tiles are open
  }

  // Carve a 3-tile entrance on one side (top by default)
  function carveEntrance(v, side="top"){
    const midX = v.x + Math.floor(v.w/2);
    const midY = v.y + Math.floor(v.h/2);
    const push = (x,y)=> entrances.add(coordKey(x,y));
    if (side==="top"){
      for(let dx=-1; dx<=1; dx++) push(midX+dx, v.y);
    } else if (side==="bottom"){
      for(let dx=-1; dx<=1; dx++) push(midX+dx, v.y+v.h-1);
    } else if (side==="left"){
      for(let dy=-1; dy<=1; dy++) push(v.x, midY+dy);
    } else if (side==="right"){
      for(let dy=-1; dy<=1; dy++) push(v.x+v.w-1, midY+dy);
    }
  }

  // Prepare village structures + carve entrances
  for(const v of VILLAGES){
    carveEntrance(v, "top"); // change side if you like
    for(let y=v.y; y<v.y+v.h; y++){
      for(let x=v.x; x<v.x+v.w; x++){
        if (isVillageWall(x,y)) walls.add(coordKey(x,y));
      }
    }
    houses.add(coordKey(v.x+2, v.y+2));
    houses.add(coordKey(v.x+v.w-3, v.y+2));
    shops.add(coordKey(v.x+Math.floor(v.w/2), v.y+Math.floor(v.h/2)));
    guilds.add(coordKey(v.x+2, v.y+v.h-3));
  }

  // Scatter decorative emojis in each region (no gameplay effect)
  function scatterDeco(){
    const density = 0.02; // 2% of tiles per region
    for(const r of REGIONS){
      const [x1,y1,x2,y2,key] = r;
      const area = (x2 - x1 + 1) * (y2 - y1 + 1);
      const target = Math.floor(area * density);
      let placed = 0, tries = 0;
      while(placed < target && tries < target * 10){
        tries++;
        const x = x1 + Math.floor(Math.random()*(x2 - x1 + 1));
        const y = y1 + Math.floor(Math.random()*(y2 - y1 + 1));
        const k = coordKey(x,y);
        // avoid walls, village walls, shops/guilds/houses, and duplicate placements
        if (isVillageWall(x,y) || isVillageTile(x,y) || walls.has(k) || shops.has(k) || guilds.has(k) || houses.has(k) || deco.has(k)) continue;
        deco.set(k, DECO_EMOJI[key] || "");
        placed++;
      }
    }
  }
  scatterDeco();

  const passable = (x,y)=> !(x<0||y<0||x>=MAP_W||y>=MAP_H) && !walls.has(coordKey(x,y));

  // -------- Player State --------
  const playerRef = doc(db, "players", username);
  const othersRef = collection(db, "players");
  let me = {
    name: username,
    x: 8, y: 8, level:1, xp:0, gold: 30,
    guild: "", inventory: [],
    active: true, lastLoginDay: "", lastSeen: serverTimestamp()
  };
  const BASE_START = {
    level:1, xp:0, gold:30,
    inventory: [
      {id:crypto.randomUUID(), name:"Rock", type:"rock", lvlReq:1},
      {id:crypto.randomUUID(), name:"Rock", type:"rock", lvlReq:1},
      {id:crypto.randomUUID(), name:"Rock", type:"rock", lvlReq:1},
      {id:crypto.randomUUID(), name:"Paper", type:"paper", lvlReq:1},
      {id:crypto.randomUUID(), name:"Paper", type:"paper", lvlReq:1},
      {id:crypto.randomUUID(), name:"Paper", type:"paper", lvlReq:1},
      {id:crypto.randomUUID(), name:"Scissors", type:"scissors", lvlReq:1},
      {id:crypto.randomUUID(), name:"Scissors", type:"scissors", lvlReq:1},
      {id:crypto.randomUUID(), name:"Scissors", type:"scissors", lvlReq:1},
    ]
  };

  // Shop catalog
  const SHOP_ITEMS = [
    {name:"Rock", type:"rock", cost:10, lvlReq:1},
    {name:"Paper", type:"paper", cost:10, lvlReq:1},
    {name:"Scissors", type:"scissors", cost:10, lvlReq:1},
    {name:"Draw", type:"effect-draw", cost:20, lvlReq:2, desc:"Draw an extra card"},
    {name:"Reveal", type:"effect-reveal", cost:25, lvlReq:3, desc:"Peek opponent choice"},
    {name:"Block Rock", type:"block-rock", cost:25, lvlReq:3, desc:"Rock ineffective"},
    {name:"Block Paper", type:"block-paper", cost:25, lvlReq:3, desc:"Paper ineffective"},
    {name:"Block Scissors", type:"block-scissors", cost:25, lvlReq:3, desc:"Scissors ineffective"},
    {name:"Crystal", type:"crystal", cost:60, lvlReq:4},
    {name:"Diamond", type:"diamond", cost:80, lvlReq:5},
    {name:"Match", type:"match", cost:90, lvlReq:6},
    {name:"Water", type:"water", cost:110, lvlReq:7},
    {name:"Slime", type:"slime", cost:130, lvlReq:8},
    {name:"Dark Matter", type:"dark", cost:160, lvlReq:9}
  ];
  const invCap = ()=> 9 + (me.level||1);

  /* ‚ñ∂ XP formula update: max XP to level up = 30 + 20 * level */
  const xpNeededFor = level => 30 + 20*level;

  // -------- UI refs --------
  const goldLbl = document.getElementById("goldLbl");
  const levelLbl = document.getElementById("levelLbl");
  const xpLbl = document.getElementById("xpLbl");
  const xpFill = document.getElementById("xpFill");
  const regionLbl = document.getElementById("regionLbl");
  const guildLbl = document.getElementById("guildLbl");
  const guildStat = document.getElementById("guildStat");
  const coordLbl = document.getElementById("coordLbl");

  function updateHUD(){
    goldLbl.textContent = me.gold|0;
    levelLbl.textContent = me.level|0;
    const need = xpNeededFor(me.level|0);
    xpLbl.textContent = `${me.xp|0}/${need}`;
    xpFill.style.width = Math.max(0, Math.min(100, Math.round((me.xp/need)*100)))+"%";
    const r = regionOf(me.x, me.y);
    regionLbl.textContent = r[5];
    if (me.guild){ guildLbl.textContent = me.guild; guildStat.style.display="flex"; } else { guildStat.style.display="none"; }
    coordLbl.textContent = `X:${me.x} Y:${me.y}`;
    meLabel.textContent = `Lv ${me.level}`;
  }

  // -------- Presence & login bonus --------
  async function ensurePlayer(){
    const snap = await getDoc(playerRef);
    const today = new Date().toISOString().slice(0,10);
    if (!snap.exists()){
      me = { ...me, ...BASE_START, x: 8, y: 8, lastLoginDay: today, active:true };
      await setDoc(playerRef, me);
      showModal("Welcome!", `<div class='row'><div class='pill'>üéÅ Login Bonus: +5 gold</div></div>`);
      me.gold += 5;
      await updateDoc(playerRef, { gold: me.gold });
    } else {
      me = { ...me, ...snap.data() };
      if (me.lastLoginDay !== today){
        me.gold = (me.gold|0) + 5;
        me.lastLoginDay = today;
        await updateDoc(playerRef, { gold: me.gold, lastLoginDay: today });
        showModal("Daily Bonus", `<div class='row'><div class='pill'>+5 gold</div><small>Welcome back!</small></div>`);
      }
      await updateDoc(playerRef, { active:true, lastSeen: serverTimestamp() });
    }
    updateHUD();
    checkLevelUp();
  }

  window.addEventListener("beforeunload", async ()=>{
    try{ await updateDoc(playerRef, { active:false, lastSeen: serverTimestamp() }); }catch(e){}
  });

  document.getElementById("logoutBtn").addEventListener("click", async ()=>{
    try{ await updateDoc(playerRef, { active:false, lastSeen: serverTimestamp() }); }catch(e){}
    location.href = "/"; // back to hub
  });

  // -------- Fullscreen --------
  const fsBtn = document.getElementById("fsBtn");
  fsBtn.addEventListener("click", async ()=>{
    try{
      if (!document.fullscreenElement){
        await document.documentElement.requestFullscreen();
        fsBtn.textContent = "‚§¢ Exit Fullscreen";
      } else {
        await document.exitFullscreen();
        fsBtn.textContent = "‚õ∂ Fullscreen";
      }
    }catch(e){ /* ignore */ }
  });
  document.addEventListener("fullscreenchange", ()=>{
    fsBtn.textContent = document.fullscreenElement ? "‚§¢ Exit Fullscreen" : "‚õ∂ Fullscreen";
  });

  // -------- Rendering viewport (dynamic) --------
  const mapEl = document.getElementById("map");
  const frame = document.getElementById("frame");
  const tilesDom = new Map(); // key->div
  const actorsDom = new Map(); // key->container

  // self actor container with label
  const meWrap = document.createElement("div");
  meWrap.className = "actor me";
  const meLabel = document.createElement("div");
  meLabel.className = "label";
  meLabel.textContent = "Lv 1";
  meWrap.appendChild(meLabel);
  mapEl.appendChild(meWrap);

  function recalcViewport(){
    const tilesAcross = Math.max(7, Math.floor(frame.clientWidth  / TILE));
    const tilesDown   = Math.max(7, Math.floor(frame.clientHeight / TILE));
    viewW = tilesAcross % 2 ? tilesAcross : tilesAcross - 1;
    viewH = tilesDown   % 2 ? tilesDown   : tilesDown   - 1;
  }
  window.addEventListener("resize", ()=>{ recalcViewport(); renderTiles(); });
  window.addEventListener("orientationchange", ()=>{ setTimeout(()=>{ recalcViewport(); renderTiles(); }, 150); });

  function screenOrigin(){
    const halfW = Math.floor(viewW/2);
    const halfH = Math.floor(viewH/2);
    const ox = me.x - halfW;
    const oy = me.y - halfH;
    return {ox, oy};
  }

  function tileClassFor(x,y){
    const r = regionOf(x,y);
    let cls = r[6]; // region outline class
    const v = isVillageTile(x,y);
    if (v){
      if (isVillageWall(x,y)) return `t-wall`;
      let extra = " t-village";
      const key = coordKey(x,y);
      if (shops.has(key)) extra += " t-shop";
      else if (guilds.has(key)) extra += " t-guild";
      else if (houses.has(key)) extra += " t-house";
      return cls + extra;
    }
    return cls;
  }

  function renderTiles(){
    recalcViewport();

    const {ox,oy} = screenOrigin();
    const startX = Math.max(0, ox-1);
    const startY = Math.max(0, oy-1);
    const endX = Math.min(MAP_W-1, ox + viewW + 1);
    const endY = Math.min(MAP_H-1, oy + viewH + 1);

    for(const [k, el] of tilesDom){
      const [x,y]=k.split(',').map(Number);
      if (x<startX||y<startY||x>endX||y>endY){ el.remove(); tilesDom.delete(k); }
    }
    for(let y=startY; y<=endY; y++){
      for(let x=startX; x<=endX; x++){
        const key = coordKey(x,y);
        const dec = deco.get(key) || "";
        if (!tilesDom.has(key)){
          const t = document.createElement("div");
          t.className = "tile " + tileClassFor(x,y);
          if (dec) t.setAttribute("data-deco", dec); else t.removeAttribute("data-deco");
          mapEl.appendChild(t);
          tilesDom.set(key,t);
        } else {
          const el = tilesDom.get(key);
          el.className = "tile " + tileClassFor(x,y);
          if (dec) el.setAttribute("data-deco", dec); else el.removeAttribute("data-deco");
        }
        const t = tilesDom.get(key);
        const sx = (x - ox)*TILE;
        const sy = (y - oy)*TILE;
        t.style.transform = `translate(${sx}px, ${sy}px)`;
      }
    }

    // Put ME at the visual center of the frame
    const pxCenterX = Math.round(frame.clientWidth/2 - TILE/2);
    const pxCenterY = Math.round(frame.clientHeight/2 - TILE/2);
    meWrap.style.transform = `translate(${pxCenterX}px, ${pxCenterY}px)`;

    // refresh actors with current camera
    renderActors();
    drawOthers();
  }

  // -------- Pathfinding (A*) --------
  const neighbors = (x,y)=>{
    const out=[]; [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
      const nx=x+dx, ny=y+dy; if (passable(nx,ny)) out.push([nx,ny]);
    }); return out;
  };
  const heuristic = (a,b)=> Math.abs(a[0]-b[0])+Math.abs(a[1]-b[1]);
  function aStar(sx,sy, tx,ty){
    if (!passable(tx,ty)) return [];
    const open = new Set([coordKey(sx,sy)]);
    const came = new Map();
    const g = new Map([[coordKey(sx,sy),0]]);
    const f = new Map([[coordKey(sx,sy), heuristic([sx,sy],[tx,ty])]]);
    const lowestF = ()=>{
      let bestK=null, best=Infinity;
      for(const k of open){ const val = f.get(k) ?? Infinity; if (val<best){ best=val; bestK=k; } }
      return bestK;
    };
    while(open.size){
      const curK = lowestF();
      const [cx,cy]=curK.split(',').map(Number);
      if (cx===tx && cy===ty){
        const path = []; let k = curK;
        while(came.has(k)){ const [px,py] = k.split(',').map(Number); path.push([px,py]); k = came.get(k); }
        path.reverse(); return path;
      }
      open.delete(curK);
      for(const [nx,ny] of neighbors(cx,cy)){
        const nk = coordKey(nx,ny);
        const tentative = (g.get(curK)??Infinity) + 1;
        if (tentative < (g.get(nk)??Infinity)){
          came.set(nk, curK); g.set(nk, tentative);
          f.set(nk, tentative + heuristic([nx,ny],[tx,ty]));
          if (!open.has(nk)) open.add(nk);
        }
      }
    }
    return [];
  }

  // Movement handling
  let moveQueue = [];
  let stepping = false;

  function setDestination(tx,ty){
    const path = aStar(me.x, me.y, tx, ty);
    moveQueue = path;
  }

  function tickMove(){
    if (stepping || moveQueue.length===0) return;
    stepping = true;
    const [nx,ny] = moveQueue.shift();
    me.x = nx; me.y = ny;
    updateDoc(playerRef, { x: me.x, y: me.y, lastSeen: serverTimestamp() }).catch(()=>{});
    renderTiles(); updateHUD();
    if (!isVillageTile(me.x,me.y)){
      checkEnemyCollision();
      checkPlayerCollision();
    }
    stepping = false;
  }
  setInterval(tickMove, 120);

  // Click/tap to move
  frame.addEventListener("click",(e)=>{
    const rect = frame.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;
    const gx = Math.floor(cx / TILE);
    const gy = Math.floor(cy / TILE);
    const {ox,oy}=screenOrigin();
    const tx = ox + gx;
    const ty = oy + gy;
    setDestination(tx,ty);
  });

  // -------- Local NPCs (NOT saved to Firebase) --------
  const npcs = [];
  function spawnNPCs(){
    const caps = { green:12, yellow:18, red:24, purple:24 };
    const existing = {green:0,yellow:0,red:0,purple:0};
    for(const n of npcs){ existing[n.regionKey]++; }
    const randInt = (a,b)=> a + Math.floor(Math.random()*(b-a+1));
    for(const r of REGIONS){
      const regionKey = r[4];
      const need = Math.max(0, (caps[regionKey]||0) - (existing[regionKey]||0));
      for(let i=0;i<need;i++){
        let pool=["rock"];
        if (regionKey!=="green") pool.push("paper");
        if (regionKey==="red" || regionKey==="purple") pool.push("scissors");
        if (regionKey==="green"){ pool.push("sprite","golem"); }
        if (regionKey==="yellow"){ pool.push("lizard"); }
        if (regionKey==="red"){ pool.push("dragon"); }
        if (regionKey==="purple"){ pool.push("knight"); }
        const type = pool[Math.floor(Math.random()*pool.length)];
        let x, y;
        for(let tries=0;tries<100;tries++){
          x = randInt(r[0], r[2]); y = randInt(r[1], r[3]);
          if (passable(x,y) && !isVillageTile(x,y)) break;
        }
        const cooldown = 1 + Math.floor(Math.random()*3); // 1‚Äì3 ticks
        npcs.push({type, x, y, regionKey, cooldown});
      }
    }
  }
  spawnNPCs();

  function npcClass(t){
    if (t==="rock") return "npc-rock";
    if (t==="paper") return "npc-paper";
    if (t==="scissors") return "npc-scissors";
    if (t==="sprite") return "npc-sprite";
    if (t==="golem") return "npc-golem";
    if (t==="lizard") return "npc-lizard";
    if (t==="dragon") return "npc-dragon";
    return "npc-knight";
  }

  function moveNPCs(){
    const AGGRO = 4;          // chase when close
    const IDLE_CHANCE = 0.25; // 25% idle
    const COMMIT_CHANCE = 0.35;

    for(const n of npcs){
      if (n.cooldown && n.cooldown > 0) { n.cooldown--; continue; }
      if (Math.random() < IDLE_CHANCE) { n.cooldown = 1; continue; }

      let dx = 0, dy = 0;
      const dist = Math.abs(n.x - me.x) + Math.abs(n.y - me.y);

      if (dist <= 1) {
        if (Math.random() < COMMIT_CHANCE) {
          if (n.x < me.x) dx = 1; else if (n.x > me.x) dx = -1;
          else if (n.y < me.y) dy = 1; else if (n.y > me.y) dy = -1;
        } else {
          n.cooldown = 1 + Math.floor(Math.random()*2);
          continue;
        }
      } else if (dist <= AGGRO) {
        if (Math.abs(n.x - me.x) >= Math.abs(n.y - me.y)) {
          dx = (me.x > n.x) ? 1 : -1;
        } else {
          dy = (me.y > n.y) ? 1 : -1;
        }
        const altDx = (me.x > n.x) ? 1 : -1;
        const altDy = (me.y > n.y) ? 1 : -1;
        if (!passable(n.x+dx, n.y+dy) || isVillageTile(n.x+dx, n.y+dy)) {
          if (Math.abs(n.x - me.x) >= Math.abs(n.y - me.y)) { dx = 0; dy = altDy; }
          else { dy = 0; dx = altDx; }
        }
      } else {
        const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
        const [rx,ry] = dirs[Math.floor(Math.random()*dirs.length)];
        dx = rx; dy = ry;
      }

      const nx = n.x + dx, ny = n.y + dy;
      const r = REGIONS.find(R=>R[4]===n.regionKey);
      if (nx>=r[0] && nx<=r[2] && ny>=r[1] && ny<=r[3] && passable(nx,ny) && !isVillageTile(nx,ny)){
        n.x = nx; n.y = ny;
      }
      n.cooldown = 1 + Math.floor(Math.random()*3);
    }
  }
  // NPC AI tick
  setInterval(()=>{ moveNPCs(); renderActors(); }, 900);

  // -------- Actors rendering (NPCs + Others + Me) --------
  function renderActors(){
    // Remove old NPC DOM
    for(const [k, el] of actorsDom){
      if (k.startsWith("npc:")){ el.remove(); actorsDom.delete(k); }
    }
    const {ox,oy}=screenOrigin();

    // NPCs within viewport
    for(const n of npcs){
      if (n.x<ox-1||n.y<oy-1||n.x>ox+viewW+1||n.y>oy+viewH+1) continue;
      const wrap = document.createElement("div");
      wrap.className = `actor ${npcClass(n.type)}`;
      wrap.style.transform = `translate(${(n.x-ox)*TILE}px, ${(n.y-oy)*TILE}px)`;
      mapEl.appendChild(wrap);
      actorsDom.set(`npc:${n.x},${n.y}:${n.type}`, wrap);
    }

    // Me centered by actual frame size
    const pxCenterX = Math.round(frame.clientWidth/2 - TILE/2);
    const pxCenterY = Math.round(frame.clientHeight/2 - TILE/2);
    meWrap.style.transform = `translate(${pxCenterX}px, ${pxCenterY}px)`;
  }

  // -------- Encounters (PvE) --------
  function checkEnemyCollision(){
    const hit = npcs.find(n=> n.x===me.x && n.y===me.y);
    if (!hit) return;
    runEncounter((["rock","paper","scissors"].includes(hit.type) ? hit.type : "wild"));
  }

  async function runEncounter(enemyType){
    try{
      const ref = await addDoc(collection(db,"encounters"), {
        type: enemyType, x: me.x, y: me.y, player: username, createdAt: serverTimestamp()
      });
      location.href = `/game/rockbattle.html?encounter=${ref.id}&username=${encodeURIComponent(username)}`;
    }catch(e){ console.error(e); }
  }

  // -------- Other Players (active only) --------
  const others = new Map();
  onSnapshot(query(othersRef, where("active","==",true)), (snap)=>{
    const present = new Set();
    snap.forEach(d=>{
      const pl = d.data(); if (pl.name===username) return;
      others.set(pl.name, pl); present.add(pl.name);
    });
    for(const k of Array.from(others.keys())){ if (!present.has(k)) others.delete(k); }
    drawOthers();
  });

  function drawOthers(){
    // prune old player dom
    for(const [k, el] of actorsDom){
      if (k.startsWith("p:")){ el.remove(); actorsDom.delete(k); }
    }
    const {ox,oy}=screenOrigin();
    for(const [name,pl] of others){
      if (!pl || typeof pl.x!=="number" || pl.active!==true) continue;
      if (pl.x<ox-1||pl.y<oy-1||pl.x>ox+viewW+1||pl.y>oy+viewH+1) continue;
      const wrap = document.createElement("div");
      wrap.className = "actor player";
      wrap.title = `${name}${pl.guild?(" ¬∑ "+pl.guild):""}`;
      wrap.style.transform = `translate(${(pl.x-ox)*TILE}px, ${(pl.y-oy)*TILE}px)`;
      // level label
      const lab = document.createElement("div");
      lab.className = "label";
      lab.textContent = `Lv ${pl.level||1}`;
      wrap.appendChild(lab);
      mapEl.appendChild(wrap);
      actorsDom.set(`p:${name}`, wrap);
    }
  }

  // ---- DUEL WIRING (PvP) ----
  let duelRedirected = false;
  onSnapshot(
    query(collection(db,"duels"), where("b","==",username), orderBy("createdAt","desc"), limit(5)),
    (snap)=>{
      if (duelRedirected) return;
      snap.forEach(d=>{
        const du = d.data();
        if (!du) return;
        const sameTile = (typeof du.x==="number" && typeof du.y==="number") ? (du.x===me.x && du.y===me.y) : true;
        if (sameTile){
          duelRedirected = true;
          location.href = `/game/rockduel.html?duel=${d.id}&username=${encodeURIComponent(username)}`;
        }
      });
    }
  );

  async function checkPlayerCollision(){
    for(const [name,pl] of others){
      if (!pl) continue;
      if (pl.x===me.x && pl.y===me.y){
        if (me.guild && pl.guild && me.guild===pl.guild){
          openTrade(name, pl);
        } else {
          const iCreate = username.localeCompare(name) < 0; // only one creator
          if (iCreate && !duelRedirected){
            try{
              const r = regionOf(me.x, me.y);
              const ref = await addDoc(collection(db,"duels"), {
                a: username, b: name,
                x: me.x, y: me.y,
                region: r[4], tile: coordKey(me.x,me.y),
                state: null,
                createdAt: serverTimestamp()
              });
              duelRedirected = true;
              location.href = `/game/rockduel.html?duel=${ref.id}&username=${encodeURIComponent(username)}`;
            }catch(e){ console.error(e); }
          }
        }
        break;
      }
    }
  }

  // -------- Chat (15 tiles radius) --------
  const msgsEl = document.getElementById("messages");
  const chatForm = document.getElementById("chatForm");
  const chatInput = document.getElementById("chatInput");
  chatForm.addEventListener("submit", async (e)=>{
    e.preventDefault();
    const text = chatInput.value.trim();
    if (!text) return;
    const r = regionOf(me.x, me.y);
    await addDoc(collection(db,"messages"), {
      user: username, text, x: me.x, y: me.y, region: r[4], createdAt: serverTimestamp()
    });
    chatInput.value = "";
  });

  onSnapshot(query(collection(db,"messages"), orderBy("createdAt","desc"), limit(60)), (snap)=>{
    const rows=[];
    snap.forEach(d=>{
      const m=d.data();
      if (typeof m.x!=="number"||typeof m.y!=="number") return;
      const dist = Math.abs(m.x - me.x) + Math.abs(m.y - me.y);
      if (dist<=15){ rows.push(m); }
    });
    rows.sort((a,b)=> (a.createdAt?.seconds||0)-(b.createdAt?.seconds||0));
    msgsEl.innerHTML = rows.map(r=>(
      `<div class="msg"><b>${r.user}</b>: ${escapeHtml(r.text)} <small>(${r.x},${r.y})</small></div>`
    )).join("");
    msgsEl.scrollTop = msgsEl.scrollHeight;
  });

  const escapeHtml = s => s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));

  // -------- Shop / Guild / Inventory --------
  const modalBack = document.getElementById("modalBack");
  const modalTitle = document.getElementById("modalTitle");
  const modalBody = document.getElementById("modalBody");
  const modalClose = document.getElementById("modalClose");
  modalClose.addEventListener("click", ()=> closeModalAndStepAway());

  function showModal(title, html){
    modalTitle.textContent = title;
    modalBody.innerHTML = html;
    modalBack.style.display="flex";
  }
  function closeModal(){
    modalBack.style.display="none";
    modalBody.innerHTML = "";
  }
  function closeModalAndStepAway(){
    closeModal();
    const options = [[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dx,dy] of options){
      const nx = me.x+dx, ny = me.y+dy;
      if (passable(nx,ny)) { me.x=nx; me.y=ny; updateDoc(playerRef,{x:me.x,y:me.y}); break; }
    }
    renderTiles(); updateHUD();
  }

  document.getElementById("shopBtn").addEventListener("click", ()=>{
    if (!shops.has(coordKey(me.x,me.y))) return showModal("Shop", "<div>Stand on üí∞ to open the shop.</div>");
    openShop();
  });
  document.getElementById("guildBtn").addEventListener("click", ()=>{
    if (!guilds.has(coordKey(me.x,me.y))) return showModal("Guild Hall", "<div>Stand on üèõÔ∏è to visit the guild hall.</div>");
    openGuild();
  });
  document.getElementById("invBtn").addEventListener("click", openInventory);

  function cardTile(c, idx, controls=true){
    const lock = (me.level < (c.lvlReq||1)) ? `<span class="pill danger">Lvl ${c.lvlReq||1}</span>` : "";
    const extra = c.desc ? `<small>${c.desc}</small>` : "";
    aconst idLine = c.id ? `<small style="color:#94a3b8">#${c.id.slice(0,6)}</small>` : "";
    const removeBtn = controls ? `<button class="btn secondary" data-remove="${idx}">Remove</button>` : "";
    return `<div class="card">
      <b>${c.name}</b>${idLine}
      <div class="row">
        <span class="pill">Type: ${c.type}</span>
        ${lock}
      </div>
      ${extra}
      ${controls? removeBtn:""}
    </div>`;
  }

  function openInventory(){
    const html = `
      <div class="row"><div class="pill">Capacity: ${me.inventory.length}/${invCap()}</div></div>
      <div class="invGrid">
        ${me.inventory.map((c,i)=> cardTile(c,i,true)).join("")}
      </div>
    `;
    showModal("Inventory", html);
    modalBody.querySelectorAll("[data-remove]").forEach(btn=>{
      btn.addEventListener("click", async ()=>{
        const idx = +btn.getAttribute("data-remove");
        me.inventory.splice(idx,1);
        await updateDoc(playerRef, { inventory: me.inventory });
        openInventory();
      });
    });
  }

  function openShop(){
    const items = SHOP_ITEMS.map((it, i)=>(
      `<div class="card">
        <b>${it.name}</b>
        <div class="row">
          <span class="pill">Lvl ${it.lvlReq}</span>
          <span class="pill">üí∞ ${it.cost}</span>
        </div>
        ${it.desc? `<small>${it.desc}</small>`:""}
        <button class="btn" data-buy="${i}">Buy</button>
      </div>`
    )).join("");
    const html = `
      <div class="row">
        <div class="pill">Gold: ${me.gold}</div>
        <div class="pill">Inv: ${me.inventory.length}/${invCap()}</div>
      </div>
      <div class="invGrid">${items}</div>
    `;
    showModal("Shop", html);
    modalBody.querySelectorAll("[data-buy]").forEach(btn=>{
      btn.addEventListener("click", async ()=>{
        const i = +btn.getAttribute("data-buy");
        const it = SHOP_ITEMS[i];
        if (me.level < it.lvlReq) return alert("Level too low.");
        if (me.gold < it.cost) return alert("Not enough gold.");
        if (me.inventory.length >= invCap()) return alert("Inventory full.");
        const card = { id: crypto.randomUUID(), name: it.name, type: it.type, lvlReq: it.lvlReq };
        me.gold -= it.cost; me.inventory.push(card);
        await updateDoc(playerRef, { gold: me.gold, inventory: me.inventory });
        openShop(); updateHUD();
      });
    });
  }

  function openGuild(){
    const html = `
      <div class="row">
        <div class="pill">Your Level: ${me.level}</div>
        <div class="pill">Current Guild: ${me.guild||"‚Äî"}</div>
      </div>
      <div class="invGrid">
        ${["rock","paper","scissors"].map(g=>`
          <div class="card">
            <b>${g[0].toUpperCase()+g.slice(1)} Guild</b>
            <small>Requires Level 5+</small>
            <button class="btn" data-join="${g}">Join</button>
          </div>`).join("")}
      </div>
    `;
    showModal("Guild Hall", html);
    modalBody.querySelectorAll("[data-join]").forEach(btn=>{
      btn.addEventListener("click", async ()=>{
        const g = btn.getAttribute("data-join");
        if (me.level < 5) return alert("You must be level 5 or higher.");
        me.guild = g;
        await updateDoc(playerRef, { guild: g });
        openGuild(); updateHUD();
      });
    });
  }

  // -------- Level-up flow --------
  async function checkLevelUp(){
    const need = xpNeededFor(me.level);
    if (me.xp >= need){
      const newLevel = me.level + 1;
      const pool = SHOP_ITEMS.filter(i=> i.lvlReq <= newLevel);
      const pick = ()=> pool[Math.floor(Math.random()*pool.length)];
      const a = pick(), b = pick();
      const html = `
        <div class="row"><div class="pill ok">Level Up! ‚Üí ${newLevel}</div></div>
        <p>Pick one reward:</p>
        <div class="invGrid">
          <div class="card">
            <b>${a.name}</b><small>Lvl ${a.lvlReq} ¬∑ ${a.cost}g</small>
            <button class="btn" id="pickA">Choose</button>
          </div>
          <div class="card">
            <b>${b.name}</b><small>Lvl ${b.lvlReq} ¬∑ ${b.cost}g</small>
            <button class="btn" id="pickB">Choose</button>
          </div>
        </div>`;
      showModal("Level Up!", html);
      const choose = async (it)=>{
        if (me.inventory.length >= invCap()) { alert("Inventory full, reward dropped."); }
        else me.inventory.push({ id: crypto.randomUUID(), name: it.name, type: it.type, lvlReq: it.lvlReq });
        me.level = newLevel; me.xp = 0;
        await updateDoc(playerRef, { level: me.level, xp: 0, inventory: me.inventory });
        closeModal();
        updateHUD();
      };
      modalBody.querySelector("#pickA").addEventListener("click", ()=> choose(a));
      modalBody.querySelector("#pickB").addEventListener("click", ()=> choose(b));
    }
  }

  // -------- Trade flow --------
  async function openTrade(otherName, otherData){
    const myOffer = { cardId:"" };
    const theirOffer = { cardId:"" };
    const html = `
      <div class="row"><div class="pill">Trading with <b>${otherName}</b></div></div>
      <div class="row">
        <div style="flex:1">
          <b>Your Offer</b>
          <div class="invGrid">
            ${me.inventory.map(c=>`
              <div class="card">
                <b>${c.name}</b><small>#${c.id.slice(0,6)}</small>
                <button class="btn secondary" data-choose="${c.id}">Offer</button>
              </div>`).join("")}
          </div>
          <div id="youOfferView" class="row"><div class="pill">Selected: ‚Äî</div></div>
        </div>
        <div style="flex:1">
          <b>${otherName}'s Inventory</b>
          <div id="otherInv" class="invGrid"><small>Waiting...</small></div>
          <div id="themOfferView" class="row"><div class="pill">Selected: ‚Äî</div></div>
        </div>
      </div>
      <div class="row">
        <button id="acceptBtn" class="btn">Accept</button>
        <button id="cancelBtn" class="btn secondary">Cancel</button>
      </div>
    `;
    showModal("Guild Trade", html);

    const otherSnap = await getDoc(doc(db,"players",otherName));
    const otherInv = (otherSnap.exists() ? (otherSnap.data().inventory || []) : []);
    const otherInvBox = document.getElementById("otherInv");
    otherInvBox.innerHTML = otherInv.map(c=>`
      <div class="card">
        <b>${c.name}</b><small>#${(c.id||'').slice(0,6)}</small>
        <button class="btn secondary" data-choose-them="${c.id}">Offer</button>
      </div>`).join("");

    const youView = document.getElementById("youOfferView");
    const themView = document.getElementById("themOfferView");

    modalBody.querySelectorAll("[data-choose]").forEach(b=>{
      b.addEventListener("click", ()=>{
        myOffer.cardId = b.getAttribute("data-choose");
        youView.innerHTML = `<div class="pill">Selected: ${myOffer.cardId.slice(0,6)}</div>`;
      });
    });
    modalBody.querySelectorAll("[data-choose-them]").forEach(b=>{
      b.addEventListener("click", ()=>{
        theirOffer.cardId = b.getAttribute("data-choose-them");
        themView.innerHTML = `<div class="pill">Selected: ${theirOffer.cardId.slice(0,6)}</div>`;
      });
    });

    document.getElementById("cancelBtn").addEventListener("click", closeModalAndStepAway);
    document.getElementById("acceptBtn").addEventListener("click", async ()=>{
      if (!myOffer.cardId || !theirOffer.cardId) return alert("Select offers on both sides.");
      try{
        await runTransaction(db, async (tx)=>{
          const meSnap = await tx.get(playerRef);
          const otRef = doc(db,"players",otherName);
          const otSnap = await tx.get(otRef);
          if (!meSnap.exists() || !otSnap.exists()) throw new Error("Missing players");
          const mine = meSnap.data();
          const othr = otSnap.data();
          const myIdx = (mine.inventory||[]).findIndex(c=> c.id===myOffer.cardId);
          const thIdx = (othr.inventory||[]).findIndex(c=> c.id===theirOffer.cardId);
          if (myIdx<0 || thIdx<0) throw new Error("Item missing");
          const myCard = mine.inventory[myIdx];
          const thCard = othr.inventory[thIdx];
          if ((mine.inventory.length -1 + 1) > invCap()) throw new Error("Your inventory would overflow.");
          if ((othr.inventory.length -1 + 1) > (9 + (othr.level||1))) throw new Error("Their inventory would overflow.");
          mine.inventory.splice(myIdx,1); othr.inventory.splice(thIdx,1);
          mine.inventory.push(thCard); othr.inventory.push(myCard);
          tx.update(playerRef, { inventory: mine.inventory });
          tx.update(otRef, { inventory: othr.inventory });
        });
        alert("Trade complete!");
        closeModalAndStepAway();
      }catch(e){
        alert("Trade failed: " + e.message);
      }
    });
  }

  // -------- Auto open shop/guild when standing on them --------
  function structureCheckOpen(){
    const key = coordKey(me.x,me.y);
    if (shops.has(key)) openShop();
    else if (guilds.has(key)) openGuild();
  }
  setInterval(structureCheckOpen, 300);

  // -------- Boot --------
  await ensurePlayer();
  recalcViewport();
  renderTiles();
  updateHUD();
  setInterval(drawOthers, 400); // keep others visible & updated
</script>
</body>
</html>





