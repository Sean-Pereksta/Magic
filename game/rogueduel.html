<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
<title>üÇ° Rogue Duel (2P) ‚Äî Simultaneous Draft + Relics</title>
<style>
  :root{
    --bg:#ffffff; --ink:#0f172a; --muted:#64748b; --line:#e5e7eb;
    --good:#16a34a; --warn:#eab308; --bad:#dc2626; --heal:#0ea5e9; --shield:#2563eb;
    --panel:#f8fafc; --card:#ffffff; --radius:14px; --shadow:0 10px 30px rgba(2,6,23,.08);
    --rar-common:#94a3b8; --rar-rare:#3b82f6; --rar-epic:#8b5cf6; --rar-legend:#f59e0b;
    --syn:#22c55e; --relic:#fb923c;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Arial,sans-serif}
  header{padding:10px 14px;display:flex;gap:10px;align-items:center;justify-content:space-between;border-bottom:1px solid var(--line);background:#fff;position:sticky;top:0;z-index:5}
  .left{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .pill{padding:6px 10px;border:1px solid var(--line);border-radius:999px;background:var(--panel);font-weight:700}
  #root{padding:14px;display:grid;gap:14px;max-width:1100px;margin:0 auto}
  .lbl{font-size:12px;color:var(--muted);margin:4px 0}
  #arena{display:grid;gap:14px}
  .laneWrap{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:10px}
  .sideTitle{font-size:12px;color:var(--muted);margin-bottom:6px}
  .lane{display:grid;gap:10px;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));min-height:140px}

  .nameRow{display:flex;align-items:center;gap:8px;justify-content:space-between}
  .synRow{display:flex;gap:6px;flex-wrap:wrap}
  .synBadge{font-size:11px;font-weight:800;padding:2px 8px;border-radius:999px;color:#065f46;background:#d1fae5;border:1px solid #a7f3d0;opacity:0;animation:fadeSyn 1.6s ease forwards}
  @keyframes fadeSyn{ 40%{opacity:1} 100%{opacity:0} }

  .card{
    position:relative;border-radius:12px;background:var(--card);
    border:1px solid var(--line);box-shadow:var(--shadow);
    padding:8px;user-select:none;touch-action:manipulation;cursor:pointer;
    display:flex;flex-direction:column;gap:6px;min-height:124px;overflow:visible;
    transition:transform .14s ease;
  }
  .card:hover{transform:translateY(-2px)}
  .rowline{display:flex;justify-content:space-between;gap:6px}
  .emoji{font-size:28px;line-height:28px}
  .name{font-size:13px;font-weight:800}
  .stars{font-size:12px;letter-spacing:.5px;color:#475569}
  .rar{font-size:11px;font-weight:800;padding:2px 6px;border-radius:999px;border:1px solid var(--line);color:#fff}
  .rar.common{background:var(--rar-common)}
  .rar.rare{background:var(--rar-rare)}
  .rar.epic{background:var(--rar-epic)}
  .rar.legend{background:var(--rar-legend)}
  .statline{display:flex;gap:6px;font-size:12px;color:#475569;flex-wrap:wrap}
  .tag{font-size:10px;border:1px solid var(--line);border-radius:999px;padding:2px 6px;color:#475569}
  .fx{position:absolute;inset:0;pointer-events:none}
  .shieldRing{position:absolute;inset:-2px;border-radius:12px;border:2px solid var(--shield);box-shadow:0 0 12px rgba(37,99,235,.45) inset;pointer-events:none}
  .freezeVeil{position:absolute;inset:0;border-radius:12px;background:rgba(96,165,250,.17);backdrop-filter:blur(1px);pointer-events:none}
  .poisonGlow{position:absolute;inset:-2px;border-radius:12px;box-shadow:0 0 0 2px rgba(124,58,237,.8) inset, 0 0 18px rgba(124,58,237,.35) inset}

  .badges{position:absolute;right:6px;top:6px;display:flex;gap:4px;z-index:3}
  .badge{font-size:11px;font-weight:800;padding:1px 5px;border-radius:999px;color:#fff;background:#0ea5e9;border:1px solid rgba(0,0,0,.1);box-shadow:0 1px 6px rgba(2,6,23,.15)}
  .badge.poison{background:#7c3aed}
  .badge.freeze{background:#60a5fa}
  .badge.shield{background:#2563eb}
  .badge.hot{background:#34d399}

  .rarity-common{box-shadow:0 0 0 2px rgba(148,163,184,.5) inset, var(--shadow)}
  .rarity-rare{box-shadow:0 0 0 2px rgba(59,130,246,.6) inset, 0 0 14px rgba(59,130,246,.28), var(--shadow)}
  .rarity-epic{box-shadow:0 0 0 2px rgba(139,92,246,.7) inset, 0 0 16px rgba(139,92,246,.30), var(--shadow)}
  .rarity-legend{box-shadow:0 0 0 2px rgba(245,158,11,.8) inset, 0 0 18px rgba(245,158,11,.32), var(--shadow)}

  #deckBar{display:flex;gap:8px;overflow:auto;padding:8px;border:1px solid var(--line);border-radius:12px;background:var(--panel)}
  #deckBar .card{flex:0 0 auto;min-width:120px}
  #log{max-height:180px;overflow:auto;border:1px solid var(--line);border-radius:12px;padding:8px;background:var(--panel);font-size:13px}
  #controls{display:flex;gap:8px;flex-wrap:wrap}
  button{
    background:linear-gradient(180deg,#0ea5e9,#0284c7);color:white;border:1px solid #0369a1;
    padding:10px 12px;border-radius:12px;font-weight:800;cursor:pointer
  }
  button:disabled{opacity:.5;cursor:not-allowed}
  #btnSpeed{background:linear-gradient(180deg,#94a3b8,#64748b);border-color:#475569}

  .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.35);padding:14px;z-index:20}
  .modal.on{display:flex}
  .sheet{max-width:980px;width:100%;background:#ffffff;border:1px solid var(--line);border-radius:16px;box-shadow:var(--shadow);padding:16px}
  .grid{display:grid;gap:10px}
  .grid.cards{grid-template-columns:repeat(auto-fit,minmax(200px,1fr))}
  .sheet h2{margin:0 0 8px 0}
  .helper{font-size:12px;color:var(--muted);margin-top:6px}

  /* Global FX */
  #fxRoot{position:fixed;inset:0;pointer-events:none;z-index:9999}
  .fxFloat{position:absolute;font-weight:900;font-size:18px;text-shadow:0 2px 10px rgba(0,0,0,.25);animation:fxRise .95s ease-out forwards;z-index:99999}
  @keyframes fxRise { to { transform:translate(-50%,-38px); opacity:0; } }
  .fxBoom{position:absolute;width:7px;height:7px;border-radius:50%;opacity:0.95}

  /* Battle flash cards (synergies/relics) */
  #battleFlash{position:fixed; right:12px; top:74px; width:280px; z-index:9999; pointer-events:none;}
  .flashCard{
    background:#fff; border:2px solid var(--line); border-left:5px solid var(--syn);
    box-shadow:0 10px 30px rgba(2,6,23,.12); border-radius:12px; margin-bottom:10px; padding:10px 12px;
    transform:translateX(320px); opacity:0; animation:flashIn 650ms ease forwards;
  }
  .flashCard.relic{border-left-color:var(--relic)}
  .flashTitle{font-weight:900; font-size:14px; margin-bottom:4px}
  .flashDesc{font-size:12px; color:#475569}
  @keyframes flashIn{ to{transform:translateX(0); opacity:1;} }

  .wait{padding:10px 12px;border:1px dashed var(--line);border-radius:12px;background:#fff7ed;color:#7c2d12;font-weight:700}
</style>
</head>
<body>
<header>
  <div class="left">
    <div class="pill">Game: <span id="gameId">‚Äî</span></div>
    <div class="pill">You: <span id="me">‚Äî</span></div>
    <div class="pill">Seat: <span id="seat">‚Äî</span></div>
    <div class="pill">Round: <span id="round">1</span></div>
    <div class="pill">Phase: <span id="phase">setup</span></div>
    <div class="pill">Score: <b id="scoreP1">0</b> ‚Äì <b id="scoreP2">0</b></div>
  </div>
  <div id="controls">
    <button id="btnSpeed">Speed: 1x</button>
  </div>
</header>

<div id="root">
  <div id="arena">
    <div class="laneWrap">
      <div class="nameRow">
        <div class="sideTitle">Your Board ‚Äî <b id="pYou">‚Äî</b></div>
        <div id="synYou" class="synRow"></div>
      </div>
      <div id="you" class="lane"></div>
    </div>
    <div class="laneWrap">
      <div class="nameRow">
        <div class="sideTitle">Enemy Board ‚Äî <b id="pFoe">‚Äî</b></div>
        <div id="synFoe" class="synRow"></div>
      </div>
      <div id="foe" class="lane"></div>
    </div>
  </div>

  <div>
    <div class="lbl">Your Deck</div>
    <div id="deckBar"></div>
  </div>

  <div>
    <div class="lbl">Battle Log</div>
    <div id="log"></div>
  </div>
</div>

<!-- Draft Modal -->
<div id="draftModal" class="modal" aria-hidden="true">
  <div class="sheet">
    <h2>Draft: Pick 1</h2>
    <div id="draftChoices" class="grid cards"></div>
    <div id="draftStatus" class="helper"></div>
  </div>
</div>

<!-- Relic Modal -->
<div id="relicModal" class="modal" aria-hidden="true">
  <div class="sheet">
    <h2>Relic: Pick 1</h2>
    <div id="relicChoices" class="grid cards"></div>
    <div id="relicStatus" class="helper"></div>
  </div>
</div>

<!-- GLOBAL OVERLAYS -->
<div id="fxRoot"></div>
<div id="battleFlash"></div>

<script type="module">
/* ===================== Firebase ===================== */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, runTransaction, serverTimestamp
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

/* Your project config */
const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);

/* ===================== URL Params / Seats ===================== */
const usp = new URLSearchParams(location.search);
const GAME_ID = usp.get('gameId') || '';
const USER = usp.get('username') || '';
document.getElementById('gameId').textContent = GAME_ID || '‚Äî';
document.getElementById('me').textContent = USER || '‚Äî';

if (!GAME_ID || !USER){
  alert('Missing gameId or username.');
}

const lobbyRef = doc(db, "lobbies", GAME_ID);
const stateRef = doc(db, "games_rogueduel", GAME_ID);

/* ===================== UI Helpers ===================== */
const logEl = document.getElementById('log');
const uiScoreP1 = document.getElementById('scoreP1');
const uiScoreP2 = document.getElementById('scoreP2');
function log(msg){ logEl.innerHTML += msg + '<br>'; logEl.scrollTop = logEl.scrollHeight; }
function setPhase(x){ document.getElementById('phase').textContent = x; }
function setRound(n){ document.getElementById('round').textContent = n; }

const SPEEDS=[1.0,1.3,1.6]; let speedIdx=0; let speed=SPEEDS[speedIdx];
document.getElementById('btnSpeed').onclick=()=>{
  speedIdx=(speedIdx+1)%SPEEDS.length; speed=SPEEDS[speedIdx];
  document.getElementById('btnSpeed').textContent=`Speed: ${speed}x`;
};

/* ===================== Game Data ===================== */
const PRIORITY={HIGH:0,MID:1,LOW:2};
const TYPE={UNIT:'unit',SPELL:'spell'};
const RAR={COMMON:'common', RARE:'rare', EPIC:'epic', LEGEND:'legend'};
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
function clone(o){return JSON.parse(JSON.stringify(o));}
function starMult(stars){return 1+0.5*(stars-1);}
function fmtStars(stars){return '‚òÖ'.repeat(stars)+'‚òÜ'.repeat(4-stars);}
function prioName(p){return p===0?'High':p===1?'Mid':'Low';}
function rarClass(r){return r===RAR.COMMON?'common':r===RAR.RARE?'rare':r===RAR.EPIC?'epic':'legend';}

/* Catalog */
const PRIOR=PRIORITY, TYPE_UNIT=TYPE.UNIT, TYPE_SPELL=TYPE.SPELL, R=RAR;
const CATALOG={
  "Slinger":   {rar:R.COMMON, icon:"ü™É", type:TYPE_UNIT, hp:7,  dmg:3, priority:PRIOR.HIGH, tags:["ranged","starter"]},
  "Spearman":  {rar:R.COMMON, icon:"üó°Ô∏è", type:TYPE_UNIT, hp:9,  dmg:4, priority:PRIOR.MID,  tags:["melee","starter"]},
  "Acolyte":   {rar:R.COMMON, icon:"üôè", type:TYPE_UNIT, hp:8,  dmg:0, priority:PRIOR.LOW,  tags:["heal1","starter"], heal1:{amt:4}},
  "Scout":     {rar:R.COMMON, icon:"ü¶ä", type:TYPE_UNIT, hp:8,  dmg:4, priority:PRIOR.HIGH, tags:["fast","starter"]},
  "Blow Dart": {rar:R.COMMON, icon:"ü™±", type:TYPE_UNIT, hp:7,  dmg:3, priority:PRIOR.HIGH, tags:["poison"], applyPoison:{dmg:2,dur:3}},
  "Slime":     {rar:R.COMMON, icon:"üß™", type:TYPE_UNIT, hp:12, dmg:3, priority:PRIOR.MID,  tags:["poison","split"], applyPoison:{dmg:2,dur:3}, split:true},
  "Pikeman":   {rar:R.COMMON, icon:"üî±", type:TYPE_UNIT, hp:12, dmg:6, priority:PRIOR.MID,  tags:["melee"]},

  "Knight":      {rar:R.COMMON,  icon:"üõ°Ô∏è", type:TYPE_UNIT, hp:16, dmg:6, priority:PRIOR.MID,  tags:["melee","guard"]},
  "Longbowman":  {rar:R.RARE,    icon:"üèπ", type:TYPE_UNIT, hp:9,  dmg:7, priority:PRIOR.HIGH, tags:["ranged","pierce"]},
  "Hoplite":     {rar:R.RARE,    icon:"ü•è", type:TYPE_UNIT, hp:14, dmg:5, priority:PRIOR.MID,  tags:["taunt","retaliate"], taunt:true},
  "Ninja":       {rar:R.EPIC,    icon:"ü•∑", type:TYPE_UNIT, hp:8,  dmg:5, priority:PRIOR.HIGH, tags:["double","bleed"], extraStrike:true},
  "Cavalier":    {rar:R.RARE,    icon:"üêé", type:TYPE_UNIT, hp:20, dmg:9, priority:PRIOR.MID,  tags:["charge"]},
  "Priest":      {rar:R.RARE,    icon:"‚úùÔ∏è", type:TYPE_UNIT, hp:10, dmg:0, priority:PRIOR.LOW,  tags:["heal2","bubble"], heal2:{amt:7}},
  "Dragonet":    {rar:R.EPIC,    icon:"üêâ", type:TYPE_UNIT, hp:22, dmg:6, priority:PRIOR.MID,  tags:["splash3","burn"], splash3:true},
  "Ice Dragon":  {rar:R.LEGEND,  icon:"üßä", type:TYPE_UNIT, hp:24, dmg:6, priority:PRIOR.MID,  tags:["freeze"], freeze:true},
  "Giant":       {rar:R.RARE,    icon:"üóø", type:TYPE_UNIT, hp:28, dmg:5, priority:PRIOR.LOW,  tags:["taunt","splash2"], taunt:true, splash2:true},
  "Wolf Pack":   {rar:R.RARE,    icon:"üê∫", type:TYPE_UNIT, hp:6,  dmg:3, priority:PRIOR.MID,  tags:["replicate2"], replicateTurns:2},
  "Crossbowman": {rar:R.RARE,    icon:"üèπ", type:TYPE_UNIT, hp:10, dmg:8, priority:PRIOR.HIGH, tags:["ranged"]},
  "Paladin":     {rar:R.EPIC,    icon:"üõê", type:TYPE_UNIT, hp:18, dmg:7, priority:PRIOR.MID,  tags:["smite-heal"], smiteHeal:true},
  "Bomber":      {rar:R.RARE,    icon:"üí£", type:TYPE_UNIT, hp:9,  dmg:9, priority:PRIOR.MID,  tags:["splash2"], splash2:true},
  "Druid":       {rar:R.RARE,    icon:"üåø", type:TYPE_UNIT, hp:12, dmg:2, priority:PRIOR.LOW,  tags:["regen2","bud"], regen2:true},
  "Frost Golem": {rar:R.EPIC,    icon:"üßä", type:TYPE_UNIT, hp:26, dmg:6, priority:PRIOR.LOW,  tags:["taunt","freeze"], taunt:true, freeze:true},
  "Assassin":    {rar:R.EPIC,    icon:"üó°Ô∏è", type:TYPE_UNIT, hp:7,  dmg:10,priority:PRIOR.HIGH, tags:["alpha"], alpha:true},
  "Bard":        {rar:R.RARE,    icon:"üéµ", type:TYPE_UNIT, hp:9,  dmg:0, priority:PRIOR.LOW,  tags:["ward-song"], wardSong:true},

  /* Spells: once per battle */
  "Firebolt":     {rar:R.COMMON,  icon:"üí•", type:TYPE_SPELL, spell:{kind:'fire', dmg:12}},
  "Lightning":    {rar:R.RARE,    icon:"‚ö°", type:TYPE_SPELL, spell:{kind:'lightning', hits:3, dmg:6}},
  "Shield":       {rar:R.RARE,    icon:"üõ°Ô∏è", type:TYPE_SPELL, spell:{kind:'shield', amount:0.5, dur:5}},
  "Plague":       {rar:R.RARE,    icon:"‚ò£Ô∏è", type:TYPE_SPELL, spell:{kind:'plague', dmg:2, dur:3, count:3}},
  "Healing Ward": {rar:R.RARE,    icon:"‚ú®", type:TYPE_SPELL, spell:{kind:'ward', heal:6, dur:3, targets:2}},
  "Blizzard":     {rar:R.EPIC,    icon:"‚ùÑÔ∏è", type:TYPE_SPELL, spell:{kind:'freeze2', dmg:3}},
  "Rejuvenate":   {rar:R.RARE,    icon:"üíö", type:TYPE_SPELL, spell:{kind:'hotAll'}}
};
const PLAYER_UNITS = Object.keys(CATALOG).filter(n=>CATALOG[n].type===TYPE_UNIT);
const PLAYER_SPELLS = Object.keys(CATALOG).filter(n=>CATALOG[n].type===TYPE_SPELL);
const PLAYER_POOL = [...PLAYER_UNITS, ...PLAYER_SPELLS];
function cardRarity(name){ const base=CATALOG[name]; return base?base.rar:RAR.COMMON; }

/* Relics */
const RELICS=[
  {id:'vigor',  title:'Banner of Vigor', desc:'+10% Max HP & +10% start heal', apply:(S)=>{S.relicMaxHPPct=0.10; S.relicStartHealPct=0.10;}},
  {id:'glass',  title:'Glass Arrows',    desc:'+20% ranged dmg, -10% HP',      apply:(S)=>{S.relicRangedDmg=1.20; S.relicHP=(S.relicHP||1)*0.90;}},
  {id:'aegis',  title:'Aegis Charm',     desc:'Shields last +1 turn',          apply:(S)=>S.relicShieldPlus=1},
  {id:'venom',  title:'Venom Vial',      desc:'+1 poison damage / tick',       apply:(S)=>S.relicPoisonPlus=(S.relicPoisonPlus||0)+1},
  {id:'spark',  title:'Arcane Capacitor',desc:'Your spells count as +1‚òÖ',      apply:(S)=>S.relicSpellStarsPlus=1},
  {id:'tempo',  title:'Tempo Drum',      desc:'High-priority act +15% faster', apply:(S)=>S.relicFasterHigh=true},
  {id:'warder', title:'Warder‚Äôs Oath',   desc:'R1: small shield to 2 low-HP',  apply:(S)=>S.relicFirstShield=1},
  {id:'fervor', title:'Fervor Coin',     desc:'+10% ally damage',              apply:(S)=>S.relicAllDmg=1.10}
];

/* Synergies */
const SYNERGIES=[
  {id:'poison', label:'Toxic Chorus', tag:'poison',  t:3, effect:(B)=>{B.poisonPlus=(B.poisonPlus||0)+1; B.poisonDurPlus=(B.poisonDurPlus||0)+1;}, desc:'+1 poison dmg & +1 duration'},
  {id:'ranged', label:'Volley Line',  tag:'ranged',  t:3, effect:(B)=>{B.rangedPriorityUp=true; B.rangedDmg=(B.rangedDmg||1)*1.1;}, desc:'Ranged +10% dmg & +Priority'},
  {id:'taunt',  label:'Shield Wall',  tag:'taunt',   t:2, effect:(B)=>{B.startShieldSmall=2;}, desc:'Start: small shield to 2 allies'},
  {id:'heal',   label:'Sanctuary',    tag:'heal2',   t:2, effect:(B)=>{B.healPlus=(B.healPlus||0)+2;}, desc:'+2 per targeted heal'},
  {id:'splash', label:'Shatterline',  tag:'splash2', t:2, effect:(B)=>{B.splashPlus=(B.splashPlus||0)+1;}, desc:'+1 damage on splash'},
  {id:'freeze', label:'Cold Front',   tag:'freeze',  t:2, effect:(B)=>{B.freezePlus=1;}, desc:'Freeze lasts +1 turn'}
];

/* ===================== Local State ===================== */
let SEAT = 'spectator';
let p1Name='‚Äî', p2Name='‚Äî';

const ui = {
  you: document.getElementById('you'),
  foe: document.getElementById('foe'),
  pYou: document.getElementById('pYou'),
  pFoe: document.getElementById('pFoe'),
  synYou: document.getElementById('synYou'),
  synFoe: document.getElementById('synFoe'),
  deckBar: document.getElementById('deckBar'),
  draftModal: document.getElementById('draftModal'),
  draftChoices: document.getElementById('draftChoices'),
  draftStatus: document.getElementById('draftStatus'),
  relicModal: document.getElementById('relicModal'),
  relicChoices: document.getElementById('relicChoices'),
  relicStatus: document.getElementById('relicStatus'),
  fxRoot: document.getElementById('fxRoot'),
  battleFlash: document.getElementById('battleFlash'),
};

/* ===================== RNG (seeded) ===================== */
function mulberry32(a){ return function(){ let t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; } }
let rand = Math.random;
function setSeed(seed){ rand = mulberry32(seed>>>0); }
const r = ()=>rand();

/* ===================== Card Factory ===================== */
function makeCard(name, stars=1, relicFlags={}){
  if (!name || !CATALOG[name]) {
    console.warn('[makeCard] Unknown card name:', name);
    return null;
  }
  const base=CATALOG[name];
  const isSpell = base.type===TYPE_SPELL;
  const relicSpellPlus = (relicFlags.relicSpellStarsPlus||0);
  const starsFinal = isSpell? Math.min(4, stars + relicSpellPlus) : stars;

  let hp = base.hp||0, dmg = base.dmg||0;
  if(!isSpell){
    const allDmgMult = (relicFlags.relicAllDmg||1);
    dmg = Math.round(dmg * allDmgMult);
    if((base.tags||[]).includes('ranged') && relicFlags.relicRangedDmg){
      dmg = Math.round(dmg * relicFlags.relicRangedDmg);
    }
    if (relicFlags.relicHP) hp = Math.round(hp * relicFlags.relicHP);
  }
  return {
    id:`${name}-${Math.floor(r()*1e9).toString(36)}`,
    name, icon:base.icon, type:base.type, rar:base.rar,
    stars:starsFinal, priority:base.priority, tags:clone(base.tags||[]),
    hp:hp, dmg:dmg, hpNow:isSpell?0:Math.round(hp*starMult(starsFinal)),
    alive:true, owner:'you', effects:[], frozen:false, turnsAlive:0, baby:false,
    taunt:!!base.taunt, splash2:!!base.splash2, splash3:!!base.splash3, extraStrike:!!base.extraStrike,
    applyPoison:base.applyPoison?clone(base.applyPoison):null, heal2:base.heal2?clone(base.heal2):null,
    chain3:!!base.chain3, split:!!base.split, smiteHeal:!!base.smiteHeal, regen2:!!base.regen2,
    alpha:!!base.alpha, wardSong:!!base.wardSong, freeze:!!base.freeze,
    spell:base.spell?clone(base.spell):null, _used:false
  };
}

/* ===================== Rendering ===================== */
function hasShield(c){return !!c.effects.find(e=>e.kind==='shield' && e.dur>0);}
function isPoisoned(c){return !!c.effects.find(e=>e.kind==='poison' && e.dur>0);}

function mountCard(c){
  const div=document.createElement('div');
  div.className='card rarity-'+rarClass(c.rar);
  div.dataset.id=c.id;
  div.innerHTML=`
    <div class="rowline">
      <div class="emoji">${c.icon||'üÇ†'}</div>
      <div class="stars">${fmtStars(c.stars)}</div>
    </div>
    <div class="rowline">
      <div class="name">${c.name}${c.baby?' (baby)':''}</div>
      <div class="rar ${rarClass(c.rar)}">${c.rar.toUpperCase()}</div>
    </div>
    <div class="statline">
      ${c.type===TYPE_UNIT?`<span>HP ${c.hpNow}</span>`:''}
      ${c.type===TYPE_UNIT?`<span>DMG ${Math.round((c.dmg||0)*starMult(c.stars))}</span>`:''}
      ${c.type===TYPE_UNIT?`<span>${prioName(c.priority)}</span>`:`<span>Spell</span>`}
    </div>
    <div class="statline">${(c.tags||[]).map(t=>`<span class="tag">${t}</span>`).join('')}</div>
    <div class="fx"></div>
  `;
  if(hasShield(c)) div.appendChild(Object.assign(document.createElement('div'),{className:'shieldRing'}));
  if(c.frozen) div.appendChild(Object.assign(document.createElement('div'),{className:'freezeVeil'}));
  if(isPoisoned(c)) div.appendChild(Object.assign(document.createElement('div'),{className:'poisonGlow'}));
  return div;
}
function renderBoard(myDeck, foeDeck){
  ui.you.innerHTML=''; ui.foe.innerHTML='';
  for(const c of myDeck.filter(x=>x.type===TYPE_UNIT && x.alive)) ui.you.appendChild(mountCard(c));
  for(const c of foeDeck.filter(x=>x.type===TYPE_UNIT && x.alive)) ui.foe.appendChild(mountCard(c));
}
function renderDeckBar(myDeck){
  ui.deckBar.innerHTML='';
  for(const c of myDeck) ui.deckBar.appendChild(mountCard(c));
}

/* ===================== FX ===================== */
function elCenter(el){const rct = el.getBoundingClientRect(); return { x: rct.left + rct.width/2, y: rct.top + rct.height*0.15 }; }
function findCardEl(id){return document.querySelector(`.card[data-id="${id}"]`);}

function gFloat(card, txt, color='#111827'){
  const targetEl = findCardEl(card.id); if(!targetEl) return;
  const {x,y} = elCenter(targetEl);
  const f = document.createElement('div');
  f.className = 'fxFloat'; f.textContent = txt;
  f.style.left = (x)+'px'; f.style.top  = (y)+'px';
  f.style.transform = 'translate(-50%, 0)'; f.style.color = color;
  ui.fxRoot.appendChild(f);
  setTimeout(()=>f.remove(), 1000/speed);
}
function boomAt(x, y, color='#ef4444', count=26, spread=100){
  for (let i=0;i<count;i++){
    const p = document.createElement('div');
    p.className = 'fxBoom';
    p.style.background = color;
    const ang = (r()*spread - spread/2) * Math.PI/180;
    const dist = 34 + r()*72;
    const dx = Math.cos(ang)*dist, dy = Math.sin(ang)*dist - 10;
    p.style.left = (x)+'px'; p.style.top = (y)+'px';
    p.style.transform = 'translate(-50%, -50%)';
    p.style.transition = `transform ${620/speed}msease-out, opacity ${700/speed}ms linear`;
    ui.fxRoot.appendChild(p);
    requestAnimationFrame(()=>{p.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`; p.style.opacity = '0';});
    setTimeout(()=>p.remove(), 720/speed);
  }
}
function bigExplosion(card, color='#ef4444', count=30){ const el = findCardEl(card.id); if(!el) return; const {x,y} = elCenter(el); boomAt(x, y, color, count, 150); }
function fireExplosion(card){ bigExplosion(card, '#fb923c', 36); }
function plagueSplash(card){ bigExplosion(card, '#a78bfa', 28); }
function blizzardBurst(card){ bigExplosion(card, '#60a5fa', 30); }
function heartPulse(card){
  const el = findCardEl(card.id); if(!el) return;
  const ring = document.createElement('div');
  ring.style.position='absolute'; ring.style.inset='-4px'; ring.style.borderRadius='12px';
  ring.style.boxShadow='0 0 0 0 rgba(52,211,153,.55), inset 0 0 18px rgba(52,211,153,.25)';
  ring.style.animation='heartPulse 540ms ease-out';
  ring.style.pointerEvents='none';
  el.appendChild(ring);
  setTimeout(()=>ring.remove(), 560/speed);
}
function slashTrail(fromCard,toCard,color='#ef4444'){
  const aEl=findCardEl(fromCard.id), dEl=findCardEl(toCard.id);
  if(!aEl||!dEl) return;
  const fx=dEl.querySelector('.fx'); if(!fx) return;
  const line=document.createElement('div');
  line.style.position='absolute'; line.style.height='3px'; line.style.background=color; line.style.borderRadius='2px';
  line.style.opacity='0.95'; line.style.left='10%'; line.style.top='50%';
  const len=120+ r()*40; line.style.width=len+'px'; const angle=(r()*40-20);
  line.style.transformOrigin='0 50%'; line.style.transform=`rotate(${angle}deg) translate(-10px, -10px)`;
  line.style.transition=`opacity ${240/speed}ms ease`; fx.appendChild(line);
  requestAnimationFrame(()=>{line.style.opacity='0';});
  setTimeout(()=>line.remove(),260/speed);
}
function impactBurst(card, big=false){
  const fx=findCardEl(card.id)?.querySelector('.fx'); if(!fx) return;
  for(let i=0;i<(big?20:12);i++){
    const p=document.createElement('div');
    const size=3 + r()*4;
    p.style.position='absolute'; p.style.width=p.style.height=size+'px'; p.style.borderRadius='50%';
    p.style.background= big?'#ef4444':'#f87171';
    p.style.left=(40 + r()*40)+'%'; p.style.top='60%';
    const dx=(r()*66-33), dy=(-34 - r()*44);
    p.style.opacity='0.95';
    p.style.transition=`transform ${560/speed}ms ease-out, opacity ${640/speed}ms linear`;
    fx.appendChild(p);
    requestAnimationFrame(()=>{p.style.transform=`translate(${dx}px,${dy}px)`; p.style.opacity='0';});
    setTimeout(()=>p.remove(),660/speed);
  }
}

/* ===================== Helpers ===================== */
function living(arr){return arr.filter(c=>c.type===TYPE_UNIT && c.alive);}
function waitMs(ms){ return new Promise(r=>setTimeout(r,ms)); }

function getMaxHP(c){
  const base = Math.round((c.hp||0) * starMult(c.stars));
  const extra = (c.effects||[]).filter(e=>e.kind==='maxhp').reduce((s,e)=>s+(e.bonus||0),0);
  return base + extra;
}
let currentMyDeck = [], currentFoeDeck = [];

function healCard(target,amt){
  if(!target.alive) return;
  const max = getMaxHP(target);
  const before=target.hpNow; target.hpNow=Math.min(max, target.hpNow + amt);
  const diff = target.hpNow - before;
  if(diff>0){ gFloat(target, `+${diff}`, '#0ea5e9'); heartPulse(target); }
  renderBoard(currentMyDeck, currentFoeDeck);
}

/* ===================== Targeting ===================== */
function safeOpponentsFor(attacker, myDeck, foeDeck){
  return attacker.owner==='you' ? living(foeDeck) : living(myDeck);
}
function chooseTargetFor(attacker, myDeck, foeDeck){
  const foes = safeOpponentsFor(attacker, myDeck, foeDeck);
  if (!foes.length) return null;
  const taunts = foes.filter(f => f.taunt);
  const bag = taunts.length ? taunts : foes;
  return bag[Math.floor(r()*bag.length)];
}

/* ===================== Combat ===================== */
function addPoison(t,dmg,dur){t.effects.push({kind:'poison',dmg,dur});}
function addBleed(t,amt=1,dur=2){t.effects.push({kind:'bleed',dmg:amt,dur});}
function addBurn(t,amt=1,dur=2){t.effects.push({kind:'burn',dmg:amt,dur});}
function addFreeze(t,turns=1){t.frozen=true; t.effects.push({kind:'freeze',dur:turns});}
function applyShield(c,dur=5){const ex=c.effects.find(e=>e.kind==='shield'); if(ex){ex.dur=Math.max(ex.dur||0,dur);} else c.effects.push({kind:'shield',dur});}

function dealDamage(attacker, target, base, heavy=false){
  if (!attacker || !target || !target.alive) return;

  const dmgStarred = Math.round(base * starMult(attacker.stars));
  let dmg = dmgStarred;

  if (hasShield(target)) dmg = Math.max(1, Math.floor(dmg * 0.5));

  target.hpNow -= dmg;

  gFloat(target, `-${dmg}`, '#dc2626');
  if (heavy) bigExplosion(target); else impactBurst(target, false);

  const wasAlive = target.alive;
  if (target.hpNow <= 0){
    target.alive = false;

    // Slime split ‚Äì keep the same owner
    if (target.split){
      const mk = () => makeCard("Slime", Math.max(1, target.stars - 1), {});
      const b1 = mk(), b2 = mk();
      b1.owner = target.owner;
      b2.owner = target.owner;
      b1.baby = b2.baby = true;
      b1.hpNow = b2.hpNow = 2;
      b1.split = b2.split = false;

      const deck = (target.owner === 'you' ? currentMyDeck : currentFoeDeck);
      deck.push(b1, b2);
      log(`${target.owner === 'you' ? 'Your' : 'Enemy'} Slime splits into two!`);
    }
  }

  // Hoplite retaliation
  if (wasAlive && target.alive && target.tags && target.tags.includes('retaliate') && !target._retalUsed){
    if (attacker && attacker.alive && attacker.owner !== target.owner){
      target._retalUsed = true;
      slashTrail(target, attacker, '#fbbf24');
      const retBase = 3;
      dealDamage(target, attacker, retBase, false);
      log(`${target.name} retaliates!`);
    }
  }

  renderBoard(currentMyDeck, currentFoeDeck);
}

/* Unit action: this is what gets called in playRound */
function actUnit(u, myDeck, foeDeck, synYou, synFoe, flagsYou, flagsFoe){
  if (!u || u.type !== TYPE_UNIT || !u.alive) return;

  const my    = (u.owner === 'you') ? myDeck : foeDeck;
  const enemy = (u.owner === 'you') ? foeDeck : myDeck;
  const syn   = (u.owner === 'you') ? (synYou || {}) : (synFoe || {});
  const flags = (u.owner === 'you') ? (flagsYou || {}) : (flagsFoe || {});

  // Frozen units skip their turn
  if (u.frozen){
    gFloat(u, '‚ùÑ', '#60a5fa');
    return;
  }

  u.turnsAlive = (u.turnsAlive || 0) + 1;
  const tags = u.tags || [];

  // Bard ‚Äì shield an ally instead of attacking
  if (u.wardSong){
    const allies = living(my).filter(a => a !== u && !hasShield(a));
    if (allies.length){
      const tgt = allies[Math.floor(r() * allies.length)];
      applyShield(tgt, 1 + (flags.relicShieldPlus || 0));
      gFloat(tgt, '‚ô™ Ward', '#0ea5e9');
    }
  }

  // Strong healer ‚Äì heal lowest ally instead of attacking
  if (tags.includes('heal2') && u.heal2){
    const allies = living(my).filter(a => a !== u);
    if (allies.length){
      const sorted = allies.sort(
        (a,b) => (a.hpNow / getMaxHP(a)) - (b.hpNow / getMaxHP(b))
      );
      const target = sorted[0];
      const bonus  = syn.healPlus || 0;
      const amt    = (u.heal2.amt || 0) + bonus;
      healCard(target, amt);
      log(`${u.name} heals ${target.name} for ${amt}`);
    }
    return;
  }

  // Attacks
  let swings = 1;
  if (u.extraStrike) swings++;
  if (u.alpha && u.turnsAlive === 1) swings++;

  const isRanged = tags.includes('ranged');
  const hasSplash2 = !!u.splash2;
  const hasSplash3 = !!u.splash3;

  for (let i = 0; i < swings; i++){
    const target = chooseTargetFor(u, myDeck, foeDeck);
    if (!target) break;

    let base = u.dmg || 0;

    // Ranged mult
    const synRangedMult   = syn.rangedDmg || 1;
    const relicRangedMult = (isRanged && flags.relicRangedDmg) ? flags.relicRangedDmg : 1;
    if (isRanged){
      base = Math.round(base * synRangedMult * relicRangedMult);
    }

    // Assassin alpha bump
    if (u.alpha && u.turnsAlive === 1 && i === 0){
      base = Math.round(base * 1.4);
    }

    // Charge on first turn
    const heavy = tags.includes('charge') && u.turnsAlive === 1;

    slashTrail(u, target, isRanged ? '#38bdf8' : '#ef4444');
    dealDamage(u, target, base, heavy);

    // Splash
    const splashCount = hasSplash3 ? 3 : (hasSplash2 ? 2 : 0);
    if (splashCount > 0){
      const others = living(enemy).filter(e => e !== target);
      const splashTargets = others.slice(0, splashCount);
      for (const s of splashTargets){
        const splashBase = Math.max(
          1,
          Math.round(base * 0.6) + (syn.splashPlus || 0)
        );
        impactBurst(s, false);
        dealDamage(u, s, splashBase, false);
      }
    }

    // On-hit poison
    if (u.applyPoison){
      const extra    = (syn.poisonPlus || 0) + (flags.relicPoisonPlus || 0);
      const durPlus  = syn.poisonDurPlus || 0;
      const pDmg     = (u.applyPoison.dmg || 0) + extra;
      const pDur     = (u.applyPoison.dur || 0) + durPlus;
      addPoison(target, pDmg, pDur);
      gFloat(target, '‚ò†', '#7c3aed');
    }

    // On-hit bleed
    if (tags.includes('bleed')){
      addBleed(target, 2, 2);
      gFloat(target, 'ü©∏', '#b91c1c');
    }

    // On-hit freeze
    if (u.freeze){
      const dur = 1 + (syn.freezePlus || 0);
      addFreeze(target, dur);
      gFloat(target, '‚ùÑ', '#60a5fa');
    }
  }
}

/* Spells ‚Äì once per battle */
function castSpellsOnce(deck, enemyDeck, ownerLabel, relicFlags, synergyBuffs){
  for (const s of deck.filter(c=>c.type===TYPE_SPELL && !c._used)) {
    s._used = true;
    const pow = starMult(s.stars);
    const sp = clone(s.spell);

    if (sp.kind==='fire'){
      const pool = living(enemyDeck);
      const tgt = pool.length ? pool[Math.floor(r()*pool.length)] : null;
      if (tgt){ fireExplosion(tgt); dealDamage(s, tgt, Math.round(sp.dmg*pow), true); log(`${ownerLabel} üí• Firebolt hits ${tgt.name}`); }
    }
    else if (sp.kind==='lightning'){
      for (let i=0;i<sp.hits;i++){
        const foes = living(enemyDeck);
        const t = foes.length? foes[Math.floor(r()*foes.length)] : null;
        if (t){ dealDamage(s,t,Math.round(sp.dmg*pow)); }
      }
      log(`${ownerLabel} ‚ö° Lightning strikes ${sp.hits} targets`);
    }
    else if (sp.kind==='shield'){
      const allies = living(deck).filter(a=>!hasShield(a));
      if (allies.length){
        const tgt = allies.sort((a,b)=>b.hpNow-a.hpNow)[0];
        const extra = (relicFlags?.relicShieldPlus||0);
        applyShield(tgt, (sp.dur||1) + extra);
        bigExplosion(tgt,'var(--shield)',18);
        gFloat(tgt, `Shield`, 'var(--shield)');
        log(`${ownerLabel} üõ°Ô∏è Shield on ${tgt.name}`);
      }
    }
    else if (sp.kind==='plague'){
      const opp = living(enemyDeck).slice(); // keep deck order for determinism
      const count = Math.min(sp.count||3, opp.length);
      for (let i=0;i<count;i++){
        const add = (relicFlags?.relicPoisonPlus||0) + (synergyBuffs.poisonPlus||0);
        const durPlus = (synergyBuffs.poisonDurPlus||0);
        addPoison(opp[i], Math.round(sp.dmg*pow)+add, (sp.dur||3)+durPlus);
        plagueSplash(opp[i]); gFloat(opp[i], `‚ò£`, '#7c3aed');
      }
      log(`${ownerLabel} ‚ò£Ô∏è Plague spreads`);
    }
    else if (sp.kind==='ward'){
      deck.__wards = deck.__wards || [];
      deck.__wards.push({heal:Math.round((sp.heal||5)*pow), dur:sp.dur||3, targets:sp.targets||2});
      for (const u of living(deck)) { bigExplosion(u,'#34d399',10); }
      log(`${ownerLabel} ‚ú® Healing Ward active`);
    }
    else if (sp.kind==='freeze2'){
      const opp = living(enemyDeck).slice().slice(0,2);
      for (const t of opp){
        blizzardBurst(t);
        addFreeze(t, 1 + (synergyBuffs.freezePlus||0));
        dealDamage(s,t,Math.round((sp.dmg||3)*pow));
      }
      log(`${ownerLabel} ‚ùÑÔ∏è Blizzard chills two`);
    }
    else if (sp.kind==='hotAll'){
      const DURATION = 3;
      deck.__hots = deck.__hots || [];
      deck.__hots.push({heal:1, dur:DURATION, label:'Rejuv'});
      for (const u of living(deck)) {
        u.effects.push({kind:'maxhp', bonus:1, dur:DURATION});
        gFloat(u, '+MaxHP', '#34d399'); heartPulse(u);
      }
      log(`${ownerLabel} üíö Rejuvenate across allies`);
    }
  }
}

/* End-of-round ticks */
function processEndOfRound(myDeck, foeDeck, synYou, synFoe){
  function tick(deck, buffs){
    const buf = buffs || {};

    for (const c of deck.filter(x => x.type === TYPE_UNIT)){
      for (const e of c.effects){
        if ((e.kind === 'poison' || e.kind === 'bleed' || e.kind === 'burn') && e.dur > 0 && c.alive){
          c.hpNow -= e.dmg;
          e.dur--;

          gFloat(
            c,
            `-${e.dmg}${e.kind === 'poison' ? '‚ò†' : e.kind === 'bleed' ? 'ü©∏' : 'üî•'}`,
            e.kind === 'poison' ? '#7c3aed' : (e.kind === 'bleed' ? '#b91c1c' : '#fb923c')
          );

          if (c.hpNow <= 0){
            c.alive = false;
          }
        }

        if (e.kind === 'shield' && e.dur > 0){
          e.dur--;
        }

        if (e.kind === 'freeze' && e.dur > 0){
          e.dur--;
          if (e.dur === 0) c.frozen = false;
        }

        if (e.kind === 'bud' && e.dur > 0 && c.alive){
          healCard(c, 1);
          e.dur--;
        }

        if (e.kind === 'maxhp' && e.dur != null && e.dur > 0){
          e.dur--;
        }
      }

      c.effects = c.effects.filter(e => (e.dur == null) || e.dur > 0);

      const newMax = getMaxHP(c);
      if (c.hpNow > newMax) c.hpNow = newMax;

      if (c.regen2 && c.alive){
        healCard(c, 2 + (buf.healPlus || 0));
      }

      if (c.smiteHeal && c.alive){
        healCard(c, 2);
      }
    }

    const wards = deck.__wards || [];
    for (const w of wards){
      if (w.dur > 0){
        const allies = living(deck).sort(
          (a,b) => (a.hpNow / getMaxHP(a)) - (b.hpNow / getMaxHP(b))
        );
        for (let i = 0; i < Math.min(w.targets || 2, allies.length); i++){
          healCard(allies[i], w.heal);
        }
        w.dur--;
      }
    }
    deck.__wards = wards.filter(w => w.dur > 0);

    const hots = deck.__hots || [];
    for (const h of hots){
      if (h.dur > 0){
        const allies = living(deck);
        for (const a of allies){
          healCard(a, h.heal);
        }
        h.dur--;
      }
    }
    deck.__hots = hots.filter(h => h.dur > 0);

    for (const c of deck.filter(x => x.baby && x.alive)){
      c.alive = false;
      gFloat(c, '‚úñ', '#6b7280');
    }
  }

  tick(myDeck, synYou);
  tick(foeDeck, synFoe);
}

/* ===================== Synergies / Relics UI ===================== */
function flashCard(kind,title,desc){
  const box=document.createElement('div');
  box.className='flashCard'+(kind?(' '+kind):'');
  box.innerHTML=`<div class="flashTitle">${title}</div><div class="flashDesc">${desc}</div>`;
  ui.battleFlash.appendChild(box);
  setTimeout(()=>box.remove(), 4000);
}
function showSynergyFlashes(activeIds, relics){
  ui.battleFlash.innerHTML='';
  for(const id of activeIds){
    const s=SYNERGIES.find(x=>x.id===id); if(s) flashCard('', `üß© ${s.label}`, s.desc);
  }
  for(const r of relics||[]){
    const rr = RELICS.find(x=>x.id===r.id);
    flashCard('relic', `üî∂ Relic: ${rr?rr.title:r.id}`, rr?rr.desc:'' );
  }
}
function computeSynergies(deck){
  const counts={}; const tagsByCard=deck.filter(c=>c.type===TYPE_UNIT).map(c=>c.tags||[]);
  for(const tags of tagsByCard){ for(const t of tags){ counts[t]=(counts[t]||0)+1; } }
  const buffs={_active:[]};
  for(const syn of SYNERGIES){
    if( (counts[syn.tag]||0) >= syn.t ){ syn.effect(buffs); buffs._active.push(syn.id); }
  }
  return buffs;
}

/* ===================== DRAFT / RELIC HELPERS ===================== */
function draftWeights(){ return {common:70, rare:24, epic:5, legend:1}; }
function weightedPick(weights){
  const entries = Object.entries(weights);
  const total=entries.reduce((s,[,v])=>s+v,0);
  let rnum = r()*total;
  for(const [k,v] of entries){ if((rnum-=v)<=0) return k; }
  return entries[0][0];
}
function rollDraft(forceCommon=false){
  const picks=[];
  for(let i=0;i<3;i++){
    let pool;
    if (forceCommon){
      pool = PLAYER_POOL.filter(n => CATALOG[n] && cardRarity(n)===RAR.COMMON);
    } else {
      const rar = weightedPick(draftWeights());
      pool = PLAYER_POOL.filter(n => CATALOG[n] && cardRarity(n)===rar);
      if (!pool.length) pool = PLAYER_POOL.filter(n => CATALOG[n]);
    }
    picks.push(pool[Math.floor(r()*pool.length)]);
  }
  return picks;
}
function rollRelics(){
  const ids = RELICS.map(r=>r.id);
  const bag = ids.slice(0);
  const picks=[];
  for(let i=0;i<3;i++){
    const j = Math.floor(r()*bag.length);
    picks.push(bag.splice(j,1)[0]);
  }
  return picks;
}
function needRelic(round){ return round>0 && round%5===0; }

/* ===================== DRAFT UI ===================== */
function openDraft(offers, mySeat, myPicked){
  ui.draftChoices.innerHTML='';
  ui.draftModal.classList.add('on');
  const mine = mySeat==='p1'? offers.p1 : offers.p2;
  for(const name of mine){
    const preview = makeCard(name, 1, {});
    if (!preview) continue;
    const box=document.createElement('div');
    box.className='card rarity-'+rarClass(preview.rar);
    box.innerHTML=`
      <div class="rowline"><div class="emoji">${preview.icon}</div><div class="stars">${fmtStars(preview.stars)}</div></div>
      <div class="rowline"><div class="name">${preview.name}</div><div class="rar ${rarClass(preview.rar)}">${preview.rar.toUpperCase()}</div></div>
      <div class="statline">${preview.type===TYPE_UNIT?`<span>HP ${preview.hpNow}</span><span>DMG ${preview.dmg}</span><span>${prioName(preview.priority)}</span>`:`<span>Spell</span>`}</div>
      <div class="statline">${(preview.tags||[]).map(t=>`<span class="tag">${t}</span>`).join('')}</div>`;
    box.onclick= async ()=>{
      if (myPicked) return;
      try{
        await updateDoc(stateRef, mySeat==='p1'?{p1Pick:name}:{p2Pick:name});
      }catch(e){}
    };
    ui.draftChoices.appendChild(box);
  }
  ui.draftStatus.textContent = myPicked ? '‚úÖ Pick locked. Waiting for the other player‚Ä¶' : 'Choose one.';
}
function closeDraft(){ ui.draftModal.classList.remove('on'); }

/* ===================== RELIC UI ===================== */
function openRelicDraft(offers, mySeat, myPicked){
  ui.relicChoices.innerHTML='';
  ui.relicModal.classList.add('on');
  const mine = mySeat==='p1'? offers.p1 : offers.p2;
  for(const id of mine){
    const r = RELICS.find(x=>x.id===id);
    if (!r) continue;
    const box=document.createElement('div');
    box.className='card rarity-legend';
    box.innerHTML=`
      <div class="rowline"><div class="emoji">üî∂</div><div class="stars">Relic</div></div>
      <div class="rowline"><div class="name">${r.title}</div><div class="rar legend">RELIC</div></div>
      <div class="statline"><span>${r.desc}</span></div>`;
    box.onclick= async ()=>{
      if (myPicked) return;
      try{
        await updateDoc(stateRef, mySeat==='p1'?{p1RelicPick:id}:{p2RelicPick:id});
      }catch(e){}
    };
    ui.relicChoices.appendChild(box);
  }
  ui.relicStatus.textContent = myPicked ? '‚úÖ Relic locked. Waiting for the other player‚Ä¶' : 'Choose one.';
}
function closeRelic(){ ui.relicModal.classList.remove('on'); }

/* ===================== BATTLE ORCHESTRATION ===================== */
function prepareTeamsForBattle(myDeck, foeDeck, flagsYou={}, flagsFoe={}){
  for(const c of myDeck){
    c.owner='you';
    if(c.type===TYPE_UNIT){
      c.alive=true; c.effects=[]; c.frozen=false; c.turnsAlive=0; c.baby=false;
      c.hpNow=Math.round(c.hp*starMult(c.stars));
      const rpct = flagsYou.relicMaxHPPct || 0;
      const hpStartHealPct = flagsYou.relicStartHealPct || 0;
      if (rpct > 0){
        const baseMax = Math.round(c.hp * starMult(c.stars));
        const bonus   = Math.max(1, Math.round(baseMax * rpct));
        c.effects.push({kind:'maxhp', bonus, dur:null});
        const healAmt = Math.max(1, Math.round(baseMax * hpStartHealPct));
        c.hpNow = Math.min(getMaxHP(c), c.hpNow + healAmt);
      }
    }
    if(c.type===TYPE_SPELL) c._used=false;
  }
  for(const c of foeDeck){
    c.owner='foe';
    if(c.type===TYPE_UNIT){
      c.alive=true; c.effects=[]; c.frozen=false; c.turnsAlive=0; c.baby=false;
      c.hpNow=Math.round(c.hp*starMult(c.stars));
      const rpct = flagsFoe.relicMaxHPPct || 0;
      const hpStartHealPct = flagsFoe.relicStartHealPct || 0;
      if (rpct > 0){
        const baseMax = Math.round(c.hp * starMult(c.stars));
        const bonus   = Math.max(1, Math.round(baseMax * rpct));
        c.effects.push({kind:'maxhp', bonus, dur:null});
        const healAmt = Math.max(1, Math.round(baseMax * hpStartHealPct));
        c.hpNow = Math.min(getMaxHP(c), c.hpNow + healAmt);
      }
    }
    if(c.type===TYPE_SPELL) c._used=false;
  }
}

async function playRound(myDeck, foeDeck, synYou, synFoe, flagsYou, flagsFoe){
  // reset retaliation flags
  const allUnits = myDeck.concat(foeDeck);
  for (const x of allUnits) {
    x._retalUsed = false;
  }

  let Y = living(myDeck).slice();
  let F = living(foeDeck).slice();

  Y.sort((a,b)=>a.priority-b.priority);
  F.sort((a,b)=>a.priority-b.priority);

  const turnOrder = Y.concat(F);

  for (const u of turnOrder){
    if (!u.alive) continue;

    const isYou = (u.owner === 'you');
    const fasterHighYou  = !!(flagsYou  && flagsYou.relicFasterHigh);
    const fasterHighFoe  = !!(flagsFoe  && flagsFoe.relicFasterHigh);

    const delayBefore =
      (isYou && fasterHighYou && u.priority === PRIORITY.HIGH) ||
      (!isYou && fasterHighFoe && u.priority === PRIORITY.HIGH)
        ? 140
        : 190;

    await waitMs(delayBefore / speed);
    actUnit(u, myDeck, foeDeck, synYou, synFoe, flagsYou, flagsFoe);
    await waitMs(300 / speed);

    if (living(myDeck).length === 0 || living(foeDeck).length === 0) break;
  }

  await waitMs(220 / speed);
  processEndOfRound(myDeck, foeDeck, synYou, synFoe);
}

async function runBattle(seed, state){
  setPhase('battle');
  ui.battleFlash.innerHTML = '';
  setSeed(seed);

  const oldRandom = Math.random;
  Math.random = rand;
  try {
    const p1Relics = state.p1Relics || [];
    const p2Relics = state.p2Relics || [];
    const flagsYou = {}, flagsFoe = {};

    for (const rObj of (SEAT === 'p1' ? p1Relics : p2Relics)){
      (RELICS.find(x => x.id === rObj.id) || {}).apply?.(flagsYou);
    }
    for (const rObj of (SEAT === 'p1' ? p2Relics : p1Relics)){
      (RELICS.find(x => x.id === rObj.id) || {}).apply?.(flagsFoe);
    }

    const sanitize = arr => (arr || []).filter(n => !!n && !!CATALOG[n]);
    const myNames  = sanitize(SEAT === 'p1' ? state.p1Deck : state.p2Deck);
    const foeNames = sanitize(SEAT === 'p1' ? state.p2Deck : state.p1Deck);

    currentMyDeck  = myNames .map(n => makeCard(n, 1, flagsYou)).filter(Boolean);
    currentFoeDeck = foeNames.map(n => makeCard(n, 1, flagsFoe)).filter(Boolean);

    prepareTeamsForBattle(currentMyDeck, currentFoeDeck, flagsYou, flagsFoe);

    ui.pYou.textContent = (SEAT === 'p1' ? p1Name : p2Name);
    ui.pFoe.textContent = (SEAT === 'p1' ? p2Name : p1Name);

    const synYou = computeSynergies(currentMyDeck);
    const synFoe = computeSynergies(currentFoeDeck);

    if (synYou.startShieldSmall){
      const allies = living(currentMyDeck)
        .sort((a,b) => a.hpNow - b.hpNow)
        .slice(0, synYou.startShieldSmall);
      for (const a of allies) applyShield(a, 1 + (flagsYou.relicShieldPlus || 0));
    }
    if (flagsYou.relicFirstShield){
      const allies = living(currentMyDeck)
        .sort((a,b) => a.hpNow - b.hpNow)
        .slice(0, 2);
      for (const a of allies) applyShield(a, 1 + (flagsYou.relicShieldPlus || 0));
    }
    if (synFoe.startShieldSmall){
      const allies = living(currentFoeDeck)
        .sort((a,b) => a.hpNow - b.hpNow)
        .slice(0, synFoe.startShieldSmall);
      for (const a of allies) applyShield(a, 1 + (flagsFoe.relicShieldPlus || 0));
    }
    if (flagsFoe.relicFirstShield){
      const allies = living(currentFoeDeck)
        .sort((a,b) => a.hpNow - b.hpNow)
        .slice(0, 2);
      for (const a of allies) applyShield(a, 1 + (flagsFoe.relicShieldPlus || 0));
    }

    ui.synYou.innerHTML = (synYou._active || [])
      .map(id => `<span class="synBadge">${SYNERGIES.find(s => s.id === id)?.label || id}</span>`)
      .join('');
    ui.synFoe.innerHTML = (synFoe._active || [])
      .map(id => `<span class="synBadge">${SYNERGIES.find(s => s.id === id)?.label || id}</span>`)
      .join('');
    showSynergyFlashes(synYou._active || [], (SEAT === 'p1' ? p1Relics : p2Relics));

    renderBoard(currentMyDeck, currentFoeDeck);
    renderDeckBar(currentMyDeck);

    await waitMs(260 / speed);
    castSpellsOnce(currentMyDeck, currentFoeDeck, 'You',   flagsYou, synYou);
    castSpellsOnce(currentFoeDeck, currentMyDeck, 'Enemy', flagsFoe, synFoe);

    while (living(currentMyDeck).length > 0 && living(currentFoeDeck).length > 0){
      await playRound(currentMyDeck, currentFoeDeck, synYou, synFoe, flagsYou, flagsFoe);
      if (living(currentMyDeck).length === 0 || living(currentFoeDeck).length === 0) break;
      await waitMs(340 / speed);
    }

    const youWin = living(currentMyDeck).length > 0;
    return { winner: youWin ? (SEAT === 'p1' ? 'p1' : 'p2') : (SEAT === 'p1' ? 'p2' : 'p1') };
  } finally {
    Math.random = oldRandom;
  }
}

/* ===================== FIRESTORE ORCHESTRATION ===================== */
const isValidCardName = (n) => typeof n === 'string' && !!CATALOG[n];
const sanitizeDeck = (arr) => (arr || []).filter(isValidCardName);

async function ensureStateSeats(){
  const lob = await getDoc(lobbyRef);
  if(!lob.exists()){ alert('Lobby not found.'); return; }
  const data = lob.data();
  const players = (data.players||[]).slice(0,2);
  if(players.length<2){ alert('Need two players.'); }
  p1Name = players[0]; p2Name = players[1];
  SEAT = (USER===p1Name)?'p1' : (USER===p2Name)?'p2' : 'spectator';
  document.getElementById('seat').textContent = SEAT;
  ui.pYou.textContent = (SEAT==='p1'?p1Name:(SEAT==='p2'?p2Name:'‚Äî'));
  ui.pFoe.textContent = (SEAT==='p1'?p2Name:(SEAT==='p2'?p1Name:'‚Äî'));

  await runTransaction(db, async (tx)=>{
    const cur = await tx.get(stateRef);
    if (!cur.exists()){
      const seed = Date.now() & 0xffffffff;
      setSeed(seed);
      tx.set(stateRef, {
        p1: p1Name, p2: p2Name,
        createdAt: serverTimestamp(),
        round: 1,
        phase: 'draft',
        draftSeed: seed,
        draftOffers: { p1: rollDraft(true), p2: rollDraft(true) }, // 3 forced commons
        p1Deck: [], p2Deck: [],
        p1Pick: null, p2Pick: null,
        draftTarget: 3,
        p1DraftedThisRound: 0,
        p2DraftedThisRound: 0,
        p1Relics: [], p2Relics: [],
        relicSeed: null,
        relicOffers: null,
        p1RelicPick: null,
        p2RelicPick: null,
        battleSeed: null,
        winner: null,
        p1Score: 0,
        p2Score: 0,
        bestTo: 10,
        matchWinner: null
      });
    }
  });

  onSnapshot(stateRef, async (snap) => {
    if (!snap.exists()) return;
    const st = snap.data() || {};
    setPhase(st.phase || '‚Äî');
    setRound(st.round || 1);

    if (uiScoreP1 && typeof st.p1Score === 'number') uiScoreP1.textContent = String(st.p1Score);
    if (uiScoreP2 && typeof st.p2Score === 'number') uiScoreP2.textContent = String(st.p2Score);

    // ===== DRAFT PHASE =====
    if (st.phase === 'draft') {
      if (st.draftOffers && (SEAT === 'p1' || SEAT === 'p2')) {
        const minePick = (SEAT === 'p1' ? st.p1Pick : SEAT === 'p2' ? st.p2Pick : null);
        ui.draftStatus.textContent = minePick ? '‚úÖ Pick locked. Waiting for the other player‚Ä¶' : 'Choose one.';
        setSeed((st.draftSeed >>> 0) || 0);
        openDraft(st.draftOffers, SEAT, !!minePick);
      } else {
        closeDraft();
      }

      if (st.p1Pick && st.p2Pick && USER === st.p1) {
        await runTransaction(db, async (tx) => {
          const cur = await tx.get(stateRef); if (!cur.exists()) return;
          const c = cur.data(); if (c.phase !== 'draft') return;

          const pick1 = isValidCardName(c.p1Pick) ? c.p1Pick : null;
          const pick2 = isValidCardName(c.p2Pick) ? c.p2Pick : null;

          const nextP1Deck = sanitizeDeck([...(c.p1Deck || []), ...(pick1 ? [pick1] : [])]);
          const nextP2Deck = sanitizeDeck([...(c.p2Deck || []), ...(pick2 ? [pick2] : [])]);

          const target  = c.draftTarget || 1;
          const p1Count = (c.p1DraftedThisRound || 0) + 1;
          const p2Count = (c.p2DraftedThisRound || 0) + 1;

          const needMoreThisRound = (p1Count < target) || (p2Count < target);

          if (needMoreThisRound) {
            const seed = (Date.now() ^ 0x51f0) & 0xffffffff;
            setSeed(seed);
            tx.update(stateRef, {
              p1Deck: nextP1Deck, p2Deck: nextP2Deck,
              p1Pick: null, p2Pick: null,
              p1DraftedThisRound: p1Count,
              p2DraftedThisRound: p2Count,
              draftSeed: seed,
              draftOffers: { p1: rollDraft(false), p2: rollDraft(false) },
              winner: null
            });
          } else {
            const round = c.round || 1;
            const needR = needRelic(round);
            if (needR) {
              const rseed = (Date.now() ^ 0x9e37) & 0xffffffff;
              setSeed(rseed);
              tx.update(stateRef, {
                p1Deck: nextP1Deck, p2Deck: nextP2Deck,
                p1Pick: null, p2Pick: null,
                p1DraftedThisRound: 0, p2DraftedThisRound: 0,
                relicSeed: rseed,
                relicOffers: { p1: rollRelics(), p2: rollRelics() },
                p1RelicPick: null, p2RelicPick: null,
                phase: 'relic',
                winner: null
              });
            } else {
              const bseed = (Date.now() ^ 0x2a2a) & 0xffffffff;
              tx.update(stateRef, {
                p1Deck: nextP1Deck, p2Deck: nextP2Deck,
                p1Pick: null, p2Pick: null,
                p1DraftedThisRound: 0, p2DraftedThisRound: 0,
                phase: 'battle',
                battleSeed: bseed,
                winner: null
              });
            }
          }
        });
      }
    } else {
      closeDraft();
    }

    // ===== RELIC PHASE =====
    if (st.phase === 'relic') {
      if (st.relicOffers && (SEAT === 'p1' || SEAT === 'p2')) {
        const minePick = (SEAT === 'p1' ? st.p1RelicPick : st.p2RelicPick) || null;
        setSeed((st.relicSeed >>> 0) || 0);
        openRelicDraft(st.relicOffers, SEAT, !!minePick);
      } else {
        closeRelic();
      }

      if (st.p1RelicPick && st.p2RelicPick && USER === st.p1) {
        await runTransaction(db, async (tx) => {
          const cur = await tx.get(stateRef); if (!cur.exists()) return;
          const c = cur.data(); if (c.phase !== 'relic') return;

          const validRelic = (id) => !!RELICS.find(r => r.id === id);
          const r1 = validRelic(c.p1RelicPick) ? { id: c.p1RelicPick } : null;
          const r2 = validRelic(c.p2RelicPick) ? { id: c.p2RelicPick } : null;

          const nextP1Relics = [...(c.p1Relics || []), ...(r1 ? [r1] : [])];
          const nextP2Relics = [...(c.p2Relics || []), ...(r2 ? [r2] : [])];

          const bseed = (Date.now() ^ 0x6d6d) & 0xffffffff;

          tx.update(stateRef, {
            p1Relics: nextP1Relics,
            p2Relics: nextP2Relics,
            p1RelicPick: null,
            p2RelicPick: null,
            relicOffers: null,
            phase: 'battle',
            battleSeed: bseed,
            winner: null
          });
        });
      }
    } else {
      closeRelic();
    }

    // ===== BATTLE PHASE (deterministic) =====
    if (st.phase === 'battle' && typeof st.battleSeed === 'number') {
      if (window.__ranBattleForSeed !== st.battleSeed) {
        window.__ranBattleForSeed = st.battleSeed;
        (async () => {
          const result = await runBattle(st.battleSeed >>> 0, st);
          if (USER === st.p1) {
            await updateDoc(stateRef, { phase: 'result', winner: result.winner });
          }
        })();
      }
    }

    // ===== RESULT ‚Üí SCORE / NEXT (host drives) =====
    if (st.phase === 'result' && st.winner && USER === st.p1) {
      await runTransaction(db, async (tx) => {
        const cur = await tx.get(stateRef); if (!cur.exists()) return;
        const c = cur.data(); if (c.phase !== 'result') return;

        const bestTo = c.bestTo || 10;
        let p1Score = typeof c.p1Score === 'number' ? c.p1Score : 0;
        let p2Score = typeof c.p2Score === 'number' ? c.p2Score : 0;

        if (c.winner === 'p1') p1Score++;
        else if (c.winner === 'p2') p2Score++;

        if (p1Score >= bestTo || p2Score >= bestTo) {
          tx.update(stateRef, {
            p1Score, p2Score,
            matchWinner: p1Score >= bestTo ? 'p1' : 'p2',
            phase: 'gameover'
          });
          return;
        }

        const nextRound = (c.round || 1) + 1;
        const seed = (Date.now() ^ 0x12345) & 0xffffffff;
        setSeed(seed);

        tx.update(stateRef, {
          p1Score, p2Score,
          round: nextRound,
          phase: 'draft',
          draftSeed: seed,
          draftOffers: { p1: rollDraft(false), p2: rollDraft(false) },
          p1Pick: null, p2Pick: null,
          draftTarget: 1,
          p1DraftedThisRound: 0,
          p2DraftedThisRound: 0,
          winner: null,
          battleSeed: null
        });
      });
    }

    // ===== GAME OVER =====
    if (st.phase === 'gameover' && st.matchWinner) {
      const name = st.matchWinner === 'p1' ? p1Name : p2Name;
      setPhase('gameover');
      log(`üèÜ Match over! Winner: ${name} (${st.p1Score ?? 0}‚Äì${st.p2Score ?? 0})`);
      ui.draftModal.classList.remove('on');
      ui.relicModal.classList.remove('on');
    }
  });
}

/* ===================== Boot ===================== */
await ensureStateSeats();
</script>
</body>
</html>











