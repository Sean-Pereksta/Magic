<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
<title>Rogue Duel ‚Äî 2P Simul Draft + Relics</title>
<style>
  :root{
    --bg:#ffffff; --ink:#0f172a; --muted:#64748b; --line:#e5e7eb;
    --good:#16a34a; --warn:#eab308; --bad:#dc2626; --heal:#0ea5e9; --shield:#2563eb;
    --panel:#f8fafc; --card:#ffffff; --radius:14px; --shadow:0 10px 30px rgba(2,6,23,.08);
    --rar-common:#94a3b8; --rar-rare:#3b82f6; --rar-epic:#8b5cf6; --rar-legend:#f59e0b;
    --syn:#22c55e; --relic:#fb923c;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Arial,sans-serif}
  header{padding:12px 16px;display:flex;gap:10px;align-items:center;justify-content:space-between;border-bottom:1px solid var(--line);background:#fff;position:sticky;top:0;z-index:5}
  .left{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .pill{padding:6px 10px;border:1px solid var(--line);border-radius:999px;background:var(--panel);font-weight:700}
  #root{padding:14px;display:grid;gap:14px;max-width:1100px;margin:0 auto}
  .lbl{font-size:12px;color:var(--muted);margin:4px 0}
  #arena{display:grid;gap:14px}
  .laneWrap{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:10px}
  .sideTitle{font-size:12px;color:var(--muted);margin-bottom:6px;display:flex;align-items:center;gap:10px}
  .synFlash{font-size:12px;font-weight:800;color:#065f46;background:#d1fae5;border:1px solid #10b981;border-radius:999px;padding:2px 8px;opacity:0;animation:fadeInOut 3.2s ease forwards}
  .relicFlash{font-size:12px;font-weight:800;color:#7c2d12;background:#ffedd5;border:1px solid #fb923c;border-radius:999px;padding:2px 8px;opacity:0;animation:fadeInOut 3.2s ease forwards}
  @keyframes fadeInOut{ 0%{opacity:0;transform:translateY(-6px)} 12%{opacity:1;transform:none} 80%{opacity:1} 100%{opacity:0} }
  .lane{display:grid;gap:10px;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));min-height:140px}

  .card{
    position:relative;border-radius:12px;background:var(--card);
    border:1px solid var(--line);box-shadow:var(--shadow);
    padding:8px;user-select:none;touch-action:manipulation;cursor:pointer;
    transition:transform .15s ease;
    display:flex;flex-direction:column;gap:6px;min-height:124px;overflow:visible;
  }
  .card:hover{transform:translateY(-2px)}
  .rowline{display:flex;justify-content:space-between;gap:6px}
  .emoji{font-size:28px;line-height:28px}
  .name{font-size:13px;font-weight:800}
  .stars{font-size:12px;letter-spacing:.5px;color:#475569}
  .rar{font-size:11px;font-weight:800;padding:2px 6px;border-radius:999px;border:1px solid var(--line);color:#fff}
  .rar.common{background:var(--rar-common)}
  .rar.rare{background:var(--rar-rare)}
  .rar.epic{background:var(--rar-epic)}
  .rar.legend{background:var(--rar-legend)}
  .statline{display:flex;gap:6px;font-size:12px;color:#475569;flex-wrap:wrap}
  .tag{font-size:10px;border:1px solid var(--line);border-radius:999px;padding:2px 6px;color:#475569}
  .fx{position:absolute;inset:0;pointer-events:none}
  .shieldRing{position:absolute;inset:-2px;border-radius:12px;border:2px solid var(--shield);box-shadow:0 0 12px rgba(37,99,235,.45) inset;pointer-events:none}
  .freezeVeil{position:absolute;inset:0;border-radius:12px;background:rgba(96,165,250,.17);backdrop-filter:blur(1px);pointer-events:none}
  .poisonGlow{position:absolute;inset:-2px;border-radius:12px;box-shadow:0 0 0 2px rgba(124,58,237,.8) inset, 0 0 18px rgba(124,58,237,.35) inset}
  .taunt{outline:2px solid #f59e0b}

  .badges{position:absolute;right:6px;top:6px;display:flex;gap:4px;z-index:3}
  .badge{font-size:11px;font-weight:800;padding:1px 5px;border-radius:999px;color:#fff;background:#0ea5e9;border:1px solid rgba(0,0,0,.1);box-shadow:0 1px 6px rgba(2,6,23,.15)}
  .badge.poison{background:#7c3aed}
  .badge.freeze{background:#60a5fa}
  .badge.shield{background:#2563eb}
  .badge.hot{background:#34d399}

  .heartPulse{position:absolute;inset:-4px;border-radius:12px;pointer-events:none;box-shadow:0 0 0 0 rgba(52,211,153,.55), inset 0 0 18px rgba(52,211,153,.25);animation:heartPulse 540ms ease-out;}
  @keyframes heartPulse{0%{box-shadow:0 0 0 0 rgba(52,211,153,.55), inset 0 0 0 rgba(52,211,153,0)}60%{box-shadow:0 0 0 12px rgba(52,211,153,0), inset 0 0 18px rgba(52,211,153,.45)}100%{box-shadow:0 0 0 0 rgba(52,211,153,0), inset 0 0 0 rgba(52,211,153,0)}}

  .rarity-common{box-shadow:0 0 0 2px rgba(148,163,184,.5) inset, var(--shadow)}
  .rarity-rare{box-shadow:0 0 0 2px rgba(59,130,246,.6) inset, 0 0 14px rgba(59,130,246,.28), var(--shadow)}
  .rarity-epic{box-shadow:0 0 0 2px rgba(139,92,246,.7) inset, 0 0 16px rgba(139,92,246,.30), var(--shadow)}
  .rarity-legend{box-shadow:0 0 0 2px rgba(245,158,11,.8) inset, 0 0 18px rgba(245,158,11,.32), var(--shadow)}

  #deckBars{display:grid;gap:10px}
  #deckBarP1,#deckBarP2{display:flex;gap:8px;overflow:auto;padding:8px;border:1px solid var(--line);border-radius:12px;background:var(--panel)}
  #deckBarP1 .card,#deckBarP2 .card{flex:0 0 auto;min-width:120px}
  #log{max-height:220px;overflow:auto;border:1px solid var(--line);border-radius:12px;padding:8px;background:var(--panel)}
  #controls{display:flex;gap:8px;flex-wrap:wrap}
  button{background:linear-gradient(180deg,#0ea5e9,#0284c7);color:white;border:1px solid #0369a1;padding:10px 12px;border-radius:12px;font-weight:800;cursor:pointer}
  button:disabled{opacity:.5;cursor:not-allowed}

  .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.35);padding:14px;z-index:10}
  .modal.on{display:flex}
  .sheet{max-width:980px;width:100%;background:#ffffff;border:1px solid var(--line);border-radius:16px;box-shadow:var(--shadow);padding:16px}
  .sheet h2{margin:0 0 12px 0}
  .dual{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .bucket{border:1px solid var(--line);background:#fff;border-radius:12px;padding:10px}
  .grid{display:grid;gap:10px}
  .grid.cards{grid-template-columns:repeat(auto-fit,minmax(160px,1fr))}
  .pickNote{font-size:12px;color:var(--muted);margin-top:6px}
  .picked{outline:2px solid #16a34a}

  #fxRoot{position:fixed;inset:0;pointer-events:none;z-index:99999}
  .fxFloat{position:absolute;font-weight:900;font-size:18px;text-shadow:0 2px 10px rgba(0,0,0,.25);animation:fxRise .95s ease-out forwards;z-index:99999}
  @keyframes fxRise { to { transform:translate(-50%,-38px); opacity:0; } }
  .fxBoom{position:absolute;width:7px;height:7px;border-radius:50%;opacity:0.95}
</style>
</head>
<body>
<header>
  <div class="left">
    <div class="pill">Round: <span id="round">1</span></div>
    <div class="pill">Draft phase: <span id="draftPhase">Opening (3x COMMON)</span></div>
  </div>
  <div id="controls">
    <button id="btnSpeed">Speed: 1x</button>
  </div>
</header>

<div id="root">
  <div id="arena">
    <div class="laneWrap">
      <div class="sideTitle">Player 1 <span id="p1Syn" class="synFlash" style="display:none"></span> <span id="p1RelFlash" class="relicFlash" style="display:none"></span></div>
      <div id="p1" class="lane"></div>
    </div>
    <div class="laneWrap">
      <div class="sideTitle">Player 2 <span id="p2Syn" class="synFlash" style="display:none"></span> <span id="p2RelFlash" class="relicFlash" style="display:none"></span></div>
      <div id="p2" class="lane"></div>
    </div>
  </div>

  <div id="deckBars">
    <div>
      <div class="lbl">P1 Deck</div>
      <div id="deckBarP1"></div>
    </div>
    <div>
      <div class="lbl">P2 Deck</div>
      <div id="deckBarP2"></div>
    </div>
  </div>

  <div>
    <div class="lbl">Battle Log</div>
    <div id="log"></div>
  </div>
</div>

<!-- Simultaneous Card Draft Modal -->
<div id="draftModal" class="modal">
  <div class="sheet">
    <h2><span id="draftTitle">Opening Draft</span></h2>
    <div class="dual">
      <div class="bucket">
        <div style="font-weight:800;margin-bottom:6px">P1 ‚Äî choose 1</div>
        <div id="draftChoicesP1" class="grid cards"></div>
        <div class="pickNote" id="noteP1"></div>
      </div>
      <div class="bucket">
        <div style="font-weight:800;margin-bottom:6px">P2 ‚Äî choose 1</div>
        <div id="draftChoicesP2" class="grid cards"></div>
        <div class="pickNote" id="noteP2"></div>
      </div>
    </div>
    <div class="pickNote" id="draftFooterNote"></div>
  </div>
</div>

<!-- Simultaneous Relic Draft Modal -->
<div id="relicModal" class="modal">
  <div class="sheet">
    <h2>Relic Draft (both players)</h2>
    <div class="dual">
      <div class="bucket">
        <div style="font-weight:800;margin-bottom:6px">P1 ‚Äî choose 1 Relic</div>
        <div id="relicChoicesP1" class="grid cards"></div>
      </div>
      <div class="bucket">
        <div style="font-weight:800;margin-bottom:6px">P2 ‚Äî choose 1 Relic</div>
        <div id="relicChoicesP2" class="grid cards"></div>
      </div>
    </div>
    <div class="pickNote">Relics stack and permanently modify combat for that player.</div>
  </div>
</div>

<!-- Detail Modal -->
<div id="detailModal" class="modal" onclick="hideDetail()">
  <div class="sheet" onclick="event.stopPropagation()">
    <span style="float:right;cursor:pointer;color:#64748b" onclick="hideDetail()">‚úï</span>
    <div id="detailBody"></div>
  </div>
</div>

<!-- GLOBAL FX -->
<div id="fxRoot"></div>

<script>
/*** Timing ***/
const SPEEDS=[1,1.4,1.8]; let speedIdx=0;

/*** Enums ***/
const PRIORITY={HIGH:0,MID:1,LOW:2};
const TYPE={UNIT:'unit',SPELL:'spell'};
const RAR={COMMON:'common', RARE:'rare', EPIC:'epic', LEGEND:'legend'};
const RAND=n=>Math.floor(Math.random()*n);
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));

/*** State ***/
let state={
  speed:1,
  round:1,
  p1Deck:[], p2Deck:[],
  p1Relics:[], p2Relics:[],
  p1RelicFlags:{}, p2RelicFlags:{},
  p1Syn:{}, p2Syn:{},
  playing:false,
  // drafting
  openDraftCountRemaining:0,
  forceCommon:false,
  awaitingP1:false, awaitingP2:false
};

/*** Helpers ***/
function clone(o){return JSON.parse(JSON.stringify(o));}
function starMult(stars){return 1+0.5*(stars-1);}
function fmtStars(stars){return '‚òÖ'.repeat(stars)+'‚òÜ'.repeat(4-stars);}
function prioName(p){return p===0?'High':p===1?'Mid':'Low';}
function rarClass(r){return r===RAR.COMMON?'common':r===RAR.RARE?'rare':r===RAR.EPIC?'epic':'legend';}
function log(msg){const el=document.getElementById('log'); el.innerHTML+=msg+'<br>'; el.scrollTop=el.scrollHeight;}
function setRound(n){state.round=n; document.getElementById('round').textContent=n;}
function setDraftPhase(text){document.getElementById('draftPhase').textContent=text;}

/*** Catalog (player-legal only) ***/
const PRIOR=PRIORITY, TYPE_UNIT=TYPE.UNIT, TYPE_SPELL=TYPE.SPELL, R=RAR;
const CATALOG={
  // Commons
  "Slinger":   {rar:R.COMMON, icon:"ü™É", type:TYPE_UNIT, hp:7,  dmg:3, priority:PRIOR.HIGH, tags:["ranged","starter"]},
  "Spearman":  {rar:R.COMMON, icon:"üó°Ô∏è", type:TYPE_UNIT, hp:9,  dmg:4, priority:PRIOR.MID,  tags:["melee","starter"]},
  "Acolyte":   {rar:R.COMMON, icon:"üôè", type:TYPE_UNIT, hp:8,  dmg:0, priority:PRIOR.LOW,  tags:["heal1","starter"], heal1:{amt:4}},
  "Scout":     {rar:R.COMMON, icon:"ü¶ä", type:TYPE_UNIT, hp:8,  dmg:4, priority:PRIOR.HIGH, tags:["fast","starter"]},
  "Blow Dart": {rar:R.COMMON, icon:"ü™±", type:TYPE_UNIT, hp:7,  dmg:3, priority:PRIOR.HIGH, tags:["poison"], applyPoison:{dmg:2,dur:3}},
  "Slime":     {rar:R.COMMON, icon:"üß™", type:TYPE_UNIT, hp:12, dmg:3, priority:PRIOR.MID,  tags:["poison","split"], applyPoison:{dmg:2,dur:3}, split:true},
  "Pikeman":   {rar:R.COMMON, icon:"üî±", type:TYPE_UNIT, hp:12, dmg:6, priority:PRIOR.MID,  tags:["melee"]},

  // Higher rarity
  "Knight":      {rar:R.COMMON,  icon:"üõ°Ô∏è", type:TYPE_UNIT, hp:16, dmg:6, priority:PRIOR.MID,  tags:["melee","guard"]},
  "Longbowman":  {rar:R.RARE,    icon:"üèπ", type:TYPE_UNIT, hp:9,  dmg:7, priority:PRIOR.HIGH, tags:["ranged","pierce"]},
  "Hoplite":     {rar:R.RARE,    icon:"ü•è", type:TYPE_UNIT, hp:14, dmg:5, priority:PRIOR.MID,  tags:["taunt","retaliate"], taunt:true},
  "Ninja":       {rar:R.EPIC,    icon:"ü•∑", type:TYPE_UNIT, hp:8,  dmg:5, priority:PRIOR.HIGH, tags:["double","bleed"], extraStrike:true},
  "Cavalier":    {rar:R.RARE,    icon:"üêé", type:TYPE_UNIT, hp:20, dmg:9, priority:PRIOR.MID,  tags:["charge"]},
  "Priest":      {rar:R.RARE,    icon:"‚úùÔ∏è", type:TYPE_UNIT, hp:10, dmg:0, priority:PRIOR.LOW,  tags:["heal2","bubble"], heal2:{amt:7}},
  "Dragonet":    {rar:R.EPIC,    icon:"üêâ", type:TYPE_UNIT, hp:22, dmg:6, priority:PRIOR.MID,  tags:["splash3","burn"], splash3:true},
  "Ice Dragon":  {rar:R.LEGEND,  icon:"üßä", type:TYPE_UNIT, hp:24, dmg:6, priority:PRIOR.MID,  tags:["freeze"], freeze:true},
  "Giant":       {rar:R.RARE,    icon:"üóø", type:TYPE_UNIT, hp:28, dmg:5, priority:PRIOR.LOW,  tags:["taunt","splash2"], taunt:true, splash2:true},
  "Wolf Pack":   {rar:R.RARE,    icon:"üê∫", type:TYPE_UNIT, hp:6,  dmg:3, priority:PRIOR.MID,  tags:["replicate2"], replicateTurns:2},
  "Crossbowman": {rar:R.RARE,    icon:"üèπ", type:TYPE_UNIT, hp:10, dmg:8, priority:PRIOR.HIGH, tags:["ranged"]},
  "Paladin":     {rar:R.EPIC,    icon:"üõê", type:TYPE_UNIT, hp:18, dmg:7, priority:PRIOR.MID,  tags:["smite-heal"], smiteHeal:true},
  "Bomber":      {rar:R.RARE,    icon:"üí£", type:TYPE_UNIT, hp:9,  dmg:9, priority:PRIOR.MID,  tags:["splash2"], splash2:true},
  "Druid":       {rar:R.RARE,    icon:"üåø", type:TYPE_UNIT, hp:12, dmg:2, priority:PRIOR.LOW,  tags:["regen2","bud"], regen2:true},
  "Frost Golem": {rar:R.EPIC,    icon:"üßä", type:TYPE_UNIT, hp:26, dmg:6, priority:PRIOR.LOW,  tags:["taunt","freeze"], taunt:true, freeze:true},
  "Assassin":    {rar:R.EPIC,    icon:"üó°Ô∏è", type:TYPE_UNIT, hp:7,  dmg:10,priority:PRIOR.HIGH, tags:["alpha"], alpha:true},
  "Bard":        {rar:R.RARE,    icon:"üéµ", type:TYPE_UNIT, hp:9,  dmg:0, priority:PRIOR.LOW,  tags:["ward-song"], wardSong:true},

  // Spells (once per battle)
  "Firebolt":     {rar:R.COMMON,  icon:"üí•", type:TYPE_SPELL, spell:{kind:'fire', dmg:12}},
  "Lightning":    {rar:R.RARE,    icon:"‚ö°", type:TYPE_SPELL, spell:{kind:'lightning', hits:3, dmg:6}},
  "Shield":       {rar:R.RARE,    icon:"üõ°Ô∏è", type:TYPE_SPELL, spell:{kind:'shield', amount:0.5, dur:5}},
  "Plague":       {rar:R.RARE,    icon:"‚ò£Ô∏è", type:TYPE_SPELL, spell:{kind:'plague', dmg:2, dur:3, count:3}},
  "Healing Ward": {rar:R.RARE,    icon:"‚ú®", type:TYPE_SPELL, spell:{kind:'ward', heal:6, dur:3, targets:2}},
  "Blizzard":     {rar:R.EPIC,    icon:"‚ùÑÔ∏è", type:TYPE_SPELL, spell:{kind:'freeze2', dmg:3}},
  "Rejuvenate":   {rar:R.RARE,    icon:"üíö", type:TYPE_SPELL, spell:{kind:'hotAll'}}
};
const PLAYER_UNITS = Object.keys(CATALOG).filter(n=>CATALOG[n].type===TYPE_UNIT);
const PLAYER_SPELLS = Object.keys(CATALOG).filter(n=>CATALOG[n].type===TYPE_SPELL);
const PLAYER_POOL = [...PLAYER_UNITS, ...PLAYER_SPELLS];

/*** Relics (per-player) ***/
const RELICS=[
  {id:'vigor',  title:'Banner of Vigor', desc:'+10% Max HP and +10% start heal', apply:(F)=>{F.relicMaxHPPct=0.10; F.relicStartHealPct=0.10;}},
  {id:'glass',  title:'Glass Arrows', desc:'+20% ranged damage, -10% HP (base)', apply:(F)=>{F.relicRangedDmg=1.20; F.relicHP=(F.relicHP||1)*0.90;}},
  {id:'aegis',  title:'Aegis Charm',  desc:'Shields last +1 turn', apply:(F)=>F.relicShieldPlus=1},
  {id:'venom',  title:'Venom Vial',   desc:'+1 poison damage / tick', apply:(F)=>F.relicPoisonPlus=(F.relicPoisonPlus||0)+1},
  {id:'spark',  title:'Arcane Capacitor', desc:'Your spells count as +1‚òÖ', apply:(F)=>F.relicSpellStarsPlus=(F.relicSpellStarsPlus||0)+1},
  {id:'tempo',  title:'Tempo Drum',   desc:'High-priority allies act +15% faster', apply:(F)=>F.relicFasterHigh=true},
  {id:'warder', title:'Warder‚Äôs Oath',desc:'Round 1: small shield to 2 low-HP allies', apply:(F)=>F.relicFirstShield=1},
  {id:'fervor', title:'Fervor Coin',  desc:'+10% ally damage', apply:(F)=>F.relicAllDmg=1.10}
];

/*** Synergies ***/
const SYNERGIES=[
  {id:'poison', label:'Toxic Chorus',   tag:'poison',  t:3, effect:(B)=>{B.poisonPlus=(B.poisonPlus||0)+1; B.poisonDurPlus=(B.poisonDurPlus||0)+1;}, desc:'+1 poison dmg & +1 duration'},
  {id:'ranged', label:'Volley Line',    tag:'ranged',  t:3, effect:(B)=>{B.rangedPriorityUp=true; B.rangedDmg=(B.rangedDmg||1)*1.1;}, desc:'Ranged +10% dmg & +Priority'},
  {id:'taunt',  label:'Shield Wall',    tag:'taunt',   t:2, effect:(B)=>{B.startShieldSmall=2;}, desc:'Start: small shield to 2 allies'},
  {id:'heal',   label:'Sanctuary',      tag:'heal2',   t:2, effect:(B)=>{B.healPlus=(B.healPlus||0)+2;}, desc:'+2 per targeted heal'},
  {id:'splash', label:'Shatterline',    tag:'splash2', t:2, effect:(B)=>{B.splashPlus=(B.splashPlus||0)+1;}, desc:'+1 damage on splash'},
  {id:'freeze', label:'Cold Front',     tag:'freeze',  t:2, effect:(B)=>{B.freezePlus=1;}, desc:'Freeze lasts +1 turn'}
];

/*** Card factory ***/
function makeCard(name,stars=1){
  const base=CATALOG[name];
  const isSpell=base.type===TYPE_SPELL;
  const c={
    id:Math.random().toString(36).slice(2),
    name, icon:base.icon, type:base.type, rar:base.rar,
    stars:Math.min(4,Math.max(1,stars)),
    priority:base.priority, tags:clone(base.tags||[]),
    hp:base.hp||0, dmg:base.dmg||0, hpNow:isSpell?0:Math.round((base.hp||0)*starMult(stars)),
    alive:!isSpell, owner:'p1', effects:[], frozen:false, turnsAlive:0, baby:false,
    taunt:!!base.taunt, splash2:!!base.splash2, splash3:!!base.splash3, extraStrike:!!base.extraStrike,
    applyPoison:base.applyPoison?clone(base.applyPoison):null, heal2:base.heal2?clone(base.heal2):null,
    chain3:!!base.chain3, split:!!base.split, smiteHeal:!!base.smiteHeal, regen2:!!base.regen2,
    alpha:!!base.alpha, wardSong:!!base.wardSong, freeze:!!base.freeze,
    spell:base.spell?clone(base.spell):null, _used:false
  };
  return c;
}

/*** Render ***/
function mountCard(c){
  const div=document.createElement('div');
  div.className='card rarity-'+rarClass(c.rar);
  div.dataset.id=c.id;
  div.onclick=()=>showDetail(c);
  div.innerHTML=`
    <div class="rowline">
      <div class="emoji">${c.icon||'üÇ†'}</div>
      <div class="stars">${fmtStars(c.stars)}</div>
    </div>
    <div class="rowline">
      <div class="name">${c.name}${c.baby?' (baby)':''}</div>
      <div class="rar ${rarClass(c.rar)}">${c.rar.toUpperCase()}</div>
    </div>
    <div class="statline">
      ${c.type===TYPE_UNIT?`<span>HP ${c.hpNow}</span>`:''}
      ${c.type===TYPE_UNIT?`<span>DMG ${Math.round((c.dmg||0)*starMult(c.stars))}</span>`:''}
      ${c.type===TYPE_UNIT?`<span>${prioName(c.priority)}</span>`:`<span>Spell</span>`}
    </div>
    <div class="statline">${(c.tags||[]).map(t=>`<span class="tag">${t}</span>`).join('')}</div>
    <div class="fx"></div>
  `;
  if(hasShield(c)) div.appendChild(Object.assign(document.createElement('div'),{className:'shieldRing'}));
  if(c.frozen) div.appendChild(Object.assign(document.createElement('div'),{className:'freezeVeil'}));
  if(isPoisoned(c)) div.appendChild(Object.assign(document.createElement('div'),{className:'poisonGlow'}));
  if(c.taunt) div.classList.add('taunt');
  return div;
}
function findCardEl(id){return document.querySelector(`.card[data-id="${id}"]`);}
function renderBoards(){
  const p1=document.getElementById('p1'); p1.innerHTML='';
  const p2=document.getElementById('p2'); p2.innerHTML='';
  for(const c of state.p1Deck.filter(x=>x.type===TYPE_UNIT && x.alive)) p1.appendChild(mountCard(c));
  for(const c of state.p2Deck.filter(x=>x.type===TYPE_UNIT && x.alive)) p2.appendChild(mountCard(c));
}
function renderDeckBars(){
  const b1=document.getElementById('deckBarP1'); b1.innerHTML='';
  const b2=document.getElementById('deckBarP2'); b2.innerHTML='';
  for(const c of state.p1Deck) b1.appendChild(mountCard(c));
  for(const c of state.p2Deck) b2.appendChild(mountCard(c));
}

/*** Status & FX helpers ***/
function hasShield(c){return !!c.effects.find(e=>e.kind==='shield' && e.dur>0);}
function isPoisoned(c){return !!c.effects.find(e=>e.kind==='poison' && e.dur>0);}
function applyShield(c,dur=5){const ex=c.effects.find(e=>e.kind==='shield'); if(ex){ex.dur=Math.max(ex.dur||0,dur);} else c.effects.push({kind:'shield',dur});}
function addPoison(t,dmg,dur){t.effects.push({kind:'poison',dmg,dur});}
function addBleed(t,amt=1,dur=2){t.effects.push({kind:'bleed',dmg:amt,dur});}
function addBurn(t,amt=1,dur=2){t.effects.push({kind:'burn',dmg:amt,dur});}
function addFreeze(t,turns=1){t.frozen=true; t.effects.push({kind:'freeze',dur:turns});}
function elCenter(el){const r = el.getBoundingClientRect(); return { x: r.left + r.width/2, y: r.top + r.height*0.15 }; }
function gFloat(card, txt, color='#111827'){
  const targetEl = findCardEl(card.id); if(!targetEl) return;
  const {x,y} = elCenter(targetEl);
  const f = document.createElement('div');
  f.className = 'fxFloat'; f.textContent = txt;
  f.style.left = (x)+'px'; f.style.top  = (y)+'px';
  f.style.transform = 'translate(-50%, 0)'; f.style.color = color;
  document.getElementById('fxRoot').appendChild(f);
  setTimeout(()=>f.remove(), 1000/state.speed);
}
function boomAt(x, y, color='#ef4444', count=26, spread=100){
  const root = document.getElementById('fxRoot');
  for (let i=0;i<count;i++){
    const p = document.createElement('div');
    p.className = 'fxBoom';
    p.style.background = color;
    const ang = (Math.random()*spread - spread/2) * Math.PI/180;
    const dist = 34 + Math.random()*72;
    const dx = Math.cos(ang)*dist, dy = Math.sin(ang)*dist - 10;
    p.style.left = (x)+'px'; p.style.top = (y)+'px';
    p.style.transform = 'translate(-50%, -50%)';
    p.style.transition = `transform ${620/state.speed}ms ease-out, opacity ${700/state.speed}ms linear`;
    root.appendChild(p);
    requestAnimationFrame(()=>{p.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`; p.style.opacity = '0';});
    setTimeout(()=>p.remove(), 720/state.speed);
  }
}
function bigExplosion(card, color='#ef4444', count=30){ const el = findCardEl(card.id); if(!el) return; const {x,y} = elCenter(el); boomAt(x, y, color, count, 150); }
function fireExplosion(card){ bigExplosion(card, '#fb923c', 36); }
function plagueSplash(card){ bigExplosion(card, '#a78bfa', 28); }
function blizzardBurst(card){ bigExplosion(card, '#60a5fa', 30); }
function slashTrail(fromCard,toCard,color='#ef4444'){
  const aEl=findCardEl(fromCard.id), dEl=findCardEl(toCard.id);
  if(!aEl||!dEl) return;
  const fx=dEl.querySelector('.fx'); if(!fx) return;
  const line=document.createElement('div');
  line.style.position='absolute'; line.style.height='3px'; line.style.background=color; line.style.borderRadius='2px';
  line.style.opacity='0.95'; line.style.left='10%'; line.style.top='50%';
  const len=120+Math.random()*40;
  line.style.width=len+'px';
  const angle=(Math.random()*40-20);
  line.style.transformOrigin='0 50%';
  line.style.transform=`rotate(${angle}deg) translate(-10px, -10px)`;
  line.style.transition=`opacity ${240/state.speed}ms ease`;
  fx.appendChild(line);
  requestAnimationFrame(()=>{line.style.opacity='0';});
  setTimeout(()=>line.remove(),260/state.speed);
}

/*** Choose & utility ***/
function living(arr){return arr.filter(c=>c.type===TYPE_UNIT && c.alive);}
function chooseTarget(opp){
  const foes=living(opp); if(!foes.length) return null;
  const taunts=foes.filter(f=>f.taunt); if(taunts.length) return taunts[RAND(taunts.length)];
  return foes[RAND(foes.length)];
}
function waitMs(ms){return new Promise(r=>setTimeout(r,ms));}

/*** Dyn Max HP ***/
function getMaxHP(c){
  const base = Math.round((c.hp||0) * starMult(c.stars));
  const extra = (c.effects||[]).filter(e=>e.kind==='maxhp').reduce((s,e)=>s+(e.bonus||0),0);
  return base + extra;
}
function healCard(target,amt){
  if(!target.alive) return;
  const max = getMaxHP(target);
  const before=target.hpNow; target.hpNow=Math.min(max, target.hpNow + amt);
  const diff = target.hpNow - before;
  if(diff>0){ gFloat(target, `+${diff}`, '#0ea5e9'); const el=findCardEl(target.id); if(el){ const ring=document.createElement('div'); ring.className='heartPulse'; el.appendChild(ring); setTimeout(()=>ring.remove(),560/state.speed);} }
  renderBoards();
}

/*** Combat ***/
function dealDamage(attacker,target,base,heavy=false){
  if(!target.alive) return;
  const dmgStarred=Math.round(base*starMult(attacker.stars));
  let dmg=dmgStarred;
  if(hasShield(target)) dmg=Math.max(1,Math.floor(dmg*0.5));
  target.hpNow-=dmg;

  gFloat(target, `-${dmg}`, '#dc2626');
  if(heavy) bigExplosion(target); else {
    const fx=findCardEl(target.id)?.querySelector('.fx'); if(fx){
      for(let i=0;i<12;i++){ const p=document.createElement('div'); const size=3+Math.random()*4;
        p.style.position='absolute'; p.style.width=p.style.height=size+'px'; p.style.borderRadius='50%'; p.style.background='#f87171';
        p.style.left=(40+Math.random()*40)+'%'; p.style.top='60%';
        const dx=(Math.random()*66-33), dy=(-34-Math.random()*44);
        p.style.opacity='0.95'; p.style.transition=`transform ${560/state.speed}ms ease-out, opacity ${640/state.speed}ms linear`;
        fx.appendChild(p); requestAnimationFrame(()=>{p.style.transform=`translate(${dx}px,${dy}px)`; p.style.opacity='0';});
        setTimeout(()=>p.remove(),660/state.speed);
      }
    }
  }

  if(target.hpNow<=0){
    target.alive=false;
    if(target.split){
      const mk=()=>makeCard("Slime",Math.max(1,target.stars-1));
      const b1=mk(), b2=mk(); b1.owner=target.owner; b2.owner=target.owner;
      b1.baby=b2.baby=true; b1.hpNow=2; b2.hpNow=2; b1.split=b2.split=false;
      (target.owner==='p1'?state.p1Deck:state.p2Deck).push(b1,b2);
      log(`${target.owner==='p1'?'P1':'P2'} Slime split into babies!`);
    }
  }
  renderBoards();
}

/*** Hoplite retaliation ***/
const _dealDamage=dealDamage;
dealDamage=function(attacker,target,base,heavy=false){
  const aliveBefore=target.alive;
  _dealDamage(attacker,target,base,heavy);
  if(target && target.alive && target.tags && target.tags.includes('retaliate') && !target._retalUsed && aliveBefore){
    target._retalUsed=true;
    slashTrail(target, attacker, '#fbbf24');
    _dealDamage(target,attacker,3,false);
    log(`${target.name} retaliates!`);
  }
}

/*** Spells ‚Äî once per battle per deck ***/
function castSpellsOnce(deck, owner, syn, flags){
  for (const s of deck.filter(c=>c.type===TYPE_SPELL && !c._used)) {
    s._used = true;
    const plusStars = flags.relicSpellStarsPlus||0;
    const pow = starMult(Math.min(4, s.stars + plusStars));
    const sp = clone(s.spell);
    const opp = owner==='p1'? state.p2Deck : state.p1Deck;

    if (sp.kind==='fire'){
      const tgt = chooseTarget(opp);
      if (tgt){ fireExplosion(tgt); dealDamage(s, tgt, Math.round(sp.dmg*pow), true); log(`${owner.toUpperCase()} üí• Firebolt hits ${tgt.name}`); }
    }
    else if (sp.kind==='lightning'){
      for (let i=0;i<sp.hits;i++){
        const t=chooseTarget(opp);
        if (t){ slashTrail(s, t, '#facc15'); dealDamage(s,t,Math.round(sp.dmg*pow)); }
      }
      log(`${owner.toUpperCase()} ‚ö° Lightning strikes ${sp.hits} targets`);
    }
    else if (sp.kind==='shield'){
      const allies = living(deck).filter(a=>!hasShield(a));
      if (allies.length){
        const tgt = allies.sort((a,b)=>b.hpNow-a.hpNow)[0];
        applyShield(tgt, (sp.dur||1) + (flags.relicShieldPlus||0));
        bigExplosion(tgt,'#2563eb',18);
        gFloat(tgt, `Shield`, '#2563eb');
        log(`${owner.toUpperCase()} üõ°Ô∏è Shield on ${tgt.name}`);
      }
    }
    else if (sp.kind==='plague'){
      const oppL = living(opp);
      const count = Math.min(sp.count||3, oppL.length);
      for (let i=0;i<count;i++){
        addPoison(oppL[i], Math.round(sp.dmg*pow) + (syn.poisonPlus||0) + (flags.relicPoisonPlus||0), (sp.dur||3) + (syn.poisonDurPlus||0));
        plagueSplash(oppL[i]); gFloat(oppL[i], `‚ò£`, '#7c3aed');
      }
      log(`${owner.toUpperCase()} ‚ò£Ô∏è Plague spreads`);
    }
    else if (sp.kind==='ward'){
      deck.__wards = deck.__wards || [];
      deck.__wards.push({heal:Math.round((sp.heal||5)*pow), dur:sp.dur||3, targets:sp.targets||2});
      for (const u of living(deck)) { bigExplosion(u,'#34d399',10); }
      log(`${owner.toUpperCase()} ‚ú® Healing Ward active`);
    }
    else if (sp.kind==='freeze2'){
      const oppL = living(opp).slice(0,2);
      for (const t of oppL){ blizzardBurst(t); addFreeze(t, 1 + (syn.freezePlus||0)); dealDamage(s,t,Math.round((sp.dmg||3)*pow)); }
      log(`${owner.toUpperCase()} ‚ùÑÔ∏è Blizzard chills two`);
    }
    else if (sp.kind==='hotAll'){
      const DURATION = 3;
      deck.__hots = deck.__hots || [];
      deck.__hots.push({heal:1, dur:DURATION, label:'Rejuv'});
      for (const u of living(deck)) {
        u.effects.push({kind:'maxhp', bonus:1, dur:DURATION});
        gFloat(u, '+MaxHP', '#34d399');
      }
      log(`${owner.toUpperCase()} üíö Rejuvenate for ${DURATION} turns`);
    }
  }
}

/*** End-of-round ticks ***/
function processEndOfRound(){
  function tick(deck, syn){
    for(const c of deck.filter(x=>x.type===TYPE_UNIT)){
      for(const e of c.effects){
        if((e.kind==='poison' || e.kind==='bleed' || e.kind==='burn') && e.dur>0 && c.alive){
          c.hpNow-=e.dmg; e.dur--;
          gFloat(c, `-${e.dmg}${e.kind==='poison'?'‚ò†':e.kind==='bleed'?'ü©∏':'üî•'}`,
                 e.kind==='poison'?'#7c3aed':(e.kind==='bleed'?'#b91c1c':'#fb923c'));
          if(c.hpNow<=0){ c.alive=false; }
        }
        if(e.kind==='shield' && e.dur>0){ e.dur--; }
        if(e.kind==='freeze' && e.dur>0){ e.dur--; if(e.dur===0) c.frozen=false; }
        if(e.kind==='bud' && e.dur>0 && c.alive){ healCard(c,1); e.dur--; }
        if(e.kind==='maxhp' && e.dur!=null && e.dur>0){ e.dur--; }
      }
      c.effects=c.effects.filter(e=> (e.dur==null)||e.dur>0);
      const newMax = getMaxHP(c); if (c.hpNow > newMax) c.hpNow = newMax;
      if(c.regen2 && c.alive) healCard(c,2 + (syn.healPlus||0));
      if(c.smiteHeal && c.alive) healCard(c,2);
    }
    const wards=deck.__wards||[];
    for(const w of wards){ if(w.dur>0){
      const allies=living(deck).sort((a,b)=>(a.hpNow/getMaxHP(a))-(b.hpNow/getMaxHP(b)));
      for(let i=0;i<Math.min(w.targets||2,allies.length);i++){ healCard(allies[i],w.heal); }
      w.dur--;
    }}
    deck.__wards=(wards||[]).filter(w=>w.dur>0);

    const hots = deck.__hots || [];
    for (const h of hots){ if(h.dur>0){ const allies=living(deck); for (const a of allies) healCard(a, h.heal); h.dur--; } }
    deck.__hots = hots.filter(h=>h.dur>0);

    for(const c of deck.filter(x=>x.baby && x.alive)){ c.alive=false; gFloat(c,'‚úñ','#6b7280'); }
  }
  tick(state.p1Deck, state.p1Syn); tick(state.p2Deck, state.p2Syn); renderBoards();
}

/*** Unit actions ***/
function actUnit(u, synSelf, flagsSelf){
  if(!u.alive) return;
  u.turnsAlive++;
  if(u.frozen){ log(`${u.owner.toUpperCase()} ${u.name} is frozen and skips.`); return; }

  // Ranged priority bump
  if((u.tags||[]).includes('ranged') && synSelf.rangedPriorityUp && u.priority>PRIORITY.HIGH) u.priority=PRIORITY.HIGH;

  // Healers
  if(u.heal1){
    const deck=u.owner==='p1'?state.p1Deck:state.p2Deck;
    const allies=living(deck).sort((a,b)=>(a.hpNow/getMaxHP(a))-(b.hpNow/getMaxHP(b)));
    if(allies.length) healCard(allies[0], Math.round(u.heal1.amt*starMult(u.stars)) + (synSelf.healPlus||0));
    log(`${u.owner.toUpperCase()} ${u.icon} ${u.name} heals`);
    return;
  }
  if(u.heal2){
    const deck=u.owner==='p1'?state.p1Deck:state.p2Deck;
    const allies=living(deck).sort((a,b)=>(a.hpNow/getMaxHP(a))-(b.hpNow/getMaxHP(b)));
    for(let i=0;i<Math.min(2,allies.length);i++){ healCard(allies[i],Math.round(u.heal2.amt*starMult(u.stars)) + (synSelf.healPlus||0)); }
    if(u.tags.includes('bubble') && allies.length){ const tgt=allies[0]; if(tgt && !hasShield(tgt)){ applyShield(tgt,1 + (flagsSelf.relicShieldPlus||0)); gFloat(tgt,'Bubble','var(--shield)'); } }
    log(`${u.owner.toUpperCase()} ${u.icon} ${u.name} heals two`);
    return;
  }
  if(u.wardSong){
    const deck=u.owner==='p1'?state.p1Deck:state.p2Deck;
    deck.__wards=deck.__wards||[]; deck.__wards.push({heal:2,dur:1,targets:2});
    for (const a of living(deck)) bigExplosion(a,'#34d399',8);
    log(`${u.owner.toUpperCase()} üéµ Bard inspires`);
  }

  let bonusMult = (u.alpha && u.turnsAlive===1)? 2 : 1;
  const oppDeck=u.owner==='p1'?state.p2Deck:state.p1Deck;
  const target=chooseTarget(oppDeck); if(!target) return;

  const doHit=()=>{
    const splashPlus = (synSelf.splashPlus||0);
    const poisonPlus = (synSelf.poisonPlus||0) + (flagsSelf.relicPoisonPlus||0);
    const poisonDurPlus = (synSelf.poisonDurPlus||0);
    const freezePlus = (synSelf.freezePlus||0);

    if(u.tags.includes('charge') && u.turnsAlive===1) bonusMult*=1.5;
    if(u.tags.includes('bleed') && u.turnsAlive===1) addBleed(target,1,2);

    if(u.tags.includes('pierce')){
      const others=living(oppDeck).filter(x=>x.id!==target.id);
      if(others.length && Math.random()<0.40){
        const second=others[RAND(others.length)];
        slashTrail(u, second, '#fca5a5');
        dealDamage(u, second, Math.floor(u.dmg*0.5), false);
      }
    }

    const allDmgMult = flagsSelf.relicAllDmg || 1;
    const rangedMult = (u.tags||[]).includes('ranged') && flagsSelf.relicRangedDmg ? flagsSelf.relicRangedDmg : 1;
    const finalBase = Math.round(u.dmg * allDmgMult * rangedMult);

    if(u.splash3){
      const arr=living(oppDeck); const n=Math.min(3,arr.length);
      for(let i=0;i<n;i++){ slashTrail(u, arr[i], '#ef4444'); dealDamage(u,arr[i],(finalBase+splashPlus)*bonusMult, true); if(u.tags.includes('burn')) addBurn(arr[i],1,2); }
      log(`${u.owner.toUpperCase()} ${u.icon} ${u.name} hits ${n}`);
    } else if(u.splash2){
      const arr=living(oppDeck); const n=Math.min(2,arr.length);
      for(let i=0;i<n;i++){ slashTrail(u, arr[i], '#ef4444'); dealDamage(u,arr[i],(finalBase+splashPlus)*bonusMult, true); }
      log(`${u.owner.toUpperCase()} ${u.icon} ${u.name} cleaves ${n}`);
    } else{
      slashTrail(u, target, '#ef4444');
      dealDamage(u,target,finalBase*bonusMult);
      if(u.freeze && target.alive) addFreeze(target,1+freezePlus);
      if(u.applyPoison && target.alive) addPoison(target, u.applyPoison.dmg + poisonPlus, u.applyPoison.dur + poisonDurPlus);
      if(u.smiteHeal) healCard(u,2);
      log(`${u.owner.toUpperCase()} ${u.icon} ${u.name} strikes ${target.name}`);
    }
  };

  // animation shim
  const aEl=findCardEl(u.id), dEl=findCardEl(target.id);
  if(!aEl||!dEl){ doHit(); return; }
  const a=aEl.getBoundingClientRect(), d=dEl.getBoundingClientRect();
  const dx=(d.left-a.left)*0.12, dy=(d.top-a.top)*0.12;
  aEl.style.transition=`transform ${160/state.speed}ms ease`; aEl.style.transform=`translate(${dx}px,${dy}px)`;
  setTimeout(()=>{ doHit(); aEl.style.transform='translate(0,0)';},180/state.speed);
}

/*** Synergies ***/
function computeSynergies(deck){
  const counts={}; const tagsByCard=deck.filter(c=>c.type===TYPE_UNIT).map(c=>c.tags||[]);
  for(const tags of tagsByCard){ for(const t of tags){ counts[t]=(counts[t]||0)+1; } }
  const buffs={_active:[]};
  for(const syn of SYNERGIES){
    if( (counts[syn.tag]||0) >= syn.t ){ syn.effect(buffs); buffs._active.push(syn.id); }
  }
  return buffs;
}

/*** Relic helpers ***/
function applyRelicsToFlags(list){
  const F={};
  for(const r of list) r.apply(F);
  return F;
}
function flashSynergyAndRelics(){
  const syn1 = SYNERGIES.filter(s=>state.p1Syn._active?.includes(s.id)).map(s=>s.label).join(' ‚Ä¢ ') || '';
  const syn2 = SYNERGIES.filter(s=>state.p2Syn._active?.includes(s.id)).map(s=>s.label).join(' ‚Ä¢ ') || '';
  const rel1 = state.p1Relics.map(r=>'üî∂ '+r.title).join(' ‚Ä¢ ');
  const rel2 = state.p2Relics.map(r=>'üî∂ '+r.title).join(' ‚Ä¢ ');
  const s1=document.getElementById('p1Syn'), s2=document.getElementById('p2Syn');
  const rf1=document.getElementById('p1RelFlash'), rf2=document.getElementById('p2RelFlash');
  s1.textContent = syn1; s2.textContent = syn2; rf1.textContent = rel1; rf2.textContent = rel2;
  s1.style.display=syn1? 'inline-block':'none'; s2.style.display=syn2? 'inline-block':'none';
  rf1.style.display=rel1? 'inline-block':'none'; rf2.style.display=rel2? 'inline-block':'none';
}

/*** Prepare teams ***/
function prepareForBattle(){
  // reset flags
  state.p1RelicFlags = applyRelicsToFlags(state.p1Relics);
  state.p2RelicFlags = applyRelicsToFlags(state.p2Relics);

  for(const c of state.p1Deck.concat(state.p2Deck)){
    if(c.type===TYPE_UNIT){
      c.alive=true; c.effects=[]; c.frozen=false; c.turnsAlive=0; c.baby=false;
      // base HP (with possible global HP penalty from Glass Arrows)
      const flag = c.owner==='p1'?state.p1RelicFlags:state.p2RelicFlags;
      const hpMult = (flag.relicHP||1);
      const baseMax = Math.round(c.hp * hpMult * starMult(c.stars));
      c.hpNow = baseMax;

      // Vigor (+maxhp effect + start heal)
      const rpct = flag.relicMaxHPPct||0, healPct = flag.relicStartHealPct||0;
      if(rpct>0){
        const bonus = Math.max(1, Math.round(baseMax * rpct));
        c.effects.push({kind:'maxhp', bonus, dur:null});
        const healAmt = Math.max(1, Math.round(baseMax * healPct));
        c.hpNow = Math.min(getMaxHP(c), c.hpNow + healAmt);
      }
    }
    if(c.type===TYPE_SPELL) c._used=false;
  }
}

/*** Battle loop ***/
async function playRound(){
  // reset retaliate flags
  for(const x of [...state.p1Deck, ...state.p2Deck]) x._retalUsed=false;

  const Y=living(state.p1Deck).sort((a,b)=>a.priority-b.priority);
  const F=living(state.p2Deck).sort((a,b)=>a.priority-b.priority);

  const fastP1 = state.p1RelicFlags.relicFasterHigh;
  const fastP2 = state.p2RelicFlags.relicFasterHigh;

  for(const u of [...Y,...F]){
    if(!u.alive) continue;
    const fast = (u.owner==='p1'?fastP1:fastP2) && u.priority===PRIORITY.HIGH;
    await waitMs((fast?140:190)/state.speed);
    actUnit(u, u.owner==='p1'?state.p1Syn:state.p2Syn, u.owner==='p1'?state.p1RelicFlags:state.p2RelicFlags);
    await waitMs(300/state.speed);
    if(living(state.p1Deck).length===0 || living(state.p2Deck).length===0) break;
  }
  await waitMs(220/state.speed);
  processEndOfRound();
}

async function battle(){
  if(state.playing) return;
  state.playing=true;
  setDraftPhase('Battle');

  state.p1Syn=computeSynergies(state.p1Deck);
  state.p2Syn=computeSynergies(state.p2Deck);
  prepareForBattle(); renderBoards(); renderDeckBars();

  // start shields from synergy & relics
  if(state.p1Syn.startShieldSmall){
    const allies=living(state.p1Deck).sort((a,b)=>a.hpNow-b.hpNow).slice(0,state.p1Syn.startShieldSmall);
    for(const a of allies){ applyShield(a,1+(state.p1RelicFlags.relicShieldPlus||0)); gFloat(a,'üõ°','var(--shield)'); }
  }
  if(state.p2Syn.startShieldSmall){
    const allies=living(state.p2Deck).sort((a,b)=>a.hpNow-b.hpNow).slice(0,state.p2Syn.startShieldSmall);
    for(const a of allies){ applyShield(a,1+(state.p2RelicFlags.relicShieldPlus||0)); gFloat(a,'üõ°','var(--shield)'); }
  }
  if(state.p1RelicFlags.relicFirstShield){
    const allies=living(state.p1Deck).sort((a,b)=>a.hpNow-b.hpNow).slice(0,2);
    for(const a of allies){ applyShield(a,1+(state.p1RelicFlags.relicShieldPlus||0)); gFloat(a,'üõ°','var(--shield)'); }
  }
  if(state.p2RelicFlags.relicFirstShield){
    const allies=living(state.p2Deck).sort((a,b)=>a.hpNow-b.hpNow).slice(0,2);
    for(const a of allies){ applyShield(a,1+(state.p2RelicFlags.relicShieldPlus||0)); gFloat(a,'üõ°','var(--shield)'); }
  }

  flashSynergyAndRelics();

  // spells once
  castSpellsOnce(state.p1Deck,'p1',state.p1Syn,state.p1RelicFlags);
  castSpellsOnce(state.p2Deck,'p2',state.p2Syn,state.p2RelicFlags);

  // loop
  let rounds=1;
  while(living(state.p1Deck).length>0 && living(state.p2Deck).length>0){
    log(`<b>Round ${rounds}</b>`);
    await playRound();
    if(living(state.p1Deck).length===0 || living(state.p2Deck).length===0) break;
    rounds++;
    await waitMs(340/state.speed);
  }
  const win=living(state.p1Deck).length>0;
  log(win?`<b>P1 Victory!</b>`:`<b>P2 Victory!</b>`);
  state.playing=false;

  // Between-battle: round++ ‚Üí if multiple rounds wanted, open relic draft on 5th, then normal draft
  setRound(state.round+1);
  // Every 5th round: relic draft first
  if((state.round-1) % 5 === 0){ openRelicDraft(()=> openSimulDraft({count:1,forceCommon:false, title:`Round ${state.round} Draft`})); }
  else { openSimulDraft({count:1,forceCommon:false, title:`Round ${state.round} Draft`}); }
}

/*** Simultaneous Drafts ***/
function draftWeightsForLevel(){ return {common:58, rare:30, epic:10, legend:2}; }
function weightedPick(weights){
  const entries=Object.entries(weights);
  const total=entries.reduce((s,[,v])=>s+v,0);
  let r=Math.random()*total;
  for(const [k,v] of entries){ if((r-=v)<=0) return k; }
  return entries[0][0];
}
function poolByRarity(rar){ return PLAYER_POOL.filter(n=>CATALOG[n].rar===RAR[rar.toUpperCase()]); }

function makeChoiceCard(c, onPick){
  const box=document.createElement('div');
  box.className='card rarity-'+rarClass(c.rar);
  box.innerHTML=`
    <div class="rowline"><div class="emoji">${c.icon||'üÇ†'}</div><div class="stars">${fmtStars(c.stars)}</div></div>
    <div class="rowline"><div class="name">${c.name}</div><div class="rar ${rarClass(c.rar)}">${c.rar.toUpperCase()}</div></div>
    <div class="statline">${c.type===TYPE_UNIT?`<span>HP ${c.hpNow}</span><span>DMG ${c.dmg}</span><span>${prioName(c.priority)}</span>`:`<span>Spell</span>`}</div>
    <div class="statline">${(c.tags||[]).map(t=>`<span class="tag">${t}</span>`).join('')}</div>`;
  box.onclick=()=>{ onPick(); box.classList.add('picked'); };
  return box;
}

function openSimulDraft({count=1, forceCommon=false, title='Draft'}={}){
  state.openDraftCountRemaining = count;
  state.forceCommon = forceCommon;
  document.getElementById('draftTitle').textContent = title + (forceCommon?' ‚Äî COMMONS':'');
  setDraftPhase(forceCommon?`Opening (remaining ${count})`:`Round ${state.round} Draft`);
  nextSimulPick();
}

function nextSimulPick(){
  const modal=document.getElementById('draftModal'); modal.classList.add('on');
  const a=document.getElementById('draftChoicesP1'); const b=document.getElementById('draftChoicesP2');
  a.innerHTML=''; b.innerHTML='';
  state.awaitingP1=true; state.awaitingP2=true;
  document.getElementById('noteP1').textContent=''; document.getElementById('noteP2').textContent='';
  document.getElementById('draftFooterNote').textContent = `Picks left in this draft phase: ${state.openDraftCountRemaining}`;

  const buildSet = ()=>{
    if(state.forceCommon){
      const commons = poolByRarity('common');
      return [makeCard(commons[RAND(commons.length)],1), makeCard(commons[RAND(commons.length)],1), makeCard(commons[RAND(commons.length)],1)];
    }else{
      const w = draftWeightsForLevel();
      const rarPick = weightedPick(w);
      const pool = poolByRarity(rarPick);
      const fall = PLAYER_POOL;
      const choose = (pool.length?pool:fall);
      return [makeCard(choose[RAND(choose.length)],1), makeCard(choose[RAND(choose.length)],1), makeCard(choose[RAND(choose.length)],1)];
    }
  };

  const setP1=buildSet(), setP2=buildSet();
  for(const c of setP1){
    const el=makeChoiceCard(c, ()=>{
      if(!state.awaitingP1) return;
      pickFor('p1',c);
      state.awaitingP1=false;
      document.getElementById('noteP1').textContent='‚úì Pick locked';
      maybeCloseDraftStep();
    });
    a.appendChild(el);
  }
  for(const c of setP2){
    const el=makeChoiceCard(c, ()=>{
      if(!state.awaitingP2) return;
      pickFor('p2',c);
      state.awaitingP2=false;
      document.getElementById('noteP2').textContent='‚úì Pick locked';
      maybeCloseDraftStep();
    });
    b.appendChild(el);
  }
}

function pickFor(owner, card){
  const deck = owner==='p1'?state.p1Deck:state.p2Deck;
  if(deck.length>=20){
    // remove lowest rarity oldest first
    const idx = deck.findIndex(x=>x.type===TYPE_UNIT||x.type===TYPE_SPELL);
    if(idx>=0) deck.splice(idx,1);
  }
  const c = clone(card); c.owner = owner;
  (owner==='p1'?state.p1Deck:state.p2Deck).push(c);
  renderDeckBars();
}

function maybeCloseDraftStep(){
  if(state.awaitingP1 || state.awaitingP2) return;
  state.openDraftCountRemaining--;
  if(state.openDraftCountRemaining>0){
    // Next simultaneous pick in same phase
    nextSimulPick();
  }else{
    // Phase complete
    document.getElementById('draftModal').classList.remove('on');
    // If we just finished opening draft, start the first battle
    if(state.forceCommon){
      state.forceCommon=false;
      setDraftPhase('‚Äî');
      battle();
    }else{
      // Between-round draft finished ‚Üí start next battle
      battle();
    }
  }
}

/*** Relic Draft (simultaneous) ***/
function relicChoiceCard(r, onPick){
  const box=document.createElement('div');
  box.className='card rarity-legend';
  box.innerHTML=`
    <div class="rowline"><div class="emoji">üî∂</div><div class="stars">Relic</div></div>
    <div class="rowline"><div class="name">${r.title}</div><div class="rar legend">RELIC</div></div>
    <div class="statline"><span>${r.desc}</span></div>`;
  box.onclick=()=>{ onPick(); box.classList.add('picked'); };
  return box;
}

function openRelicDraft(onDone){
  const modal=document.getElementById('relicModal'); modal.classList.add('on');
  const a=document.getElementById('relicChoicesP1'); const b=document.getElementById('relicChoicesP2');
  a.innerHTML=''; b.innerHTML='';
  let lockP1=false, lockP2=false;

  const choices1=[...RELICS].sort(()=>Math.random()-0.5).slice(0,3);
  const choices2=[...RELICS].sort(()=>Math.random()-0.5).slice(0,3);

  for(const r of choices1){
    a.appendChild(relicChoiceCard(r, ()=>{
      if(lockP1) return; lockP1=true;
      state.p1Relics.push(r);
      if(lockP1 && lockP2){ modal.classList.remove('on'); onDone&&onDone(); }
    }));
  }
  for(const r of choices2){
    b.appendChild(relicChoiceCard(r, ()=>{
      if(lockP2) return; lockP2=true;
      state.p2Relics.push(r);
      if(lockP1 && lockP2){ modal.classList.remove('on'); onDone&&onDone(); }
    }));
  }
}

/*** Detail ***/
function showDetail(c){
  const m=document.getElementById('detailModal'); m.classList.add('on');
  const base=CATALOG[c.name]; const b=document.getElementById('detailBody');
  b.innerHTML=`
    <h2 style="margin:0 0 6px 0">${c.icon||''} ${c.name}${c.baby?' (baby)':''}</h2>
    <div style="color:#475569;font-size:13px;margin-bottom:8px">${c.type.toUpperCase()} ‚Ä¢ ${c.rar.toUpperCase()} ‚Ä¢ ${fmtStars(c.stars)} ${c.type===TYPE_UNIT?`‚Ä¢ Priority: ${prioName(c.priority)}`:''}</div>
    ${c.type===TYPE_UNIT?`
      <div>Max HP now: ${getMaxHP(c)}, Damage: ${Math.round((c.dmg||0)*starMult(c.stars))}</div>
      <div style="margin-top:6px">Tags: ${(c.tags||[]).join(', ')||'‚Äî'}</div>
    `:`<div>Spell: <code>${JSON.stringify(base.spell)}</code></div>`}
  `;
}
function hideDetail(){ document.getElementById('detailModal').classList.remove('on'); }

/*** Controls ***/
document.getElementById('btnSpeed').onclick=()=>{speedIdx=(speedIdx+1)%SPEEDS.length; state.speed=SPEEDS[speedIdx]; document.getElementById('btnSpeed').textContent=`Speed: ${state.speed}x`;};

/*** Bootstrap ***/
function startGame(){
  state.round=1; setRound(1);
  state.p1Deck=[]; state.p2Deck=[];
  state.p1Relics=[]; state.p2Relics=[];
  state.p1RelicFlags={}; state.p2RelicFlags={};
  document.getElementById('log').innerHTML='';
  renderDeckBars(); renderBoards();
  // Opening: 3x COMMON picks simultaneously
  openSimulDraft({count:3, forceCommon:true, title:'Opening Draft'});
}
startGame();
</script>
</body>
</html>

