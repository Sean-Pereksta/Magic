<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>üìñ Bible Game (Multiplayer)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<style>
  :root{
    --bg:#fffaf5; --ink:#0f172a; --muted:#64748b; --panel:#ffffff; --br:#f1e7da;
    --accent:#7c3aed; --accent-2:#6d28d9; --good:#16a34a; --bad:#ef4444; --warn:#f59e0b;
    --chip:#f5f3ff; --shadow:0 10px 30px rgba(2,6,23,.08); --radius:14px;
    --tap:56px;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--ink)}
  .wrap{max-width:820px;margin:0 auto;padding:10px}
  header{display:flex;align-items:center;justify-content:space-between;gap:8px;margin:6px 0 10px}
  .brand{display:flex;align-items:center;gap:8px}
  .logo{width:34px;height:34px;border-radius:10px;display:grid;place-items:center;background:#ede9fe;border:1px solid #ddd6fe;font-size:18px}
  h1{font-size:1.05rem;margin:0}
  .badge{display:inline-flex;gap:6px;align-items:center;padding:6px 10px;border-radius:999px;border:1px solid #ddd6fe;background:#f5f3ff;color:#3730a3;font-weight:800}
  .panel{background:var(--panel);border:1px solid var(--br);border-radius:var(--radius);box-shadow:var(--shadow);padding:10px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .muted{color:var(--muted)}
  .pill{display:inline-flex;align-items:center;gap:6px;padding:5px 9px;border-radius:999px;border:1px solid var(--br);background:#fff;font-weight:700}
  .timer{font-weight:900;letter-spacing:.3px}
  .title{font-weight:900;font-size:1rem}
  .btn{appearance:none;border:none;cursor:pointer;background:var(--accent);color:#fff;font-weight:900;padding:10px 12px;border-radius:12px;min-height:40px}
  .btn:hover{background:var(--accent-2)}
  .btn-ghost{background:#fff;border:1px solid var(--br);color:#0f172a}
  .btn.small{padding:7px 10px;min-height:34px;border-radius:10px}
  .scores{display:grid;grid-template-columns:1fr 1fr;gap:6px}
  .scores .entry{display:flex;align-items:center;justify-content:space-between;padding:6px 8px;border:1px solid var(--br);border-radius:10px;background:#fff}
  .scores .name{font-weight:800;font-size:.95rem}
  .verse-box{padding:10px;border:1px solid var(--br);border-radius:12px;background:#fff}
  .verse-text{font-size:1rem;line-height:1.45}
  .inputs{display:grid;grid-template-columns:1.2fr .5fr .5fr auto;gap:6px;margin-top:8px}
  @media (max-width:520px){ .inputs{grid-template-columns:1fr 1fr 1fr auto} }
  select, input[type="number"], input[type="text"]{width:100%;padding:9px 9px;border:1px solid var(--br);border-radius:10px;font-size:16px;outline:none;background:#fff}
  select:focus, input:focus{border-color:#e9d5ff;box-shadow:0 0 0 3px rgba(124,58,237,.15)}
  .sm{font-size:.9rem}
  .vote-grid{display:grid;grid-template-columns: repeat(2,minmax(0,1fr)); gap:8px}
  .card{border:1px solid var(--br);border-radius:12px;padding:9px;background:#fff;display:flex;gap:8px;align-items:center;justify-content:space-between}
  .card .left{display:grid}
  .card.leader{border-color:#7c3aed; box-shadow:0 0 0 3px rgba(124,58,237,.13)}
  .chat{border:1px solid var(--br);border-radius:12px;background:#fff;display:grid;gap:6px;padding:8px}
  .chatlog{display:grid;gap:4px;min-height:24px}
  .bubble{padding:6px 8px;border-radius:9px;background:#f8fafc;border:1px solid #eef2f7;font-size:.92rem}
  .teamA{--team:#0ea5e9} .teamB{--team:#ef4444}
  .team-tag{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:9px;background:rgba(0,0,0,.04);border:1px solid #e5e7eb}
  .team-chip{width:10px;height:10px;border-radius:50%;background:var(--team)}
  .teams-bar{display:flex;align-items:center;justify-content:space-between;gap:6px}
  .teams-bar .tot{font-weight:900}
  .books-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:6px}
  @media (max-width:560px){ .books-grid{grid-template-columns:repeat(2,1fr)} }
  .book-btn{border:1px solid var(--br);background:#fff;border-radius:10px;padding:8px;cursor:pointer}
  .book-btn[disabled]{opacity:.5;cursor:not-allowed}
  .pickbar{display:flex;flex-wrap:wrap;gap:6px}
  .pick{background:#f1f5f9;border:1px solid #e2e8f0;padding:5px 9px;border-radius:999px;font-size:.92rem}
  .help{font-size:.9rem;color:#475569}
  .toprow{display:grid;gap:8px}
  .header-actions{display:flex;gap:6px;align-items:center}
</style>
</head>
<body>
<div class="wrap">

  <header>
    <div class="brand">
      <div class="logo">üìñ</div>
      <div>
        <div class="title">Bible Game</div>
        <div class="muted sm" id="subtitle">Connecting‚Ä¶</div>
      </div>
    </div>
    <div class="header-actions">
      <button class="btn-ghost small" id="fsBtn" title="Fullscreen">‚õ∂</button>
      <button class="btn-ghost small" id="leaveBtn">Leave</button>
    </div>
  </header>

  <!-- ALWAYS TOP: SCORES -->
  <section class="panel" id="scoresPanel">
    <div class="row" style="justify-content:space-between">
      <span class="badge"><span id="modeLabel">Vote</span> ‚Ä¢ <span class="timer" id="timer">--:--</span></span>
      <span class="pill">Host: <b id="hostName">‚Äî</b></span>
    </div>
    <div id="scoreboard" class="scores" style="margin-top:6px"></div>
  </section>

  <!-- MAIN STACK -->
  <section class="panel" id="phase-vote" style="display:none">
    <div class="row" style="justify-content:space-between;align-items:flex-end">
      <div>
        <div class="title">Vote: Game Type (30s)</div>
        <div class="muted sm">Traditional ‚Ä¢ Speed ‚Ä¢ Draft ‚Ä¢ Teams</div>
      </div>
      <div class="pill">Your vote: <strong id="myVote">‚Äî</strong></div>
    </div>
    <div class="vote-grid" style="margin-top:8px">
      <button class="card" data-mode="traditional">
        <div class="left"><b>üï∞Ô∏è Traditional</b><span class="sm muted">6 rounds, shared verse</span></div>
        <span class="pill">Votes: <b id="v-traditional">0</b></span>
      </button>
      <button class="card" data-mode="speed">
        <div class="left"><b>‚ö° Speed</b><span class="sm muted">90s, per-player verses, -1 all-wrong</span></div>
        <span class="pill">Votes: <b id="v-speed">0</b></span>
      </button>
      <button class="card" data-mode="draft">
        <div class="left"><b>üß≠ Draft</b><span class="sm muted">Snake picks ‚Ä¢ 3 books ‚Ä¢ -3 wrong book</span></div>
        <span class="pill">Votes: <b id="v-draft">0</b></span>
      </button>
      <button class="card" data-mode="teams">
        <div class="left"><b>üë• Teams</b><span class="sm muted">6 rounds ‚Ä¢ team chat ‚Ä¢ first answer locks</span></div>
        <span class="pill">Votes: <b id="v-teams">0</b></span>
      </button>
    </div>
    <div class="help" style="margin-top:6px">Highest votes wins. Ties: randomly chosen.</div>
  </section>

  <section class="panel" id="phase-draft" style="display:none">
    <div class="row" style="justify-content:space-between;align-items:flex-end">
      <div>
        <div class="title">Draft: Pick 3 Books</div>
        <div class="muted sm">Snake order ‚Ä¢ 10s per pick ‚Ä¢ Turn: <b id="turnName">‚Äî</b></div>
      </div>
      <div class="pickbar" id="myPicks"></div>
    </div>
    <div class="books-grid" id="booksGrid" style="margin-top:8px"></div>
  </section>

  <section class="panel" id="phase-play" style="display:none">
    <!-- Teams meta (scores + chat) -->
    <div id="teamsBar" class="teams-bar" style="display:none; margin-bottom:8px">
      <div class="teamA tot">Team A: <span id="teamAScore">0</span></div>
      <div class="teamB tot">Team B: <span id="teamBScore">0</span></div>
    </div>

    <div id="teamChatWrap" style="display:none; margin-bottom:8px">
      <div class="chat">
        <div class="row" style="justify-content:space-between">
          <div class="team-tag"><span class="team-chip"></span><span id="teamLabel">Team</span> chat</div>
          <div class="muted sm">Last 3 messages</div>
        </div>
        <div class="chatlog" id="chatLog"></div>
        <div class="row">
          <input id="chatInput" type="text" placeholder="Type hint/idea‚Ä¶" />
          <button class="btn small" id="sendChat">Send</button>
        </div>
      </div>
    </div>

    <div class="verse-box">
      <div class="muted sm" id="verseHeader">Verse</div>
      <div class="verse-text" id="verseText">Loading verses‚Ä¶</div>
    </div>

    <div class="inputs">
      <select id="bookInput"></select>
      <input id="chapInput" type="number" min="1" placeholder="Chapter" />
      <input id="verseInput" type="number" min="1" placeholder="Verse" />
      <button class="btn" id="submitBtn">Submit</button>
    </div>

    <div id="playHelp" class="help" style="margin-top:6px"></div>
  </section>

  <section class="panel" id="phase-end" style="display:none">
    <div class="title">Game Over</div>
    <div class="muted sm">Final standings above. Host can start again or head back.</div>
    <div class="row" style="margin-top:8px">
      <button class="btn" id="playAgainBtn">Play Again</button>
      <button class="btn-ghost" id="toLobbyBtn">Back to Lobby</button>
    </div>
  </section>

</div>

<!-- Firebase (v10 modular) -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import {
    getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, addDoc,
    serverTimestamp, query, orderBy, limit, getDocs, runTransaction, increment
  } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

  // ---------- CONFIG ----------
  const firebaseConfig = {
    apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
    authDomain: "bible-game-246c0.firebaseapp.com",
    projectId: "bible-game-246c0",
    storageBucket: "bible-game-246c0.appspot.com",
    messagingSenderId: "959619818996",
    appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // ---------- DOM SHORTCUTS ----------
  const $ = (id)=> document.getElementById(id);
  const qs = (sel)=> document.querySelector(sel);

  // ---------- QUERY PARAMS ----------
  const url = new URL(location.href);
  const gameId = url.searchParams.get('gameId') || '';
  const username = url.searchParams.get('username') || '';

  // ---------- GLOBAL STATE ----------
  let LOBBY = null, GAME = null, HOST = null, isHost = false;
  let verses = [], books = [], bookSet = new Set();
  let myCurrentVerse = null, tickTimer = null;

  // ---------- FS REFS ----------
  const lobbyRef  = doc(db, 'lobbies', gameId);
  const gameRef   = doc(db, 'games', gameId);
  const votesCol  = collection(db, 'games', gameId, 'votes');
  const pstateCol = collection(db, 'games', gameId, 'playerState');
  const chatCol   = collection(db, 'games', gameId, 'chat');

  // ---------- HELPERS ----------
  const now = ()=> Date.now();
  const fmtTime = (ms)=> { if (ms<0) ms=0; const s=Math.floor(ms/1000), m=Math.floor(s/60), r=s%60; return `${m}:${String(r).padStart(2,'0')}`; };
  const shuffle = (arr)=> arr.map(v=>[Math.random(),v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]);

  function parseCSV(text){
    const rows=[]; let row=[], val=''; let inQ=false;
    for (let i=0;i<text.length;i++){
      const c = text[i];
      if (inQ){
        if (c === '"'){ if (text[i+1] === '"'){ val+='"'; i++; } else inQ=false; }
        else val += c;
      } else {
        if (c === '"') inQ=true;
        else if (c === ','){ row.push(val); val=''; }
        else if (c === '\n'){ row.push(val); rows.push(row); row=[]; val=''; }
        else if (c === '\r'){ }
        else val += c;
      }
    }
    if (val.length || row.length){ row.push(val); rows.push(row); }
    return rows;
  }
  const normBook = (s)=> (s||'').toString().trim().replace(/\s+/g,' ').toLowerCase();

  function buildBooksAndVerses(rows){
    const H = rows[0].map(h => (h||'').toString().trim());
    const idx = (name)=> H.findIndex(h => h.toLowerCase() === name.toLowerCase());
    const idI=idx('VerseID'), bookI=idx('BookName'), bookNumI=idx('BookNumber'), chapI=idx('Chapter'), verseI=idx('Verse'), textI=idx('Text');
    const out=[];
    for (let i=1;i<rows.length;i++){
      const r = rows[i]; if (!r || !r.length) continue;
      const id=parseInt(r[idI],10), book=(r[bookI]||'').toString().trim();
      const chap=parseInt(r[chapI],10), ver=parseInt(r[verseI],10), txt=(r[textI]||'').toString().trim();
      if (!id || !book || !chap || !ver || !txt) continue;
      out.push({id,book,chapter:chap,verse:ver,text:txt});
      if (!bookSet.has(book)){ bookSet.add(book); books.push(book); }
    }
    books.sort((a,b)=> a.localeCompare(b));
    return out;
  }
  function fillBookDropdown(){
    const sel = $('bookInput'); sel.innerHTML='';
    const blank = document.createElement('option'); blank.value=''; blank.textContent='Book';
    sel.appendChild(blank);
    for (const b of books){ const o=document.createElement('option'); o.value=b; o.textContent=b; sel.appendChild(o); }
  }

  // NEW SCORING: 1=book, 3=book+chapter, 5=book+chapter+verse
  function scoreAnswer(guess, correct, mode){
    const bookOK = normBook(guess.book)===normBook(correct.book);
    const chapOK = Number(guess.chapter)===Number(correct.chapter);
    const verOK  = Number(guess.verse)===Number(correct.verse);
    let pts = 0;
    if (bookOK && chapOK && verOK) pts = 5;
    else if (bookOK && chapOK) pts = 3;
    else if (bookOK) pts = 1;

    if (mode==='speed'){
      if (!bookOK && !chapOK && !verOK) pts -= 1; // all wrong
    } else if (mode==='draft'){
      if (!bookOK) pts -= 3; // wrong book
    }
    return pts;
  }

  function pickRandomVerse(filterFn=null, excludeSet=null){
    let pool = verses;
    if (filterFn) pool = pool.filter(filterFn);
    if (excludeSet) pool = pool.filter(v => !excludeSet.has(v.id));
    if (!pool.length) return null;
    return pool[Math.floor(Math.random()*pool.length)];
  }

  // ---------- UI ----------
  $('leaveBtn').onclick = ()=> { location.href = `/index.html?username=${encodeURIComponent(username)}`; };
  $('fsBtn').onclick = toggleFullscreen;
  function toggleFullscreen(){
    const d = document;
    if (!d.fullscreenElement && !d.webkitFullscreenElement){
      const el = d.documentElement;
      (el.requestFullscreen||el.webkitRequestFullscreen||el.mozRequestFullScreen||el.msRequestFullscreen).call(el);
    } else {
      (d.exitFullscreen||d.webkitExitFullscreen||d.mozCancelFullScreen||d.msExitFullscreen).call(d);
    }
  }

  for (const btn of document.querySelectorAll('#phase-vote .card')){
    btn.addEventListener('click', ()=> submitVote(btn.dataset.mode));
  }
  $('submitBtn').onclick = onSubmitAnswer;
  $('sendChat').onclick = sendChat;
  $('toLobbyBtn').onclick = ()=> location.href = `/index.html?username=${encodeURIComponent(username)}`;
  $('playAgainBtn').onclick = async ()=> {
    if (!isHost) return;
    await runTransaction(db, async (tx)=>{
      const l = await tx.get(lobbyRef); if (!l.exists()) throw 'no lobby';
      const players = l.data().players || [];
      tx.set(gameRef, {
        status:'voting',
        host:l.data().host || players[0] || username,
        players,
        mode:null,
        deadline: now()+30000,
        round:0,
        scores: Object.fromEntries(players.map(p=>[p,0])),
        teamTotals:{A:0,B:0},
        teamLocks:{},
        picks: {},
        pickOrder: players,
        pickIndex: 0,
        picksPerPlayer: 3,
        chosenShared: [],
        endAt: 0,
        turnDeadline: 0
      }, {merge:true});
    });
  };

  // ---------- STARTUP ----------
  main().catch(console.error);

  async function main(){
    if (!gameId || !username){ $('subtitle').textContent='Missing gameId/username'; return; }

    const lobbySnap = await getDoc(lobbyRef);
    if (!lobbySnap.exists()){ $('subtitle').textContent='Lobby not found.'; return; }
    LOBBY = lobbySnap.data();
    HOST = LOBBY.host || (LOBBY.players && LOBBY.players[0]) || username;
    isHost = (username === HOST);
    $('hostName').textContent = HOST;
    $('subtitle').textContent = `You are ${username} ‚Ä¢ Players: ${(LOBBY.players||[]).join(', ')}`;

    // Load verses
    const csvUrl = 'https://raw.githubusercontent.com/Sean-Pereksta/Bible-Data/refs/heads/main/web.csv';
    const csvText = await (await fetch(csvUrl, {cache:'force-cache'})).text();
    const rows = parseCSV(csvText);
    verses = buildBooksAndVerses(rows);
    fillBookDropdown();

    // Ensure game doc
    const gSnap = await getDoc(gameRef);
    if (!gSnap.exists() && isHost){
      const players = LOBBY.players || [username];
      await setDoc(gameRef, {
        status:'voting',
        host: HOST,
        players,
        mode:null,
        deadline: now()+30000,
        round:0,
        scores: Object.fromEntries(players.map(p=>[p,0])),
        teamTotals:{A:0,B:0},
        teamLocks:{},
        picks: {},
        pickOrder: players,
        pickIndex: 0,
        picksPerPlayer: 3,
        chosenShared: [],
        endAt: 0,
        turnDeadline: 0
      });
    }

    // Game listener
    onSnapshot(gameRef, (snap)=>{ if (!snap.exists()) return; GAME = snap.data(); render(); });

    // Votes listener
    onSnapshot(votesCol, (qsnap)=>{
      const counts = {traditional:0, speed:0, draft:0, teams:0};
      qsnap.forEach(doc=>{ const m=doc.data().mode; if (counts[m]!==undefined) counts[m]++; });
      $('v-traditional').textContent = counts.traditional;
      $('v-speed').textContent       = counts.speed;
      $('v-draft').textContent       = counts.draft;
      $('v-teams').textContent       = counts.teams;
      highlightVoteLeader(counts);
    });

    // Chat listener (buffer, show last 3 of your team)
    onSnapshot(query(chatCol, orderBy('ts','desc'), limit(12)), (qsnap)=>{
      const msgs=[]; qsnap.forEach(d=> msgs.push(d.data())); msgs.reverse(); drawChat(msgs);
    });

    // Player state (my current verse for speed/draft)
    onSnapshot(doc(pstateCol, username), (psnap)=>{
      const st = psnap.exists() ? psnap.data() : null;
      if (st && st.currentVerseId){
        const v = verses.find(x=> x.id === st.currentVerseId);
        if (v){ myCurrentVerse = v; maybeShowVerse(); }
      }
    });

    // Timers
    if (tickTimer) clearInterval(tickTimer);
    tickTimer = setInterval(isHost ? hostDrive : updateCountdownUI, 250);
  }

  // ---------- RENDER ----------
  function render(){
    if (!GAME) return;

    const phase = GAME.status || 'voting';
    const mode  = GAME.mode || 'Vote';
    $('modeLabel').textContent = (phase==='voting') ? 'Vote' : (mode.charAt(0).toUpperCase()+mode.slice(1));

    // Toggle views (avoid nulls)
    $('phase-vote').style.display  = (phase === 'voting')   ? 'block' : 'none';
    $('phase-draft').style.display = (phase === 'drafting') ? 'block' : 'none';
    $('phase-play').style.display  = (phase === 'playing')  ? 'block' : 'none';
    $('phase-end').style.display   = (phase === 'ended')    ? 'block' : 'none';

    drawScores();

    if (phase === 'drafting'){
      buildDraftUI();
    } else if (phase === 'playing'){
      if (GAME.mode === 'teams'){
        $('teamsBar').style.display = 'flex';
        $('teamAScore').textContent = (GAME.teamTotals && GAME.teamTotals.A) || 0;
        $('teamBScore').textContent = (GAME.teamTotals && GAME.teamTotals.B) || 0;
        $('teamChatWrap').style.display = 'block';
      } else {
        $('teamsBar').style.display = 'none';
        $('teamChatWrap').style.display = 'none';
      }
      buildPlayHelp();
      maybeShowVerse();
    }
    updateCountdownUI();
  }

  function drawScores(){
    const sb = $('scoreboard'); sb.innerHTML='';
    const players = (GAME.players || []);
    const scores = (GAME.scores || {});
    const order = players.slice().sort((a,b)=> (scores[b]||0) - (scores[a]||0));
    for (const p of order){
      const row = document.createElement('div'); row.className='entry';
      const name = document.createElement('div'); name.className='name'; name.textContent = p + (p === GAME.host ? ' ‚≠ê' : '');
      const sc = document.createElement('div'); sc.innerHTML = `üèÜ <b>${scores[p]||0}</b>`;
      row.appendChild(name); row.appendChild(sc);
      sb.appendChild(row);
    }
  }

  function updateCountdownUI(){
    if (!GAME) return;
    let t=0;
    if (GAME.status === 'voting' || GAME.status === 'drafting'){
      t = (GAME.turnDeadline || GAME.deadline || 0) - now();
    } else if (GAME.status === 'playing'){
      t = (GAME.mode==='speed' || GAME.mode==='draft') ? (GAME.endAt||0) - now() : (GAME.deadline||0) - now();
    }
    $('timer').textContent = fmtTime(t);
  }

  function highlightVoteLeader(counts){
    for (const btn of document.querySelectorAll('#phase-vote .card')) btn.classList.remove('leader');
    const max = Math.max(counts.traditional, counts.speed, counts.draft, counts.teams);
    const leaders = [];
    if (counts.traditional===max) leaders.push('traditional');
    if (counts.speed===max)       leaders.push('speed');
    if (counts.draft===max)       leaders.push('draft');
    if (counts.teams===max)       leaders.push('teams');
    for (const m of leaders){
      const el = document.querySelector(`#phase-vote .card[data-mode="${m}"]`);
      if (el) el.classList.add('leader');
    }
  }

  // ---------- VOTE ----------
  async function submitVote(mode){
    $('myVote').textContent = mode[0].toUpperCase()+mode.slice(1);
    await setDoc(doc(votesCol, username), {mode, ts: serverTimestamp()});
  }

  // ---------- HOST DRIVER ----------
  async function hostDrive(){
    if (!GAME) return;
    updateCountdownUI();
    const tnow = now();

    if (GAME.status === 'voting'){
      if (tnow >= (GAME.deadline || 0)){
        const vSnap = await getDocs(votesCol);
        const counts = {traditional:0, speed:0, draft:0, teams:0};
        vSnap.forEach(d=>{ const m=d.data().mode; if (counts[m]!==undefined) counts[m]++; });

        const max = Math.max(counts.traditional, counts.speed, counts.draft, counts.teams);
        const top = Object.entries(counts).filter(([k,v])=> v===max).map(([k])=>k);
        let chosen = top[Math.floor(Math.random()*top.length)]; // random tie-break

        const baseUpdate = {
          mode: chosen, round: 0,
          scores: Object.fromEntries((GAME.players||[]).map(p=>[p,0])),
          chosenShared: []
        };

        if (chosen === 'draft'){
          await updateDoc(gameRef, {
            status:'drafting', ...baseUpdate,
            pickOrder: (GAME.players||[]),
            pickIndex: 0,
            picks: {},
            turnDeadline: tnow + 10000
          });
        } else if (chosen === 'teams'){
          const ps = (GAME.players||[]).slice();
          const A=[], B=[]; ps.forEach((p,i)=> (i%2===0?A:B).push(p));
          await updateDoc(gameRef, {
            status:'playing', ...baseUpdate,
            teamA:A, teamB:B, teamTotals:{A:0,B:0}, teamLocks:{A:false,B:false},
            round:1,
            currentSharedId: pickRandomVerse().id,
            deadline: tnow + 30000
          });
        } else if (chosen === 'speed'){
          await updateDoc(gameRef, { status:'playing', ...baseUpdate, endAt: tnow + 90000 });
          await seedPerPlayerVerses();
        } else { // traditional
          await updateDoc(gameRef, {
            status:'playing', ...baseUpdate,
            round:1,
            currentSharedId: pickRandomVerse().id,
            deadline: tnow + 30000
          });
        }
      }
    }
    else if (GAME.status === 'drafting'){
      if (tnow >= (GAME.turnDeadline || 0)){ await autoPickIfNeeded(); }
      const picks = GAME.picks || {};
      const done = (GAME.players||[]).every(p => (picks[p]||[]).length >= (GAME.picksPerPlayer||3));
      if (done){
        await updateDoc(gameRef, { status:'playing', endAt: tnow + 90000 });
        await seedPerPlayerVerses(true);
      }
    }
    else if (GAME.status === 'playing'){
      const mode = GAME.mode;
      if (mode === 'traditional' || mode === 'teams'){
        if (tnow >= (GAME.deadline || 0)){
          const nextRound = (GAME.round||1) + 1;
          if (nextRound > 6){ await updateDoc(gameRef, {status:'ended', deadline:0}); }
          else {
            const chosenSet = new Set(GAME.chosenShared || []);
            let v = pickRandomVerse(null, chosenSet); if (!v) v = pickRandomVerse();
            chosenSet.add(v.id);
            await updateDoc(gameRef, {
              round: nextRound,
              currentSharedId: v.id,
              chosenShared: Array.from(chosenSet),
              deadline: tnow + 30000,
              teamLocks: {A:false,B:false}
            });
          }
        }
      } else { // speed/draft
        if (tnow >= (GAME.endAt || 0)){ await updateDoc(gameRef, {status:'ended'}); }
      }
    }
  }

  async function autoPickIfNeeded(){
    const order = GAME.pickOrder || [];
    const idx = GAME.pickIndex || 0;
    if (!order.length) return;
    const cur = order[idx % order.length];
    const picks = GAME.picks || {};
    const curPicks = picks[cur] || [];
    if (curPicks.length >= (GAME.picksPerPlayer||3)){
      const nextIdx = nextPickIndex(order, picks, GAME.picksPerPlayer||3, idx+1);
      await updateDoc(gameRef, { pickIndex: nextIdx, turnDeadline: now()+10000 });
      return;
    }
    await runTransaction(db, async (tx)=>{
      const g = await tx.get(gameRef); if (!g.exists()) return;
      const G = g.data();
      const P = G.picks || {};
      const mine = P[cur] || [];
      if (mine.length >= (G.picksPerPlayer||3)) return;
      const taken = new Set(Object.values(P).flat());
      const pool = books.filter(b=> !taken.has(b));
      const pick = pool.length ? pool[Math.floor(Math.random()*pool.length)] : books[Math.floor(Math.random()*books.length)];
      P[cur] = [...mine, pick];
      const nIdx = nextPickIndex(G.pickOrder||[], P, G.picksPerPlayer||3, (G.pickIndex||0)+1);
      tx.update(gameRef, { picks:P, pickIndex:nIdx, turnDeadline: now()+10000 });
    });
  }
  function nextPickIndex(order, picks, per, startIdx){
    let idx = startIdx;
    for (let guard=0; guard<order.length*4; guard++){
      const cur = order[idx % order.length];
      if ((picks[cur]||[]).length < per) break;
      idx++;
    }
    return idx % order.length;
  }
  async function seedPerPlayerVerses(restrict=false){
    const players = (GAME.players || []);
    for (const p of players){
      const filterFn = restrict ? (v)=> (GAME.picks && (GAME.picks[p]||[]).includes(v.book)) : null;
      const v = pickRandomVerse(filterFn);
      if (!v) continue;
      await setDoc(doc(pstateCol, p), { currentVerseId: v.id }, {merge:true});
    }
  }

  // ---------- DRAFT UI ----------
  function buildDraftUI(){
    $('turnName').textContent = (GAME.pickOrder||[])[GAME.pickIndex||0] || '‚Äî';
    const grid = $('booksGrid'); grid.innerHTML='';
    const taken = new Set(Object.values(GAME.picks||{}).flat());
    for (const b of books){
      const btn = document.createElement('button');
      btn.className='book-btn'; btn.textContent=b; btn.disabled = taken.has(b);
      btn.onclick = ()=> pickBook(b);
      grid.appendChild(btn);
    }
    const my = (GAME.picks && GAME.picks[username]) || [];
    const bar = $('myPicks'); bar.innerHTML='';
    for (const b of my){ const s=document.createElement('span'); s.className='pick'; s.textContent=b; bar.appendChild(s); }
  }
  async function pickBook(book){
    if (GAME.status!=='drafting') return;
    if ((GAME.pickOrder||[])[GAME.pickIndex||0] !== username) return;
    await runTransaction(db, async (tx)=>{
      const g = await tx.get(gameRef); if (!g.exists()) return;
      const G = g.data(); const P = G.picks || {}; const mine = P[username] || [];
      if (mine.includes(book) || mine.length >= (G.picksPerPlayer||3)) return;
      const taken = new Set(Object.values(P).flat()); if (taken.has(book)) return;
      P[username] = [...mine, book];
      const nextIdx = nextPickIndex(G.pickOrder||[], P, G.picksPerPlayer||3, (G.pickIndex||0)+1);
      tx.update(gameRef, { picks:P, pickIndex: nextIdx, turnDeadline: now()+10000 });
    });
  }

  // ---------- PLAY ----------
  function maybeShowVerse(){
    if (!GAME) return;
    const mode = GAME.mode;
    if (mode==='traditional' || mode==='teams'){
      const v = verses.find(x=> x.id === GAME.currentSharedId);
      $('verseHeader').textContent = `Round ${GAME.round||1} ‚Ä¢ Shared`;
      $('verseText').textContent = v ? v.text : '‚Äî';
    } else {
      $('verseHeader').textContent = (mode==='draft') ? 'Your verse (drafted books)' : 'Your verse';
      $('verseText').textContent = myCurrentVerse ? myCurrentVerse.text : '‚Äî';
    }
    $('bookInput').value=''; $('chapInput').value=''; $('verseInput').value='';
  }
  function buildPlayHelp(){
    const m = GAME.mode;
    let txt='';
    if (m==='traditional') txt='6 rounds ‚Ä¢ 30s each ‚Ä¢ Scoring: 1 Book ‚Ä¢ 3 Book+Chap ‚Ä¢ 5 Book+Chap+Verse';
    else if (m==='speed') txt='90s ‚Ä¢ Per-player verses ‚Ä¢ Scoring 1/3/5 as above ‚Ä¢ -1 if ALL three wrong';
    else if (m==='draft') txt='90s ‚Ä¢ Only from your 3 drafted books ‚Ä¢ Scoring 1/3/5 ‚Ä¢ -3 if Book wrong';
    else if (m==='teams') txt='6 rounds ‚Ä¢ 30s each ‚Ä¢ First team answer locks ‚Ä¢ Team chat above ‚Ä¢ Scoring 1/3/5 (no negatives)';
    $('playHelp').textContent = txt;
  }
  async function onSubmitAnswer(){
    if (!GAME) return;
    const mode = GAME.mode;
    const book = $('bookInput').value;
    const chapter = parseInt($('chapInput').value,10);
    const verseNum = parseInt($('verseInput').value,10);
    if (!chapter || !verseNum || !book) return;

    if (mode==='traditional' || mode==='teams'){
      const v = verses.find(x=> x.id === GAME.currentSharedId); if (!v) return;
      const pts = scoreAnswer({book,chapter,verse:verseNum}, v, mode);
      if (mode==='teams'){
        const team = getMyTeam(); if (!team) return;
        await runTransaction(db, async (tx)=>{
          const g = await tx.get(gameRef); if (!g.exists()) return;
          const G = g.data(); const locks = G.teamLocks || {A:false,B:false};
          if (locks[team]) return;
          locks[team] = true;
          const scs = G.scores || {}; scs[username] = (scs[username]||0) + Math.max(0,pts);
          const tots = G.teamTotals || {A:0,B:0}; tots[team] = (tots[team]||0) + Math.max(0,pts);
          tx.update(gameRef, { teamLocks: locks, scores: scs, teamTotals: tots });
        });
      } else {
        await updateDoc(gameRef, { [`scores.${username}`]: increment(Math.max(0, pts)) });
      }
      $('bookInput').value=''; $('chapInput').value=''; $('verseInput').value='';
    } else { // speed/draft
      const v = myCurrentVerse; if (!v) return;
      const pts = scoreAnswer({book,chapter,verse:verseNum}, v, mode);
      await updateDoc(gameRef, { [`scores.${username}`]: increment(pts) });
      const restrict = (mode==='draft');
      const filterFn = restrict ? (x)=> (GAME.picks && (GAME.picks[username]||[]).includes(x.book)) : null;
      const next = pickRandomVerse(filterFn);
      if (next) await setDoc(doc(pstateCol, username), { currentVerseId: next.id }, {merge:true});
      $('bookInput').value=''; $('chapInput').value=''; $('verseInput').value='';
    }
  }

  function getMyTeam(){
    const A = GAME.teamA || []; const B = GAME.teamB || [];
    if (A.includes(username)){ setTeamUI('A'); return 'A'; }
    if (B.includes(username)){ setTeamUI('B'); return 'B'; }
    return null;
  }
  function setTeamUI(team){
    const chip = qs('.team-chip'); if (chip) chip.style.background = (team==='A') ? '#0ea5e9' : '#ef4444';
    $('teamLabel').textContent = (team==='A') ? 'Team A' : 'Team B';
  }

  // ---------- TEAM CHAT ----------
  async function sendChat(){
    if (!GAME || GAME.mode!=='teams') return;
    const txt = $('chatInput').value.trim(); if (!txt) return;
    const team = getMyTeam(); if (!team) return;
    await addDoc(chatCol, { team, name: username, text: txt.slice(0,160), ts: serverTimestamp() });
    $('chatInput').value='';
  }
  function drawChat(msgs){
    if (!GAME || GAME.mode!=='teams') return;
    const team = getMyTeam(); if (!team) return;
    const mine = msgs.filter(m=> m.team===team).slice(-3);
    const log = $('chatLog'); log.innerHTML='';
    for (const m of mine){
      const div = document.createElement('div'); div.className='bubble';
      div.textContent = `${m.name}: ${m.text}`; log.appendChild(div);
    }
  }
</script>
</body>
</html>


