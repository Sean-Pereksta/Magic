<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>üìñ Bible Game (Multiplayer)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<style>
  :root{
    --bg:#fffaf5; --ink:#0f172a; --muted:#64748b; --panel:#ffffff; --br:#f1e7da;
    --accent:#7c3aed; --accent-2:#6d28d9; --good:#16a34a; --bad:#ef4444; --warn:#f59e0b;
    --chip:#f5f3ff; --shadow:0 10px 30px rgba(2,6,23,.08); --radius:14px;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--ink)}
  .wrap{max-width:820px;margin:0 auto;padding:10px}
  header{display:flex;align-items:center;justify-content:space-between;gap:8px;margin:6px 0 10px}
  .brand{display:flex;align-items:center;gap:8px}
  .logo{width:34px;height:34px;border-radius:10px;display:grid;place-items:center;background:#ede9fe;border:1px solid #ddd6fe;font-size:18px}
  .muted{color:var(--muted)} .title{font-weight:900;font-size:1rem}
  .badge{display:inline-flex;gap:6px;align-items:center;padding:6px 10px;border-radius:999px;border:1px solid #ddd6fe;background:#f5f3ff;color:#3730a3;font-weight:800}
  .panel{background:var(--panel);border:1px solid var(--br);border-radius:var(--radius);box-shadow:var(--shadow);padding:10px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .pill{display:inline-flex;align-items:center;gap:6px;padding:5px 9px;border-radius:999px;border:1px solid var(--br);background:#fff;font-weight:700}
  .btn{appearance:none;border:none;cursor:pointer;background:var(--accent);color:#fff;font-weight:900;padding:10px 12px;border-radius:12px;min-height:40px}
  .btn:hover{background:var(--accent-2)} .btn-ghost{background:#fff;border:1px solid var(--br);color:#0f172a}
  .btn.small{padding:7px 10px;min-height:34px;border-radius:10px}
  .scores{display:grid;grid-template-columns:1fr 1fr;gap:6px}
  .scores .entry{display:flex;align-items:center;justify-content:space-between;padding:6px 8px;border:1px solid var(--br);border-radius:10px;background:#fff}
  .scores .name{font-weight:800;font-size:.95rem}
  .verse-box{padding:10px;border:1px solid var(--br);border-radius:12px;background:#fff}
  .verse-text{font-size:1rem;line-height:1.45}
  .inputs{display:grid;grid-template-columns:1.2fr .5fr .5fr auto;gap:6px;margin-top:8px}
  @media (max-width:520px){ .inputs{grid-template-columns:1fr 1fr 1fr auto} }
  select, input[type="number"], input[type="text"]{width:100%;padding:9px;border:1px solid var(--br);border-radius:10px;font-size:16px;outline:none;background:#fff}
  select:focus, input:focus{border-color:#e9d5ff;box-shadow:0 0 0 3px rgba(124,58,237,.15)}
  .sm{font-size:.9rem}
  .vote-grid{display:grid;grid-template-columns: repeat(2,minmax(0,1fr)); gap:8px}
  .card{border:1px solid var(--br);border-radius:12px;padding:9px;background:#fff;display:flex;gap:8px;align-items:center;justify-content:space-between}
  .card .left{display:grid}
  .card.leader{border-color:#7c3aed; box-shadow:0 0 0 3px rgba(124,58,237,.13)}
  .chat{border:1px solid var(--br);border-radius:12px;background:#fff;display:grid;gap:6px;padding:8px}
  .chatlog{display:grid;gap:4px;min-height:24px}
  .bubble{padding:6px 8px;border-radius:9px;background:#f8fafc;border:1px solid #eef2f7;font-size:.92rem}
  .team-tag{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:9px;background:rgba(0,0,0,.04);border:1px solid #e5e7eb}
  .teams-bar{display:flex;align-items:center;justify-content:space-between;gap:6px}
  .teams-bar .tot{font-weight:900}
  .timer{font-weight:900;letter-spacing:.3px}
  .header-actions{display:flex;gap:6px;align-items:center}
  .typebox{border:1px dashed #e5e7eb;border-radius:12px;background:#fff;padding:8px}
  .typeitem{font-size:.9rem;padding:4px 8px;border-radius:9px;background:#faf5ff;border:1px solid #e9d5ff;display:inline-block;margin:3px 3px 0 0}

  /* Multiple-choice grid */
  .mc-wrap{margin-top:8px}
  .mc-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
  .mc-btn{border:1px solid var(--br);background:#fff;border-radius:10px;padding:10px;cursor:pointer;text-align:left}
  .mc-btn.selected{outline:3px solid #c4b5fd;border-color:#a78bfa;background:#faf5ff}
  .mc-btn[disabled]{opacity:.5;cursor:not-allowed}

  /* Float-fade reveal */
  @keyframes floatFade {
    0% { transform: translate(-50%, 8px); opacity: 0; }
    12% { opacity: 1; }
    80% { opacity: 1; }
    100% { transform: translate(-50%, -22px); opacity: 0; }
  }
  .reveal{
    position:fixed; left:50%; top:16%;
    transform:translate(-50%, 0);
    padding:8px 12px; border-radius:12px; border:1px solid;
    background:rgba(255,255,255,.96); box-shadow:var(--shadow);
    font-weight:900; z-index:9999; animation: floatFade 1800ms ease-out forwards;
  }
  .reveal.good{ color:var(--good); border-color:#bbf7d0; background:#f0fdf4 }
  .reveal.bad{  color:var(--bad);  border-color:#fecaca; background:#fff1f2 }

  /* Submitted notice */
  .notice{margin-top:6px;font-weight:800}
  .notice.ok{color:var(--good)}
  .notice.bad{color:var(--bad)}
</style>
</head>
<body>
<div class="wrap">

  <header>
    <div class="brand">
      <div class="logo">üìñ</div>
      <div>
        <div class="title">Bible Game</div>
        <div class="muted sm" id="subtitle">Connecting‚Ä¶</div>
      </div>
    </div>
    <div class="header-actions">
      <button class="btn-ghost small" id="fsBtn" title="Fullscreen">‚õ∂</button>
      <button class="btn-ghost small" id="leaveBtn">Leave</button>
    </div>
  </header>

  <!-- TOP: MODE / TIMER / HOST / LIVES -->
  <section class="panel" id="scoresPanel">
    <div class="row" style="justify-content:space-between">
      <span class="badge"><span id="modeLabel">Vote</span> ‚Ä¢ <span class="timer" id="timer">--:--</span></span>
      <div class="row">
        <span class="pill">Host: <b id="hostName">‚Äî</b></span>
        <span class="pill" id="livesPill" style="display:none">‚ô• Lives: <b id="livesCount">3</b></span>
      </div>
    </div>
    <div id="scoreboard" class="scores" style="margin-top:6px"></div>
  </section>

  <!-- VOTE -->
  <section class="panel" id="phase-vote" style="display:none">
    <div class="row" style="justify-content:space-between;align-items:flex-end">
      <div>
        <div class="title">Vote: Game Type (30s)</div>
        <div class="muted sm">Traditional ‚Ä¢ Speed ‚Ä¢ Teams ‚Ä¢ Co-Op Survival</div>
      </div>
      <div class="pill">Your vote: <strong id="myVote">‚Äî</strong></div>
    </div>
    <div class="vote-grid" style="margin-top:8px">
      <button class="card" data-mode="traditional">
        <div class="left"><b>üï∞Ô∏è Traditional</b><span class="sm muted">6 rounds, shared verse</span></div>
        <span class="pill">Votes: <b id="v-traditional">0</b></span>
      </button>
      <button class="card" data-mode="speed">
        <div class="left"><b>‚ö° Speed</b><span class="sm muted">90s, per-player verses, ‚àí1 all-wrong</span></div>
        <span class="pill">Votes: <b id="v-speed">0</b></span>
      </button>
      <button class="card" data-mode="teams">
        <div class="left"><b>üë• Teams</b><span class="sm muted">6 rounds ‚Ä¢ team chat ‚Ä¢ 60s/round</span></div>
        <span class="pill">Votes: <b id="v-teams">0</b></span>
      </button>
      <button class="card" data-mode="coop">
        <div class="left"><b>ü§ù Co-Op Survival</b><span class="sm muted">Shared lives ‚Ä¢ first answer locks ‚Ä¢ no timer</span></div>
        <span class="pill">Votes: <b id="v-coop">0</b></span>
      </button>
    </div>
    <div class="sm muted" style="margin-top:6px">Highest votes wins; ties are randomly chosen.</div>
  </section>

  <!-- PLAY -->
  <section class="panel" id="phase-play" style="display:none">
    <!-- Teams meta (scores + chat) -->
    <div id="teamsBar" class="teams-bar" style="display:none; margin-bottom:8px">
      <div class="tot">Team A: <span id="teamAScore">0</span></div>
      <div class="tot">Team B: <span id="teamBScore">0</span></div>
    </div>

    <!-- Chat + Teammate Typing -->
    <div id="chatWrap" style="display:none; margin-bottom:8px">
      <div class="chat">
        <div class="row" style="justify-content:space-between">
          <div class="team-tag" id="chatLabel">Chat</div>
          <div class="muted sm">Last 3 messages</div>
        </div>
        <div class="chatlog" id="chatLog"></div>
        <div class="row">
          <input id="chatInput" type="text" placeholder="Type hint/idea‚Ä¶" />
          <button class="btn small" id="sendChat">Send</button>
        </div>
      </div>
      <div class="typebox" id="typePanel" style="display:none; margin-top:6px">
        <div class="muted sm" style="margin-bottom:4px">Teammates are selecting‚Ä¶</div>
        <div id="typeList"></div>
      </div>
    </div>

    <div class="verse-box">
      <div class="muted sm" id="verseHeader">Verse</div>
      <div class="verse-text" id="verseText">Loading verses‚Ä¶</div>
    </div>

    <!-- Multiple choice (Co-Op Survival) -->
    <div id="mcWrap" class="mc-wrap" style="display:none">
      <div id="mcGrid" class="mc-grid"></div>
      <div class="row" style="margin-top:6px;justify-content:flex-end">
        <button class="btn" id="mcSubmitBtn">Submit</button>
      </div>
    </div>

    <!-- Manual inputs (other modes) -->
    <div id="inputsWrap" class="inputs">
      <select id="bookInput"></select>
      <input id="chapInput" type="number" min="1" placeholder="Chapter" />
      <input id="verseInput" type="number" min="1" placeholder="Verse" />
      <button class="btn" id="submitBtn">Submit</button>
    </div>

    <div id="playHelp" class="sm muted" style="margin-top:6px"></div>
    <div id="submitNotice" class="notice" style="display:none"></div>
  </section>

  <!-- END -->
  <section class="panel" id="phase-end" style="display:none">
    <div class="title">Game Over</div>
    <div class="muted sm">Final standings above. Host can start again or head back.</div>
    <div class="row" style="margin-top:8px">
      <button class="btn" id="playAgainBtn">Play Again</button>
      <button class="btn-ghost" id="toLobbyBtn">Back to Lobby</button>
    </div>
  </section>

</div>

<!-- Firebase (v10 modular) -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import {
    getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, addDoc,
    serverTimestamp, query, orderBy, limit, getDocs, runTransaction, increment
  } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

  // ---------- CONFIG ----------
  const firebaseConfig = {
    apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
    authDomain: "bible-game-246c0.firebaseapp.com",
    projectId: "bible-game-246c0",
    storageBucket: "bible-game-246c0.appspot.com",
    messagingSenderId: "959619818996",
    appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // ---------- DOM ----------
  const $  = (id)=> document.getElementById(id);

  // ---------- URL ----------
  const url = new URL(location.href);
  const gameId   = url.searchParams.get('gameId') || '';
  const username = url.searchParams.get('username') || '';

  // ---------- STATE ----------
  let LOBBY=null, GAME=null, HOST=null, isHost=false;
  let verses=[], books=[], bookSet=new Set();
  let myCurrentVerse=null, tickTimer=null;
  let lastMyWasCorrectFull = false; // for shared modes reveal
  let mcSelectedId = null;
  let prevGame = null; // for coop reveal
  let iTypedDebounce = null;
  let iJustSubmitted = false; // prevent external re-renders from clearing my inputs
  let lastSubmittedInfo = null; // for classic local notice

  // ---------- FS REFS ----------
  const lobbyRef  = doc(db, 'lobbies', gameId);
  const gameRef   = doc(db, 'games', gameId);
  const votesCol  = collection(db, 'games', gameId, 'votes');
  const pstateCol = collection(db, 'games', gameId, 'playerState');
  const chatCol   = collection(db, 'games', gameId, 'chat');

  // ---------- HELPERS ----------
  const now = ()=> Date.now();
  const fmtTime = (ms)=> { if (ms<0) ms=0; const s=Math.floor(ms/1000), m=Math.floor(s/60), r=s%60; return `${m}:${String(r).padStart(2,'0')}`; };

  function parseCSV(text){
    const rows=[]; let row=[], val=''; let inQ=false;
    for (let i=0;i<text.length;i++){
      const c = text[i];
      if (inQ){
        if (c === '"'){ if (text[i+1] === '"'){ val+='"'; i++; } else inQ=false; }
        else val += c;
      } else {
        if (c === '"') inQ=true;
        else if (c === ','){ row.push(val); val=''; }
        else if (c === '\n'){ row.push(val); rows.push(row); row=[]; val=''; }
        else if (c === '\r'){ }
        else val += c;
      }
    }
    if (val.length || row.length){ row.push(val); rows.push(row); }
    return rows;
  }
  const normBook = (s)=> (s||'').toString().trim().replace(/\s+/g,' ').toLowerCase();

  function buildBooksAndVerses(rows){
    const H = rows[0].map(h => (h||'').toString().trim());
    const idx = (name)=> H.findIndex(h => h.toLowerCase() === name.toLowerCase());
    const idI=idx('VerseID'), bookI=idx('BookName'), chapI=idx('Chapter'), verseI=idx('Verse'), textI=idx('Text');
    const out=[];
    for (let i=1;i<rows.length;i++){
      const r = rows[i]; if (!r || !r.length) continue;
      const id=parseInt(r[idI],10), book=(r[bookI]||'').toString().trim();
      const chap=parseInt(r[chapI],10), ver=parseInt(r[verseI],10), txt=(r[textI]||'').toString().trim();
      if (!id || !book || !chap || !ver || !txt) continue;
      out.push({id,book,chapter:chap,verse:ver,text:txt});
      if (!bookSet.has(book)){ bookSet.add(book); books.push(book); }
    }
    books.sort((a,b)=> a.localeCompare(b));
    return out;
  }
  function fillBookDropdown(){
    const sel = $('bookInput'); sel.innerHTML='';
    const blank = document.createElement('option'); blank.value=''; blank.textContent='Book';
    sel.appendChild(blank);
    for (const b of books){ const o=document.createElement('option'); o.value=b; o.textContent=b; sel.appendChild(o); }
  }

  // Scoring: 1 Book ‚Ä¢ 3 Book+Chap ‚Ä¢ 5 Book+Chap+Verse
  function scoreAnswerBits(guess, correct){
    const bookOK = normBook(guess.book)===normBook(correct.book);
    const chapOK = Number(guess.chapter)===Number(correct.chapter);
    const verOK  = Number(guess.verse)===Number(correct.verse);
    let pts = 0;
    if (bookOK && chapOK && verOK) pts = 5;
    else if (bookOK && chapOK) pts = 3;
    else if (bookOK) pts = 1;
    return {bookOK, chapOK, verOK, pts};
  }
  function scoreAnswer(guess, correct, mode){
    const {bookOK, chapOK, verOK, pts:base} = scoreAnswerBits(guess, correct);
    let pts = base;
    if (mode==='speed'){ if (!bookOK && !chapOK && !verOK) pts -= 1; }
    return {pts, full: (bookOK && chapOK && verOK)};
  }

  function pickRandomVerse(filterFn=null, excludeSet=null){
    let pool = verses;
    if (filterFn) pool = pool.filter(filterFn);
    if (excludeSet) pool = pool.filter(v => !excludeSet.has(v.id));
    if (!pool.length) return null;
    return pool[Math.floor(Math.random()*pool.length)];
  }

  // Co-Op option generator (returns array of verse IDs incl. correct)
  function genCoopOptions(correctId){
    const ids = new Set([correctId]);
    while (ids.size < 4){
      const v = verses[Math.floor(Math.random()*verses.length)];
      if (v) ids.add(v.id);
    }
    // shuffle
    const arr = Array.from(ids);
    for (let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; }
    return arr;
  }

  // Floating reveal
  function showRevealRef(v, ok){
    if (!v) return;
    const el = document.createElement('div');
    el.className = `reveal ${ok ? 'good' : 'bad'}`;
    el.textContent = `${ok ? '‚úì' : '‚úó'} ${v.book} ${v.chapter}:${v.verse}`;
    document.body.appendChild(el);
    setTimeout(()=> { if (el.parentNode) el.parentNode.removeChild(el); }, 1850);
  }

  // ---------- UI WIRING ----------
  $('leaveBtn').onclick = ()=> { location.href = `/index.html?username=${encodeURIComponent(username)}`; };
  $('fsBtn').onclick = ()=>{
    const docEl = document;
    if (!docEl.fullscreenElement && !docEl.webkitFullscreenElement){
      const el = docEl.documentElement;
      (el.requestFullscreen||el.webkitRequestFullscreen||el.mozRequestFullScreen||el.msRequestFullscreen).call(el);
    } else {
      (docEl.exitFullscreen||docEl.webkitExitFullscreen||docEl.mozCancelFullScreen||docEl.msExitFullscreen).call(docEl);
    }
  };
  for (const btn of document.querySelectorAll('#phase-vote .card')){
    btn.addEventListener('click', ()=> submitVote(btn.dataset.mode));
  }
  $('submitBtn').onclick = onSubmitAnswer;
  $('mcSubmitBtn').onclick = onSubmitMC;
  $('sendChat').onclick = sendChat;
  $('toLobbyBtn').onclick = ()=> location.href = `/index.html?username=${encodeURIComponent(username)}`;
  $('playAgainBtn').onclick = async ()=> {
    if (!isHost) return;
    await runTransaction(db, async (tx)=>{
      const l = await tx.get(lobbyRef); if (!l.exists()) throw 'no lobby';
      const players = l.data().players || [];
      tx.set(gameRef, {
        status:'voting',
        host:l.data().host || players[0] || username,
        players,
        mode:null,
        deadline: now()+30000,
        round:0,
        scores: Object.fromEntries(players.map(p=>[p,0])),
        lives: Object.fromEntries(players.map(p=>[p,3])),
        sharedLives: 3,
        teamTotals:{A:0,B:0},
        teamLocks:{},
        chosenShared: [],
        options: [],
        endAt: 0,
        coopLocked: false,
        coopNextAt: 0,
        coopAnsweredBy: "",
        coopWasRight: null,
        coopStartAt: 0
      }, {merge:true});
    });
  };

  // Live-typing publisher (Teams mode)
  ['bookInput','chapInput','verseInput'].forEach(id=>{
    $(id).addEventListener('input', ()=>{
      if (GAME?.mode!=='teams') return;
      if (iTypedDebounce) clearTimeout(iTypedDebounce);
      iTypedDebounce = setTimeout(async ()=>{
        const book = $('bookInput').value || '';
        const chapter = parseInt($('chapInput').value,10) || '';
        const verseNum = parseInt($('verseInput').value,10) || '';
        await setDoc(doc(pstateCol, username), {
          typingGuess: {book, chapter, verse: verseNum, t: now()}
        }, {merge:true});
      }, 120);
    });
  });

  // ---------- STARTUP ----------
  main().catch(console.error);

  async function main(){
    if (!gameId || !username){ $('subtitle').textContent='Missing gameId/username'; return; }

    const lobbySnap = await getDoc(lobbyRef);
    if (!lobbySnap.exists()){ $('subtitle').textContent='Lobby not found.'; return; }
    LOBBY = lobbySnap.data();
    HOST  = LOBBY.host || (LOBBY.players && LOBBY.players[0]) || username;
    isHost = (username === HOST);
    $('hostName').textContent = HOST;
    $('subtitle').textContent = `You are ${username} ‚Ä¢ Players: ${(LOBBY.players||[]).join(', ')}`;

    // Load verses
    const csvUrl = 'https://raw.githubusercontent.com/Sean-Pereksta/Bible-Data/refs/heads/main/web.csv';
    const csvText = await (await fetch(csvUrl, {cache:'force-cache'})).text();
    const rows = parseCSV(csvText);
    verses = buildBooksAndVerses(rows);
    fillBookDropdown();

    // Ensure game doc
    const gSnap = await getDoc(gameRef);
    if (!gSnap.exists() && isHost){
      const players = LOBBY.players || [username];
      await setDoc(gameRef, {
        status:'voting',
        host: HOST,
        players,
        mode:null,
        deadline: now()+30000,
        round:0,
        scores: Object.fromEntries(players.map(p=>[p,0])),
        lives: Object.fromEntries(players.map(p=>[p,3])),
        sharedLives: 3,
        teamTotals:{A:0,B:0},
        teamLocks:{},
        chosenShared: [],
        options: [],
        endAt: 0,
        coopLocked: false,
        coopNextAt: 0,
        coopAnsweredBy: "",
        coopWasRight: null,
        coopStartAt: 0
      });
    }

    // Game listener
    onSnapshot(gameRef, (snap)=>{
      if (!snap.exists()) return;
      const old = prevGame;
      const fresh = snap.data();

      GAME = fresh; prevGame = fresh;
      render();

      // Reveal on shared-verse change
      if (old && old.status==='playing' && old.currentSharedId && old.currentSharedId !== (fresh.currentSharedId||null)){
        const v = verses.find(x=> x.id === old.currentSharedId);
        if (old.mode==='coop'){
          const ok = (old.coopAnsweredBy === username) ? !!old.coopWasRight : false;
          showRevealRef(v, ok);
        } else if (old.mode==='traditional' || old.mode==='teams'){
          showRevealRef(v, !!lastMyWasCorrectFull);
          lastMyWasCorrectFull = false;
        }
        // reset local notice on new round
        lastSubmittedInfo = null;
        $('submitNotice').style.display='none';
      }
      // Final reveal on end
      if (old && old.status==='playing' && fresh.status==='ended' && old.currentSharedId){
        const v = verses.find(x=> x.id === old.currentSharedId);
        if (old.mode==='coop'){
          const ok = (old.coopAnsweredBy === username) ? !!old.coopWasRight : false;
          showRevealRef(v, ok);
        } else if (old.mode==='traditional' || old.mode==='teams'){
          showRevealRef(v, !!lastMyWasCorrectFull);
          lastMyWasCorrectFull = false;
        }
      }
    });

    // Votes listener
    onSnapshot(votesCol, (qsnap)=>{
      const counts = {traditional:0, speed:0, teams:0, coop:0};
      qsnap.forEach((snapDoc)=>{
        const m = (snapDoc.data() || {}).mode;
        if (counts[m] !== undefined) counts[m]++;
      });
      $('v-traditional').textContent = counts.traditional;
      $('v-speed').textContent       = counts.speed;
      $('v-teams').textContent       = counts.teams;
      $('v-coop').textContent        = counts.coop;
      highlightVoteLeader(counts);
    });

    // Chat listener
    onSnapshot(query(chatCol, orderBy('ts','desc'), limit(20)), (qsnap)=>{
      const msgs=[]; qsnap.forEach((snapDoc)=> msgs.push(snapDoc.data())); msgs.reverse(); drawChat(msgs);
    });

    // Player state (my current verse for speed)
    onSnapshot(doc(pstateCol, username), (psnap)=>{
      const st = psnap.exists() ? psnap.data() : null;
      if (st && st.currentVerseId){
        const v = verses.find(x=> x.id === st.currentVerseId);
        if (v){ myCurrentVerse = v; maybeShowVerse(true); }
      }
    });

    // Team typing panel listener (watch all)
    onSnapshot(pstateCol, (qsnap)=>{
      const all = [];
      qsnap.forEach(s=>{
        const data=s.data();
        all.push({name:s.id, typingGuess:data.typingGuess||null});
      });
      drawTyping(all);
    });

    // Timer loop
    if (tickTimer) clearInterval(tickTimer);
    tickTimer = setInterval(isHost ? hostDrive : updateCountdownUI, 250);
  }

  // ---------- RENDER ----------
  function render(){
    if (!GAME) return;

    const phase = GAME.status || 'voting';
    const mode  = GAME.mode || 'Vote';
    $('modeLabel').textContent = (phase==='voting') ? 'Vote' : (mode.charAt(0).toUpperCase()+mode.slice(1));

    // Toggle views
    $('phase-vote').style.display  = (phase === 'voting')   ? 'block' : 'none';
    $('phase-play').style.display  = (phase === 'playing')  ? 'block' : 'none';
    $('phase-end').style.display   = (phase === 'ended')    ? 'block' : 'none';

    // Lives pill (Co-Op)
    if (phase==='playing' && GAME.mode==='coop'){
      $('livesPill').style.display='inline-flex';
      $('livesCount').textContent = GAME.sharedLives ?? 3;
    } else {
      $('livesPill').style.display='none';
    }

    drawScores();

    if (phase === 'playing'){
      // Chat visibility
      if (GAME.mode === 'teams'){
        $('teamsBar').style.display = 'flex';
        $('teamAScore').textContent = (GAME.teamTotals && GAME.teamTotals.A) || 0;
        $('teamBScore').textContent = (GAME.teamTotals && GAME.teamTotals.B) || 0;
        $('chatWrap').style.display = 'block';
        $('chatLabel').textContent = 'Team chat';
        $('typePanel').style.display = 'block';
      } else if (GAME.mode === 'coop'){
        $('teamsBar').style.display = 'none';
        $('chatWrap').style.display = 'block';
        $('chatLabel').textContent = 'Chat';
        $('typePanel').style.display = 'none';
      } else {
        $('teamsBar').style.display = 'none';
        $('chatWrap').style.display = 'none';
        $('typePanel').style.display = 'none';
      }

      // Inputs vs Multiple-choice
      if (GAME.mode === 'coop'){
        $('inputsWrap').style.display = 'none';
        $('mcWrap').style.display = 'block';
        buildMCUI();
      } else {
        $('mcWrap').style.display = 'none';
        $('inputsWrap').style.display = 'grid';
      }

      buildPlayHelp();
      maybeShowVerse(false);
    }
    updateCountdownUI();
  }

  function drawScores(){
    const sb = $('scoreboard'); sb.innerHTML='';
    const players = (GAME.players || []);
    const scores = (GAME.scores || {});
    const order = players.slice().sort((a,b)=> (scores[b]||0) - (scores[a]||0));
    for (const p of order){
      const row = document.createElement('div'); row.className='entry';
      const name = document.createElement('div'); name.className='name';
      const star = (p === GAME.host) ? ' ‚≠ê' : '';
      name.textContent = p + star;
      const sc = document.createElement('div'); sc.innerHTML = `üèÜ <b>${scores[p]||0}</b>`;
      row.appendChild(name); row.appendChild(sc);
      sb.appendChild(row);
    }

    // Disable Co-Op inputs if locked or game over
    if (GAME.mode==='coop'){
      const dead = (GAME.sharedLives||0) <= 0;
      const locked = !!GAME.coopLocked;
      for (const b of document.querySelectorAll('.mc-btn')) b.disabled = dead || locked;
      if ($('mcSubmitBtn')) $('mcSubmitBtn').disabled = dead || locked || !mcSelectedId;
    }
  }

  function updateCountdownUI(){
    if (!GAME) return;
    let text='--:--';
    if (GAME.status === 'voting'){
      const t = (GAME.deadline || 0) - now();
      text = fmtTime(t);
    } else if (GAME.status === 'playing'){
      if (GAME.mode==='speed'){
        text = fmtTime((GAME.endAt||0) - now());
      } else if (GAME.mode==='coop'){
        const start = GAME.coopStartAt || now();
        text = fmtTime(now() - start); // survival time (count-up)
      } else {
        text = fmtTime((GAME.deadline||0) - now());
      }
    }
    $('timer').textContent = text;
  }

  function highlightVoteLeader(counts){
    for (const btn of document.querySelectorAll('#phase-vote .card')) btn.classList.remove('leader');
    const max = Math.max(counts.traditional, counts.speed, counts.teams, counts.coop);
    const leaders = [];
    if (counts.traditional===max) leaders.push('traditional');
    if (counts.speed===max)       leaders.push('speed');
    if (counts.teams===max)       leaders.push('teams');
    if (counts.coop===max)        leaders.push('coop');
    for (const m of leaders){
      const el = document.querySelector(`#phase-vote .card[data-mode="${m}"]`);
      if (el) el.classList.add('leader');
    }
  }

  // ---------- VOTE ----------
  async function submitVote(mode){
    $('myVote').textContent = mode[0].toUpperCase()+mode.slice(1);
    await setDoc(doc(votesCol, username), {mode, ts: serverTimestamp()});
  }

  // ---------- HOST DRIVER ----------
  async function hostDrive(){
    if (!GAME) return;
    updateCountdownUI();
    const tnow = now();

    if (GAME.status === 'voting'){
      if (tnow >= (GAME.deadline || 0)){
        const vSnap = await getDocs(votesCol);
        const counts = {traditional:0, speed:0, teams:0, coop:0};
        vSnap.forEach((snapDoc)=>{ const m=snapDoc.data().mode; if (counts[m]!==undefined) counts[m]++; });

        const max = Math.max(counts.traditional, counts.speed, counts.teams, counts.coop);
        const top = Object.entries(counts).filter(([k,v])=> v===max).map(([k])=>k);
        const chosen = top[Math.floor(Math.random()*top.length)]; // random tie-break

        const baseUpdate = {
          mode: chosen, round: 0,
          scores: Object.fromEntries((GAME.players||[]).map(p=>[p,0])),
          chosenShared: []
        };

        if (chosen === 'teams'){
          const ps = (GAME.players||[]).slice();
          const A=[], B=[]; ps.forEach((p,i)=> (i%2===0?A:B).push(p));
          await updateDoc(gameRef, {
            status:'playing', ...baseUpdate,
            teamA:A, teamB:B, teamTotals:{A:0,B:0}, teamLocks:{A:false,B:false},
            round:1,
            currentSharedId: pickRandomVerse().id,
            deadline: tnow + 60000 // <-- one minute
          });
        } else if (chosen === 'speed'){
          await updateDoc(gameRef, { status:'playing', ...baseUpdate, endAt: tnow + 90000 });
          await seedPerPlayerVerses();
        } else if (chosen === 'coop'){
          const v = pickRandomVerse(); const opts = genCoopOptions(v.id);
          await updateDoc(gameRef, {
            status:'playing', ...baseUpdate,
            sharedLives: 3,
            coopLocked: false,
            coopNextAt: 0,
            coopAnsweredBy: "",
            coopWasRight: null,
            coopStartAt: tnow,
            currentSharedId: v.id,
            options: opts
          });
        } else { // traditional
          await updateDoc(gameRef, {
            status:'playing', ...baseUpdate,
            round:1,
            currentSharedId: pickRandomVerse().id,
            deadline: tnow + 30000
          });
        }
      }
    }
    else if (GAME.status === 'playing'){
      const mode = GAME.mode;
      if (mode === 'coop'){
        if ((GAME.sharedLives||0) <= 0){ await updateDoc(gameRef, {status:'ended'}); return; }
        if (GAME.coopLocked && tnow >= (GAME.coopNextAt || 0)){
          const chosenSet = new Set(GAME.chosenShared || []);
          let v = pickRandomVerse(null, chosenSet); if (!v) v = pickRandomVerse();
          chosenSet.add(v.id);
          await updateDoc(gameRef, {
            currentSharedId: v.id,
            options: genCoopOptions(v.id),
            chosenShared: Array.from(chosenSet),
            coopLocked: false,
            coopAnsweredBy: "",
            coopWasRight: null
          });
        }
      } else if (mode === 'traditional' || mode === 'teams'){
        if (tnow >= (GAME.deadline || 0)){
          const nextRound = (GAME.round||1) + 1;
          if (nextRound > 6){ await updateDoc(gameRef, {status:'ended', deadline:0}); }
          else {
            const chosenSet = new Set(GAME.chosenShared || []);
            let v = pickRandomVerse(null, chosenSet); if (!v) v = pickRandomVerse();
            chosenSet.add(v.id);
            await updateDoc(gameRef, {
              round: nextRound,
              currentSharedId: v.id,
              chosenShared: Array.from(chosenSet),
              deadline: tnow + (mode==='teams' ? 60000 : 30000), // 60s teams, 30s classic
              teamLocks: mode==='teams' ? {A:false,B:false} : (GAME.teamLocks||{})
            });
          }
        }
      } else if (mode === 'speed'){
        if (tnow >= (GAME.endAt || 0)){ await updateDoc(gameRef, {status:'ended'}); }
      }
    }
  }

  async function seedPerPlayerVerses(){
    const players = (GAME.players || []);
    for (const p of players){
      const v = pickRandomVerse();
      if (!v) continue;
      await setDoc(doc(pstateCol, p), { currentVerseId: v.id }, {merge:true});
    }
  }

  // ---------- PLAY VIEW ----------
  function maybeShowVerse(isMineChange){
    if (!GAME) return;
    const mode = GAME.mode;
    if (mode==='traditional' || mode==='teams' || mode==='coop'){
      const v = verses.find(x=> x.id === GAME.currentSharedId);
      $('verseHeader').textContent = (mode==='coop')
        ? `Co-Op Survival`
        : (mode==='teams' ? `Round ${GAME.round||1} ‚Ä¢ Teams (60s)` : `Round ${GAME.round||1} ‚Ä¢ Shared`);
      $('verseText').textContent = v ? v.text : '‚Äî';
      if (mode==='coop') buildMCUI();
      // Do NOT clear my inputs here. (prevents resets on other players' submissions)
      if (!isMineChange){
        // keep what I'm typing
      }
    } else {
      $('verseHeader').textContent = 'Your verse';
      $('verseText').textContent = myCurrentVerse ? myCurrentVerse.text : '‚Äî';
      // Do NOT clear inputs unless I submitted (handled in onSubmitAnswer)
    }
  }

  function buildPlayHelp(){
    const m = GAME.mode;
    let txt='';
    if (m==='traditional') txt='6 rounds ‚Ä¢ 30s each ‚Ä¢ Scoring: 1 Book ‚Ä¢ 3 Book+Chap ‚Ä¢ 5 Book+Chap+Verse (no negatives)';
    else if (m==='speed') txt='90s ‚Ä¢ Per-player verses ‚Ä¢ Scoring 1/3/5 ‚Ä¢ ‚àí1 if ALL three wrong';
    else if (m==='teams') txt='6 rounds ‚Ä¢ 60s ‚Ä¢ First team answer locks ‚Ä¢ Team chat above ‚Ä¢ Live teammate picks ‚Ä¢ Scoring 1/3/5';
    else if (m==='coop')  txt='Survival ‚Ä¢ Shared lives ‚Ä¢ First answer locks ‚Ä¢ Choose 1 of 4 refs ‚Ä¢ +1 if correct, wrong costs a life';
    $('playHelp').textContent = txt;
  }

  // Co-Op UI
  function buildMCUI(){
    if (GAME.mode!=='coop') return;
    const grid = $('mcGrid'); grid.innerHTML='';
    mcSelectedId = null;
    const opts = GAME.options || [];
    for (const id of opts){
      const v = verses.find(x=> x.id === id);
      const btn = document.createElement('button');
      btn.className='mc-btn';
      btn.textContent = v ? `${v.book} ${v.chapter}:${v.verse}` : '‚Äî';
      btn.onclick = ()=>{
        if (GAME.coopLocked) return;
        mcSelectedId = id;
        for (const b of document.querySelectorAll('.mc-btn')) b.classList.remove('selected');
        btn.classList.add('selected');
        $('mcSubmitBtn').disabled = (GAME.coopLocked || (GAME.sharedLives||0)<=0 || !mcSelectedId);
      };
      grid.appendChild(btn);
    }
    const locked = !!GAME.coopLocked;
    const dead = (GAME.sharedLives||0) <= 0;
    for (const b of document.querySelectorAll('.mc-btn')) b.disabled = locked || dead;
    $('mcSubmitBtn').disabled = locked || dead || !mcSelectedId;
  }

  // Manual inputs submit (Traditional/Teams/Speed)
  async function onSubmitAnswer(){
    if (!GAME) return;
    const mode = GAME.mode;
    if (mode==='coop') return; // handled by MC flow
    const book = $('bookInput').value;
    const chapter = parseInt($('chapInput').value,10);
    const verseNum = parseInt($('verseInput').value,10);
    if (!chapter || !verseNum || !book) return;

    if (mode==='traditional' || mode==='teams'){
      const v = verses.find(x=> x.id === GAME.currentSharedId); if (!v) return;
      const {pts, full} = scoreAnswer({book,chapter,verse:verseNum}, v, mode);
      lastMyWasCorrectFull = full;

      if (mode==='teams'){
        const team = getMyTeam(); if (!team) return;
        await runTransaction(db, async (tx)=>{
          const g = await tx.get(gameRef); if (!g.exists()) return;
          const G = g.data(); const locks = G.teamLocks || {A:false,B:false};
          if (locks[team]) return;
          locks[team] = true;
          const scs = G.scores || {}; scs[username] = (scs[username]||0) + Math.max(0,pts);
          const tots = G.teamTotals || {A:0,B:0}; tots[team] = (tots[team]||0) + Math.max(0,pts);
          tx.update(gameRef, { teamLocks: locks, scores: scs, teamTotals: tots });
        });
        // Announce who submitted what for teams
        await addDoc(chatCol, {
          name: username,
          text: `submitted ${book} ${chapter}:${verseNum}`,
          team: getMyTeam() || 'A',
          ts: serverTimestamp()
        });
      } else {
        await updateDoc(gameRef, { [`scores.${username}`]: increment(Math.max(0, pts)) });
        // Classic: show immediate local submitted result
        lastSubmittedInfo = {
          ok: full,
          correct: `${v.book} ${v.chapter}:${v.verse}`
        };
        showSubmittedNotice();
      }

      // I submitted: clear my inputs locally only
      iJustSubmitted = true;
      $('bookInput').value=''; $('chapInput').value=''; $('verseInput').value='';
      setTimeout(()=>{ iJustSubmitted = false; }, 400);
    } else if (mode==='speed'){
      const v = myCurrentVerse; if (!v) return;
      const {pts, full} = scoreAnswer({book,chapter,verse:verseNum}, v, mode);
      await updateDoc(gameRef, { [`scores.${username}`]: increment(pts) });
      showRevealRef(v, full);

      const next = pickRandomVerse();
      if (next) await setDoc(doc(pstateCol, username), { currentVerseId: next.id }, {merge:true});

      // I submitted: clear my inputs locally only
      iJustSubmitted = true;
      $('bookInput').value=''; $('chapInput').value=''; $('verseInput').value='';
      setTimeout(()=>{ iJustSubmitted = false; }, 400);
    }
  }

  function showSubmittedNotice(){
    if (!lastSubmittedInfo) return;
    const el = $('submitNotice');
    el.style.display='block';
    el.className = 'notice ' + (lastSubmittedInfo.ok ? 'ok' : 'bad');
    el.textContent = `Submitted ‚Äî ${lastSubmittedInfo.ok ? 'Correct!' : 'Wrong'} ‚Ä¢ Correct: ${lastSubmittedInfo.correct}`;
  }

  // Co-Op submission (first answer locks; updates shared lives / score; schedules next verse)
  async function onSubmitMC(){
    if (!GAME || GAME.mode!=='coop') return;
    if (!mcSelectedId) return;
    await runTransaction(db, async (tx)=>{
      const g = await tx.get(gameRef); if (!g.exists()) return;
      const G = g.data(); if (G.mode!=='coop') return;
      if (G.coopLocked) return; // already answered by someone
      if ((G.sharedLives||0) <= 0) return;

      const correctId = G.currentSharedId;
      const wasRight = (mcSelectedId === correctId);
      const scores = G.scores || {};
      let sharedLives = G.sharedLives ?? 3;

      if (wasRight){
        scores[username] = (scores[username]||0) + 1; // +1 point to submitter
      } else {
        sharedLives = Math.max(0, sharedLives - 1);
      }

      const patch = {
        scores,
        sharedLives,
        coopLocked: true,
        coopAnsweredBy: username,
        coopWasRight: wasRight,
        coopNextAt: now() + 1500 // short reveal window
      };

      if (sharedLives <= 0){
        patch.status = 'ended';
      }
      tx.update(gameRef, patch);
    });
  }

  function getMyTeam(){
    const A = GAME.teamA || []; const B = GAME.teamB || [];
    if (A.includes(username)) return 'A';
    if (B.includes(username)) return 'B';
    return null;
  }

  // ---------- CHAT ----------
  async function sendChat(){
    if (!GAME) return;
    const txt = $('chatInput').value.trim(); if (!txt) return;
    const payload = { name: username, text: txt.slice(0,160), ts: serverTimestamp() };
    if (GAME.mode==='teams'){ payload.team = getMyTeam() || 'A'; } else { payload.team = 'all'; }
    await addDoc(chatCol, payload);
    $('chatInput').value='';
  }
  function drawChat(msgs){
    if (!GAME) return;
    let show = [];
    if (GAME.mode==='teams'){
      const t = getMyTeam(); if (!t) return;
      show = msgs.filter(m=> m.team===t).slice(-3);
    } else if (GAME.mode==='coop'){
      show = msgs.filter(m=> (m.team==='all' || !m.team)).slice(-3);
    } else {
      show = []; // no chat for other modes
    }
    const log = $('chatLog'); log.innerHTML='';
    for (const m of show){
      const div = document.createElement('div'); div.className='bubble';
      div.textContent = `${m.name}: ${m.text}`; log.appendChild(div);
    }
  }

  // ---------- TEAM TYPING PANEL ----------
  function drawTyping(allStates){
    if (!GAME || GAME.mode!=='teams') return;
    const myTeam = getMyTeam(); if (!myTeam) return;
    const isOnTeam = (name)=>{
      return (myTeam==='A' ? (GAME.teamA||[]).includes(name) : (GAME.teamB||[]).includes(name));
    };
    const list = $('typeList'); list.innerHTML='';
    const cutoff = now() - 65000; // show last ~65s
    allStates
      .filter(s=> s.name!==username && isOnTeam(s.name) && s.typingGuess && (s.typingGuess.t||0) >= cutoff)
      .forEach(s=>{
        const g = s.typingGuess;
        const txt = `${s.name}: ${g.book||'‚Äî'} ${g.chapter||''}${g.verse?':'+g.verse:''}`;
        const chip = document.createElement('div');
        chip.className='typeitem';
        chip.textContent = txt.trim();
        list.appendChild(chip);
      });
  }
</script>
</body>
</html>






