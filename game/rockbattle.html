<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>‚öîÔ∏è Rock Battle</title>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<style>
  :root{
    --ink:#0f172a; --muted:#6b7280; --br:#e5e7eb; --card:#fff; --shadow:0 10px 30px rgba(15,23,42,.08);
    --good:#16a34a; --bad:#ef4444; --accent:#111827;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Arial;color:var(--ink);background:#fafafa;}
  button{font-family:inherit; cursor:pointer}

  .wrap{min-height:100vh;display:grid;grid-template-rows:auto 1fr auto}
  .top{
    position:sticky; top:0; z-index:5; background:#fff; border-bottom:1px solid var(--br);
    display:flex; align-items:center; justify-content:space-between; gap:10px; padding:8px 10px;
  }
  .hp{display:flex;align-items:center;gap:8px;border:1px solid var(--br);background:#fff;padding:8px 12px;border-radius:12px}
  .hpbar{position:relative;width:140px;height:10px;background:#f3f4f6;border-radius:999px;overflow:hidden;border:1px solid var(--br)}
  .hpbar>i{display:block;height:100%;width:100%;background:linear-gradient(90deg,#22c55e,#84cc16)}
  .enemyTag{font-weight:900}
  .statusPanel{display:flex;gap:8px;flex-wrap:wrap}
  .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border:1px solid var(--br);border-radius:999px;background:#fff;font-size:12px}

  .arena{
    position:relative; display:grid; place-items:center; padding:12px; overflow:hidden;
    min-height:260px;
  }
  .row{display:flex; gap:8px; align-items:center; justify-content:center; flex-wrap:wrap}

  .centerText{
    position:absolute; left:50%; top:32%; transform:translate(-50%,-50%);
    font-weight:900; font-size:20px; text-align:center; min-height:40px;
    z-index:5; pointer-events:none;
  }

  .hand{
    position:sticky; bottom:0; background:#fff;border-top:1px solid var(--br);
    padding:8px; display:flex; align-items:center; justify-content:center; gap:8px; flex-wrap:wrap
  }
  .card{
    width:110px; height:150px; border:2px solid var(--br); border-radius:14px; background:#fff; box-shadow:var(--shadow);
    display:flex; flex-direction:column; align-items:center; justify-content:center; gap:8px; padding:10px;
  }
  .card.small{ width:88px; height:120px; }
  .card b{ font-size:14px; text-align:center }
  .card small{ color:var(--muted); text-align:center }
  .disabled{ opacity:.5; pointer-events:none }

  .sprite{
    width:120px;height:120px;border-radius:16px;border:2px solid var(--br);display:grid;place-items:center;background:#fff;box-shadow:var(--shadow);
    position:absolute;top:50%;transform:translateY(-50%);
    z-index:1;
  }
  .spriteL{ left:-140px }
  .spriteR{ right:-140px }
  .runL{ animation:runL .9s forwards }
  .runR{ animation:runR .9s forwards }
  .fade{ animation:fade .7s forwards }

  @keyframes runL{ to{ left:calc(50% - 130px) } }
  @keyframes runR{ to{ right:calc(50% - 130px) } }
  @keyframes fade{ to{ opacity:0 } }

  @media (max-width:680px){
    .hpbar{ width:110px }
    .card{ width:92px; height:124px }
    .card.small{ width:80px; height:110px }
    .sprite{ width:96px;height:96px }
    .centerText{ font-size:18px; top:28%; }
  }
</style>
</head>
<body>
<div class="wrap">

  <div class="top">
    <div class="hp">
      <span id="enemyEmoji">ü™®</span>
      <span class="enemyTag" id="enemyName">Enemy</span>
      <div class="hpbar"><i id="ehpFill" style="width:100%"></i></div>
      <span id="ehpLbl">0/0</span>
    </div>
    <div class="statusPanel">
      <span class="pill">‚è±Ô∏è <span id="timer">15</span>s</span>
      <span class="pill" id="blkRock" style="display:none">üö´ Rock (2)</span>
      <span class="pill" id="blkPaper" style="display:none">üö´ Paper (2)</span>
      <span class="pill" id="blkScissors" style="display:none">üö´ Scissors (2)</span>
      <span class="pill" id="handBoost" style="display:none">üÉè Hand +1 (2)</span>
    </div>
  </div>

  <div class="arena" id="arena">
    <div id="center" class="centerText">Choose your card‚Ä¶</div>
  </div>

  <div class="hand" id="handBar">
    <div class="hp">
      <span>üßô You</span>
      <div class="hpbar"><i id="phpFill" style="width:100%"></i></div>
      <span id="phpLbl">0/0</span>
    </div>
    <div class="row" id="handRow"></div>
  </div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import {
    getFirestore, doc, getDoc, updateDoc
  } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

  // ---------- Firebase ----------
  const firebaseConfig = {
    apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
    authDomain: "bible-game-246c0.firebaseapp.com",
    projectId: "bible-game-246c0",
    storageBucket: "bible-game-246c0.appspot.com",
    messagingSenderId: "959619818996",
    appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // ---------- Params ----------
  const qs = new URLSearchParams(location.search);
  const encounterId = qs.get("encounter") || "";
  const username = qs.get("username") || localStorage.getItem("gh.username") || "";

  function gotoWorldRelative(){
    const worldURL = new URL('./rock.html', location.href).toString();
    location.href = username ? `${worldURL}?username=${encodeURIComponent(username)}` : worldURL;
  }

  if (!encounterId || !username){
    alert("Missing encounter or username.");
    gotoWorldRelative();
  }

  // ---------- UI refs ----------
  const center = document.getElementById("center");
  const enemyEmojiEl = document.getElementById("enemyEmoji");
  const enemyNameEl = document.getElementById("enemyName");
  const ehpLbl = document.getElementById("ehpLbl");
  const ehpFill = document.getElementById("ehpFill");
  const phpLbl = document.getElementById("phpLbl");
  const phpFill = document.getElementById("phpFill");
  const timerEl = document.getElementById("timer");
  const handRow = document.getElementById("handRow");
  const arena = document.getElementById("arena");
  const blkRock = document.getElementById("blkRock");
  const blkPaper = document.getElementById("blkPaper");
  const blkScissors = document.getElementById("blkScissors");
  const handBoostPill = document.getElementById("handBoost");

  // ---------- Rules ----------
  const NON_ATTACK = new Set(["effect-reveal","effect-draw","block-rock","block-paper","block-scissors"]);
  const EMOJI = {
    rock:"ü™®", paper:"üìÑ", scissors:"‚úÇÔ∏è",
    crystal:"üíé", diamond:"üî∑", match:"üß®", water:"üíß", slime:"üü¢", dark:"üåë",
    "effect-reveal":"üëÅÔ∏è", "effect-draw":"üÉè",
    "block-rock":"‚õîü™®", "block-paper":"‚õîüìÑ", "block-scissors":"‚õî‚úÇÔ∏è"
  };
  const NAME = {
    rock:"Rock", paper:"Paper", scissors:"Scissors",
    crystal:"Crystal", diamond:"Diamond", match:"Match", water:"Water", slime:"Slime", dark:"Dark Matter",
    "effect-reveal":"Reveal", "effect-draw":"Draw",
    "block-rock":"Block Rock", "block-paper":"Block Paper", "block-scissors":"Block Scissors"
  };

  function compareTypes(a,b){
    if (a===b) return 0;
    const base = { rock:{scissors:1,paper:-1}, paper:{rock:1,scissors:-1}, scissors:{paper:1,rock:-1} };
    if (base[a]?.[b]!==undefined) return base[a][b];
    if (base[b]?.[a]!==undefined) return -base[b][a];

    if (a==="crystal"){ if (b==="rock"||b==="scissors") return 1; if (b==="paper") return -1; }
    if (b==="crystal"){ if (a==="rock"||a==="scissors") return -1; if (a==="paper") return 1; }

    if (a==="diamond"){ if (["crystal","rock","scissors"].includes(b)) return 1; if (b==="paper") return -1; }
    if (b==="diamond"){ if (["crystal","rock","scissors"].includes(a)) return -1; if (a==="paper") return 1; }

    if (a==="match"){ if (["paper","scissors"].includes(b)) return 1; if (["crystal","diamond","rock"].includes(b)) return -1; }
    if (b==="match"){ if (["paper","scissors"].includes(a)) return -1; if (["crystal","diamond","rock"].includes(a)) return 1; }

    if (a==="water"){ if (["rock","paper","match"].includes(b)) return 1; if (["crystal","diamond","scissors"].includes(b)) return -1; }
    if (b==="water"){ if (["rock","paper","match"].includes(a)) return -1; if (["crystal","diamond","scissors"].includes(a)) return 1; }

    if (a==="slime"){ if (["rock","crystal","diamond","match","paper"].includes(b)) return 1; if (["scissors","water"].includes(b)) return -1; }
    if (b==="slime"){ if (["rock","crystal","diamond","match","paper"].includes(a)) return -1; if (["scissors","water"].includes(a)) return 1; }

    if (a==="dark"){ if (b==="rock") return -1; return 1; }
    if (b==="dark"){ if (a==="rock") return 1; return -1; }
    return 0;
  }

  // ---------- Enemy catalogs ----------
  const ENEMY_META = {
    rock: {emoji:"ü™®", tier:0, name:"Rockling"},
    paper:{emoji:"üìÑ", tier:0, name:"Paperman"},
    scissors:{emoji:"‚úÇÔ∏è", tier:0, name:"Shearer"},
    sprite:{emoji:"üßö", tier:1, name:"Sprite"},
    golem:{emoji:"üóø", tier:1, name:"Golem"},
    lizard:{emoji:"ü¶é", tier:2, name:"Lizard"},
    dragon:{emoji:"üêâ", tier:3, name:"Dragon"},
    knight:{emoji:"üõ°Ô∏è", tier:4, name:"Knight"},
    wild:{emoji:"‚ùî", tier:1, name:"Wanderer"}
  };

  function buildEnemyDeck(kind){
    const meta = ENEMY_META[kind] || ENEMY_META.wild;
    const t = meta.tier;
    const deck = [];

    const baseCount = Math.max(0, 8 - t*2); // 8,6,4,2,0
    const advCount  = 10 - baseCount;

    for(let i=0;i<baseCount;i++){
      if (kind==="rock") deck.push({type:"rock"});
      else if (kind==="paper") deck.push({type:"paper"});
      else if (kind==="scissors") deck.push({type:"scissors"});
      else deck.push([{type:"rock"},{type:"paper"},{type:"scissors"}][i%3]);
    }

    let pool = [];
    if (t>=1) pool.push("effect-reveal","effect-draw","block-rock");
    if (t>=2) pool.push("block-paper","crystal","water");
    if (t>=3) pool.push("block-scissors","diamond","match","slime");
    if (t>=4) pool.push("dark","diamond","crystal","slime");

    const fallback = ["rock","paper","scissors"];
    for(let i=0;i<advCount;i++){
      const bag = (pool.length>0 ? pool : fallback);
      const pick = bag[(Math.random()*bag.length)|0];
      deck.push({type: pick});
    }
    return shuffle(deck);
  }

  // ---------- Safety-hardened deck building ----------
  const MAX_PER_TYPE = 50;
  const MAX_DECK_SIZE = 200;

  function normalizeNameToType(n){
    const m = String(n||"").toLowerCase();
    if (m.includes("block") && m.includes("rock")) return "block-rock";
    if (m.includes("block") && m.includes("paper")) return "block-paper";
    if (m.includes("block") && m.includes("scissors")) return "block-scissors";
    if (m.includes("reveal")) return "effect-reveal";
    if (m.includes("draw")) return "effect-draw";
    if (m.includes("crystal")) return "crystal";
    if (m.includes("diamond")) return "diamond";
    if (m.includes("match")) return "match";
    if (m.includes("water")) return "water";
    if (m.includes("slime")) return "slime";
    if (m.includes("dark")) return "dark";
    if (m.includes("rock")) return "rock";
    if (m.includes("paper")) return "paper";
    if (m.includes("scissors")) return "scissors";
    return "rock";
  }

  function coerceInventory(raw){
    const out = [];

    if (!raw){
      return baseInventory().map(c => ({ type: normalizeNameToType(c.name) }));
    }
    if (Array.isArray(raw)){
      for (const c of raw){
        const type = normalizeNameToType(c?.type || c?.name);
        if (typeof type === 'string') out.push({ type });
        if (out.length >= MAX_DECK_SIZE) break;
      }
      return out.length ? out : baseInventory().map(c => ({ type: normalizeNameToType(c.name) }));
    }
    if (typeof raw === 'object'){
      for (const [key, val] of Object.entries(raw)){
        const type = normalizeNameToType(key);
        let n = Number(val);
        if (!Number.isFinite(n) || n < 0) n = 0;
        n = Math.min(n, MAX_PER_TYPE);
        for (let i = 0; i < n && out.length < MAX_DECK_SIZE; i++){
          out.push({ type });
        }
        if (out.length >= MAX_DECK_SIZE) break;
      }
      return out.length ? out : baseInventory().map(c => ({ type: normalizeNameToType(c.name) }));
    }
    return baseInventory().map(c => ({ type: normalizeNameToType(c.name) }));
  }

  function deckFromInventory(inv){
    const normalized = coerceInventory(inv);
    return shuffle(normalized.length ? normalized : baseInventory().map(c => ({ type: normalizeNameToType(c.name) })));
  }

  function baseInventory(){
    return [
      {name:"Rock"},{name:"Rock"},{name:"Rock"},
      {name:"Paper"},{name:"Paper"},{name:"Paper"},
      {name:"Scissors"},{name:"Scissors"},{name:"Scissors"}
    ];
  }

  // ---------- State ----------
  let me = null, enemy = null;
  let myHP=0, myMax=0, enHP=0, enMax=0;

  let myDeck=[], myDiscard=[], myHand=[];
  let enDeck=[], enDiscard=[], enHand=[];

  let timer=15, timerId=null;
  let round=1;
  let awaitingPick=true;
  let handBoostTurns=0;
  const blocks = { rock:0, paper:0, scissors:0 };

  // ---------- Boot ----------
  await init();

  async function init(){
    try{
      const encSnap = await getDoc(doc(db,"encounters",encounterId));
      if (!encSnap.exists()){
        alert("Encounter missing.");
        return backToWorld();
      }
      const enc = encSnap.data();

      const plSnap = await getDoc(doc(db,"players", username));
      if (!plSnap.exists()){
        alert("Player doc missing.");
        return backToWorld();
      }
      me = plSnap.data();

      const kind = (enc.type || "rock");
      enemy = { kind, ...ENEMY_META[kind] };

      myMax = 3 + (me.level||1);
      myHP = myMax;
      enMax = 3 + Math.max(1, (enemy.tier||0) + 1);
      enHP = enMax;

      enemyEmojiEl.textContent = enemy.emoji;
      enemyNameEl.textContent = enemy.name;
      renderHP();

      myDeck = deckFromInventory(me.inventory || baseInventory());
      enDeck = buildEnemyDeck(enemy.kind);
      drawToHand(myHand, myDeck, 3);
      drawToHand(enHand, enDeck, 3);
      renderHand();

      newRound();
    }catch(err){
      console.error("Init failed:", err);
      alert("There was an error loading the battle.");
      backToWorld();
    }
  }

  // ---------- UI helpers ----------
  function renderHP(){
    phpLbl.textContent = `${myHP}/${myMax}`;
    phpFill.style.width = Math.max(0, Math.round((myHP/myMax)*100))+"%";
    ehpLbl.textContent = `${enHP}/${enMax}`;
    ehpFill.style.width = Math.max(0, Math.round((enHP/enMax)*100))+"%";
  }

  function cardHTML(card, i, disabled=false){
    const type = card.type;
    const e = EMOJI[type] || "‚ùî";
    const n = NAME[type] || type;
    return `<button class="card ${window.innerWidth<680?"small":""} ${disabled?"disabled":""}" data-idx="${i}">
      <div style="font-size:26px">${e}</div>
      <b>${n}</b>
      <small>${NON_ATTACK.has(type)?"Utility":"Attack"}</small>
    </button>`;
  }

  function renderHand(disable=false){
    handRow.innerHTML = myHand.map((c,i)=> cardHTML(c,i, disable)).join("");
    handRow.querySelectorAll(".card").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        if (!awaitingPick) return;
        const idx = +btn.getAttribute("data-idx");
        pickCard(idx);
      });
    });

    blkRock.style.display = blocks.rock>0 ? "inline-flex":"none";
    blkPaper.style.display = blocks.paper>0 ? "inline-flex":"none";
    blkScissors.style.display = blocks.scissors>0 ? "inline-flex":"none";
    if (blocks.rock>0) blkRock.textContent = `üö´ Rock (${blocks.rock})`;
    if (blocks.paper>0) blkPaper.textContent = `üö´ Paper (${blocks.paper})`;
    if (blocks.scissors>0) blkScissors.textContent = `üö´ Scissors (${blocks.scissors})`;
    handBoostPill.style.display = handBoostTurns>0 ? "inline-flex":"none";
    if (handBoostTurns>0) handBoostPill.textContent = `üÉè Hand +1 (${handBoostTurns})`;
  }

  function setCenter(msg){ center.innerHTML = msg; }

  // ---------- Timer ----------
  function startTimer(){
    clearInterval(timerId);
    timer = 15; timerEl.textContent = ""+timer;
    timerId = setInterval(()=>{
      timer--; timerEl.textContent = ""+timer;
      if (timer<=0){
        clearInterval(timerId);
        autoPlay();
      }
    }, 1000);
  }
  function autoPlay(){
    if (!awaitingPick) return;
    pickCard(0);
  }

  // ---------- Round flow ----------
  function newRound(){
    awaitingPick = true;
    setCenter(`Round ${round}: Choose your card‚Ä¶`);
    renderHand(false);
    startTimer();
  }

  async function pickCard(myIdx){
    awaitingPick = false;
    clearInterval(timerId);

    const myCard = myHand.splice(myIdx,1)[0] || {type:"rock"};
    const enemyIdx = chooseEnemyIndex();
    const enCard = enHand.splice(enemyIdx,1)[0] || {type:"rock"};

    myDiscard.push(myCard);
    enDiscard.push(enCard);

    await showClash(myCard, enCard);
    await resolveTurn(myCard, enCard);

    const maxHand = (handBoostTurns>0)?4:3;
    drawToHand(myHand, myDeck, Math.max(0, maxHand - myHand.length));
    drawToHand(enHand, enDeck, Math.max(0, 3 - enHand.length));

    ["rock","paper","scissors"].forEach(k=>{ if (blocks[k]>0) blocks[k]--; });
    if (handBoostTurns>0) handBoostTurns--;

    renderHP();
    renderHand(true);

    if (myHP<=0){ await onPlayerDefeat(); return; }
    if (enHP<=0){ await onWin(); return; }

    round++;
    setTimeout(()=>{ newRound(); }, 600);
  }

  function chooseEnemyIndex(){
    const validIdx = enHand
      .map((c, i)=> (c && typeof c.type==='string') ? i : -1)
      .filter(i=> i>=0);

    if (validIdx.length === 0) return 0;

    const revealIdx = validIdx.find(i => enHand[i].type === "effect-reveal");
    if (revealIdx !== undefined && Math.random() < 0.15) return revealIdx;

    const blockIdx = validIdx.find(i => String(enHand[i].type).startsWith("block-"));
    if (blockIdx !== undefined && Math.random() < 0.12) return blockIdx;

    const atkIdx = validIdx.find(i => !NON_ATTACK.has(enHand[i].type));
    return (atkIdx !== undefined) ? atkIdx : validIdx[0];
  }

  async function showClash(myCard, enCard){
    arena.querySelectorAll(".sprite").forEach(n=>n.remove());
    const left = document.createElement("div");
    const right = document.createElement("div");
    left.className="sprite spriteL runL";
    right.className="sprite spriteR runR";
    left.innerHTML = `<div style="font-size:28px">${EMOJI[myCard.type]||"‚ùî"}</div><small>${NAME[myCard.type]||myCard.type}</small>`;
    right.innerHTML= `<div style="font-size:28px">${EMOJI[enCard.type]||"‚ùî"}</div><small>${NAME[enCard.type]||enCard.type}</small>`;
    arena.appendChild(left); arena.appendChild(right);
    setCenter(`${EMOJI[myCard.type]||"‚ùî"} ${NAME[myCard.type]||myCard.type}  vs  ${EMOJI[enCard.type]||"‚ùî"} ${NAME[enCard.type]||enCard.type}`);
    await wait(900);
  }

  async function resolveTurn(myCard, enCard){
    await applyUtility(myCard, true);
    await applyUtility(enCard, false);

    function blocked(t){
      if (t==="rock") return blocks.rock>0;
      if (t==="paper") return blocks.paper>0;
      if (t==="scissors") return blocks.scissors>0;
      return false;
    }
    let myType = myCard.type, enType = enCard.type;
    let myAtk = !NON_ATTACK.has(myType);
    let enAtk = !NON_ATTACK.has(enType);

    if (myAtk && blocked(myType)) myAtk=false;
    if (enAtk && blocked(enType)) enAtk=false;

    if ((!myAtk) && enAtk){
      setCenter(`<span style="color:var(--bad);font-weight:900">${enemy.name} strikes!</span>`);
      await wait(800); myHP = Math.max(0, myHP-1); return -1;
    }
    if ((!enAtk) && myAtk){
      setCenter(`<span style="color:var(--good);font-weight:900">You strike!</span>`);
      await wait(800); enHP = Math.max(0, enHP-1); return 1;
    }
    if ((!myAtk) && (!enAtk)){
      setCenter(`<span style="color:#6b7280">No effect.</span>`);
      await wait(600); return 0;
    }

    const cmp = compareTypes(myType, enType);
    if (cmp>0){
      setCenter(`<span style="color:var(--good);font-weight:900">You win the clash!</span>`);
      await wait(800); enHP = Math.max(0, enHP-1); return 1;
    } else if (cmp<0){
      setCenter(`<span style="color:var(--bad);font-weight:900">${enemy.name} wins!</span>`);
      await wait(800); myHP = Math.max(0, myHP-1); return -1;
    } else {
      setCenter(`<span style="color:#6b7280;font-weight:900">Draw.</span>`);
      await wait(600); return 0;
    }
  }

  async function applyUtility(card, isPlayer){
    const t = card.type;
    if (t==="effect-reveal"){
      const list = isPlayer ? enHand : myHand;
      const side = isPlayer ? "Enemy" : "You";
      const txt = list.map(c=> (EMOJI[c.type]||"‚ùî")+" "+(NAME[c.type]||c.type)).join(" ¬∑ ");
      setCenter(`üëÅÔ∏è Reveal ‚Äî ${side} hand: ${txt}`);
      await wait(1200);
    } else if (t==="effect-draw"){
      if (isPlayer){
        drawToHand(myHand, myDeck, 2);
        handBoostTurns = Math.max(handBoostTurns, 2);
        renderHand(true);
      } else {
        drawToHand(enHand, enDeck, 2);
      }
    } else if (t==="block-rock" || t==="block-paper" || t==="block-scissors"){
      const typ = t.split("-")[1];
      blocks[typ] = Math.max(blocks[typ], 3);
      renderHand(true);
    }
  }

  // ---------- Deck helpers ----------
  function shuffle(arr){
    if (!Array.isArray(arr)) return [];
    for(let i=arr.length-1;i>0;i--){
      const j = (Math.random()*(i+1))|0;
      const t = arr[i]; arr[i]=arr[j]; arr[j]=t;
    }
    return arr;
  }

  function drawToHand(hand, deck, n){
    n = Number(n);
    if (!Number.isFinite(n) || n <= 0) return;
    for(let i=0;i<n;i++){
      if (deck.length===0) reshuffle(deck, hand===myHand?myDiscard:enDiscard);
      if (deck.length===0) break;
      const next = deck.pop();
      if (next && typeof next.type === 'string') hand.push(next);
    }
  }

  function reshuffle(deck, discard){
    if (deck.length>0) return;
    if (Array.isArray(discard) && discard.length>0){
      while(discard.length) deck.push(discard.pop());
      shuffle(deck);
    }
  }

  // ---------- End handling ----------
  async function onWin(){
    const tier = enemy.tier || 0;
    const xpGain = 15 + 10*tier;
    const goldGain = 3 + tier;
    try{
      const pRef = doc(db,"players",username);
      const pSnap = await getDoc(pRef);
      if (pSnap.exists()){
        const cur = pSnap.data();
        const xp = (cur.xp||0) + xpGain;
        const gold = (cur.gold||0) + goldGain;
        await updateDoc(pRef, { xp, gold });
      }
    }catch(e){ console.warn("Win update failed:", e); }
    setCenter(`üèÜ Victory! +${xpGain} XP ¬∑ +${goldGain} gold`);
    await wait(1000);
    backToWorld();
  }

  function removeRandomCards(inv, count){
    const res = Array.isArray(inv) ? [...inv] : [];
    if (res.length <= 2 || count <= 0) return res;
    const n = Math.min(count, res.length);
    for (let i = 0; i < n; i++){
      const idx = (Math.random()*res.length)|0;
      res.splice(idx, 1);
    }
    return res;
  }

  async function onPlayerDefeat(){
    let lost = 0;
    let newLevel = 1;
    try{
      const pRef = doc(db,"players",username);
      const pSnap = await getDoc(pRef);
      if (pSnap.exists()){
        const cur = pSnap.data();
        newLevel = Math.max(1, (cur.level || 1) - 1);

        const currentInv = Array.isArray(cur.inventory) ? cur.inventory : [];
        const removeCount = currentInv.length > 2 ? 2 : 0;
        const newInv = removeRandomCards(currentInv, removeCount);
        lost = removeCount;

        await updateDoc(pRef, {
          level: newLevel,
          inventory: newInv,
          x: 8, y: 8
        });
      }
    }catch(e){
      console.warn("Defeat update failed:", e);
    }

    setCenter(`üíÄ Defeat ‚Äî Level set to ${newLevel}${lost ? ` ¬∑ lost ${lost} card${lost>1?'s':''}` : ''}. Returning to town‚Ä¶`);
    await wait(1200);
    backToWorld();
  }

  function backToWorld(){
    const worldURL = new URL('./rock.html', location.href).toString();
    location.href = `${worldURL}?username=${encodeURIComponent(username)}`;
  }

  // ---------- Utils ----------
  function wait(ms){ return new Promise(r=> setTimeout(r, ms)); }
</script>
</body>
</html>



