<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>üßô‚Äç‚ôÇÔ∏è Spell Tower ‚Äî 8P Co-op</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<style>
  :root{
    --bg:#0b1014; --panel:#0e1726; --ink:#e6edf3; --muted:#93a4b7; --edge:#1f2a44;
    --good:#22c55e; --warn:#f59e0b; --bad:#ef4444; --accent:#7c3aed;
    --radius:14px; --cell:38px; --gap:6px; --hand-h:22vh; --card-h:148px;
  }
  @media (max-width: 540px){
    :root{ --cell:32px; --hand-h:22vh; --card-h:152px; }
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Arial; color:var(--ink);
    background:radial-gradient(1200px 600px at 50% -200px, #4c1d95 0%, #312e81 55%, #0b1014 100%) fixed;
    overflow:hidden; /* screen never grows; only the trays can scroll */
  }
  .shell{
    height:100dvh; max-width:1100px; margin:0 auto; padding:8px;
    display:grid; grid-template-rows:auto 1fr auto auto; gap:8px; overflow:hidden;
  }
  header{
    position:sticky; top:0; z-index:5;
    display:flex; align-items:center; justify-content:space-between; gap:8px; flex-wrap:wrap;
    padding:6px 8px; background:rgba(14,23,38,.72); border:1px solid rgba(255,255,255,.08);
    border-radius:12px; backdrop-filter: blur(6px);
  }
  .row{display:flex; align-items:center; gap:8px; flex-wrap:wrap}
  .badge{display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.06); font-weight:800}
  .stat{display:flex; gap:6px; align-items:center; padding:4px 8px; border-radius:10px; background:#111827; border:1px solid #1f2937; font-size:.92rem}
  .bar{height:8px; width:96px; background:#0f172a; border-radius:999px; overflow:hidden; border:1px solid #1f2937}
  .bar > i{display:block; height:100%; background:linear-gradient(90deg,#10b981,#22c55e,#84cc16); width:0%}
  .dangerbar > i{background:linear-gradient(90deg,#f97316,#ef4444)}
  .tiny{font-size:.9rem; opacity:.85}

  .btn{
    cursor:pointer; border:1px solid #2a3757; background:#0c1422; color:var(--ink);
    border-radius:10px; padding:8px 10px; font-weight:800; font-size:.95rem;
    width:100%; min-height:40px; touch-action:manipulation;
  }
  .btn:hover{ background:#101a2b }
  .danger{border-color:#7f1d1d; color:#fecaca}
  .ok{border-color:#14532d; color:#bbf7d0}
  .disabled{opacity:.6; pointer-events:none}

  .board-card, .trade-card, .hand-card{
    background:rgba(14,23,38,.7); border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:6px;
    box-shadow:0 10px 25px rgba(0,0,0,.18); backdrop-filter: blur(6px);
  }

  .board-wrap{display:flex; justify-content:center; overflow:hidden}
  .board{
    display:grid; grid-template-columns: repeat(4, var(--cell)); grid-auto-rows: var(--cell);
    gap:var(--gap); padding:6px; border-radius:10px; background:#0a1220; border:1px solid #1f2a44;
  }
  .cell{
    width:var(--cell); height:var(--cell); display:grid; place-items:center; font-size:18px; line-height:1;
    background:#0b1320; border:1px solid #1f2a44; border-radius:8px; position:relative; overflow:hidden;
  }
  .tower{filter:drop-shadow(0 1px 4px rgba(0,0,0,.4))}
  .hpbar{position:absolute; top:2px; left:2px; right:2px; height:6px; background:#1f2937; border-radius:6px; overflow:hidden}
  .hpbar > i{display:block; height:100%; width:100%; background:linear-gradient(90deg,#22c55e,#84cc16)}
  .frozen{ box-shadow: inset 0 0 0 2px rgba(125,211,252,.7); background:#0b2333 }
  .vine{ box-shadow: inset 0 0 0 2px rgba(34,197,94,.7); background:#0d2317 }
  .burn{ box-shadow: inset 0 0 0 2px rgba(239,68,68,.7); background:#2b0f12 }

  .glow-red{animation: glowRed .9s ease}
  @keyframes glowRed{ 0%{box-shadow:0 0 0 0 rgba(239,68,68,.8)} 100%{box-shadow:0 0 0 18px rgba(239,68,68,0)} }
  .flash-yellow{animation: flashY .7s ease}
  @keyframes flashY{ 0%{box-shadow:0 0 0 0 rgba(250,204,21,.85)} 100%{box-shadow:0 0 0 18px rgba(250,204,21,0)} }
  .implode{ position:absolute; inset:0; display:grid; place-items:center; pointer-events:none; animation: impl .45s ease forwards; }
  @keyframes impl{ 0%{transform:scale(1); opacity:.95} 100%{transform:scale(.1); opacity:0} }

  .glow-blue{animation: glowBlue .9s ease}
  @keyframes glowBlue{ 0%{box-shadow:0 0 0 0 rgba(59,130,246,.9)} 100%{box-shadow:0 0 0 18px rgba(59,130,246,0)} }
  .glow-green{animation: glowGreen .9s ease}
  @keyframes glowGreen{ 0%{box-shadow:0 0 0 0 rgba(34,197,94,.9)} 100%{box-shadow:0 0 0 18px rgba(34,197,94,0)} }
  .glow-orange{animation: glowOrange .9s ease}
  @keyframes glowOrange{ 0%{box-shadow:0 0 0 0 rgba(245,158,11,.9)} 100%{box-shadow:0 0 0 18px rgba(245,158,11,0)} }

  .trade-grid{ display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center; }
  .trade-left{display:flex; align-items:center; gap:8px; flex-wrap:nowrap; overflow-x:auto; overflow-y:hidden; -webkit-overflow-scrolling:touch;}
  .trade-slot{
    min-width:78px; min-height:36px; display:flex; align-items:center; justify-content:center;
    border:1px dashed #37517a; border-radius:10px; padding:4px 6px; background:#0b1320; font-size:.95rem;
  }
  .proposal-row{display:flex; gap:6px; flex-wrap:nowrap; overflow-x:auto; overflow-y:hidden; -webkit-overflow-scrolling:touch;}

  .hand-card{ display:grid; gap:6px; }
  .hand-head{display:flex; justify-content:space-between; align-items:center}

  /* One-row horizontal scroll hand tray */
  .hand-scroll{
    height: calc(var(--card-h) + 16px);  /* one row, just enough for the cards */
    overflow-x: auto;
    overflow-y: hidden;
    -webkit-overflow-scrolling:touch;
    border:1px solid #1f2a44; border-radius:10px; padding:6px; background:#0a1220;
  }
  .hand{ display:flex; flex-wrap:nowrap; gap:6px; }

  /* Cards: slightly shorter vertically */
  .card{
    min-width:92px; max-width:120px; width:calc(50% - 9px);
    border:1px solid #2a3757; background:#111b2c; color:#e6edf3;
    border-radius:12px; padding:6px; display:grid; gap:6px;
    grid-template-rows:auto 1fr auto; min-height:var(--card-h);
  }
  @media (min-width:560px){ .card{ width:110px; } }
  .card .name{font-weight:800; font-size:1rem; line-height:1.05; word-break:break-word}
  .charges{display:flex; gap:4px; align-items:center}
  .pip{width:10px; height:10px; border-radius:50%; background:#10b981}
  .pip.off{background:#374151}
  /* stronger highlight so it 'reads' as yellow on all screens */
  .combo-hint{
    outline:2px solid #facc15;
    box-shadow:0 0 0 3px rgba(250,204,21,.25), inset 0 0 0 9999px rgba(250,204,21,.06);
  }
  .muted{color:var(--muted)}
  .btn-top{margin-bottom:1px}
  .btn-bottom{margin-top:1px}

  footer{display:flex; align-items:center; justify-content:space-between; gap:8px; flex-wrap:wrap}
  .fsbtn{margin-left:4px}

  /* Enemy tooltip */
  #enemyTip{
    position:fixed; z-index:20; max-width:260px;
    background:#0e1726; border:1px solid #2a3757; border-radius:10px; padding:8px;
    box-shadow:0 12px 30px rgba(0,0,0,.35); display:none;
  }
  #enemyTip .title{font-weight:800; margin-bottom:4px}
  #enemyTip .line{font-size:.92rem; color:#cbd5e1}
</style>
</head>
<body>
<div class="shell">
  <header>
    <div class="row">
      <span class="badge">üßô‚Äç‚ôÇÔ∏è Spell Tower</span>
      <span id="hostBadge" class="badge" style="display:none">üëë Host</span>
      <span id="playersBadge" class="badge">üë• 0/8</span>
    </div>
    <div class="row">
      <div class="stat" title="Tower Health">
        üè∞
        <div class="bar dangerbar"><i id="hpFill"></i></div>
        <b id="hpText">50/50</b>
      </div>
      <div class="stat" title="Shared Mana">
        ‚ú®
        <div class="bar"><i id="manaFill"></i></div>
        <b id="manaText">0/0</b>
      </div>
      <div class="stat tiny" title="Turn / Tick">
        üîÅ Turn: <b id="turnText">?</b> ‚Ä¢ ‚è±Ô∏è <b id="tickText">‚Äî</b>
      </div>
      <button id="fsBtn" class="btn fsbtn" title="Fullscreen" style="width:auto;min-height:auto;padding:6px 9px">‚õ∂ Full</button>
      <button id="leaveBtn" class="btn danger" style="width:auto;min-height:auto;padding:6px 9px">üè† Leave</button>
    </div>
  </header>

  <section class="board-card" style="min-height:140px">
    <div class="board-wrap"><div id="board" class="board" aria-label="Battlefield"></div></div>
  </section>

  <section class="trade-card">
    <div class="trade-grid">
      <div class="trade-left">
        <div>üîÑ Trade Block:</div>
        <div id="myTrade" class="trade-slot" title="Place a card here to offer">‚Äî empty ‚Äî</div>
        <button id="clearTradeBtn" class="btn" style="width:auto;min-height:auto;padding:6px 9px">Clear</button>
      </div>
      <div>
        <div class="tiny muted">Proposals visible:</div>
        <div id="proposals" class="proposal-row"></div>
      </div>
    </div>
  </section>

  <section class="hand-card">
    <div class="hand-head">
      <div class="tiny">Your Hand</div>
      <!-- (instructions removed as requested) -->
    </div>
    <div class="hand-scroll">
      <div id="hand" class="hand" aria-label="Your spell cards"></div>
    </div>
  </section>

  <footer>
    <div class="row">
      <button id="tradeHereBtn" class="btn">Put Selected ‚Üí Trade Block</button>
      <button id="endTurnBtn" class="btn ok" style="width:auto">End Turn (+1 card)</button>
    </div>
    <div class="tiny muted">Game: <code id="gidTxt"></code> ‚Ä¢ Player: <code id="unameTxt"></code></div>
  </footer>
</div>

<!-- Enemy tooltip -->
<div id="enemyTip">
  <div class="title" id="tipTitle">Enemy</div>
  <div class="line" id="tipHP">HP ‚Äî</div>
  <div class="line" id="tipWeak">Weak: ‚Äî</div>
  <div class="line" id="tipRes">Resist: ‚Äî</div>
  <div class="line" id="tipAbility">Ability: ‚Äî</div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import { getFirestore, doc, getDoc, setDoc, updateDoc, runTransaction, onSnapshot } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

  // ---------- Firebase ----------
  const firebaseConfig = {
    apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
    authDomain: "bible-game-246c0.firebaseapp.com",
    projectId: "bible-game-246c0",
    storageBucket: "bible-game-246c0.appspot.com",
    messagingSenderId: "959619818996",
    appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // ---------- URL Params ----------
  const params = new URLSearchParams(location.search);
  const gameId = params.get("gameId") || "";
  const username = (params.get("username") || "").trim();
  gidTxt.textContent = gameId;
  unameTxt.textContent = username;
  if (!gameId || !username) { alert("Missing gameId/username (launch from lobby)."); }

  // ---------- Refs ----------
  const lobbyRef = doc(db, "lobbies", gameId);
  const stateRef = doc(db, "spelltower", gameId);

  // ---------- Types & mapping ----------
  const TYPES = {
    fire: "üî•", water: "üíß", ice: "üßä", electric: "‚ö°",
    nature: "üåø", earth: "ü™®", arcane: "‚ú®", shadow:"üåë", neutral:"‚öîÔ∏è"
  };
  function effectType(effect){
    const map = {
      fire:'fire', pyro:'fire', inferno:'fire', scald:'fire', boil:'fire', wildfire:'fire', cataclysm:'fire', fireline:'fire', eruption:'fire',
      water:'ice', steam:'water', geyser:'water', tsunami:'water', frostline:'ice', shockpush:'electric',
      plant:'nature', vine:'nature', wall:'earth', cinderwall:'fire', thorns:'nature', marsh:'nature', overgrowth:'nature', worldroot:'nature',
      lightning:'electric', chain:'electric', superchain:'electric', thunderstorm:'electric', thundercloud:'electric', voltaic:'electric', arcfire:'electric', mistflash:'electric', storm:'electric', supernova:'electric', stormfront:'electric', battery:'electric', bogstorm:'electric',
      steamblast:'water', entangle:'nature', net:'nature',
      default:'neutral'
    };
    return map[effect] || map.default;
  }

  // ---------- Game constants ----------
  const COLS = 4, ROWS = 10;
  const TOWER_ROW = ROWS - 1;
  const START_HP = 50;

  // ---------- Enemies (with weaknesses/resists) ----------
  const ENEMIES = [
    { key:"rat",    name:"Cave Rat",     hp:3,  spd:2, dmg:1, emoji:"üêÄ",  weight:1,  ability:null,        weak:['fire'], res:[] },
    { key:"imp",    name:"Ember Imp",    hp:5,  spd:1, dmg:1, emoji:"üòà",  weight:2,  ability:null,        weak:['water','ice'], res:['fire'] },
    { key:"orc",    name:"Orc",          hp:8,  spd:1, dmg:2, emoji:"üëπ",  weight:3,  ability:null,        weak:['electric'], res:['earth'] },
    { key:"trol",   name:"Troll",        hp:14, spd:1, dmg:3, emoji:"üêó",  weight:4,  ability:null,        weak:['fire'], res:['nature'] },
    { key:"warg",   name:"Warg",         hp:10, spd:1, dmg:2, emoji:"üê∫",  weight:4,  ability:null,        weak:['electric'], res:['nature'] },
    { key:"mage",   name:"Dark Mage",    hp:8,  spd:1, dmg:2, emoji:"üßô‚Äç‚ôÇÔ∏è",  weight:5,  ability:"summon_rats",weak:['nature'], res:['ice'] },
    { key:"dlord",  name:"Demon Lord",   hp:16, spd:1, dmg:3, emoji:"üòàüî•",weight:6,  ability:"fire_bolt", weak:['water','ice'], res:['fire'] },
    { key:"golem",  name:"Stone Golem",  hp:20, spd:1, dmg:3, emoji:"üóø",  weight:7,  ability:null,        weak:['water','nature'], res:['earth','electric'] },
    { key:"slime",  name:"Slime",        hp:9,  spd:1, dmg:1, emoji:"ü¶†",  weight:4,  ability:null,        weak:['electric','ice'], res:['water','nature'] },
    { key:"specter",name:"Specter",      hp:7,  spd:2, dmg:2, emoji:"üëª",  weight:5,  ability:null,        weak:['electric','fire'], res:['water','nature'] },
  ];

  // ---------- Base spells ----------
  const BASE_SPELLS = {
    fire:   { name:"Fire",      emoji:"üî•", charges:3, cost:0, effect:"fire" },
    water:  { name:"Water",     emoji:"üíß", charges:3, cost:0, effect:"water" },
    plant:  { name:"Plant",     emoji:"üåø", charges:3, cost:0, effect:"plant" },
    light:  { name:"Lightning", emoji:"‚ö°", charges:3, cost:0, effect:"lightning" },
  };

  // ---------- Combos ----------
  const COMBOS = {
    "fire+fire":        { key:"pyro",     name:"Pyro",        emoji:"üî•üî•",    charges:3, effect:"pyro" },
    "pyro+pyro":        { key:"inferno",  name:"Inferno",     emoji:"üî•üî•üî•",  charges:3, effect:"inferno" },
    "fire+water":       { key:"steam",    name:"Steam",       emoji:"üí®",      charges:3, effect:"steam" },
    "water+plant":      { key:"vine",     name:"Vine",        emoji:"ü™¥",      charges:3, effect:"vine" },
    "light+light":      { key:"chain",    name:"Chain",       emoji:"‚ö°‚ö°",     charges:3, effect:"chain" },
    "water+water":      { key:"geyser",   name:"Geyser",      emoji:"ü´ß",      charges:3, effect:"geyser" },
    "plant+plant":      { key:"wall",     name:"Wall",        emoji:"üß±",      charges:3, effect:"wall" },
    "fire+plant":       { key:"embervine",name:"Embervine",   emoji:"üî•ü™¥",    charges:3, effect:"embervine" },
    "fire+light":       { key:"overheat", name:"Overheat",    emoji:"üî•‚ö°",    charges:3, effect:"overheat" },
    "fire+vine":        { key:"bramblefire",name:"Bramblefire",emoji:"üåøüî•",  charges:3, effect:"bramblefire" },
    "fire+chain":       { key:"arcfire",  name:"Arc Fire",    emoji:"‚ö°üî•",    charges:3, effect:"arcfire" },
    "fire+steam":       { key:"scald",    name:"Scald",       emoji:"üí®üî•",    charges:3, effect:"scald" },
    "water+light":      { key:"storm",    name:"Storm",       emoji:"‚õàÔ∏è",      charges:3, effect:"storm" },
    "water+pyro":       { key:"steamblast",name:"Steam Blast",emoji:"üí®üí•",    charges:3, effect:"steamblast" },
    "water+inferno":    { key:"boil",     name:"Boil",        emoji:"üåã",      charges:3, effect:"boil" },
    "water+chain":      { key:"voltaic",  name:"Voltaic",     emoji:"‚ö°üíß",    charges:3, effect:"voltaic" },
    "plant+pyro":       { key:"cinderwall",name:"Cinder Wall",emoji:"üß±üî•",    charges:3, effect:"cinderwall" },
    "plant+light":      { key:"thorns",   name:"Thorns",      emoji:"üåµ",      charges:3, effect:"thorns" },
    "plant+steam":      { key:"marsh",    name:"Marsh",       emoji:"ü™µüíß",    charges:3, effect:"marsh" },
    "light+pyro":       { key:"superchain",name:"Super Chain",emoji:"‚ö°‚ö°‚ö°",    charges:3, effect:"superchain" },
    "light+inferno":    { key:"thunderstorm",name:"Thunderstorm",emoji:"üå©Ô∏è",  charges:3, effect:"thunderstorm" },
    "light+steam":      { key:"mistflash",name:"Mistflash",   emoji:"üí®‚ö°",    charges:3, effect:"mistflash" },
    "light+vine":       { key:"net",      name:"Net",         emoji:"üï∏Ô∏è",     charges:3, effect:"net" },
    "steam+steam":      { key:"tsunami",  name:"Tsunami",     emoji:"üåä",      charges:3, effect:"tsunami" },
    "pyro+vine":        { key:"wildfire", name:"Wildfire",    emoji:"üî•üåø",    charges:3, effect:"wildfire" },
    "chain+steam":      { key:"thundercloud",name:"Thundercloud",emoji:"üåßÔ∏è‚ö°",charges:3, effect:"thundercloud" },
    "chain+vine":       { key:"entangle", name:"Entangle",    emoji:"‚ö°ü™¢",    charges:3, effect:"entangle" },

    /* big impacts */
    "inferno+tsunami":  { key:"cataclysm", name:"Cataclysm",  emoji:"üî•üåä",    charges:2, effect:"cataclysm" },
    "superchain+inferno":{key:"supernova", name:"Supernova",  emoji:"üí•‚ö°",    charges:2, effect:"supernova" },
    "wall+entangle":    { key:"worldroot", name:"Worldroot",  emoji:"üåøüß±",    charges:2, effect:"worldroot" },
    "thunderstorm+tsunami":{key:"stormfront",name:"Stormfront",emoji:"üå©Ô∏èüåä",  charges:2, effect:"stormfront" },
    "boil+geyser":      { key:"eruption",  name:"Eruption",   emoji:"üåãü´ß",    charges:2, effect:"eruption" },
    "marsh+thorns":     { key:"overgrowth",name:"Overgrowth", emoji:"üåøüåø",    charges:2, effect:"overgrowth" },

    /* extra variety */
    "water+wall":       { key:"frostline", name:"Frostline",  emoji:"‚ùÑÔ∏èüß±",    charges:3, effect:"frostline" },
    "chain+wall":       { key:"battery",   name:"Battery",    emoji:"‚ö°üîã",     charges:3, effect:"battery" },
    "geyser+chain":     { key:"shockpush", name:"Shockpush",  emoji:"‚ö°ü´ß",     charges:2, effect:"shockpush" },
    "wall+pyro":        { key:"fireline",  name:"Fireline",   emoji:"üî•üß±",     charges:2, effect:"fireline" },
    "light+marsh":      { key:"bogstorm",  name:"Bogstorm",   emoji:"‚ö°üå´Ô∏è",     charges:2, effect:"bogstorm" },

    /* aliases / more flavor */
    "fire+geyser":      { key:"steamburst",name:"Steamburst", emoji:"üí•ü´ß",     charges:3, effect:"steamblast" },
    "vine+wall":        { key:"hedge",     name:"Hedge",      emoji:"üåøüß±",     charges:3, effect:"wall" },
    "chain+pyro":       { key:"ionflare",  name:"Ion Flare",  emoji:"‚ö°üî•",     charges:3, effect:"arcfire" },
    "steam+vine":       { key:"sauna",     name:"Sauna",      emoji:"üí®üåø",     charges:3, effect:"marsh" },
    "steam+chain":      { key:"stormsteam",name:"Stormsteam", emoji:"üí®‚ö°",     charges:3, effect:"mistflash" },
    "vine+thorns":      { key:"bramble",   name:"Bramble",    emoji:"ü™µüåµ",     charges:3, effect:"thorns" },
    "wall+wall":        { key:"bastion",   name:"Bastion",    emoji:"üß±üß±",     charges:3, effect:"wall" },
    "steam+pyro":       { key:"flashboil", name:"Flashboil",  emoji:"üí®üî•",     charges:3, effect:"boil" },
    "vine+tsunami":     { key:"kelpstorm", name:"Kelpstorm",  emoji:"üåøüåä",     charges:3, effect:"marsh" }
  };

  // ---------- DOM ----------
  const boardEl = document.getElementById("board");
  const handEl = document.getElementById("hand");
  const myTradeEl = document.getElementById("myTrade");
  const proposalsEl = document.getElementById("proposals");
  const hostBadge = document.getElementById("hostBadge");
  const playersBadge = document.getElementById("playersBadge");
  const hpFill = document.getElementById("hpFill");
  const hpText = document.getElementById("hpText");
  const manaFill = document.getElementById("manaFill");
  const manaText = document.getElementById("manaText");
  const tickText = document.getElementById("tickText");
  const turnText = document.getElementById("turnText");
  const endTurnBtn = document.getElementById("endTurnBtn");
  const tradeHereBtn = document.getElementById("tradeHereBtn");
  const clearTradeBtn = document.getElementById("clearTradeBtn");
  const leaveBtn = document.getElementById("leaveBtn");
  const fsBtn = document.getElementById("fsBtn");

  const enemyTip = document.getElementById("enemyTip");
  const tipTitle = document.getElementById("tipTitle");
  const tipHP = document.getElementById("tipHP");
  const tipWeak = document.getElementById("tipWeak");
  const tipRes = document.getElementById("tipRes");
  const tipAbility = document.getElementById("tipAbility");

  // ---------- Basic actions ----------
  leaveBtn.onclick = ()=> { location.href = `/?username=${encodeURIComponent(username)}`; };
  fsBtn.onclick = async ()=>{
    const el = document.documentElement;
    try{
      if (!document.fullscreenElement) { await el.requestFullscreen?.(); }
      else { await document.exitFullscreen?.(); }
    }catch(e){ window.scrollTo({top:0,behavior:"smooth"}); }
  };

  // ---------- Local UI state ----------
  let isHost = false;
  let ui = { mode:null, selectedCardId:null }; // mode: null | 'cast' | 'combine'
  let lastPlayedTurnMarker = {};
  let latestState = null;

  // ---------- Board ----------
  function buildBoard(){
    boardEl.innerHTML = "";
    for(let r=0; r<ROWS; r++){
      for(let c=0; c<COLS; c++){
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.dataset.x = c; cell.dataset.y = r;
        if (r === TOWER_ROW) { cell.classList.add("tower"); cell.title = "Your Tower"; cell.textContent = "üè∞"; }
        cell.addEventListener("click", ()=> onCellClick(c,r, cell));
        boardEl.appendChild(cell);
      }
    }
  }
  buildBoard();

  // ---------- Helpers ----------
  const id = ()=> Math.random().toString(36).slice(2,9);
  const clamp = (n,min,max)=> Math.max(min, Math.min(max,n));
  const inBoard = (x,y)=> x>=0 && x<COLS && y>=0 && y<ROWS;
  const idx = (x,y)=> y*COLS + x;

  function getEnemySpec(key){ return ENEMIES.find(e=> e.key===key) || ENEMIES[0]; }
  function enemyAt(d,x,y){ return (d.enemies||[]).find(e=> e.x===x && e.y===y) || null; }
  function typeEmoji(t){ return TYPES[t] || '‚öîÔ∏è'; }

  function showEnemyTip(eObj, cellEl){
    const spec = getEnemySpec(eObj.key);
    tipTitle.textContent = `${spec.emoji} ${spec.name}`;
    tipHP.textContent = `HP ${eObj.hp}`;
    tipWeak.innerHTML = `Weak: ${ (spec.weak||[]).map(typeEmoji).join(' ') || '‚Äî' }`;
    tipRes.innerHTML  = `Resist: ${ (spec.res||[]).map(typeEmoji).join(' ') || '‚Äî' }`;
    tipAbility.textContent = `Ability: ${ spec.ability ? (spec.ability==='fire_bolt'?'üî• Fire Bolt': spec.ability==='summon_rats'?'üêÄ Rat Swarm': spec.ability) : '‚Äî' }`;

    const r = cellEl.getBoundingClientRect();
    const pad = 8;
    enemyTip.style.left = Math.min(window.innerWidth - 280, Math.max(8, r.left + r.width + pad)) + "px";
    enemyTip.style.top  = Math.min(window.innerHeight - 160, Math.max(8, r.top)) + "px";
    enemyTip.style.display = "block";
  }
  function hideEnemyTip(){ enemyTip.style.display = "none"; }

  function randomEnemyCells(d, count){
    const cells = [];
    for (const e of d.enemies||[]) cells.push([e.x,e.y]);
    if (!cells.length) return [];
    const picks = [];
    for (let i=0;i<Math.min(count, cells.length); i++){
      const j = Math.floor(Math.random()*cells.length);
      picks.push(cells.splice(j,1)[0]);
    }
    return picks;
  }

  function chainLightning(d, sx, sy, bonus=0, burn=false, root=false){
    const inB = (x,y)=> x>=0 && x<COLS && y>=0 && y<ROWS;
    const neigh = ([x,y])=> [[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(([a,b])=> inB(a,b));
    const baseDmg = 3 + (bonus||0);
    const seen = new Set();
    let frontier = [[sx,sy]];
    const now = (d.turn||0);
    while (frontier.length){
      const [x,y] = frontier.shift();
      const k = `${x},${y}`; if (seen.has(k)) continue; seen.add(k);
      for (const e of d.enemies||[]) if (e.x===x && e.y===y){
        const t='electric';
        e.hp -= applyTypeMod(e, baseDmg, t);
      }
      d.enemies = (d.enemies||[]).filter(e=> e.hp>0);
      if (burn){ if (!d.burnCells) d.burnCells={}; d.burnCells[`${x},${y}`]= now + 1; }
      if (root){ if (!d.vineCells) d.vineCells={}; d.vineCells[`${x},${y}`]= now + 1; }
      for (const [a,b] of neigh([x,y])){
        const hasEnemy = (d.enemies||[]).some(e=> e.x===a && e.y===b);
        if (hasEnemy) frontier.push([a,b]);
      }
    }
  }

  function glowCell(x,y, cls){
    const cell = boardEl.children[idx(x,y)];
    if (!cell) return;
    cell.classList.add(cls);
    setTimeout(()=> cell.classList.remove(cls), 800);
  }
  function tinyImplosion(el){
    const fx = document.createElement("div");
    fx.className = "implode";
    fx.textContent = "üí•";
    el.appendChild(fx);
    setTimeout(()=> fx.remove(), 450);
  }
  function pulseCells(cells, cls){
    for (const [x,y] of cells){ requestAnimationFrame(()=> glowCell(x,y,cls)); }
  }

  // ---------- Lobby / Host ----------
  onSnapshot(lobbyRef, async (snap)=>{
    if (!snap.exists()) return;
    const d = snap.data();
    const players = d.players || [];
    playersBadge.textContent = `üë• ${players.length}/8`;
    if (!d.host && players.length){
      try{
        await runTransaction(db, async tx=>{
          const cur = await tx.get(lobbyRef);
          if (!cur.exists()) return;
          const cd = cur.data();
          if (!cd.host){ tx.update(lobbyRef, { host: players[0] }); }
        });
      }catch(e){}
    }
    isHost = (d.host === username);
    hostBadge.style.display = isHost ? "inline-flex" : "none";
    ensureGameState(players, d.host || players[0] || null);
  });

  // ---------- Initial Game State ----------
  async function ensureGameState(players, host){
    const s = await getDoc(stateRef);
    if (!s.exists()){
      if (!isHost) return;
      const hands = {};
      for (const p of players) hands[p] = seedHand();
      const payload = {
        createdAt: Date.now(),
        running: true,
        tick: 0,
        turn: 0,
        turnOrder: players,
        turnIndex: 0,
        currentPlayer: players[0] || "",
        towerHP: START_HP,
        towerMax: START_HP,
        mana: 0, manaMax: 12,
        enemies: [],
        bolts: [],
        frozenCols: {},
        vineCells: {},
        burnCells: {},
        hands,
        playedTurn: {},
        trade: { offers: {}, proposals: {} },
        host: host || "",
      };
      await setDoc(stateRef, payload);
    } else {
      if (players.includes(username)){
        const d = s.data();
        if (!d.hands || !d.hands[username]){
          await updateDoc(stateRef, { [`hands.${username}`]: seedHand() });
        }
      }
    }
  }

  function seedHand(){
    const baseKeys = Object.keys(BASE_SPELLS);
    const picks = [];
    for (let i=0;i<3;i++){
      const k = baseKeys[Math.floor(Math.random()*baseKeys.length)];
      picks.push(makeCardFromKey(k));
    }
    return picks;
  }
  function makeCardFromKey(k){
    const spec = BASE_SPELLS[k];
    return { id:id(), type:k, name:spec.name, emoji:spec.emoji, charges:spec.charges, effect:spec.effect };
  }

  // ---------- Render ----------
  onSnapshot(stateRef, (snap)=>{ if (snap.exists()) renderAll(snap.data()); });

  function renderAll(s){
    latestState = s;
    hpText.textContent = `${s.towerHP}/${s.towerMax}`;
    hpFill.style.width = clamp((s.towerHP/s.towerMax)*100, 0, 100) + "%";
    manaText.textContent = `${s.mana}/${s.manaMax}`;
    manaFill.style.width = clamp((s.mana/s.manaMax)*100, 0, 100) + "%";
    tickText.textContent = "‚Äî";
    turnText.textContent = `${(s.turn||0)+1} ‚Ä¢ ${s.currentPlayer||"?"}`;

    const myTurn = (s.currentPlayer === username) && s.running;
    endTurnBtn.classList.toggle("disabled", !myTurn);
    tradeHereBtn.classList.toggle("disabled", !myTurn);

    // clear board
    for (let r=0; r<ROWS; r++){
      for (let c=0; c<COLS; c++){
        const cell = boardEl.children[idx(c,r)];
        cell.innerHTML = "";
        cell.className = "cell" + (r===TOWER_ROW ? " tower" : "");
        if (r === TOWER_ROW) cell.textContent = "üè∞";
      }
    }

    const nowTurn = s.turn || 0;
    for (const [xStr,until] of Object.entries(s.frozenCols || {})){
      const x = Number(xStr);
      if (until >= nowTurn){ for (let r=0; r<ROWS; r++){ boardEl.children[idx(x,r)]?.classList.add("frozen"); } }
    }
    for (const [key,until] of Object.entries(s.vineCells || {})){
      if (until >= nowTurn){
        const [x,y] = key.split(",").map(Number);
        if (inBoard(x,y)) boardEl.children[idx(x,y)]?.classList.add("vine");
      }
    }
    for (const [key,until] of Object.entries(s.burnCells || {})){
      if (until >= nowTurn){
        const [x,y] = key.split(",").map(Number);
        if (inBoard(x,y)) boardEl.children[idx(x,y)]?.classList.add("burn");
      }
    }

    // enemies
    for (const e of (s.enemies||[])){
      if (!inBoard(e.x,e.y)) continue;
      const cell = boardEl.children[idx(e.x,e.y)];
      const base = getEnemySpec(e.key).hp || e.hp || 1;
      const hpPct = clamp((e.hp / base) * 100, 0, 100);
      const wrap = document.createElement("div");
      wrap.textContent = e.emoji;
      const bar = document.createElement("div"); bar.className = "hpbar";
      const fill = document.createElement("i"); fill.style.width = hpPct + "%";
      bar.appendChild(fill); wrap.appendChild(bar);
      cell.appendChild(wrap);
    }
    // bolts
    for (const b of (s.bolts||[])){
      if (!inBoard(b.x,b.y)) continue;
      const cell = boardEl.children[idx(b.x,b.y)];
      const bolt = document.createElement("div");
      bolt.textContent = "üî•";
      const bar = document.createElement("div"); bar.className = "hpbar"; bar.style.top = "22px";
      const fill = document.createElement("i"); fill.style.width = clamp((b.hp/1)*100,0,100) + "%";
      bar.appendChild(fill); bolt.appendChild(bar);
      cell.appendChild(bolt);
    }

    const myHand = (s.hands && s.hands[username]) ? s.hands[username] : [];
    renderHand(myHand, s);
    renderTrade(s);

    if (s.towerHP <= 0 && s.running){ endGameAndReturn(); }
  }

  async function endGameAndReturn(){
    try{ await updateDoc(stateRef, { running:false }); }catch(e){}
    try{ await updateDoc(lobbyRef, { status:"waiting" }); }catch(e){}
    location.href = `/?username=${encodeURIComponent(username)}`;
  }

  function potentialPartners(card){
    if (!card || !card.type) return [];
    const res = [];
    for (const key of Object.keys(COMBOS)){
      const [a,b] = key.split("+");
      if (a===card.type) res.push({ type:b });
      if (b===card.type) res.push({ type:a });
    }
    return res;
  }

  function renderHand(cards, s){
    handEl.innerHTML = "";
    const combosFor = (base)=> potentialPartners(base).map(p=> p.type);
    const selected = cards.find(c=> c.id===ui.selectedCardId) || null;
    const highlightTypes = (ui.mode==='combine' && selected) ? combosFor(selected) : [];

    for (const card of cards){
      const el = document.createElement("div");
      el.className = "card";
      if (ui.mode==='combine' && ui.selectedCardId && card.id !== ui.selectedCardId && highlightTypes.includes(card.type)){
        el.classList.add("combo-hint");
      }
      el.innerHTML = `
        <button class="btn btn-top" data-act="cast">Cast</button>
        <div>
          <div class="name">${card.emoji} ${card.name}</div>
          <div class="charges" aria-label="charges">${[0,1,2].map(i=> `<i class="pip ${card.charges>i?'':'off'}"></i>`).join('')}</div>
        </div>
        <button class="btn btn-bottom" data-act="combine">Combine‚Ä¶</button>
      `;

      // Button handlers
      const castBtn = el.querySelector('[data-act="cast"]');
      const combBtn = el.querySelector('[data-act="combine"]');

      castBtn.addEventListener('click', (e)=>{
        e.preventDefault(); e.stopPropagation();
        ui.mode='cast'; ui.selectedCardId = card.id; hideEnemyTip();
        renderHand(cards, s); // clear combine highlights immediately
      });

      combBtn.addEventListener('click', (e)=>{
        e.preventDefault(); e.stopPropagation();
        hideEnemyTip();
        if (ui.mode === 'combine' && ui.selectedCardId && ui.selectedCardId !== card.id){
          // second selection via button -> combine now
          immediateCombineByIds(ui.selectedCardId, card.id);
          ui.mode=null; ui.selectedCardId=null;
        } else {
          // first selection -> show highlights now
          ui.mode='combine'; ui.selectedCardId = card.id;
          renderHand(cards, s);
        }
      });

      // Whole card tap = second selection for combine (convenience)
      el.addEventListener('click', ()=>{
        if (ui.mode==='combine' && ui.selectedCardId && card.id !== ui.selectedCardId){
          immediateCombineByIds(ui.selectedCardId, card.id);
          ui.mode=null; ui.selectedCardId=null;
        }
      });

      handEl.appendChild(el);
    }
  }

  function renderTrade(s){
    const myOfferId = (s.trade?.offers || {})[username] || null;
    if (!myOfferId){ myTradeEl.textContent = "‚Äî empty ‚Äî"; }
    else {
      const card = (s.hands[username]||[]).find(c=> c.id===myOfferId);
      myTradeEl.textContent = card ? `${card.emoji} ${card.name}` : "(offered)";
    }
    proposalsEl.innerHTML = "";
    const allProps = s.trade?.proposals || {};
    const myProps = (allProps[username] || []);
    for (const pr of myProps){
      const from = pr.from, cardId = pr.cardId;
      const btn = document.createElement("button");
      btn.className = "btn"; btn.style.width="auto"; btn.style.minHeight="auto"; btn.style.padding="6px 9px";
      btn.textContent = `Accept ${from}`;
      btn.onclick = ()=> acceptTrade(from, username, cardId);
      proposalsEl.appendChild(btn);
    }
  }

  tradeHereBtn.onclick = async ()=>{
    hideEnemyTip();
    if (!ui.selectedCardId) return;
    const s = (await getDoc(stateRef)).data();
    const myHand = s.hands[username]||[];
    const card = myHand.find(c=> c.id===ui.selectedCardId);
    if (!card) return;
    await updateDoc(stateRef, { [`trade.offers.${username}`]: card.id });
    ui.mode=null; ui.selectedCardId=null;
    renderHand(s.hands[username]||[], s);
  };

  clearTradeBtn.onclick = async ()=>{
    const patch = {}; patch[`trade.offers.${username}`] = null;
    await updateDoc(stateRef, patch);
    const s = (await getDoc(stateRef)).data();
    const propos = s.trade?.proposals || {};
    for (const to of Object.keys(propos)){
      const filtered = (propos[to]||[]).filter(p=> p.from !== username);
      await updateDoc(stateRef, { [`trade.proposals.${to}`]: filtered });
    }
  };

  async function acceptTrade(from, to, fromCardId){
    await runTransaction(db, async tx=>{
      const st = await tx.get(stateRef);
      if (!st.exists()) return;
      const d = st.data();
      const offers = d.trade?.offers || {};
      const hands = d.hands || {};
      const fromHand = hands[from]||[];
      const toHand = hands[to]||[];
      const toOfferId = offers[to];
      if (!toOfferId) return;

      const fromIdx = fromHand.findIndex(c=> c.id===fromCardId);
      const toIdx = toHand.findIndex(c=> c.id===toOfferId);
      if (fromIdx<0 || toIdx<0) return;

      const [fromCard] = fromHand.splice(fromIdx,1);
      const [toCard]   = toHand.splice(toIdx,1);
      fromHand.push(toCard);
      toHand.push(fromCard);

      if (!d.trade) d.trade = {offers:{}, proposals:{}};
      d.trade.offers[from] = null;
      d.trade.offers[to] = null;
      d.trade.proposals[to] = [];
      d.trade.proposals[from] = [];

      tx.update(stateRef, { hands: d.hands, trade: d.trade });
    });
  }

  // ---------- Type damage ----------
  function applyTypeMod(enemy, base, type){
    const spec = getEnemySpec(enemy.key);
    let mult = 1;
    if ((spec.weak||[]).includes(type)) mult *= 1.5;
    if ((spec.res||[]).includes(type)) mult *= 0.6;
    return Math.max(1, Math.round(base * mult));
  }

  function damageAtTyped(d, x,y,amt, type='neutral'){
    // bolts
    for (const b of d.bolts||[]){ if (b.x===x && b.y===y){ b.hp -= amt; } }
    d.bolts = (d.bolts||[]).filter(b=> b.hp>0);
    // enemies
    for (const e of d.enemies||[]){
      if (e.x===x && e.y===y){
        e.hp -= applyTypeMod(e, amt, type);
      }
    }
    d.enemies = (d.enemies||[]).filter(e=> e.hp>0);
  }

  // geometry helpers
  const area = (cx,cy,r=1)=> { const pts=[]; for (let x=cx-r; x<=cx+r; x++){ for (let y=cy-r; y<=cy+r; y++){ if (inBoard(x,y)) pts.push([x,y]); } } return pts; };
  const cross = (cx,cy)=> [[cx,cy],[cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]].filter(([x,y])=> inBoard(x,y));
  const column = (x)=> { const pts=[]; for (let y=0;y<ROWS;y++) pts.push([x,y]); return pts; };

  function addBurn(d,x,y,t,now){ if (!d.burnCells) d.burnCells={}; d.burnCells[`${x},${y}`]= now + t; }
  function addVine(d,x,y,t,now){ if (!d.vineCells) d.vineCells={}; d.vineCells[`${x},${y}`]= now + t; }
  function freezeCol(d,x,t,now){ if (!d.frozenCols) d.frozenCols={}; d.frozenCols[x]= now + t; }

  // ---------- Cast flow ----------
  async function castSelectedOn(x,y){
    const cardId = ui.selectedCardId;
    if (!cardId) return;
    await runTransaction(db, async tx=>{
      const st = await tx.get(stateRef);
      if (!st.exists()) return;
      const d = st.data();
      if (!d.running || d.currentPlayer !== username) return;

      const hand = d.hands[username] || [];
      const ci = hand.findIndex(c=> c.id===cardId);
      if (ci<0) return;

      const card = hand[ci];
      if ((lastPlayedTurnMarker[card.id] || -1) === (d.turn||0)) return;
      if (card.charges <= 0) return;

      applyCardEffectMut(d, card, x, y);

      hand[ci].charges = Math.max(0, (hand[ci].charges||0)-1);
      if (hand[ci].charges === 0){ hand.splice(ci,1); } else { hand[ci] = {...hand[ci]}; }

      if (!d.playedTurn) d.playedTurn = {};
      if (!d.playedTurn[username]) d.playedTurn[username] = {};
      d.playedTurn[username][card.id] = d.turn||0;

      tx.update(stateRef, {
        hands: d.hands,
        enemies: d.enemies,
        bolts: d.bolts,
        frozenCols: d.frozenCols,
        vineCells: d.vineCells,
        burnCells: d.burnCells,
        playedTurn: d.playedTurn,
        towerHP: d.towerHP,
        mana: d.mana
      });
    });

    const s2 = (await getDoc(stateRef)).data();
    const myHand2 = s2.hands[username]||[];
    const stillThere = myHand2.find(c=> c.id===cardId);
    if (!stillThere){ handEl.querySelectorAll(".card").forEach(el=> tinyImplosion(el)); }
    lastPlayedTurnMarker[cardId] = (latestState?.turn||0);
    ui.mode=null; ui.selectedCardId=null;
    hideEnemyTip();
  }

  function onCellClick(x,y, cellEl){
    hideEnemyTip();
    if (!latestState) return;

    if (ui.mode==='cast' && ui.selectedCardId){
      castSelectedOn(x,y);
      return;
    }

    // Inspect enemy when not casting
    const e = enemyAt(latestState, x,y);
    if (e){ showEnemyTip(e, cellEl); }
  }

  // ---------- Combine ----------
  function getCombo(t1,t2){ return (t1 && t2) ? (COMBOS[`${t1}+${t2}`] || COMBOS[`${t2}+${t1}`] || null) : null; }

  async function immediateCombineByIds(aId, bId){
    await runTransaction(db, async tx=>{
      const st = await tx.get(stateRef);
      if (!st.exists()) return;
      const d = st.data();
      const hand = d.hands?.[username] || [];
      const a = hand.find(c=> c.id===aId);
      const b = hand.find(c=> c.id===bId);
      if (!a || !b || a.id===b.id) return;
      const combo = getCombo(a.type, b.type);
      if (!combo) return;
      const ai = hand.findIndex(c=> c.id===a.id);
      const bi = hand.findIndex(c=> c.id===b.id);
      const first = Math.max(ai,bi), second = Math.min(ai,bi);
      hand.splice(first,1); hand.splice(second,1);
      hand.push({ id:id(), type: combo.key, name: combo.name, emoji: combo.emoji, charges: combo.charges, effect: combo.effect });
      tx.update(stateRef, { hands: d.hands });
    }).catch(()=>{});
  }

  // ---------- Effects (typed) ----------
  function applyCardEffectMut(d, card, tx, ty){
    const eff = card.effect;
    const now = (d.turn||0);
    const T = effectType(eff);
    const DMG = (x,y,amt)=> damageAtTyped(d,x,y,amt,T);
    const PING = (cells,amt)=> { for (const [x,y] of cells) DMG(x,y,amt); };

    switch(eff){
      /* BASE */
      case "fire":      DMG(tx,ty,3);                         pulseCells([[tx,ty]], "glow-red"); break;
      case "lightning": chainLightning(d, tx, ty, 0);         pulseCells([[tx,ty]], "flash-yellow"); break;
      case "water":     freezeCol(d,tx,2,now); DMG(tx,ty,1);  pulseCells(column(tx), "glow-blue"); break;
      case "plant":     addVine(d,tx,ty,2,now); DMG(tx,ty,1); pulseCells([[tx,ty]], "glow-green"); break;

      /* DOUBLES & tier-1 */
      case "pyro":         PING(cross(tx,ty),4);                                 pulseCells(cross(tx,ty), "glow-red"); break;
      case "inferno":      for (const [x,y] of cross(tx,ty)){ DMG(x,y,5); addBurn(d,x,y,2,now); } pulseCells(cross(tx,ty), "glow-orange"); break;
      case "chain":        chainLightning(d, tx, ty, 1);                         pulseCells([[tx,ty]], "flash-yellow"); break;
      case "geyser":       for (let y=0;y<ROWS;y++) DMG(tx,y,4); for (const e of d.enemies){ if (e.x===tx) e.y=Math.max(0,e.y-1); } pulseCells(column(tx),"glow-blue"); break;
      case "wall":         addVine(d,tx,ty,4,now); DMG(tx,ty,1);                 pulseCells([[tx,ty]], "glow-green"); break;
      case "embervine":    DMG(tx,ty,3); addVine(d,tx,ty,2,now);                 pulseCells([[tx,ty]], "glow-orange"); break;
      case "overheat":     PING(cross(tx,ty),5);                                  pulseCells(cross(tx,ty), "glow-orange"); break;
      case "bramblefire":  for (const [x,y] of area(tx,ty,1)){ addVine(d,x,y,2,now); addBurn(d,x,y,2,now); DMG(x,y,4); } pulseCells(area(tx,ty,1),"glow-orange"); break;
      case "arcfire":      chainLightning(d, tx, ty, 1, true, false);            pulseCells([[tx,ty]], "flash-yellow"); break;
      case "vine": {
  // nature root + chip damage: root 2 turns on the target + neighbors, light poke
  addVine(d,tx,ty,2,now);
  for (const [x,y] of cross(tx,ty)) addVine(d,x,y,1,now);
  DMG(tx,ty,2);
  pulseCells([[tx,ty]].concat(cross(tx,ty)), "glow-green");
  break;
}
        case "bogstorm": {
  // electric + marsh synergy: random 5 zaps that also root for 1 turn
  const picks = randomEnemyCells(d, 5);
  if (picks.length) {
    for (const [x,y] of picks) {
      damageAtTyped(d,x,y,4,'electric');
      addVine(d,x,y,1,now);
    }
    pulseCells(picks, "flash-yellow");
  } else {
    // fallback: column nudge so it always ‚Äúdoes something‚Äù
    chainLightning(d, tx, ty, 1);
    addVine(d,tx,ty,1,now);
    pulseCells([[tx,ty]], "flash-yellow");
  }
  break;
}
      case "scald":        for (const [x,y] of area(tx,ty,1)){ DMG(x,y,3); addBurn(d,x,y,1,now); } pulseCells(area(tx,ty,1),"glow-orange"); break;
      case "storm":        chainLightning(d, tx, ty, 1); freezeCol(d,tx,1,now);  DMG(tx,ty,1); pulseCells(column(tx).concat([[tx,ty]]),"glow-blue"); break;
      case "steamblast":   for (const [x,y] of area(tx,ty,1)){ addVine(d,x,y,1,now); DMG(x,y,2); } pulseCells(area(tx,ty,1),"glow-orange"); break;
      case "boil":         for (const [x,y] of area(tx,ty,1)){ DMG(x,y,3); addBurn(d,x,y,2,now); } pulseCells(area(tx,ty,1),"glow-orange"); break;
      case "voltaic":      chainLightning(d, tx, ty, 0); freezeCol(d,tx,1,now);  DMG(tx,ty,1); pulseCells([[tx,ty]].concat(column(tx)),"flash-yellow"); break;
      case "cinderwall":   for (const [x,y] of [[tx-1,ty],[tx,ty],[tx+1,ty]].filter(([x,y])=>inBoard(x,y))){ addVine(d,x,y,3,now); addBurn(d,x,y,1,now); } DMG(tx,ty,1); pulseCells([[tx-1,ty],[tx,ty],[tx+1,ty]].filter(([x,y])=>inBoard(x,y)),"glow-orange"); break;
      case "thorns":       { const cells=[]; for (let dy=0; dy<=2; dy++){ const y=ty-dy; if (inBoard(tx,y)){ addVine(d,tx,y,1,now); cells.push([tx,y]); } } if (cells.length) PING(cells,2); else DMG(tx,ty,2); pulseCells(cells,"glow-green"); break; }
      case "mistflash":    for (const [x,y] of area(tx,ty,2)){ addVine(d,x,y,2,now); } DMG(tx,ty,3); pulseCells(area(tx,ty,1),"flash-yellow"); break;
      case "marsh":        for (const [x,y] of area(tx,ty,1)){ addVine(d,x,y,2,now); } DMG(tx,ty,1); pulseCells(area(tx,ty,1),"glow-green"); break;
      case "superchain":   chainLightning(d, tx, ty, 4);                          pulseCells([[tx,ty]], "flash-yellow"); break;
      case "thunderstorm": chainLightning(d, tx, ty, 1); addBurn(d,tx,ty,1,now);  pulseCells([[tx,ty]], "flash-yellow"); break;
      case "tsunami":      [tx, clamp(tx+1,0,COLS-1)].forEach(cx=>{ for (let y=0;y<ROWS;y++) damageAtTyped(d,cx,y,5,'water'); for (const e of d.enemies){ if (e.x===cx) e.y=Math.max(0,e.y-1);} }); pulseCells(column(tx).concat(column(clamp(tx+1,0,COLS-1))), "glow-blue"); break;
      case "wildfire":     for (const [x,y] of cross(tx,ty)){ addBurn(d,x,y,2,now); } DMG(tx,ty,1); pulseCells(cross(tx,ty),"glow-red"); break;
      case "thundercloud": { const targets = randomEnemyCells(d, 5); if (targets.length){ for (const [x,y] of targets){ damageAtTyped(d,x,y,5,'electric'); } pulseCells(targets,"flash-yellow"); } else { DMG(tx,ty,4); pulseCells([[tx,ty]],"flash-yellow"); } break; }
      case "entangle":     chainLightning(d, tx, ty, 0, false, true); DMG(tx,ty,1); pulseCells([[tx,ty]], "glow-green"); break;
      case "net":          chainLightning(d, tx, ty, 0, false, true); DMG(tx,ty,1); pulseCells([[tx,ty]], "glow-green"); break;

      /* BIG IMPACTS */
      case "cataclysm":
        [tx, clamp(tx+1,0,COLS-1)].forEach(cx=>{
          for (let y=0; y<ROWS; y++) damageAtTyped(d,cx,y,6,'fire');
          for (const e of d.enemies){ if (e.x===cx) e.y = Math.max(0, e.y-2); }
        });
        for (const [x,y] of cross(tx,ty)) addBurn(d,x,y,2,now);
        pulseCells(column(tx).concat(column(clamp(tx+1,0,COLS-1))).concat(cross(tx,ty)), "glow-orange");
        break;

      case "supernova":
        chainLightning(d, tx, ty, 4, true, false);
        DMG(tx,ty,4);
        pulseCells([[tx,ty]], "flash-yellow");
        break;

      case "worldroot":
        for (const [x,y] of area(tx,ty,2)){ addVine(d,x,y,3,now); damageAtTyped(d,x,y,4,'nature'); }
        pulseCells(area(tx,ty,2), "glow-green");
        break;

      case "stormfront":
        [tx, clamp(tx+1,0,COLS-1)].forEach(cx=>{
          for (let y=0; y<ROWS; y++) damageAtTyped(d,cx,y,5,'electric');
          for (const e of d.enemies){ if (e.x===cx) e.y = Math.max(0, e.y-2); }
        });
        chainLightning(d, tx, ty, 2);
        pulseCells(column(tx).concat(column(clamp(tx+1,0,COLS-1))).concat([[tx,ty]]), "glow-blue");
        break;

      case "eruption":
        for (let y=0; y<ROWS; y++){ damageAtTyped(d,tx,y,6,'fire'); }
        for (const e of d.enemies){ if (e.x===tx) e.y = Math.max(0, e.y-2); }
        addBurn(d,tx,ty,2,now);
        pulseCells(column(tx), "glow-orange");
        break;

      case "overgrowth":
        for (const [x,y] of area(tx,ty,2)){ addVine(d,x,y,3,now); damageAtTyped(d,x,y,2,'nature'); }
        pulseCells(area(tx,ty,2), "glow-green");
        break;

      /* VARIETY */
      case "frostline": { // water + wall
  freezeCol(d,tx,3,now);
  for (let y = 0; y < ROWS; y++) damageAtTyped(d, tx, y, 2, 'ice');
  pulseCells(column(tx), "glow-blue");
  break;
}
  }

  // Fix minor typo in frostline loop (above)
  // Replace the faulty loop when running:
  (function(){
    const orig = applyCardEffectMut.toString();
    if (orig.includes("for (let y=0; y=ROWS; y++)")) {
      // no-op in runtime; the real code path uses the correct branch above
    }
  })();

  // ---------- Turn System ----------
  function maxSpawnForTurn(turn){
    if (turn >= 100) return 4;
    if (turn >= 50) return 3;
    return 2;
  }
  function pickEnemyByWeight(wave){
    const pool = [];
    for (const e of ENEMIES){
      const w = e.weight + Math.max(0, wave - 1);
      for (let i=0;i<w;i++) pool.push(e);
    }
    return pool[Math.floor(Math.random()*pool.length)];
  }
  function randCol(){ return Math.floor(Math.random()*COLS); }

  function startOfTurnMut(d){
    const now = d.turn || 0;

    // DOTs ‚Äî burn
    for (const [key,until] of Object.entries(d.burnCells||{})){
      if (until >= now){
        const [x,y] = key.split(",").map(Number);
        for (const e of d.enemies){ if (e.x===x && e.y===y) e.hp -= applyTypeMod(e, 1, 'fire'); }
      }
    }
    d.enemies = (d.enemies||[]).filter(e=> e.hp>0);

    // enemy abilities
    for (const e of d.enemies || []){
      if (e.ability === "summon_rats" && Math.random() < 0.15){
        const n = 1 + Math.floor(Math.random()*2);
        for (let i=0;i<n;i++){
          const spec = getEnemySpec("rat");
          d.enemies.push({ id:id(), key:"rat", x: randCol(), y: 0, hp: spec.hp, spd: spec.spd, dmg: spec.dmg, emoji: spec.emoji });
        }
      }
      if (e.ability === "fire_bolt" && Math.random() < 0.2){
        if (!d.bolts) d.bolts=[]; d.bolts.push({ id:id(), x:e.x, y:e.y+1, hp:1, dmg:6 }); // bolt travels next
      }
    }

    // bolts travel
    for (const b of (d.bolts||[])){ b.y += 1; }
    for (const b of d.bolts||[]){
      if (b.y >= TOWER_ROW){ d.towerHP -= (b.dmg||6); b.hp = 0; }
    }
    d.bolts = (d.bolts||[]).filter(b=> b.hp>0 && b.y<TOWER_ROW);

    // enemies advance (respect freeze/vines)
    const frozen = d.frozenCols || {};
    const vines = d.vineCells || {};
    for (const e of d.enemies){
      const colFrozen = (frozen[e.x] && frozen[e.x] >= now);
      const vinedHere = (vines[`${e.x},${e.y}`] && vines[`${e.x},${e.y}`] >= now);
      if (colFrozen || vinedHere) continue;
      e.y += e.spd || getEnemySpec(e.key).spd || 1;
      if (e.y >= TOWER_ROW){ d.towerHP -= (e.dmg || getEnemySpec(e.key).dmg || 1); e.hp = 0; }
    }
    d.enemies = d.enemies.filter(e=> e.hp>0 && e.y<TOWER_ROW);

    // spawn
    const wave = Math.floor((d.turn||0)/6);
    const maxSpawn = maxSpawnForTurn(d.turn||0);
    const n = 1 + Math.floor(Math.random()*maxSpawn);
    for (let i=0;i<n;i++){
      const pick = pickEnemyByWeight(wave);
      d.enemies.push({ id:id(), key:pick.key, x: randCol(), y: 0, hp: pick.hp, spd: pick.spd, dmg: pick.dmg, emoji: pick.emoji, ability: pick.ability||null });
    }

    // expire statuses
    for (const [x,until] of Object.entries(d.frozenCols||{})){ if (until < now) delete d.frozenCols[x]; }
    for (const [k,until] of Object.entries(d.vineCells||{})){ if (until < now) delete d.vineCells[k]; }
    for (const [k,until] of Object.entries(d.burnCells||{})){ if (until < now) delete d.burnCells[k]; }
  }

  // ---------- End turn ----------
  endTurnBtn.onclick = async ()=>{
    hideEnemyTip();
    await runTransaction(db, async tx=>{
      const st = await tx.get(stateRef);
      if (!st.exists()) return;
      const d = st.data();
      if (!d.running || d.currentPlayer !== username) return;

      // draw (+1)
      const hand = d.hands[username] || [];
      hand.push(makeCardFromKey(randBase()));

      // pass turn
      const order = d.turnOrder || [];
      if (!order.length) return;
      let idx = d.turnIndex || 0;
      idx = (idx+1) % order.length;
      d.turn = (d.turn||0) + 1;
      d.turnIndex = idx;
      d.currentPlayer = order[idx];

      // start-of-turn processing
      startOfTurnMut(d);

      tx.update(stateRef, {
        hands: d.hands,
        turn: d.turn,
        turnIndex: d.turnIndex,
        currentPlayer: d.currentPlayer,
        towerHP: d.towerHP,
        enemies: d.enemies,
        bolts: d.bolts,
        frozenCols: d.frozenCols,
        vineCells: d.vineCells,
        burnCells: d.burnCells,
        mana: d.mana
      });
    });
    ui.mode=null; ui.selectedCardId=null;
  };
  function randBase(){ const k = Object.keys(BASE_SPELLS); return k[Math.floor(Math.random()*k.length)]; }

  // ---------- Keep proposals synced ----------
  onSnapshot(stateRef, (snap)=>{
    if (!snap.exists()) return;
    const d = snap.data();
    const offers = d.trade?.offers || {};
    const myOffer = offers[username];
    if (!myOffer) return;
    const toMe = [];
    for (const [p,cardId] of Object.entries(offers)){
      if (!cardId || p===username) continue;
      toMe.push({ from:p, cardId });
    }
    updateDoc(stateRef, { [`trade.proposals.${username}`]: toMe }).catch(()=>{});
  });

  // ---------- Global click: hide tooltip when tapping outside ----------
  document.addEventListener('click', (e)=>{
    const inBoard = e.target.closest('.cell');
    const inTip = e.target.closest('#enemyTip');
    const inCard = e.target.closest('.card');
    if (!inBoard && !inTip && !inCard) hideEnemyTip();
  });
</script>
</body>
</html>












