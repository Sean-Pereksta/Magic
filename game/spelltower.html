<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>üßô‚Äç‚ôÇÔ∏è Spell Tower ‚Äî 8P Co-op</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<style>
  :root{
    --bg:#0b1014; --panel:#0e1726; --ink:#e6edf3; --muted:#93a4b7; --edge:#1f2a44;
    --good:#22c55e; --warn:#f59e0b; --bad:#ef4444; --accent:#7c3aed;
    --radius:14px; --cell:38px; --gap:6px; --hand-h:22vh; --card-h:148px;
  }
  @media (max-width: 540px){
    :root{ --cell:32px; --hand-h:22vh; --card-h:152px; }
  }
  *{box-sizing:border-box}
  html,body{min-height:100%}
  body{
    margin:0; font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Arial; color:var(--ink);
    background:radial-gradient(1200px 600px at 50% -200px, #4c1d95 0%, #312e81 55%, #0b1014 100%) fixed;
    overflow:auto;
  }
  .shell{
    min-height:100dvh; height:auto;
    max-width:1100px; margin:0 auto; padding:8px;
    display:grid; gap:8px;
    grid-template-rows:auto auto auto auto;
    overflow:visible;
  }
  header{
    position:sticky; top:0; z-index:5;
    display:flex; align-items:center; justify-content:space-between; gap:8px; flex-wrap:wrap;
    padding:6px 8px; background:rgba(14,23,38,.72); border:1px solid rgba(255,255,255,.08);
    border-radius:12px; backdrop-filter: blur(6px);
  }
  .row{display:flex; align-items:center; gap:8px; flex-wrap:wrap}
  .badge{display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.06); font-weight:800}
  .stat{display:flex; gap:6px; align-items:center; padding:4px 8px; border-radius:10px; background:#111827; border:1px solid #1f2937; font-size:.92rem}
  .bar{height:8px; width:96px; background:#0f172a; border-radius:999px; overflow:hidden; border:1px solid #1f2937}
  .bar > i{display:block; height:100%; background:linear-gradient(90deg,#10b981,#22c55e,#84cc16); width:0%}
  .dangerbar > i{background:linear-gradient(90deg,#f97316,#ef4444)}
  .tiny{font-size:.9rem; opacity:.85}

  .btn{
    cursor:pointer; border:1px solid #2a3757; background:#0c1422; color:var(--ink);
    border-radius:10px; padding:8px 10px; font-weight:800; font-size:.95rem;
    width:auto; min-height:40px; touch-action:manipulation;
  }
  .btn:hover{ background:#101a2b }
  .danger{border-color:#7f1d1d; color:#fecaca}
  .ok{border-color:#14532d; color:#bbf7d0}
  .disabled{opacity:.6; pointer-events:none}

  .board-card, .trade-card, .hand-card{
    background:rgba(14,23,38,.7); border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:6px;
    box-shadow:0 10px 25px rgba(0,0,0,.18); backdrop-filter: blur(6px);
  }

  .board-wrap{
    display:flex; justify-content:center;
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    touch-action:pan-x pan-y;
    max-height:none;
  }
  .board{
    display:grid; grid-template-columns: repeat(4, var(--cell)); grid-auto-rows: var(--cell);
    gap:var(--gap); padding:6px; border-radius:10px; background:#0a1220; border:1px solid #1f2a44;
  }
  .cell{
    width:var(--cell); height:var(--cell); display:grid; place-items:center; font-size:18px; line-height:1;
    background:#0b1320; border:1px solid #1f2a44; border-radius:8px; position:relative; overflow:hidden;
  }
  .tower{filter:drop-shadow(0 1px 4px rgba(0,0,0,.4))}
  .hpbar{position:absolute; top:2px; left:2px; right:2px; height:6px; background:#1f2937; border-radius:6px; overflow:hidden}
  .hpbar > i{display:block; height:100%; width:100%; background:linear-gradient(90deg,#22c55e,#84cc16)}
  .frozen{ box-shadow: inset 0 0 0 2px rgba(125,211,252,.7); background:#0b2333 }
  .vine{ box-shadow: inset 0 0 0 2px rgba(34,197,94,.7); background:#0d2317 }
  .burn{ box-shadow: inset 0 0 0 2px rgba(239,68,68,.7); background:#2b0f12 }

  .glow-red{animation: glowRed .9s ease}
  @keyframes glowRed{ 0%{box-shadow:0 0 0 0 rgba(239,68,68,.8)} 100%{box-shadow:0 0 0 18px rgba(239,68,68,0)} }
  .flash-yellow{animation: flashY .7s ease}
  @keyframes flashY{ 0%{box-shadow:0 0 0 0 rgba(250,204,21,.85)} 100%{box-shadow:0 0 0 18px rgba(250,204,21,0)} }
  .implode{ position:absolute; inset:0; display:grid; place-items:center; pointer-events:none; animation: impl .45s ease forwards; }
  @keyframes impl{ 0%{transform:scale(1); opacity:.95} 100%{transform:scale(.1); opacity:0} }

  .glow-blue{animation: glowBlue .9s ease}
  @keyframes glowBlue{ 0%{box-shadow:0 0 0 0 rgba(59,130,246,.9)} 100%{box-shadow:0 0 0 18px rgba(59,130,246,0)} }
  .glow-green{animation: glowGreen .9s ease}
  @keyframes glowGreen{ 0%{box-shadow:0 0 0 0 rgba(34,197,94,.9)} 100%{box-shadow:0 0 0 18px rgba(34,197,94,0)} }
  .glow-orange{animation: glowOrange .9s ease}
  @keyframes glowOrange{ 0%{box-shadow:0 0 0 0 rgba(245,158,11,.9)} 100%{box-shadow:0 0 0 18px rgba(245,158,11,0)} }

  .trade-grid{ display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center; }
  .trade-left{display:flex; align-items:center; gap:8px; flex-wrap:nowrap; overflow-x:auto; overflow-y:hidden; -webkit-overflow-scrolling:touch;}
  .trade-slot{
    min-width:78px; min-height:36px; display:flex; align-items:center; justify-content:center;
    border:1px dashed #37517a; border-radius:10px; padding:4px 6px; background:#0b1320; font-size:.95rem;
  }
  .proposal-row{display:flex; gap:6px; flex-wrap:nowrap; overflow-x:auto; overflow-y:hidden; -webkit-overflow-scrolling:touch;}

  .hand-card{ display:grid; gap:6px; }
  .hand-head{display:flex; justify-content:space-between; align-items:center}

  .hand-scroll{
    height: calc(var(--card-h) + 16px);
    overflow-x: auto;
    overflow-y: hidden;
    -webkit-overflow-scrolling:touch;
    border:1px solid #1f2a44; border-radius:10px; padding:6px; background:#0a1220;
  }
  .hand{ display:flex; flex-wrap:nowrap; gap:6px; }

  .card{
    min-width:92px; max-width:120px; width:calc(50% - 9px);
    border:1px solid #2a3757; background:#111b2c; color:#e6edf3;
    border-radius:12px; padding:6px; display:grid; gap:6px;
    grid-template-rows:auto 1fr auto; min-height:var(--card-h);
    position:relative;
  }
  @media (min-width:560px){ .card{ width:110px; } }
  .card .name{font-weight:800; font-size:1rem; line-height:1.05; word-break:break-word}
  .charges{display:flex; gap:4px; align-items:center}
  .pip{width:10px; height:10px; border-radius:50%; background:#10b981}
  .pip.off{background:#374151}
  .combo-hint{
    outline:2px solid #facc15;
    box-shadow:0 0 0 3px rgba(250,204,21,.25), inset 0 0 0 9999px rgba(250,204,21,.06);
  }
  .muted{color:var(--muted)}
  .btn-top{margin-bottom:1px}
  .btn-bottom{margin-top:1px}
  .super-tag{
    position:absolute; top:4px; right:4px;
    font-size:.7rem; padding:2px 4px;
    border-radius:999px; background:#7c2d12; color:#fed7aa; border:1px solid #9a3412;
  }

  footer{display:flex; align-items:center; justify-content:space-between; gap:8px; flex-wrap:wrap}
  .fsbtn{margin-left:4px}

  #enemyTip{
    position:fixed; z-index:20; max-width:260px;
    background:#0e1726; border:1px solid #2a3757; border-radius:10px; padding:8px;
    box-shadow:0 12px 30px rgba(0,0,0,.35); display:none;
  }
  #enemyTip .title{font-weight:800; margin-bottom:4px}
  #enemyTip .line{font-size:.92rem; color:#cbd5e1}

  .zoomrow{display:flex; align-items:center; gap:8px; flex-wrap:wrap}
  .zoomrow input{ width:160px; }
</style>
</head>
<body>
<div class="shell">
  <header>
    <div class="row">
      <span class="badge">üßô‚Äç‚ôÇÔ∏è Spell Tower</span>
      <span id="hostBadge" class="badge" style="display:none">üëë Host</span>
      <span id="playersBadge" class="badge">üë• 0/8</span>
    </div>
    <div class="row">
      <div class="stat" title="Tower Health">
        üè∞
        <div class="bar dangerbar"><i id="hpFill"></i></div>
        <b id="hpText">50/50</b>
      </div>
      <div class="stat" title="Shared Mana">
        ‚ú®
        <div class="bar"><i id="manaFill"></i></div>
        <b id="manaText">0/0</b>
      </div>
      <div class="stat tiny" title="Turn / Wave / Difficulty">
        üîÅ <b id="turnText">‚Äî</b>
      </div>
      <div class="zoomrow">
        <span class="tiny">Zoom</span>
        <input id="zoomRange" type="range" min="24" max="64" step="2" />
        <button id="fsBtn" class="btn fsbtn" style="width:auto;min-height:auto;padding:6px 9px">‚õ∂ Full</button>
        <button id="leaveBtn" class="btn danger" style="width:auto;min-height:auto;padding:6px 9px">üè† Leave</button>
      </div>
    </div>
  </header>

  <section class="board-card" style="min-height:140px">
    <div class="board-wrap">
      <div id="board" class="board" aria-label="Battlefield"></div>
    </div>
    <p class="tiny muted" style="margin:6px 4px 0 4px">Tip: select a spell, then tap the board. Drag to scroll if the board doesn‚Äôt fit.</p>
  </section>

  <section class="trade-card">
    <div class="trade-grid">
      <div class="trade-left">
        <div>üîÑ Trade Block:</div>
        <div id="myTrade" class="trade-slot" title="Place a card here to offer">‚Äî empty ‚Äî</div>
        <button id="clearTradeBtn" class="btn" style="width:auto;min-height:auto;padding:6px 9px">Clear</button>
      </div>
      <div>
        <div class="tiny muted">Proposals to you:</div>
        <div id="proposals" class="proposal-row"></div>
      </div>
    </div>
  </section>

  <section class="hand-card">
    <div class="hand-head">
      <div class="tiny">Your Hand</div>
      <button id="tradeHereBtn" class="btn">Put Selected ‚Üí Trade Block</button>
    </div>
    <div class="hand-scroll">
      <div id="hand" class="hand" aria-label="Your spell cards"></div>
    </div>
  </section>

  <footer>
    <div class="row">
      <button id="endTurnBtn" class="btn ok">End Turn (+1 card)</button>
    </div>
    <div class="tiny muted">Game: <code id="gidTxt"></code> ‚Ä¢ Player: <code id="unameTxt"></code></div>
  </footer>
</div>

<div id="enemyTip">
  <div class="title" id="tipTitle">Enemy</div>
  <div class="line" id="tipHP">HP ‚Äî</div>
  <div class="line" id="tipWeak">Weak: ‚Äî</div>
  <div class="line" id="tipRes">Resist: ‚Äî</div>
  <div class="line" id="tipAbility">Ability: ‚Äî</div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import { getFirestore, doc, getDoc, setDoc, updateDoc, runTransaction, onSnapshot } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

  // ---------- Firebase ----------
  const firebaseConfig = {
    apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
    authDomain: "bible-game-246c0.firebaseapp.com",
    projectId: "bible-game-246c0",
    storageBucket: "bible-game-246c0.appspot.com",
    messagingSenderId: "959619818996",
    appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // ---------- DOM refs for game/player labels ----------
  const gidTxt = document.getElementById("gidTxt");
  const unameTxt = document.getElementById("unameTxt");

  // ---------- URL params ----------
  const params = new URLSearchParams(location.search);
  const gameId = params.get("gameId") || "";
  const username = (params.get("username") || "").trim();
  if (gidTxt) gidTxt.textContent = gameId;
  if (unameTxt) unameTxt.textContent = username;
  if (!gameId || !username) { alert("Missing gameId/username (launch from lobby)."); }

  // ---------- Refs ----------
  const lobbyRef = doc(db, "lobbies", gameId);
  const stateRef = doc(db, "spelltower", gameId);

  // ---------- Types ----------
  const TYPES = {
    fire: "üî•", water: "üíß", ice: "üßä", electric: "‚ö°",
    nature: "üåø", earth: "ü™®", arcane: "‚ú®", shadow:"üåë", neutral:"‚öîÔ∏è"
  };
  function effectType(effect){
    const map = {
      fire:'fire', pyro:'fire', inferno:'fire', scald:'fire', boil:'fire', wildfire:'fire', cataclysm:'fire', fireline:'fire', eruption:'fire',
      water:'ice', steam:'water', geyser:'water', tsunami:'water', frostline:'ice', shockpush:'electric',
      plant:'nature', vine:'nature', wall:'earth', cinderwall:'fire', thorns:'nature', marsh:'nature', overgrowth:'nature', worldroot:'nature',
      lightning:'electric', chain:'electric', superchain:'electric', thunderstorm:'electric', thundercloud:'electric', voltaic:'electric', arcfire:'electric', mistflash:'electric', storm:'electric', supernova:'electric', stormfront:'electric', battery:'electric', bogstorm:'electric',
      steamblast:'water', entangle:'nature', net:'nature',
      manafont:'arcane', overcharge:'electric', focus:'arcane', sprout:'nature',
      armageddon:'fire', genesis:'nature',
      default:'neutral'
    };
    return map[effect] || map.default;
  }

  // ---------- Game constants ----------
  const COLS = 4, ROWS = 10;
  const TOWER_ROW = ROWS - 1;
  const START_HP = 50;
  const TURNS_PER_WAVE = 6;

  // ---------- Enemies ----------
  const ENEMIES = [
    { key:"rat",    name:"Cave Rat",     hp:3,  spd:2, dmg:1, emoji:"üêÄ",  weight:1,  ability:null,        weak:['fire'], res:[] },
    { key:"imp",    name:"Ember Imp",    hp:5,  spd:2, dmg:1, emoji:"üòà",  weight:2,  ability:null,        weak:['water','ice'], res:['fire'] },
    { key:"orc",    name:"Orc",          hp:8,  spd:1, dmg:2, emoji:"üëπ",  weight:3,  ability:null,        weak:['electric'], res:['earth'] },
    { key:"trol",   name:"Troll",        hp:14, spd:1, dmg:5, emoji:"üêó",  weight:4,  ability:null,        weak:['fire'], res:['nature'] },
    { key:"warg",   name:"Warg",         hp:10, spd:2, dmg:2, emoji:"üê∫",  weight:4,  ability:null,        weak:['electric'], res:['nature'] },
    { key:"mage",   name:"Dark Mage",    hp:8,  spd:1, dmg:2, emoji:"üßô‚Äç‚ôÇÔ∏è",  weight:5,  ability:"summon_rats",weak:['nature'], res:['ice'] },
    { key:"dlord",  name:"Demon Lord",   hp:16, spd:1, dmg:3, emoji:"üòàüî•",weight:6,  ability:"fire_bolt", weak:['water','ice'], res:['fire'] },
    { key:"golem",  name:"Stone Golem",  hp:20, spd:1, dmg:4, emoji:"üóø",  weight:7,  ability:null,        weak:['water','nature'], res:['earth','electric'] },
    { key:"slime",  name:"Slime",        hp:9,  spd:2, dmg:1, emoji:"ü¶†",  weight:4,  ability:null,        weak:['electric','ice'], res:['water','nature'] },
    { key:"specter",name:"Specter",      hp:7,  spd:2, dmg:2, emoji:"üëª",  weight:5,  ability:null,        weak:['electric','fire'], res:['water','nature'] },
    { key:"slime_baby", name:"Baby Slime", hp:4, spd:2, dmg:1, emoji:"üß´", weight:0, ability:null, weak:['electric','ice'], res:['water','nature'] },

    // Mini-boss & big boss
    { key:"ogre",   name:"Ogre Warlord",   hp:32, spd:1, dmg:6, emoji:"üßå", weight:0, ability:"shockwave",     weak:['water','electric'], res:['fire','nature'] },
    { key:"dragon", name:"Ancient Dragon", hp:60, spd:1, dmg:10,emoji:"üêâ", weight:0, ability:"dragon_breath", weak:['water','ice'],    res:['fire','electric'] },
  ];

  // ---------- Base spells ----------
  const BASE_SPELLS = {
    fire:   { name:"Fire",      emoji:"üî•", charges:3, cost:0, effect:"fire" },
    water:  { name:"Water",     emoji:"üíß", charges:3, cost:0, effect:"water" },
    plant:  { name:"Plant",     emoji:"üåø", charges:3, cost:0, effect:"plant" },
    light:  { name:"Lightning", emoji:"‚ö°", charges:3, cost:0, effect:"lightning" },
  };

  // ---------- Combos ----------
  const COMBOS = {
    "fire+fire":        { key:"pyro",     name:"Pyro",        emoji:"üî•üî•",    charges:3, effect:"pyro" },
    "pyro+pyro":        { key:"inferno",  name:"Inferno",     emoji:"üî•üî•üî•",  charges:3, effect:"inferno" },
    "fire+water":       { key:"steam",    name:"Steam",       emoji:"üí®",      charges:3, effect:"steam" },
    "water+plant":      { key:"vine",     name:"Vine",        emoji:"ü™¥",      charges:3, effect:"vine" },
    "light+light":      { key:"chain",    name:"Chain",       emoji:"‚ö°‚ö°",     charges:3, effect:"chain" },
    "water+water":      { key:"geyser",   name:"Geyser",      emoji:"ü´ß",      charges:3, effect:"geyser" },
    "plant+plant":      { key:"wall",     name:"Wall",        emoji:"üß±",      charges:3, effect:"wall" },
    "fire+plant":       { key:"embervine",name:"Embervine",   emoji:"üî•ü™¥",    charges:3, effect:"embervine" },
    "fire+light":       { key:"overheat", name:"Overheat",    emoji:"üî•‚ö°",    charges:3, effect:"overheat" },
    "fire+vine":        { key:"bramblefire",name:"Bramblefire",emoji:"üåøüî•",  charges:3, effect:"bramblefire" },
    "fire+chain":       { key:"arcfire",  name:"Arc Fire",    emoji:"‚ö°üî•",    charges:3, effect:"arcfire" },
    "fire+steam":       { key:"scald",    name:"Scald",       emoji:"üí®üî•",    charges:3, effect:"scald" },
    "water+light":      { key:"storm",    name:"Storm",       emoji:"‚õàÔ∏è",      charges:3, effect:"storm" },
    "water+pyro":       { key:"steamblast",name:"Steam Blast",emoji:"üí®üí•",    charges:3, effect:"steamblast" },
    "water+inferno":    { key:"boil",     name:"Boil",        emoji:"üåã",      charges:3, effect:"boil" },
    "water+chain":      { key:"voltaic",  name:"Voltaic",     emoji:"‚ö°üíß",    charges:3, effect:"voltaic" },
    "plant+pyro":       { key:"cinderwall",name:"Cinder Wall",emoji:"üß±üî•",    charges:3, effect:"cinderwall" },
    "plant+light":      { key:"thorns",   name:"Thorns",      emoji:"üåµ",      charges:3, effect:"thorns" },
    "plant+steam":      { key:"marsh",    name:"Marsh",       emoji:"ü™µüíß",    charges:3, effect:"marsh" },
    "light+pyro":       { key:"superchain",name:"Super Chain",emoji:"‚ö°‚ö°‚ö°",    charges:3, effect:"superchain" },
    "light+inferno":    { key:"thunderstorm",name:"Thunderstorm",emoji:"üå©Ô∏è",  charges:3, effect:"thunderstorm" },
    "light+steam":      { key:"mistflash",name:"Mistflash",   emoji:"üí®‚ö°",    charges:3, effect:"mistflash" },
    "light+vine":       { key:"net",      name:"Net",         emoji:"üï∏Ô∏è",     charges:3, effect:"net" },
    "steam+steam":      { key:"tsunami",  name:"Tsunami",     emoji:"üåä",      charges:3, effect:"tsunami" },
    "pyro+vine":        { key:"wildfire", name:"Wildfire",    emoji:"üî•üåø",    charges:3, effect:"wildfire" },
    "chain+steam":      { key:"thundercloud",name:"Thundercloud",emoji:"üåßÔ∏è‚ö°",charges:3, effect:"thundercloud" },
    "chain+vine":       { key:"entangle", name:"Entangle",    emoji:"‚ö°ü™¢",    charges:3, effect:"entangle" },

    "inferno+tsunami":  { key:"cataclysm", name:"Cataclysm",  emoji:"üî•üåä",    charges:2, effect:"cataclysm" },
    "superchain+inferno":{key:"supernova", name:"Supernova",  emoji:"üí•‚ö°",    charges:2, effect:"supernova" },
    "wall+entangle":    { key:"worldroot", name:"Worldroot",  emoji:"üåøüß±",    charges:2, effect:"worldroot" },
    "thunderstorm+tsunami":{key:"stormfront",name:"Stormfront",emoji:"üå©Ô∏èüåä",  charges:2, effect:"stormfront" },
    "boil+geyser":      { key:"eruption",  name:"Eruption",   emoji:"üåãü´ß",    charges:2, effect:"eruption" },
    "marsh+thorns":     { key:"overgrowth",name:"Overgrowth", emoji:"üåøüåø",    charges:2, effect:"overgrowth" },

    "water+wall":       { key:"frostline", name:"Frostline",  emoji:"‚ùÑÔ∏èüß±",    charges:3, effect:"frostline" },
    "chain+wall":       { key:"battery",   name:"Battery",    emoji:"‚ö°üîã",     charges:3, effect:"battery" },
    "geyser+chain":     { key:"shockpush", name:"Shockpush",  emoji:"‚ö°ü´ß",     charges:2, effect:"shockpush" },
    "wall+pyro":        { key:"fireline",  name:"Fireline",   emoji:"üî•üß±",     charges:2, effect:"fireline" },
    "light+marsh":      { key:"bogstorm",  name:"Bogstorm",   emoji:"‚ö°üå´Ô∏è",     charges:2, effect:"bogstorm" },

    "fire+geyser":      { key:"steamburst",name:"Steamburst", emoji:"üí•ü´ß",     charges:3, effect:"steamblast" },
    "vine+wall":        { key:"hedge",     name:"Hedge",      emoji:"üåøüß±",     charges:3, effect:"wall" },
    "chain+pyro":       { key:"ionflare",  name:"Ion Flare",  emoji:"‚ö°üî•",     charges:3, effect:"arcfire" },
    "steam+vine":       { key:"sauna",     name:"Sauna",      emoji:"üí®üåø",     charges:3, effect:"marsh" },
    "steam+chain":      { key:"stormsteam",name:"Stormsteam", emoji:"üí®‚ö°",     charges:3, effect:"mistflash" },
    "vine+thorns":      { key:"bramble",   name:"Bramble",    emoji:"ü™µüåµ",     charges:3, effect:"thorns" },
    "wall+wall":        { key:"bastion",   name:"Bastion",    emoji:"üß±üß±",     charges:3, effect:"wall" },
    "steam+pyro":       { key:"flashboil", name:"Flashboil",  emoji:"üí®üî•",     charges:3, effect:"boil" },
    "vine+tsunami":     { key:"kelpstorm", name:"Kelpstorm",  emoji:"üåøüåä",     charges:3, effect:"marsh" },

    /* economy & support */
    "steam+wall":       { key:"manafont",   name:"Mana Font",    emoji:"üîÆ",      charges:2, effect:"manafont" },
    "battery+steam":    { key:"overcharge", name:"Overcharge",   emoji:"‚ö°üîÅ",    charges:2, effect:"overcharge" },
    "wall+chain":       { key:"focus",      name:"Focus Ward",   emoji:"üß±‚ú®",    charges:2, effect:"focus" },
    "marsh+wall":       { key:"sprout",     name:"Sprout",       emoji:"üå±üß±",    charges:2, effect:"sprout" },

    /* super spells */
    "cataclysm+stormfront": { key:"armageddon", name:"Armageddon",    emoji:"‚òÑÔ∏èüî•",  charges:4, effect:"armageddon", super:true },
    "supernova+worldroot":  { key:"genesis",    name:"Genesis Pulse", emoji:"üååüåø",  charges:4, effect:"genesis",    super:true }
  };

  // ---------- DOM ----------
  const boardEl = document.getElementById("board");
  const handEl = document.getElementById("hand");
  const myTradeEl = document.getElementById("myTrade");
  const proposalsEl = document.getElementById("proposals");
  const hostBadge = document.getElementById("hostBadge");
  const playersBadge = document.getElementById("playersBadge");
  const hpFill = document.getElementById("hpFill");
  const hpText = document.getElementById("hpText");
  const manaFill = document.getElementById("manaFill");
  const manaText = document.getElementById("manaText");
  const turnText = document.getElementById("turnText");
  const endTurnBtn = document.getElementById("endTurnBtn");
  const tradeHereBtn = document.getElementById("tradeHereBtn");
  const clearTradeBtn = document.getElementById("clearTradeBtn");
  const leaveBtn = document.getElementById("leaveBtn");
  const fsBtn = document.getElementById("fsBtn");
  const zoomRange = document.getElementById("zoomRange");

  const enemyTip = document.getElementById("enemyTip");
  const tipTitle = document.getElementById("tipTitle");
  const tipHP = document.getElementById("tipHP");
  const tipWeak = document.getElementById("tipWeak");
  const tipRes = document.getElementById("tipRes");
  const tipAbility = document.getElementById("tipAbility");

  // ---------- Zoom ----------
  const cssRoot = document.documentElement;
  const getCell = ()=> parseInt(getComputedStyle(cssRoot).getPropertyValue('--cell')) || 38;
  zoomRange.value = String(getCell());
  zoomRange.addEventListener('input', (e)=>{
    const v = parseInt(e.target.value,10);
    cssRoot.style.setProperty('--cell', v+'px');
  });

  // ---------- Basic actions ----------
  leaveBtn.onclick = ()=> { location.href = `/?username=${encodeURIComponent(username)}`; };
  fsBtn.onclick = async ()=>{
    const el = document.documentElement;
    try{
      if (!document.fullscreenElement) { await el.requestFullscreen?.(); }
      else { await document.exitFullscreen?.(); }
    }catch(e){ window.scrollTo({top:0,behavior:"smooth"}); }
  };

  // ---------- Local UI state ----------
  let isHost = false;
  let ui = { mode:null, selectedCardId:null };
  let lastPlayedTurnMarker = {};
  let latestState = null;

  // ---------- Board ----------
  function buildBoard(){
    boardEl.innerHTML = "";
    for(let r=0; r<ROWS; r++){
      for(let c=0; c<COLS; c++){
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.dataset.x = c; cell.dataset.y = r;
        if (r === TOWER_ROW) { cell.classList.add("tower"); cell.title = "Your Tower"; cell.textContent = "üè∞"; }
        cell.addEventListener("click", ()=> onCellClick(c,r, cell));
        boardEl.appendChild(cell);
      }
    }
  }
  buildBoard();

  // ---------- Helpers ----------
  const id = ()=> Math.random().toString(36).slice(2,9);
  const clamp = (n,min,max)=> Math.max(min, Math.min(max,n));
  const inBoard = (x,y)=> x>=0 && x<COLS && y>=0 && y<ROWS;
  const idx = (x,y)=> y*COLS + x;

  function getEnemySpec(key){ return ENEMIES.find(e=> e.key===key) || ENEMIES[0]; }
  function enemyAt(d,x,y){ return (d.enemies||[]).find(e=> e.x===x && e.y===y) || null; }
  function typeEmoji(t){ return TYPES[t] || '‚öîÔ∏è'; }

  function ensureSynergy(d){
    if (!d.synergy){
      d.synergy = { fire:0, water:0, nature:0, electric:0, arcane:0 };
    } else {
      for (const k of ['fire','water','nature','electric','arcane'] ){
        if (typeof d.synergy[k] !== 'number') d.synergy[k] = 0;
      }
    }
  }
  function addSynergy(d, type){
    ensureSynergy(d);
    if (!Object.prototype.hasOwnProperty.call(d.synergy, type)) return;
    d.synergy[type] = Math.min((d.synergy[type] || 0) + 1, 6);
  }

  function showEnemyTip(eObj, cellEl){
    const spec = getEnemySpec(eObj.key);
    tipTitle.textContent = `${spec.emoji} ${spec.name}`;
    const maxHP = eObj.maxHP || spec.hp || eObj.hp;
    tipHP.textContent = `HP ${eObj.hp}/${maxHP}`;
    tipWeak.innerHTML = `Weak: ${ (spec.weak||[]).map(typeEmoji).join(' ') || '‚Äî' }`;
    tipRes.innerHTML  = `Resist: ${ (spec.res||[]).map(typeEmoji).join(' ') || '‚Äî' }`;
    let abilityText = '‚Äî';
    if (spec.ability === 'fire_bolt') abilityText = 'üî• Fire Bolt (ranged tower hit)';
    else if (spec.ability === 'summon_rats') abilityText = 'üêÄ Rat Swarm (summons rats, clears freeze)';
    else if (spec.ability === 'shockwave') abilityText = 'üí• Shockwave (clears roots/freeze nearby)';
    else if (spec.ability === 'dragon_breath') abilityText = 'üî• Dragon Breath (burns column, extra bolt)';
    tipAbility.textContent = `Ability: ${ abilityText }`;

    const r = cellEl.getBoundingClientRect();
    const pad = 8;
    enemyTip.style.left = Math.min(window.innerWidth - 280, Math.max(8, r.left + r.width + pad)) + "px";
    enemyTip.style.top  = Math.min(window.innerHeight - 160, Math.max(8, r.top)) + "px";
    enemyTip.style.display = "block";
  }
  function hideEnemyTip(){ enemyTip.style.display = "none"; }

  function randomEnemyCells(d, count){
    const cells = [];
    for (const e of d.enemies||[]) cells.push([e.x,e.y]);
    if (!cells.length) return [];
    const picks = [];
    for (let i=0;i<Math.min(count, cells.length); i++){
      const j = Math.floor(Math.random()*cells.length);
      picks.push(cells.splice(j,1)[0]);
    }
    return picks;
  }

  const neighbors8 = (x,y)=>{
    const pts=[];
    for (let dx=-1; dx<=1; dx++){
      for (let dy=-1; dy<=1; dy++){
        if (dx===0 && dy===0) continue;
        const a=x+dx, b=y+dy;
        if (inBoard(a,b)) pts.push([a,b]);
      }
    }
    return pts;
  };
  const rectArea = (cx,cy,r=1)=>{
    const pts=[];
    for (let dx=-r; dx<=r; dx++){
      for (let dy=-r; dy<=r; dy++){
        const a=cx+dx, b=cy+dy;
        if (inBoard(a,b)) pts.push([a,b]);
      }
    }
    return pts;
  };

  function clearWaterArea(d, cx, cy, r=1){
    const cols = new Set(rectArea(cx,cy,r).map(([x])=> x));
    for (const x of cols){ if (d.frozenCols && d.frozenCols[x] != null) delete d.frozenCols[x]; }
  }
  function clearVinesArea(d, cx, cy, r=1){
    if (!d.vineCells) return;
    for (const [k,_until] of Object.entries({...d.vineCells})){
      const [x,y] = k.split(",").map(Number);
      if (Math.abs(x-cx)<=r && Math.abs(y-cy)<=r){ delete d.vineCells[k]; }
    }
  }

  function chainLightning(d, sx, sy, bonus=0, burn=false, root=false){
    const inB = (x,y)=> x>=0 && x<COLS && y>=0 && y<ROWS;
    const neigh = ([x,y])=> [[x+1,y],[x-1,y],[x,y+1],[x,y-1]].filter(([a,b])=> inB(a,b));
    const baseDmg = 3 + (bonus||0);
    const seen = new Set();
    let frontier = [[sx,sy]];
    const now = (d.turn||0);
    while (frontier.length){
      const [x,y] = frontier.shift();
      const k = `${x},${y}`; if (seen.has(k)) continue; seen.add(k);
      for (const e of d.enemies||[]) if (e.x===x && e.y===y){
        const t='electric';
        e.hp -= applyTypeMod(e, baseDmg, t);
        if (e.hp <= 0){ onEnemyDeath(d, e, "kill"); }
      }
      d.enemies = (d.enemies||[]).filter(e=> e.hp>0);
      if (burn){ if (!d.burnCells) d.burnCells={}; d.burnCells[`${x},${y}`]= now + 1; }
      if (root){ if (!d.vineCells) d.vineCells={}; d.vineCells[`${x},${y}`]= now + 1; }
      for (const [a,b] of neigh([x,y])){
        const hasEnemy = (d.enemies||[]).some(e=> e.x===a && e.y===b);
        if (hasEnemy) frontier.push([a,b]);
      }
    }
  }

  function glowCell(x,y, cls){
    const cell = boardEl.children[idx(x,y)];
    if (!cell) return;
    cell.classList.add(cls);
    setTimeout(()=> cell.classList.remove(cls), 800);
  }
  function tinyImplosion(el){
    const fx = document.createElement("div");
    fx.className = "implode";
    fx.textContent = "üí•";
    el.appendChild(fx);
    setTimeout(()=> fx.remove(), 450);
  }
  function pulseCells(cells, cls){
    for (const [x,y] of cells){ requestAnimationFrame(()=> glowCell(x,y,cls)); }
  }

  // ---------- Lobby / host ----------
  onSnapshot(lobbyRef, async (snap)=>{
    if (!snap.exists()) return;
    const d = snap.data();
    const players = d.players || [];
    playersBadge.textContent = `üë• ${players.length}/8`;
    if (!d.host && players.length){
      try{
        await runTransaction(db, async tx=>{
          const cur = await tx.get(lobbyRef);
          if (!cur.exists()) return;
          const cd = cur.data();
          if (!cd.host){ tx.update(lobbyRef, { host: players[0] }); }
        });
      }catch(e){}
    }
    isHost = (d.host === username);
    hostBadge.style.display = isHost ? "inline-flex" : "none";
    ensureGameState(players, d.host || players[0] || null);
  });

  // ---------- Initial Game State ----------
  async function ensureGameState(players, host){
    const s = await getDoc(stateRef);
    if (!s.exists()){
      if (!isHost) return;
      const hands = {};
      for (const p of players) hands[p] = seedHand();
      const payload = {
        createdAt: Date.now(),
        running: true,
        tick: 0,
        turn: 0,
        turnOrder: players,
        turnIndex: 0,
        currentPlayer: players[0] || "",
        towerHP: START_HP,
        towerMax: START_HP,
        mana: 0, manaMax: 12,
        enemies: [],
        bolts: [],
        frozenCols: {},
        vineCells: {},
        burnCells: {},
        hands,
        playedTurn: {},
        trade: { offers: {}, proposals: {} },
        host: host || "",
        synergy: { fire:0, water:0, nature:0, electric:0, arcane:0 },
        lastWaveSpawned: 0,
        difficulty: 1
      };
      await setDoc(stateRef, payload);
    } else {
      if (players.includes(username)){
        const d = s.data();
        if (!d.hands || !d.hands[username]){
          await updateDoc(stateRef, { [`hands.${username}`]: seedHand() });
        }
      }
    }
  }

  function seedHand(){
    const baseKeys = Object.keys(BASE_SPELLS);
    const picks = [];
    for (let i=0;i<3;i++){
      const k = baseKeys[Math.floor(Math.random()*baseKeys.length)];
      picks.push(makeCardFromKey(k));
    }
    return picks;
  }
  function makeCardFromKey(k){
    const spec = BASE_SPELLS[k];
    return { id:id(), type:k, name:spec.name, emoji:spec.emoji, charges:spec.charges, effect:spec.effect };
  }

  // ---------- Waves / difficulty ----------
  function waveForTurn(turn){
    return Math.floor((turn || 0) / TURNS_PER_WAVE) + 1;
  }
  function difficultyForWave(wave){
    return Math.floor((wave - 1) / 10) + 1;
  }
  function maxSpawnForTurn(turn){
    const wave = waveForTurn(turn);
    const diff = difficultyForWave(wave);
    if (diff >= 3) return 4;
    if (diff === 2) return 3;
    return wave >= 5 ? 3 : 2;
  }
  function randCol(){ return Math.floor(Math.random()*COLS); }
  function healthScaleForTurn(d){
    const turn = d.turn || 0;
    const wave = waveForTurn(turn);
    const diff = difficultyForWave(wave);
    const base = 1 + (wave - 1) * 0.06 + (diff - 1) * 0.6;
    return Math.min(4, base);
  }
  function bossScaleFor(d, big){
    const base = healthScaleForTurn(d);
    return base * (big ? 8 : 4);
  }

  function pickEnemyByWeight(wave){
    const diff = difficultyForWave(wave);
    const pool = [];
    for (const e of ENEMIES){
      if (e.weight <= 0) continue;
      const w = e.weight + Math.max(0, wave - 1) + (diff - 1);
      for (let i = 0; i < w; i++) pool.push(e);
    }
    return pool[Math.floor(Math.random()*pool.length)];
  }

  function spawnEnemy(d, key, x){
    const spec = getEnemySpec(key);
    const scale = (key === "ogre" || key === "dragon") ? bossScaleFor(d, key === "dragon") : healthScaleForTurn(d);
    const maxHP = Math.max(1, Math.round(spec.hp * scale));
    d.enemies.push({
      id: id(),
      key: spec.key,
      x: (typeof x === 'number') ? x : randCol(),
      y: 0,
      hp: maxHP,
      maxHP,
      spd: spec.spd,
      dmg: spec.dmg,
      emoji: spec.emoji,
      ability: spec.ability || null
    });
  }
  function spawnMiniBoss(d){ spawnEnemy(d, "ogre", randCol()); }
  function spawnBigBoss(d){ spawnEnemy(d, "dragon", Math.floor(COLS/2)); }

  // ---------- Render ----------
  onSnapshot(stateRef, (snap)=>{ if (snap.exists()) renderAll(snap.data()); });

  function renderAll(s){
    latestState = s;
    hpText.textContent = `${s.towerHP}/${s.towerMax}`;
    hpFill.style.width = clamp((s.towerHP/s.towerMax)*100, 0, 100) + "%";
    manaText.textContent = `${s.mana}/${s.manaMax}`;
    manaFill.style.width = clamp((s.mana/s.manaMax)*100, 0, 100) + "%";

    const turnNum = (s.turn||0)+1;
    const wave = waveForTurn(s.turn||0);
    const diff = difficultyForWave(wave);
    turnText.textContent = `T${turnNum} ‚Ä¢ W${wave} ‚Ä¢ D${diff} ‚Ä¢ ${s.currentPlayer||"?"}`;

    const myTurn = (s.currentPlayer === username) && s.running;
    endTurnBtn.classList.toggle("disabled", !myTurn);
    tradeHereBtn.classList.toggle("disabled", !myTurn);

    // clear board
    for (let r=0; r<ROWS; r++){
      for (let c=0; c<COLS; c++){
        const cell = boardEl.children[idx(c,r)];
        cell.innerHTML = "";
        cell.className = "cell" + (r===TOWER_ROW ? " tower" : "");
        if (r === TOWER_ROW) cell.textContent = "üè∞";
      }
    }

    const nowTurn = s.turn || 0;
    for (const [xStr,until] of Object.entries(s.frozenCols || {})){
      const x = Number(xStr);
      if (until >= nowTurn){ for (let r=0; r<ROWS; r++){ boardEl.children[idx(x,r)]?.classList.add("frozen"); } }
    }
    for (const [key,until] of Object.entries(s.vineCells || {})){
      if (until >= nowTurn){
        const [x,y] = key.split(",").map(Number);
        if (inBoard(x,y)) boardEl.children[idx(x,y)]?.classList.add("vine");
      }
    }
    for (const [key,until] of Object.entries(s.burnCells || {})){
      if (until >= nowTurn){
        const [x,y] = key.split(",").map(Number);
        if (inBoard(x,y)) boardEl.children[idx(x,y)]?.classList.add("burn");
      }
    }

    // enemies
    for (const e of (s.enemies||[])){
      if (!inBoard(e.x,e.y)) continue;
      const cell = boardEl.children[idx(e.x,e.y)];
      const spec = getEnemySpec(e.key);
      const baseMax = e.maxHP || spec.hp || e.hp || 1;
      const hpPct = clamp((e.hp / baseMax) * 100, 0, 100);
      const wrap = document.createElement("div");
      wrap.textContent = e.emoji;
      const bar = document.createElement("div"); bar.className = "hpbar";
      const fill = document.createElement("i"); fill.style.width = hpPct + "%";
      bar.appendChild(fill); wrap.appendChild(bar);
      cell.appendChild(wrap);
    }
    // bolts
    for (const b of (s.bolts||[])){
      if (!inBoard(b.x,b.y)) continue;
      const cell = boardEl.children[idx(b.x,b.y)];
      const bolt = document.createElement("div");
      bolt.textContent = "üî•";
      const bar = document.createElement("div"); bar.className = "hpbar"; bar.style.top = "22px";
      const fill = document.createElement("i"); fill.style.width = clamp((b.hp/1)*100,0,100) + "%";
      bar.appendChild(fill); bolt.appendChild(bar);
      cell.appendChild(bolt);
    }

    const myHand = (s.hands && s.hands[username]) ? s.hands[username] : [];
    renderHand(myHand, s);
    renderTrade(s);

    if (s.towerHP <= 0 && s.running){ endGameAndReturn(); }
  }

  async function endGameAndReturn(){
    try{ await updateDoc(stateRef, { running:false }); }catch(e){}
    try{ await updateDoc(lobbyRef, { status:"waiting" }); }catch(e){}
    location.href = `/?username=${encodeURIComponent(username)}`;
  }

  function potentialPartners(card){
    if (!card || !card.type) return [];
    const res = [];
    for (const key of Object.keys(COMBOS)){
      const [a,b] = key.split("+");
      if (a===card.type) res.push({ type:b });
      if (b===card.type) res.push({ type:a });
    }
    return res;
  }

  function renderHand(cards, s){
    handEl.innerHTML = "";
    const combosFor = (base)=> potentialPartners(base).map(p=> p.type);
    const selected = cards.find(c=> c.id===ui.selectedCardId) || null;
    const highlightTypes = (ui.mode==='combine' && selected) ? combosFor(selected) : [];

    for (const card of cards){
      const el = document.createElement("div");
      el.className = "card";
      if (ui.mode==='combine' && ui.selectedCardId && card.id !== ui.selectedCardId && highlightTypes.includes(card.type)){
        el.classList.add("combo-hint");
      }
      el.innerHTML = `
        <button class="btn btn-top" data-act="cast">Cast</button>
        <div>
          <div class="name">${card.emoji} ${card.name}</div>
          <div class="charges" aria-label="charges">${[0,1,2,3].map(i=> `<i class="pip ${card.charges>i?'':'off'}"></i>`).join('')}</div>
        </div>
        <button class="btn btn-bottom" data-act="combine">Combine‚Ä¶</button>
      `;
      if (card.super){
        const tag = document.createElement("div");
        tag.className = "super-tag";
        tag.textContent = "SUPER";
        el.appendChild(tag);
      }

      const castBtn = el.querySelector('[data-act="cast"]');
      const combBtn = el.querySelector('[data-act="combine"]');

      castBtn.addEventListener('click', (e)=>{
        e.preventDefault(); e.stopPropagation();
        ui.mode='cast'; ui.selectedCardId = card.id; hideEnemyTip();
        renderHand(cards, s);
      });

      combBtn.addEventListener('click', (e)=>{
        e.preventDefault(); e.stopPropagation();
        hideEnemyTip();
        if (ui.mode === 'combine' && ui.selectedCardId && ui.selectedCardId !== card.id){
          immediateCombineByIds(ui.selectedCardId, card.id);
          ui.mode=null; ui.selectedCardId=null;
        } else {
          ui.mode='combine'; ui.selectedCardId = card.id;
          renderHand(cards, s);
        }
      });

      el.addEventListener('click', ()=>{
        if (ui.mode==='combine' && ui.selectedCardId && card.id !== ui.selectedCardId){
          immediateCombineByIds(ui.selectedCardId, card.id);
          ui.mode=null; ui.selectedCardId=null;
        }
      });

      handEl.appendChild(el);
    }
  }

  function renderTrade(s){
    const myOfferId = (s.trade?.offers || {})[username] || null;
    if (!myOfferId){ myTradeEl.textContent = "‚Äî empty ‚Äî"; }
    else {
      const card = (s.hands[username]||[]).find(c=> c.id===myOfferId);
      myTradeEl.textContent = card ? `${card.emoji} ${card.name}` : "(offered)";
    }
    proposalsEl.innerHTML = "";
    const allProps = s.trade?.proposals || {};
    const myProps = (allProps[username] || []);
    for (const pr of myProps){
      const from = pr.from, cardId = pr.cardId;
      const btn = document.createElement("button");
      btn.className = "btn"; btn.style.width="auto"; btn.style.minHeight="auto"; btn.style.padding="6px 9px";
      btn.textContent = `Accept ${from}`;
      btn.onclick = ()=> acceptTrade(from, username, cardId);
      proposalsEl.appendChild(btn);
    }
  }

  tradeHereBtn.onclick = async ()=>{
    hideEnemyTip();
    if (!ui.selectedCardId) return;
    const s = (await getDoc(stateRef)).data();
    const myHand = s.hands[username]||[];
    const card = myHand.find(c=> c.id===ui.selectedCardId);
    if (!card) return;
    await updateDoc(stateRef, { [`trade.offers.${username}`]: card.id });
    ui.mode=null; ui.selectedCardId=null;
    renderHand(s.hands[username]||[], s);
  };

  clearTradeBtn.onclick = async ()=>{
    const patch = {}; patch[`trade.offers.${username}`] = null;
    await updateDoc(stateRef, patch);
    const s = (await getDoc(stateRef)).data();
    const propos = s.trade?.proposals || {};
    for (const to of Object.keys(propos)){
      const filtered = (propos[to]||[]).filter(p=> p.from !== username);
      await updateDoc(stateRef, { [`trade.proposals.${to}`]: filtered });
    }
  };

  async function acceptTrade(from, to, fromCardId){
    await runTransaction(db, async tx=>{
      const st = await tx.get(stateRef);
      if (!st.exists()) return;
      const d = st.data();
      const offers = d.trade?.offers || {};
      const hands = d.hands || {};
      const fromHand = hands[from]||[];
      const toHand = hands[to]||[];
      const toOfferId = offers[to];
      if (!toOfferId) return;

      const fromIdx = fromHand.findIndex(c=> c.id===fromCardId);
      const toIdx = toHand.findIndex(c=> c.id===toOfferId);
      if (fromIdx<0 || toIdx<0) return;

      const [fromCard] = fromHand.splice(fromIdx,1);
      const [toCard]   = toHand.splice(toIdx,1);
      fromHand.push(toCard);
      toHand.push(fromCard);

      if (!d.trade) d.trade = {offers:{}, proposals:{}};
      d.trade.offers[from] = null;
      d.trade.offers[to] = null;
      d.trade.proposals[to] = [];
      d.trade.proposals[from] = [];

      tx.update(stateRef, { hands: d.hands, trade: d.trade });
    });
  }

  // ---------- Type damage ----------
  function applyTypeMod(enemy, base, type){
    const spec = getEnemySpec(enemy.key);
    let mult = 1;
    if ((spec.weak||[]).includes(type)) mult *= 1.5;
    if ((spec.res||[]).includes(type)) mult *= 0.6;
    return Math.max(1, Math.round(base * mult));
  }

  // --- Knockback helpers (Golems immune) ---
  function tryPush(e, amount){
    if (e.key === "golem") return;
    e.y = Math.max(0, e.y - amount);
  }
  function pushBackColumn(d, x, amount){
    for (const e of d.enemies||[]) if (e.x===x) tryPush(e, amount);
  }

  // --- Death triggers (Slime split) ---
  function spawnBabySlimes(d, x, y){
    const open = neighbors8(x,y).filter(([a,b])=>{
      if (b >= TOWER_ROW) return false;
      return !(d.enemies||[]).some(en=> en.x===a && en.y===b);
    });
    for (let i=0; i<2 && open.length; i++){
      const j = Math.floor(Math.random()*open.length);
      const [a,b] = open.splice(j,1)[0];
      const baby = getEnemySpec("slime_baby");
      const scale = healthScaleForTurn(d);
      const maxHP = Math.max(1, Math.round(baby.hp * scale));
      d.enemies.push({ id:id(), key:"slime_baby", x:a, y:b, hp:maxHP, maxHP, spd:baby.spd, dmg:baby.dmg, emoji:baby.emoji, ability:null });
    }
  }
  function onEnemyDeath(d, e, cause="kill"){
    if (e._deadHandled) return;
    e._deadHandled = true;
    if (e.key === "slime" && cause==="kill"){
      spawnBabySlimes(d, e.x, e.y);
    }
  }

  function damageAtTyped(d, x,y,amt, type='neutral'){
    for (const b of d.bolts||[]){ if (b.x===x && b.y===y){ b.hp -= amt; } }
    d.bolts = (d.bolts||[]).filter(b=> b.hp>0);
    for (const e of d.enemies||[]){
      if (e.x===x && e.y===y){
        e.hp -= applyTypeMod(e, amt, type);
        if (e.hp <= 0){ onEnemyDeath(d, e, "kill"); }
      }
    }
    d.enemies = (d.enemies||[]).filter(e=> e.hp>0);
  }

  const area = (cx,cy,r=1)=> { const pts=[]; for (let x=cx-r; x<=cx+r; x++){ for (let y=cy-r; y<=cy+r; y++){ if (inBoard(x,y)) pts.push([x,y]); } } return pts; };
  const cross = (cx,cy)=> [[cx,cy],[cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]].filter(([x,y])=> inBoard(x,y));
  const column = (x)=> { const pts=[]; for (let y=0;y<ROWS;y++) pts.push([x,y]); return pts; };

  function addBurn(d,x,y,t,now){ if (!d.burnCells) d.burnCells={}; d.burnCells[`${x},${y}`]= now + t; }
  function addVine(d,x,y,t,now){ if (!d.vineCells) d.vineCells={}; d.vineCells[`${x},${y}`]= now + t; }
  function freezeCol(d,x,t,now){ if (!d.frozenCols) d.frozenCols={}; d.frozenCols[x]= now + t; }

  // ---------- Effects ----------
  function applyCardEffectMut(d, card, tx, ty){
    const eff = card.effect;
    const now = (d.turn||0);
    const T = effectType(eff);

    ensureSynergy(d);
    addSynergy(d, T);

    const sy = d.synergy[T] || 0;
    const dmgBonus = sy >= 2 ? 1 : 0;
    const durBonus = sy >= 3 ? 1 : 0;

    const DMG = (x,y,amt)=> damageAtTyped(d,x,y,amt + dmgBonus, T);
    const PING = (cells,amt)=> { for (const [x,y] of cells) DMG(x,y,amt); };

    const burnDur = (base)=> base + (T==='fire'    ? durBonus : 0);
    const vineDur = (base)=> base + (T==='nature'  ? durBonus : 0);
    const freezeDur = (base)=> base + (T==='water' ? durBonus : 0);

    switch(eff){
      // Base spells
      case "fire":      DMG(tx,ty,3);                         pulseCells([[tx,ty]], "glow-red"); break;
      case "lightning": chainLightning(d, tx, ty, 0);         pulseCells([[tx,ty]], "flash-yellow"); break;
      case "water":     freezeCol(d,tx,freezeDur(2),now); DMG(tx,ty,1);  pulseCells(column(tx), "glow-blue"); break;
      case "plant":     addVine(d,tx,ty,vineDur(2),now); DMG(tx,ty,1);   pulseCells([[tx,ty]], "glow-green"); break;

      case "pyro":         PING(cross(tx,ty),4);                                 pulseCells(cross(tx,ty), "glow-red"); break;
      case "inferno":      for (const [x,y] of cross(tx,ty)){ DMG(x,y,5); addBurn(d,x,y,burnDur(2),now); } pulseCells(cross(tx,ty), "glow-orange"); break;
      case "chain":        chainLightning(d, tx, ty, 1 + Math.floor(sy/2));      pulseCells([[tx,ty]], "flash-yellow"); break;

      case "steam": {
        for (const [x,y] of area(tx,ty,1)) DMG(x,y,2);
        pulseCells(area(tx,ty,1), "glow-blue");
        break;
      }

      case "vine": {
        addVine(d,tx,ty,vineDur(2),now);
        for (const [x,y] of cross(tx,ty)) addVine(d,x,y,vineDur(1),now);
        DMG(tx,ty,2);
        pulseCells([[tx,ty]].concat(cross(tx,ty)), "glow-green");
        break;
      }

      case "geyser": {
        for (let y=0;y<ROWS;y++) DMG(tx,y,4);
        pushBackColumn(d, tx, 1);
        pulseCells(column(tx),"glow-blue");
        break;
      }

      case "wall":         addVine(d,tx,ty,vineDur(4),now); DMG(tx,ty,1);                pulseCells([[tx,ty]], "glow-green"); break;
      case "embervine":    DMG(tx,ty,3); addVine(d,tx,ty,vineDur(2),now);                pulseCells([[tx,ty]], "glow-orange"); break;
      case "overheat":     PING(cross(tx,ty),5);                                          pulseCells(cross(tx,ty), "glow-orange"); break;
      case "bramblefire":  for (const [x,y] of area(tx,ty,1)){ addVine(d,x,y,vineDur(2),now); addBurn(d,x,y,burnDur(2),now); DMG(x,y,4); } pulseCells(area(tx,ty,1),"glow-orange"); break;
      case "arcfire":      chainLightning(d, tx, ty, 1 + Math.floor(sy/2), true, false);  pulseCells([[tx,ty]], "flash-yellow"); break;

      case "scald": {
        for (const [x,y] of area(tx,ty,1)){ DMG(x,y,3); addBurn(d,x,y,burnDur(1),now); }
        pulseCells(area(tx,ty,1),"glow-orange");
        break;
      }

      case "storm": {
        chainLightning(d, tx, ty, 1);
        freezeCol(d,tx,freezeDur(1),now);
        DMG(tx,ty,1);
        pulseCells(column(tx).concat([[tx,ty]]),"glow-blue");
        break;
      }

      case "steamblast": {
        for (const [x,y] of area(tx,ty,1)){ addVine(d,x,y,vineDur(1),now); DMG(x,y,2); }
        pulseCells(area(tx,ty,1),"glow-orange");
        break;
      }

      case "boil": {
        for (const [x,y] of area(tx,ty,1)){ DMG(x,y,3); addBurn(d,x,y,burnDur(2),now); }
        pulseCells(area(tx,ty,1),"glow-orange");
        break;
      }

      case "voltaic": {
        chainLightning(d, tx, ty, 0);
        freezeCol(d,tx,freezeDur(1),now);
        DMG(tx,ty,1);
        pulseCells([[tx,ty]].concat(column(tx)),"flash-yellow");
        break;
      }

      case "cinderwall": {
        const band = [[tx-1,ty],[tx,ty],[tx+1,ty]].filter(([x,y])=>inBoard(x,y));
        for (const [x,y] of band){ addVine(d,x,y,vineDur(3),now); addBurn(d,x,y,burnDur(1),now); }
        DMG(tx,ty,1);
        pulseCells(band,"glow-orange");
        break;
      }

      case "thorns": {
        const cells=[];
        for (let dy=0; dy<=2; dy++){
          const y=ty-dy; if (inBoard(tx,y)){ addVine(d,tx,y,vineDur(1),now); cells.push([tx,y]); }
        }
        if (cells.length) PING(cells,2); else DMG(tx,ty,2);
        pulseCells(cells,"glow-green");
        break;
      }

      case "mistflash": {
        for (const [x,y] of area(tx,ty,2)){ addVine(d,x,y,vineDur(2),now); }
        DMG(tx,ty,3);
        pulseCells(area(tx,ty,1),"flash-yellow");
        break;
      }

      case "marsh": {
        for (const [x,y] of area(tx,ty,1)){ addVine(d,x,y,vineDur(2),now); }
        DMG(tx,ty,1);
        pulseCells(area(tx,ty,1),"glow-green");
        break;
      }

      case "superchain":   chainLightning(d, tx, ty, 4 + Math.floor(sy/2));                 pulseCells([[tx,ty]], "flash-yellow"); break;
      case "thunderstorm": chainLightning(d, tx, ty, 1); addBurn(d,tx,ty,burnDur(1),now);   pulseCells([[tx,ty]], "flash-yellow"); break;

      case "tsunami": {
        const cx2 = clamp(tx+1,0,COLS-1);
        [tx, cx2].forEach(cx=>{
          for (let y=0;y<ROWS;y++) damageAtTyped(d,cx,y,5 + dmgBonus,'water');
          pushBackColumn(d, cx, 1);
        });
        pulseCells(column(tx).concat(column(cx2)), "glow-blue");
        break;
      }

      case "wildfire": {
        for (const [x,y] of cross(tx,ty)){ addBurn(d,x,y,burnDur(2),now); }
        DMG(tx,ty,1);
        pulseCells(cross(tx,ty),"glow-red");
        break;
      }

      case "thundercloud": {
        const targets = randomEnemyCells(d, 5 + Math.floor(sy/2));
        if (targets.length){
          for (const [x,y] of targets){ damageAtTyped(d,x,y,5 + dmgBonus,'electric'); }
          pulseCells(targets,"flash-yellow");
        } else {
          DMG(tx,ty,4); pulseCells([[tx,ty]],"flash-yellow");
        }
        break;
      }

      case "entangle":
      case "net": {
        chainLightning(d, tx, ty, 0, false, true);
        DMG(tx,ty,1);
        pulseCells([[tx,ty]], "glow-green");
        break;
      }

      case "cataclysm": {
        const cx2 = clamp(tx+1,0,COLS-1);
        [tx, cx2].forEach(cx=>{
          for (let y=0; y<ROWS; y++){
            damageAtTyped(d,cx,y,6 + dmgBonus,'fire');
            pushBackColumn(d, cx, 2);
          }
        });
        for (const [x,y] of cross(tx,ty)) addBurn(d,x,y,burnDur(2),now);
        pulseCells(column(tx).concat(column(cx2)).concat(cross(tx,ty)), "glow-orange");
        break;
      }

      case "supernova": {
        chainLightning(d, tx, ty, 4 + Math.floor(sy/2), true, false);
        DMG(tx,ty,4);
        pulseCells([[tx,ty]], "flash-yellow");
        break;
      }

      case "worldroot": {
        for (const [x,y] of area(tx,ty,2)){ addVine(d,x,y,vineDur(3),now); damageAtTyped(d,x,y,4 + dmgBonus,'nature'); }
        pulseCells(area(tx,ty,2), "glow-green");
        break;
      }

      case "stormfront": {
        const cx2 = clamp(tx+1,0,COLS-1);
        [tx, cx2].forEach(cx=>{
          for (let y=0; y<ROWS; y++) damageAtTyped(d,cx,y,5 + dmgBonus,'electric');
          pushBackColumn(d, cx, 2);
        });
        chainLightning(d, tx, ty, 2 + Math.floor(sy/2));
        pulseCells(column(tx).concat(column(cx2)).concat([[tx,ty]]), "glow-blue");
        break;
      }

      case "eruption": {
        for (let y=0; y<ROWS; y++){ damageAtTyped(d,tx,y,6 + dmgBonus,'fire'); }
        pushBackColumn(d, tx, 2);
        addBurn(d,tx,ty,burnDur(2),now);
        pulseCells(column(tx), "glow-orange");
        break;
      }

      case "overgrowth": {
        for (const [x,y] of area(tx,ty,2)){ addVine(d,x,y,vineDur(3),now); damageAtTyped(d,x,y,2 + dmgBonus,'nature'); }
        pulseCells(area(tx,ty,2), "glow-green");
        break;
      }

      case "frostline": {
        freezeCol(d,tx,freezeDur(3),now);
        for (let y = 0; y < ROWS; y++) damageAtTyped(d, tx, y, 2 + dmgBonus, 'ice');
        pulseCells(column(tx), "glow-blue");
        break;
      }

      case "battery": {
        chainLightning(d, tx, ty, 2 + Math.floor(sy/2));
        DMG(tx,ty,2);
        ensureSynergy(d);
        d.synergy.electric = Math.min((d.synergy.electric||0)+1,6);
        pulseCells([[tx,ty]], "flash-yellow");
        break;
      }

      case "shockpush": {
        for (let y=0;y<ROWS;y++) damageAtTyped(d,tx,y,3 + dmgBonus,'electric');
        pushBackColumn(d, tx, 1);
        pulseCells(column(tx), "flash-yellow");
        break;
      }

      case "fireline": {
        const band = [[tx-1,ty],[tx,ty],[tx+1,ty]].filter(([x,y])=>inBoard(x,y));
        for (const [x,y] of band){ DMG(x,y,3); addBurn(d,x,y,burnDur(2),now); }
        pulseCells(band, "glow-orange");
        break;
      }

      case "bogstorm": {
        const picks = randomEnemyCells(d, 5 + Math.floor(sy/2));
        if (picks.length) {
          for (const [x,y] of picks) { damageAtTyped(d,x,y,4 + dmgBonus,'electric'); addVine(d,x,y,vineDur(1),now); }
          pulseCells(picks, "flash-yellow");
        } else {
          chainLightning(d, tx, ty, 1); addVine(d,tx,ty,vineDur(1),now); pulseCells([[tx,ty]], "flash-yellow");
        }
        break;
      }

      // Economy / support
      case "manafont": {
        d.mana = Math.min(d.manaMax || 12, (d.mana || 0) + 3 + sy);
        const hand = d.hands[username] || [];
        const cand = hand.filter(c=> c.id !== card.id);
        if (cand.length){
          const tgt = cand[Math.floor(Math.random()*cand.length)];
          tgt.charges = Math.min(4, (tgt.charges||0) + 1);
        }
        pulseCells(column(tx), "glow-blue");
        break;
      }

      case "overcharge": {
        ensureSynergy(d);
        d.synergy.electric = Math.min((d.synergy.electric||0) + 2, 6);
        const hand = d.hands[username] || [];
        for (const h of hand){
          if (effectType(h.effect)==='electric'){
            h.charges = Math.min(4, (h.charges||0) + 1);
          }
        }
        pulseCells(area(tx,1), "flash-yellow");
        break;
      }

      case "focus": {
        d.manaMax = Math.min((d.manaMax || 12) + 2, 20);
        const hand = d.hands[username] || [];
        if (hand.length){
          const t = hand[Math.floor(Math.random()*hand.length)];
          t.charges = Math.min(4, (t.charges||0) + 2);
        }
        pulseCells([[tx,ty]], "glow-blue");
        break;
      }

      case "sprout": {
        const hand = d.hands[username] || [];
        if (hand.length){
          const base = hand[Math.floor(Math.random()*hand.length)];
          hand.push({ ...base, id:id(), charges: Math.min(3, base.charges||2) });
        }
        for (const [x,y] of area(tx,ty,1)){ addVine(d,x,y,vineDur(1),now); }
        pulseCells(area(tx,ty,1), "glow-green");
        break;
      }

      // Super spells
      case "armageddon": {
        for (let x=0; x<COLS; x++){
          for (let y=0; y<ROWS; y++){
            damageAtTyped(d,x,y,8 + dmgBonus,'fire');
            addBurn(d,x,y,burnDur(2),now);
          }
        }
        pulseCells(rectArea(Math.floor(COLS/2),Math.floor(ROWS/2),2),"glow-orange");
        break;
      }

      case "genesis": {
        d.towerHP = Math.min(d.towerMax, d.towerHP + 20);
        const hand = d.hands[username] || [];
        for (const h of hand){
          h.charges = Math.min(4, (h.charges||0) + 1);
        }
        ensureSynergy(d);
        for (const k of ['fire','water','nature','electric','arcane']){
          d.synergy[k] = Math.max(0, d.synergy[k] - 1);
        }
        for (const [x,y] of area(tx,ty,2)){
          addVine(d,x,y,vineDur(2),now);
          if (d.burnCells) delete d.burnCells[`${x},${y}`];
        }
        pulseCells(area(tx,ty,2),"glow-green");
        break;
      }

      default: {
        DMG(tx,ty,2);
        pulseCells([[tx,ty]], "flash-yellow");
        break;
      }
    }
  }

  // ---------- Cast flow ----------
  async function castSelectedOn(x,y){
    const cardId = ui.selectedCardId;
    if (!cardId) return;
    await runTransaction(db, async tx=>{
      const st = await tx.get(stateRef);
      if (!st.exists()) return;
      const d = st.data();
      if (!d.running || d.currentPlayer !== username) return;

      const hand = d.hands[username] || [];
      const ci = hand.findIndex(c=> c.id===cardId);
      if (ci<0) return;

      const card = hand[ci];
      if ((lastPlayedTurnMarker[card.id] || -1) === (d.turn||0)) return;
      if (card.charges <= 0) return;

      applyCardEffectMut(d, card, x, y);

      if (card.super){
        hand.splice(ci,1);
      } else {
        hand[ci].charges = Math.max(0, (hand[ci].charges||0)-1);
        if (hand[ci].charges === 0){ hand.splice(ci,1); } else { hand[ci] = {...hand[ci]}; }
      }

      if (!d.playedTurn) d.playedTurn = {};
      if (!d.playedTurn[username]) d.playedTurn[username] = {};
      d.playedTurn[username][card.id] = d.turn||0;

      tx.update(stateRef, {
        hands: d.hands,
        enemies: d.enemies,
        bolts: d.bolts,
        frozenCols: d.frozenCols,
        vineCells: d.vineCells,
        burnCells: d.burnCells,
        playedTurn: d.playedTurn,
        towerHP: d.towerHP,
        mana: d.mana,
        synergy: d.synergy
      });
    });

    const s2 = (await getDoc(stateRef)).data();
    const myHand2 = s2.hands[username]||[];
    const stillThere = myHand2.find(c=> c.id===cardId);
    if (!stillThere){ handEl.querySelectorAll(".card").forEach(el=> tinyImplosion(el)); }
    lastPlayedTurnMarker[cardId] = (latestState?.turn||0);
    ui.mode=null; ui.selectedCardId=null;
    hideEnemyTip();
  }

  function onCellClick(x,y, cellEl){
    hideEnemyTip();
    if (!latestState) return;

    if (ui.mode==='cast' && ui.selectedCardId){
      castSelectedOn(x,y);
      return;
    }

    const e = enemyAt(latestState, x,y);
    if (e){ showEnemyTip(e, cellEl); }
  }

  // ---------- Combine ----------
  function getCombo(t1,t2){ return (t1 && t2) ? (COMBOS[`${t1}+${t2}`] || COMBOS[`${t2}+${t1}`] || null) : null; }

  async function immediateCombineByIds(aId, bId){
    await runTransaction(db, async tx=>{
      const st = await tx.get(stateRef);
      if (!st.exists()) return;
      const d = st.data();
      const hand = d.hands?.[username] || [];
      const a = hand.find(c=> c.id===aId);
      const b = hand.find(c=> c.id===bId);
      if (!a || !b || a.id===b.id) return;
      const combo = getCombo(a.type, b.type);
      if (!combo) return;
      const ai = hand.findIndex(c=> c.id===a.id);
      const bi = hand.findIndex(c=> c.id===b.id);
      const first = Math.max(ai,bi), second = Math.min(ai,bi);
      hand.splice(first,1); hand.splice(second,1);
      hand.push({
        id: id(),
        type: combo.key,
        name: combo.name,
        emoji: combo.emoji,
        charges: combo.charges,
        effect: combo.effect,
        super: !!combo.super
      });
      tx.update(stateRef, { hands: d.hands });
    }).catch(()=>{});
  }

  // ---------- Turn System ----------
  function startOfTurnMut(d){
    const now = d.turn || 0;

    const wave = waveForTurn(now);
    const diff = difficultyForWave(wave);
    d.difficulty = diff;
    if (d.lastWaveSpawned == null) d.lastWaveSpawned = 0;
    if (wave > d.lastWaveSpawned){
      d.lastWaveSpawned = wave;
      if (wave % 10 === 0){
        spawnBigBoss(d);
      } else if (wave % 5 === 0){
        spawnMiniBoss(d);
      }
    }

    ensureSynergy(d);
    for (const k of Object.keys(d.synergy)){
      d.synergy[k] = Math.max(0, d.synergy[k] - 1);
    }

    // burn ticks
    for (const [key,until] of Object.entries(d.burnCells||{})){
      if (until >= now){
        const [x,y] = key.split(",").map(Number);
        for (const e of d.enemies || []){
          if (e.x===x && e.y===y){
            e.hp -= applyTypeMod(e, 1, 'fire');
            if (e.hp <= 0){ onEnemyDeath(d, e, "kill"); }
          }
        }
      }
    }
    d.enemies = (d.enemies||[]).filter(e=> e.hp>0);

    // abilities
    for (const e of d.enemies || []){
      if (e.key === "mage"){
        if (Math.random() < 0.15){
          const n = 1 + Math.floor(Math.random()*2);
          for (let i=0;i<n;i++){ spawnEnemy(d, "rat"); }
        }
        if (Math.random() < 0.50){
          clearWaterArea(d, e.x, e.y, 1);
        }
      }
      if (e.key === "imp" && Math.random() < 0.5){
        clearVinesArea(d, e.x, e.y, 1);
      }
      if (e.key === "ogre" && Math.random() < 0.35){
        clearVinesArea(d, e.x, e.y, 2);
        clearWaterArea(d, e.x, e.y, 2);
      }
      if (e.key === "dragon" && Math.random() < 0.5){
        for (let y = e.y+1; y < ROWS; y++){
          addBurn(d, e.x, y, 2, now);
        }
        if (!d.bolts) d.bolts = [];
        d.bolts.push({ id:id(), x:e.x, y:e.y+1, hp:1, dmg:8 });
      }
      if (e.ability === "fire_bolt" && Math.random() < 0.4){
        if (!d.bolts) d.bolts=[]; d.bolts.push({ id:id(), x:e.x, y:e.y+1, hp:1, dmg:6 });
      }
    }

    // move bolts
    for (const b of (d.bolts||[])){ b.y += 1; }
    for (const b of d.bolts||[]){
      if (b.y >= TOWER_ROW){ d.towerHP -= (b.dmg || 6); b.hp = 0; }
    }
    d.bolts = (d.bolts||[]).filter(b=> b.hp>0 && b.y<TOWER_ROW);

    const frozen = d.frozenCols || {};
    const vines = d.vineCells || {};
    for (const e of d.enemies){
      const colFrozen = (frozen[e.x] && frozen[e.x] >= now);
      const vinedHere = (vines[`${e.x},${e.y}`] && vines[`${e.x},${e.y}`] >= now);
      const isSpecter = (e.key === "specter");
      if (colFrozen || (!isSpecter && vinedHere)) continue;
      e.y += e.spd || getEnemySpec(e.key).spd || 1;
      if (e.y >= TOWER_ROW){
        d.towerHP -= (e.dmg || getEnemySpec(e.key).dmg || 1);
        e._deadHandled = true;
        e.hp = 0;
      }
    }
    d.enemies = d.enemies.filter(e=> e.hp>0 && e.y<TOWER_ROW);

    const waveNow = waveForTurn(d.turn||0);
    const maxSpawn = maxSpawnForTurn(d.turn||0);
    const n = 1 + Math.floor(Math.random()*maxSpawn);
    for (let i=0;i<n;i++){
      const pick = pickEnemyByWeight(waveNow);
      spawnEnemy(d, pick.key);
    }

    for (const [x,until] of Object.entries(d.frozenCols||{})){ if (until < now) delete d.frozenCols[x]; }
    for (const [k,until] of Object.entries(d.vineCells||{})){ if (until < now) delete d.vineCells[k]; }
    for (const [k,until] of Object.entries(d.burnCells||{})){ if (until < now) delete d.burnCells[k]; }
  }

  // ---------- End turn ----------
  endTurnBtn.onclick = async ()=>{
    hideEnemyTip();
    await runTransaction(db, async tx=>{
      const st = await tx.get(stateRef);
      if (!st.exists()) return;
      const d = st.data();
      if (!d.running || d.currentPlayer !== username) return;

      const hand = d.hands[username] || [];
      hand.push(makeCardFromKey(randBase()));

      const order = d.turnOrder || [];
      if (!order.length) return;
      let idx = d.turnIndex || 0;
      idx = (idx+1) % order.length;
      d.turn = (d.turn||0) + 1;
      d.turnIndex = idx;
      d.currentPlayer = order[idx];

      startOfTurnMut(d);

      tx.update(stateRef, {
        hands: d.hands,
        turn: d.turn,
        turnIndex: d.turnIndex,
        currentPlayer: d.currentPlayer,
        towerHP: d.towerHP,
        enemies: d.enemies,
        bolts: d.bolts,
        frozenCols: d.frozenCols,
        vineCells: d.vineCells,
        burnCells: d.burnCells,
        mana: d.mana,
        synergy: d.synergy,
        lastWaveSpawned: d.lastWaveSpawned,
        difficulty: d.difficulty
      });
    });
    ui.mode=null; ui.selectedCardId=null;
  };
  function randBase(){ const k = Object.keys(BASE_SPELLS); return k[Math.floor(Math.random()*k.length)]; }

  // ---------- Keep proposals synced ----------
  onSnapshot(stateRef, (snap)=>{
    if (!snap.exists()) return;
    const d = snap.data();
    const offers = d.trade?.offers || {};
    const myOffer = offers[username];
    if (!myOffer) return;
    const toMe = [];
    for (const [p,cardId] of Object.entries(offers)){
      if (!cardId || p===username) continue;
      toMe.push({ from:p, cardId });
    }
    updateDoc(stateRef, { [`trade.proposals.${username}`]: toMe }).catch(()=>{});
  });

  // ---------- Global click: hide tooltip ----------
  document.addEventListener('click', (e)=>{
    const inBoard = e.target.closest('.cell');
    const inTip = e.target.closest('#enemyTip');
    const inCard = e.target.closest('.card');
    if (!inBoard && !inTip && !inCard) hideEnemyTip();
  });
</script>
</body>
</html>

















