<!DOCTYPE html> 
<html lang="en">
<head>
<meta charset="utf-8" />
<title>‚öîÔ∏è Draft Brawl ‚Äî Factions (2P)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<style>
  :root{
    --bg:#ffffff; --ink:#0f172a; --muted:#64748b; --line:#e5e7eb;
    --shadow:0 10px 30px rgba(2,6,23,.08);
    --cell:64px; /* bigger tiles for closer view */
    --gap:4px;
    /* team fills kept around but unused now (rank colors used instead) */
    --p0bg:#ffdbe0;
    --p1bg:#dbe7ff;

    /* darker, solid rank colors */
    --rank1:#166534;  /* dark green */
    --rank2:#a16207;  /* dark amber/gold */
    --rank3:#991b1b;  /* dark red */
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}

  .topbar{
    position:sticky; top:0; z-index:30;
    background:#fff; border-bottom:1px solid var(--line);
    padding:8px 10px; display:flex; align-items:center; justify-content:space-between; gap:10px;
  }
  .row{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
  .badge{display:inline-flex;gap:8px;align-items:center;padding:8px 12px;border:1px solid var(--line);border-radius:999px;background:#fff;box-shadow:var(--shadow);font-weight:800}
  .btn{appearance:none;border:1px solid var(--line);border-radius:12px;padding:10px 12px;font-weight:800;cursor:pointer;background:#111827;color:#fff}
  .btn.ghost{background:#fff;color:var(--ink)}

  .viewport{
    position:relative; width:100%; height:calc(100dvh - 70px);
    border:1px solid var(--line); border-radius:14px; overflow:hidden; background:#fff;
    cursor:grab; user-select:none; touch-action:none;
  }
  .viewport:active{ cursor:grabbing; }
  .canvas{ position:absolute; left:0; top:0; transform-origin:0 0; will-change:transform; }

  .cells{
    position:relative;
    display:grid;
    grid-template-columns:repeat(var(--w),var(--cell));
    grid-auto-rows:var(--cell);
    gap:var(--gap);
  }
  .cell{
    width:var(--cell);height:var(--cell);
    border:1px solid #e2e8f0;border-radius:10px;background:#f8fafc;
    position:relative;overflow:hidden;
  }

  /* Layers (z-index order): under(0) < ground fx(1) < unit(3) < hp(4) */
  .under{
    position:absolute; inset:0; z-index:0; /* rank fill */
    /* force fully solid color (no transparency or blending) */
    opacity:1 !important;
    mix-blend-mode:normal !important;
    filter:none !important;
  }
  .unit{ position:absolute; inset:0; display:grid; place-items:center; font-size:26px; z-index:3; pointer-events:none; }
  .hp{position:absolute;left:3px;right:3px;bottom:3px;height:6px;border-radius:4px;background:#e2e8f0;overflow:hidden;z-index:4}
  .hp>i{display:block;height:100%;background:linear-gradient(90deg,#22c55e,#16a34a)}
  .hitflash{ position:absolute; inset:0; background:rgba(255,255,255,.9); animation:flash .12s ease; pointer-events:none; z-index:2 }
  @keyframes flash{ from{opacity:.9} to{opacity:0} }
  .dmg{
    position:absolute; left:50%; top:40%; transform:translate(-50%,-50%);
    font-weight:900; font-size:12px; color:#b91c1c; text-shadow:0 1px 0 rgba(0,0,0,.15);
    animation:dmg 600ms ease-out forwards; pointer-events:none; z-index:5;
  }
  @keyframes dmg{
    0%{opacity:0; transform:translate(-50%,-40%) scale(.9)}
    10%{opacity:1;}
    100%{opacity:0; transform:translate(-50%,-100%) scale(1)}
  }

  /* Ground effects */
  .poison{ position:absolute; inset:0; background:#ffb3b3; opacity:.95; z-index:1; animation:poipulse 1s ease-in-out infinite; }
  @keyframes poipulse{ 0%,100%{filter:brightness(1)} 50%{filter:brightness(1.15)} }

  /* NEW: Defiler toxic splash (purple) */
  .toxic{ position:absolute; inset:0; background:#6b21a8; opacity:.9; z-index:1; animation:toxpulse 1s ease-in-out infinite; }
  @keyframes toxpulse{ 0%,100%{filter:saturate(1)} 50%{filter:saturate(1.2)} }

  .acid{ position:absolute; inset:0; background:#c7b8ff; opacity:.95; z-index:1; animation:acidpulse 1s ease-in-out infinite; }
  @keyframes acidpulse{ 0%,100%{filter:saturate(1)} 50%{filter:saturate(1.2)} }
  .ward{ position:absolute; inset:0; background:#8ec5ff; border:1px solid #4ea3ff; z-index:1 }

  /* Draft overlay */
  .overlay{position:absolute;inset:0;background:rgba(255,255,255,.55);display:none;z-index:40}
  .cardRow{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);display:flex;gap:10px;z-index:50;flex-wrap:wrap;justify-content:center}
  .card{width:min(240px,34vw);background:#fff;border:1px solid var(--line);border-radius:14px;box-shadow:var(--shadow);padding:12px 14px;cursor:pointer;display:grid;gap:6px;user-select:none}
  .card:hover{background:#f8fafc}
  .title{font-weight:900}
  .desc{color:var(--muted);font-size:.92rem}
  .pickNote{
    position:absolute;left:50%;top:12%;transform:translateX(-50%);
    z-index:60;background:#fff;border:1px solid var(--line);border-radius:999px;box-shadow:var(--shadow);
    padding:8px 14px;font-weight:900;display:none;
  }
  .pickCounter{
    position:absolute;left:50%;top:8%;transform:translateX(-50%);
    z-index:61;background:#fff;border:1px solid var(--line);border-radius:999px;box-shadow:var(--shadow);
    padding:6px 12px;font-weight:900;display:none;
  }

  /* VFX */
  .beams, .particles{ position:absolute; left:0; top:0; width:1px; height:1px; transform:translate3d(0,0,0); pointer-events:none; }
  .beam{
    position:absolute; height:3px; border-radius:3px; background:linear-gradient(90deg,rgba(59,130,246,.95),rgba(239,68,68,.95));
    opacity:.95; transform-origin:0 50%; animation:beamfade .35s ease-out forwards;
  }
  .hbeam{
    position:absolute; height:3px; border-radius:3px; background:linear-gradient(90deg,rgba(34,197,94,1),rgba(134,239,172,1));
    opacity:1; transform-origin:0 50%; animation:beamfade .35s ease-out forwards;
  }
  @keyframes beamfade{ to{ opacity:0 } }

  .p{ position:absolute; width:6px; height:6px; border-radius:50%; background:#ef4444; opacity:.95; animation:pfade .7s ease-out forwards }
  .p.purple{ background:#6b21a8; }
  @keyframes pfade{ to{ opacity:0; transform:translateY(-8px) scale(.7) } }
</style>
</head>
<body>
  <div class="topbar">
    <div class="row">
      <span class="badge">‚öîÔ∏è Draft Brawl ‚Äî Factions</span>
      <span id="phaseBadge" class="badge">‚Äî</span>
    </div>
    <div class="row">
      <span id="p0Badge" class="badge">P0 ‚Äî ‚ù§‚ù§‚ù§‚ù§</span>
      <span id="p1Badge" class="badge">P1 ‚Äî ‚ù§‚ù§‚ù§‚ù§</span>
      <span id="timerBadge" class="badge">‚è≥ ‚Äî</span>
      <button id="fsBtn" class="btn ghost">‚õ∂ Fullscreen</button>
    </div>
  </div>

  <div class="viewport" id="viewport">
    <div class="canvas" id="canvas">
      <div id="cells" class="cells" style="--w:8; --cell:64px; --gap:4px"></div>
      <div id="beams" class="beams"></div>
      <div id="particles" class="particles"></div>
    </div>
    <div id="overlay" class="overlay"></div>
    <div id="cardRow" class="cardRow" style="display:none"></div>
    <div id="pickNote" class="pickNote"></div>
    <div id="pickCounter" class="pickCounter"></div>
  </div>

<script type="module">
/* ---------------- Firebase ---------------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, runTransaction } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);

/* ---------------- URL params ---------------- */
const params   = new URLSearchParams(location.search);
const gameId   = params.get("gameId");
const username = params.get("username");
if (!gameId || !username){ alert("Missing gameId or username."); }

const lobbyRef = doc(db,"lobbies",gameId);
const stateRef = doc(db,"lobbies",gameId,"crowncouncil","state");

/* ---------------- Pace / sizes ---------------- */
const PACE = { tickMs: 560, atkMult: 2.35, moveSteps: 1, poisonDotMs: 900, poisonSlowMs: 1100, toxicDotMs: 1000 };
const VIEW_MS  = 120;   // publish + render cadence (smoother remote view)
const LOGIC_MS = 560;   // core logic cadence (unchanged battle speed)
const MOVE_MS  = 560;   // gate movement per unit so logic pacing matches old behavior

let CELL=64, GAP=4, W=8, H=20; // half height and larger cells

/* ---------------- DOM ---------------- */
const $ = (id)=>document.getElementById(id);
const cellsEl=$("cells"), canvas=$("canvas"), viewport=$("viewport"), beamsEl=$("beams"), partsEl=$("particles");

/* ---------------- Fit/zoom & pan ---------------- */
let boardScale=1, pan={x:12, y:12};
function applyTransform(){
  canvas.style.transform = `translate(${pan.x}px, ${pan.y}px) scale(${boardScale})`;
}
function fitBoard(){
  const boardW = W*(CELL+GAP)-GAP;
  const boardH = H*(CELL+GAP)-GAP;
  const vw = viewport.clientWidth, vh=viewport.clientHeight;

  const fitScale = Math.min(vw/boardW, vh/boardH);
  boardScale = Math.min(2.2, fitScale * 1.25); // zoom in beyond fit

  pan.x = Math.round((vw - boardW*boardScale) / 2);
  pan.y = Math.round((vh - boardH*boardScale) / 2);
  applyTransform();
}
new ResizeObserver(fitBoard).observe(viewport);

/* pointer pan */
let dragging=false, last={x:0,y:0};
viewport.addEventListener("pointerdown", e=>{ dragging=true; last={x:e.clientX,y:e.clientY}; });
viewport.addEventListener("pointermove", e=>{
  if(!dragging) return;
  const dx=e.clientX-last.x, dy=e.clientY-last.y;
  pan.x+=dx; pan.y+=dy; applyTransform();
  last={x:e.clientX,y:e.clientY};
});
viewport.addEventListener("pointerup", ()=>{ dragging=false; });
viewport.addEventListener("pointercancel", ()=>{ dragging=false; });

/* ---------------- Build cells ---------------- */
function buildBoard(){
  cellsEl.style.setProperty("--w", W);
  cellsEl.style.setProperty("--cell", CELL + "px");
  cellsEl.style.setProperty("--gap", GAP + "px");
  const frag=document.createDocumentFragment();
  for (let y=0;y<H;y++){
    for (let x=0;x<W;x++){
      const d=document.createElement("div");
      d.className="cell";
      d.dataset.x=String(x); d.dataset.y=String(y);
      d.innerHTML = `
        <div class="under"></div>
        <div class="unit"></div>
        <div class="hp"><i style="width:0%"></i></div>
      `;
      frag.appendChild(d);
    }
  }
  cellsEl.innerHTML="";
  cellsEl.appendChild(frag);
}
buildBoard();

/* ---------------- Units & data ---------------- */
const R = (hp,dmg,range,cd)=>({hp,dmg,range,cd});
const M = (hp,dmg,cd)=>({hp,dmg,range:1,cd});

/* NOTE: Changes per request:
   - rifleman dmg ‚Üì and range ‚Üë
   - guardian size -> 1, dmg ‚Üë, stronger knockback
   - defiler size -> 1, gains toxicSplash on hit (10s purple DoT)
*/
const TROOPS = {
  /* Vanir */
  rifleman: { faction:"Vanir", name:"Riflemen", emoji:"üî´", role:"back",  base:{...R(7,1,6,1050)}, spawn:2 },
  vrocket:  { faction:"Vanir", name:"Rockets",   emoji:"üöÄ", role:"back",  base:{...R(8,4,10,2000), splash1:true, knock:true} },
  vguard:   { faction:"Vanir", name:"Vanir Guard", emoji:"üõ°Ô∏è", role:"front", base:{...M(18,5,800)}, splash1:true },
  miner:    { faction:"Vanir", name:"Miners",    emoji:"‚õèÔ∏è", role:"front", base:{...M(16,2,800), spd:2, hunterRanged:true}, spawn:2 },
  medic:    { faction:"Vanir", name:"Field Medic", emoji:"üß∞", role:"back", base:{ hp:8, dmg:0, range:3, cd:1100, heal:true, healAmt:2, healRange:3, healCd:1200 }},

  /* Aesir */
  phaser:   { faction:"Aesir", name:"Phasers",   emoji:"‚ú®", role:"back",  base:{...R(6,2,4,900), blink50:true}, spawn:2 },
  blade:    { faction:"Aesir", name:"Blademasters", emoji:"‚öîÔ∏è", role:"front", base:{...M(12,6,700), spd:2}, spawn:2 },
  storm:    { faction:"Aesir", name:"Storm Seer", emoji:"üå©Ô∏è", role:"back",  base:{...R(7,3,3,1100), chain3:true} },
  guardian: { faction:"Aesir", name:"Guardian",  emoji:"üõ°Ô∏è", role:"front", base:{...M(22,6,900), splash1:true, knock:true, strongKnock:true}, size:1 },
  wardmaker:{ faction:"Aesir", name:"Wardmaker", emoji:"üõ°Ô∏è‚ú®", role:"back", base:{ hp:9, dmg:0, range:3, cd:1500, ward:true, wardCd:1900, wardDur:6000, wardHp:2 }},

  /* Helions */
  hellspawn:{ faction:"Helions", name:"Hell Spawn", emoji:"üî•", role:"front", base:{...M(6,2,500), spd:3}, spawn:4 },
  roach:    { faction:"Helions", name:"Roaches",  emoji:"üêû", role:"back",  base:{...R(12,3,3,1000)}, spawn:2 },
  defiler:  { faction:"Helions", name:"Defiler",  emoji:"üßü", role:"front", base:{...M(26,4,900), splash1:true, toxicSplash:true}, size:1 },
  blood:    { faction:"Helions", name:"BloodBurst", emoji:"ü©∏", role:"front", base:{...M(9,3,0), kamikaze:true, paints:true}, spawn:2 },
  spitter:  { faction:"Helions", name:"Spitter Brood", emoji:"üü£", role:"back", base:{...R(12,3,5,1200), acid:true, acidDur:3500} }
};
const FACTIONS = {
  Vanir:  ["rifleman","vrocket","vguard","miner","medic"],
  Aesir:  ["phaser","blade","storm","guardian","wardmaker"],
  Helions:["hellspawn","roach","defiler","blood","spitter"]
};
const ALL_FACTIONS = ["Helions","Aesir","Vanir"];

/* ---------------- Helpers & state ---------------- */
const pKey = (i)=> i===0 ? "p0" : "p1";
const idx=(x,y)=> y*W+x;
const inside=(x,y)=> x>=0 && x<W && y>=0 && y<H;

/* rank color map */
function rankColor(lvl){
  if (lvl===3) return getComputedStyle(document.documentElement).getPropertyValue('--rank3') || '#ef4444';
  if (lvl===2) return getComputedStyle(document.documentElement).getPropertyValue('--rank2') || '#eab308';
  return getComputedStyle(document.documentElement).getPropertyValue('--rank1') || '#22c55e';
}

let S=null, lobbyPlayers=[], meIndex=0, isHost=false;
const fieldEmpty = ()=>({units:[], poison:[], toxic:[], acid:[], wards:[], fx:[]});

/* 2√ó2 helpers (guardians/defilers now 1√ó1 but keep generic) */
function unitSize(u){ return TROOPS[u.type]?.size===2 ? 2 : 1; }
function rectangleFree(units,x,y,size){
  for(let yy=0; yy<size; yy++){
    for(let xx=0; xx<size; xx++){
      const nx=x+xx, ny=y+yy;
      if(!inside(nx,ny)) return false;
      if (units.some(o=>{
        const os=unitSize(o);
        return nx>=o.x && nx<o.x+os && ny>=o.y && ny<o.y+os;
      })) return false;
    }
  }
  return true;
}
function canMoveTo(u, units, nx, ny){
  const s = unitSize(u);
  return rectangleFree(units.filter(o=>o.id!==u.id), nx, ny, s);
}

/* Spawns */
function bandRows(p, role){
  if (p===0){
    return role==="back" ? [H-1,H-2,H-3] : [H-6,H-5,H-4];
  }else{
    return role==="back" ? [0,1,2] : [3,4,5];
  }
}
function spawnSlot(state,p,typeKey){
  const role = TROOPS[typeKey]?.role || "front";
  const sz = TROOPS[typeKey]?.size===2 ? 2 : 1;
  const rows = bandRows(p, role);
  for(const r of rows){
    const cx=Math.floor(W/2), order=[0,-1,1,-2,2,-3,3,-4,4];
    for(const dx of order){
      const x=Math.max(0,Math.min(W-sz,cx+dx));
      const y=r;
      if (rectangleFree(state.field.units, x, y, sz)) return {x,y};
    }
  }
  if (p===0){
    for(let y=H-1;y>=Math.max(0,H-8);y--) for(let x=0;x<=W-sz;x++) if (rectangleFree(state.field.units,x,y,sz)) return {x,y};
  }else{
    for(let y=0; y<Math.min(H,8); y++) for(let x=0;x<=W-sz;x++) if (rectangleFree(state.field.units,x,y,sz)) return {x,y};
  }
  return {x:Math.max(0,Math.min(W-sz, Math.floor(W/2))), y:(p===0? H-2 : 1)};
}
function placeUnit(state,p,key,lvl){
  const t=TROOPS[key]; if(!t) return;
  const spawnCount = Math.max(1, t.spawn||1);
  for(let k=0;k<spawnCount;k++){
    const pos=spawnSlot(state,p,key);
    const b=t.base, size = t.size===2?2:1;
    const u={
      id:crypto.randomUUID(), p, type:key, x:pos.x, y:pos.y, lvl,
      maxhp:Math.round((b.hp||10)), hp:Math.round((b.hp||10)),
      dmg:Math.round((b.dmg||3)), spd: b.spd ?? 1, range:b.range ?? 1,
      cd: Math.round((b.cd ?? 600)*PACE.atkMult),
      splash1:!!b.splash1, knock:!!b.knock, strongKnock:!!b.strongKnock, hunterRanged:!!b.hunterRanged,
      blink50:!!b.blink50, blinked:false, chain3:!!b.chain3,
      kamikaze:!!b.kamikaze, paints:!!b.paints, size,
      heal:!!b.heal, healAmt:b.healAmt||0, healRange:b.healRange||0, healCd:b.healCd||0,
      ward:!!b.ward, wardCd:b.wardCd||0, wardDur:b.wardDur||0, wardHp:b.wardHp||1,
      acid:!!b.acid, acidDur:b.acidDur||0,
      toxicSplash:!!b.toxicSplash,
      nextAtk:0, nextHeal:0, nextWard:0, slowUntil:0,
      nextStep:0
    };
    /* NEW: +33% per level (L1=1.00, L2=1.33, L3=1.66) */
    const mult = 1 + 0.33 * Math.max(0, (lvl||1)-1);
    u.maxhp = Math.round(u.maxhp*mult);
    u.hp    = u.maxhp;
    u.dmg   = Math.max(1, Math.round(u.dmg*mult));
    state.field.units.push(u);
  }
}
function rebuildFieldFromRoster(state){
  state.field = state.field || fieldEmpty();
  state.field.units = [];
  state.field.poison = state.field.poison || [];
  state.field.toxic  = state.field.toxic  || [];
  state.field.acid   = state.field.acid   || [];
  state.field.wards  = state.field.wards  || [];
  for(let p=0;p<2;p++){
    const rk = pKey(p);
    const roster = (state.roster?.[rk]||[]);
    const fronts = roster.filter(r=>TROOPS[r.type]?.role==="front");
    const backs  = roster.filter(r=>TROOPS[r.type]?.role!=="front");
    for(const r of fronts){ for(let c=0;c<r.count;c++) placeUnit(state,p,r.type,r.lvl); }
    for(const r of backs ){ for(let c=0;c<r.count;c++) placeUnit(state,p,r.type,r.lvl); }
  }
}

/* Draft packs (unchanged logic, specials are targeted) */
function ownedTypes(roster){ return (roster||[]).filter(r=>r.count>0).map(r=>r.type); }
function weightedPick(pool, n){
  const out=[]; const copy=[...pool];
  for(let k=0;k<n && copy.length;k++){
    const sum = copy.reduce((a,b)=>a+b.w,0);
    let r = Math.random()*sum, i=0;
    for(; i<copy.length; i++){ r-=copy[i].w; if(r<=0) break; }
    out.push(copy[i].item); copy.splice(i,1);
  }
  return out;
}
function packFor(roster, faction){
  const poolTypes = FACTIONS[faction] || [];
  const troopCards = poolTypes.map(k=>({type:"troop", key:k, name:TROOPS[k].name, emoji: unitEmoji(k), role:TROOPS[k].role}));
  const types = ownedTypes(roster);
  const specials=[];
  if (types.length){
    const up = types[Math.floor(Math.random()*types.length)];
    specials.push({type:"special", special:"upgrade", for:up, name:`Upgrade ${TROOPS[up].name}`, emoji:"‚¨ÜÔ∏è"});
    const db = types[Math.floor(Math.random()*types.length)];
    specials.push({type:"special", special:"double", for:db, name:`Double ${TROOPS[db].name}`, emoji:"üÉè"});
  }
  const pool = [
    ...troopCards.map(item=>({item,w:3})),
    ...specials.map(item=>({item,w:1})) // ~33%
  ];
  return weightedPick(pool, 3);
}

/* Roster ops */
function rosterAdd(roster, type, inc=1){ const f=roster.find(r=>r.type===type); if (f) f.count+=inc; else roster.push({type, lvl:1, count:inc}); }
function rosterDoubleOneSpecific(roster, type){ const f=roster.find(r=>r.type===type); if(!f) return; f.count += Math.max(1,f.count); }
function rosterUpgradeOneSpecific(roster, type){ const f=roster.find(r=>r.type===type && r.lvl<3); if(!f) return; f.lvl++; }

/* VFX helpers */
function fxBeam(x1,y1,x2,y2){ return { id:crypto.randomUUID(), type:"beam", x1,y1,x2,y2, at:Date.now(), ttl:350 }; }
function fxHeal(x1,y1,x2,y2){ return { id:crypto.randomUUID(), type:"hbeam", x1,y1,x2,y2, at:Date.now(), ttl:350 }; }
function fxBurst(cx,cy){ return { id:crypto.randomUUID(), type:"burst", cx,cy, at:Date.now(), ttl:700 }; }
function unitEmoji(type){ return TROOPS[type]?.emoji || "‚ùì"; }
function centerPx(x,y){
  const left = x*(CELL+GAP) + CELL/2;
  const top  = y*(CELL+GAP) + CELL/2;
  return {left, top};
}
function renderBeam(ev, heal=false){
  const a = centerPx(ev.x1,ev.y1), b=centerPx(ev.x2,ev.y2);
  const dx=b.left-a.left, dy=b.top-a.top, len=Math.hypot(dx,dy), ang=Math.atan2(dy,dx);
  const el=document.createElement("div"); el.className= heal? "hbeam" : "beam";
  el.style.left = a.left + "px";
  el.style.top  = a.top  + "px";
  el.style.width = Math.max(1,len) + "px";
  el.style.transform = `rotate(${ang}rad)`;
  beamsEl.appendChild(el);
  setTimeout(()=>el.remove(), ev.ttl);
}
function renderBurst(ev){
  for(let i=0;i<10;i++){
    const dot=document.createElement("div"); dot.className="p";
    const offx = (Math.random()*14-7), offy=(Math.random()*14-7);
    const a=centerPx(ev.cx,ev.cy);
    dot.style.left = (a.left + offx) + "px";
    dot.style.top  = (a.top + offy) + "px";
    partsEl.appendChild(dot);
    setTimeout(()=>dot.remove(), ev.ttl);
  }
}
function groundTickParticles(x,y, purple=false){
  const a=centerPx(x,y);
  for(let i=0;i<4;i++){
    const dot=document.createElement("div"); dot.className="p"; if (purple) dot.classList.add("purple");
    const offx = (Math.random()*10-5), offy=(Math.random()*6-3);
    dot.style.left = (a.left + offx) + "px";
    dot.style.top  = (a.top + offy) + "px";
    partsEl.appendChild(dot);
    setTimeout(()=>dot.remove(), 550);
  }
}
function flashAt(x,y, dmgNum){
  const i=idx(x,y); const cell=cellsEl.children[i]; if (!cell) return;
  const f=document.createElement("div"); f.className="hitflash"; cell.appendChild(f);
  setTimeout(()=>f.remove(), 140);
  if (dmgNum>0){
    const t=document.createElement("div"); t.className="dmg"; t.textContent=`-${dmgNum}`;
    cell.appendChild(t); setTimeout(()=>t.remove(), 650);
  }
}

/* Painting board ‚Äî NOW BY RANK, not team */
function paint(units, field){
  const total=W*H;
  for(let i=0;i<total;i++){
    const d=cellsEl.children[i];
    const under=d.querySelector(".under"); under.style.background="transparent";
    const uni=d.querySelector(".unit"); uni.textContent="";
    d.querySelector(".hp>i").style.width="0%";
    d.querySelector(".poison")?.remove();
    d.querySelector(".toxic")?.remove();
    d.querySelector(".acid")?.remove();
    d.querySelector(".ward")?.remove();
  }
  const now=Date.now();
  (field.poison||[]).forEach(p=>{
    if (p.until<=now) return;
    const i=idx(p.x,p.y); const d=cellsEl.children[i]; if (!d) return;
    d.appendChild(Object.assign(document.createElement("div"),{className:"poison"}));
  });
  (field.toxic||[]).forEach(t=>{
    if (t.until<=now) return;
    const i=idx(t.x,t.y); const d=cellsEl.children[i]; if (!d) return;
    d.appendChild(Object.assign(document.createElement("div"),{className:"toxic"}));
  });
  (field.acid||[]).forEach(a=>{
    if (a.until<=now) return;
    const i=idx(a.x,a.y); const d=cellsEl.children[i]; if (!d) return;
    d.appendChild(Object.assign(document.createElement("div"),{className:"acid"}));
  });
  (field.wards||[]).forEach(w=>{
    if (w.until<=now || w.hp<=0) return;
    const i=idx(w.x,w.y); const d=cellsEl.children[i]; if(!d) return;
    d.appendChild(Object.assign(document.createElement("div"),{className:"ward"}));
  });

  for(const u of units){
    const s = unitSize(u);
    const color = rankColor(u.lvl||1).trim() || '#22c55e';
    for(let yy=0; yy<s; yy++){
      for(let xx=0; xx<s; xx++){
        const i=idx(u.x+xx,u.y+yy); const d=cellsEl.children[i]; if(!d) continue;
        const under=d.querySelector(".under");
        /* Fill by RANK (solid), not team */
        under.style.background = color;
      }
    }
    const i0=idx(u.x,u.y), d0=cellsEl.children[i0]; if(!d0) continue;
    const uni=d0.querySelector(".unit");
    uni.style.zIndex = "3";                 // emoji above fill & effects
    uni.style.fontSize = s===2 ? "32px" : "26px";
    uni.textContent = unitEmoji(u.type);
    const hp=d0.querySelector(".hp>i");
    hp.style.width = Math.max(0,Math.round(100*u.hp/u.maxhp))+"%";
  }
}

/* Ranged helpers & AI */
function unitCenter(u){ return { x: u.x + (unitSize(u)-1)/2, y: u.y + (unitSize(u)-1)/2 }; }
function nearestEnemy(u,units){
  let b=null,bd=1e9; const c=unitCenter(u);
  for(const v of units){ if(v.p===u.p) continue;
    const d=Math.abs(unitCenter(v).x-c.x)+Math.abs(unitCenter(v).y-c.y);
    if(d<bd){bd=d;b=v;}
  } return b;
}
function nearestEnemyRangedPriority(u,units){
  const ranged=units.filter(v=>v.p!==u.p && TROOPS[v.type]?.role==="back");
  if(ranged.length){
    let b=null,bd=1e9; const c=unitCenter(u);
    for(const v of ranged){ const d=Math.abs(unitCenter(v).x-c.x)+Math.abs(unitCenter(v).y-c.y); if(d<bd){bd=d;b=v;} }
    return b;
  }
  return nearestEnemy(u,units);
}
function manhattanUnits(u,t){
  const a=unitCenter(u), b=unitCenter(t);
  return Math.abs(a.x-b.x)+Math.abs(a.y-b.y);
}
function stepToward(u,t,units){
  const a=unitCenter(u), b=unitCenter(t);
  const dx=b.x-a.x, dy=b.y-a.y;
  const sx=Math.sign(dx), sy=Math.sign(dy);
  const absx=Math.abs(dx), absy=Math.abs(dy);
  const opts = (absx>=absy)
    ? [[u.x+sx,u.y],[u.x,u.y+sy],[u.x-sx,u.y],[u.x,u.y-sy]]
    : [[u.x,u.y+sy],[u.x+sx,u.y],[u.x,u.y-sy],[u.x-sx,u.y]];
  for(const p of opts){
    if (canMoveTo(u,units,p[0],p[1])){ u.x=p[0]; u.y=p[1]; return; }
  }
}
function canStepNow(u, now){
  if (!u.nextStep || now>=u.nextStep){ u.nextStep = now + MOVE_MS; return true; }
  return false;
}
function blinkIfNeeded(u){
  if(!u.blink50 || u.blinked) return;
  if (u.hp <= 0.5*u.maxhp){
    const dir = (u.p===0? +1 : -1);
    for(let i=0;i<3;i++){
      const nx=u.x, ny=u.y+dir;
      if (!inside(nx,ny)) break;
      if (canMoveTo(u, S.field.units, nx, ny)){ u.x=nx; u.y=ny; }
    }
    u.blinked=true;
  }
}
function tilesOnLine(x1,y1,x2,y2){
  const tiles=[]; const dx=x2-x1, dy=y2-y1; const steps = Math.max(Math.abs(dx), Math.abs(dy));
  if (steps===0){ tiles.push({x:Math.round(x1),y:Math.round(y1)}); return tiles; }
  const sx=dx/steps, sy=dy/steps; let x=x1, y=y1;
  for(let i=0;i<=steps;i++){ tiles.push({x:Math.round(x), y:Math.round(y)}); x+=sx; y+=sy; }
  return tiles;
}
function beamBlockedByWard(u,t, wards){
  const a=unitCenter(u), b=unitCenter(t);
  const path=tilesOnLine(a.x,a.y,b.x,b.y);
  for(const pt of path){
    const w = wards.find(w2=>w2.hp>0 && w2.x===Math.round(pt.x) && w2.y===Math.round(pt.y) && w2.until>Date.now());
    if (w) return w;
  }
  return null;
}

/* Combat & abilities */
function healAction(u, st, now){
  if (!u.heal) return false;
  if (now < (u.nextHeal||0)) return false;
  const allies = st.field.units.filter(v=>v.p===u.p && v.id!==u.id && v.hp>0);
  if (!allies.length) return false;
  let target=null, minRatio=1.01;
  for(const a of allies){
    const dist = Math.abs(unitCenter(a).x-unitCenter(u).x)+Math.abs(unitCenter(a).y-unitCenter(u).y);
    if (dist <= (u.healRange||2)){
      const r = a.hp/a.maxhp;
      if (r < minRatio){ minRatio = r; target=a; }
    }
  }
  if (!target) return false;
  const amt = Math.max(1, u.healAmt|0);
  target.hp = Math.min(target.maxhp, target.hp + amt);
  st.field.fx.push(fxHeal(u.x,u.y,target.x,target.y));
  u.nextHeal = now + (u.healCd||1200);
  return true;
}
function wardAction(u, st, now){
  if (!u.ward) return false;
  if (now < (u.nextWard||0)) return false;
  const dir = u.p===0 ? -1 : +1;
  const tx=u.x, ty=u.y+dir;
  if (inside(tx,ty)){
    if (placeWard(st, tx,ty, u.wardHp||2, u.wardDur||6000)){
      u.nextWard = now + (u.wardCd||1700);
      return true;
    }
  }
  return false;
}
function applyDamage(victim, dmg){
  victim.hp -= dmg;
  flashAt(victim.x, victim.y, dmg);
}
function splash(units,x,y,dmg,srcP,kn,strong=false){
  for(let dy=-1;dy<=1;dy++){
    for(let dx=-1;dx<=1;dx++){
      const nx=x+dx, ny=y+dy; if(!inside(nx,ny)) continue;
      const hit=units.find(o=>o.p!==srcP && nx>=o.x && nx<o.x+unitSize(o) && ny>=o.y && ny<o.y+unitSize(o));
      if(hit){ applyDamage(hit,dmg); if(kn) tryKnock(x,y,hit,units,strong); }
    }
  }
}
function tryKnock(cx,cy,t,units,strong=false){
  const tcx=t.x+(unitSize(t)-1)/2, tcy=t.y+(unitSize(t)-1)/2;
  const dx=Math.sign(tcx-cx), dy=Math.sign(tcy-cy);
  let steps = strong ? 2 : 1;
  while(steps>0){
    const nx=t.x+dx, ny=t.y+dy;
    if (canMoveTo(t, units, nx, ny)){ t.x=nx; t.y=ny; steps--; } else break;
  }
}
function chainLightning(units, startTarget, srcP, hops, dmg){
  let cur = startTarget; let left=hops; const hit=new Set();
  while(cur && left>0){
    applyDamage(cur,dmg); hit.add(cur.id);
    let cand=null,bd=1e9; const cx=cur.x, cy=cur.y;
    for(const v of units){
      if(v.p===srcP || hit.has(v.id)) continue;
      const d=Math.abs(v.x-cx)+Math.abs(v.y-cy);
      if(d<=2 && d<bd){ bd=d; cand=v; }
    }
    cur=cand; left--;
  }
}
function attack(u,t,now,st){
  const inRange = manhattanUnits(u,t) <= (u.range||1);
  if(!inRange) return false;
  if(now < (u.nextAtk||0)) return true;

  const ranged = (u.range||1) > 1;
  if (ranged){
    const ward = beamBlockedByWard(u,t, st.field.wards||[]);
    if (ward){
      st.field.fx.push(fxBeam(u.x,u.y,ward.x,ward.y));
      ward.hp -= 1;
      u.nextAtk = now + (u.cd||600);
      return true;
    }
  }

  if (u.kamikaze){
    st.field.fx.push(fxBurst(u.x,u.y));
    applyDamage(t,u.dmg);
    if (u.splash1) splash(st.field.units, t.x,t.y, Math.max(1,Math.floor(u.dmg*0.6)), u.p, true);
    if (u.paints) paintPoison(st, u.x, u.y, 7000);
    u.hp=0;
  } else if (u.type==="vrocket"){
    st.field.fx.push(fxBeam(u.x,u.y,t.x,t.y));
    applyDamage(t,u.dmg);
    splash(st.field.units, t.x,t.y, Math.max(1,Math.floor(u.dmg*0.6)), u.p, true);
  } else if (u.chain3){
    st.field.fx.push(fxBeam(u.x,u.y,t.x,t.y));
    chainLightning(st.field.units,t,u.p,3, u.dmg);
  } else if (u.acid){
    st.field.fx.push(fxBeam(u.x,u.y,t.x,t.y));
    applyDamage(t,u.dmg);
    addAcid(st, t.x, t.y, TROOPS[u.type].base.acidDur||3500);
  } else {
    if (ranged) st.field.fx.push(fxBeam(u.x,u.y,t.x,t.y));
    applyDamage(t,u.dmg);
    const strong = !!u.strongKnock;
    if (u.splash1) splash(st.field.units, t.x,t.y, Math.max(1,Math.floor(u.dmg*0.6)), u.p, !!u.knock, strong);
    /* NEW: Defiler toxic splash (10s) */
    if (u.toxicSplash){
      addToxicSplash(st, t.x, t.y, 7_000);
    }
  }
  u.nextAtk = now + (u.cd||600);
  return true;
}

/* Terrain */
function paintPoison(state, cx, cy, durMs){
  const until = Date.now()+durMs;
  state.field.poison = state.field.poison || [];
  for(let dy=-1;dy<=1;dy++){
    for(let dx=-1;dx<=1;dx++){
      const x=cx+dx, y=cy+dy; if(!inside(x,y)) continue;
      state.field.poison.push({x,y,until});
    }
  }
}
/* NEW: toxic (purple) DoT area for Defiler ‚Äî 3x3 around impact */
function addToxicSplash(state, cx, cy, durMs){
  const until = Date.now()+durMs;
  state.field.toxic = state.field.toxic || [];
  for(let dy=-1;dy<=1;dy++){
    for(let dx=-1;dx<=1;dx++){
      const x=cx+dx, y=cy+dy; if(!inside(x,y)) continue;
      state.field.toxic.push({x,y,until});
    }
  }
}
function addAcid(state, x,y, durMs){
  if(!inside(x,y)) return;
  state.field.acid = state.field.acid || [];
  state.field.acid.push({x,y,until:Date.now()+durMs});
}
function placeWard(state, x,y, hp, dur){
  if(!inside(x,y)) return false;
  if (state.field.wards.some(w=>w.x===x&&w.y===y)) return false;
  state.field.wards.push({x,y,hp,until:Date.now()+dur});
  return true;
}
function applyTerrain(field, units){
  const now=Date.now();
  (field.poison||[]).forEach(p=>{
    if (p.until<=now) return;
    let ticked=false;
    for(const u of units){
      if (u.x<=p.x && p.x<u.x+unitSize(u) && u.y<=p.y && p.y<u.y+unitSize(u)){
        u.slowUntil = Math.max(u.slowUntil||0, now+PACE.poisonSlowMs);
        if (!u._poisonTick || now - u._poisonTick >= PACE.poisonDotMs){
          u._poisonTick = now; u.hp = u.hp - 1; flashAt(u.x,u.y,1); ticked=true;
        }
      }
    }
    if (ticked) groundTickParticles(p.x,p.y,false);
  });
  /* NEW: toxic purple ‚Äî damage over 10s, no slow */
  (field.toxic||[]).forEach(t=>{
    if (t.until<=now) return;
    let ticked=false;
    for(const u of units){
      if (u.x<=t.x && t.x<u.x+unitSize(u) && u.y<=t.y && t.y<u.y+unitSize(u)){
        if (!u._toxicTick || now - u._toxicTick >= PACE.toxicDotMs){
          u._toxicTick = now; u.hp = u.hp - 1; flashAt(u.x,u.y,1); ticked=true;
        }
      }
    }
    if (ticked) groundTickParticles(t.x,t.y,true);
  });
  (field.acid||[]).forEach(a=>{
    if (a.until<=now) return;
    let ticked=false;
    for(const u of units){
      if (u.x<=a.x && a.x<u.x+unitSize(u) && u.y<=a.y && a.y<u.y+unitSize(u)){
        u.slowUntil = Math.max(u.slowUntil||0, now+800);
        if (!u._acidTick || now - u._acidTick >= 1100){
          u._acidTick = now; u.hp = u.hp - 1; flashAt(u.x,u.y,1); ticked=true;
        }
      }
    }
    if (ticked) groundTickParticles(a.x,a.y,true);
  });
}

/* Init & host loops (unchanged flow) */
async function ensureStateExists(){
  const lobSnap = await getDoc(lobbyRef);
  if (!lobSnap.exists()) return false;
  const lob=lobSnap.data();
  lobbyPlayers=(Array.isArray(lob.players)? lob.players:[]).slice(0,2);
  isHost = lob.host===username;

  await runTransaction(db, async tx=>{
    const st=await tx.get(stateRef);
    if (st.exists()) return;
    const now=Date.now();
    tx.set(stateRef,{
      players:lobbyPlayers, lives:[4,4],
      phase: lobbyPlayers.length<2? "waiting":"faction-select",
      phaseEndsAt: lobbyPlayers.length<2?0:now+20_000,
      roster:{p0:[],p1:[]}, factions:{p0:null,p1:null},
      field:fieldEmpty(),
      selections:{p0:[],p1:[]},
      currentPacks:{p0:[],p1:[]},
      bonusFor:null,
      draftIndex:0, winner:null
    });
  });
}
async function syncPlayersIntoStateIfNeeded(){
  const st = (await getDoc(stateRef)).data(); if(!st) return;
  const want = lobbyPlayers.slice(0,2);
  const cur = Array.isArray(st.players)? st.players : [];
  if (want.length && (cur.length!==want.length || cur.some((n,i)=>n!==want[i]))){
    await updateDoc(stateRef, { players: want });
  }
}
function bothPicked(d){
  const di=d.draftIndex|0;
  return (d.selections?.p0?.[di] != null) && (d.selections?.p1?.[di] != null);
}
function bothFactionsChosen(d){
  return !!(d.factions?.p0) && !!(d.factions?.p1);
}

let hostTick=null, battleTick=null;
function startHostLoops(){
  if(hostTick) return;
  hostTick=setInterval(async ()=>{
    const snap=await getDoc(stateRef); if(!snap.exists()) return;
    const d=snap.data(); const now=Date.now();

    if (d.phase==="waiting" && lobbyPlayers.length>=2){
      await updateDoc(stateRef,{ phase:"faction-select", phaseEndsAt: now+20_000 });
      return;
    }
    if (d.phase==="faction-select"){
      if (bothFactionsChosen(d) || now >= (d.phaseEndsAt||0)){
        const fx={...d.factions};
        if(!fx.p0) fx.p0 = ALL_FACTIONS[Math.floor(Math.random()*ALL_FACTIONS.length)];
        if(!fx.p1) fx.p1 = ALL_FACTIONS[Math.floor(Math.random()*ALL_FACTIONS.length)];
        await updateDoc(stateRef,{
          factions:fx, phase:"draft", draftIndex:0,
          selections:{p0:[],p1:[]},
          currentPacks:{
            p0: packFor(d.roster?.p0||[], fx.p0),
            p1: packFor(d.roster?.p1||[], fx.p1)
          },
          phaseEndsAt: now+10_000,
          bonusFor:null
        });
      }
      return;
    }

    if (d.phase==="draft" && (bothPicked(d) || now >= (d.phaseEndsAt||0))){
      const di=d.draftIndex|0;
      const sel=d.selections||{p0:[],p1:[]};

      ["p0","p1"].forEach(sk=>{
        if (sel[sk][di]==null){
          const pack=(d.currentPacks?.[sk]||[]);
          sel[sk][di] = Math.floor(Math.random()*Math.max(1,pack.length));
        }
      });

      const roster=d.roster||{p0:[],p1:[]};
      ["p0","p1"].forEach(sk=>{
        const pack=(d.currentPacks?.[sk]||[]);
        const pick=pack[ sel[sk][di] ];
        if(!pick) return;
        if (pick.type==="troop") rosterAdd(roster[sk], pick.key, 1);
        else if (pick.type==="special"){
          if(pick.special==="double") rosterDoubleOneSpecific(roster[sk], pick.for);
          if(pick.special==="upgrade") rosterUpgradeOneSpecific(roster[sk], pick.for);
        }
      });

      const nextIx=di+1;
      if (nextIx>=3){
        const next={...d, roster, selections:{p0:[],p1:[]}, draftIndex:0, currentPacks:{p0:[],p1:[]}, phase:"battle", phaseEndsAt:0, field:fieldEmpty(), bonusFor:null};
        rebuildFieldFromRoster(next);
        await updateDoc(stateRef,next);
        runBattle();
      }else{
        await updateDoc(stateRef,{
          roster, selections:sel, draftIndex:nextIx,
          currentPacks:{
            p0: packFor(roster.p0, d.factions.p0),
            p1: packFor(roster.p1, d.factions.p1)
          },
          phaseEndsAt: Date.now()+10_000,
          bonusFor:null
        });
      }
      return;
    }

    if (d.phase==="loser-bonus"){
      const loser = d.bonusFor;
      const di=d.draftIndex|0;
      const sel=d.selections||{p0:[],p1:[]};

      if (sel[loser]?.[di]==null && now >= (d.phaseEndsAt||0)){
        const pack=(d.currentPacks?.[loser]||[]);
        sel[loser][di] = Math.floor(Math.random()*Math.max(1,pack.length));
      }
      const hasPicked = sel[loser]?.[di]!=null;
      if (hasPicked){
        const roster=d.roster||{p0:[],p1:[]};
        const pack=(d.currentPacks?.[loser]||[]);
        const pick=pack[ sel[loser][di] ];
        if (pick){
          if (pick.type==="troop") rosterAdd(roster[loser], pick.key, 1);
          else if (pick.type==="special"){
            if(pick.special==="double") rosterDoubleOneSpecific(roster[loser], pick.for);
            if(pick.special==="upgrade") rosterUpgradeOneSpecific(roster[loser], pick.for);
          }
        }
        await updateDoc(stateRef,{
          roster,
          selections:{p0:[],p1:[]},
          draftIndex:0,
          currentPacks:{
            p0: packFor(roster.p0, d.factions.p0),
            p1: packFor(roster.p1, d.factions.p1)
          },
          phase:"draft-after",
          phaseEndsAt: Date.now()+10_000,
          bonusFor:null
        });
      }
      return;
    }

    if (d.phase==="draft-after" && (bothPicked(d) || now >= (d.phaseEndsAt||0))){
      const di=d.draftIndex|0;
      const sel=d.selections||{p0:[],p1:[]};

      ["p0","p1"].forEach(sk=>{
        if (sel[sk][di]==null){
          const pack=(d.currentPacks?.[sk]||[]);
          sel[sk][di] = Math.floor(Math.random()*Math.max(1,pack.length));
        }
      });

      const roster=d.roster||{p0:[],p1:[]};
      ["p0","p1"].forEach(sk=>{
        const pack=(d.currentPacks?.[sk]||[]);
        const pick=pack[ sel[sk][di] ];
        if(!pick) return;
        if (pick.type==="troop") rosterAdd(roster[sk], pick.key, 1);
        else if (pick.type==="special"){
          if(pick.special==="double") rosterDoubleOneSpecific(roster[sk], pick.for);
          if(pick.special==="upgrade") rosterUpgradeOneSpecific(roster[sk], pick.for);
        }
      });

      const nextIx=di+1;
      if (nextIx>=3){
        const next={...d, roster, selections:{p0:[],p1:[]}, draftIndex:0, currentPacks:{p0:[],p1:[]}, phase:"battle", phaseEndsAt:0, field:fieldEmpty()};
        rebuildFieldFromRoster(next);
        await updateDoc(stateRef,next);
        runBattle();
      }else{
        await updateDoc(stateRef,{
          roster, selections:sel, draftIndex:nextIx,
          currentPacks:{
            p0: packFor(roster.p0, d.factions.p0),
            p1: packFor(roster.p1, d.factions.p1)
          },
          phaseEndsAt: Date.now()+10_000
        });
      }
      return;
    }

    if (d.phase==="battle" && !battleTick) runBattle();

    // prune expired tiles/fx
    const nf = {...d.field};
    const now2=Date.now();
    nf.fx    = (nf.fx||[]).filter(ev=>ev.at+ev.ttl > now2);
    nf.poison= (nf.poison||[]).filter(p=>p.until>now2);
    nf.toxic = (nf.toxic ||[]).filter(t=>t.until>now2);
    nf.acid  = (nf.acid  ||[]).filter(a=>a.until>now2);
    nf.wards = (nf.wards ||[]).filter(w=>w.until>now2 && w.hp>0);
    if (JSON.stringify(nf) !== JSON.stringify(d.field)){
      await updateDoc(stateRef, { field: nf });
    }
  }, 260);
}

/* ----------- Battle loop (fast view, gated logic) ----------- */
function runBattle(){
  if(battleTick) return;

  let lastLogic = 0;

  battleTick = setInterval(async ()=>{
    const snap=await getDoc(stateRef); if(!snap.exists()){ clearInterval(battleTick); battleTick=null; return; }
    const d=snap.data(); if(d.phase!=="battle"){ clearInterval(battleTick); battleTick=null; return; }
    const st=structuredClone(d);
    const units=st.field.units; const now=Date.now();

    const doLogic = (now - lastLogic) >= LOGIC_MS;
    if (doLogic) lastLogic = now;

    if (doLogic) applyTerrain(st.field, units);
    if (doLogic) for(const u of units){ blinkIfNeeded(u); }

    for(const u of units){
      if (doLogic) {
        healAction(u, st, now);
        wardAction(u, st, now);
      }
      const t = u.hunterRanged ? nearestEnemyRangedPriority(u,units) : nearestEnemy(u,units);
      if(!t) continue;

      const attacked = attack(u,t,now,st); // time-gated by nextAtk
      if (!attacked && doLogic) {
        if (canStepNow(u, now)) {
          const slowed=(u.slowUntil && u.slowUntil>now);
          const steps = slowed ? 1 : PACE.moveSteps;
          for(let s=0;s<steps;s++){
            const t2 = u.hunterRanged ? nearestEnemyRangedPriority(u,units) : nearestEnemy(u,units);
            if(!t2) break;
            stepToward(u,t2,units);
            if (manhattanUnits(u,t2) <= (u.range||1)){ attack(u,t2,now,st); break; }
          }
        }
      }
    }

    if (doLogic){
      const dead = st.field.units.filter(u=>u.hp<=0);
      for(const u of dead){
        if (u.paints){ paintPoison(st, u.x, u.y, 7000); st.field.fx.push(fxBurst(u.x,u.y)); }
      }
      st.field.units = st.field.units.filter(u=>u.hp>0);
    }

    const a0=st.field.units.some(u=>u.p===0), a1=st.field.units.some(u=>u.p===1);
    if(!a0 || !a1){
      clearInterval(battleTick); battleTick=null;
      const loser = a0?1:0;
      const lives=[...(st.lives||[4,4])]; lives[loser]=Math.max(0,lives[loser]-1);
      const winner = lives[0]===0 ? st.players[1] : (lives[1]===0 ? st.players[0] : null);

      if (winner){
        const next = { ...st, lives, phase:"game-over", phaseEndsAt:0, winner };
        await updateDoc(stateRef,next);
      }else{
        const loserKey = pKey(loser);
        const winnerKey = pKey(1-loser);
        const next = {
          ...st,
          lives,
          phase: "loser-bonus",
          phaseEndsAt: Date.now()+10_000,
          selections:{p0:[],p1:[]},
          currentPacks: {
            [loserKey]:  packFor(st.roster[loserKey],  st.factions[loserKey]),
            [winnerKey]: []
          },
          draftIndex:0,
          bonusFor: loserKey
        };
        await updateDoc(stateRef,next);
      }
    }else{
      // publish frequently for smooth remote viewing
      await updateDoc(stateRef,st);
    }
  }, VIEW_MS);
}

/* ----------- Live listeners & render ----------- */
function render(){
  const p0n=(S?.players?.[0])||"P0", p1n=(S?.players?.[1])||"P1";
  const lives=S?.lives||[4,4];
  $("p0Badge").textContent = `${p0n} ‚Äî ${"‚ù§".repeat(lives[0])}`;
  $("p1Badge").textContent = `${p1n} ‚Äî ${"‚ù§".repeat(lives[1])}`;

  const phase=S?.phase||"waiting";
  $("phaseBadge").textContent = phase.replaceAll("-"," ");
  const draftish=["faction-select","draft","loser-bonus","draft-after"].includes(phase);
  const tleft = draftish ? Math.max(0,(S?.phaseEndsAt||0)-Date.now()) : 0;
  $("timerBadge").textContent = draftish ? `‚è≥ ${Math.ceil(tleft/1000)}s` : "‚è≥ ‚Äî";

  const counter = $("pickCounter");
  if (phase==="draft" || phase==="draft-after"){
    counter.style.display="block";
    counter.textContent = `Pick ${(S?.draftIndex||0)+1} / 3`;
  } else if (phase==="loser-bonus"){
    counter.style.display="block"; counter.textContent = `Bonus 1 / 1`;
  } else { counter.style.display="none"; }

  if (draftish){
    const ghost=structuredClone(S); rebuildFieldFromRoster(ghost);
    paint(ghost.field.units, ghost.field);
  }else{
    paint(S?.field?.units||[], S?.field||fieldEmpty());
  }

  const row=$("cardRow"), overlay=$("overlay"), note=$("pickNote");
  if (!draftish){ overlay.style.display="none"; row.style.display="none"; note.style.display="none"; row.innerHTML=""; return; }
  overlay.style.display="block";

  const di=S?.draftIndex|0;
  const sk=pKey(meIndex);
  const pickedIndex=S?.selections?.[sk]?.[di];

  if (phase==="faction-select"){
    const already=S?.factions?.[sk];
    if (already){ row.style.display="none"; row.innerHTML=""; note.textContent=`Selected: ${already}`; note.style.display="block"; return; }
    row.style.display="flex"; row.innerHTML=""; note.style.display="none";
    ["Helions","Aesir","Vanir"].forEach(f=>{
      const el=document.createElement("div"); el.className="card";
      el.innerHTML=`<div class="title">${f}</div><div class="desc">${(FACTIONS[f]||[]).map(k=>unitEmoji(k)+" "+TROOPS[k].name).join(" ¬∑ ")}</div>`;
      el.onclick=()=> chooseFaction(f); row.appendChild(el);
    });
    return;
  }

  if (phase==="loser-bonus"){
    const loserKey = S?.bonusFor || null;
    if (loserKey !== sk){
      row.style.display="none"; row.innerHTML=""; note.textContent=`Opponent bonus pick‚Ä¶`; note.style.display="block"; return;
    }
  }

  const pack=(S?.currentPacks?.[sk]||[]);
  if (pickedIndex!=null){
    row.style.display="none"; row.innerHTML="";
    const picked = pack[pickedIndex];
    const label = picked
      ? (picked.type==="troop" ? picked.name : `${picked.special==="upgrade"?"Upgrade":"Double"} ${(TROOPS[picked.for]||{}).name||""}`)
      : "(auto)";
    note.textContent=`Selected: ${label}`;
    note.style.display="block";
    return;
  }

  row.style.display="flex"; row.innerHTML=""; note.style.display="none";
  pack.forEach((c,i)=>{
    const el=document.createElement("div"); el.className="card";
    if (c.type==="troop"){
      el.innerHTML=`<div class="title">${c.emoji} ${c.name}</div><div class="desc">${c.role==="back"?"Backline":"Frontline"} ‚Äî ${TROOPS[c.key].faction}</div>`;
    }else{
      const nn=TROOPS[c.for]?.name||"Type";
      el.innerHTML=`<div class="title">${c.emoji} ${c.name|| (c.special==="upgrade"?"Upgrade":"Double")}</div><div class="desc">${c.special==="upgrade"?"Upgrade":"Double"} ${nn}</div>`;
    }
    el.onclick=()=> chooseCard(i);
    row.appendChild(el);
  });
}

async function chooseFaction(fac){
  if(!S) return; const sk=pKey(meIndex);
  if (S.factions?.[sk]) return;
  await updateDoc(stateRef, { [`factions.${sk}`]: fac });
}
async function chooseCard(i){
  if(!S) return; const di=S.draftIndex|0; const sk=pKey(meIndex);
  const already=S.selections?.[sk]?.[di]; if (already!=null) return;
  await updateDoc(stateRef, { [`selections.${sk}.${di}`]: i });
}

/* Listeners */
onSnapshot(lobbyRef, async (snap)=>{
  if (!snap.exists()) return;
  const lob = snap.data();
  lobbyPlayers=(Array.isArray(lob.players)? lob.players:[]).slice(0,2);
  isHost = lob.host===username;

  await ensureStateExists();
  await syncPlayersIntoStateIfNeeded();

  const current = S?.players || lobbyPlayers;
  meIndex = Math.max(0, (current||[]).indexOf(username));

  if (isHost) startHostLoops();
  fitBoard();
  render();
});

let lastFxSeen=new Set();
onSnapshot(stateRef,(snap)=>{
  if(!snap.exists()) return;
  S=snap.data();
  const current = S.players || lobbyPlayers;
  meIndex = Math.max(0, (current||[]).indexOf(username));
  render();

  const list=S.field?.fx||[];
  for(const ev of list){
    if (lastFxSeen.has(ev.id)) continue;
    lastFxSeen.add(ev.id);
    if (ev.type==="beam") renderBeam(ev,false);
    if (ev.type==="hbeam") renderBeam(ev,true);
    if (ev.type==="burst") renderBurst(ev);
    setTimeout(()=> lastFxSeen.delete(ev.id), ev.ttl+200);
  }
});

/* Fullscreen */
$("fsBtn").onclick = async ()=>{
  try{
    if (!document.fullscreenElement) await document.documentElement.requestFullscreen();
    else await document.exitFullscreen();
  }catch(e){}
};
</script>
</body>
</html>















