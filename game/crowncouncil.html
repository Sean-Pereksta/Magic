<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>üëë Crown & Council (Multiplayer)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<style>
  :root{
    --bg:#fff7f7; --ink:#0f172a; --muted:#6b7280; --card:#fff; --br:#f3e2e2;
    --accent:#b91c1c; --accent-2:#991b1b; --accent-soft:#fee2e2;
    --good:#16a34a; --warn:#f59e0b; --bad:#ef4444;
    --shadow:0 10px 30px rgba(15,23,42,.1); --radius:16px; --radius-sm:12px;
    --tap:54px;
    --p0:#ef4444; --p1:#3b82f6; --p2:#10b981; --p3:#f59e0b;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .shell{max-width:1100px;margin:0 auto;padding:10px 12px 26px}

  .topbar{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;margin:8px 0}
  .leftrow{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
  .badge{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border:1px solid var(--br);border-radius:999px;background:var(--card);box-shadow:var(--shadow);font-weight:900;transition:background-color .25s}
  .dot{width:10px;height:10px;border-radius:50%}
  .btn{appearance:none;border:1px solid var(--br);border-radius:12px;padding:12px 14px;font-weight:800;cursor:pointer;background:var(--accent);color:#fff}
  .btn:hover{background:var(--accent-2)}
  .btn-ghost{background:#fff;color:var(--ink)}
  .btn-ghost:hover{background:#fff5f5}
  .mini{padding:8px 10px;border-radius:10px;font-size:.95rem}
  .card{background:var(--card);border:1px solid var(--br);border-radius:var(--radius);box-shadow:var(--shadow)}
  .card-head{padding:12px 14px;border-bottom:1px solid var(--br);display:flex;align-items:center;justify-content:space-between}
  .card-title{font-weight:900}
  .card-body{padding:12px 14px}
  .muted{color:var(--muted)}

  .grid{display:grid;grid-template-columns:2fr 1fr;gap:12px}
  @media (max-width:960px){ .grid{grid-template-columns:1fr} }

  .mapWrap{position:relative;border:1px solid var(--br);border-radius:14px;overflow:hidden;background:#fff}
  .mapHead{display:flex;align-items:center;justify-content:space-between;padding:8px 10px;border-bottom:1px solid var(--br)}
  .mapWindow{position:relative;touch-action:none;width:100%;height:min(70vh,580px);background:#fafafa}
  .mapCanvas{position:absolute; left:0; top:0; transform:translate3d(0,0,0)}
  .tile{position:absolute;width:80px;height:80px;border:2px solid #e5e7eb;border-radius:10px;background:#f3f4f6;display:grid;place-items:center;font-weight:900;user-select:none;-webkit-user-select:none;touch-action:none}
  .tile.owned{background:#fff}
  .tile.sel{outline:3px solid #111827}
  .cap-icon{position:absolute;inset:auto 4px 4px auto;font-size:14px}
  .tile .u{font-size:16px}
  .tile.p0{border-color:var(--p0)}
  .tile.p1{border-color:var(--p1)}
  .tile.p2{border-color:var(--p2)}
  .tile.p3{border-color:var(--p3)}

  .pillrow{display:flex;flex-wrap:wrap;gap:6px;margin:6px 0 0}
  .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border:1px solid var(--br);border-radius:999px;background:#fff;font-weight:800}

  .controls{display:grid;gap:10px}
  .vlist{display:grid;gap:8px;max-height:280px;overflow:auto;padding-right:6px}
  .input, .select{padding:10px 12px;border:1px solid var(--br);border-radius:12px;min-height:44px;background:#fff;font-size:16px;outline:none}
  .input:focus,.select:focus{border-color:#fecaca;box-shadow:0 0 0 4px rgba(239,68,68,.25)}

  .actionbar{position:sticky;bottom:0;left:0;right:0;background:rgba(255,255,255,.96);backdrop-filter:saturate(1.1) blur(6px);border:1px solid var(--br);border-radius:14px;padding:8px 10px;display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:space-between}

  .modal-back{position:fixed;inset:0;background:rgba(0,0,0,.5);display:none;align-items:center;justify-content:center;padding:14px;z-index:1200}
  .modal{width:min(720px,96vw);background:#fff;border:1px solid var(--br);border-radius:16px;box-shadow:var(--shadow);overflow:hidden}
  .modal .head{padding:12px 14px;border-bottom:1px solid var(--br);display:flex;align-items:center;justify-content:space-between}
  .modal .body{padding:12px 14px}
  .opt{padding:10px;border:1px solid var(--br);border-radius:12px;background:#fff;font-weight:800;cursor:pointer}
  .opt:hover{background:#fff5f5}
</style>
</head>
<body>
<div class="shell">
  <div class="topbar">
    <div class="leftrow">
      <span class="badge">üëë Crown & Council</span>
      <span id="statusBadge" class="badge">Loading‚Ä¶</span>
      <span id="roundBadge" class="badge">‚Äî</span>
      <span id="timerBadge" class="badge">‚è≥ ‚Äî</span>
      <span id="moveBadge" class="badge">Moves: 0/‚Äî</span>
      <span id="pointsBadge" class="badge">‚≠ê 0</span>
      <span id="coalitionBadge" class="badge">Coalition: ‚Äî</span>
    </div>
    <div class="leftrow">
      <button id="fsBtn" class="btn btn-ghost mini" title="Fullscreen">‚õ∂ Fullscreen</button>
      <a class="btn btn-ghost mini" href="/index.html">üè† Hub</a>
    </div>
  </div>

  <div class="grid">
    <!-- MAP -->
    <div class="mapWrap card">
      <div class="mapHead">
        <div class="card-title">Map</div>
        <div class="pillrow" id="scoresRow"></div>
      </div>
      <div id="mapWindow" class="mapWindow">
        <div id="mapCanvas" class="mapCanvas"><!-- tiles injected --></div>
      </div>
      <div class="actionbar">
        <div class="leftrow">
          <span class="badge">Order: <span id="orderMode">Attack</span></span>
          <button class="btn-ghost mini" id="modeAttack">‚öîÔ∏è Attack</button>
          <button class="btn-ghost mini" id="modeFortify">üõ°Ô∏è Fortify</button>
          <button class="btn-ghost mini" id="modeMove">üöö Move</button>
          <button class="btn-ghost mini" id="modeClear">üßº Clear</button>
        </div>
        <div class="leftrow">
          <button class="btn-ghost mini" id="btnSpend3">‚≠ê3 ‚Üí +2</button>
          <button class="btn-ghost mini" id="btnSpend6">‚≠ê6 ‚Üí +5</button>
          <button class="btn-ghost mini" id="btnDiplomacy">ü§ù Diplomacy</button>
          <button class="btn mini" id="btnSubmit">‚úÖ Submit Orders</button>
        </div>
      </div>
    </div>

    <!-- RIGHT: ORDERS + CHAT -->
    <div class="controls">
      <div class="card">
        <div class="card-head">
          <div class="card-title">Your Orders</div>
          <div class="muted">Simultaneous; host resolves</div>
        </div>
        <div class="card-body">
          <div id="ordersList" class="vlist"></div>
        </div>
      </div>

      <div class="card">
        <div class="card-head">
          <div class="card-title">Diplomacy</div>
          <div class="muted">Micro-deals & messages</div>
        </div>
        <div class="card-body">
          <div class="vlist" id="dipFeed"></div>
          <div style="display:flex;gap:8px;margin-top:8px">
            <select id="dipTarget" class="select" style="flex:0 0 120px"></select>
            <input id="dipMsg" class="input" placeholder="e.g., I‚Äôll hit Rome if you spare Greece‚Ä¶" style="flex:1 1 auto" />
            <button id="dipSend" class="btn">Send</button>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="card-head">
          <div class="card-title">Rules</div>
        </div>
        <div class="card-body">
          <ul style="margin:0;padding-left:16px;line-height:1.45">
            <li>Turns are simultaneous. Timer auto-resolves if someone stalls.</li>
            <li>‚öîÔ∏è Attack: commit all units from a tile into one adjacent enemy tile.</li>
            <li>üõ°Ô∏è Fortify: +1 on a tile you own (max +1/tile/round).</li>
            <li>üöö Move: transfer some units between adjacent owned tiles (can‚Äôt leave source &lt;1).</li>
            <li><b>Capture Points:</b> +1 point for each tile you capture each round.</li>
            <li><b>Spend Points (free):</b> ‚≠ê3 ‚Üí +2 units (any owned tile), ‚≠ê6 ‚Üí +5 units.</li>
            <li><b>Resolve order:</b> Levy ‚Üí <b>Point Spends</b> ‚Üí Fortify ‚Üí Move ‚Üí Attacks ‚Üí Attrition ‚Üí Victory checks.</li>
            <li>Move cap: at most <span id="ruleCapN">4</span> orders (attacks + fortifies + moves). <b>Point Spends don‚Äôt use the cap.</b></li>
            <li>Win: eliminate all rivals or own ‚â•60% of the map at resolve.</li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Diplomacy modal -->
<div id="dipModal" class="modal-back" role="dialog" aria-modal="true">
  <div class="modal">
    <div class="head">
      <div class="card-title">ü§ù Diplomacy</div>
      <button class="btn btn-ghost" id="dipClose">Close</button>
    </div>
    <div class="body">
      <div class="vlist" id="dipModalFeed"></div>
      <div style="margin-top:10px;display:grid;gap:8px">
        <div style="display:flex;gap:8px">
          <select id="quickDipTarget" class="select" style="flex:0 0 160px"></select>
          <select id="quickDipTemplate" class="select" style="flex:1">
            <option value="NAP">‚úåÔ∏è Non-Aggression for 1 round?</option>
            <option value="TRADE">üîÅ Trade: I‚Äôll attack X if you attack Y.</option>
            <option value="ALLY">üõ°Ô∏è Alliance for 2 rounds vs Leader.</option>
            <option value="SPARE">üïäÔ∏è I‚Äôll spare your border if you spare mine.</option>
          </select>
          <button id="quickDipSend" class="btn">Propose</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script type="module">
/* ===================== Firebase ===================== */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

/* ===================== Params ===================== */
const params = new URLSearchParams(location.search);
const gameId = params.get("gameId");
const username = params.get("username");
if (!gameId || !username) alert("Missing gameId or username.");
const stateRef = doc(db, "lobbies", gameId, "crowncouncil", "state");

/* ===================== Config ===================== */
const MAX_ORDERS_DEFAULT = 4;           // cap per player per round (attacks + fortifies + moves)
const ROUND_LEN_MS_DEFAULT = 45_000;

/* ===================== Helpers ===================== */
const $ = (id)=> document.getElementById(id);
const clamp=(n,a,b)=>Math.max(a,Math.min(b,n));
const shuffle=a=>{for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a;}
const COLORS = ["var(--p0)","var(--p1)","var(--p2)","var(--p3)"];
const PLAYER_COLORS = {};
const getMaxOrders = ()=> (state?.maxOrdersPerTurn ?? MAX_ORDERS_DEFAULT);

/* ===================== Map (square grid) ===================== */
const W = 10, H = 8, TILE = 80, GAP = 6;
const mapWindow = $("mapWindow");
const mapCanvas = $("mapCanvas");
let tilesDOM = [];
let pan = { x: 20, y: 20 };
let panning = false, lastPt = {x:0,y:0};
let dragStart = null, didPan=false;
const DRAG_THRESHOLD = 6;

mapWindow.addEventListener("pointerdown", (e)=>{
  panning = true; didPan = false;
  dragStart = { x:e.clientX, y:e.clientY };
  lastPt = { x:e.clientX, y:e.clientY };
});
mapWindow.addEventListener("pointermove", (e)=>{
  if (!panning) return;
  const dx = e.clientX - lastPt.x, dy = e.clientY - lastPt.y;
  lastPt = { x:e.clientX, y:e.clientY };
  const moved = Math.hypot(e.clientX-dragStart.x, e.clientY-dragStart.y);
  if (moved > DRAG_THRESHOLD) didPan = true;
  if (didPan){ pan.x += dx; pan.y += dy; applyPan(); }
});
mapWindow.addEventListener("pointerup", (e)=>{
  if (!panning) return;
  panning=false;
  if (!didPan){
    const el = document.elementFromPoint(e.clientX, e.clientY);
    const tile = el?.closest?.(".tile");
    if (tile){
      const id = Number(tile.dataset.id);
      onTileTap(id);
    }
  }
});
mapWindow.addEventListener("pointercancel", ()=>{ panning=false; didPan=false; });
function applyPan(){ mapCanvas.style.transform = `translate(${pan.x}px, ${pan.y}px)`; }
applyPan();

/* ===================== UI State ===================== */
let state = null;
let myOrders = [];
let orderMode = "attack"; // "attack" | "fortify" | "move" | "spend3" | "spend6"
let selectedSrc = null;
let timerInterval = null;
let lastRoundSeen = null;

/* ===================== Build Map DOM ===================== */
function buildMapDOM(){
  mapCanvas.innerHTML = "";
  tilesDOM = [];
  const width = W*TILE + (W-1)*GAP;
  const height= H*TILE + (H-1)*GAP;
  mapCanvas.style.width = width+"px";
  mapCanvas.style.height= height+"px";
  for (let y=0;y<H;y++){
    for (let x=0;x<W;x++){
      const id = y*W+x;
      const d = document.createElement("div");
      d.className = "tile";
      d.dataset.id = id;
      d.style.left = (x*(TILE+GAP))+"px";
      d.style.top  = (y*(TILE+GAP))+"px";
      d.innerHTML = `<span class="u" id="u_${id}">0</span><span class="cap-icon" id="c_${id}" style="display:none">‚≠ê</span>`;
      mapCanvas.appendChild(d);
      tilesDOM[id] = d;
    }
  }
}
buildMapDOM();

/* ===================== Game Bootstrap ===================== */
async function ensureState(){
  const snap = await getDoc(stateRef);
  if (snap.exists()) return;

  const terr = [];
  for (let i=0;i<W*H;i++){
    const x = i%W, y = (i/W)|0;
    const n = [];
    if (x>0)   n.push(i-1);
    if (x<W-1) n.push(i+1);
    if (y>0)   n.push(i-W);
    if (y<H-1) n.push(i+W);
    terr.push({ id:i, owner:null, units:1, neighbors:n, isCapital:false });
  }

  const lobbyRef = doc(db, "lobbies", gameId);
  const lob = await getDoc(lobbyRef);
  const players = (lob.exists() && Array.isArray(lob.data().players))
    ? lob.data().players.slice(0,4) : [username];

  const seeds = shuffle([...Array(W*H).keys()]).slice(0, players.length);
  players.forEach((p, idx)=>{
    const c = seeds[idx];
    terr[c].owner = p; terr[c].units = 5; terr[c].isCapital = true;
  });
  players.forEach((p, idx)=>{
    const q = [seeds[idx]];
    const gave = new Set([seeds[idx]]);
    let need = 4;
    while(need>0 && q.length){
      const cur = q.shift();
      for(const nb of terr[cur].neighbors){
        if (!gave.has(nb) && terr[nb].owner===null){
          terr[nb].owner = p; terr[nb].units = 2;
          gave.add(nb); q.push(nb); need--; if (need<=0) break;
        }
      }
    }
  });

  const now = Date.now();
  const payload = {
    status:"planning", round:1,
    players,
    territories: terr,
    submitted:{},
    orders:{},                // normal orders
    ordersPower:{},           // { name: [ {id, amt:2|5} ] }
    levyNextRound: {},
    points:{},                // { name: integer }
    roundEndsAt: now + ROUND_LEN_MS_DEFAULT,
    lastResolveAt: 0,
    diplomacy: [],
    winner:null,
    maxOrdersPerTurn: MAX_ORDERS_DEFAULT,
    roundLenMs: ROUND_LEN_MS_DEFAULT
  };
  await setDoc(stateRef, payload);
}
ensureState();

/* ===================== Snap & Render ===================== */
onSnapshot(stateRef, (snap)=>{
  if (!snap.exists()) return;
  state = snap.data();
  updatePlayerColors();

  if (lastRoundSeen === null || lastRoundSeen !== state.round){
    selectedSrc = null;
    myOrders = (state?.orders?.[username]) || [];
    lastRoundSeen = state.round;
  }

  renderStatus();
  renderMap();
  renderOrdersPane();
  renderDiplomacy();

  if (state.status === "planning") ensureTimer();
  else stopTimer();

  if (state.winner){
    $("statusBadge").textContent = `üèÜ ${state.winner} wins!`;
  }
});

/* ===================== Colors per player ===================== */
function updatePlayerColors(){
  const plist = (state?.players||[]).slice(0,4);
  plist.forEach((p,i)=> PLAYER_COLORS[p]=i%4);
}

/* ===================== Status ===================== */
function pendingPowerCost(){
  const arr = (state?.ordersPower?.[username]) || [];
  let cost = 0;
  for (const o of arr){ cost += (o.amt===2?3:6); }
  return cost;
}
function myPoints(){
  return (state?.points?.[username]||0);
}
function canSpend(cost){
  return (myPoints() - pendingPowerCost()) >= cost;
}

function renderStatus(){
  $("statusBadge").textContent = (state?.status||"‚Äî");
  $("roundBadge").textContent = `Round ${state?.round||"‚Äî"}`;
  const maxN = getMaxOrders();
  $("ruleCapN").textContent = maxN;

  // scoreboard + coalition
  const terr = state?.territories||[];
  const owned = {};
  (state?.players||[]).forEach(n=> owned[n]=0);
  terr.forEach(t=>{ if (t.owner) owned[t.owner] = (owned[t.owner]||0)+1; });
  const total = terr.length || 1;
  let leader = null, leadPct = 0;
  for(const [k,v] of Object.entries(owned)){
    const pct = Math.round((100*v)/total);
    if (pct > leadPct){ leadPct = pct; leader=k; }
  }
  $("coalitionBadge").textContent = (leader ? `${leader} ${leadPct}%` : "‚Äî");

  const row = $("scoresRow"); row.innerHTML = "";
  (state?.players||[]).forEach(n=>{
    const pill = document.createElement("div"); pill.className="pill";
    const dot = document.createElement("span"); dot.className="dot"; dot.style.background = COLORS[PLAYER_COLORS[n]||0];
    const cells = owned[n]||0;
    pill.appendChild(dot);
    pill.appendChild(document.createTextNode(`${n} ‚Äî ${cells}`));
    row.appendChild(pill);
  });

  const done = !!state?.submitted?.[username];
  $("btnSubmit").disabled = done || state.status!=="planning";

  const mineCount = (state?.orders?.[username]?.length) || 0;
  $("moveBadge").textContent = `Moves: ${mineCount}/${maxN}`;
  $("pointsBadge").textContent = `‚≠ê ${myPoints() - pendingPowerCost()}`;

  // enable/disable spend buttons based on remaining points after pending
  $("btnSpend3").disabled = !canSpend(3) || state.status!=="planning";
  $("btnSpend6").disabled = !canSpend(6) || state.status!=="planning";
}

/* ===================== Map & Orders UI ===================== */
function renderMap(){
  if (!state) return;
  const terr = state.territories||[];
  for (const t of terr){
    const el = tilesDOM[t.id];
    if (!el) continue;
    el.classList.remove("p0","p1","p2","p3","owned","sel");
    if (t.owner){
      el.classList.add("owned", `p${PLAYER_COLORS[t.owner]||0}`);
    }
    el.querySelector(".u").textContent = t.units;
    const cap = $("c_"+t.id);
    if (cap) cap.style.display = t.isCapital ? "inline" : "none";
  }
  highlightOrders();
}

function renderOrdersPane(){
  const box = $("ordersList"); box.innerHTML="";

  const mine = (state?.orders?.[username]) || [];
  const pows = (state?.ordersPower?.[username]) || [];

  if (mine.length===0 && pows.length===0){
    const x = document.createElement("div"); x.className="muted";
    x.textContent = "No orders yet. Attack, Fortify, Move, or Spend Points.";
    box.appendChild(x);
  }

  mine.forEach((o,i)=>{
    const row = document.createElement("div");
    row.className = "pill"; row.style.justifyContent="space-between";
    row.innerHTML = (o.type==="attack") ? `‚öîÔ∏è ${o.src} ‚Üí ${o.dst}`
      : (o.type==="move") ? `üöö ${o.src} ‚Üí ${o.dst} (${o.amt})`
      : `üõ°Ô∏è Fortify ${o.id}`;
    const del = document.createElement("button"); del.className="btn-ghost mini"; del.textContent="Remove";
    del.onclick = ()=> removeOrder(i);
    row.appendChild(del);
    box.appendChild(row);
  });

  pows.forEach((o,i)=>{
    const row = document.createElement("div");
    row.className = "pill"; row.style.justifyContent="space-between";
    row.textContent = `‚≠ê +${o.amt} at ${o.id} (cost ${o.amt===2?3:6})`;
    const del = document.createElement("button"); del.className="btn-ghost mini"; del.textContent="Remove";
    del.onclick = ()=> removePower(i);
    row.appendChild(del);
    box.appendChild(row);
  });

  $("moveBadge").textContent = `Moves: ${mine.length}/${getMaxOrders()}`;
  $("pointsBadge").textContent = `‚≠ê ${myPoints() - pendingPowerCost()}`;
}

/* ===================== Diplomacy ===================== */
function renderDiplomacy(){
  const feed = $("dipFeed"); feed.innerHTML="";
  for (const d of (state?.diplomacy||[]).slice(-50)){
    const row = document.createElement("div"); row.className="pill";
    row.textContent = `üí¨ ${new Date(d.t).toLocaleTimeString()} ${d.from} ‚Üí ${d.to||"All"}: ${d.msg}`;
    feed.appendChild(row);
  }
  const sel = $("dipTarget"); sel.innerHTML="";
  const modalSel = $("quickDipTarget"); modalSel.innerHTML="";
  for(const p of (state?.players||[])){
    if (p===username) continue;
    const o1 = document.createElement("option"); o1.value=p; o1.textContent=p;
    const o2 = document.createElement("option"); o2.value=p; o2.textContent=p;
    sel.appendChild(o1); modalSel.appendChild(o2);
  }
}

/* ===================== Orders ===================== */
function setMode(m){
  orderMode = m;
  $("orderMode").textContent =
    m==="attack" ? "Attack" :
    m==="fortify" ? "Fortify" :
    m==="move" ? "Move" :
    m==="spend3" ? "Spend ‚≠ê3 (+2)" :
    m==="spend6" ? "Spend ‚≠ê6 (+5)" : "‚Äî";
  selectedSrc=null; renderMap();
}
$("modeAttack").onclick = ()=> setMode("attack");
$("modeFortify").onclick = ()=> setMode("fortify");
$("modeMove").onclick    = ()=> setMode("move");
$("modeClear").onclick = async ()=>{
  await updateDoc(stateRef, { [`orders.${username}`]: [], [`ordersPower.${username}`]: [] });
};

$("btnSpend3").onclick = ()=> setMode("spend3");
$("btnSpend6").onclick = ()=> setMode("spend6");

function removeOrder(idx){
  const mine = (state?.orders?.[username]) || [];
  mine.splice(idx,1);
  updateDoc(stateRef, { [`orders.${username}`]: mine });
}
function removePower(idx){
  const arr = (state?.ordersPower?.[username]) || [];
  arr.splice(idx,1);
  updateDoc(stateRef, { [`ordersPower.${username}`]: arr });
}

function pushMyOrders(){
  updateDoc(stateRef, { [`orders.${username}`]: myOrders });
}

function hitMoveCapFlash(){ const m=$("moveBadge"); m.style.background="var(--accent-soft)"; setTimeout(()=>m.style.background="",400); }

function onTileTap(id){
  if (!state || state.status!=="planning") return;
  const t = state.territories[id]; if (!t) return;
  const mine = (state.orders?.[username]) || [];
  const maxN = getMaxOrders();

  // SPENDS (free, not part of cap)
  if (orderMode==="spend3" || orderMode==="spend6"){
    if (t.owner !== username) return;
    const cost = orderMode==="spend3" ? 3 : 6;
    const amt  = orderMode==="spend3" ? 2 : 5;
    if (!canSpend(cost)) return;
    const arr = (state?.ordersPower?.[username]) || [];
    const newArr = arr.concat([{ id, amt }]);
    updateDoc(stateRef, { [`ordersPower.${username}`]: newArr });
    // stay in spend mode for batch spending
    return;
  }

  if (orderMode === "fortify"){
    if (t.owner !== username) return;
    if (mine.length >= maxN){ hitMoveCapFlash(); return; }
    if (mine.some(o=>o.type==="fortify" && o.id===id)) return; // one fortify per tile
    myOrders = mine.concat([{ type:"fortify", id }]);
    pushMyOrders();
    renderOrdersPane(); highlightOrders();
    return;
  }

  if (orderMode === "attack"){
    if (!selectedSrc){
      if (t.owner !== username) return;
      if (t.units <= 0) return;
      selectedSrc = id; highlightOrders(); return;
    }else{
      const src = state.territories[selectedSrc];
      if (id===selectedSrc){ selectedSrc=null; highlightOrders(); return; }
      if (!src.neighbors.includes(id)){ selectedSrc=null; highlightOrders(); return; }
      const dst = state.territories[id];
      if (dst.owner === username){ selectedSrc=null; highlightOrders(); return; }
      if (mine.length >= maxN){ selectedSrc=null; hitMoveCapFlash(); highlightOrders(); return; }
      if (mine.some(o=>o.type==="attack" && o.src===selectedSrc)){ selectedSrc=null; highlightOrders(); return; }
      myOrders = mine.concat([{ type:"attack", src: selectedSrc, dst: id }]);
      pushMyOrders();
      selectedSrc=null; renderOrdersPane(); highlightOrders(); return;
    }
  }

  if (orderMode === "move"){
    if (!selectedSrc){
      if (t.owner !== username) return;
      if (t.units <= 1) return;
      selectedSrc = id; highlightOrders(); return;
    }else{
      const src = state.territories[selectedSrc];
      if (id===selectedSrc){ selectedSrc=null; highlightOrders(); return; }
      if (!src.neighbors.includes(id)){ selectedSrc=null; highlightOrders(); return; }
      const dst = state.territories[id];
      if (dst.owner !== username){ selectedSrc=null; highlightOrders(); return; }
      if (mine.length >= maxN){ selectedSrc=null; hitMoveCapFlash(); highlightOrders(); return; }
      if (mine.some(o=>o.type==="move" && o.src===selectedSrc)){ selectedSrc=null; highlightOrders(); return; }
      const maxSend = Math.max(0, src.units - 1);
      const amt = Math.max(1, Math.floor(maxSend/2)); // simple default (half); you already had a picker earlier‚Äîoptional to re-add
      myOrders = mine.concat([{ type:"move", src: selectedSrc, dst: id, amt }]);
      pushMyOrders();
      selectedSrc=null; renderOrdersPane(); highlightOrders(); return;
    }
  }
}

function highlightOrders(){
  tilesDOM.forEach(el=> el.classList.remove("sel"));
  if (selectedSrc!=null) tilesDOM[selectedSrc].classList.add("sel");
  const mine = (state?.orders?.[username])||[];
  const pows = (state?.ordersPower?.[username])||[];
  for(const o of mine){
    if (o.type==="attack"){ tilesDOM[o.src].classList.add("sel"); tilesDOM[o.dst].classList.add("sel"); }
    if (o.type==="fortify"){ tilesDOM[o.id].classList.add("sel"); }
    if (o.type==="move"){ tilesDOM[o.src].classList.add("sel"); tilesDOM[o.dst].classList.add("sel"); }
  }
  for(const o of pows){ tilesDOM[o.id].classList.add("sel"); }
}

/* ===================== Submit & Timer ===================== */
$("btnSubmit").onclick = async ()=>{
  if (!state || state.status!=="planning") return;
  await updateDoc(stateRef, { [`submitted.${username}`]: true });
};

function ensureTimer(){
  stopTimer();
  tickTimer();
  timerInterval = setInterval(tickTimer, 250);
  maybeHostResolve();
}
function stopTimer(){
  if (timerInterval){ clearInterval(timerInterval); timerInterval=null; }
}
function tickTimer(){
  if (!state?.roundEndsAt){ $("timerBadge").textContent = "‚è≥ ‚Äî"; return; }
  const ms = Math.max(0, state.roundEndsAt - Date.now());
  const s = Math.ceil(ms/1000);
  $("timerBadge").textContent = `‚è≥ ${s}s`;
}

/* ===================== Host Resolve ===================== */
async function maybeHostResolve(){
  try{
    const lobRef = doc(db,"lobbies", gameId);
    const lob = await getDoc(lobRef);
    const isHost = lob.exists() && (lob.data().host === username);
    if (!isHost) return;

    const guard = setInterval(async ()=>{
      const snap = await getDoc(stateRef);
      if (!snap.exists()) return;
      const d = snap.data();
      if (d.status!=="planning") return;
      const everyone = (d.players||[]).every(p=> !!d.submitted?.[p]);
      const expired = Date.now() >= (d.roundEndsAt||0);
      if (everyone || expired){
        clearInterval(guard);
        await resolveRound(d);
      }
    }, 800);
  }catch(e){ /* ignore */ }
}

/* ===================== Resolve ===================== */
async function resolveRound(d){
  const terr = (d.territories||[]).map(t=>({...t, neighbors:[...t.neighbors]}));
  const players = d.players || [];
  const byPlayerRaw = d.orders || {};
  const powerRaw    = d.ordersPower || {};
  const pointsPrev  = d.points || {};

  // Trim normal orders to cap
  const cap = d.maxOrdersPerTurn ?? MAX_ORDERS_DEFAULT;
  const byPlayer = {};
  for(const p of players){
    const arr = (byPlayerRaw[p]||[]).filter(o=>o && (o.type==="attack" || o.type==="fortify" || o.type==="move"));
    byPlayer[p] = arr.slice(0, cap);
  }

  /* 1) Levy (free) */
  const levy = d.levyNextRound || {};
  for(const p of players){
    if (levy[p]){
      const capTile = terr.find(t=> t.owner===p && t.isCapital);
      if (capTile) capTile.units += 1;
    }
  }

  /* 2) Apply Point Spends (‚≠ê3‚Üí+2, ‚≠ê6‚Üí+5) BEFORE Fortify/Move/Attacks */
  const pointsSpent = {}; players.forEach(p=> pointsSpent[p]=0);
  for (const p of players){
    const orders = (powerRaw[p]||[]);
    let avail = pointsPrev[p] || 0;
    for (const o of orders){
      const cost = (o.amt===2?3:6);
      if (cost<=avail){
        const t = terr[o.id];
        if (t && t.owner===p){
          t.units += o.amt;
          avail -= cost;
          pointsSpent[p] += cost;
        }
      }
    }
  }

  /* 3) Fortify (+1 each, unique per tile) */
  for(const p of players){
    const seenFortTiles = new Set();
    for(const o of (byPlayer[p]||[])){
      if (o.type!=="fortify") continue;
      if (seenFortTiles.has(o.id)) continue;
      const t = terr[o.id];
      if (t && t.owner===p){ t.units += 1; seenFortTiles.add(o.id); }
    }
  }

  /* 4) Move (can‚Äôt reduce source below 1) */
  for(const p of players){
    const seenMoveSrc = new Set();
    for(const o of (byPlayer[p]||[])){
      if (o.type!=="move") continue;
      if (seenMoveSrc.has(o.src)) continue;
      const src = terr[o.src], dst = terr[o.dst];
      if (!src || !dst) continue;
      if (src.owner!==p || dst.owner!==p) continue;
      if (!src.neighbors.includes(dst.id)) continue;
      const maxSend = Math.max(0, src.units - 1);
      const amt = clamp(o.amt|0, 0, maxSend);
      if (amt>0){ src.units -= amt; dst.units += amt; }
      seenMoveSrc.add(o.src);
    }
  }

  /* 5) Attacks (commit all after moves) */
  const plannedAttacks = [];
  const attach = (dst, item)=>{
    let bucket = plannedAttacks.find(x=>x.dst===dst);
    if (!bucket){ bucket = { dst, attacks:[] }; plannedAttacks.push(bucket); }
    bucket.attacks.push(item);
  };
  for (const p of players){
    for(const o of (byPlayer[p]||[])){
      if (o.type!=="attack") continue;
      const src = terr[o.src], dst = terr[o.dst];
      if (!src || !dst) continue;
      if (src.owner!==p) continue;
      if (!src.neighbors.includes(dst.id)) continue;
      if (src.units<=0) continue;
      const force = src.units; src.units = 0;
      attach(dst.id, { p, src:o.src, force });
    }
  }

  const capturesBy = {}; players.forEach(p=>capturesBy[p]=0);
  for (const bucket of plannedAttacks){
    const dst = terr[bucket.dst];
    const defender = { p: dst.owner, force: dst.units };
    const by = {};
    for(const a of bucket.attacks){ by[a.p] = (by[a.p]||0) + a.force; }
    let topA = null, topForce = 0, sumA = 0;
    for(const [p,force] of Object.entries(by)){ sumA+=force; if (force>topForce){ topA=p; topForce=force; } }
    if (sumA > defender.force){
      dst.owner = topA;
      dst.units = (sumA - defender.force) + 1; // capture bonus
      if (topA) capturesBy[topA] += 1;         // ‚≠ê +1 point for a capture
    } else {
      dst.units = Math.max(0, defender.force - sumA);
    }
  }

  /* 6) Frontline attrition */
  const seen = new Set();
  for(const t of terr){
    for(const nb of t.neighbors){
      const key = t.id<nb ? (t.id+"_"+nb) : (nb+"_"+t.id);
      if (seen.has(key)) continue; seen.add(key);
      const a=t, b=terr[nb];
      if (!a || !b) continue;
      if (a.owner && b.owner && a.owner!==b.owner){
        a.units = Math.max(0, a.units-1);
        b.units = Math.max(0, b.units-1);
      }
    }
  }

  /* 7) Elims / Victory */
  const owned = {}; players.forEach(p=>owned[p]=0);
  terr.forEach(t=>{ if (t.owner) owned[t.owner] = (owned[t.owner]||0)+1; });
  let alive = players.filter(p=> (owned[p]||0)>0);
  let winner = null;
  const total = terr.length;
  for(const p of alive){
    if ((owned[p]||0) >= Math.ceil(0.6*total)){ winner=p; break; }
  }
  if (!winner && alive.length===1) winner = alive[0];

  /* 8) Coalition flags for next round */
  let leadP=null, leadPct=0;
  for(const [p,v] of Object.entries(owned)){
    const pct = Math.round((100*v)/total);
    if (pct>leadPct){ leadPct=pct; leadP=p; }
  }
  const levyNextRound = {};
  if (leadP && leadPct>40){
    for(const p of players){ if (p!==leadP) levyNextRound[p]=true; }
  }

  /* 9) Points update: new = prev - spent + captures */
  const pointsNext = {};
  for (const p of players){
    const prev = pointsPrev[p]||0;
    const spent = pointsSpent[p]||0;
    const earn = capturesBy[p]||0;
    pointsNext[p] = Math.max(0, prev - spent + earn);
  }

  const next = {
    status: winner ? "finished" : "planning",
    territories: terr,
    submitted: {},
    orders: {},
    ordersPower: {},              // clear queued spends
    levyNextRound,
    points: pointsNext,
    round: d.round + 1,
    roundEndsAt: winner ? 0 : (Date.now()+ (d.roundLenMs || ROUND_LEN_MS_DEFAULT)),
    lastResolveAt: Date.now(),
    winner: winner || null,
    maxOrdersPerTurn: d.maxOrdersPerTurn ?? MAX_ORDERS_DEFAULT,
    roundLenMs: d.roundLenMs || ROUND_LEN_MS_DEFAULT
  };
  await updateDoc(stateRef, next);
}

/* ===================== Diplomacy ===================== */
$("dipSend").onclick = async ()=>{
  const to = $("dipTarget").value || null;
  const msg = $("dipMsg").value.trim();
  if (!msg) return;
  const ent = { t:Date.now(), from:username, to, msg };
  const arr = (state?.diplomacy||[]).concat([ent]).slice(-200);
  $("dipMsg").value="";
  await updateDoc(stateRef, { diplomacy: arr });
};
$("btnDiplomacy").onclick = ()=>{ $("dipModal").style.display="flex"; $("dipModalFeed").innerHTML = $("dipFeed").innerHTML; };
$("dipClose").onclick = ()=>{ $("dipModal").style.display="none"; };

/* ===================== Fullscreen & Keys ===================== */
$("fsBtn").onclick = async ()=>{
  try{
    if (!document.fullscreenElement) await document.documentElement.requestFullscreen();
    else await document.exitFullscreen();
  }catch(e){}
};
window.addEventListener("keydown",(e)=>{
  if (e.key==="1") setMode("attack");
  if (e.key==="2") setMode("fortify");
  if (e.key==="3") setMode("move");
});

/* ===================== Timer ===================== */
function flashMoveBadge(){
  const m = $("moveBadge");
  if (!m) return;
  m.style.background = "var(--accent-soft)";
  setTimeout(()=>{ m.style.background = ""; }, 400);
}
</script>
</body>
</html>






