<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>‚öîÔ∏è Draft Battle (2P)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<style>
  :root{
    --bg:#ffffff; --ink:#0f172a; --muted:#64748b; --line:#e5e7eb;
    --p0:#ef4444; --p1:#3b82f6;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}

  .topbar{
    position:sticky; top:0; z-index:50;
    background:#fff; border-bottom:1px solid var(--line);
    display:flex; align-items:center; justify-content:space-between; gap:8px; padding:8px 10px;
  }
  .lives{display:flex; gap:8px; align-items:center; font-weight:900}
  .life{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid var(--line); border-radius:999px; background:#fff; font-size:.95rem}
  .dot{width:10px;height:10px;border-radius:50%}
  .dot.p0{ background:var(--p0) } .dot.p1{ background:var(--p1) }

  .btn{appearance:none;border:1px solid var(--line);border-radius:10px;background:#fff;padding:8px 10px;font-weight:800;cursor:pointer}
  .btn:hover{background:#f8fafc}
  .timer{font-weight:900}
  .status{font-weight:800}
  .muted{color:var(--muted)}

  .stage{ padding:6px 10px; border-bottom:1px solid var(--line); display:flex; align-items:center; justify-content:space-between; gap:8px; }
  .stage .left{display:flex; align-items:center; gap:10px; flex-wrap:wrap}

  /* Board Window (smaller) */
  .wrap{ position:relative; margin:8px auto; width:min(980px, 98vw); height:min(68vh, 640px);
         border:1px solid var(--line); border-radius:12px; overflow:hidden; background:#fff; }
  .draghint{ position:absolute; right:8px; bottom:8px; color:var(--muted); font-size:.8rem; background:#fff; padding:3px 8px; border-radius:8px; border:1px solid var(--line); }

  .boardOuter{ position:absolute; inset:0; overflow:hidden; background:#fff; touch-action:none; }
  .boardInner{ position:absolute; left:0; top:0; transform:translate3d(0,0,0); }

  /* Grid (smaller cells) */
  .cell{ position:absolute; width:34px; height:34px; border:1px solid #e5e7eb; border-radius:6px; background:#fff; }
  .centerLine{ position:absolute; left:0; right:0; height:2px; background:#e5e7eb; }

  /* Units */
  .unitBox{
    position:absolute; display:grid; place-items:center;
    color:#111; font-weight:900; border:2px solid #111; border-radius:8px;
    pointer-events:none; box-shadow:0 2px 0 rgba(0,0,0,.2);
  }
  .unitBox .emoji{ font-size:18px; line-height:1 }
  .lvl1{ background:#22c55e } .lvl2{ background:#3b82f6 } .lvl3{ background:#ef4444 }
  .big{ border-radius:10px }     /* 2√ó2 */
  .ghost{ opacity:.7; outline:2px dashed rgba(0,0,0,.25); }
  .hitFlash{ animation:hf .25s linear }
  @keyframes hf{ from{filter:brightness(1.8)} to{filter:brightness(1)} }

  /* Health bar */
  .hpWrap{
    position:absolute; left:0; right:0; top:-7px; height:5px;
    background:rgba(0,0,0,.12); border-radius:6px; overflow:hidden; pointer-events:none;
  }
  .hpFill{ height:100%; background:linear-gradient(90deg,#22c55e,#eab308,#ef4444); transform-origin:left center }

  /* Fields / blood / acid */
  .fieldTile{
    position:absolute; width:34px; height:34px; border-radius:6px;
    background:#b91c1c; opacity:.55; pointer-events:none;
  }

  /* Wards */
  .ward{
    position:absolute; width:34px; height:34px; border-radius:8px;
    background:#7c3aed; border:2px solid #3b0764; color:#fff; font-size:11px; display:grid; place-items:center;
    box-shadow:0 2px 0 rgba(0,0,0,.25);
  }

  /* Shots */
  .shot{ position:absolute; height:2px; background:#111; opacity:.85; transform-origin:left center; }
  .shot.lightning{ height:3px; background:linear-gradient(90deg,#fb923c,#f59e0b,#fbbf24) }
  .shot.plasma{ height:2px; background:#22d3ee }

  /* Center draft cards (smaller) */
  .centerModal{
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center; z-index:30;
    background:rgba(255,255,255,.0);
    pointer-events:none;
  }
  .cardRow{ display:flex; gap:10px; pointer-events:auto; flex-wrap:wrap; justify-content:center; }
  .pickCard{
    width:min(180px,42vw); border:2px solid var(--line); border-radius:12px; background:#fff;
    box-shadow:0 6px 24px rgba(0,0,0,.12); padding:10px; cursor:pointer; user-select:none;
    display:flex; flex-direction:column; gap:6px; align-items:center; justify-content:center;
    transition:transform .1s ease;
  }
  .pickCard:hover{ transform:translateY(-2px) }
  .pc-emoji{ font-size:24px }
  .pc-title{ font-weight:900; font-size:1rem; text-align:center }
  .pc-note{ color:var(--muted); font-size:.85rem; text-align:center }

  .youPicked{
    position:absolute; top:10px; left:50%; transform:translateX(-50%);
    background:#fff; border:1px solid var(--line); border-radius:10px; padding:6px 10px; font-weight:800;
    z-index:60; font-size:.95rem;
  }

  .fsBtn{
    position:fixed; right:10px; top:10px; z-index:1000;
    border:1px solid var(--line); background:#fff; border-radius:10px; padding:8px 10px; font-weight:800;
  }
</style>
</head>
<body>
  <button id="fsBtn" class="fsBtn">‚õ∂</button>

  <div class="topbar">
    <div class="lives">
      <span class="life"><i class="dot p0"></i><span id="p0Name">‚Äî</span> ‚Ä¢ ‚ù§Ô∏è <b id="p0Lives">4</b></span>
      <span class="life"><i class="dot p1"></i><span id="p1Name">‚Äî</span> ‚Ä¢ ‚ù§Ô∏è <b id="p1Lives">4</b></span>
    </div>
    <div class="status">
      <span id="phaseBadge">‚Äî</span> ‚Ä¢ <span class="timer" id="timerBadge">‚è≥ ‚Äî</span>
    </div>
  </div>

  <div class="stage">
    <div class="left">
      <span id="roundBadge">Round ‚Äî</span>
      <span id="bonusBadge" style="display:none">Loser Bonus: +1 pick</span>
      <span id="draftCount" class="muted"></span>
      <span id="pickedMsg" class="muted"></span>
    </div>
    <div>
      <button id="clearPick" class="btn" style="display:none">Clear Pick</button>
    </div>
  </div>

  <div class="wrap">
    <div class="boardOuter" id="boardOuter" aria-label="Battlefield (drag to pan)">
      <div class="boardInner" id="boardInner"></div>
    </div>
    <div class="draghint">Drag to pan ‚Ä¢ 8√ó20</div>

    <div id="centerUI" class="centerModal" style="display:none;">
      <div class="cardRow" id="cardRow"></div>
    </div>
    <div id="pickedToast" class="youPicked" style="display:none;"></div>
  </div>

<script type="module">
/* ---------------------- Firebase ---------------------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, runTransaction
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

/* ---------------------- Params ------------------------ */
const params = new URLSearchParams(location.search);
const gameId = params.get("gameId");
const username = params.get("username") || "Player";
if (!gameId || !username) alert("Missing ?gameId or ?username");
const lobbyRef = doc(db, "lobbies", gameId);
const stateRef = doc(db, "lobbies", gameId, "draftbattle", "state");

/* ---------------------- Board ------------------------- */
const W = 8, H = 20;         // 8√ó20
const CELL = 34, GAP = 4;    // px
const boardInner = document.getElementById("boardInner");
const boardOuter = document.getElementById("boardOuter");
boardInner.style.width = (W*CELL + (W-1)*GAP) + "px";
boardInner.style.height= (H*CELL + (H-1)*GAP) + "px";

/* layers */
const gridLayer = document.createElement("div"); boardInner.appendChild(gridLayer);
const unitLayer = document.createElement("div"); boardInner.appendChild(unitLayer);
const fieldLayer= document.createElement("div"); boardInner.appendChild(fieldLayer);
const shotLayer = document.createElement("div"); boardInner.appendChild(shotLayer);

/* pan with mobile polish */
let pan = { x: 8, y: 8 };
let drag = null;
function applyPan(){ boardInner.style.transform = `translate(${pan.x}px, ${pan.y}px)`; }
boardOuter.addEventListener("pointerdown", (e)=>{ drag={id:e.pointerId,x:e.clientX,y:e.clientY,sx:pan.x,sy:pan.y}; boardOuter.setPointerCapture(e.pointerId); e.preventDefault(); }, {passive:false});
boardOuter.addEventListener("pointermove", (e)=>{ if(!drag||e.pointerId!==drag.id) return; const dx=e.clientX-drag.x, dy=e.clientY-drag.y; pan.x=drag.sx+dx; pan.y=drag.sy+dy; applyPan(); e.preventDefault(); }, {passive:false});
boardOuter.addEventListener("pointerup", (e)=>{ if(drag&&e.pointerId===drag.id) drag=null; }, {passive:true});
applyPan();

/* Build grid */
for (let y=0;y<H;y++){
  for (let x=0;x<W;x++){
    const d = document.createElement("div");
    d.className="cell";
    d.style.left = (x*(CELL+GAP))+"px";
    d.style.top  = (y*(CELL+GAP))+"px";
    gridLayer.appendChild(d);
  }
}
const midY = Math.floor(H/2)*(CELL+GAP)-GAP/2;
const cen = document.createElement("div"); cen.className="centerLine"; cen.style.top=midY+"px"; gridLayer.appendChild(cen);

/* ---------------------- UI refs ----------------------- */
const p0Name = document.getElementById("p0Name");
const p1Name = document.getElementById("p1Name");
const p0Lives= document.getElementById("p0Lives");
const p1Lives= document.getElementById("p1Lives");
const phaseBadge = document.getElementById("phaseBadge");
const timerBadge = document.getElementById("timerBadge");
const roundBadge = document.getElementById("roundBadge");
const draftCount = document.getElementById("draftCount");
const bonusBadge = document.getElementById("bonusBadge");
const pickedMsg = document.getElementById("pickedMsg");
const cardRow = document.getElementById("cardRow");
const centerUI = document.getElementById("centerUI");
const pickedToast = document.getElementById("pickedToast");

/* ---------------------- Fullscreen -------------------- */
document.getElementById("fsBtn").onclick = async ()=>{
  try{
    if (!document.fullscreenElement) await document.documentElement.requestFullscreen();
    else await document.exitFullscreen();
  }catch(e){}
};

/* ---------------------- Game Data --------------------- */
const rand = (n)=> Math.floor(Math.random()*n);
const choice = (arr)=> arr[rand(arr.length)];
const clamp = (n,a,b)=> Math.max(a, Math.min(b,n));
const now = ()=> Date.now();

const TROOPS = {
  /* VANIR */
  Rifleman: { emoji:"üî´", role:"ranged", range:4, atk:13, hp:62, asp:1.2, speed:1, size:1, frontline:false, spawnCount:2 },
  Rockets:  { emoji:"üöÄ", role:"artillery", range:10, atk:18, hp:120, asp:1.9, speed:0.8, size:1, frontline:false, splash:true, knock:true },
  "Vanir Guard": { emoji:"üõ°Ô∏è", role:"melee", range:1, atk:16, hp:200, asp:1.0, speed:1, size:1, frontline:true },
  Miner: { emoji:"‚õèÔ∏è", role:"diver", range:1, atk:18, hp:160, asp:1.0, speed:2, size:1, frontline:true, spawnCount:2, priority:"rangedFirst", pathBias:"bypass" },
  Ballista: { emoji:"üéØ", role:"siege", range:6, atk:16, hp:140, asp:1.4, speed:0.8, size:1, frontline:false, knock:true },

  /* AESIR */
  Phaser: { emoji:"‚ú®", role:"ranged", range:4, atk:11, hp:75, asp:1.2, speed:1, size:1, frontline:false, spawnCount:2, retreat50:true, retreatDist:3 },
  Blademaster: { emoji:"‚öîÔ∏è", role:"assassin", range:1, atk:28, hp:140, asp:0.9, speed:3, size:1, frontline:true, spawnCount:2 },
  "Storm Seer": { emoji:"‚ö°", role:"chain", range:3, atk:14, hp:90, asp:1.3, speed:1, size:1, frontline:false, chain:3 },
  Guardian: { emoji:"üõ°Ô∏è", role:"bruiser", range:1, atk:22, hp:260, asp:1.1, speed:1, size:2, frontline:true, splash:true, knock:true },
  Warder: { emoji:"üß±", role:"support", range:0, atk:0, hp:1, asp:1, speed:0, size:1, frontline:false, placeWard:true },

  /* HELIONS */
  "Hell Spawn": { emoji:"üî•", role:"swarm", range:1, atk:9, hp:55, asp:0.8, speed:3, size:1, frontline:true, spawnCount:3 },
  Roach: { emoji:"ü™≥", role:"ranged", range:3, atk:11, hp:120, asp:1.5, speed:1, size:1, frontline:false, spawnCount:2 },
  Defiler: { emoji:"üß´", role:"tankSplash", range:1, atk:22, hp:360, asp:1.1, speed:1, size:2, frontline:true, splash:true },
  BloodBurst: { emoji:"ü©∏", role:"bomber", range:1, atk:0, hp:95, asp:1.0, speed:2, size:1, frontline:true, spawnCount:2, kamikaze:true,
                deathField:{ durationMs:6000, slow:0.15, dps:8, color:"#b91c1c" } },
  Spitter: { emoji:"üß™", role:"acid", range:3, atk:10, hp:110, asp:1.4, speed:1, size:1, frontline:false, splashSmall:true }
};
const WARD_HP = 120;
const FACTIONS = {
  Vanir: ["Rifleman","Rockets","Vanir Guard","Miner","Ballista"],
  Aesir: ["Phaser","Blademaster","Storm Seer","Guardian","Warder"],
  Helions:["Hell Spawn","Roach","Defiler","BloodBurst","Spitter"]
};
const SPECIAL_TYPES = { double:"Double", upgrade:"Upgrade", ward:"Ward" };

/* odds: troops more likely than specials (bumped further) */
const WEIGHTS = { troop:4, special:1 };

/* ---------------------- State shape ------------------- */
let me = username;
let state = null;
let players = [];
let meIdx = 0;
let isHost = false;
let timerIv = null;

/* helpers */
function uid(){ return Math.random().toString(36).slice(2); }
function inBounds(x,y){ return x>=0 && x<W && y>=0 && y<H; }
function isTop(playerName){ return (players.indexOf(playerName)===1); } // p0 bottom, p1 top
function frontlineDir(name){ return isTop(name) ? +1 : -1; }
function frontRowIndex(name){ return isTop(name) ? 1 : H-2; }
function backRowIndex(name){ return isTop(name) ? 0 : H-1; }
function unitSize(u){ return (TROOPS[u.type]?.size===2) ? 2 : 1; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }

/* ---------------------- Boot -------------------------- */
await ensureState();
onSnapshot(stateRef, (snap)=>{
  if (!snap.exists()) return;
  state = snap.data();
  players = state.players || players;
  meIdx = players.indexOf(me);
  isHost = (state.host === me);
  renderAll();
});

/* create state if missing */
async function ensureState(){
  const s = await getDoc(stateRef);
  if (s.exists()) return;

  const lob = await getDoc(lobbyRef);
  const lp = (lob.exists() && Array.isArray(lob.data().players))
      ? (lob.data().players.slice(0,2)) : [me];
  const host = (lob.exists() && lob.data().host) || lp[0] || me;

  const lives = {}; lp.forEach(p => lives[p]=4);

  const payload = {
    createdAt: now(),
    host, players: lp,
    lives,
    round: 1,
    phase: "faction",
    phaseEndsAt: now()+20_000,
    factions: {},
    picked: {},
    armies: {},
    bonusFor: null,
    draftLeft: {},
    board: { units:[], wards:[], fields:[] },
    winner: null
  };
  await setDoc(stateRef, payload);
}

/* ---------------------- Timer / Phase ----------------- */
function renderAll(){
  if (!state) return;
  // names & lives
  p0Name.textContent = players[0] || "‚Äî";
  p1Name.textContent = players[1] || "‚Äî";
  p0Lives.textContent = (state.lives?.[players[0]] ?? 4);
  p1Lives.textContent = (state.lives?.[players[1]] ?? 4);

  // badges
  phaseBadge.textContent = `Phase: ${state.phase}`;
  document.getElementById("roundBadge").textContent = `Round ${state.round ?? 1}`;
  document.getElementById("bonusBadge").style.display = state.bonusFor ? "inline-block" : "none";

  ensureTimer();

  // Draw board: during battle use real units; during faction/draft show PREVIEW of both armies
  if (state.phase==="battle"){
    drawBoard(state.board || {units:[],wards:[],fields:[]});
  } else {
    drawDraftPreview();
  }

  // cards
  if (state.phase==="faction" || state.phase==="draft") showPicks();
  else { document.getElementById("centerUI").style.display="none"; document.getElementById("pickedToast").style.display="none"; }

  // draft counter
  if (state.phase==="draft"){
    const mine = state.draftLeft?.[me] ?? 0;
    draftCount.textContent = `Your picks left: ${mine}`;
  } else draftCount.textContent = "";
}

function ensureTimer(){
  if (timerIv) { clearInterval(timerIv); timerIv=null; }
  tickTimer();
  timerIv = setInterval(tickTimer, 200);
}
function tickTimer(){
  if (!state?.phaseEndsAt){ timerBadge.textContent="‚è≥ ‚Äî"; return; }
  const ms = Math.max(0, state.phaseEndsAt - now());
  const s = Math.ceil(ms/1000);
  timerBadge.textContent = `‚è≥ ${s}s`;
  if (isHost && ms<=0) advancePhaseTimeout();
}

/* ---------------------- Picks UI ---------------------- */
function factionEmoji(f){ return f==="Vanir"?"üõ°Ô∏è": f==="Aesir"?"‚ö°":"üî•"; }

function showPicks(){
  const already = state.picked?.[me] || null;
  const opts = pickOptionsFor(me);
  const cardRow = document.getElementById("cardRow");
  const centerUI = document.getElementById("centerUI");
  const pickedToast = document.getElementById("pickedToast");

  cardRow.innerHTML = "";
  centerUI.style.display = "flex";

  if (already){
    pickedToast.textContent =
      (state.phase==="faction")
        ? `Selected faction: ${already.faction}`
        : (already.kind==="troop" ? `Selected: ${already.type}` :
           already.kind==="double" ? `Selected: Double ${already.targetType||"(random)"}` :
           already.kind==="upgrade" ? `Selected: Upgrade ${already.targetType||"(random)"}`
           : "Selected: Ward");
    pickedToast.style.display = "block";
    return;
  } else {
    pickedToast.style.display = "none";
  }

  opts.forEach(o=>{
    const c = document.createElement("div"); c.className="pickCard";
    const em = document.createElement("div"); em.className="pc-emoji"; em.textContent = o.emoji;
    const t = document.createElement("div"); t.className="pc-title";
    const n = document.createElement("div"); n.className="pc-note";

    if (state.phase==="faction"){
      t.textContent = o.faction;
      n.textContent = "Faction";
    } else {
      if (o.kind==="troop"){
        t.textContent = o.type;
        n.textContent = "Add to army";
      } else if (o.kind==="double"){
        t.textContent = `Double ${o.targetType}`;
        n.textContent = "Duplicate that owned type";
      } else if (o.kind==="upgrade"){
        t.textContent = `Upgrade ${o.targetType}`;
        n.textContent = "Level up that owned type";
      } else {
        t.textContent = "Ward";
        n.textContent = "Shield tile";
      }
    }
    c.appendChild(em); c.appendChild(t); c.appendChild(n);
    c.onclick = ()=> pickOption(o);
    cardRow.appendChild(c);
  });
}

/* Build a 3-card hand. Specials are specific to an owned type. */
function pickOptionsFor(name){
  const mineFaction = state.factions?.[name] || null;
  const mineArmy = state.armies?.[name] || [];
  const haveTypes = Array.from(new Set(mineArmy.map(e=>e.type)));

  if (state.phase==="faction"){
    const facs = ["Vanir","Aesir","Helions"];
    return shuffle(facs).slice(0,3).map(f=>({ kind:"faction", faction:f, emoji: factionEmoji(f) }));
  }

  // draft
  const pool = FACTIONS[mineFaction] || [];
  const baseTroops = shuffle(pool).map(t=>({ kind:"troop", type:t, emoji:TROOPS[t]?.emoji||"‚ùì" }));

  // specials ‚Äî only if you own at least one type; each card targets a *specific* owned type
  const specialBag = [];
  if (haveTypes.length>0){
    // choose a target for each card we add to the bag
    const pickOwned = ()=> haveTypes[rand(haveTypes.length)];
    // titles will be rendered in showPicks; include small marker in emoji for clarity
    specialBag.push({ kind:"double", targetType: pickOwned(), emoji:"üÇ°" });
    // only include upgrade if there exists a non-maxed level to upgrade
    const upCandidates = mineArmy.filter(e=>(e.level||1)<3).map(e=>e.type);
    if (upCandidates.length>0){
      const target = upCandidates[rand(upCandidates.length)];
      specialBag.push({ kind:"upgrade", targetType: target, emoji:"‚¨ÜÔ∏è" });
    }
  }
  // Ward is allowed any time
  specialBag.push({ kind:"ward", emoji:"üß±" });

  // Assemble weighted bag
  const bag = [];
  const seen = new Set();
  const pushIfNew = (obj)=>{
    const key = obj.kind + ":" + (obj.type||obj.targetType||obj.faction||"");
    if (seen.has(key)) return; seen.add(key); bag.push(obj);
  };

  for(const t of baseTroops){ for(let i=0;i<WEIGHTS.troop;i++) pushIfNew(t); }
  for(const s of specialBag){ for(let i=0;i<WEIGHTS.special;i++) pushIfNew(s); }

  shuffle(bag);
  const hand=[];
  while(hand.length<3 && bag.length){
    const cand = bag.shift();
    if ((cand.kind==="double"||cand.kind==="upgrade") && haveTypes.length===0) continue;
    hand.push(cand);
  }
  // ensure emojis for troop types are correct
  return hand.map(o=> o.kind==="troop" ? {...o, emoji:TROOPS[o.type]?.emoji||"‚ùì"} : o );
}

async function pickOption(opt){
  const pkt = (state.phase==="faction")
    ? { faction: opt.faction, emoji: factionEmoji(opt.faction) }
    : opt;
  await updateDoc(stateRef, { [`picked.${me}`]: pkt });
}

/* ---------------------- Advance Phase ----------------- */
onSnapshot(stateRef, (snap)=>{
  if (!snap.exists() || !isHost) return;
  const d = snap.data();
  if (d.phase==="faction" || d.phase==="draft"){
    const a = !!d.picked?.[players[0]];
    const b = !!d.picked?.[players[1]];
    if (a && b) advancePhaseTimeout();
  }
});

async function advancePhaseTimeout(){
  if (!isHost || !state) return;

  if (state.phase==="faction"){
    for (const p of players){
      if (!state.picked?.[p]){
        const choice = pickOptionsFor(p)[0];
        await updateDoc(stateRef, { [`picked.${p}`]: { faction: choice.faction, emoji: factionEmoji(choice.faction) } });
      }
    }
    await resolveFactionPhase();
    return;
  }

  if (state.phase==="draft"){
    const upd={};
    for (const p of players){
      const left = state.draftLeft?.[p] ?? 0;
      if (left>0 && !state.picked?.[p]){
        const opt = pickOptionsFor(p)[0];
        upd[`picked.${p}`] = opt;
      }
    }
    if (Object.keys(upd).length) await updateDoc(stateRef, upd);
    await resolveDraftPick();
    return;
  }

  if (state.phase==="battle"){
    if ((state.phaseEndsAt||0) <= now()) await endBattle(null);
  }
}

async function resolveFactionPhase(){
  const factions = {...(state.factions||{})};
  for(const p of players){
    const pick = state.picked?.[p];
    factions[p] = pick?.faction || choice(["Vanir","Aesir","Helions"]);
  }
  const armies = {...(state.armies||{})};
  players.forEach(p=>{ if (!armies[p]) armies[p]=[]; });

  const draftLeft = {};
  for (const p of players){
    draftLeft[p] = 3 + ((state.bonusFor===p) ? 1 : 0);
  }

  await updateDoc(stateRef, {
    factions, picked: {}, armies,
    phase: "draft",
    phaseEndsAt: now()+10_000,
    draftLeft
  });
}

async function resolveDraftPick(){
  const armies = {...state.armies};
  const draftLeft = {...state.draftLeft};
  const picked = {...state.picked};

  for(const p of players){
    const pk = picked[p]; if (!pk) continue;
    if (pk.kind==="troop"){
      const arr = armies[p] || [];
      const ex = arr.find(e=> e.type===pk.type);
      if (ex) ex.count += (TROOPS[pk.type]?.spawnCount || 1);
      else arr.push({ type: pk.type, level:1, count: (TROOPS[pk.type]?.spawnCount || 1) });
      armies[p] = arr;
    } else if (pk.kind==="double"){
      const arr = armies[p]||[];
      let target = arr.find(e=> e.type === pk.targetType);
      if (!target){ // fallback for older states: random owned
        const owned = arr.filter(e=> e.count>0);
        if (owned.length>0) target = choice(owned);
      }
      if (target){
        target.count += Math.max(1, (TROOPS[target.type]?.spawnCount || 1));
      }
    } else if (pk.kind==="upgrade"){
      const arr = armies[p]||[];
      let target = arr.find(e=> e.type === pk.targetType && (e.level||1)<3);
      if (!target){ // fallback: any upgradable
        const owned = arr.filter(e=> (e.level||1) < 3);
        if (owned.length>0) target = choice(owned);
      }
      if (target){
        target.level = clamp((target.level||1)+1,1,3);
      }
    } else if (pk.kind==="ward"){
      const side = isTop(p) ? 0 : H-1;
      const x = rand(W);
      const ward = { id: uid(), owner:p, x, y:side, hp: WARD_HP };
      const wards = (state.board?.wards||[]).slice();
      wards.push(ward);
      await updateDoc(stateRef, { "board.wards": wards });
    }
    draftLeft[p] = Math.max(0, (draftLeft[p]||0) - 1);
  }

  const nextPicked = {};
  const more = (draftLeft[players[0]]>0) || (draftLeft[players[1]]>0);

  if (more){
    await updateDoc(stateRef, {
      armies, picked: nextPicked, draftLeft,
      phase: "draft", phaseEndsAt: now()+10_000
    });
  } else {
    await updateDoc(stateRef, {
      armies, picked: nextPicked, draftLeft,
      phase: "battle", phaseEndsAt: now()+120_000
    });
    if (isHost) startBattle();
  }
}

/* ---------------------- PREVIEW (during draft) -------- */
function drawDraftPreview(){
  const board = { units:[], wards:(state.board?.wards||[]), fields:(state.board?.fields||[]) };
  // spawn from current armies (ghosted)
  for(const p of players){
    const army = state.armies?.[p] || [];
    const us = spawnArmyFor(p, army, board.wards, true/*preview*/);
    board.units.push(...us);
  }
  drawBoard(board, true);
}

/* ---------------------- Battle Sim (host) ------------- */
function spawnArmyFor(p, army, wards, preview=false){
  const units = [];
  const baseFront = frontRowIndex(p);
  const baseBack  = backRowIndex(p);
  const laneX = shuffle([...Array(W).keys()]);
  let lf=0, lb=0;

  for(const e of army){
    const spec = TROOPS[e.type]||{};
    const s = spec.size===2 ? 2 : 1;
    const times = e.count || 1;
    for(let k=0;k<times;k++){
      const front = !!spec.frontline;
      const col = laneX[(front?lf:lb)%W]; if (front) lf++; else lb++;
      let x = clamp(col, 0, W-(s));
      let y = front ? baseFront : baseBack;
      if (!isTop(p) && !front) y = H-1-(s-1);
      if (isTop(p) && !front) y = 0;

      let attempt=0;
      while(occupiedFootprint(units, wards, x,y,s) && attempt<8){
        x = (x+1)% (W-(s-1));
        attempt++;
      }
      if (!occupiedFootprint(units, wards, x,y,s)){
        const hpM = scaledHp(e.type, e.level||1);
        units.push({
          id: uid(), owner:p, type:e.type, level:e.level||1,
          x, y, hp: hpM, hpMax: hpM, size:s, cd: 0,
          _ghost: preview
        });
      }
    }
  }
  return units;
}

function scaledHp(type, lvl){
  const base = TROOPS[type]?.hp || 100;
  const mul = lvl===1?1 : (lvl===2?1.25:1.55);
  return Math.round(base * mul);
}
function scaledAtk(type, lvl){
  const base = TROOPS[type]?.atk || 10;
  const mul = lvl===1?1 : (lvl===2?1.25:1.55);
  return Math.round(base * mul);
}
function occupiedFootprint(units, wards, x,y,s){
  for(const w of wards){ if (rectsOverlap(x,y,s,s, w.x,w.y,1,1)) return true; }
  for(const u of units){
    const ss = unitSize(u);
    if (rectsOverlap(x,y,s,s, u.x,u.y,ss,ss)) return true;
  }
  return false;
}
function rectsOverlap(ax,ay,aw,ah, bx,by,bw,bh){
  return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
}

let simIv = null;
async function startBattle(){
  const wards = (state.board?.wards||[]).slice();
  const units = [];
  for(const p of players){
    const army = state.armies?.[p] || [];
    const us = spawnArmyFor(p, army, wards, false);
    units.push(...us);
  }
  const board = { units, wards, fields: [] };
  await updateDoc(stateRef, { board });
  if (simIv) clearInterval(simIv);
  simIv = setInterval(()=> stepSim(), 200); // slower tick for readability
}

function pickTarget(u, units){
  // Priority rules: Miner => rangedFirst; others => nearest
  if (TROOPS[u.type]?.priority === "rangedFirst"){
    const r = units.filter(v=> v.owner!==u.owner && ["ranged","artillery","chain","siege","acid"].includes(TROOPS[v.type]?.role));
    if (r.length){
      r.sort((a,b)=> manhattan(u,a) - manhattan(u,b));
      return r[0];
    }
  }
  // default nearest
  let best=null, bestD=1e9;
  for(const v of units){
    if (v.owner===u.owner || v.hp<=0) continue;
    const d = manhattan(u,v);
    if (d<bestD){ bestD=d; best=v; }
  }
  return best;
}
function manhattan(a,b){
  const ax = a.x + (unitSize(a)-1)/2, ay = a.y + (unitSize(a)-1)/2;
  const bx = b.x + (unitSize(b)-1)/2, by = b.y + (unitSize(b)-1)/2;
  return Math.abs(ax-bx) + Math.abs(ay-by);
}

function lineShot(from,to){
  const x1 = from.x*(CELL+GAP)+CELL/2, y1 = from.y*(CELL+GAP)+CELL/2;
  const x2 = to.x*(CELL+GAP)+CELL/2, y2 = to.y*(CELL+GAP)+CELL/2;
  return { x1,y1,x2,y2, len: Math.hypot(x2-x1, y2-y1), ang: Math.atan2(y2-y1, x2-x1) };
}

function canStand(units, wards, x,y,s, selfId){
  if (!inBounds(x,y)) return false;
  if (x+s-1 >= W || y+s-1 >= H) return false;
  for (const w of wards){ if (rectsOverlap(x,y,s,s, w.x,w.y,1,1)) return false; }
  for (const u of units){
    if (u.id===selfId || u.hp<=0) continue;
    const ss=unitSize(u);
    if (rectsOverlap(x,y,s,s, u.x,u.y,ss,ss)) return false;
  }
  return true;
}

function greedyStep(units, wards, u, target){
  // If adjacent/in range already, don't move (prevents sliding past)
  const dist = manhattan(u,target);
  const rng = TROOPS[u.type]?.range || 1;
  if (dist <= rng) return {x:u.x, y:u.y};

  const s = unitSize(u);
  const dirPrimary = (frontlineDir(u.owner));
  const dirs = [
    {dx: 0, dy: dirPrimary},              // toward enemy side
    {dx: (target.x>u.x?+1:-1), dy:0},     // toward target column
    {dx: 0, dy: -dirPrimary},             // away (rarely useful)
    {dx: -(target.x>u.x?+1:-1), dy:0}
  ];

  // Try steps that reduce distance; skip those that increase it
  for(const d of dirs){
    const nx = u.x + d.dx, ny = u.y + d.dy;
    if (!canStand(units, wards, nx, ny, s, u.id)) continue;
    const newD = Math.abs(nx + (s-1)/2 - (target.x + (unitSize(target)-1)/2))
               + Math.abs(ny + (s-1)/2 - (target.y + (unitSize(target)-1)/2));
    if (newD < dist) return {x:nx,y:ny};
  }

  // Last resort: any open tile that doesn‚Äôt increase too much
  const fallbacks = [ {dx:0,dy:1},{dx:0,dy:-1},{dx:1,dy:0},{dx:-1,dy:0} ];
  for(const d of fallbacks){
    const nx = u.x + d.dx, ny = u.y + d.dy;
    if (!canStand(units, wards, nx, ny, s, u.id)) continue;
    const newD = Math.abs(nx - target.x) + Math.abs(ny - target.y);
    if (newD <= dist) return {x:nx,y:ny};
  }
  return {x:u.x, y:u.y};
}

function applyFieldEffects(u, fields, dt){
  let slow = 1, dps=0;
  for(const f of fields){
    if (now()>f.tEnd) continue;
    for(const t of f.tiles){
      if (u.x===t.x && u.y===t.y){
        slow = Math.min(slow, f.slow);
        dps += f.dps;
        break;
      }
    }
  }
  u.hp -= dps*dt;
  return slow;
}

async function stepSim(){
  const snap = await getDoc(stateRef);
  if (!snap.exists()) return;
  const d = snap.data();
  if (d.phase!=="battle"){ if (simIv) clearInterval(simIv); return; }
  let board = d.board || {units:[],wards:[],fields:[]};
  let units = board.units.map(x=>({...x}));
  let wards = board.wards.map(x=>({...x}));
  let fields= board.fields.filter(f=> now() <= f.tEnd );

  wards = wards.filter(w => w.hp>0);

  const shots = [];
  const DT = 0.2;

  for (const u of units){
    if (u.hp<=0) continue;
    const spec = TROOPS[u.type] || {};
    const rng = spec.range || 1;

    const slow = applyFieldEffects(u, fields, DT);
    u.cd = Math.max(0, (u.cd||0)-DT);
    u._mv = (u._mv||0) + 1;

    // ensure hpMax exists (for older states)
    if (!u.hpMax){ u.hpMax = scaledHp(u.type, u.level||1); u.hp = Math.min(u.hp, u.hpMax); }

    const enemy = pickTarget(u, units);
    if (!enemy) continue;

    const dist = manhattan(u, enemy);

    if (dist <= rng && u.cd<=0){
      const shot = lineShot(
        {x: u.x + (unitSize(u)-1)/2, y: u.y + (unitSize(u)-1)/2},
        {x: enemy.x + (unitSize(enemy)-1)/2, y: enemy.y + (unitSize(enemy)-1)/2}
      );
      shots.push({ ...shot, kind: (spec.role==="chain"?"lightning": spec.role==="ranged"?"plasma":"plain") });

      // Ward interception
      let blocked = false;
      for (const w of wards){
        const wx = w.x*(CELL+GAP)+CELL/2, wy = w.y*(CELL+GAP)+CELL/2;
        const dmin = pointSegDist({x:shot.x1,y:shot.y1},{x:shot.x2,y:shot.y2},{x:wx,y:wy});
        if (dmin < 17){ // inside half-cell
          const dmg = scaledAtk(u.type, u.level||1);
          w.hp -= dmg; blocked=true; break;
        }
      }
      if (!blocked){
        const dmg = scaledAtk(u.type, u.level||1);
        applyDamage(units, enemy, dmg, spec, u);
      }
      u.cd = spec.asp || 1.0;
    } else {
      // move (only if it helps close the distance)
      if ((u._mv % Math.max(1, Math.round(1/(spec.speed*slow))))===0){
        const step = greedyStep(units.filter(x=>x.hp>0), wards, u, enemy);
        u.x = step.x; u.y = step.y;
      }
    }

    // kamikaze contact
    if (spec.kamikaze && dist<=1){
      spawnField(fields, u.x, u.y, spec.deathField);
      u.hp = 0;
    }

    // phaser retreat
    if (spec.retreat50 && u.hp < 0.5*scaledHp(u.type,u.level||1) && !u.__retreated){
      const dir = -frontlineDir(u.owner);
      const nx = u.x, ny = clamp(u.y + 3*dir, 0, H-1);
      if (canStand(units, wards, nx, ny, unitSize(u), u.id)){
        u.y = ny; u.__retreated = true;
      }
    }
  }

  const after = [];
  for (const u of units){
    if (u.hp>0){ after.push(u); continue; }
    if (TROOPS[u.type]?.deathField){
      spawnField(fields, u.x, u.y, TROOPS[u.type].deathField);
    }
  }

  const aliveA = after.some(u=> u.owner===players[0] && u.hp>0);
  const aliveB = after.some(u=> u.owner===players[1] && u.hp>0);

  await updateDoc(stateRef, {
    "board.units": after,
    "board.wards": wards,
    "board.fields": fields
  });

  drawShots(shots);

  if (!aliveA || !aliveB){
    if (simIv){ clearInterval(simIv); simIv=null; }
    const winner = aliveA && !aliveB ? players[0] : aliveB && !aliveA ? players[1] : null;
    await endBattle(winner);
  }
}

function applyDamage(units, target, dmg, spec, attacker){
  if (spec.splash || spec.splashSmall){
    const rad = spec.splash ? 1 : 0;
    for (const v of units){
      if (v.owner===attacker.owner || v.hp<=0) continue;
      if (Math.abs(v.x - target.x) <= rad && Math.abs(v.y - target.y) <= rad){
        v.hp -= dmg;
        if (spec.knock){
          const dx = Math.sign(v.x - target.x), dy = Math.sign(v.y - target.y);
          const nx = clamp(v.x+dx,0,W-1), ny = clamp(v.y+dy,0,H-1);
          if (canStand(units, [], nx, ny, unitSize(v), v.id)) { v.x=nx; v.y=ny; }
        }
      }
    }
  } else if (spec.role==="chain"){
    const foes = units.filter(u=>u.owner!==attacker.owner && u.hp>0)
                      .sort((a,b)=> manhattan(target,a) - manhattan(target,b));
    let left = TROOPS[attacker.type].chain || 3;
    for(const v of foes){ v.hp -= dmg; left--; if (left<=0) break; }
  } else {
    target.hp -= dmg;
  }
}

function spawnField(fields, cx, cy, opts){
  const { durationMs=6000, slow=0.15, dps=8, color="#b91c1c" } = opts || {};
  const tiles = [];
  for(let dy=-1;dy<=1;dy++){
    for(let dx=-1;dx<=1;dx++){
      const x = cx+dx, y = cy+dy;
      if (inBounds(x,y)) tiles.push({x,y});
    }
  }
  fields.push({ id: uid(), tiles, tEnd: now()+durationMs, dps, slow, color });
}

/* ---------------------- Rendering --------------------- */
function drawBoard(board, preview=false){
  unitLayer.innerHTML = "";
  fieldLayer.innerHTML= "";
  shotLayer.innerHTML = "";

  // fields
  for(const f of board.fields||[]){
    if (now()>f.tEnd) continue;
    for(const t of f.tiles){
      const e = document.createElement("div");
      e.className="fieldTile";
      e.style.left = (t.x*(CELL+GAP))+"px";
      e.style.top  = (t.y*(CELL+GAP))+"px";
      e.style.background = f.color || "#b91c1c";
      fieldLayer.appendChild(e);
      if (!preview) particleBurst(t.x,t.y, f.color||"#b91c1c");
    }
  }

  // wards
  for(const w of board.wards||[]){
    const e = document.createElement("div");
    e.className="ward";
    e.style.left = (w.x*(CELL+GAP))+"px";
    e.style.top  = (w.y*(CELL+GAP))+"px";
    e.textContent = Math.max(0, w.hp|0);
    fieldLayer.appendChild(e);
  }

  // units
  for(const u of board.units||[]){
    renderUnit(u, !!(preview || u._ghost));
  }
}
function renderUnit(u, ghost=false){
  const s = unitSize(u);
  const el = document.createElement("div");
  el.className = `unitBox lvl${u.level||1}` + (s===2?" big":"") + (ghost?" ghost":"");
  const left = u.x*(CELL+GAP), top = u.y*(CELL+GAP);
  const w = s*CELL + (s-1)*GAP, h = s*CELL + (s-1)*GAP;
  el.style.left = left+"px"; el.style.top = top+"px"; el.style.width = w+"px"; el.style.height=h+"px";
  el.style.zIndex = String(100 + u.y*2 + (s===2?1:0));

  // emoji
  const em = document.createElement("div"); em.className="emoji"; em.textContent = TROOPS[u.type]?.emoji || "‚ùì";
  el.appendChild(em);

  // health bar (even in preview for clarity)
  const maxHp = u.hpMax || scaledHp(u.type, u.level||1);
  const curHp = Math.max(0, Math.min(u.hp ?? maxHp, maxHp));
  const pct = maxHp ? (curHp / maxHp) : 1;
  const hpWrap = document.createElement("div"); hpWrap.className="hpWrap";
  const hpFill = document.createElement("div"); hpFill.className="hpFill";
  hpFill.style.width = (pct*100).toFixed(0) + "%";
  hpWrap.appendChild(hpFill);
  el.appendChild(hpWrap);

  unitLayer.appendChild(el);
}

function drawShots(shots){
  shotLayer.innerHTML = "";
  for(const s of shots){
    const e = document.createElement("div");
    e.className = "shot " + (s.kind||"");
    e.style.left = s.x1+"px"; e.style.top = s.y1+"px";
    e.style.width = s.len+"px"; e.style.transform = `rotate(${s.ang}rad)`;
    shotLayer.appendChild(e);
    setTimeout(()=>{ if (e.parentNode) e.parentNode.removeChild(e); }, 220);
  }
}

function particleBurst(x,y,color){
  for(let i=0;i<2;i++){
    const p = document.createElement("div");
    p.style.position="absolute"; p.style.width="6px"; p.style.height="6px";
    p.style.left = (x*(CELL+GAP)+CELL/2-3 + rand(12)-6)+"px";
    p.style.top  = (y*(CELL+GAP)+CELL/2-3 + rand(12)-6)+"px";
    p.style.background = color || "#b91c1c"; p.style.borderRadius="999px"; p.style.opacity=".8";
    fieldLayer.appendChild(p);
    const dx = (Math.random()-0.5)*18, dy=(Math.random()-0.5)*18;
    p.animate([{transform:`translate(0,0)`,opacity:.9},{transform:`translate(${dx}px,${dy}px)`,opacity:0}],{duration:500, easing:"ease-out"});
    setTimeout(()=>{ if (p.parentNode) p.parentNode.removeChild(p); }, 520);
  }
}

/* small geometry helper */
function pointSegDist(A,B,P){
  const ABx=B.x-A.x, ABy=B.y-A.y, APx=P.x-A.x, APy=P.y-A.y;
  const ab2=ABx*ABx + ABy*ABy;
  const t = Math.max(0, Math.min(1, (APx*ABx + APy*ABy)/ab2));
  const cx = A.x + ABx*t, cy = A.y + ABy*t;
  return Math.hypot(P.x-cx, P.y-cy);
}

/* ---------------------- End Battle -------------------- */
async function endBattle(winner){
  const lives = {...state.lives};
  let bonusFor = null;
  if (winner===players[0]){ lives[players[1]] = Math.max(0, (lives[players[1]]||1)-1); bonusFor = players[1]; }
  else if (winner===players[1]){ lives[players[0]] = Math.max(0, (lives[players[0]]||1)-1); bonusFor = players[0]; }

  let winName = null;
  if ((lives[players[0]]||0)<=0) winName = players[1];
  if ((lives[players[1]]||0)<=0) winName = players[0];

  if (winName){
    await updateDoc(stateRef, { lives, winner: winName, phase:"finished", phaseEndsAt: 0 });
    return;
  }

  const draftLeft = {};
  for (const p of players){ draftLeft[p] = 3 + ((bonusFor===p)?1:0); }

  await updateDoc(stateRef, {
    lives, bonusFor, round: (state.round||1)+1,
    phase: "draft", phaseEndsAt: now()+10_000,
    picked: {}, draftLeft,
    "board.units": [], "board.fields": []
  });
}
</script>
</body>
</html>


















