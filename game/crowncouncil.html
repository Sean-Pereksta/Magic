<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>‚öîÔ∏è Draft Brawl (2P)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<style>
  :root{
    --bg:#ffffff; --ink:#0f172a; --muted:#64748b; --line:#e5e7eb;
    --panel:#ffffff; --shadow:0 10px 30px rgba(2,6,23,.08);
    --rad:16px; --rad-sm:12px;

    /* board */
    --cell:40px; --gap:4px;
    --l1:#dcfce7; --l2:#dbeafe; --l3:#fee2e2;
    --p0:#ef4444; --p1:#3b82f6;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}

  .shell{max-width:1200px;margin:0 auto;padding:12px 14px 28px}
  .topbar{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;margin:6px 0 12px}
  .left{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .badge{display:inline-flex;gap:8px;align-items:center;padding:8px 12px;border:1px solid var(--line);border-radius:999px;background:#fff;box-shadow:var(--shadow);font-weight:800}
  .btn{appearance:none;border:1px solid var(--line);border-radius:12px;padding:10px 12px;font-weight:800;cursor:pointer;background:#111827;color:#fff}
  .btn.ghost{background:#fff;color:var(--ink)}
  .btn:hover{filter:brightness(1.05)}

  /* Windowed board */
  .window{
    display:grid; grid-template-columns: 1fr 260px; gap:14px;
    border:1px solid var(--line); border-radius:16px; background:#fff; box-shadow:var(--shadow); padding:10px;
  }
  .viewport{
    position:relative; width:100%; height:min(78vh,860px);
    border:1px solid var(--line); border-radius:14px; overflow:hidden; background:#fff;
    cursor:grab; user-select:none;
  }
  .viewport:active{ cursor:grabbing; }
  .canvas{ position:absolute; left:0; top:0; transform:translate3d(0,0,0) }

  .board{ position:relative }
  .cells{position:relative;display:grid;grid-template-columns:repeat(var(--w),var(--cell));grid-auto-rows:var(--cell);gap:var(--gap)}
  .cell{width:var(--cell);height:var(--cell);border:1px solid #e2e8f0;border-radius:10px;background:#f8fafc;display:grid;place-items:center;position:relative;overflow:hidden}
  .lvl{position:absolute;inset:0;border-radius:8px;opacity:.9}
  .cell.l1 .lvl{background:var(--l1)}
  .cell.l2 .lvl{background:var(--l2)}
  .cell.l3 .lvl{background:var(--l3)}
  .unit{font-size:20px;text-shadow:0 1px 0 rgba(0,0,0,.08)}
  .tag{position:absolute;top:3px;left:4px;padding:1px 6px;border-radius:999px;background:#fff;border:1px solid var(--line);font-size:10px;font-weight:900;color:#475569}
  .hp{position:absolute;left:4px;right:4px;bottom:3px;height:5px;border-radius:4px;background:#e2e8f0;overflow:hidden}
  .hp>i{display:block;height:100%;background:linear-gradient(90deg,#22c55e,#16a34a)}
  .p0 .tag{color:#991b1b;border-color:#fecaca}
  .p1 .tag{color:#1e3a8a;border-color:#bfdbfe}

  /* Draft overlay/cards */
  .overlay{position:absolute;inset:0;background:rgba(255,255,255,.55);display:none;z-index:40}
  .cardRow{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);display:flex;gap:10px;z-index:50}
  .card{width:min(220px,31vw);background:#fff;border:1px solid var(--line);border-radius:14px;box-shadow:var(--shadow);padding:10px 12px;cursor:pointer;display:grid;gap:6px;user-select:none}
  .card:hover{background:#f8fafc}
  .title{font-weight:900}
  .desc{color:var(--muted);font-size:.92rem}

  /* Side HUD */
  .side{
    display:grid; gap:10px;
  }
  .panel{border:1px solid var(--line);border-radius:14px;background:#fff;box-shadow:var(--shadow)}
  .head{padding:10px 12px;border-bottom:1px solid var(--line);font-weight:900}
  .body{padding:10px 12px}
  .pill{display:inline-flex;gap:6px;align-items:center;padding:6px 10px;border:1px solid var(--line);border-radius:999px;background:#fff;font-weight:800}
  .list{display:grid;gap:6px}

  .toast{position:fixed;left:50%;bottom:18px;transform:translateX(-50%);padding:10px 14px;background:#fff;border:1px solid var(--line);border-radius:12px;box-shadow:var(--shadow);font-weight:800;z-index:200;display:none}
</style>
</head>
<body>
<div class="shell">
  <div class="topbar">
    <div class="left">
      <span class="badge">‚öîÔ∏è Draft Brawl</span>
      <span id="phaseBadge" class="badge">‚Äî</span>
    </div>
    <div class="left">
      <span id="p0Badge" class="badge">P0 ‚Äî ‚ù§‚ù§‚ù§‚ù§</span>
      <span id="p1Badge" class="badge">P1 ‚Äî ‚ù§‚ù§‚ù§‚ù§</span>
      <span id="timerBadge" class="badge">‚è≥ ‚Äî</span>
      <button id="fsBtn" class="btn ghost">‚õ∂ Fullscreen</button>
    </div>
  </div>

  <div class="window">
    <!-- Viewport with click-drag pan -->
    <div id="viewport" class="viewport" aria-label="Game board">
      <div id="canvas" class="canvas">
        <div class="board">
          <div id="cells" class="cells" style="--w:8; --cell:40px; --gap:4px"></div>
        </div>
      </div>
      <div id="overlay" class="overlay"></div>
      <div id="cardRow" class="cardRow" style="display:none"></div>
    </div>

    <!-- Side HUD -->
    <aside class="side">
      <div class="panel">
        <div class="head">Players</div>
        <div class="body list">
          <div id="p0Line" class="pill">P0</div>
          <div id="p1Line" class="pill">P1</div>
        </div>
      </div>
      <div class="panel">
        <div class="head">Draft & Phases</div>
        <div class="body list">
          <div class="pill">Draft: 3 √ó 10s</div>
          <div class="pill">Loser bonus: 1 √ó 10s</div>
          <div class="pill">Armies persist between battles</div>
          <div class="pill">Frontline = nearer enemy</div>
          <div class="pill">Backline = furthest from enemy</div>
        </div>
      </div>
      <div class="panel">
        <div class="head">Legend</div>
        <div class="body list">
          <div class="pill">üó°Ô∏è Knight (front)</div>
          <div class="pill">üèπ Archer (back)</div>
          <div class="pill">üí£ Bomber (front)</div>
          <div class="pill">üó°Ô∏èüï≥Ô∏è Assassin (front)</div>
          <div class="pill">üßå Giant (front)</div>
          <div class="pill">üöÄ Rocket (back)</div>
          <div class="pill">üÉè Double (needs troops)</div>
          <div class="pill">‚¨ÜÔ∏è Upgrade (needs troops)</div>
        </div>
      </div>
    </aside>
  </div>
</div>

<div id="toast" class="toast"></div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

/* ---------- Firebase config ---------- */
const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);

/* ---------- URL params ---------- */
const params   = new URLSearchParams(location.search);
const gameId   = params.get("gameId");
const username = params.get("username");
if (!gameId || !username){ alert("Missing gameId or username."); }

/* ---------- Firestore refs ---------- */
const stateRef = doc(db, "lobbies", gameId, "crowncouncil", "state");

/* ---------- DOM helpers ---------- */
const $ = (id)=>document.getElementById(id);
const toast = (t)=>{ const x=$("toast"); x.textContent=t; x.style.display="block"; clearTimeout(window.__t); window.__t=setTimeout(()=>x.style.display="none",1500); };

/* ---------- Viewport pan ---------- */
const viewport = $("viewport"), canvas = $("canvas");
let pan={x:12,y:12}, dragging=false, last={x:0,y:0};
function applyPan(){ canvas.style.transform=`translate(${pan.x}px,${pan.y}px)`; }
viewport.addEventListener("pointerdown", e=>{ dragging=true; last={x:e.clientX,y:e.clientY}; });
viewport.addEventListener("pointermove", e=>{
  if(!dragging) return;
  const dx=e.clientX-last.x, dy=e.clientY-last.y;
  last={x:e.clientX,y:e.clientY}; pan.x+=dx; pan.y+=dy; applyPan();
});
viewport.addEventListener("pointerup", ()=> dragging=false);
viewport.addEventListener("pointercancel", ()=> dragging=false);
applyPan();

/* ---------- Board geometry ---------- */
const W=8, H=32;
const cellsEl=$("cells");
function buildBoard(){
  cellsEl.style.setProperty("--w", W);
  cellsEl.innerHTML="";
  for (let y=0;y<H;y++){
    for (let x=0;x<W;x++){
      const i=y*W+x;
      const d=document.createElement("div");
      d.className="cell";
      d.dataset.i=i;
      d.innerHTML=`<div class="lvl"></div><div class="unit"></div><div class="tag"></div><div class="hp"><i style="width:0%"></i></div>`;
      cellsEl.appendChild(d);
    }
  }
}
buildBoard();
const idx=(x,y)=> y*W+x;
const xy =(i)=> ({x:i%W,y:Math.floor(i/W)});
const inside=(x,y)=> x>=0 && x<W && y>=0 && y<H;

/* ---------- Content ---------- */
const TROOPS = [
  { key:"knight",   name:"Knight",   emoji:"üó°Ô∏è", role:"front", base:{hp:10,dmg:3,spd:1,range:1,cd:600} },
  { key:"archer",   name:"Archer",   emoji:"üèπ", role:"back",  base:{hp:5, dmg:2,spd:1,range:3,cd:800} },
  { key:"bomber",   name:"Bomber",   emoji:"üí£", role:"front", base:{hp:3, dmg:4,spd:1,range:1,cd:0, bomber:true} },
  { key:"assassin", name:"Assassin", emoji:"üó°Ô∏è", role:"front", base:{hp:4, dmg:3,spd:2,range:1,cd:0, assassin:true} },
  { key:"giant",    name:"Giant",    emoji:"üßå", role:"front", base:{hp:20,dmg:4,spd:1,range:1,cd:1000, splash1:true} },
  { key:"rocket",   name:"Rocket",   emoji:"üöÄ", role:"back",  base:{hp:6, dmg:3,spd:0,range:6,cd:1800, splash1:true, knock:true} },
];
const SPECIAL = [
  { key:"double",  name:"Double Type",  emoji:"üÉè", special:"double",  desc:"Double one of your existing troop types" },
  { key:"upgrade", name:"Upgrade Type", emoji:"‚¨ÜÔ∏è", special:"upgrade", desc:"Upgrade one existing troop type (+1 level)" }
];

/* ---------- Packs (per-player) with filtering ---------- */
const ALL_CARDS_TROOPS = TROOPS.map(t=>({type:"troop",...t}));
const ALL_CARDS_SPECIAL= SPECIAL.map(s=>({type:"special",...s}));
function filterPackForPlayer(roster){
  const hasAny = (roster||[]).some(r=>r.count>0);
  const specials = hasAny ? ALL_CARDS_SPECIAL : [];        // gate specials until player has troops
  const pool = [...ALL_CARDS_TROOPS, ...specials];
  // sample 3 distinct
  const out=[]; const bag=[...pool];
  for(let i=0;i<3 && bag.length;i++){
    const j=Math.floor(Math.random()*bag.length);
    out.push(bag.splice(j,1)[0]);
  }
  // Fallback if somehow <3 (e.g., initial bag too small) ‚Äì fill with troops
  while(out.length<3){ out.push(ALL_CARDS_TROOPS[Math.floor(Math.random()*ALL_CARDS_TROOPS.length)]); }
  return out;
}

/* ---------- State ---------- */
let S=null;
let me=0;

/* ---------- Helpers ---------- */
const levelMult=(l)=> [1,1,1.5,2][l] || 1;
const levelClass=(l)=> l>=3?"l3":(l>=2?"l2":"l1");

/* Roster ops */
function rosterAdd(roster, type, inc=1){
  const f=roster.find(r=>r.type===type);
  if (f) f.count+=inc; else roster.push({type, lvl:1, count:inc});
}
function rosterDoubleOne(roster){
  const ks=roster.filter(r=>r.count>0);
  if (!ks.length) return;
  const k=ks[Math.floor(Math.random()*ks.length)];
  k.count += Math.max(1,k.count);
}
function rosterUpgradeOne(roster){
  const ks=roster.filter(r=>r.count>0 && r.lvl<3);
  if (!ks.length) return;
  ks[Math.floor(Math.random()*ks.length)].lvl++;
}

/* Frontline/backline rows (front = nearer enemy, back = furthest) */
function frontRow(p){ return p===0 ? Math.floor(H/2)-1 : Math.floor(H/2); } // near middle
function backEdgeRow(p){ return p===0 ? H-1 : 0; }                          // far from enemy
function moveArmyTowardCenter(state, p){
  const dir = (p===0? -1 : +1); // toward middle
  // check collisions
  for(const u of state.field.units){ if (u.p!==p) continue;
    const ny=u.y+dir; if (!inside(u.x,ny)) return false;
    if (state.field.units.some(v=>v!==u && v.x===u.x && v.y===ny)) return false;
  }
  for(const u of state.field.units){ if (u.p===p) u.y += dir; }
  return true;
}
function rowSlot(state,row){
  const cx=Math.floor(W/2), order=[0,-1,1,-2,2,-3,3,-4,4];
  for(const dx of order){
    const x=Math.max(0,Math.min(W-1,cx+dx));
    if (!state.field.units.some(o=>o.x===x && o.y===row)) return {x,y:row};
  }
  return null;
}
function spawnSlot(state,p,typeKey){
  const base=TROOPS.find(t=>t.key===typeKey);
  const role=base?.role||"front";
  const same=state.field.units.filter(u=>u.p===p && u.type===typeKey);
  if (same.length){
    const row=same[same.length-1].y;
    const pos=rowSlot(state,row); if (pos) return pos;
  }
  let row = (role==="front" ? frontRow(p) : backEdgeRow(p));
  while(inside(0,row)){
    const pos=rowSlot(state,row); if (pos) return pos;
    if (role==="back"){
      if (!moveArmyTowardCenter(state,p)) break;
    }else{
      // try one step away from enemy if jammed
      row = (p===0? row+1 : row-1);
    }
  }
  // fallback any free on side
  const y0 = (p===0? Math.floor(H/2):0);
  const y1 = (p===0? H-1 : Math.floor(H/2)-1);
  for(let y=y0;y<=y1;y++){ for(let x=0;x<W;x++){
    if (!state.field.units.some(o=>o.x===x && o.y===y)) return {x,y};
  }}
  return {x:Math.floor(W/2), y: backEdgeRow(p)};
}
function placeUnit(state,p,key,lvl){
  const b=TROOPS.find(t=>t.key===key); if(!b) return;
  const pos=spawnSlot(state,p,key);
  const u={
    id:crypto.randomUUID(), p, type:key, emoji:b.emoji, role:b.role,
    lvl, x:pos.x, y:pos.y,
    maxhp:Math.round(b.base.hp*levelMult(lvl)), hp:Math.round(b.base.hp*levelMult(lvl)),
    dmg:Math.round(b.base.dmg*levelMult(lvl)),
    spd:b.base.spd, range:b.base.range, cd:b.base.cd,
    bomber:!!b.base.bomber, assassin:!!b.base.assassin, splash1:!!b.base.splash1, knock:!!b.base.knock,
    nextAtk:0, fuse:0, stealthUntil:0, __jumped:false
  };
  state.field.units.push(u);
}
function rebuildFieldFromRoster(state){
  state.field={units:[]};
  for(let p=0;p<2;p++){
    for(const r of (state.roster?.[p]||[])){
      for(let c=0;c<r.count;c++) placeUnit(state,p,r.type,r.lvl);
    }
  }
}

/* Rendering */
function paint(units){
  const grid=Array(W*H).fill(null);
  for(const u of units){ grid[idx(u.x,u.y)] = u; }
  for(let i=0;i<W*H;i++){
    const d=cellsEl.children[i], u=grid[i];
    d.className="cell";
    const lvl=d.querySelector(".lvl"), tag=d.querySelector(".tag"), hp=d.querySelector(".hp>i"), uni=d.querySelector(".unit");
    if(u){
      d.classList.add(levelClass(u.lvl), u.p===0?"p0":"p1");
      uni.textContent = u.emoji; tag.textContent = (u.p===0?"P0":"P1");
      hp.style.width = Math.max(0,Math.round(100*u.hp/u.maxhp))+"%";
    }else{
      uni.textContent=""; tag.textContent=""; hp.style.width="0%";
    }
  }
}
function render(){
  if(!S) return;
  const showDraft = ["draft","loser-bonus","draft-after"].includes(S.phase);
  $("phaseBadge").textContent = S.phase || "‚Äî";
  const tleft = Math.max(0,(S.phaseEndsAt||0) - Date.now());
  $("timerBadge").textContent = showDraft ? `‚è≥ ${Math.ceil(tleft/1000)}s` : "‚è≥ ‚Äî";

  const p0n = S.players?.[0] || "P0";
  const p1n = S.players?.[1] || "P1";
  const l0  = "‚ù§".repeat((S.lives?.[0]??4));
  const l1  = "‚ù§".repeat((S.lives?.[1]??4));
  $("p0Badge").textContent = `${p0n} ‚Äî ${l0}`;
  $("p1Badge").textContent = `${p1n} ‚Äî ${l1}`;
  $("p0Line").textContent  = `${p0n} ‚Äî ${l0}`;
  $("p1Line").textContent  = `${p1n} ‚Äî ${l1}`;

  // During draft, render from roster so both sides see forces ‚Äúso far‚Äù
  if (showDraft){
    const ghost=structuredClone(S);
    rebuildFieldFromRoster(ghost);
    paint(ghost.field.units);
  }else{
    paint(S.field?.units||[]);
  }

  // Draft cards (per player)
  $("overlay").style.display = showDraft ? "block" : "none";
  const row=$("cardRow");
  row.style.display = showDraft ? "flex":"none";
  if (showDraft){
    const pack = (S.currentPacks?.[me] || []);
    row.innerHTML="";
    pack.forEach((c,i)=>{
      const el=document.createElement("div");
      el.className="card";
      if(c.type==="troop"){
        el.innerHTML=`<div class="title">${c.emoji} ${c.name}</div><div class="desc">${c.role==="back"?"Backline":"Frontline"} unit</div>`;
      }else{
        el.innerHTML=`<div class="title">${c.emoji} ${c.name}</div><div class="desc">${c.desc}</div>`;
      }
      el.onclick = ()=> chooseCard(i);
      row.appendChild(el);
    });
  }
}

/* Choose card */
async function chooseCard(i){
  if(!S) return;
  const draftIx=S.draftIndex|0;
  const already = S.selections?.[me]?.[draftIx];
  if (already!=null) return;
  await updateDoc(stateRef, { [`selections.${me}.${draftIx}`]: i });
}

/* Battle sim */
function nearestEnemy(u,units){ let b=null,bd=1e9; for(const v of units){ if(v.p===u.p) continue; const d=Math.abs(v.x-u.x)+Math.abs(v.y-u.y); if(d<bd){bd=d;b=v;} } return b; }
function cellFree(units,x,y){ return inside(x,y) && !units.some(o=>o.x===x&&o.y===y); }
function tryKnock(cx,cy,t,units){ if(!t) return; const dx=Math.sign(t.x-cx), dy=Math.sign(t.y-cy); const nx=t.x+dx, ny=t.y+dy; if(cellFree(units,nx,ny)){ t.x=nx;t.y=ny; } }
function splash(units,x,y,dmg,srcP,kn=false){ for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){ if(!dx&&!dy) continue; const nx=x+dx,ny=y+dy; if(!inside(nx,ny)) continue; const hit=units.find(o=>o.p!==srcP&&o.x===nx&&o.y===ny); if(hit){ hit.hp-=dmg; if(kn) tryKnock(x,y,hit,units); } } }
function attack(u,t,now,units){
  const dist=Math.abs(u.x-t.x)+Math.abs(u.y-t.y);
  if(dist <= (u.range||1)){
    if(now >= u.nextAtk){
      if(u.bomber && dist<=1){ u.fuse = u.fuse || (now+1000); }
      else{
        t.hp -= u.dmg;
        if(u.splash1) splash(units,t.x,t.y,Math.max(1,Math.floor(u.dmg*0.6)),u.p,!!u.knock);
      }
      u.nextAtk = now + (u.cd||600);
    }
    return true;
  }
  return false;
}
function stepToward(u,t,units){
  const dx=Math.sign(t.x-u.x), dy=Math.sign(t.y-u.y);
  const opts=[];
  // prefer advancing toward enemy: for p0 move up, for p1 move down toward center/enemy
  if (Math.abs(t.y-u.y) >= Math.abs(t.x-u.x)) opts.push([u.x,u.y+Math.sign(t.y-u.y)],[u.x+dx,u.y]);
  else opts.push([u.x+dx,u.y],[u.x,u.y+Math.sign(t.y-u.y)]);
  // backups
  opts.push([u.x+dx,u.y-dy],[u.x-dx,u.y+dy],[u.x-dx,u.y],[u.x,u.y-dy]);
  for(const [nx,ny] of opts){ if(cellFree(units,nx,ny)){ u.x=nx;u.y=ny;return; } }
}
function assassinLogic(u,now,units){
  if(!u.assassin) return;
  if(!u.stealthUntil) u.stealthUntil = now+3000;
  if(now>=u.stealthUntil && !u.__jumped){
    const enemy=1-u.p; const row=backEdgeRow(enemy);
    const cx=Math.floor(W/2), order=[0,-1,1,-2,2,-3,3,-4,4];
    for(const dx of order){ const x=Math.max(0,Math.min(W-1,cx+dx)); if(cellFree(units,x,row)){ u.x=x;u.y=row;u.__jumped=true;break; } }
  }
}
function clean(units){ return units.filter(u=>u.hp>0); }

/* Host loop */
let host=false, hostTick=null, battleTick=null;
(async function whoHost(){
  const lob=await getDoc(doc(db,"lobbies",gameId));
  host = lob.exists() && lob.data().host===username;
  if (host) startHost();
})();
function startHost(){
  if(hostTick) return;
  hostTick=setInterval(async ()=>{
    const snap=await getDoc(stateRef); if(!snap.exists()) return;
    const d=snap.data();

    /* Bootstrap ‚Äì start draft immediately */
    if(!d.inited){
      const lob=await getDoc(doc(db,"lobbies",gameId));
      const players=(lob.exists()? (lob.data().players||[]) : [username]).slice(0,2);
      const init={
        inited:true, players, lives:[4,4],
        phase:"draft", draftIndex:0, selections:[[],[]],
        currentPacks:[ filterPackForPlayer([]), filterPackForPlayer([]) ], // gate specials
        phaseEndsAt: Date.now()+10_000,
        roster:[[],[]], field:{units:[]}, winner:null
      };
      await setDoc(stateRef, init);
      return;
    }

    const now=Date.now();

    /* Draft phases: enforce timer + auto pick */
    if (["draft","loser-bonus","draft-after"].includes(d.phase) && now >= (d.phaseEndsAt||0)){
      const di=d.draftIndex|0;
      const sel=d.selections||[[],[]];
      // auto-picks if missing
      for(let p=0;p<2;p++){
        if (sel[p][di]==null){
          const pack=(d.currentPacks?.[p]||[]);
          sel[p][di] = Math.floor(Math.random()*Math.max(1,pack.length));
        }
      }
      // apply picks
      const roster=d.roster||[[],[]];
      for(let p=0;p<2;p++){
        const pack=(d.currentPacks?.[p]||[]);
        const pick=pack[ sel[p][di] ];
        if (pick?.type==="troop") rosterAdd(roster[p], pick.key, 1);
        else if (pick?.type==="special"){
          if (pick.special==="double") rosterDoubleOne(roster[p]);
          if (pick.special==="upgrade") rosterUpgradeOne(roster[p]);
        }
      }

      if (d.phase==="draft"){
        const nextIx=di+1;
        if (nextIx>=3){
          const next={...d, roster, selections:[[],[]], draftIndex:0, currentPacks:[[],[]], phase:"battle", phaseEndsAt:0};
          rebuildFieldFromRoster(next);
          await updateDoc(stateRef,next);
          runBattle();
        }else{
          await updateDoc(stateRef,{
            roster, selections:sel, draftIndex:nextIx,
            currentPacks:[ filterPackForPlayer(roster[0]), filterPackForPlayer(roster[1]) ],
            phaseEndsAt: Date.now()+10_000
          });
        }
        return;
      }

      if (d.phase==="loser-bonus"){
        await updateDoc(stateRef,{
          roster, selections:[[],[]], draftIndex:0,
          currentPacks:[ filterPackForPlayer(roster[0]), filterPackForPlayer(roster[1]) ],
          phase:"draft-after", phaseEndsAt: Date.now()+10_000
        });
        return;
      }

      if (d.phase==="draft-after"){
        const nextIx=di+1;
        if (nextIx>=3){
          const next={...d, roster, selections:[[],[]], draftIndex:0, currentPacks:[[],[]], phase:"battle", phaseEndsAt:0};
          rebuildFieldFromRoster(next);
          await updateDoc(stateRef,next);
          runBattle();
        }else{
          await updateDoc(stateRef,{
            roster, selections:sel, draftIndex:nextIx,
            currentPacks:[ filterPackForPlayer(roster[0]), filterPackForPlayer(roster[1]) ],
            phaseEndsAt: Date.now()+10_000
          });
        }
        return;
      }
    }

    /* Battle driver guard */
    if (d.phase==="battle" && !battleTick) runBattle();
  }, 250);
}

/* Battle loop */
function runBattle(){
  if(battleTick) return;
  battleTick=setInterval(async ()=>{
    const snap=await getDoc(stateRef); if(!snap.exists()){ clearInterval(battleTick); battleTick=null; return; }
    const d=snap.data(); if(d.phase!=="battle"){ clearInterval(battleTick); battleTick=null; return; }
    const st=structuredClone(d);
    const units=st.field.units;
    const now=Date.now();

    // assassins
    for(const u of units) if(u.assassin) assassinLogic(u,now,units);
    // bomber fuses
    for(const u of units) if(u.bomber && u.fuse && now>=u.fuse){
      const mid=units.find(v=>v.p!==u.p && v.x===u.x && v.y===u.y);
      if(mid){ mid.hp -= u.dmg; tryKnock(u.x,u.y,mid,units); }
      splash(units,u.x,u.y, Math.max(1,Math.floor(u.dmg*0.8)), u.p, true);
      u.hp=0;
    }
    st.field.units = units.filter(u=>u.hp>0);

    // attack or move
    for(const u of st.field.units){
      if (u.type==="rocket"){ const t=nearestEnemy(u,st.field.units); if(t) attack(u,t,now,st.field.units); continue; }
      const t=nearestEnemy(u,st.field.units); if(!t) continue;
      if(!attack(u,t,now,st.field.units)){ if(u.spd>0) stepToward(u,t,st.field.units); }
    }
    st.field.units = st.field.units.filter(u=>u.hp>0);

    const a0=st.field.units.some(u=>u.p===0), a1=st.field.units.some(u=>u.p===1);
    if(!a0 || !a1){
      clearInterval(battleTick); battleTick=null;
      const loser = a0?1:0;
      const lives=[...(st.lives||[4,4])]; lives[loser]=Math.max(0,lives[loser]-1);
      const winner = lives[0]===0 ? st.players[1] : (lives[1]===0 ? st.players[0] : null);

      const next = {
        ...st, lives,
        phase: winner ? "game-over" : "loser-bonus",
        phaseEndsAt: winner ? 0 : Date.now()+10_000,
        selections:[[],[]],
        currentPacks: winner ? [[],[]] : [ filterPackForPlayer(st.roster[0]), filterPackForPlayer(st.roster[1]) ],
        draftIndex:0,
        winner: winner || null
      };
      await updateDoc(stateRef,next);
    }else{
      await updateDoc(stateRef,st);
    }
  }, 250);
}

/* Snapshot */
onSnapshot(stateRef,(snap)=>{
  if(!snap.exists()) return;
  S=snap.data();
  me = Math.max(0,(S.players||[]).indexOf(username));
  render();
});

/* Fullscreen */
$("fsBtn").onclick = async ()=>{
  try{
    if (!document.fullscreenElement) await document.documentElement.requestFullscreen();
    else await document.exitFullscreen();
  }catch(e){}
};
</script>
</body>
</html>











