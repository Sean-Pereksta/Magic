<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>‚öîÔ∏è Draft Battle (2P)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<style>
  :root{
    --bg:#ffffff; --ink:#0f172a; --muted:#64748b; --line:#e5e7eb;
    --good:#22c55e; --mid:#3b82f6; --bad:#ef4444; --warn:#f59e0b;
    --p0:#ef4444; --p1:#3b82f6;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}

  .topbar{
    position:sticky; top:0; z-index:50;
    background:#fff; border-bottom:1px solid var(--line);
    display:flex; align-items:center; justify-content:space-between; gap:8px; padding:8px 10px;
  }
  .lives{display:flex; gap:10px; align-items:center; font-weight:900}
  .life{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid var(--line); border-radius:999px; background:#fff}
  .dot{width:10px;height:10px;border-radius:50%}
  .dot.p0{ background:var(--p0) } .dot.p1{ background:var(--p1) }

  .btn{appearance:none;border:1px solid var(--line);border-radius:10px;background:#fff;padding:10px 12px;font-weight:800;cursor:pointer}
  .btn:hover{background:#f8fafc}
  .timer{font-weight:900}
  .status{font-weight:800}

  .stage{ padding:8px 10px; border-bottom:1px solid var(--line); display:flex; align-items:center; justify-content:space-between; gap:8px; }
  .stage .left{display:flex; align-items:center; gap:8px; flex-wrap:wrap}

  /* Board Window */
  .wrap{ position:relative; margin:8px auto; width:min(1100px, 98vw); height: min(72vh, 760px);
         border:1px solid var(--line); border-radius:12px; overflow:hidden; background:#fff; }
  .draghint{ position:absolute; right:8px; bottom:8px; color:var(--muted); font-size:.85rem; background:#fff; padding:4px 8px; border-radius:8px; border:1px solid var(--line); }

  .boardOuter{ position:absolute; inset:0; overflow:hidden; background:#fff }
  .boardInner{ position:absolute; left:0; top:0; transform:translate3d(0,0,0); }

  /* Grid */
  .cell{ position:absolute; width:40px; height:40px; border:1px solid #e5e7eb; border-radius:6px; background:#fff; }
  .centerLine{ position:absolute; left:0; right:0; height:2px; background:#e5e7eb; }

  /* Units */
  .unitBox{
    position:absolute; display:grid; place-items:center;
    color:#111; font-weight:900; border:2px solid #111; border-radius:8px;
    pointer-events:none; box-shadow:0 2px 0 rgba(0,0,0,.2);
  }
  .unitBox .emoji{ font-size:20px; line-height:1 }
  .lvl1{ background:#22c55e }   /* green */
  .lvl2{ background:#3b82f6 }   /* blue */
  .lvl3{ background:#ef4444 }   /* red  */
  .big{ border-radius:10px }     /* 2√ó2 */
  .hitFlash{ animation:hf .25s linear }
  @keyframes hf{ from{filter:brightness(1.8)} to{filter:brightness(1)} }

  /* Fields / blood / acid */
  .fieldTile{
    position:absolute; width:40px; height:40px; border-radius:6px;
    background:#b91c1c; opacity:.55; pointer-events:none;
  }
  /* Wards */
  .ward{
    position:absolute; width:40px; height:40px; border-radius:8px;
    background:#7c3aed; border:2px solid #3b0764; color:#fff; font-size:12px; display:grid; place-items:center;
    box-shadow:0 2px 0 rgba(0,0,0,.25);
  }

  /* Shots */
  .shot{
    position:absolute; height:2px; background:#111; opacity:.8; transform-origin:left center;
  }
  .shot.lightning{ height:3px; background:linear-gradient(90deg,#fb923c,#f59e0b,#fbbf24) }
  .shot.plasma{ height:2px; background:#22d3ee }

  /* Modal for center draft cards */
  .centerModal{
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center; z-index:30;
    background:rgba(255,255,255,.0); /* subtle */
    pointer-events:none;
  }
  .cardRow{ display:flex; gap:12px; pointer-events:auto; }
  .pickCard{
    width:min(220px, 44vw); border:2px solid var(--line); border-radius:14px; background:#fff;
    box-shadow:0 6px 28px rgba(0,0,0,.15); padding:12px; cursor:pointer; user-select:none;
    display:flex; flex-direction:column; gap:8px; align-items:center; justify-content:center;
    transition:transform .1s ease;
  }
  .pickCard:hover{ transform:translateY(-2px) }
  .pc-emoji{ font-size:28px }
  .pc-title{ font-weight:900 }
  .pc-note{ color:var(--muted); font-size:.92rem; text-align:center }

  .youPicked{
    position:absolute; top:12px; left:50%; transform:translateX(-50%);
    background:#fff; border:1px solid var(--line); border-radius:10px; padding:6px 10px; font-weight:800;
    z-index:60;
  }

  /* Mobile fullscreen button */
  .fsBtn{
    position:fixed; right:10px; top:10px; z-index:1000;
    border:1px solid var(--line); background:#fff; border-radius:10px; padding:8px 10px; font-weight:800;
  }
</style>
</head>
<body>
  <button id="fsBtn" class="fsBtn">‚õ∂</button>

  <div class="topbar">
    <div class="lives">
      <span class="life"><i class="dot p0"></i><span id="p0Name">‚Äî</span> ‚Ä¢ ‚ù§Ô∏è <b id="p0Lives">4</b></span>
      <span class="life"><i class="dot p1"></i><span id="p1Name">‚Äî</span> ‚Ä¢ ‚ù§Ô∏è <b id="p1Lives">4</b></span>
    </div>
    <div class="status">
      <span id="phaseBadge">‚Äî</span> ‚Ä¢ <span class="timer" id="timerBadge">‚è≥ ‚Äî</span>
    </div>
  </div>

  <div class="stage">
    <div class="left">
      <span id="roundBadge">Round ‚Äî</span>
      <span id="bonusBadge" style="display:none">Loser Bonus: +1 pick</span>
      <span id="draftCount" class="muted"></span>
      <span id="pickedMsg" class="muted"></span>
    </div>
    <div>
      <button id="clearPick" class="btn" style="display:none">Clear Pick</button>
    </div>
  </div>

  <div class="wrap">
    <div class="boardOuter" id="boardOuter" aria-label="Battlefield (drag to pan)">
      <div class="boardInner" id="boardInner">
        <!-- grid, units, fields, shots appended here -->
      </div>
    </div>
    <div class="draghint">Drag to pan ‚Ä¢ 8√ó20</div>

    <!-- picks appear centered here -->
    <div id="centerUI" class="centerModal" style="display:none;">
      <div class="cardRow" id="cardRow"></div>
    </div>
    <div id="pickedToast" class="youPicked" style="display:none;"></div>
  </div>

<script type="module">
/* ---------------------- Firebase ---------------------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, runTransaction
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

/* ---------------------- Params ------------------------ */
const params = new URLSearchParams(location.search);
const gameId = params.get("gameId");
const username = params.get("username") || "Player";
if (!gameId || !username) alert("Missing ?gameId or ?username");
const lobbyRef = doc(db, "lobbies", gameId);
const stateRef = doc(db, "lobbies", gameId, "draftbattle", "state");

/* ---------------------- Board ------------------------- */
const W = 8, H = 20;         // 8√ó20
const CELL = 40, GAP = 4;    // px
const boardInner = document.getElementById("boardInner");
const boardOuter = document.getElementById("boardOuter");

/* pan */
let pan = { x: 10, y: 10 };
let drag = null;
boardInner.style.width = (W*CELL + (W-1)*GAP) + "px";
boardInner.style.height= (H*CELL + (H-1)*GAP) + "px";
function applyPan(){ boardInner.style.transform = `translate(${pan.x}px, ${pan.y}px)`; }
boardOuter.addEventListener("pointerdown", (e)=>{ drag={x:e.clientX,y:e.clientY,sx:pan.x,sy:pan.y}; boardOuter.setPointerCapture(e.pointerId); });
boardOuter.addEventListener("pointermove", (e)=>{ if(!drag) return; const dx=e.clientX-drag.x, dy=e.clientY-drag.y; pan.x=drag.sx+dx; pan.y=drag.sy+dy; applyPan(); });
boardOuter.addEventListener("pointerup", ()=> drag=null);
applyPan();

/* Build grid */
const gridLayer = document.createElement("div"); boardInner.appendChild(gridLayer);
const unitLayer = document.createElement("div"); boardInner.appendChild(unitLayer);
const fieldLayer= document.createElement("div"); boardInner.appendChild(fieldLayer);
const shotLayer = document.createElement("div"); boardInner.appendChild(shotLayer);
for (let y=0;y<H;y++){
  for (let x=0;x<W;x++){
    const d = document.createElement("div");
    d.className="cell";
    d.style.left = (x*(CELL+GAP))+"px";
    d.style.top  = (y*(CELL+GAP))+"px";
    gridLayer.appendChild(d);
  }
}
const midY = Math.floor(H/2)*(CELL+GAP)-GAP/2;
const cen = document.createElement("div"); cen.className="centerLine"; cen.style.top=midY+"px"; gridLayer.appendChild(cen);

/* ---------------------- UI refs ----------------------- */
const p0Name = document.getElementById("p0Name");
const p1Name = document.getElementById("p1Name");
const p0Lives= document.getElementById("p0Lives");
const p1Lives= document.getElementById("p1Lives");
const phaseBadge = document.getElementById("phaseBadge");
const timerBadge = document.getElementById("timerBadge");
const roundBadge = document.getElementById("roundBadge");
const draftCount = document.getElementById("draftCount");
const bonusBadge = document.getElementById("bonusBadge");
const pickedMsg = document.getElementById("pickedMsg");
const cardRow = document.getElementById("cardRow");
const centerUI = document.getElementById("centerUI");
const pickedToast = document.getElementById("pickedToast");
const clearPickBtn = document.getElementById("clearPick");

/* ---------------------- Fullscreen -------------------- */
document.getElementById("fsBtn").onclick = async ()=>{
  try{
    if (!document.fullscreenElement) await document.documentElement.requestFullscreen();
    else await document.exitFullscreen();
  }catch(e){}
};

/* ---------------------- Game Data --------------------- */
/*  Helper: random util */
const rand = (n)=> Math.floor(Math.random()*n);
const choice = (arr)=> arr[rand(arr.length)];
const clamp = (n,a,b)=> Math.max(a, Math.min(b,n));
const now = ()=> Date.now();

/* factions & troops
   NOTE: ranged are nerfed (atk ~-20%) vs earlier values                     */
const TROOPS = {
  /* VANIR */
  Rifleman: { emoji:"üî´", role:"ranged", range:4, atk:13, hp:70, asp:1.2, speed:1, size:1, frontline:false, spawnCount:2 },
  Rockets:  { emoji:"üöÄ", role:"artillery", range:10, atk:18, hp:120, asp:1.9, speed:0.8, size:1, frontline:false, splash:true, knock:true },
  "Vanir Guard": { emoji:"üõ°Ô∏è", role:"melee", range:1, atk:16, hp:200, asp:1.0, speed:1, size:1, frontline:true },
  Miner: { emoji:"‚õèÔ∏è", role:"diver", range:1, atk:15, hp:160, asp:1.0, speed:2, size:1, frontline:true, spawnCount:2, priority:"rangedFirst", pathBias:"bypass" },
  Ballista: { emoji:"üéØ", role:"siege", range:6, atk:16, hp:140, asp:1.4, speed:0.8, size:1, frontline:false, knock:true },

  /* AESIR */
  Phaser: { emoji:"‚ú®", role:"ranged", range:4, atk:12, hp:80, asp:1.2, speed:1, size:1, frontline:false, spawnCount:2, retreat50:true, retreatDist:3 },
  Blademaster: { emoji:"‚öîÔ∏è", role:"assassin", range:1, atk:28, hp:140, asp:0.9, speed:3, size:1, frontline:true, spawnCount:2 },
  "Storm Seer": { emoji:"‚ö°", role:"chain", range:3, atk:14, hp:90, asp:1.3, speed:1, size:1, frontline:false, chain:3 },
  Guardian: { emoji:"üõ°Ô∏è", role:"bruiser", range:1, atk:22, hp:260, asp:1.1, speed:1, size:2, frontline:true, splash:true, knock:true },
  Warder: { emoji:"üß±", role:"support", range:0, atk:0, hp:1, asp:1, speed:0, size:1, frontline:false, placeWard:true }, // plays Ward card

  /* HELIONS */
  "Hell Spawn": { emoji:"üî•", role:"swarm", range:1, atk:9, hp:55, asp:0.8, speed:3, size:1, frontline:true, spawnCount:3 },
  Roach: { emoji:"ü™≥", role:"ranged", range:3, atk:11, hp:120, asp:1.5, speed:1, size:1, frontline:false, spawnCount:2 },
  Defiler: { emoji:"üß´", role:"tankSplash", range:1, atk:22, hp:360, asp:1.1, speed:1, size:2, frontline:true, splash:true },
  BloodBurst: { emoji:"ü©∏", role:"bomber", range:1, atk:0, hp:95, asp:1.0, speed:2, size:1, frontline:true, spawnCount:2, kamikaze:true,
                deathField:{ durationMs:6000, slow:0.15, dps:8, color:"#b91c1c" } },
  Spitter: { emoji:"üß™", role:"acid", range:3, atk:10, hp:110, asp:1.4, speed:1, size:1, frontline:false, splashSmall:true }
};

/* Generic ward object (blocks paths & shots; loses HP on hits) */
const WARD_HP = 120;

/* factions content */
const FACTIONS = {
  Vanir: ["Rifleman","Rockets","Vanir Guard","Miner","Ballista"],
  Aesir: ["Phaser","Blademaster","Storm Seer","Guardian","Warder"],  // Warder lets you place Wards (draft special)
  Helions:["Hell Spawn","Roach","Defiler","BloodBurst","Spitter"]
};

/* Specials: doubles / upgrades / ward placement */
const SPECIAL_TYPES = {
  double: "Double",
  upgrade: "Upgrade",
  ward: "Ward"  // place a 1√ó1 Ward block on your backline row during draft
};

/* rarity weights (specials 1/3rd as likely) */
const WEIGHTS = {
  troop: 3,
  special: 1
};

/* ---------------------- State shape ------------------- */
/*
state = {
  createdAt, host, players:[p0,p1],
  lives: { [name]:4, ... },
  round: 1,
  phase: "faction"|"draft"|"battle"|"finished",
  phaseEndsAt: <ms>,
  factions: { [name]:"Vanir"|"Aesir"|"Helions" },
  picked:   { [name]: <pick object or null> },       // transient during phase
  armies:   { [name]: [ { type, level, count } ] },  // no nested arrays
  bonusFor: <name|null>,   // last-round loser (gets +1 extra pick)
  draftLeft:{ [name]: number }, // remaining picks in current draft window
  board: { units:[ {id,owner, type, level, x, y, hp, size} ], wards:[{x,y,hp,owner}], fields:[{id,tiles:[{x,y},...],tEnd,dps,slow}] },
  winner: null|name
}
*/

/* ---------------------- Local session ----------------- */
let me = username;
let state = null;
let players = [];
let meIdx = 0;
let isHost = false;
let timerIv = null;

/* ---------------------- Utils ------------------------- */
function uid(){ return Math.random().toString(36).slice(2); }
function inBounds(x,y){ return x>=0 && x<W && y>=0 && y<H; }
function isTop(playerName){ return (players.indexOf(playerName)===1); } // p0 bottom, p1 top
function mySideTop(){ return isTop(me); }
function frontlineDir(name){ return isTop(name) ? +1 : -1; } // top moves down (+1), bottom moves up (-1)
function frontRowIndex(name){ return isTop(name) ? 1 : H-2; }      // near mid
function backRowIndex(name){ return isTop(name) ? 0 : H-1; }       // far edge

/* ---------------------- Boot -------------------------- */
await ensureState();
onSnapshot(stateRef, (snap)=>{
  if (!snap.exists()) return;
  state = snap.data();
  players = state.players || players;
  meIdx = players.indexOf(me);
  isHost = (state.host === me);
  renderAll();
});

/* create state if missing & lock players from lobby */
async function ensureState(){
  const s = await getDoc(stateRef);
  if (s.exists()) return;

  const lob = await getDoc(lobbyRef);
  const lp = (lob.exists() && Array.isArray(lob.data().players))
      ? (lob.data().players.slice(0,2)) : [me];
  const host = (lob.exists() && lob.data().host) || lp[0] || me;

  const lives = {}; lp.forEach(p => lives[p]=4);

  const payload = {
    createdAt: now(),
    host, players: lp,
    lives,
    round: 1,
    phase: "faction",
    phaseEndsAt: now()+20_000,
    factions: {},
    picked: {},
    armies: {},
    bonusFor: null,
    draftLeft: {},
    board: { units:[], wards:[], fields:[] },
    winner: null
  };
  await setDoc(stateRef, payload);
}

/* ---------------------- Phase & UI -------------------- */
function renderAll(){
  if (!state) return;

  // names & lives
  p0Name.textContent = players[0] || "‚Äî";
  p1Name.textContent = players[1] || "‚Äî";
  p0Lives.textContent = (state.lives?.[players[0]] ?? 4);
  p1Lives.textContent = (state.lives?.[players[1]] ?? 4);

  // badges
  roundBadge.textContent = `Round ${state.round ?? 1}`;
  phaseBadge.textContent = `Phase: ${state.phase}`;
  bonusBadge.style.display = state.bonusFor ? "inline-block" : "none";

  // timer
  ensureTimer();

  // board render
  drawBoard(state.board || {units:[],wards:[],fields:[]});

  // center cards / picked banner
  if (state.phase==="faction" || state.phase==="draft"){
    showPicks();
  } else {
    centerUI.style.display = "none";
    pickedToast.style.display = "none";
  }

  // draft counters
  if (state.phase==="draft"){
    const mine = state.draftLeft?.[me] ?? 0;
    draftCount.textContent = `Your picks left: ${mine}`;
  } else {
    draftCount.textContent = "";
  }
}

function ensureTimer(){
  if (timerIv) { clearInterval(timerIv); timerIv=null; }
  tickTimer();
  timerIv = setInterval(tickTimer, 200);
}
function tickTimer(){
  if (!state?.phaseEndsAt){ timerBadge.textContent="‚è≥ ‚Äî"; return; }
  const ms = Math.max(0, state.phaseEndsAt - now());
  const s = Math.ceil(ms/1000);
  timerBadge.textContent = `‚è≥ ${s}s`;

  if (isHost && ms<=0){
    // time expired, advance phase server-side
    advancePhaseTimeout();
  }
}

/* ---------------------- Picks UI ---------------------- */
async function showPicks(){
  const alreadyPicked = state.picked?.[me] || null;

  // Compute options
  const opts = pickOptionsFor(me);
  cardRow.innerHTML = "";
  centerUI.style.display = "flex";

  const countBanner = (state.phase==="draft")
    ? `Draft: pick ${state.draftLeft?.[me] ?? 0} left` : `Pick your Faction`;

  // If already picked, hide cards and show banner
  if (alreadyPicked){
    cardRow.innerHTML = "";
    pickedToast.textContent =
      (state.phase==="faction")
        ? `Selected faction: ${alreadyPicked.faction}`
        : `Selected: ${alreadyPicked.kind==="troop"?alreadyPicked.type:alreadyPicked.kind}`;
    pickedToast.style.display = "block";
    return;
  }
  pickedToast.style.display = "none";

  opts.forEach(o=>{
    const c = document.createElement("div"); c.className="pickCard";
    const em = document.createElement("div"); em.className="pc-emoji"; em.textContent = o.emoji;
    const t = document.createElement("div"); t.className="pc-title";
    const n = document.createElement("div"); n.className="pc-note";

    if (state.phase==="faction"){
      t.textContent = o.faction;
      n.textContent = ["Vanir","Aesir","Helions"].includes(o.faction) ? "Faction" : "";
    } else {
      t.textContent = (o.kind==="troop") ? o.type : (o.kind==="double" ? "Double" : (o.kind==="upgrade" ? "Upgrade" : "Ward"));
      n.textContent = (o.kind==="troop") ? "Add to army" :
                      (o.kind==="double") ? "Duplicate one owned type" :
                      (o.kind==="upgrade") ? "Level up an owned type" :
                      "Place a protective Ward";
    }
    c.appendChild(em); c.appendChild(t); c.appendChild(n);
    c.onclick = ()=> pickOption(o);
    cardRow.appendChild(c);
  });
}

/* produce 3 options, respecting rules */
function pickOptionsFor(name){
  const mineFaction = state.factions?.[name] || null;
  const mineArmy = state.armies?.[name] || [];

  if (state.phase==="faction"){
    // randomize 3 distinct factions
    const facs = ["Vanir","Aesir","Helions"];
    return shuffle(facs).slice(0,3).map(f=>({ kind:"faction", faction:f, emoji: factionEmoji(f) }));
  }

  // draft
  const pool = FACTIONS[mineFaction] || [];
  const haveTypes = new Set(mineArmy.map(e=>e.type));

  const baseTroops = shuffle(pool).map(t=>({ kind:"troop", type:t, emoji:TROOPS[t]?.emoji||"‚ùì" }));
  // specials limited by ownership
  const ownList = Array.from(haveTypes);
  const specialBag = [];
  if (ownList.length>0){
    specialBag.push({ kind:"double", emoji:"üÇ°" });
    specialBag.push({ kind:"upgrade", emoji:"‚¨ÜÔ∏è" });
  }
  // Generic Ward option available to any faction
  specialBag.push({ kind:"ward", emoji:"üß±" });

  // Weights: troop 3, special 1
  const bag = [];
  // ensure uniqueness by kind+type
  const seen = new Set();

  function pushIfNew(obj){
    const key = obj.kind + ":" + (obj.type||obj.faction||"");
    if (seen.has(key)) return;
    seen.add(key); bag.push(obj);
  }

  // Build a mixed bag
  for(const t of baseTroops){ for(let i=0;i<WEIGHTS.troop;i++) pushIfNew(t); }
  for(const s of specialBag){ for(let i=0;i<WEIGHTS.special;i++) pushIfNew(s); }

  // Remove troop types that would be duplicates in the 3-card hand (we still allow picking a type you already own)
  shuffle(bag);
  const hand = [];
  while(hand.length<3 && bag.length){
    const cand = bag.shift();
    // disallow double/upgrade with no owned types
    if ((cand.kind==="double"||cand.kind==="upgrade") && ownList.length===0) continue;
    hand.push(cand);
  }
  // Map emoji for troop after shuffle
  return hand.map(o=>{
    if (o.kind==="troop") return {...o, emoji: TROOPS[o.type]?.emoji || "‚ùì" };
    return o;
  });
}

function factionEmoji(f){ return f==="Vanir"?"üõ°Ô∏è": f==="Aesir"?"‚ö°":"üî•"; }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }

async function pickOption(opt){
  const pkt = (state.phase==="faction")
    ? { faction: opt.faction, emoji: factionEmoji(opt.faction) }
    : opt;
  await updateDoc(stateRef, { [`picked.${me}`]: pkt });
}

/* host: on timer end OR both-picked, advance phase */
async function advancePhaseTimeout(){
  if (!isHost || !state) return;

  // If both picked early, or timer hit 0, resolve phase
  if (state.phase==="faction"){
    const pA = !!state.picked?.[players[0]];
    const pB = !!state.picked?.[players[1]];
    if (!pA || !pB){
      // time over: assign random to those who didn't pick
      const upd = {};
      for (const p of players){
        if (!state.picked?.[p]){
          const choice = pickOptionsFor(p)[0]; // first option from generator
          upd[`picked.${p}`] = { faction: choice.faction, emoji: factionEmoji(choice.faction) };
        }
      }
      if (Object.keys(upd).length) await updateDoc(stateRef, upd);
    }
    await resolveFactionPhase();
    return;
  }

  if (state.phase==="draft"){
    const leftA = state.draftLeft?.[players[0]] ?? 0;
    const leftB = state.draftLeft?.[players[1]] ?? 0;
    const pA = !!state.picked?.[players[0]];
    const pB = !!state.picked?.[players[1]];

    // auto-pick random for those who didn‚Äôt
    const upd = {};
    for (const p of players){
      const mineLeft = state.draftLeft?.[p] ?? 0;
      if (mineLeft>0 && !state.picked?.[p]){
        const opt = pickOptionsFor(p)[0];
        upd[`picked.${p}`] = opt;
      }
    }
    if (Object.keys(upd).length) await updateDoc(stateRef, upd);

    // resolve once both have a pick packet
    if ((!pA && !upd[`picked.${players[0]}`]) || (!pB && !upd[`picked.${players[1]}`])) {
      // not yet picked; will try again next tick
      return;
    }
    await resolveDraftPick(); // decrements picks, applies effects, starts battle when both are at zero
    return;
  }

  if (state.phase==="battle"){
    // battle step tick is separate; timeout safely ends battle if stuck
    // but we‚Äôll rely on the sim to finish; add a guard anyway:
    if ((state.phaseEndsAt||0) <= now()){
      await forceBattleFinishIfNeeded();
    }
    return;
  }
}

/* ---------------------- Resolve Phases ---------------- */
async function resolveFactionPhase(){
  const factions = {...(state.factions||{})};
  for(const p of players){
    const pick = state.picked?.[p];
    const f = pick?.faction || choice(["Vanir","Aesir","Helions"]);
    factions[p] = f;
  }
  // give each player an empty army to start
  const armies = {...(state.armies||{})};
  players.forEach(p=>{ if (!armies[p]) armies[p]=[]; });

  const draftLeft = {};
  // start draft: 3 picks per, loser bonus if any
  for (const p of players){
    draftLeft[p] = 3 + ((state.bonusFor===p) ? 1 : 0);
  }

  await updateDoc(stateRef, {
    factions, picked: {},
    armies,
    phase: "draft",
    phaseEndsAt: now()+10_000,
    draftLeft
  });
}

async function resolveDraftPick(){
  // apply each player's pick to army and decrement
  const armies = {...state.armies};
  const draftLeft = {...state.draftLeft};
  const picked = {...state.picked};

  for(const p of players){
    const pk = picked[p]; if (!pk) continue;
    if (pk.kind==="troop"){
      const arr = armies[p] || [];
      const ex = arr.find(e=> e.type===pk.type);
      if (ex) ex.count += (TROOPS[pk.type]?.spawnCount || 1);
      else arr.push({ type: pk.type, level:1, count: (TROOPS[pk.type]?.spawnCount || 1) });
      armies[p] = arr;
    } else if (pk.kind==="double"){
      // duplicate one owned type at random
      const owned = (armies[p]||[]).filter(e=> e.count>0);
      if (owned.length>0){
        const t = choice(owned);
        t.count += Math.max(1, (TROOPS[t.type]?.spawnCount || 1));
      }
    } else if (pk.kind==="upgrade"){
      const owned = (armies[p]||[]).filter(e=> (e.level||1) < 3);
      if (owned.length>0){
        choice(owned).level = clamp((choice(owned).level||1)+1,1,3);
      }
    } else if (pk.kind==="ward"){
      // place a ward object stored in board at backline (one per pick)
      // store in a temp "preWards" list we‚Äôll merge at battle start
      const side = isTop(p) ? 0 : H-1;
      const x = rand(W);
      const ward = { id: uid(), owner:p, x, y:side, hp: WARD_HP };
      // keep in a safe array in board.wards (no nested arrays)
      const wards = (state.board?.wards||[]).slice();
      wards.push(ward);
      await updateDoc(stateRef, { "board.wards": wards });
    }
    draftLeft[p] = Math.max(0, (draftLeft[p]||0) - 1);
  }

  // Clear picks
  const nextPicked = {};
  const morePicksRemain = (draftLeft[players[0]]>0) || (draftLeft[players[1]]>0);

  if (morePicksRemain){
    await updateDoc(stateRef, {
      armies, picked: nextPicked, draftLeft,
      phase: "draft", phaseEndsAt: now()+10_000
    });
  } else {
    // start battle
    await updateDoc(stateRef, {
      armies, picked: nextPicked, draftLeft,
      phase: "battle", phaseEndsAt: now()+120_000
    });
    if (isHost) startBattle();
  }
}

/* If stuck, award draw -> no life loss (rare) */
async function forceBattleFinishIfNeeded(){
  if (!isHost || state.phase!=="battle") return;
  await endBattle(null);
}

/* ---------------------- Battle Sim (host) ------------- */
function unitSize(u){ return (TROOPS[u.type]?.size===2) ? 2 : 1; }

function spawnArmyFor(p, army, wards){
  // Create units on far side; backline vs frontline
  const units = [];
  const bottom = !isTop(p); // bottom side spawns at y=H-1(back) toward mid
  const baseFront = frontRowIndex(p);
  const baseBack  = backRowIndex(p);

  // Lay down lanes by type
  const laneX = shuffle([...Array(W).keys()]);
  let lf=0, lb=0;

  for(const e of army){
    const spec = TROOPS[e.type]||{};
    const s = spec.size===2 ? 2 : 1;

    const times = e.count || 1;
    for(let k=0;k<times;k++){
      const front = !!spec.frontline;
      const col = laneX[(front?lf:lb)%W]; if (front) lf++; else lb++;
      let x = clamp(col, 0, W-(s));
      let y = front ? baseFront : baseBack;

      // adjust for footprint
      if (bottom && !front) y = H-1-(s-1);
      if (!bottom && !front) y = 0;

      // if collides with a ward or unit, try nearby columns
      let attempt=0;
      while(occupiedFootprint(units, wards, x,y,s) && attempt<8){
        x = (x+1)% (W-(s-1));
        attempt++;
      }
      if (!occupiedFootprint(units, wards, x,y,s)){
        const id = uid();
        units.push({
          id, owner:p, type:e.type, level:e.level||1,
          x, y, hp: scaledHp(e.type, e.level||1), size:s,
          cd: 0
        });
      }
    }
  }
  return units;
}

function scaledHp(type, lvl){
  const base = TROOPS[type]?.hp || 100;
  const mul = lvl===1?1 : (lvl===2?1.25:1.55);
  return Math.round(base * mul);
}
function scaledAtk(type, lvl){
  const base = TROOPS[type]?.atk || 10;
  const mul = lvl===1?1 : (lvl===2?1.25:1.55);
  return Math.round(base * mul);
}

function occupiedFootprint(units, wards, x,y,s){
  for(const w of wards){ if (rectsOverlap(x,y,s,s, w.x,w.y,1,1)) return true; }
  for(const u of units){
    const ss = unitSize(u);
    if (rectsOverlap(x,y,s,s, u.x,u.y,ss,ss)) return true;
  }
  return false;
}
function rectsOverlap(ax,ay,aw,ah, bx,by,bw,bh){
  return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
}

let simIv = null;
async function startBattle(){
  // host builds units from armies + existing wards
  const wards = (state.board?.wards||[]).slice();
  const units = [];
  for(const p of players){
    const army = state.armies?.[p] || [];
    const us = spawnArmyFor(p, army, wards);
    units.push(...us);
  }
  // reset fields (keep wards from draft)
  const board = { units, wards, fields: [] };
  await updateDoc(stateRef, { board });

  // tick sim
  if (simIv) clearInterval(simIv);
  const TICK_MS = 200; // slow
  simIv = setInterval(()=> stepSim(), TICK_MS);
}

function nearestEnemy(u, units){
  let best=null, bestD=1e9;
  const ux = u.x + (unitSize(u)-1)/2, uy = u.y + (unitSize(u)-1)/2;
  for(const v of units){
    if (v.owner===u.owner) continue;
    const vx = v.x + (unitSize(v)-1)/2, vy = v.y + (unitSize(v)-1)/2;
    const d = Math.abs(ux-vx)+Math.abs(uy-vy);
    if (d<bestD){ bestD=d; best=v; }
  }
  return best;
}

function lineShot(from,to){ // returns line segments for UI & for ward collisions
  const x1 = from.x*(CELL+GAP)+CELL/2, y1 = from.y*(CELL+GAP)+CELL/2;
  const x2 = to.x*(CELL+GAP)+CELL/2, y2 = to.y*(CELL+GAP)+CELL/2;
  return { x1,y1,x2,y2, len: Math.hypot(x2-x1,y2-y1), ang: Math.atan2(y2-y1, x2-x1) };
}

function canStand(units, wards, x,y,s, selfId){
  if (!inBounds(x,y)) return false;
  if (x+s-1 >= W || y+s-1 >= H) return false;
  for (const w of wards){ if (rectsOverlap(x,y,s,s, w.x,w.y,1,1)) return false; }
  for (const u of units){
    if (u.id===selfId) continue;
    const ss=unitSize(u);
    if (rectsOverlap(x,y,s,s, u.x,u.y,ss,ss)) return false;
  }
  return true;
}

function bfsNextStep(units, wards, u, target){
  // simple greedy toward target with 4-dir priority
  const s = unitSize(u);
  const dirs = [
    {dx: 0, dy: (frontlineDir(u.owner))}, // toward enemy
    {dx: 0, dy: -frontlineDir(u.owner)},
    {dx: (target.x>u.x?+1:-1), dy:0},
    {dx: -(target.x>u.x?+1:-1), dy:0}
  ];
  for(const d of dirs){
    const nx = u.x + d.dx, ny = u.y + d.dy;
    if (canStand(units, wards, nx, ny, s, u.id)) return {x:nx,y:ny};
  }
  // last resort: try any direction to unstick
  const any = [ {dx:0,dy:1},{dx:0,dy:-1},{dx:1,dy:0},{dx:-1,dy:0} ];
  for(const d of any){
    const nx = u.x + d.dx, ny = u.y + d.dy;
    if (canStand(units, wards, nx, ny, s, u.id)) return {x:nx,y:ny};
  }
  return {x:u.x, y:u.y};
}

function applyFieldEffects(u, fields, dt){
  let slow = 1, dps=0;
  for(const f of fields){
    if (now()>f.tEnd) continue;
    for(const t of f.tiles){
      if (u.x===t.x && u.y===t.y){
        slow = Math.min(slow, f.slow);
        dps += f.dps;
        break;
      }
    }
  }
  u.hp -= dps*dt;
  return slow;
}

async function stepSim(){
  // pull fresh once
  const snap = await getDoc(stateRef);
  if (!snap.exists()) return;
  const d = snap.data();
  if (d.phase!=="battle"){ if (simIv) clearInterval(simIv); return; }
  let board = d.board || {units:[],wards:[],fields:[]};
  let units = board.units.map(x=>({...x}));
  let wards = board.wards.map(x=>({...x}));
  let fields= board.fields.filter(f=> now() <= f.tEnd );

  // remove dead wards
  wards = wards.filter(w => w.hp>0);

  // shots drawn later; but we track ward hits along the line:
  const shots = [];

  // per unit tick
  const DT = 0.2; // seconds per step
  for (const u of units){
    if (u.hp<=0) continue;
    const spec = TROOPS[u.type] || {};
    const rng = spec.range || 1;

    // field effects
    const slow = applyFieldEffects(u, fields, DT);
    const moveEvery = Math.max(1, Math.round(2/spec.speed)); // coarse move pacing
    u._mv = (u._mv||0)+1;
    u.cd = Math.max(0, (u.cd||0)-DT);

    const enemy = nearestEnemy(u, units.filter(x=>x.hp>0));
    if (!enemy){ /* battle over will be handled */ continue; }

    const dist = Math.abs((u.x + (unitSize(u)-1)/2) - (enemy.x + (unitSize(enemy)-1)/2))
               + Math.abs((u.y + (unitSize(u)-1)/2) - (enemy.y + (unitSize(enemy)-1)/2));

    // attack if in range
    if (dist <= rng && u.cd<=0){
      // ranged line (or melee small line)
      const shot = lineShot(
        {x: u.x + (unitSize(u)-1)/2, y: u.y + (unitSize(u)-1)/2},
        {x: enemy.x + (unitSize(enemy)-1)/2, y: enemy.y + (unitSize(enemy)-1)/2}
      );
      shots.push({ ...shot, kind: (spec.role==="chain"?"lightning": spec.role==="ranged"?"plasma":"plain") });

      // ward collision: if a ward is between, it takes damage and may absorb
      let blocked = false;
      for (const w of wards){
        // project ward center onto shot; crude check: if ward y between y1,y2 and x between too
        const wx = w.x*(CELL+GAP)+CELL/2, wy = w.y*(CELL+GAP)+CELL/2;
        // distance from line segment
        const A = {x:shot.x1, y:shot.y1}, B={x:shot.x2,y:shot.y2}, P={x:wx,y:wy};
        const d = pointSegDist(A,B,P);
        if (d < 20){ // within half-cell
          // ward soaks damage
          const dmg = scaledAtk(u.type, u.level||1);
          w.hp -= dmg;
          blocked = true;
          break;
        }
      }
      if (!blocked){
        // apply to target (with splash/chain)
        const dmg = scaledAtk(u.type, u.level||1);
        applyDamage(units, enemy, dmg, spec, u);
      }
      u.cd = spec.asp || 1.0;
    } else {
      // move toward enemy
      if ((u._mv % Math.max(1, Math.round(1/(spec.speed*slow))))===0){
        const step = bfsNextStep(units.filter(x=>x.hp>0), wards, u, enemy);
        u.x = step.x; u.y = step.y;
      }
    }

    // kamikaze on contact
    if (spec.kamikaze && dist<=1){
      // explode and die
      spawnField(fields, u.x, u.y, spec.deathField);
      u.hp = 0;
    }

    // Phaser retreat (once below 50%)
    if (spec.retreat50 && u.hp < 0.5*scaledHp(u.type,u.level||1) && !u.__retreated){
      const dir = -frontlineDir(u.owner);
      const nx = u.x, ny = clamp(u.y + 3*dir, 0, H-1);
      if (canStand(units, wards, nx, ny, unitSize(u), u.id)){
        u.y = ny; u.__retreated = true;
      }
    }
  }

  // remove dead units; trigger blood field on BloodBurst death
  const after = [];
  for (const u of units){
    if (u.hp>0){ after.push(u); continue; }
    if (TROOPS[u.type]?.deathField){
      spawnField(fields, u.x, u.y, TROOPS[u.type].deathField);
    }
  }

  // win check
  const aliveA = after.some(u=> u.owner===players[0] && u.hp>0);
  const aliveB = after.some(u=> u.owner===players[1] && u.hp>0);

  // write snapshot
  await updateDoc(stateRef, {
    "board.units": after,
    "board.wards": wards,
    "board.fields": fields
  });

  // draw shots (visual only clients will render)
  drawShots(shots);

  if (!aliveA || !aliveB){
    if (simIv){ clearInterval(simIv); simIv=null; }
    const winner = aliveA && !aliveB ? players[0] : aliveB && !aliveA ? players[1] : null;
    await endBattle(winner);
  }
}

function applyDamage(units, target, dmg, spec, attacker){
  // splash?
  if (spec.splash || spec.splashSmall){
    const rad = spec.splash ? 1 : 0; // splash radius in tiles
    for (const v of units){
      if (v.owner===attacker.owner) continue;
      if (Math.abs(v.x - target.x) <= rad && Math.abs(v.y - target.y) <= rad){
        v.hp -= dmg;
        if (spec.knock){
          // knock one tile away from impact center if free
          const dx = Math.sign(v.x - target.x), dy = Math.sign(v.y - target.y);
          const nx = clamp(v.x+dx,0,W-1), ny = clamp(v.y+dy,0,H-1);
          if (canStand(units, [], nx, ny, unitSize(v), v.id)) { v.x=nx; v.y=ny; }
        }
      }
    }
  } else if (spec.role==="chain"){
    // lightning: chain to up to 3 enemies near target
    const foes = units.filter(u=>u.owner!==attacker.owner && u.hp>0)
                      .sort((a,b)=> (Math.abs(a.x-target.x)+Math.abs(a.y-target.y)) - (Math.abs(b.x-target.x)+Math.abs(b.y-target.y)));
    let left = TROOPS[attacker.type].chain || 3;
    for(const v of foes){
      v.hp -= dmg;
      left--; if (left<=0) break;
    }
  } else {
    target.hp -= dmg;
  }
}

function spawnField(fields, cx, cy, opts){
  const { durationMs=6000, slow=0.15, dps=8, color="#b91c1c" } = opts || {};
  const tiles = [];
  for(let dy=-1;dy<=1;dy++){
    for(let dx=-1;dx<=1;dx++){
      const x = cx+dx, y = cy+dy;
      if (inBounds(x,y)) tiles.push({x,y});
    }
  }
  fields.push({ id: uid(), tiles, tEnd: now()+durationMs, dps, slow, color });
}

/* ---------------------- Render Board ------------------ */
function drawBoard(board){
  // clear layers
  unitLayer.innerHTML = "";
  fieldLayer.innerHTML= "";
  // fields
  for(const f of board.fields||[]){
    if (now()>f.tEnd) continue;
    for(const t of f.tiles){
      const e = document.createElement("div");
      e.className="fieldTile";
      e.style.left = (t.x*(CELL+GAP))+"px";
      e.style.top  = (t.y*(CELL+GAP))+"px";
      e.style.background = f.color || "#b91c1c";
      fieldLayer.appendChild(e);
      particleBurst(t.x,t.y, f.color||"#b91c1c");
    }
  }
  // wards
  for(const w of board.wards||[]){
    const e = document.createElement("div");
    e.className="ward";
    e.style.left = (w.x*(CELL+GAP))+"px";
    e.style.top  = (w.y*(CELL+GAP))+"px";
    e.textContent = Math.max(0, w.hp|0);
    fieldLayer.appendChild(e);
  }
  // units
  for(const u of board.units||[]){
    renderUnit(u);
  }
}

function renderUnit(u){
  const s = unitSize(u);
  const el = document.createElement("div");
  el.className = `unitBox lvl${u.level||1}` + (s===2?" big":"");
  const left = u.x*(CELL+GAP), top = u.y*(CELL+GAP);
  const w = s*CELL + (s-1)*GAP, h = s*CELL + (s-1)*GAP;
  el.style.left = left+"px"; el.style.top = top+"px"; el.style.width = w+"px"; el.style.height=h+"px";
  el.style.zIndex = String(100 + u.y*2 + (s===2?1:0));
  const em = document.createElement("div"); em.className="emoji"; em.textContent = TROOPS[u.type]?.emoji || "‚ùì";
  el.appendChild(em);
  unitLayer.appendChild(el);
  u.__el = el;
}

/* shot visuals */
function drawShots(shots){
  shotLayer.innerHTML = "";
  for(const s of shots){
    const e = document.createElement("div");
    e.className = "shot " + (s.kind||"");
    e.style.left = s.x1+"px"; e.style.top = s.y1+"px";
    e.style.width = s.len+"px"; e.style.transform = `rotate(${s.ang}rad)`;
    shotLayer.appendChild(e);
    setTimeout(()=>{ if (e.parentNode) e.parentNode.removeChild(e); }, 200);
  }
}

/* tiny particles on fields */
function particleBurst(x,y,color){
  for(let i=0;i<2;i++){
    const p = document.createElement("div");
    p.style.position="absolute"; p.style.width="6px"; p.style.height="6px";
    p.style.left = (x*(CELL+GAP)+CELL/2-3 + rand(12)-6)+"px";
    p.style.top  = (y*(CELL+GAP)+CELL/2-3 + rand(12)-6)+"px";
    p.style.background = color || "#b91c1c"; p.style.borderRadius="999px"; p.style.opacity=".8";
    fieldLayer.appendChild(p);
    const dx = (Math.random()-0.5)*18, dy=(Math.random()-0.5)*18;
    p.animate([{transform:`translate(0,0)`,opacity:.9},{transform:`translate(${dx}px,${dy}px)`,opacity:0}],{duration:500, easing:"ease-out"});
    setTimeout(()=>{ if (p.parentNode) p.parentNode.removeChild(p); }, 520);
  }
}

/* geometry helpers */
function pointSegDist(A,B,P){
  const ABx=B.x-A.x, ABy=B.y-A.y, APx=P.x-A.x, APy=P.y-A.y;
  const ab2=ABx*ABx + ABy*ABy;
  const t = Math.max(0, Math.min(1, (APx*ABx + APy*ABy)/ab2));
  const cx = A.x + ABx*t, cy = A.y + ABy*t;
  return Math.hypot(P.x-cx, P.y-cy);
}

/* ---------------------- End Battle -------------------- */
async function endBattle(winner){
  // adjust lives, set bonus for loser only
  const lives = {...state.lives};
  let bonusFor = null;
  if (winner===players[0]){
    lives[players[1]] = Math.max(0, (lives[players[1]]||1)-1);
    bonusFor = players[1];
  } else if (winner===players[1]){
    lives[players[0]] = Math.max(0, (lives[players[0]]||1)-1);
    bonusFor = players[0];
  } else {
    // draw: no life change
    bonusFor = null;
  }

  // check game end
  let winName = null;
  if ((lives[players[0]]||0)<=0) winName = players[1];
  if ((lives[players[1]]||0)<=0) winName = players[0];

  if (winName){
    await updateDoc(stateRef, {
      lives, winner: winName, phase:"finished", phaseEndsAt: 0
    });
    return;
  }

  // next round: reset picks with loser bonus
  const draftLeft = {};
  for (const p of players){
    draftLeft[p] = 3 + ((bonusFor===p)?1:0);
  }
  await updateDoc(stateRef, {
    lives,
    bonusFor,
    round: (state.round||1)+1,
    phase: "draft",
    phaseEndsAt: now()+10_000,
    picked: {},
    draftLeft,
    // board persists wards; clear units & fields
    "board.units": [],
    "board.fields": []
  });
}

/* ---------------------- Shots & Picks Early  ----------- */
/* advance early if both picked */
onSnapshot(stateRef, (snap)=>{
  if (!snap.exists()) return;
  const d = snap.data();
  if (!isHost) return;

  if (d.phase==="faction" || d.phase==="draft"){
    const a = !!d.picked?.[players[0]];
    const b = !!d.picked?.[players[1]];
    if (a && b){
      // advance immediately without waiting full timer
      advancePhaseTimeout();
    }
  }
});

/* ---------------------- End --------------------------- */
</script>
</body>
</html>



















