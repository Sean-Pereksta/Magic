<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>‚öîÔ∏è Draft Brawl (2P) ‚Äî Crown & Council</title>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<style>
  :root{
    --bg:#ffffff; --ink:#0f172a; --muted:#64748b; --line:#e5e7eb;
    --panel:#ffffff; --shadow:0 10px 30px rgba(2,6,23,.08);
    --rad:16px; --rad-sm:12px;
    --cell:38px; --gap:4px;
    --l1:#dcfce7; --l2:#dbeafe; --l3:#fee2e2;
    --p0:#ef4444; --p1:#3b82f6;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}

  .shell{max-width:1100px;margin:0 auto;padding:12px 14px 28px}
  .topbar{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;margin:6px 0 12px}
  .left{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .badge{display:inline-flex;gap:8px;align-items:center;padding:8px 12px;border:1px solid var(--line);border-radius:999px;background:#fff;box-shadow:var(--shadow);font-weight:800}
  .btn{appearance:none;border:1px solid var(--line);border-radius:12px;padding:10px 12px;font-weight:800;cursor:pointer;background:#111827;color:#fff}
  .btn.ghost{background:#fff;color:var(--ink)}
  .btn:hover{filter:brightness(1.05)}

  .boardWrap{border:1px solid var(--line);border-radius:16px;background:#fff;box-shadow:var(--shadow);padding:10px}
  .board{position:relative;width:100%;height:min(80vh,880px);display:grid;justify-content:center;align-content:center}
  .cells{position:relative;display:grid;grid-template-columns:repeat(var(--w),var(--cell));grid-auto-rows:var(--cell);gap:var(--gap);margin:0 auto}
  .cell{width:var(--cell);height:var(--cell);border:1px solid #e2e8f0;border-radius:10px;background:#f8fafc;display:grid;place-items:center;position:relative;overflow:hidden}
  .lvl{position:absolute;inset:0;border-radius:8px;opacity:.9}
  .cell.l1 .lvl{background:var(--l1)}
  .cell.l2 .lvl{background:var(--l2)}
  .cell.l3 .lvl{background:var(--l3)}
  .unit{font-size:18px;text-shadow:0 1px 0 rgba(0,0,0,.08)}
  .tag{position:absolute;top:3px;left:4px;padding:1px 6px;border-radius:999px;background:#fff;border:1px solid var(--line);font-size:10px;font-weight:900;color:#475569}
  .hp{position:absolute;left:4px;right:4px;bottom:3px;height:5px;border-radius:4px;background:#e2e8f0;overflow:hidden}
  .hp>i{display:block;height:100%;background:linear-gradient(90deg,#22c55e,#16a34a)}
  .p0 .tag{color:#991b1b;border-color:#fecaca}
  .p1 .tag{color:#1e3a8a;border-color:#bfdbfe}

  .centerCards{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);display:flex;gap:10px;z-index:50}
  .overlay{position:absolute;inset:0;background:rgba(255,255,255,.6);display:none;z-index:40}
  .card{width:min(200px,30vw);background:#fff;border:1px solid var(--line);border-radius:14px;box-shadow:var(--shadow);padding:10px 12px;cursor:pointer;display:grid;gap:6px;user-select:none}
  .card:hover{background:#f8fafc}
  .title{font-weight:900}
  .desc{color:var(--muted);font-size:.92rem}

  .hud{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
  .pill{display:inline-flex;gap:6px;align-items:center;padding:6px 10px;border:1px solid var(--line);border-radius:999px;background:#fff;font-weight:800}
  .legend{display:flex;flex-wrap:wrap;gap:6px}

  .toast{position:fixed;left:50%;bottom:18px;transform:translateX(-50%);padding:10px 14px;background:#fff;border:1px solid var(--line);border-radius:12px;box-shadow:var(--shadow);font-weight:800;z-index:200;display:none}
</style>
</head>
<body>
<div class="shell">
  <div class="topbar">
    <div class="left">
      <span class="badge">‚öîÔ∏è Draft Brawl</span>
      <span id="phaseBadge" class="badge">‚Äî</span>
      <span id="timerBadge" class="badge">‚è≥ ‚Äî</span>
    </div>
    <div class="left">
      <span id="p0Badge" class="badge">P0 ‚Äî ‚ù§‚ù§‚ù§‚ù§</span>
      <span id="p1Badge" class="badge">P1 ‚Äî ‚ù§‚ù§‚ù§‚ù§</span>
      <button id="fsBtn" class="btn ghost">‚õ∂ Fullscreen</button>
    </div>
  </div>

  <div class="boardWrap">
    <div class="board">
      <div id="cells" class="cells" style="--w:8; --cell:38px; --gap:4px"></div>
      <div id="overlay" class="overlay"></div>
      <div id="centerCards" class="centerCards" style="display:none"></div>
    </div>
    <div class="hud">
      <div class="legend">
        <span class="pill">üó°Ô∏è Knight</span>
        <span class="pill">üèπ Archer</span>
        <span class="pill">üí£ Bomber</span>
        <span class="pill">üó°Ô∏èüï≥Ô∏è Assassin</span>
        <span class="pill">üßå Giant</span>
        <span class="pill">üöÄ Rocket</span>
        <span class="pill">üÉè Double Type</span>
        <span class="pill">‚¨ÜÔ∏è Upgrade Type</span>
      </div>
      <span class="pill" style="margin-left:auto;color:#334155">Draft 3√ó10s ‚Üí Battle. Loser gets +1 pick, then both draft 3√ó10s again.</span>
    </div>
  </div>
</div>

<div id="toast" class="toast"></div>

<!-- Firebase game logic -->
<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, runTransaction } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

/* ---------- Firebase config (yours) ---------- */
const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);

/* ---------- URL params ---------- */
const params   = new URLSearchParams(location.search);
const gameId   = params.get("gameId");
const username = params.get("username");
if (!gameId || !username){ alert("Missing gameId or username."); }

/* ---------- Firestore refs ---------- */
const stateRef = doc(db, "lobbies", gameId, "crowncouncil", "state");

/* ---------- DOM helpers ---------- */
const $ = (id)=>document.getElementById(id);
const toast = (t)=>{ const x=$("toast"); x.textContent=t; x.style.display="block"; clearTimeout(window.__t); window.__t=setTimeout(()=>x.style.display="none",1500); };

/* ---------- Board geometry ---------- */
const W=8, H=32;  // 8 x 32 grid
const cellsEl = $("cells");
function buildBoard(){
  cellsEl.style.setProperty("--w", W);
  cellsEl.innerHTML="";
  for (let y=0;y<H;y++){
    for (let x=0;x<W;x++){
      const i=y*W+x;
      const d=document.createElement("div");
      d.className="cell";
      d.dataset.i=i;
      d.innerHTML=`<div class="lvl"></div><div class="unit"></div><div class="tag"></div><div class="hp"><i style="width:0%"></i></div>`;
      cellsEl.appendChild(d);
    }
  }
}
buildBoard();
const idx=(x,y)=> y*W+x;
const xy =(i)=> ({x:i%W,y:Math.floor(i/W)});
const inside=(x,y)=> x>=0 && x<W && y>=0 && y<H;

/* ---------- Game content ---------- */
const TROOPS = [
  { key:"knight",   name:"Knight",   emoji:"üó°Ô∏è", role:"front", base:{hp:10,dmg:3,spd:1,range:1,cd:600} },
  { key:"archer",   name:"Archer",   emoji:"üèπ", role:"back",  base:{hp:5, dmg:2,spd:1,range:3,cd:800} },
  { key:"bomber",   name:"Bomber",   emoji:"üí£", role:"front", base:{hp:3, dmg:4,spd:1,range:1,cd:0, bomber:true} },
  { key:"assassin", name:"Assassin", emoji:"üó°Ô∏è", role:"front", base:{hp:4, dmg:3,spd:2,range:1,cd:0, assassin:true} },
  { key:"giant",    name:"Giant",    emoji:"üßå", role:"front", base:{hp:20,dmg:4,spd:1,range:1,cd:1000, splash1:true} },
  { key:"rocket",   name:"Rocket",   emoji:"üöÄ", role:"back",  base:{hp:6, dmg:3,spd:0,range:6,cd:1800, splash1:true, knock:true} },
];
const SPECIAL = [
  { key:"double",  name:"Double Type",  emoji:"üÉè", special:"double",  desc:"Double one of your existing troop types" },
  { key:"upgrade", name:"Upgrade Type", emoji:"‚¨ÜÔ∏è", special:"upgrade", desc:"Upgrade one existing troop type (+1 level)" }
];
const ALL_CARDS=[...TROOPS.map(t=>({type:"troop",...t})), ...SPECIAL.map(s=>({type:"special",...s}))];
const randCards=(n=3)=> Array.from({length:n},()=> ALL_CARDS[Math.floor(Math.random()*ALL_CARDS.length)]);

/* ---------- Local working copy ---------- */
let S=null;
let meIndex=0;
let host=false;

/* ---------- Phases ----------
draft (3 picks) ‚Üí battle ‚Üí loser-bonus (1 pick: both see, loser matters) ‚Üí draft-after (3 picks) ‚Üí battle ‚Üí ...
Lives: [4,4]. Game ends when any hits 0.
We maintain:
- roster[0], roster[1]: [{type,lvl,count}] (persistent army between battles)
- field.units: actual board layout for rendering and for battles (freshly cloned from roster at battle start; in draft we render from roster so both can see forces)
------------------------------------- */

/* ---------- Army / roster helpers ---------- */
const levelMult=(l)=> [1,1,1.5,2][l] || 1;
const levelClass=(l)=> l>=3?"l3":(l>=2?"l2":"l1");
function rosterAdd(roster, type, inc=1){
  const found=roster.find(r=>r.type===type);
  if (found) found.count += inc;
  else roster.push({type, lvl:1, count:inc});
}
function rosterDoubleOne(roster){
  const keys = roster.filter(r=>r.count>0);
  if (!keys.length) return;
  const k = keys[Math.floor(Math.random()*keys.length)];
  k.count += Math.max(1,k.count); // double (add current count)
}
function rosterUpgradeOne(roster){
  const keys = roster.filter(r=>r.count>0 && r.lvl<3);
  if (!keys.length) return;
  const k = keys[Math.floor(Math.random()*keys.length)];
  k.lvl = Math.min(3, k.lvl+1);
}
function buildFieldFromRoster(state){
  // Create fresh field from roster, placing units via spawn rules
  state.field = { units: [] };
  for (let p=0;p<2;p++){
    const arr = (state.roster?.[p]||[]);
    // expand counts into actual units with placement
    for (const r of arr){
      for (let i=0;i<r.count;i++){
        placeNewUnit(state, p, r.type, r.lvl);
      }
    }
  }
}

/* ---------- Placement rules ---------- */
function forwardDir(p){ return p===0 ? -1 : +1; }
const centerRow = Math.floor(H/2);
function frontlineRow(p){ return p===0 ? centerRow : centerRow-1; }
function backlineRowStart(p){ return p===0 ? H-1 : 0; }
function bumpAllTowardCenter(state, p){
  const dir = -forwardDir(p); // toward center
  // ensure valid
  for (const u of state.field.units){ if (u.p!==p) continue;
    const ny=u.y+dir; if (!inside(u.x,ny)) return false;
    // collision check
    if (state.field.units.some(v=>v!==u && v.x===u.x && v.y===ny)) return false;
  }
  // apply
  for (const u of state.field.units){ if (u.p===p) u.y += dir; }
  return true;
}
function tryRowSlot(state, row){
  const cx=Math.floor(W/2);
  const order=[0,-1,1,-2,2,-3,3,-4,4, -5,5]; // wider safety
  for (const dx of order){
    const x=Math.max(0,Math.min(W-1,cx+dx));
    if (!state.field.units.some(o=>o.x===x && o.y===row)) return {x,y:row};
  }
  return null;
}
function spawnSlotForType(state, p, typeKey){
  const base = TROOPS.find(t=>t.key===typeKey);
  const role = base?.role || "front";
  const owned = state.field.units.filter(u=>u.p===p);
  const same = owned.filter(u=>u.type===typeKey);
  // prefer clustering: use the last placed same-type row if exists
  if (same.length){
    const row = same[same.length-1].y;
    const pos = tryRowSlot(state,row); if (pos) return pos;
  }
  let row = (role==="back"? backlineRowStart(p) : frontlineRow(p));
  while (inside(0,row)){
    const pos = tryRowSlot(state,row); if (pos) return pos;
    if (role==="back"){
      // push army toward center if back row jammed
      if (!bumpAllTowardCenter(state,p)) break;
    }else{
      // try deeper toward base if front row jammed
      row = (p===0? row+1 : row-1);
    }
  }
  // fallback: any free on your half
  const yStart = (p===0? centerRow : 0);
  const yEnd   = (p===0? H-1 : centerRow-1);
  for (let y=yStart;y<=yEnd;y++){
    for (let x=0;x<W;x++){
      if (!state.field.units.some(o=>o.x===x && o.y===y)) return {x,y};
    }
  }
  return {x:Math.floor(W/2), y:(p===0? H-1:0)};
}
function placeNewUnit(state, p, typeKey, lvl){
  const base = TROOPS.find(t=>t.key===typeKey); if (!base) return;
  const pos = spawnSlotForType(state, p, typeKey);
  const u = {
    id: crypto.randomUUID(), p, type:typeKey, emoji:base.emoji, role:base.role,
    lvl, x:pos.x, y:pos.y,
    maxhp: Math.round(base.base.hp*levelMult(lvl)),
    hp: Math.round(base.base.hp*levelMult(lvl)),
    dmg: Math.round(base.base.dmg*levelMult(lvl)),
    spd: base.base.spd, range: base.base.range, cd: base.base.cd,
    bomber:!!base.base.bomber, assassin:!!base.base.assassin, splash1:!!base.base.splash1, knock:!!base.base.knock,
    nextAtk:0, fuse:0, stealthUntil:0, __jumped:false
  };
  state.field.units.push(u);
}

/* ---------- Rendering ---------- */
function render(){
  if (!S) return;
  $("phaseBadge").textContent = S.phase || "‚Äî";
  const tleft = Math.max(0, (S.phaseEndsAt||0) - Date.now());
  $("timerBadge").textContent = (S.phase==="draft"||S.phase==="loser-bonus"||S.phase==="draft-after") ? ("‚è≥ "+Math.ceil(tleft/1000)+"s") : "‚è≥ ‚Äî";

  const p0n = S.players?.[0] || "P0";
  const p1n = S.players?.[1] || "P1";
  $("p0Badge").textContent = `${p0n} ‚Äî ${"‚ù§".repeat(S.lives?.[0]??4)}`;
  $("p1Badge").textContent = `${p1n} ‚Äî ${"‚ù§".repeat(S.lives?.[1]??4)}`;

  // ensure field is built from roster during draft so both armies are visible
  if (S.phase==="draft" || S.phase==="loser-bonus" || S.phase==="draft-after"){
    const ghost = structuredClone(S);
    buildFieldFromRoster(ghost);
    paintBoard(ghost.field.units);
  }else{
    paintBoard(S.field?.units||[]);
  }

  // center cards
  const showCards = (S.phase==="draft" || S.phase==="loser-bonus" || S.phase==="draft-after");
  $("overlay").style.display = showCards ? "block":"none";
  $("centerCards").style.display = showCards ? "flex":"none";
  if (showCards) drawCardsUI();
}
function paintBoard(units){
  const grid = Array(W*H).fill(null);
  for (const u of units){ grid[idx(u.x,u.y)] = u; }
  for (let i=0;i<W*H;i++){
    const d = cellsEl.children[i];
    const u = grid[i];
    d.className="cell";
    if (u){
      d.classList.add(levelClass(u.lvl));
      d.classList.add(u.p===0?"p0":"p1");
      d.querySelector(".unit").textContent = u.emoji;
      d.querySelector(".tag").textContent = (u.p===0?"P0":"P1");
      const pct = Math.max(0, Math.round(100*(u.hp/u.maxhp)));
      d.querySelector(".hp>i").style.width = pct+"%";
    }else{
      d.querySelector(".unit").textContent = "";
      d.querySelector(".tag").textContent = "";
      d.querySelector(".hp>i").style.width = "0%";
    }
  }
}
function drawCardsUI(){
  const cards = S.currentPack || [];
  const wrap = $("centerCards");
  wrap.innerHTML="";
  cards.forEach((c, i)=>{
    const el=document.createElement("div");
    el.className="card";
    if (c.type==="troop"){
      el.innerHTML=`<div class="title">${c.emoji} ${c.name}</div><div class="desc">${c.role==="back"?"Backline":"Frontline"} unit</div>`;
    }else{
      el.innerHTML=`<div class="title">${c.emoji} ${c.name}</div><div class="desc">${c.desc}</div>`;
    }
    el.onclick = ()=> chooseCard(i);
    wrap.appendChild(el);
  });
}

/* ---------- Choosing a card ---------- */
async function chooseCard(index){
  if (!S) return;
  if (!(S.phase==="draft"||S.phase==="loser-bonus"||S.phase==="draft-after")) return;
  const key = `selections.${meIndex}.${S.draftIndex}`;
  const cur = S.selections?.[meIndex]?.[S.draftIndex];
  if (cur!=null) return; // already picked
  await updateDoc(stateRef, { [key]: index });
}

/* ---------- Host loop & battle sim ---------- */
let hostTimer=null, battleTimer=null;

function nearestEnemy(u, units){
  let best=null, bd=1e9;
  for (const v of units){ if (v.p===u.p) continue;
    const d=Math.abs(v.x-u.x)+Math.abs(v.y-u.y); if (d<bd){ bd=d; best=v; }
  }
  return best;
}
function cellFree(units,x,y){ return inside(x,y) && !units.some(o=>o.x===x && o.y===y); }
function tryKnock(cx,cy, target, units){
  if (!target) return;
  const dx=Math.sign(target.x-cx), dy=Math.sign(target.y-cy);
  const nx=target.x+dx, ny=target.y+dy;
  if (cellFree(units,nx,ny)){ target.x=nx; target.y=ny; }
}
function splash(units, x,y, dmg, srcP, knock=false){
  for (let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){
    if (!dx && !dy) continue;
    const nx=x+dx, ny=y+dy; if (!inside(nx,ny)) continue;
    const hit=units.find(o=>o.p!==srcP && o.x===nx && o.y===ny);
    if (hit){ hit.hp -= dmg; if (knock) tryKnock(x,y,hit,units); }
  }
}
function attack(u,t, nowMs, units){
  const dist=Math.abs(u.x-t.x)+Math.abs(u.y-t.y);
  if (dist <= (u.range||1)){
    if (nowMs >= u.nextAtk){
      if (u.bomber && dist<=1){
        u.fuse = u.fuse || (nowMs+1000);
      }else{
        t.hp -= u.dmg;
        if (u.splash1) splash(units, t.x,t.y, Math.max(1,Math.floor(u.dmg*0.6)), u.p, !!u.knock);
      }
      u.nextAtk = nowMs + (u.cd||600);
    }
    return true;
  }
  return false;
}
function stepToward(u,t,units){
  const dx=Math.sign(t.x-u.x), dy=Math.sign(t.y-u.y);
  const opts=[];
  if (Math.abs(t.y-u.y) >= Math.abs(t.x-u.x)) opts.push([u.x,u.y+dy],[u.x+dx,u.y]);
  else opts.push([u.x+dx,u.y],[u.x,u.y+dy]);
  opts.push([u.x+dx,u.y-dy],[u.x-dx,u.y+dy],[u.x-dx,u.y],[u.x,u.y-dy]);
  for (const [nx,ny] of opts){ if (cellFree(units,nx,ny)){ u.x=nx;u.y=ny;return; } }
}
function assassinLogic(u, nowMs, units){
  if (!u.assassin) return;
  if (!u.stealthUntil) u.stealthUntil = nowMs+3000;
  if (nowMs >= u.stealthUntil && !u.__jumped){
    const enemy=1-u.p; const row=backlineRowStart(enemy);
    const cx=Math.floor(W/2), order=[0,-1,1,-2,2,-3,3,-4,4];
    for (const dx of order){
      const x=Math.max(0,Math.min(W-1,cx+dx));
      if (cellFree(units,x,row)){ u.x=x;u.y=row;u.__jumped=true;break; }
    }
  }
}
function clean(units){ return units.filter(u=>u.hp>0); }

async function hostLoop(){
  clearInterval(hostTimer);
  hostTimer=setInterval(async ()=>{
    const snap=await getDoc(stateRef);
    if (!snap.exists()) return;
    const d=snap.data();

    // init
    if (!d.inited){
      const lob=await getDoc(doc(db,"lobbies",gameId));
      const players=(lob.exists()? (lob.data().players||[]) : [username]).slice(0,2);
      const next={
        inited:true, players, lives:[4,4],
        phase:"draft", phaseEndsAt: Date.now()+10_000,
        draftIndex:0, currentPack: randCards(3),
        selections:[[],[]],
        roster:[[],[]], // persistent armies
        field:{units:[]},
        winner:null
      };
      await setDoc(stateRef,next);
      return;
    }

    // phase timeouts / auto-picks
    const nowMs=Date.now();
    if ((d.phase==="draft"||d.phase==="loser-bonus"||d.phase==="draft-after") && nowMs >= (d.phaseEndsAt||0)){
      // ensure both have a pick
      const sel = d.selections || [[],[]];
      for (let p=0;p<2;p++){
        if (sel[p][d.draftIndex]==null){
          sel[p][d.draftIndex] = Math.floor(Math.random()* (d.currentPack?.length||3));
        }
      }
      // apply picks to roster
      const pack = d.currentPack || [];
      const roster = d.roster || [[],[]];
      for (let p=0;p<2;p++){
        const pick = pack[ sel[p][d.draftIndex] ];
        if (pick.type==="troop"){
          rosterAdd(roster[p], pick.key, 1);
        }else if (pick.type==="special"){
          if (pick.special==="double") rosterDoubleOne(roster[p]);
          else if (pick.special==="upgrade") rosterUpgradeOne(roster[p]);
        }
      }

      // advance phase
      if (d.phase==="draft"){
        const nextIdx=d.draftIndex+1;
        if (nextIdx>=3){
          // start battle (clone from roster)
          const next={...d, phase:"battle", phaseEndsAt:0, draftIndex:0, selections:[[],[]], currentPack:[], roster};
          buildFieldFromRoster(next);
          await updateDoc(stateRef,next);
          startBattle();
        }else{
          await updateDoc(stateRef,{
            selections:sel, roster,
            draftIndex: nextIdx,
            currentPack: randCards(3),
            phaseEndsAt: Date.now()+10_000
          });
        }
        return;
      }
      if (d.phase==="loser-bonus"){
        // after loser bonus ‚Üí draft-after 3 picks
        await updateDoc(stateRef,{
          selections: [[],[]],
          roster,
          phase:"draft-after",
          draftIndex:0,
          currentPack: randCards(3),
          phaseEndsAt: Date.now()+10_000
        });
        return;
      }
      if (d.phase==="draft-after"){
        const nextIdx=d.draftIndex+1;
        if (nextIdx>=3){
          const next={...d, phase:"battle", phaseEndsAt:0, draftIndex:0, selections:[[],[]], currentPack:[], roster};
          buildFieldFromRoster(next);
          await updateDoc(stateRef,next);
          startBattle();
        }else{
          await updateDoc(stateRef,{
            selections:sel, roster,
            draftIndex: nextIdx,
            currentPack: randCards(3),
            phaseEndsAt: Date.now()+10_000
          });
        }
        return;
      }
    }

    // battle driving guard
    if (d.phase==="battle" && !battleTimer){
      startBattle(); // safety
    }
    if (d.phase==="game-over"){
      clearInterval(hostTimer);
      if (battleTimer){ clearInterval(battleTimer); battleTimer=null; }
    }
  }, 250);
}

function startBattle(){
  if (battleTimer) return;
  battleTimer=setInterval(async ()=>{
    const snap=await getDoc(stateRef);
    if (!snap.exists()){ clearInterval(battleTimer); battleTimer=null; return; }
    const d=snap.data();
    if (d.phase!=="battle"){ clearInterval(battleTimer); battleTimer=null; return; }
    const state=structuredClone(d);
    const units=state.field.units;

    // tick
    const nowMs=Date.now();

    // assassin stealth/jump
    for (const u of units){ if (u.assassin) assassinLogic(u, nowMs, units); }

    // bomber explosions
    for (const u of units){ if (u.bomber && u.fuse && nowMs>=u.fuse){
      const center=units.find(v=>v.p!==u.p && v.x===u.x && v.y===u.y);
      if (center){ center.hp -= u.dmg; tryKnock(u.x,u.y,center,units); }
      splash(units,u.x,u.y, Math.max(1,Math.floor(u.dmg*0.8)), u.p, true);
      u.hp=0;
    }}
    state.field.units = clean(units);

    // attacks / moves
    for (const u of state.field.units){
      if (u.type==="rocket"){
        const t=nearestEnemy(u,state.field.units);
        if (t) attack(u,t,nowMs,state.field.units);
        continue;
      }
      const t=nearestEnemy(u,state.field.units);
      if (!t) continue;
      if (!attack(u,t,nowMs,state.field.units)){
        if (u.spd>0) stepToward(u,t,state.field.units);
      }
    }
    state.field.units = clean(state.field.units);

    // end?
    const alive0=state.field.units.some(u=>u.p===0);
    const alive1=state.field.units.some(u=>u.p===1);
    if (!alive0 || !alive1){
      clearInterval(battleTimer); battleTimer=null;
      const loser = alive0?1:0;
      const lives = [...(state.lives||[4,4])];
      lives[loser]=Math.max(0, lives[loser]-1);

      // winner?
      const winner = lives[0]===0 ? state.players[1]
                    : lives[1]===0 ? state.players[0] : null;

      // after battle, we DO NOT change roster (armies persist); field will be rebuilt from roster for next draft
      const next = {
        ...state,
        lives,
        phase: winner ? "game-over" : "loser-bonus",
        phaseEndsAt: winner ? 0 : Date.now()+10_000,
        winner: winner || null,
        selections:[[],[]],
        currentPack: winner ? [] : randCards(3),
        draftIndex: 0
      };
      await updateDoc(stateRef,next);
    }else{
      await updateDoc(stateRef,state);
    }
  }, 250);
}

/* ---------- Snapshot & identity ---------- */
onSnapshot(stateRef, (snap)=>{
  if (!snap.exists()) return;
  S = snap.data();

  // who am I?
  meIndex = Math.max(0, (S.players||[]).indexOf(username));

  // render
  render();
});

/* ---------- Host gate ---------- */
(async function setHost(){
  const lob = await getDoc(doc(db,"lobbies",gameId));
  host = lob.exists() && lob.data().host===username;
  if (host) hostLoop();
})();

/* ---------- Card click guards in UI ---------- */
window.addEventListener("keydown",(e)=>{
  if (e.key==="f" && (e.ctrlKey||e.metaKey)){ e.preventDefault(); }
});

/* ---------- Fullscreen ---------- */
$("fsBtn").onclick = async ()=>{
  try{
    if (!document.fullscreenElement) await document.documentElement.requestFullscreen();
    else await document.exitFullscreen();
  }catch(e){}
};
</script>
</body>
</html>









