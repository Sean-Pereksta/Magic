<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>‚öîÔ∏è Draft Brawl ‚Äî Factions (2P)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<style>
  :root{
    --bg:#ffffff; --ink:#0f172a; --muted:#64748b; --line:#d1d5db;
    --shadow:0 10px 30px rgba(2,6,23,.18);
    --cell:64px; /* bigger tiles for closer view */
    --gap:4px;

    /* team fills kept around but unused now (rank colors used instead) */
    --p0bg:#ffdbe0;
    --p1bg:#dbe7ff;

    /* darker, solid rank colors */
    --rank1:#166534;  /* dark green */
    --rank2:#a16207;  /* dark amber/gold */
    --rank3:#991b1b;  /* dark red */

    /* team colors for HP bars */
    --team0:#ef4444;  /* red */
    --team0b:#dc2626; /* darker red */
    --team1:#3b82f6;  /* blue */
    --team1b:#2563eb; /* darker blue */
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    background:
      radial-gradient(circle at top,#ffffff 0,#f8fafc 55%,#eef2f7 100%);
    color:#0f172a;
    font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;
  }

  .topbar{
    position:sticky; top:0; z-index:30;
    background:linear-gradient(90deg,#020617,#020617,#0f172a);
    border-bottom:1px solid rgba(148,163,184,.35);
    padding:8px 12px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    box-shadow:0 12px 30px rgba(15,23,42,.65);
  }
  .row{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
  .badge{
    display:inline-flex;
    gap:8px;
    align-items:center;
    padding:6px 12px;
    border-radius:999px;
    background:rgba(15,23,42,.9);
    border:1px solid rgba(148,163,184,.4);
    box-shadow:0 6px 18px rgba(15,23,42,.55);
    font-weight:700;
    font-size:.85rem;
    color:#e5e7eb;
    backdrop-filter:blur(10px);
  }
  .badge.p0{border-color:#f97373;background:linear-gradient(135deg,rgba(248,113,113,.22),rgba(15,23,42,.95));}
  .badge.p1{border-color:#60a5fa;background:linear-gradient(135deg,rgba(96,165,250,.22),rgba(15,23,42,.95));}
  .badge.phase{background:rgba(15,23,42,.95);border-style:dashed;border-color:rgba(148,163,184,.7);}
  .badge.timer{background:rgba(15,23,42,.95);}

  .btn{
    appearance:none;
    border-radius:999px;
    padding:8px 12px;
    font-weight:700;
    cursor:pointer;
    border:1px solid rgba(148,163,184,.5);
    background:#111827;
    color:#e5e7eb;
    font-size:.85rem;
    display:inline-flex;
    align-items:center;
    gap:6px;
  }
  .btn.ghost{background:rgba(15,23,42,.8);}
  .btn:hover{border-color:#38bdf8;}

  .viewport{
    position:relative;
    width:100%;
    height:calc(100dvh - 70px);
    border-top:1px solid rgba(15,23,42,.2);
    border-radius:18px 18px 0 0;
    overflow:hidden;
    background:linear-gradient(180deg,#ffffff,#f8fafc);
    cursor:grab;
    user-select:none;
    touch-action:none;
  }
  .viewport:active{ cursor:grabbing; }
  .canvas{ position:absolute; left:0; top:0; transform-origin:0 0; will-change:transform; }

  .cells{
    position:relative;
    display:grid;
    grid-template-columns:repeat(var(--w),var(--cell));
    grid-auto-rows:var(--cell);
    gap:var(--gap);
    padding:10px;
  }
  .cell{
    width:var(--cell);height:var(--cell);
    border-radius:12px;
    background:
      radial-gradient(circle at 28% 26%, rgba(34,197,94,.28), transparent 40%),
      radial-gradient(circle at 70% 60%, rgba(120,53,15,.24), transparent 42%),
      linear-gradient(145deg,#d9f99d,#bbf7d0 55%,#86efac);
    border:1px solid rgba(22,101,52,.28);
    position:relative;
    overflow:hidden;
    box-shadow:0 1px 0 rgba(255,255,255,.75) inset, 0 2px 8px rgba(15,23,42,.12);
  }
  .cell.multi-origin{ overflow:visible; z-index:8; }

  /* Layers (z-index order): under(0) < ground fx(1) < unit(3) < hp(4) < status(6) */
  .under{
    position:absolute; inset:0; z-index:0;
    opacity:1 !important;
    mix-blend-mode:screen !important;
    filter:brightness(1.05) saturate(1.1);
  }
  .unit{ position:absolute; inset:0; display:grid; place-items:center; font-size:26px; z-index:3; pointer-events:none; }
  .unit.attacking{ animation:unitAttack .35s ease-out; }
  .unit.casting{ animation:unitCast .5s ease-out; }
  .unit .troop-art{ width:88%; height:88%; filter:drop-shadow(0 0 7px rgba(0,0,0,.55)); }
  .unit.big{ width:calc(200% + var(--gap)); height:calc(200% + var(--gap)); place-items:stretch; }
  .unit.big .troop-art{ width:100%; height:100%; }
  .unit svg{ width:100%; height:100%; overflow:visible; }
  .unit .stroke{ stroke:rgba(15,23,42,.95); stroke-width:2; }
  @keyframes unitAttack{
    0%{ transform:translateY(0) scale(1); }
    40%{ transform:translateY(-2px) scale(1.12); }
    100%{ transform:translateY(0) scale(1); }
  }
  @keyframes unitCast{
    0%{ transform:scale(1); filter:brightness(1); }
    50%{ transform:scale(1.08); filter:brightness(1.35); }
    100%{ transform:scale(1); filter:brightness(1); }
  }
  .unit.team0{
    filter:drop-shadow(0 0 1px rgba(15,23,42,.95)) drop-shadow(0 0 4px var(--team0)) drop-shadow(0 0 1px var(--team0b));
  }
  .unit.team1{
    filter:drop-shadow(0 0 1px rgba(15,23,42,.95)) drop-shadow(0 0 4px var(--team1)) drop-shadow(0 0 1px var(--team1b));
  }

  .hp{
    position:absolute;left:6px;right:6px;bottom:4px;height:7px;border-radius:999px;
    background:rgba(15,23,42,.9);overflow:hidden;z-index:4;
    box-shadow:0 0 0 1px rgba(15,23,42,.85),0 0 18px rgba(15,23,42,.9) inset;
  }
  .hp.big{
    width:calc(200% + var(--gap));
    right:auto;
    bottom:calc(4px - var(--cell) - var(--gap));
  }
  /* default (fallback) fill is green; team classes override it */
  .hp>i{
    display:block;height:100%;
    background:linear-gradient(90deg,#22c55e,#16a34a);
    box-shadow:0 0 18px rgba(34,197,94,.6);
  }
  /* team-colored HP fills */
  .hp>i.team0{ background:linear-gradient(90deg,var(--team0),var(--team0b)); box-shadow:0 0 18px rgba(248,113,113,.7); }
  .hp>i.team1{ background:linear-gradient(90deg,var(--team1),var(--team1b)); box-shadow:0 0 18px rgba(96,165,250,.7); }

  .status{
    position:absolute;
    top:4px;
    right:4px;
    display:flex;
    gap:2px;
    font-size:11px;
    z-index:6;
    pointer-events:none;
  }
  .status span{
    text-shadow:0 1px 2px rgba(0,0,0,.7);
  }

  .hitflash{ position:absolute; inset:0; background:rgba(248,250,252,.9); animation:flash .12s ease; pointer-events:none; z-index:2 }
  @keyframes flash{ from{opacity:.9} to{opacity:0} }
  .dmg{
    position:absolute; left:50%; top:40%; transform:translate(-50%,-50%);
    font-weight:900; font-size:12px; color:#f97373; text-shadow:0 1px 0 rgba(15,23,42,.7);
    animation:dmg 600ms ease-out forwards; pointer-events:none; z-index:5;
  }
  @keyframes dmg{
    0%{opacity:0; transform:translate(-50%,-40%) scale(.9)}
    10%{opacity:1;}
    100%{opacity:0; transform:translate(-50%,-100%) scale(1)}
  }

  /* Ground effects (more saturated) */
  .poison{ position:absolute; inset:0; background:#15803d; opacity:.85; z-index:1; animation:poipulse 1s ease-in-out infinite; }
  @keyframes poipulse{ 0%,100%{filter:brightness(1)} 50%{filter:brightness(1.15)} }

  .toxic{ position:absolute; inset:0; background:#6b21a8; opacity:.9; z-index:1; animation:toxpulse 1s ease-in-out infinite; }
  @keyframes toxpulse{ 0%,100%{filter:saturate(1)} 50%{filter:saturate(1.2)} }

  .acid{ position:absolute; inset:0; background:#1d4ed8; opacity:.85; z-index:1; animation:acidpulse 1s ease-in-out infinite; }
  @keyframes acidpulse{ 0%,100%{filter:saturate(1)} 50%{filter:saturate(1.2)} }
  .ward{ position:absolute; inset:0; background:#8ec5ff33; border:1px solid #4ea3ff; z-index:1; box-shadow:0 0 20px rgba(59,130,246,.7) inset; }

  /* Draft overlay */
  .overlay{position:absolute;inset:0;background:radial-gradient(circle at top,rgba(15,23,42,.85),rgba(15,23,42,.97));display:none;z-index:40}
  .cardRow{
    position:absolute;
    left:50%;top:50%;
    transform:translate(-50%,-50%);
    display:flex;
    gap:14px;
    z-index:50;
    flex-wrap:wrap;
    justify-content:center;
    max-width:960px;
  }
  .card{
    width:min(260px,40vw);
    background:radial-gradient(circle at top,#0b1120,#020617);
    border-radius:16px;
    border:1px solid rgba(148,163,184,.7);
    box-shadow:0 18px 40px rgba(15,23,42,.9);
    padding:12px 14px;
    cursor:pointer;
    display:grid;
    gap:6px;
    user-select:none;
    transition:transform .12s ease, box-shadow .12s ease, border-color .12s ease;
  }
  .card .title{
    font-weight:800;
    letter-spacing:.02em;
    font-size:.96rem;
    color:#e5e7eb;
  }
  .card .meta{
    font-size:.78rem;
    text-transform:uppercase;
    letter-spacing:.08em;
    color:#93c5fd;
  }
  .card .desc{
    color:#cbd5f5;
    font-size:.88rem;
  }
  .card:hover{
    transform:translateY(-3px);
    box-shadow:0 22px 50px rgba(15,23,42,1);
    border-color:#38bdf8;
  }

  .pickNote{
    position:absolute;left:50%;top:12%;transform:translateX(-50%);
    z-index:60;background:rgba(15,23,42,.96);border:1px solid rgba(148,163,184,.7);border-radius:999px;box-shadow:var(--shadow);
    padding:8px 16px;font-weight:800;display:none;font-size:.85rem;color:#e5e7eb;letter-spacing:.03em;text-transform:uppercase;
  }
  .pickCounter{
    position:absolute;left:50%;top:7%;transform:translateX(-50%);
    z-index:61;background:rgba(15,23,42,.96);border:1px solid rgba(148,163,184,.7);border-radius:999px;box-shadow:var(--shadow);
    padding:6px 14px;font-weight:800;display:none;font-size:.78rem;color:#bfdbfe;text-transform:uppercase;letter-spacing:.08em;
  }

  /* VFX */
  .beams, .particles{ position:absolute; left:0; top:0; width:1px; height:1px; transform:translate3d(0,0,0); pointer-events:none; }
  .beam{
    position:absolute; height:3px; border-radius:3px; background:linear-gradient(90deg,rgba(59,130,246,.98),rgba(239,68,68,.98));
    opacity:.98; transform-origin:0 50%; animation:beamfade .35s ease-out forwards; box-shadow:0 0 16px rgba(59,130,246,.8);
  }
  .hbeam{
    position:absolute; height:3px; border-radius:3px; background:linear-gradient(90deg,rgba(34,197,94,1),rgba(134,239,172,1));
    opacity:1; transform-origin:0 50%; animation:beamfade .35s ease-out forwards; box-shadow:0 0 16px rgba(34,197,94,.9);
  }
  .tline{
    position:absolute;
    height:3px;
    border-radius:3px;
    background:linear-gradient(90deg,#22c55e,#06b6d4);
    opacity:.98;
    transform-origin:0 50%;
    animation:beamfade .45s ease-out forwards;
    box-shadow:0 0 16px rgba(45,212,191,.9);
  }
  @keyframes beamfade{ to{ opacity:0 } }

  .p{ position:absolute; width:6px; height:6px; border-radius:50%; background:#ef4444; opacity:.95; animation:pfade .7s ease-out forwards; box-shadow:0 0 10px rgba(248,113,113,.7);}
  .p.purple{ background:#a855f7; box-shadow:0 0 12px rgba(168,85,247,.9);}
  @keyframes pfade{ to{ opacity:0; transform:translateY(-8px) scale(.7) } }
  .impact{
    position:absolute; width:16px; height:16px; border-radius:50%;
    border:2px solid rgba(248,113,113,.92);
    box-shadow:0 0 14px rgba(248,113,113,.9);
    animation:impact .32s ease-out forwards;
  }
  .storm{
    position:absolute;
    width:calc(var(--cell) * 2.3);
    height:calc(var(--cell) * 2.3);
    border-radius:50%;
    background:
      radial-gradient(circle, rgba(96,165,250,.45) 0%, rgba(37,99,235,.22) 45%, rgba(15,23,42,0) 75%);
    border:2px solid rgba(56,189,248,.7);
    box-shadow:0 0 24px rgba(56,189,248,.7), inset 0 0 20px rgba(59,130,246,.6);
    animation:stormPulse .6s ease-out forwards;
    pointer-events:none;
  }
  .storm:before, .storm:after{
    content:"";
    position:absolute;
    width:3px;
    height:70%;
    left:48%;
    top:15%;
    background:linear-gradient(180deg,#dbeafe,#60a5fa,#1d4ed8);
    box-shadow:0 0 10px rgba(147,197,253,.95);
    transform-origin:50% 0;
  }
  .storm:before{ transform:rotate(-20deg); }
  .storm:after{ transform:rotate(22deg); }
  @keyframes stormPulse{
    0%{ opacity:0; transform:translate(-50%,-50%) scale(.65); }
    30%{ opacity:1; transform:translate(-50%,-50%) scale(1); }
    100%{ opacity:0; transform:translate(-50%,-50%) scale(1.2); }
  }

  .nameBronze{color:#cd7f32}
  .nameSilver{color:#c0c0c0}
  .nameGold{color:#fbbf24}
  .nameDiamond{color:#60a5fa}
  .nameMasters{
    background:linear-gradient(90deg,#f43f5e,#f59e0b,#22d3ee,#a78bfa,#f43f5e);
    background-size:250% 100%;
    -webkit-background-clip:text; background-clip:text; color:transparent;
    animation:rankShift 2s linear infinite;
  }
  .nameGrandmaster{
    background:linear-gradient(90deg,#f59e0b,#ef4444,#fbbf24,#dc2626,#f59e0b);
    background-size:260% 100%;
    -webkit-background-clip:text; background-clip:text; color:transparent;
    animation:rankShift 1.4s linear infinite;
    text-shadow:0 0 8px rgba(239,68,68,.6);
  }
  @keyframes rankShift{ from{background-position:0 0} to{background-position:220% 0} }
  @keyframes impact{
    from{ opacity:.95; transform:translate(-50%,-50%) scale(.5); }
    to{ opacity:0; transform:translate(-50%,-50%) scale(1.7); }
  }
  .statusPop{
    position:absolute;
    font-size:14px;
    text-shadow:0 1px 2px rgba(0,0,0,.9);
    animation:statusFloat .6s ease-out forwards;
  }
  @keyframes statusFloat{
    from{ opacity:.95; transform:translate(-50%,-50%); }
    to{ opacity:0; transform:translate(-50%,-130%); }
  }

  .endSummary{
    position:fixed;
    left:50%;
    bottom:16px;
    transform:translateX(-50%);
    min-width:280px;
    max-width:90vw;
    background:#020617;
    color:#e5e7eb;
    padding:10px 14px;
    border-radius:12px;
    box-shadow:0 18px 40px rgba(15,23,42,.95);
    font-size:.9rem;
    z-index:50;
    display:none;
    border:1px solid rgba(148,163,184,.6);
  }
  .endSummary .mmrUp{ color:#22c55e; font-weight:700; }
  .endSummary .mmrDown{ color:#ef4444; font-weight:700; }

  @media (max-width:768px){
    .badge{padding:5px 10px;font-size:.8rem}
    .btn{padding:6px 10px;font-size:.8rem}
    .card{width:min(260px,88vw);}
    .cells{padding:6px;}
  }
</style>
</head>
<body>
  <div class="topbar">
    <div class="row">
      <span class="badge">‚öîÔ∏è Draft Brawl ‚Äî Factions</span>
      <span id="phaseBadge" class="badge phase">‚Äî</span>
    </div>
    <div class="row">
      <span id="p0Badge" class="badge p0">P0 ‚Äî ‚ù§‚ù§‚ù§‚ù§</span>
      <span id="p1Badge" class="badge p1">P1 ‚Äî ‚ù§‚ù§‚ù§‚ù§</span>
      <span id="timerBadge" class="badge timer">‚è≥ ‚Äî</span>
      <button id="fsBtn" class="btn ghost">‚õ∂ Fullscreen</button>
    </div>
  </div>

  <div class="viewport" id="viewport">
    <div class="canvas" id="canvas">
      <div id="cells" class="cells" style="--w:8; --cell:64px; --gap:4px"></div>
      <div id="beams" class="beams"></div>
      <div id="particles" class="particles"></div>
    </div>
    <div id="overlay" class="overlay"></div>
    <div id="cardRow" class="cardRow" style="display:none"></div>
    <div id="pickNote" class="pickNote"></div>
    <div id="pickCounter" class="pickCounter"></div>
  </div>

  <div id="endSummary" class="endSummary"></div>

<script type="module">
/* ---------------- Firebase ---------------- */
// NOTE: Make sure your Firestore rules allow access to
// /lobbies/{gameId} and /lobbies/{gameId}/crowncouncil/state
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, runTransaction } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};

const app  = initializeApp(firebaseConfig);
const db   = getFirestore(app);
const auth = getAuth(app);

// üîê Sign in anonymously
signInAnonymously(auth).catch((error) => {
  console.error("Anon sign-in failed", error);
});


/* --------- safe deep clone ---------- */
function deepClone(obj){
  if (typeof structuredClone === "function") {
    return structuredClone(obj);
  }
  return JSON.parse(JSON.stringify(obj));
}

/* ---------------- URL params ---------------- */
const params   = new URLSearchParams(location.search);
const gameId   = params.get("gameId");
const username = params.get("username");
if (!gameId || !username){ alert("Missing gameId or username in URL."); }

const lobbyRef = doc(db,"lobbies",gameId);
const stateRef = doc(db,"lobbies",gameId,"crowncouncil","state");

/* ---------------- Pace / sizes ---------------- */
const PACE = {
  tickMs: 560,
  atkMult: 2.35,
  moveSteps: 1,
  poisonDotMs: 900,
  poisonSlowMs: 1100,
  toxicDotMs: 1000
};
const VIEW_MS  = 120;   // publish + render cadence
const LOGIC_MS = 560;   // core logic cadence
const MOVE_MS  = 560;   // gate movement per unit

let CELL=64, GAP=4, W=8, H=16;

/* ---------------- DOM ---------------- */
const $ = (id)=>document.getElementById(id);
const cellsEl=$("cells"), canvas=$("canvas"), viewport=$("viewport"), beamsEl=$("beams"), partsEl=$("particles");

/* ---------------- Fit/zoom & pan ---------------- */
let boardScale=1, pan={x:12, y:12};
function applyTransform(){
  canvas.style.transform = `translate(${pan.x}px, ${pan.y}px) scale(${boardScale})`;
}
function fitBoard(){
  const boardW = W*(CELL+GAP)-GAP;
  const boardH = H*(CELL+GAP)-GAP;
  const vw = viewport.clientWidth, vh=viewport.clientHeight;

  const fitScale = Math.min(vw/boardW, vh/boardH);
  boardScale = Math.min(2.2, fitScale * 1.25);

  pan.x = Math.round((vw - boardW*boardScale) / 2);
  pan.y = Math.round((vh - boardH*boardScale) / 2);
  applyTransform();
}
new ResizeObserver(fitBoard).observe(viewport);

/* pointer pan */
let dragging=false, last={x:0,y:0};
viewport.addEventListener("pointerdown", e=>{
  dragging=true; last={x:e.clientX,y:e.clientY};
});
viewport.addEventListener("pointermove", e=>{
  if(!dragging) return;
  const dx=e.clientX-last.x, dy=e.clientY-last.y;
  pan.x+=dx; pan.y+=dy; applyTransform();
  last={x:e.clientX,y:e.clientY};
});
viewport.addEventListener("pointerup", ()=>{ dragging=false; });
viewport.addEventListener("pointercancel", ()=>{ dragging=false; });

let didEnsure = false;
let ensureInFlight = false;
let listenersStarted = false;

async function fetchPlayerMMR(players){
  const p = Array.isArray(players) ? players.slice(0,2) : [];
  const out = [1000,1000];
  for (let i=0;i<2;i++){
    const name = p[i];
    if (!name) continue;
    try{
      const us = await getDoc(doc(db, "users", name));
      if (us.exists()){
        const val = Number(us.data()?.crowncouncilElo);
        if (Number.isFinite(val) && val > 0) out[i] = Math.round(val);
      }
    }catch(e){
      console.warn("fetchPlayerMMR failed for", name, e);
    }
  }
  return out;
}

/* -------- transactional state creation (host only) -------- */
async function ensureStateExists(){
  if (didEnsure || ensureInFlight) return;
  ensureInFlight = true;
  try {
    const lobSnap = await getDoc(lobbyRef);
    const lob = lobSnap.exists() ? lobSnap.data() : {};
    const players = Array.isArray(lob.players) ? lob.players.slice(0, 2) : [];
    const seededMMR = await fetchPlayerMMR(players);

    await runTransaction(db, async (tx)=>{
      const stSnap = await tx.get(stateRef);
      if (stSnap.exists()) {
        didEnsure = true;
        return;
      }
      const now = Date.now();

      tx.set(stateRef, {
        players: players,
        lives: [4, 4],
        phase: players.length < 2 ? "waiting" : "faction-select",
        phaseEndsAt: players.length < 2 ? 0 : now + 20000,
        roster:   { p0: [], p1: [] },
        factions: { p0: null, p1: null },
        field:    { units: [], poison: [], toxic: [], acid: [], wards: [], fx: [] },
        selections:   { p0: [], p1: [] },
        currentPacks: { p0: [], p1: [] },
        bonusFor: null,
        draftIndex: 0,
        winner: null,
        mmr: seededMMR,
        mmrChange: [0, 0],
        eloCommitted: false
      });
      didEnsure = true;
    });
  } catch (e) {
    console.error("ensureStateExists failed", e);
  } finally {
    ensureInFlight = false;
  }
}

/* ---------------- Build cells ---------------- */
function buildBoard(){
  cellsEl.style.setProperty("--w", W);
  cellsEl.style.setProperty("--cell", CELL + "px");
  cellsEl.style.setProperty("--gap", GAP + "px");
  const frag=document.createDocumentFragment();
  for (let y=0;y<H;y++){
    for (let x=0;x<W;x++){
      const d=document.createElement("div");
      d.className="cell";
      d.dataset.x=String(x); d.dataset.y=String(y);
      d.innerHTML = `
        <div class="under"></div>
        <div class="unit"></div>
        <div class="hp"><i style="width:0%"></i></div>
        <div class="status"></div>
      `;
      frag.appendChild(d);
    }
  }
  cellsEl.innerHTML="";
  cellsEl.appendChild(frag);
}
buildBoard();

/* ---------------- Units & data ---------------- */
const R = (hp,dmg,range,cd)=>({hp:hp,dmg:dmg,range:range,cd:cd});
const M = (hp,dmg,cd)=>({hp:hp,dmg:dmg,range:1,cd:cd});

const TROOPS = {
  /* Vanir */
  rifleman: { faction:"Vanir", name:"Riflemen",    emoji:"üî´", role:"back",  base:Object.assign({},R(7,3,6,1050),{armor:0}), spawn:2 },
  vrocket:  { faction:"Vanir", name:"Rockets",     emoji:"üöÄ", role:"back",  base:Object.assign({},R(8,6,10,2100),{splash1:true,knock:true,armor:0}) },
  vguard:   { faction:"Vanir", name:"Vanir Guard", emoji:"üõ°Ô∏è", role:"front", base:Object.assign({},M(22,5,800),{splash1:true,armor:3}) },
  miner:    { faction:"Vanir", name:"Miners",      emoji:"‚õèÔ∏è", role:"front", base:Object.assign({},M(16,3,800),{spd:2,hunterRanged:true,armor:1}), spawn:2 },
  medic:    { faction:"Vanir", name:"Field Medic", emoji:"üß∞", role:"back",
    base:{ hp:11, dmg:0, range:3, cd:1100, heal:true, healAmt:3, healRange:3, healCd:1200, armor:0 }
  },

  suppressor:{ faction:"Vanir", name:"Suppressor", emoji:"üßØ", role:"back",
    base:{ hp:8, dmg:2, range:3, cd:850, spd:1, armor:0 },
    suppress:true,
    suppressDur:900,
    slowFactor:2
  },

  shieldcap:{ faction:"Vanir", name:"Shield Captain", emoji:"üõ°Ô∏è‚≠ê", role:"front",
    base:{ hp:19, dmg:3, range:1, cd:800, spd:1, armor:2 },
    auraReduce:1,
    auraRange:2
  },
  marksman:{ faction:"Vanir", name:"Marksman", emoji:"üéØ", role:"back",
    base:{ hp:8, dmg:5, range:6, cd:1450, spd:1, armor:0 },
    strongVs:["light"],
    antiSupport:true,
    supportBonus:4,
    executePct:0.35
  },
  emp:{ faction:"Vanir", name:"EMP Grenadier", emoji:"üß≤", role:"back",
    base:{ hp:9, dmg:3, range:4, cd:1200, spd:1, armor:0 },
    empShock:true,
    shockDur:1500
  },

  /* Aesir */
  phaser:   { faction:"Aesir", name:"Phasers",   emoji:"‚ú®", role:"back",  base:Object.assign({},R(6,5,4,1100),{blink50:true,armor:0}), spawn:2 },
  blade:    { faction:"Aesir", name:"Blademasters", emoji:"‚öîÔ∏è", role:"front", base:Object.assign({},M(14,6,700),{spd:2,armor:1}), spawn:2 },
  storm:    { faction:"Aesir", name:"Storm Seer", emoji:"üå©Ô∏è", role:"back",  base:Object.assign({},R(7,4,3,1100),{chain3:true,armor:0}) },
  guardian: { faction:"Aesir", name:"Guardian",  emoji:"üåÄ", role:"front", base:Object.assign({},M(24,6,900),{splash1:true,knock:true,strongKnock:true,armor:3}), size:1 },
  wardmaker:{ faction:"Aesir", name:"Wardmaker", emoji:"üîÆ", role:"back",
    base:{ hp:7, dmg:0, range:3, cd:1500, ward:true, wardCd:1900, wardDur:5100, wardHp:4, armor:0 },
    wardHealAmt:2, wardHealRange:3, wardHealCd:2500
  },
  architect:{
    faction:"Aesir", name:"Aegis Architect", emoji:"üß±", role:"back",
    base:{ hp:8, dmg:0, range:3, cd:1600, ward:true, wardCd:2200, wardDur:7000, wardHp:4, armor:1 },
    wardShooter:true,
    wardDmg:2,
    wardRange:3,
    wardCdShoot:1400
  },
  golem:{ faction:"Aesir", name:"Sentinel Golem", emoji:"üóø", role:"front",
    base:{ hp:30, dmg:5, range:1, cd:1050, spd:1, armor:2 }, size:2,
    rangedReduce:2
  },
  runebinder:{ faction:"Aesir", name:"Rune Binder", emoji:"ü™Ñ", role:"back",
    base:{ hp:8, dmg:2, range:4, cd:1250, spd:1, armor:0 },
    bind:true,
    bindDur:1200
  },

  /* Helions */
  hellspawn:{ faction:"Helions", name:"Hell Spawn", emoji:"üêú", role:"front", base:Object.assign({},M(9,2,500),{spd:3,armor:0}), spawn:4 },
  roach:    { faction:"Helions", name:"Roaches",  emoji:"üëæ", role:"back",  base:Object.assign({},R(11,4,3,1000),{armor:1}), spawn:2 },
  defiler:  { faction:"Helions", name:"Defiler",  emoji:"ü¶Ç", role:"front", base:Object.assign({},M(22,4,900),{splash1:true,toxicSplash:true,armor:2}), size:1 },
  blood:    { faction:"Helions", name:"BloodBurst", emoji:"üêû", role:"front", base:Object.assign({},M(9,3,0),{kamikaze:true,paints:true,armor:0}), spawn:2 },
  matron:{
    faction:"Helions", name:"Brood Matron", emoji:"üï∑Ô∏è", role:"back",
    base:{ hp:18, dmg:1, range:3, cd:1200, armor:1 },
    brood:true,
    broodType:"hellspawn",
    broodCd:3500
  },
  viper:{
    faction:"Helions", name:"Viper", emoji:"üêç", role:"front",
    base:{ hp:8, dmg:14, range:1, cd:2000, spd:2, armor:0 },
    strongVs:["armored"],
    hunterRanged:true,
    trueDamage:true,
    viperLeap:true,
    leapDist:2, spawn:2
  },
  spitter:  { faction:"Helions", name:"Spitter Brood", emoji:"üü£", role:"back", base:Object.assign({},R(9,4,5,1200),{acid:true,acidDur:3500,armor:0}) },
  carrion:{ faction:"Helions", name:"Carrion Priest", emoji:"ü©∏", role:"back",
    base:{ hp:9, dmg:3, range:4, cd:1200, spd:1, armor:0 },
    wound:true,
    woundDur:2600
  },
  burrower:{ faction:"Helions", name:"Burrower", emoji:"ü™±", role:"front",
    base:{ hp:7, dmg:7, range:1, cd:1200, spd:2, armor:0 },
    burrow:true,
    burrowDist:2,
    burrowCd:2200
  }
};
const FACTIONS = {
  Vanir:  ["rifleman","vrocket","vguard","miner","medic","suppressor","shieldcap","marksman","emp"],
  Aesir:  ["phaser","blade","storm","guardian","wardmaker","architect","golem","runebinder"],
  Helions:["hellspawn","roach","defiler","blood","spitter","matron","viper","carrion","burrower"]
};
const ALL_FACTIONS = ["Helions","Aesir","Vanir"];

/* ---------------- Helpers & state ---------------- */
const pKey = (i)=> i===0 ? "p0" : "p1";
const idx=(x,y)=> y*W+x;
const inside=(x,y)=> x>=0 && x<W && y>=0 && y<H;

function rankColor(lvl){
  const root = document.documentElement;
  if (lvl===3) return getComputedStyle(root).getPropertyValue('--rank3') || '#ef4444';
  if (lvl===2) return getComputedStyle(root).getPropertyValue('--rank2') || '#eab308';
  return getComputedStyle(root).getPropertyValue('--rank1') || '#22c55e';
}

function manhattan(a, b){ return Math.abs(a.x - b.x) + Math.abs(a.y - b.y); }

let S=null, lobbyPlayers=[], meIndex=0, isHost=false;
const fieldEmpty = ()=>({units:[], poison:[], toxic:[], acid:[], wards:[], fx:[]});

/* 2√ó2 helpers */
function unitSize(u){ return TROOPS[u.type] && TROOPS[u.type].size===2 ? 2 : 1; }
function armorTypeFor(type, unit){
  const t = TROOPS[type] || {};
  if (t.armorType) return t.armorType;
  if (unit && unit.size===2) return "armored";
  const armorVal = (unit && typeof unit.armor === "number") ? unit.armor : ((t.base && t.base.armor) || 0);
  if (armorVal >= 3) return "armored";
  if (t.role === "back") return "light";
  return "balanced";
}
function unitStrongVs(type){
  if (type === "guardian") return ["light"];
  return (TROOPS[type] && TROOPS[type].strongVs) ? TROOPS[type].strongVs : [];
}
function rectangleFree(units,x,y,size){
  for(let yy=0; yy<size; yy++){
    for(let xx=0; xx<size; xx++){
      const nx=x+xx, ny=y+yy;
      if(!inside(nx,ny)) return false;
      if (units.some(o=>{
        const os=unitSize(o);
        return nx>=o.x && nx<o.x+os && ny>=o.y && ny<o.y+os;
      })) return false;
    }
  }
  return true;
}
function canMoveTo(u, units, nx, ny){
  const s = unitSize(u);
  return rectangleFree(units.filter(o=>o.id!==u.id), nx, ny, s);
}

/* spawn bands */
function bandRows(p, role){
  if (p===0){
    return role==="back" ? [H-1,H-2,H-3] : [H-6,H-5,H-4];
  }else{
    return role==="back" ? [0,1,2] : [3,4,5];
  }
}
function spawnSlot(state,p,typeKey){
  const t = TROOPS[typeKey];
  const role = t ? t.role : "front";
  const sz = t && t.size===2 ? 2 : 1;
  const rows = bandRows(p, role);
  for(const r of rows){
    const cx=Math.floor(W/2), order=[0,-1,1,-2,2,-3,3,-4,4];
    for(const dx of order){
      const x=Math.max(0,Math.min(W-sz,cx+dx));
      const y=r;
      if (rectangleFree(state.field.units, x, y, sz)) return {x:x,y:y};
    }
  }
  if (p===0){
    for(let y=H-1;y>=Math.max(0,H-8);y--){
      for(let x=0;x<=W-sz;x++){
        if (rectangleFree(state.field.units,x,y,sz)) return {x:x,y:y};
      }
    }
  }else{
    for(let y=0; y<Math.min(H,8); y++){
      for(let x=0;x<=W-sz;x++){
        if (rectangleFree(state.field.units,x,y,sz)) return {x:x,y:y};
      }
    }
  }
  return {x:Math.max(0,Math.min(W-sz, Math.floor(W/2))), y:(p===0? H-2 : 1)};
}

function placeUnit(state,p,key,lvl){
  const t=TROOPS[key]; if(!t) return;
  const spawnCount = Math.max(1, t.spawn || 1);
  for(let k=0;k<spawnCount;k++){
    const pos=spawnSlot(state,p,key);
    const b=t.base;
    const size = t.size===2?2:1;
    let maxhp = Math.round(b.hp || 10);
    let dmg   = Math.round(b.dmg || 3);
    const cd  = Math.round((b.cd || 600)*PACE.atkMult);
    const spd = (typeof b.spd === "number" ? b.spd : 1);
    const range = (typeof b.range === "number" ? b.range : 1);

    /* +33% per level */
    const mult = 1 + 0.33 * Math.max(0, (lvl||1)-1);
    maxhp = Math.round(maxhp * mult);
    dmg   = Math.max(1, Math.round(dmg * mult));

    const u={
      id:crypto.randomUUID(), p:p, type:key, x:pos.x, y:pos.y, lvl:lvl,
      maxhp:maxhp, hp:maxhp,
      dmg:dmg, spd:spd, range:range, armor:(b.armor|0),
      armorType:armorTypeFor(key, {size:size, armor:(b.armor|0)}),
      strongVs:unitStrongVs(key),
      cd:cd,
      splash1:!!b.splash1, knock:!!b.knock, strongKnock:!!b.strongKnock, hunterRanged:!!b.hunterRanged,
      blink50:!!b.blink50, blinked:false, chain3:!!b.chain3,
      kamikaze:!!b.kamikaze, paints:!!b.paints, size:size,
      heal:!!b.heal, healAmt:b.healAmt||0, healRange:b.healRange||0, healCd:b.healCd||0,
      ward:!!b.ward, wardCd:b.wardCd||0, wardDur:b.wardDur||0, wardHp:b.wardHp||1,
      acid:!!b.acid, acidDur:b.acidDur||0,
      toxicSplash:!!b.toxicSplash,
      brood:!!t.brood, broodType:t.broodType||null, broodCd:t.broodCd||0,
      viperLeap:!!t.viperLeap, leapDist:t.leapDist||0, trueDamage:!!t.trueDamage,
      suppress:!!t.suppress, suppressDur:t.suppressDur||0, slowFactor:t.slowFactor||2,
      auraReduce:t.auraReduce||0, auraRange:t.auraRange||0,
      wardShooter:!!t.wardShooter, wardDmg:t.wardDmg||0, wardRange:t.wardRange||0, wardCdShoot:t.wardCdShoot||0,
      wardHealAmt:t.wardHealAmt||0, wardHealRange:t.wardHealRange||0, wardHealCd:t.wardHealCd||0,
      antiSupport:!!t.antiSupport, supportBonus:t.supportBonus||0, executePct:t.executePct||0,
      empShock:!!t.empShock, shockDur:t.shockDur||0,
      rangedReduce:t.rangedReduce||0, bind:!!t.bind, bindDur:t.bindDur||0,
      wound:!!t.wound, woundDur:t.woundDur||0,
      burrow:!!t.burrow, burrowDist:t.burrowDist||0, burrowCd:t.burrowCd||0, nextBurrow:0,
      nextAtk:0, nextHeal:0, nextWard:0, slowUntil:0,
      nextStep:0
    };

    // Level 3+ special hooks
    if (key === "rifleman" && (lvl||1) >= 3){
      u.cd = Math.round(u.cd * 0.7);
    }
    if (key === "matron" && (lvl||1) >= 3){
      u.broodCd = Math.round((t.broodCd || 3500) * 0.7);
    }

    state.field.units.push(u);
  }
}

function rebuildFieldFromRoster(state){
  if (!state.field) state.field = fieldEmpty();
  state.field.units = [];
  if (!state.field.poison) state.field.poison = [];
  if (!state.field.toxic)  state.field.toxic  = [];
  if (!state.field.acid)   state.field.acid   = [];
  if (!state.field.wards)  state.field.wards  = [];

  for(let p=0;p<2;p++){
    const rk = pKey(p);
    const roster = (state.roster && state.roster[rk]) ? state.roster[rk] : [];
    const fronts = roster.filter(r=>TROOPS[r.type] && TROOPS[r.type].role==="front");
    const backs  = roster.filter(r=>!TROOPS[r.type] || TROOPS[r.type].role!=="front");
    for(const r of fronts){ for(let c=0;c<r.count;c++) placeUnit(state,p,r.type,r.lvl); }
    for(const r of backs ){ for(let c=0;c<r.count;c++) placeUnit(state,p,r.type,r.lvl); }
  }
}

/* Draft packs */
function ownedTypes(roster){ return (roster||[]).filter(r=>r.count>0).map(r=>r.type); }
function weightedPick(pool, n){
  const out=[]; const copy=pool.slice();
  for(let k=0;k<n && copy.length;k++){
    const sum = copy.reduce((a,b)=>a+b.w,0);
    let r = Math.random()*sum, i=0;
    for(; i<copy.length; i++){
      r-=copy[i].w;
      if(r<=0) break;
    }
    out.push(copy[i].item);
    copy.splice(i,1);
  }
  return out;
}
function unitEmoji(type){ return TROOPS[type]?.emoji || "‚ùì"; }
function troopBodyClass(type){
  if (["storm","wardmaker","architect","runebinder","medic","carrion"].includes(type)) return "caster";
  return "fighter";
}
function troopArt(type, u){
  const hpPct = Math.max(0, Math.min(1, (u.hp||1)/Math.max(1,u.maxhp||1)));
  const hpGlow = hpPct < 0.35 ? "drop-shadow(0 0 6px rgba(248,113,113,.85))" : "none";
  const teamFill = u.p===0 ? "#f87171" : "#60a5fa";
  const lvlGem = (u.lvl||1) >= 3 ? '<circle cx="39" cy="10" r="4" fill="#fde047" class="stroke" />' : '';
  const ART = {
    rifleman:'<rect x="7" y="10" width="20" height="28" rx="7" fill="#9ca3af" class="stroke"/><rect x="25" y="13" width="16" height="7" rx="3" fill="#1f2937" class="stroke"/><rect x="29" y="21" width="14" height="4" rx="2" fill="#374151"/><rect x="12" y="16" width="10" height="4" fill="'+teamFill+'" opacity=".9"/><circle cx="13" cy="28" r="3" fill="#d1d5db"/><circle cx="21" cy="28" r="3" fill="#d1d5db"/>',
    vrocket:'<path d="M10 36 L24 7 L38 36 Z" fill="#64748b" class="stroke"/><path d="M24 10 L31 24 L24 27 L17 24 Z" fill="#e2e8f0"/><rect x="20" y="24" width="8" height="12" fill="#ef4444"/><path d="M14 33 L18 38 L10 38 Z" fill="#fb7185"/><path d="M34 33 L38 38 L30 38 Z" fill="#fb7185"/>',
    vguard:'<path d="M24 6 L39 12 V24 C39 33 31 39 24 42 C17 39 9 33 9 24 V12 Z" fill="#334155" class="stroke"/><path d="M24 11 L34 15 V24 C34 30 29 34 24 36 C19 34 14 30 14 24 V15 Z" fill="#cbd5e1" class="stroke"/><rect x="21" y="17" width="6" height="16" fill="'+teamFill+'"/><rect x="16" y="21" width="16" height="5" fill="'+teamFill+'"/>',
    miner:'<rect x="8" y="13" width="23" height="26" rx="8" fill="#52525b" class="stroke"/><path d="M24 10 L40 24 L34 30 L18 16 Z" fill="#a1a1aa" class="stroke"/><rect x="10" y="20" width="12" height="3" fill="#facc15"/><circle cx="16" cy="30" r="3" fill="#d4d4d8"/><rect x="32" y="21" width="5" height="10" rx="2" fill="#78716c"/>',
    medic:'<rect x="8" y="10" width="31" height="30" rx="8" fill="#0f766e" class="stroke"/><rect x="13" y="16" width="21" height="18" rx="4" fill="#115e59"/><rect x="20" y="14" width="7" height="22" fill="#ecfeff"/><rect x="13" y="21" width="21" height="7" fill="#ecfeff"/><circle cx="34" cy="14" r="4" fill="#99f6e4"/>',
    suppressor:'<rect x="8" y="12" width="30" height="28" rx="8" fill="#3f3f46" class="stroke"/><path d="M29 10 L41 14 L36 34 L25 30 Z" fill="#ef4444" class="stroke"/><rect x="12" y="18" width="12" height="5" fill="#a1a1aa"/><rect x="12" y="26" width="14" height="3" fill="#f97316"/><circle cx="33" cy="22" r="3" fill="#fecaca"/>',
    shieldcap:'<path d="M24 5 L40 11 V23 C40 33 32 40 24 43 C16 40 8 33 8 23 V11 Z" fill="#1e293b" class="stroke"/><path d="M24 10 L34 14 V23 C34 29 29 34 24 37 C19 34 14 29 14 23 V14 Z" fill="#475569" class="stroke"/><circle cx="24" cy="24" r="6" fill="#fde68a" class="stroke"/><circle cx="24" cy="24" r="2" fill="#f59e0b"/>',
    marksman:'<rect x="8" y="12" width="23" height="27" rx="8" fill="#94a3b8" class="stroke"/><circle cx="34" cy="15" r="8" fill="none" stroke="#ef4444" stroke-width="3"/><line x1="34" y1="8" x2="34" y2="22" stroke="#ef4444"/><line x1="27" y1="15" x2="41" y2="15" stroke="#ef4444"/><rect x="12" y="19" width="12" height="4" fill="#1f2937"/>',
    emp:'<rect x="9" y="12" width="24" height="27" rx="9" fill="#334155" class="stroke"/><circle cx="34" cy="18" r="8" fill="#0ea5e9" class="stroke"/><path d="M34 11 L30 18 H35 L31 26" stroke="#dbeafe" fill="none" stroke-width="2.5"/><rect x="13" y="28" width="15" height="5" fill="#64748b"/>',
    phaser:'<ellipse cx="24" cy="24" rx="13" ry="17" fill="#e2e8f0" class="stroke"/><path d="M14 18 Q24 6 34 18" fill="#93c5fd" class="stroke"/><circle cx="24" cy="24" r="4" fill="#60a5fa"/><path d="M10 24 H38" stroke="#bfdbfe" stroke-width="2" opacity=".8"/>',
    blade:'<rect x="10" y="12" width="20" height="28" rx="8" fill="#f8fafc" class="stroke"/><path d="M30 8 L40 18 L28 31 L22 25 Z" fill="#cbd5e1" class="stroke"/><path d="M19 18 L23 10 L27 18" fill="#93c5fd"/><rect x="13" y="28" width="12" height="4" fill="#94a3b8"/>',
    storm:'<rect x="9" y="11" width="30" height="29" rx="12" fill="#fde68a" class="stroke"/><path d="M25 9 L19 23 H26 L21 39 L34 21 H27 Z" fill="#3b82f6" class="stroke"/><circle cx="15" cy="16" r="3" fill="#fef3c7"/><circle cx="33" cy="31" r="2" fill="#fef3c7"/>',
    guardian:'<circle cx="24" cy="24" r="17" fill="#d4af37" class="stroke"/><circle cx="24" cy="24" r="11" fill="#1d4ed8" class="stroke"/><circle cx="24" cy="24" r="5" fill="#93c5fd"/><path d="M24 7 L24 41 M7 24 L41 24" stroke="#fef08a" stroke-width="1.5"/>',
    wardmaker:'<rect x="9" y="11" width="18" height="29" rx="8" fill="#fef3c7" class="stroke"/><circle cx="33" cy="18" r="8" fill="#38bdf8" class="stroke"/><circle cx="33" cy="18" r="3" fill="#e0f2fe"/><path d="M14 21 L22 21 M14 27 L22 27" stroke="#ca8a04" stroke-width="2"/>',
    architect:'<rect x="7" y="12" width="32" height="27" rx="5" fill="#d4af37" class="stroke"/><rect x="12" y="18" width="22" height="15" fill="#93c5fd" class="stroke"/><path d="M10 17 L24 8 L38 17" fill="#fef3c7" class="stroke"/><rect x="17" y="22" width="6" height="9" fill="#1e3a8a"/>',
    golem:'<rect x="6" y="7" width="36" height="33" rx="8" fill="#6b7280" class="stroke"/><rect x="12" y="12" width="24" height="8" fill="#9ca3af"/><circle cx="18" cy="24" r="3" fill="#0ea5e9"/><circle cx="30" cy="24" r="3" fill="#0ea5e9"/><rect x="15" y="29" width="18" height="4" fill="#4b5563"/>',
    runebinder:'<circle cx="18" cy="26" r="11" fill="#e2e8f0" class="stroke"/><path d="M29 14 L39 24 L30 34" stroke="#a78bfa" stroke-width="4" fill="none"/><path d="M14 21 L21 21 L18 27 Z" fill="#7c3aed"/><circle cx="34" cy="24" r="2" fill="#ddd6fe"/>',
    hellspawn:'<ellipse cx="22" cy="25" rx="13" ry="10" fill="#7f1d1d" class="stroke"/><path d="M10 24 L4 20 M34 24 L40 20" stroke="#b91c1c" stroke-width="3"/><path d="M10 28 L4 32 M34 28 L40 32" stroke="#b91c1c" stroke-width="2"/><circle cx="17" cy="23" r="2" fill="#fee2e2"/><circle cx="27" cy="23" r="2" fill="#fee2e2"/>',
    roach:'<ellipse cx="23" cy="24" rx="14" ry="10" fill="#581c87" class="stroke"/><path d="M12 30 L6 36 M34 30 L40 36" stroke="#9333ea" stroke-width="3"/><path d="M13 19 L8 14 M33 19 L38 14" stroke="#a855f7" stroke-width="2"/><rect x="18" y="19" width="10" height="9" fill="#7e22ce"/>',
    defiler:'<ellipse cx="20" cy="25" rx="14" ry="12" fill="#27272a" class="stroke"/><path d="M30 25 Q41 18 37 10" stroke="#22c55e" stroke-width="4" fill="none"/><circle cx="37" cy="9" r="3" fill="#86efac"/><path d="M8 26 L3 30 M12 33 L6 38 M28 34 L34 39" stroke="#4ade80" stroke-width="2"/>',
    blood:'<circle cx="22" cy="24" r="12" fill="#b91c1c" class="stroke"/><circle cx="30" cy="16" r="5" fill="#ef4444" class="stroke"/><circle cx="17" cy="20" r="3" fill="#fecaca"/><path d="M15 33 L19 38 L23 33" fill="#f87171"/>',
    matron:'<ellipse cx="23" cy="24" rx="14" ry="12" fill="#4c1d95" class="stroke"/><path d="M11 30 L5 36 M17 33 L12 39 M29 33 L34 39 M35 30 L41 36" stroke="#7c3aed" stroke-width="2"/><circle cx="18" cy="22" r="2" fill="#ddd6fe"/><circle cx="28" cy="22" r="2" fill="#ddd6fe"/>',
    viper:'<path d="M7 30 Q16 10 34 20 Q42 25 35 33 Q25 38 16 34 Q11 32 7 30 Z" fill="#14532d" class="stroke"/><path d="M16 30 Q23 23 31 27" stroke="#86efac" stroke-width="2" fill="none"/><circle cx="34" cy="23" r="2" fill="#dcfce7"/><path d="M36 24 L40 23 L37 26" fill="#f87171"/>',
    spitter:'<ellipse cx="22" cy="24" rx="14" ry="10" fill="#6d28d9" class="stroke"/><circle cx="34" cy="24" r="5" fill="#c4b5fd" class="stroke"/><circle cx="33" cy="24" r="2" fill="#ede9fe"/><path d="M10 25 L5 28 M13 30 L8 35" stroke="#8b5cf6" stroke-width="2"/>',
    carrion:'<rect x="10" y="11" width="24" height="29" rx="8" fill="#7f1d1d" class="stroke"/><path d="M24 11 L30 4 L34 11" fill="#b91c1c" class="stroke"/><path d="M14 20 L30 20 M14 27 L30 27" stroke="#fca5a5" stroke-width="2" opacity=".8"/><circle cx="22" cy="33" r="3" fill="#ef4444"/>',
    burrower:'<path d="M7 31 Q22 8 39 31 Q22 41 7 31 Z" fill="#78350f" class="stroke"/><path d="M20 22 L24 17 L28 22" stroke="#fbbf24" stroke-width="2" fill="none"/><path d="M12 32 Q22 35 34 32" stroke="#a16207" stroke-width="2" fill="none"/><circle cx="22" cy="27" r="2" fill="#fde68a"/>'
  };
  const body = ART[type] || ('<text x="24" y="30" text-anchor="middle" font-size="20">'+unitEmoji(type)+'</text>');
  return '<div class="troop-art" style="filter:'+hpGlow+'">\n    <svg viewBox="0 0 48 48" aria-label="'+(TROOPS[type]?.name||type)+'">'+body+lvlGem+'</svg>\n  </div>';
}
function unitActionClass(u, now){
  if ((u.animUntil||0) <= now) return "";
  return u.animType === "cast" ? "casting" : "attacking";
}
function packFor(roster, faction){
  const poolTypes = FACTIONS[faction] || [];

  const troopCards = poolTypes.map(k=>({
    type:"troop",
    key:k,
    name:TROOPS[k].name,
    emoji: unitEmoji(k),
    role:TROOPS[k].role
  }));

  const owned = Array.isArray(roster) ? roster : [];
  const ownedTypesList      = owned.filter(r=>r.count>0).map(r=>r.type);
  const ownedUpgradeable    = owned.filter(r=>r.count>0 && (r.lvl||1) < 3).map(r=>r.type);

  const specials = [];
  if (ownedTypesList.length){
    if (ownedUpgradeable.length){
      const up = ownedUpgradeable[Math.floor(Math.random()*ownedUpgradeable.length)];
      specials.push({
        type:"special", special:"upgrade", for:up,
        name:"Upgrade "+TROOPS[up].name, emoji:"‚¨ÜÔ∏è"
      });
    }
    const db = ownedTypesList[Math.floor(Math.random()*ownedTypesList.length)];
    specials.push({
      type:"special", special:"double", for:db,
      name:"Double "+TROOPS[db].name, emoji:"üÉè"
    });
  }

  const pool = [
    ...troopCards.map(item=>({ item:item, w:3 })),
    ...specials   .map(item=>({ item:item, w:1 }))
  ];

  return weightedPick(pool, 3);
}

/* Roster ops */
function rosterAdd(roster, type, inc){
  const incVal = (typeof inc === "number" ? inc : 1);
  const f=roster.find(r=>r.type===type);
  if (f) f.count+=incVal;
  else roster.push({type:type, lvl:1, count:incVal});
}
function rosterDoubleOneSpecific(roster, type){
  const f=roster.find(r=>r.type===type);
  if(!f) return;
  const add = Math.max(1,f.count);
  f.count += add;
}
function rosterUpgradeOneSpecific(roster, type){
  const f=roster.find(r=>r.type===type && (r.lvl||1)<3);
  if(!f) return;
  f.lvl = (f.lvl||1)+1;
}

/* VFX helpers */
function fxBeam(x1,y1,x2,y2){ return { id:crypto.randomUUID(), type:"beam", x1:x1,y1:y1,x2:x2,y2:y2, at:Date.now(), ttl:350 }; }
function fxHeal(x1,y1,x2,y2){ return { id:crypto.randomUUID(), type:"hbeam", x1:x1,y1:y1,x2:x2,y2:y2, at:Date.now(), ttl:350 }; }
function fxBurst(cx,cy){     return { id:crypto.randomUUID(), type:"burst", cx:cx,cy:cy, at:Date.now(), ttl:700 }; }
function fxTransport(x1,y1,x2,y2){ return { id:crypto.randomUUID(), type:"transport", x1:x1,y1:y1,x2:x2,y2:y2, at:Date.now(), ttl:450 }; }
function fxImpact(x,y){ return { id:crypto.randomUUID(), type:"impact", x:x, y:y, at:Date.now(), ttl:320 }; }
function fxStorm(cx,cy){ return { id:crypto.randomUUID(), type:"storm", cx:cx, cy:cy, at:Date.now(), ttl:620 }; }
function fxStatus(x,y,emoji){ return { id:crypto.randomUUID(), type:"status", x:x, y:y, emoji:emoji, at:Date.now(), ttl:620 }; }

function centerPx(x,y){
  const left = x*(CELL+GAP) + CELL/2;
  const top  = y*(CELL+GAP) + CELL/2;
  return {left:left, top:top};
}
function renderBeam(ev, heal){
  const a = centerPx(ev.x1,ev.y1), b=centerPx(ev.x2,ev.y2);
  const dx=b.left-a.left, dy=b.top-a.top, len=Math.hypot(dx,dy), ang=Math.atan2(dy,dx);
  const el=document.createElement("div"); el.className= heal? "hbeam" : "beam";
  el.style.left = a.left + "px";
  el.style.top  = a.top  + "px";
  el.style.width = Math.max(1,len) + "px";
  el.style.transform = "rotate("+ang+"rad)";
  beamsEl.appendChild(el);
  setTimeout(()=>el.remove(), ev.ttl);
}
function renderTransport(ev){
  const a = centerPx(ev.x1,ev.y1), b=centerPx(ev.x2,ev.y2);
  const dx=b.left-a.left, dy=b.top-a.top, len=Math.hypot(dx,dy), ang=Math.atan2(dy,dx);
  const el=document.createElement("div");
  el.className = "tline";
  el.style.left = a.left + "px";
  el.style.top  = a.top  + "px";
  el.style.width = Math.max(1, len) + "px";
  el.style.transform = "rotate("+ang+"rad)";
  beamsEl.appendChild(el);
  setTimeout(()=>el.remove(), ev.ttl);
}
function renderBurst(ev){
  for(let i=0;i<10;i++){
    const dot=document.createElement("div"); dot.className="p";
    const offx = (Math.random()*14-7), offy=(Math.random()*14-7);
    const a=centerPx(ev.cx,ev.cy);
    dot.style.left = (a.left + offx) + "px";
    dot.style.top  = (a.top + offy) + "px";
    partsEl.appendChild(dot);
    setTimeout(()=>dot.remove(), ev.ttl);
  }
}

function renderImpact(ev){
  const a=centerPx(ev.x, ev.y);
  const el=document.createElement("div");
  el.className="impact";
  el.style.left = a.left + "px";
  el.style.top = a.top + "px";
  partsEl.appendChild(el);
  setTimeout(()=>el.remove(), ev.ttl||320);
}
function renderStorm(ev){
  const a=centerPx(ev.cx, ev.cy);
  const el=document.createElement("div");
  el.className="storm";
  el.style.left = a.left + "px";
  el.style.top = a.top + "px";
  el.style.transform = "translate(-50%,-50%)";
  partsEl.appendChild(el);
  setTimeout(()=>el.remove(), ev.ttl||620);
}
function renderStatusPop(ev){
  const a=centerPx(ev.x, ev.y);
  const el=document.createElement("div");
  el.className="statusPop";
  el.textContent = ev.emoji || "‚ö°";
  el.style.left = a.left + "px";
  el.style.top = a.top + "px";
  partsEl.appendChild(el);
  setTimeout(()=>el.remove(), ev.ttl||620);
}

function groundTickParticles(x,y, purple){
  const a=centerPx(x,y);
  for(let i=0;i<4;i++){
    const dot=document.createElement("div"); dot.className="p";
    if (purple) dot.classList.add("purple");
    const offx = (Math.random()*10-5), offy=(Math.random()*6-3);
    dot.style.left = (a.left + offx) + "px";
    dot.style.top  = (a.top + offy) + "px";
    partsEl.appendChild(dot);
    setTimeout(()=>dot.remove(), 550);
  }
}
function flashAt(x,y, dmgNum){
  const i=idx(x,y); const cell=cellsEl.children[i]; if (!cell) return;
  const f=document.createElement("div"); f.className="hitflash"; cell.appendChild(f);
  setTimeout(()=>f.remove(), 140);
  if (dmgNum>0){
    const t=document.createElement("div"); t.className="dmg"; t.textContent="-"+dmgNum;
    cell.appendChild(t); setTimeout(()=>t.remove(), 650);
  }
}

/* ward helpers / aura */
function auraDamageReduceFor(target, field){
  let reduce = 0;
  const units = field.units || [];
  for (const a of units) {
    if (a.p !== target.p) continue;
    if (!a.auraReduce || a.hp <= 0) continue;
    const rng = a.auraRange || 0;
    if (rng > 0 && manhattan(a, target) <= rng) {
      if (a.auraReduce > reduce) reduce = a.auraReduce|0;
    }
  }
  return reduce;
}

function spawnAdjacentUnit(st, parent, typeKey){
  const t = TROOPS[typeKey]; if (!t) return false;
  const size = (t.size===2?2:1);
  const dir = parent.p===0 ? -1 : +1;
  const candidates = [
    [parent.x, parent.y+dir],
    [parent.x-1, parent.y+dir],[parent.x+1, parent.y+dir],
    [parent.x-1,parent.y],[parent.x+1,parent.y],
    [parent.x, parent.y-dir],
    [parent.x-1,parent.y-dir],[parent.x+1,parent.y-dir]
  ];
  for (let k=0;k<candidates.length;k++){
    const x=candidates[k][0], y=candidates[k][1];
    if (!inside(x,y)) continue;
    if (rectangleFree(st.field.units, x, y, size)){
      const b=t.base;
      const u={
        id:crypto.randomUUID(), p:parent.p, type:typeKey, x:x, y:y, lvl:1,
        maxhp:Math.round(b.hp||8), hp:Math.round(b.hp||8),
        dmg:Math.round(b.dmg||2), spd: b.spd || 1, range:b.range || 1, armor:(b.armor|0),
        armorType:armorTypeFor(typeKey, {size:size, armor:(b.armor|0)}),
        strongVs:unitStrongVs(typeKey),
        cd: Math.round((b.cd || 700)*PACE.atkMult),
        splash1:!!b.splash1, knock:!!b.knock, strongKnock:!!b.strongKnock, hunterRanged:!!b.hunterRanged,
        blink50:!!b.blink50, blinked:false, chain3:!!b.chain3,
        kamikaze:!!b.kamikaze, paints:!!b.paints, size:size,
        heal:!!b.heal, healAmt:b.healAmt||0, healRange:b.healRange||0, healCd:b.healCd||0,
        ward:false, acid:!!b.acid, acidDur:b.acidDur||0, toxicSplash:!!b.toxicSplash,
        brood:!!t.brood, broodType:t.broodType||null, broodCd:t.broodCd||0,
        viperLeap:!!t.viperLeap, leapDist:t.leapDist||0, trueDamage:!!t.trueDamage,
        suppress:!!t.suppress, suppressDur:t.suppressDur||0, slowFactor:t.slowFactor||2,
        auraReduce:t.auraReduce||0, auraRange:t.auraRange||0,
        wardShooter:!!t.wardShooter, wardDmg:t.wardDmg||0, wardRange:t.wardRange||0, wardCdShoot:t.wardCdShoot||0,
        wardHealAmt:t.wardHealAmt||0, wardHealRange:t.wardHealRange||0, wardHealCd:t.wardHealCd||0,
        antiSupport:!!t.antiSupport, supportBonus:t.supportBonus||0, executePct:t.executePct||0,
        empShock:!!t.empShock, shockDur:t.shockDur||0,
        rangedReduce:t.rangedReduce||0, bind:!!t.bind, bindDur:t.bindDur||0,
        wound:!!t.wound, woundDur:t.woundDur||0,
        burrow:!!t.burrow, burrowDist:t.burrowDist||0, burrowCd:t.burrowCd||0, nextBurrow:0,
        nextAtk:0, nextHeal:0, nextWard:0, slowUntil:0, nextStep:0
      };
      st.field.units.push(u);
      st.field.fx.push(fxBurst(x,y));
      return true;
    }
  }
  return false;
}
function isBacklineUnit(v){
  return (TROOPS[v.type] && TROOPS[v.type].role === "back");
}

function frontBlocked(u, units){
  const dir = (u.p===0? -1 : +1);
  const nx = u.x, ny = u.y + dir;
  for (let k=0;k<units.length;k++){
    const o=units[k];
    if (o.p === u.p) continue;
    const os = unitSize(o);
    const blocks = nx>=o.x && nx<o.x+os && ny>=o.y && ny<o.y+os;
    if (blocks && TROOPS[o.type] && TROOPS[o.type].role === "front") return true;
  }
  return false;
}

function attemptViperLeap(u, units, st){
  if (!u.viperLeap) return false;
  const dir = (u.p===0? -1 : +1);
  const dist = Math.max(1, u.leapDist || 2);

  const fromX = u.x, fromY = u.y;

  for (let d=dist; d>=1; d--){
    const nx = u.x, ny = u.y + dir*d;
    if (!inside(nx,ny)) continue;
    if (canMoveTo(u, units, nx, ny)){
      u.x = nx; u.y = ny;
      if ((u.lvl||1) >= 3 && st && st.field && st.field.fx){
        st.field.fx.push(fxTransport(fromX, fromY, nx, ny));
      }
      return true;
    }
  }
  return false;
}

function attemptBurrow(u, units, st, now){
  if (!u.burrow || u.hp<=0) return false;
  if (!u.nextBurrow) u.nextBurrow = 0;
  if (now < u.nextBurrow) return false;
  const dir = (u.p===0? -1 : +1);
  const dist = Math.max(1, u.burrowDist || 2);
  const fromX=u.x, fromY=u.y;
  for (let d=dist; d>=1; d--){
    const nx=u.x, ny=u.y + dir*d;
    if (!inside(nx,ny)) continue;
    if (canMoveTo(u, units, nx, ny)){
      u.x=nx; u.y=ny;
      u.nextBurrow = now + (u.burrowCd || 2200);
      if (st && st.field && st.field.fx) st.field.fx.push(fxTransport(fromX, fromY, nx, ny));
      return true;
    }
  }
  u.nextBurrow = now + 500;
  return false;
}

function broodTick(st, now){
  const units = st.field.units || [];
  for (let i=0;i<units.length;i++){
    const u = units[i];
    if (!u.brood || u.hp<=0) continue;
    if (!u.nextBrood) u.nextBrood = 0;
    if (now >= u.nextBrood){
      if (spawnAdjacentUnit(st, u, u.broodType || "hellspawn")){
        u.nextBrood = now + (u.broodCd || TROOPS[u.type]?.broodCd || 3500);
      } else {
        u.nextBrood = now + 800;
      }
    }
  }
}

function reduceDamageForTarget(baseDmg, target, field, opts){
  let dmg = baseDmg|0;
  const ignoreArmor = !!(opts && opts.ignoreArmor);
  if (ignoreArmor) return Math.max(1, dmg);

  const auraReduce = auraDamageReduceFor(target, field);
  const armor = target && target.armor ? (target.armor|0) : 0;
  const totalReduce = Math.max(0, auraReduce + armor);
  if (totalReduce > 0) dmg = Math.max(1, dmg - totalReduce);
  return dmg;
}
function healScale(v, now){
  return (v.woundUntil && v.woundUntil > now) ? 0.5 : 1;
}
function isSupportUnit(v){
  return !!(v.heal || v.ward || v.wardShooter);
}
function applyShockDebuff(st, target, now, dur){
  const d = dur || 1500;
  target.statusShockUntil = Math.max(target.statusShockUntil||0, now + d);
  target.slowUntil = Math.max(target.slowUntil||0, now + d);
  if (st && st.field && st.field.fx) st.field.fx.push(fxStatus(target.x, target.y, "‚ö°"));
  const wards = (st && st.field && st.field.wards) ? st.field.wards : [];
  for (let i=0;i<wards.length;i++){
    const w=wards[i];
    if (w.p===target.p && (w.shoot || w.heal)){
      w.disabledUntil = Math.max(w.disabledUntil||0, now + d);
    }
  }
}

/* ward shields vs ranged */
function tilesOnLine(x1,y1,x2,y2){
  const tiles=[];
  const dx=x2-x1, dy=y2-y1;
  const steps = Math.max(Math.abs(dx), Math.abs(dy));
  if (steps===0){
    tiles.push({x:Math.round(x1),y:Math.round(y1)});
    return tiles;
  }
  const sx=dx/steps, sy=dy/steps;
  let x=x1, y=y1;
  for(let i=0;i<=steps;i++){
    tiles.push({x:Math.round(x), y:Math.round(y)});
    x+=sx; y+=sy;
  }
  return tiles;
}
function unitCenter(u){
  return { x: u.x + (unitSize(u)-1)/2, y: u.y + (unitSize(u)-1)/2 };
}
function applyWardShields(attacker, target, rawDmg, field){
  const wards = field.wards || [];
  if (!wards.length || rawDmg <= 0) return rawDmg;

  const a = unitCenter(attacker), b = unitCenter(target);
  const path = tilesOnLine(a.x, a.y, b.x, b.y);
  const now = Date.now();
  let dmg = rawDmg;

  for (let i=0;i<wards.length;i++){
    const w=wards[i];
    if (w.hp <= 0 || w.until <= now) continue;
    if (w.p != null && w.p !== target.p) continue;

    const onPath = path.some(pt => pt.x === w.x && pt.y === w.y);
    if (!onPath) continue;

    const reduce = (w.shieldReduce != null ? w.shieldReduce : 2);
    dmg = Math.max(0, dmg - reduce);
    w.hp -= 1;
  }
  return dmg;
}

/* Painting board ‚Äî BY RANK color */
function paint(units, field){
  const total = W * H;
  const now = Date.now();
  for (let i = 0; i < total; i++){
    const d = cellsEl.children[i];
    if (!d) continue;

    const under = d.querySelector(".under"); if (under) under.style.background = "transparent";
    const uni = d.querySelector(".unit");
    if (uni){
      uni.textContent = "";
      uni.classList.remove("team0","team1","attacking","casting","big");
    }
    const statusEl = d.querySelector(".status"); if (statusEl) statusEl.textContent = "";
    d.classList.remove("multi-origin");
    const hpWrap = d.querySelector(".hp"); if (hpWrap) hpWrap.classList.remove("big");

    const hpFill = d.querySelector(".hp>i");
    if (hpFill){
      hpFill.style.width = "0%";
      hpFill.classList.remove("team0","team1");
    }

    d.querySelector(".poison")?.remove();
    d.querySelector(".toxic")?.remove();
    d.querySelector(".acid")?.remove();
    d.querySelector(".ward")?.remove();
  }

  (field.poison||[]).forEach(p=>{
    if (p.until <= now) return;
    const d = cellsEl.children[idx(p.x,p.y)]; if (!d) return;
    const el = document.createElement("div");
    el.className="poison";
    d.appendChild(el);
  });
  (field.toxic||[]).forEach(t=>{
    if (t.until <= now) return;
    const d = cellsEl.children[idx(t.x,t.y)]; if (!d) return;
    const el = document.createElement("div");
    el.className="toxic";
    d.appendChild(el);
  });
  (field.acid||[]).forEach(a=>{
    if (a.until <= now) return;
    const d = cellsEl.children[idx(a.x,a.y)]; if (!d) return;
    const el = document.createElement("div");
    el.className="acid";
    d.appendChild(el);
  });
  (field.wards||[]).forEach(w=>{
    if (w.until <= now || w.hp <= 0) return;
    const d = cellsEl.children[idx(w.x,w.y)]; if (!d) return;
    const el = document.createElement("div");
    el.className="ward";
    d.appendChild(el);
  });

  for (let i=0;i<units.length;i++){
    const u = units[i];
    const s = unitSize(u);
    const color = (rankColor(u.lvl||1).trim() || "#22c55e");

    for (let yy=0; yy<s; yy++){
      for (let xx=0; xx<s; xx++){
        const d = cellsEl.children[idx(u.x+xx, u.y+yy)]; if (!d) continue;
        const under = d.querySelector(".under"); if (!under) continue;
        under.style.background = "radial-gradient(circle at top,"+color+","+color+")";
      }
    }

    const d0 = cellsEl.children[idx(u.x, u.y)]; if (!d0) continue;
    d0.classList.toggle("multi-origin", s===2);

    const uni = d0.querySelector(".unit");
    if (uni){
      uni.style.zIndex = "3";
      uni.style.fontSize = s===2 ? "32px" : "26px";
      uni.classList.remove("team0","team1","attacking","casting","big");
      uni.classList.toggle("team0", u.p === 0);
      uni.classList.toggle("team1", u.p === 1);
      uni.classList.toggle("big", s===2);
      const actClass = unitActionClass(u, now);
      if (actClass) uni.classList.add(actClass);
      uni.innerHTML = troopArt(u.type, u);
    }

    const hpFill = d0.querySelector(".hp>i");
    const hpWrap = d0.querySelector(".hp");
    if (hpWrap) hpWrap.classList.toggle("big", s===2);
    if (hpFill){
      hpFill.classList.toggle("team0", u.p === 0);
      hpFill.classList.toggle("team1", u.p === 1);
      const pct = Math.max(0, Math.round(100 * u.hp / u.maxhp));
      hpFill.style.width = pct + "%";
    }

    const statusEl = d0.querySelector(".status");
    if (statusEl){
      const icons = [];
      if (u.slowUntil && u.slowUntil > now) icons.push("üê¢");
      if (u.statusPoisonUntil && u.statusPoisonUntil > now) icons.push("‚ò†");
      if (u.statusAcidUntil && u.statusAcidUntil > now) icons.push("üß™");
      if (u.statusShockUntil && u.statusShockUntil > now) icons.push("‚ö°");
      if (u.woundUntil && u.woundUntil > now) icons.push("ü©∏");
      if (u.bindUntil && u.bindUntil > now) icons.push("‚ö°");
      if (auraDamageReduceFor(u, field) > 0) icons.push("üõ°Ô∏è");
      statusEl.innerHTML = icons.map(i=>"<span>"+i+"</span>").join("");
    }
  }
}

/* Ranged helpers & AI */
function nearestEnemy(u,units,field){
  const wards = field.wards || [];
  let best=null, bd=1e9;
  const c=unitCenter(u);

  function consider(obj,isWard){
    if (obj.p === u.p) return;
    if (obj.hp <= 0) return;
    const sz = isWard ? 1 : unitSize(obj);
    const center = isWard ? { x: obj.x + (sz-1)/2, y: obj.y + (sz-1)/2 } : unitCenter(obj);
    const d = Math.abs(center.x - c.x) + Math.abs(center.y - c.y);
    if (d < bd){ bd=d; best=obj; }
  }

  for(let i=0;i<units.length;i++) consider(units[i],false);
  for(let i=0;i<wards.length;i++){
    const w=wards[i];
    if (!w.shoot) continue;
    consider(w,true);
  }
  return best;
}
function strongestArmorTargetInRange(u, units){
  const strongVs = (u.strongVs || []).length ? u.strongVs : unitStrongVs(u.type);
  if (!strongVs.length) return null;
  const c = unitCenter(u);
  const range = (u.range||1);
  let best=null, bd=1e9;
  for (let i=0;i<units.length;i++){
    const v = units[i];
    if (!v || v.p===u.p || v.hp<=0) continue;
    const d = Math.abs(unitCenter(v).x-c.x)+Math.abs(unitCenter(v).y-c.y);
    if (d > range) continue;
    const armorType = v.armorType || armorTypeFor(v.type, v);
    if (!strongVs.includes(armorType)) continue;
    if (d < bd){ bd=d; best=v; }
  }
  return best;
}
function pickTarget(u, units, field){
  const priority = strongestArmorTargetInRange(u, units);
  if (priority) return priority;
  return u.hunterRanged ? nearestEnemyRangedPriority(u,units,field)
                        : nearestEnemy(u,units,field);
}
function nearestEnemyRangedPriority(u,units,field){
  const wards = field.wards || [];
  const c = unitCenter(u);
  let best=null, bd=1e9;

  function consider(obj,isWard){
    if (obj.p === u.p) return;
    if (obj.hp <= 0) return;
    const sz = isWard ? 1 : unitSize(obj);
    const center = isWard ? { x: obj.x + (sz-1)/2, y: obj.y + (sz-1)/2 } : unitCenter(obj);
    const d = Math.abs(center.x - c.x) + Math.abs(center.y - c.y);
    if (d < bd){ bd=d; best=obj; }
  }

  const rangedUnits = units.filter(v=> v.p!==u.p && TROOPS[v.type] && TROOPS[v.type].role==="back" && v.hp>0);
  if (rangedUnits.length){
    for(let i=0;i<rangedUnits.length;i++) consider(rangedUnits[i],false);
    if (best) return best;
  }
  return nearestEnemy(u,units,field);
}
function manhattanUnits(u,t){
  const a=unitCenter(u), b=unitCenter(t);
  return Math.abs(a.x-b.x)+Math.abs(a.y-b.y);
}
function stepToward(u,t,units){
  const a=unitCenter(u), b=unitCenter(t);
  const dx=b.x-a.x, dy=b.y-a.y;
  const sx=Math.sign(dx), sy=Math.sign(dy);
  const absx=Math.abs(dx), absy=Math.abs(dy);
  const opts = (absx>=absy)
    ? [[u.x+sx,u.y],[u.x,u.y+sy],[u.x-sx,u.y],[u.x,u.y-sy]]
    : [[u.x,u.y+sy],[u.x+sx,u.y],[u.x,u.y-sy],[u.x-sx,u.y]];
  for(let i=0;i<opts.length;i++){
    const p=opts[i];
    if (canMoveTo(u,units,p[0],p[1])){ u.x=p[0]; u.y=p[1]; return; }
  }
}
function canStepNow(u, now){
  if (!u.nextStep || now>=u.nextStep){
    u.nextStep = now + MOVE_MS;
    return true;
  }
  return false;
}
function blinkIfNeeded(u){
  if(!u.blink50 || u.blinked) return;
  if (u.hp <= 0.5*u.maxhp){
    const dir = (u.p===0? +1 : -1);
    for(let i=0;i<3;i++){
      const nx=u.x, ny=u.y+dir;
      if (!inside(nx,ny)) break;
      if (canMoveTo(u, S.field.units, nx, ny)){ u.x=nx; u.y=ny; }
    }
    u.blinked=true;
  }
}

/* Terrain */
function paintPoison(state, cx, cy, durMs, ownerP){
  const until = Date.now()+durMs;
  if (!state.field.poison) state.field.poison = [];
  for (let dy=-1; dy<=1; dy++){
    for (let dx=-1; dx<=1; dx++){
      const x=cx+dx, y=cy+dy; if(!inside(x,y)) continue;
      state.field.poison.push({x:x,y:y,until:until,p:ownerP});
    }
  }
}
function addToxicSplash(state, cx, cy, durMs, ownerP){
  const until = Date.now()+durMs;
  if (!state.field.toxic) state.field.toxic = [];
  for(let dy=-1;dy<=1;dy++){
    for(let dx=-1;dx<=1;dx++){
      const x=cx+dx, y=cy+dy; if(!inside(x,y)) continue;
      state.field.toxic.push({x:x,y:y,until:until,p:ownerP});
    }
  }
}
function addAcid(state, x,y, durMs){
  if(!inside(x,y)) return;
  if (!state.field.acid) state.field.acid = [];
  state.field.acid.push({x:x,y:y,until:Date.now()+durMs});
}
function placeWard(state, x, y, hp, dur, opts){
  if (!inside(x,y)) return false;
  if (state.field.wards && state.field.wards.some(w=>w.x===x && w.y===y)) return false;

  if (!state.field.wards) state.field.wards = [];

  const until = Date.now() + dur;
  const w = {
    x:x, y:y,
    hp: hp|0,
    maxhp: hp|0,
    until:until,
    p: (opts && "p" in opts) ? opts.p : null,
    type: (opts && opts.shoot) ? "wardTurret" : "wardShield",
    shieldReduce: (opts && "shieldReduce" in opts) ? opts.shieldReduce : 2,
    shoot: !!(opts && opts.shoot),
    wDmg:  (opts && "wDmg"  in opts) ? (opts.wDmg|0)  : 1,
    wRange:(opts && "wRange"in opts) ? (opts.wRange|0): 3,
    wCd:   (opts && "wCd"   in opts) ? (opts.wCd|0)   : 1400,
    next:  0,
    multi: !!(opts && opts.multi),
    maxTargets: (opts && "maxTargets" in opts) ? opts.maxTargets : 1,
    heal:    !!(opts && opts.heal),
    hAmt:    (opts && "hAmt"   in opts) ? (opts.hAmt|0)   : 2,
    hRange:  (opts && "hRange" in opts) ? (opts.hRange|0) : 3,
    hCd:     (opts && "hCd"    in opts) ? (opts.hCd|0)    : 1500,
    nextHeal:0
  };
  state.field.wards.push(w);
  return true;
}

function applyTerrain(field, units){
  const now=Date.now();
  (field.poison||[]).forEach(p=>{
    if (p.until<=now) return;
    let ticked=false;

    for (let i=0;i<units.length;i++){
      const u=units[i];
      if (u.x<=p.x && p.x<u.x+unitSize(u) && u.y<=p.y && p.y<u.y+unitSize(u)){
        if (p.p!=null && u.p === p.p) continue;
        u.slowUntil = Math.max(u.slowUntil||0, now+PACE.poisonSlowMs);
        u.statusPoisonUntil = Math.max(u.statusPoisonUntil||0, now + 2*PACE.poisonDotMs);

        if (!u._poisonTick || now - u._poisonTick >= PACE.poisonDotMs){
          u._poisonTick = now; u.hp = u.hp - 1; flashAt(u.x,u.y,1); ticked=true;
        }
      }
    }
    if (ticked) groundTickParticles(p.x,p.y,false);
  });

  (field.toxic||[]).forEach(t=>{
    if (t.until<=now) return;
    let ticked=false;
    for(let i=0;i<units.length;i++){
      const u=units[i];
      if (u.x<=t.x && t.x<u.x+unitSize(u) && u.y<=t.y && t.y<u.y+unitSize(u)){
        if (t.p==null || u.p !== t.p){
          u.statusPoisonUntil = Math.max(u.statusPoisonUntil||0, now + 2*PACE.toxicDotMs);
          if (!u._toxicTick || now - u._toxicTick >= PACE.toxicDotMs){
            u._toxicTick = now; u.hp = u.hp - 1; flashAt(u.x,u.y,1); ticked=true;
          }
        }
      }
    }
    if (ticked) groundTickParticles(t.x,t.y,true);
  });

  (field.acid||[]).forEach(a=>{
    if (a.until<=now) return;
    let ticked=false;
    for(let i=0;i<units.length;i++){
      const u=units[i];
      if (u.x<=a.x && a.x<u.x+unitSize(u) && u.y<=a.y && a.y<u.y+unitSize(u)){
        u.slowUntil = Math.max(u.slowUntil||0, now+800);
        u.statusAcidUntil = Math.max(u.statusAcidUntil||0, now + 2200);
        if (!u._acidTick || now - u._acidTick >= 1100){
          u._acidTick = now; u.hp = u.hp - 1; flashAt(u.x,u.y,1); ticked=true;
        }
      }
    }
    if (ticked) groundTickParticles(a.x,a.y,true);
  });
}

/* wards heal/shoot */
function wardsHeal(st, now){
  const wards = st.field.wards || [];
  for (let i=0;i<wards.length;i++){
    const w = wards[i];
    if (!w.heal || w.hp<=0 || w.until<=now) continue;
    if (w.disabledUntil && w.disabledUntil > now) continue;
    if (now < (w.nextHeal||0)) continue;

    let tgt = null, minRatio = 1.01;
    for (let j=0;j<st.field.units.length;j++){
      const v = st.field.units[j];
      if (v.hp<=0) continue;
      if (w.p!=null && v.p !== w.p) continue;
      const d = Math.abs(v.x - w.x) + Math.abs(v.y - w.y);
      if (d <= (w.hRange||3)){
        const r = v.hp / v.maxhp;
        if (r < 1 && r < minRatio){ minRatio = r; tgt = v; }
      }
    }
    if (!tgt) continue;

    const raw = Math.max(1, w.hAmt|0);
    const amt = Math.max(1, Math.round(raw * healScale(tgt, now)));
    tgt.hp = Math.min(tgt.maxhp, tgt.hp + amt);
    st.field.fx.push(fxHeal(w.x, w.y, tgt.x, tgt.y));
    w.nextHeal = now + (w.hCd || 1500);
  }
}

function wardsShoot(st, now){
  const wards = st.field.wards || [];
  for (let i=0;i<wards.length;i++){
    const w = wards[i];
    if (!w.shoot || w.hp<=0 || w.until<=now) continue;
    if (w.disabledUntil && w.disabledUntil > now) continue;
    if (now < (w.next||0)) continue;

    const maxT = w.maxTargets || 1;
    const cand = [];
    for (let j=0;j<st.field.units.length;j++){
      const v = st.field.units[j];
      if (v.hp<=0) continue;
      if (w.p!=null && v.p===w.p) continue;
      const d = Math.abs(v.x - w.x) + Math.abs(v.y - w.y);
      if (d <= (w.wRange||3)) cand.push({v:v,d:d});
    }
    if (!cand.length) continue;
    cand.sort((a,b)=>a.d-b.d);
    const targets = cand.slice(0, maxT).map(c=>c.v);

    for (let j=0;j<targets.length;j++){
      const tgt = targets[j];
      st.field.fx.push(fxBeam(w.x, w.y, tgt.x, tgt.y));
      const raw = w.wDmg || 1;
      const dmg = reduceDamageForTarget(raw, tgt, st.field);
      applyDamage(tgt, dmg, st);
    }
    w.next = now + (w.wCd || 1400);
  }
}

/* Combat & abilities */
function healAction(u, st, now){
  if (!u.heal) return false;
  if (now < (u.nextHeal||0)) return false;
  const allies = st.field.units.filter(v=>v.p===u.p && v.id!==u.id && v.hp>0);
  if (!allies.length) return false;
  let target=null, minRatio=1.01;
  for(let i=0;i<allies.length;i++){
    const a = allies[i];
    const dist = Math.abs(unitCenter(a).x-unitCenter(u).x)+Math.abs(unitCenter(a).y-unitCenter(u).y);
    if (dist <= (u.healRange||2)){
      const r = a.hp/a.maxhp;
      if (r < minRatio){ minRatio = r; target=a; }
    }
  }
  if (!target) return false;
  const raw = Math.max(1, u.healAmt|0);
  const amt = Math.max(1, Math.round(raw * healScale(target, now)));
  target.hp = Math.min(target.maxhp, target.hp + amt);
  st.field.fx.push(fxHeal(u.x,u.y,target.x,target.y));
  u.nextHeal = now + (u.healCd||1200);
  return true;
}
function wardAction(u, st, now){
  if (!u.ward) return false;
  if (now < (u.nextWard||0)) return false;
  const dir = u.p===0 ? -1 : +1;
  const tx=u.x, ty=u.y+dir;
  if (inside(tx,ty)){
    const isShooter = !!u.wardShooter;
    const isL3Architect = (u.type === "architect" && (u.lvl||1) >= 3);

    const opts = isShooter
      ? {
          p:u.p,
          shoot:true,
          wDmg:(u.wardDmg||2),
          wRange:(u.wardRange||3),
          wCd:(u.wardCdShoot||u.wardCd||1400),
          multi:isL3Architect,
          maxTargets:isL3Architect ? 3 : 1
        }
      : {
          p:u.p,
          heal:true,
          hAmt:(u.wardHealAmt||2),
          hRange:(u.wardHealRange||3),
          hCd:(u.wardHealCd||1500)
        };

    if (placeWard(st, tx, ty, u.wardHp||2, u.wardDur||6000, opts)){
      u.nextWard = now + (u.wardCd||1700);
      return true;
    }
  }
  return false;
}

function applyDamage(victim, dmg, st){
  victim.hp -= dmg;
  flashAt(victim.x, victim.y, dmg);
  if (st && st.field && st.field.fx) st.field.fx.push(fxImpact(victim.x, victim.y));
}
function splash(units, field, x,y,dmg,srcP,kn,strong,opts){
  for(let dy=-1;dy<=1;dy++){
    for(let dx=-1;dx<=1;dx++){
      const nx=x+dx, ny=y+dy; if(!inside(nx,ny)) continue;
      const hit=units.find(o=>o.p!==srcP && nx>=o.x && nx<o.x+unitSize(o) && ny>=o.y && ny<o.y+unitSize(o));
      if(hit){
        const rd = reduceDamageForTarget(dmg, hit, field, opts);
        applyDamage(hit, rd, {field:field});
        if(kn) tryKnock(x,y,hit,units,strong);
      }
    }
  }
}
function tryKnock(cx,cy,t,units,strong){
  const tcx=t.x+(unitSize(t)-1)/2, tcy=t.y+(unitSize(t)-1)/2;
  const dx=Math.sign(tcx-cx), dy=Math.sign(tcy-cy);
  let steps = strong ? 2 : 1;
  while(steps>0){
    const nx=t.x+dx, ny=t.y+dy;
    if (canMoveTo(t, units, nx, ny)){ t.x=nx; t.y=ny; steps--; } else break;
  }
}
function chainLightning(units, field, startTarget, srcP, hops, dmg, opts){
  let cur = startTarget; let left=hops; const hit=new Set();
  while(cur && left>0){
    applyDamage(cur, reduceDamageForTarget(dmg, cur, field, opts), {field:field});
    hit.add(cur.id);
    let cand=null,bd=1e9; const cx=cur.x, cy=cur.y;
    for(let i=0;i<units.length;i++){
      const v=units[i];
      if(v.p===srcP || hit.has(v.id)) continue;
      const d=Math.abs(v.x-cx)+Math.abs(v.y-cy);
      if(d<=2 && d<bd){ bd=d; cand=v; }
    }
    cur=cand; left--;
  }
}
function attack(u, t, now, st){
  const inRange = manhattanUnits(u,t) <= (u.range||1);
  if (!inRange) return false;
  if (now < (u.nextAtk||0)) return true;

  const ranged = (u.range||1) > 1;
  u.animUntil = now + 320;
  u.animType = troopBodyClass(u.type) === "caster" ? "cast" : "attack";

  function deal(victim, raw, isRanged){
    let dmg = raw|0;
    const attackerStrongVs = (u.strongVs || []).length ? u.strongVs : unitStrongVs(u.type);
    const victimArmor = victim.armorType || armorTypeFor(victim.type, victim);
    if (attackerStrongVs.includes(victimArmor)) dmg += 2;
    if (isRanged){
      dmg = applyWardShields(u, victim, dmg, st.field);
      if (victim.rangedReduce) dmg = Math.max(1, dmg - (victim.rangedReduce|0));
    }
    dmg = reduceDamageForTarget(dmg, victim, st.field, {ignoreArmor:!!u.trueDamage});
    applyDamage(victim, dmg, st);
  }

  if (u.kamikaze){
    st.field.fx.push(fxBurst(u.x,u.y));
    deal(t, u.dmg, ranged);

    if (u.splash1){
      const sd = Math.max(1, Math.floor(u.dmg * 0.6));
      splash(st.field.units, st.field, t.x, t.y, sd, u.p, true, false, {ignoreArmor:!!u.trueDamage});
    }
    if (u.paints) paintPoison(st, u.x, u.y, 7000, u.p);

    u.hp = 0;

  } else if (u.type === "vrocket"){
    st.field.fx.push(fxBeam(u.x,u.y,t.x,t.y));
    deal(t, u.dmg, true);
    const sd = Math.max(1, Math.floor(u.dmg * 0.6));
    splash(st.field.units, st.field, t.x, t.y, sd, u.p, true, false, {ignoreArmor:!!u.trueDamage});

  } else if (u.chain3){
    st.field.fx.push(fxBeam(u.x,u.y,t.x,t.y));
    if (u.type === "storm") st.field.fx.push(fxStorm(t.x,t.y));
    chainLightning(st.field.units, st.field, t, u.p, 3, u.dmg, {ignoreArmor:!!u.trueDamage});

  } else if (u.type === "roach" && (u.lvl||1) >= 3){
    if (ranged) st.field.fx.push(fxBeam(u.x,u.y,t.x,t.y));
    deal(t, u.dmg, true);
    paintPoison(st, t.x, t.y, 5000, u.p);

  } else if (u.acid){
    st.field.fx.push(fxBeam(u.x,u.y,t.x,t.y));
    deal(t, u.dmg, true);
    addAcid(st, t.x, t.y, TROOPS[u.type].base.acidDur || 3500);

  } else {
    if (ranged) st.field.fx.push(fxBeam(u.x,u.y,t.x,t.y));
    deal(t, u.dmg, ranged);
    const strong = !!u.strongKnock;
    if (u.splash1){
      const sd = Math.max(1, Math.floor(u.dmg * 0.6));
      splash(st.field.units, st.field, t.x, t.y, sd, u.p, !!u.knock, strong, {ignoreArmor:!!u.trueDamage});
    }
    if (u.toxicSplash){
      addToxicSplash(st, t.x, t.y, 7000, u.p);
    }

    if (u.type === "storm" && (u.lvl||1) >= 3 && t.hp > 0){
      const shockDur = 1200;
      t.slowUntil = Math.max(t.slowUntil||0, now + shockDur);
      t.statusShockUntil = Math.max(t.statusShockUntil||0, now + shockDur);
    }
  }

  if (u.antiSupport && t.hp > 0 && isSupportUnit(t)){
    const bonus = Math.max(1, u.supportBonus||3);
    applyDamage(t, bonus, st);
  }
  if (u.executePct && t.hp > 0 && t.hp <= Math.floor(t.maxhp * u.executePct)){
    applyDamage(t, t.hp, st);
  }
  if (u.empShock && t.hp > 0){
    applyShockDebuff(st, t, now, u.shockDur || 1500);
  }
  if (u.bind && t.hp > 0){
    const bd = u.bindDur || 1200;
    t.bindUntil = Math.max(t.bindUntil||0, now + bd);
    t.statusShockUntil = Math.max(t.statusShockUntil||0, now + bd);
    st.field.fx.push(fxStatus(t.x, t.y, "‚ö°"));
  }
  if (u.wound && t.hp > 0){
    const wd = u.woundDur || 2400;
    t.woundUntil = Math.max(t.woundUntil||0, now + wd);
    st.field.fx.push(fxStatus(t.x, t.y, "ü©∏"));
  }
  if (u.suppress && t.hp > 0){
    t.slowUntil  = Math.max(t.slowUntil||0, now + (u.suppressDur || 900));
    t.slowFactor = u.slowFactor || 2;
  }

  u.nextAtk = now + (u.cd || 600);
  return true;
}

/* VGuard L3 regen */
function applyVguardRegen(u, st, now){
  if (u.type === "vguard" && (u.lvl||1) >= 3 && u.hp > 0 && u.hp < u.maxhp){
    if (!u.regenCd) u.regenCd = 2000;
    if (!u.nextRegen) u.nextRegen = 0;
    if (now >= u.nextRegen){
      const raw = 2;
      const amt = Math.max(1, Math.round(raw * healScale(u, now)));
      const before = u.hp;
      u.hp = Math.min(u.maxhp, u.hp + amt);
      if (u.hp > before){
        st.field.fx.push(fxHeal(u.x, u.y, u.x, u.y));
      }
      u.nextRegen = now + u.regenCd;
    }
  }
}

/* state helpers */
function bothPicked(d){
  const di=d.draftIndex|0;
  return (d.selections && d.selections.p0 && d.selections.p0[di] != null) &&
         (d.selections && d.selections.p1 && d.selections.p1[di] != null);
}
function bothFactionsChosen(d){
  return !!(d.factions && d.factions.p0) && !!(d.factions && d.factions.p1);
}

/* MMR helpers */
function calcMMRChange(st, winnerName){
  const mmr = st.mmr || [1000,1000];
  const players = st.players || [];
  const idxWin = players.indexOf(winnerName);
  if (idxWin < 0) return { mmr:mmr, delta:[0,0] };
  const idxLose = idxWin === 0 ? 1 : 0;

  const base = 25;
  const diff = (mmr[idxLose] - mmr[idxWin]) || 0;
  const factor = 1 + diff / 4000;
  const gain = Math.max(10, Math.round(base * factor));

  const next = [mmr[0], mmr[1]];
  next[idxWin]  = mmr[idxWin]  + gain;
  next[idxLose] = Math.max(0, mmr[idxLose] - gain);

  const delta = [0,0];
  delta[idxWin]  = gain;
  delta[idxLose] = -gain;

  return { mmr:next, delta:delta };
}
function rankLabel(m){
  if (m >= 3000) return "Grandmaster";
  if (m >= 2500) return "Masters";
  if (m >= 2000) return "Diamond";
  if (m >= 1600) return "Gold";
  if (m >= 1300) return "Silver";
  return "Bronze";
}
function rankClass(m){
  if (m >= 3000) return "nameGrandmaster";
  if (m >= 2500) return "nameMasters";
  if (m >= 2000) return "nameDiamond";
  if (m >= 1600) return "nameGold";
  if (m >= 1300) return "nameSilver";
  return "nameBronze";
}

let hostTick=null, battleTick=null;

/* keep lobby.players in state.players (host only) */
async function syncPlayersIntoStateIfNeeded(){
  const stSnap = await getDoc(stateRef);
  if (!stSnap.exists()) return;
  const st = stSnap.data();
  const want = lobbyPlayers.slice(0,2);
  const cur = Array.isArray(st.players)? st.players : [];
  if (want.length && (cur.length!==want.length || cur.some((n,i)=>n!==want[i]))){
    const next = { players: want };
    if ((st.phase === "waiting" || st.phase === "faction-select") && !st.eloCommitted){
      next.mmr = await fetchPlayerMMR(want);
      next.mmrChange = [0,0];
    }
    await updateDoc(stateRef, next);
  }
}

/* ----------- Host loop (phase machine) ----------- */
function startHostLoops(){
  if(hostTick) return;
  hostTick=setInterval(async ()=>{
    const snap=await getDoc(stateRef); if(!snap.exists()) return;
    const d=snap.data(); const now=Date.now();

    if (!d.players || !Array.isArray(d.players)) d.players = lobbyPlayers.slice(0,2);

    if (d.phase==="waiting" && lobbyPlayers.length>=2){
      await updateDoc(stateRef,{ phase:"faction-select", phaseEndsAt: now+20000 });
      return;
    }

    if (d.phase==="faction-select"){
      if (bothFactionsChosen(d) || now >= (d.phaseEndsAt||0)){
        const fx = { p0:null, p1:null };
        fx.p0 = (d.factions && d.factions.p0) ? d.factions.p0 : ALL_FACTIONS[Math.floor(Math.random()*ALL_FACTIONS.length)];
        fx.p1 = (d.factions && d.factions.p1) ? d.factions.p1 : ALL_FACTIONS[Math.floor(Math.random()*ALL_FACTIONS.length)];

        await updateDoc(stateRef,{
          factions:fx, phase:"draft", draftIndex:0,
          selections:{p0:[],p1:[]},
          currentPacks:{
            p0: packFor(d.roster && d.roster.p0 ? d.roster.p0 : [], fx.p0),
            p1: packFor(d.roster && d.roster.p1 ? d.roster.p1 : [], fx.p1)
          },
          phaseEndsAt: now+10000,
          bonusFor:null
        });
      }
      return;
    }

    if (d.phase==="draft" && (bothPicked(d) || now >= (d.phaseEndsAt||0))){
      const di=d.draftIndex|0;
      const sel = d.selections || {p0:[],p1:[]};

      if (!sel.p0) sel.p0 = [];
      if (!sel.p1) sel.p1 = [];

      ["p0","p1"].forEach(sk=>{
        if (sel[sk][di]==null){
          const pack=(d.currentPacks && d.currentPacks[sk]) ? d.currentPacks[sk] : [];
          if (pack.length>0) sel[sk][di] = Math.floor(Math.random()*pack.length);
        }
      });

      const roster = d.roster || {p0:[],p1:[]};
      if (!roster.p0) roster.p0 = [];
      if (!roster.p1) roster.p1 = [];

      ["p0","p1"].forEach(sk=>{
        const pack=(d.currentPacks && d.currentPacks[sk]) ? d.currentPacks[sk] : [];
        const pickIndex = sel[sk][di];
        const pick = (pickIndex!=null) ? pack[pickIndex] : null;
        if(!pick) return;
        if (pick.type==="troop") rosterAdd(roster[sk], pick.key, 1);
        else if (pick.type==="special"){
          if(pick.special==="double") rosterDoubleOneSpecific(roster[sk], pick.for);
          if(pick.special==="upgrade") rosterUpgradeOneSpecific(roster[sk], pick.for);
        }
      });

      const nextIx=di+1;
      if (nextIx>=3){
        const temp = {
          players: d.players || [],
          lives: d.lives || [4,4],
          roster: roster,
          field: fieldEmpty(),
          factions: d.factions || {p0:null,p1:null}
        };
        rebuildFieldFromRoster(temp);
        await updateDoc(stateRef,{
          roster: temp.roster,
          field: temp.field,
          selections:{p0:[],p1:[]},
          draftIndex:0,
          currentPacks:{p0:[],p1:[]},
          phase:"battle",
          phaseEndsAt:0,
          bonusFor:null
        });
        runBattle();
      }else{
        await updateDoc(stateRef,{
          roster: roster,
          selections: sel,
          draftIndex: nextIx,
          currentPacks:{
            p0: packFor(roster.p0, d.factions && d.factions.p0 ? d.factions.p0 : "Helions"),
            p1: packFor(roster.p1, d.factions && d.factions.p1 ? d.factions.p1 : "Helions")
          },
          phaseEndsAt: Date.now()+10000,
          bonusFor:null
        });
      }
      return;
    }

    if (d.phase==="loser-bonus"){
      const loser = d.bonusFor;
      const di=d.draftIndex|0;
      const sel=d.selections || {p0:[],p1:[]};
      if (!sel.p0) sel.p0 = [];
      if (!sel.p1) sel.p1 = [];

      if (sel[loser] && sel[loser][di]==null && now >= (d.phaseEndsAt||0)){
        const pack=(d.currentPacks && d.currentPacks[loser]) ? d.currentPacks[loser] : [];
        if (pack.length>0){
          sel[loser][di] = Math.floor(Math.random()*pack.length);
        }
      }
      const hasPicked = sel[loser] && sel[loser][di]!=null;
      if (hasPicked){
        const roster=d.roster || {p0:[],p1:[]};
        if (!roster.p0) roster.p0 = [];
        if (!roster.p1) roster.p1 = [];

        const pack=(d.currentPacks && d.currentPacks[loser]) ? d.currentPacks[loser] : [];
        const pickIndex = sel[loser][di];
        const pick = (pickIndex!=null) ? pack[pickIndex] : null;
        if (pick){
          if (pick.type==="troop") rosterAdd(roster[loser], pick.key, 1);
          else if (pick.type==="special"){
            if(pick.special==="double") rosterDoubleOneSpecific(roster[loser], pick.for);
            if(pick.special==="upgrade") rosterUpgradeOneSpecific(roster[loser], pick.for);
          }
        }
        await updateDoc(stateRef,{
          roster: roster,
          selections:{p0:[],p1:[]},
          draftIndex:0,
          currentPacks:{
            p0: packFor(roster.p0, d.factions && d.factions.p0 ? d.factions.p0 : "Helions"),
            p1: packFor(roster.p1, d.factions && d.factions.p1 ? d.factions.p1 : "Helions")
          },
          phase:"draft-after",
          phaseEndsAt: Date.now()+10000,
          bonusFor:null
        });
      }
      return;
    }

    if (d.phase==="draft-after" && (bothPicked(d) || now >= (d.phaseEndsAt||0))){
      const di=d.draftIndex|0;
      const sel=d.selections || {p0:[],p1:[]};
      if (!sel.p0) sel.p0 = [];
      if (!sel.p1) sel.p1 = [];

      ["p0","p1"].forEach(sk=>{
        if (sel[sk][di]==null){
          const pack=(d.currentPacks && d.currentPacks[sk]) ? d.currentPacks[sk] : [];
          if (pack.length>0){
            sel[sk][di] = Math.floor(Math.random()*pack.length);
          }
        }
      });

      const roster=d.roster || {p0:[],p1:[]};
      if (!roster.p0) roster.p0 = [];
      if (!roster.p1) roster.p1 = [];

      ["p0","p1"].forEach(sk=>{
        const pack=(d.currentPacks && d.currentPacks[sk]) ? d.currentPacks[sk] : [];
        const pickIndex = sel[sk][di];
        const pick = (pickIndex!=null) ? pack[pickIndex] : null;
        if(!pick) return;
        if (pick.type==="troop") rosterAdd(roster[sk], pick.key, 1);
        else if (pick.type==="special"){
          if(pick.special==="double") rosterDoubleOneSpecific(roster[sk], pick.for);
          if(pick.special==="upgrade") rosterUpgradeOneSpecific(roster[sk], pick.for);
        }
      });

      const nextIx=di+1;
      if (nextIx>=3){
        const temp = {
          players: d.players || [],
          lives: d.lives || [4,4],
          roster: roster,
          field: fieldEmpty(),
          factions: d.factions || {p0:null,p1:null}
        };
        rebuildFieldFromRoster(temp);
        await updateDoc(stateRef,{
          roster: temp.roster,
          field: temp.field,
          selections:{p0:[],p1:[]},
          draftIndex:0,
          currentPacks:{p0:[],p1:[]},
          phase:"battle",
          phaseEndsAt:0
        });
        runBattle();
      }else{
        await updateDoc(stateRef,{
          roster: roster,
          selections: sel,
          draftIndex: nextIx,
          currentPacks:{
            p0: packFor(roster.p0, d.factions && d.factions.p0 ? d.factions.p0 : "Helions"),
            p1: packFor(roster.p1, d.factions && d.factions.p1 ? d.factions.p1 : "Helions")
          },
          phaseEndsAt: Date.now()+10000
        });
      }
      return;
    }

    if (d.phase==="battle" && !battleTick) runBattle();

    /* cleanup FX + terrain (skip during battle; battle loop owns the field) */
    if (d.phase === "battle") return;

    const nf = d.field || fieldEmpty();
    const now2=Date.now();
    const beforeFx = (nf.fx||[]).length;
    const beforePoison = (nf.poison||[]).length;
    const beforeToxic = (nf.toxic||[]).length;
    const beforeAcid = (nf.acid||[]).length;
    const beforeWards = (nf.wards||[]).length;
    nf.fx    = (nf.fx||[]).filter(ev=>ev.at+ev.ttl > now2);
    nf.poison= (nf.poison||[]).filter(p=>p.until>now2);
    nf.toxic = (nf.toxic ||[]).filter(t=>t.until>now2);
    nf.acid  = (nf.acid  ||[]).filter(a=>a.until>now2);
    nf.wards = (nf.wards ||[]).filter(w=>w.until>now2 && w.hp>0);

    const changed =
      beforeFx !== nf.fx.length ||
      beforePoison !== nf.poison.length ||
      beforeToxic !== nf.toxic.length ||
      beforeAcid !== nf.acid.length ||
      beforeWards !== nf.wards.length;

    if (changed) await updateDoc(stateRef, { field: nf });
  }, 260);
}

/* ----------- Battle loop ----------- */
function runBattle(){
  if (battleTick) return;

  let lastLogic = 0;

  battleTick = setInterval(async ()=>{
    const snap = await getDoc(stateRef);
    if (!snap.exists()){
      clearInterval(battleTick); battleTick=null; return;
    }
    const d = snap.data();
    if (d.phase !== "battle"){
      clearInterval(battleTick); battleTick=null; return;
    }

    const st = deepClone(d);
    const units = st.field.units || [];
    const now = Date.now();

    const doLogic = (now - lastLogic) >= LOGIC_MS;
    if (!doLogic) return;
    lastLogic = now;

    if (doLogic) applyTerrain(st.field, units);
    if (doLogic){
      for (let i=0;i<units.length;i++){
        blinkIfNeeded(units[i]);
      }
    }

    if (doLogic) wardsHeal(st, now);
    if (doLogic) wardsShoot(st, now);
    if (doLogic) broodTick(st, now);

    for (let i=0;i<units.length;i++){
      const u = units[i];
      if (!u || u.hp<=0) continue;

      if (doLogic){
        healAction(u, st, now);
        wardAction(u, st, now);
        applyVguardRegen(u, st, now);
      }

      const t = pickTarget(u, units, st.field);
      if (!t) continue;

      const attacked = attack(u, t, now, st);

      if (!attacked && doLogic){
        if (canStepNow(u, now)) {
          const slowed = (u.slowUntil && u.slowUntil > now);
          const bound = (u.bindUntil && u.bindUntil > now);
          const steps = bound ? 0 : (slowed ? 1 : PACE.moveSteps);

          for (let s=0; s<steps; s++){
            const t2 = pickTarget(u, units, st.field);
            if (!t2) break;

            if (u.burrow) attemptBurrow(u, units, st, now);

            const targetIsBack = isBacklineUnit(t2);
            if (u.viperLeap && targetIsBack && frontBlocked(u, units)){
              if (attemptViperLeap(u, units, st)){
                if (manhattanUnits(u, t2) <= (u.range||1)){
                  attack(u, t2, now, st);
                }
                continue;
              }
            }

            stepToward(u, t2, units);
            if (manhattanUnits(u, t2) <= (u.range||1)){
              attack(u, t2, now, st);
              break;
            }
          }
        }
      }
    }

    if (doLogic){
      const dead = st.field.units.filter(u=>u.hp<=0);
      for (let i=0;i<dead.length;i++){
        const u = dead[i];
        if (u.paints){
          paintPoison(st, u.x, u.y, 7000, u.p);
          st.field.fx.push(fxBurst(u.x,u.y));
        }
      }
      st.field.units = st.field.units.filter(u=>u.hp>0);
    }

    const a0 = st.field.units.some(u=>u.p===0);
    const a1 = st.field.units.some(u=>u.p===1);
    if (!a0 || !a1){
      clearInterval(battleTick); battleTick=null;

      const loser = a0 ? 1 : 0;
      const lives = (st.lives || [4,4]).slice();
      lives[loser] = Math.max(0, lives[loser]-1);

      const players = st.players || [];
      let winnerName = null;
      if (lives[0]===0 && players.length>1) winnerName = players[1];
      if (lives[1]===0 && players.length>0) winnerName = players[0];

      if (winnerName){
        const mmrInfo = calcMMRChange(st, winnerName);
        await runTransaction(db, async (tx)=>{
          const latest = await tx.get(stateRef);
          if (!latest.exists()) return;
          const live = latest.data();
          if (live.phase === "game-over" && live.eloCommitted) return;

          const names = Array.isArray(st.players) ? st.players.slice(0,2) : [];
          for (let i=0;i<2;i++){
            const nm = names[i];
            if (!nm) continue;
            tx.set(doc(db, "users", nm), {
              crowncouncilElo: mmrInfo.mmr[i],
              crowncouncilLastDelta: mmrInfo.delta[i],
              crowncouncilLastMatchAt: Date.now()
            }, { merge:true });
          }

          tx.update(stateRef, {
            lives: lives,
            phase: "game-over",
            phaseEndsAt: 0,
            winner: winnerName,
            mmr: mmrInfo.mmr,
            mmrChange: mmrInfo.delta,
            eloCommitted: true
          });
        });
      } else {
        const loserKey  = pKey(loser);
        const winnerKey = pKey(1-loser);

        const roster = st.roster || {p0:[],p1:[]};
        if (!roster.p0) roster.p0 = [];
        if (!roster.p1) roster.p1 = [];

        await updateDoc(stateRef, {
          lives: lives,
          phase: "loser-bonus",
          phaseEndsAt: Date.now()+10000,
          selections: { p0:[], p1:[] },
          currentPacks: (function(){
            const packs = { p0:[], p1:[] };
            packs[loserKey]  = packFor(roster[loserKey],  st.factions && st.factions[loserKey] ? st.factions[loserKey] : "Helions");
            packs[winnerKey] = [];
            return packs;
          })(),
          draftIndex: 0,
          bonusFor: loserKey
        });
      }
    } else {
      st.field.wards = (st.field.wards||[]).filter(w=>w.hp>0 && w.until>now);
      await updateDoc(stateRef, { field: st.field });
    }
  }, VIEW_MS);
}

/* ----------- UI render ----------- */
function render(){
  const p0n=(S && S.players && S.players[0]) || "P0";
  const p1n=(S && S.players && S.players[1]) || "P1";
  const lives=(S && S.lives) || [4,4];
  const mmr = (S && S.mmr) || [1000,1000];

  $("p0Badge").innerHTML = '<span class="'+rankClass(mmr[0])+'">'+p0n+'</span> ['+rankLabel(mmr[0])+' '+mmr[0]+'] ‚Äî <span class="'+rankClass(mmr[0])+'">'+("‚ù§".repeat(lives[0]))+'</span>';
  $("p1Badge").innerHTML = '<span class="'+rankClass(mmr[1])+'">'+p1n+'</span> ['+rankLabel(mmr[1])+' '+mmr[1]+'] ‚Äî <span class="'+rankClass(mmr[1])+'">'+("‚ù§".repeat(lives[1]))+'</span>';

  const phase=(S && S.phase) || "waiting";
  $("phaseBadge").textContent = phase.replaceAll("-"," ").toUpperCase();
  const draftish=["faction-select","draft","loser-bonus","draft-after"].includes(phase);
  const tleft = draftish ? Math.max(0,((S && S.phaseEndsAt) || 0)-Date.now()) : 0;
  $("timerBadge").textContent = draftish ? "‚è≥ "+Math.ceil(tleft/1000)+"s" : "‚è≥ ‚Äî";

  const counter = $("pickCounter");
  if (phase==="draft" || phase==="draft-after"){
    counter.style.display="block";
    counter.textContent = "PICK "+(((S && S.draftIndex) || 0)+1)+" / 3";
  } else if (phase==="loser-bonus"){
    counter.style.display="block"; counter.textContent = "LOSER BONUS";
  } else { counter.style.display="none"; }

  const endSummaryEl = $("endSummary");
  if (S && S.phase === "game-over"){
    const mmrFinal = S.mmr || [1000,1000];
    const delta = S.mmrChange || [0,0];
    const players = S.players || ["P0","P1"];
    const winner = S.winner;

    const p0Before = mmrFinal[0] - (delta[0]||0);
    const p1Before = mmrFinal[1] - (delta[1]||0);

    function fmtDelta(d){
      if (d>0) return '<span class="mmrUp">+'+d+'</span>';
      if (d<0) return '<span class="mmrDown">'+d+'</span>';
      return '<span>'+d+'</span>';
    }

    endSummaryEl.innerHTML = ''+
      '<div><strong>Winner:</strong> '+(winner||"‚Äî")+'</div>'+
      '<div><strong>'+(players[0]||"P0")+':</strong> '+p0Before+' ‚Üí '+mmrFinal[0]+' '+fmtDelta(delta[0]||0)+'</div>'+
      '<div><strong>'+(players[1]||"P1")+':</strong> '+p1Before+' ‚Üí '+mmrFinal[1]+' '+fmtDelta(delta[1]||0)+'</div>'+
      '<div style="margin-top:6px;opacity:.9">'+
      'Factions: '+((S.factions && S.factions.p0) || "?")+' vs '+((S.factions && S.factions.p1) || "?")+
      '</div>';
    endSummaryEl.style.display = "block";
  } else {
    if (endSummaryEl) endSummaryEl.style.display = "none";
  }

  const draftishPh=["faction-select","draft","loser-bonus","draft-after"].includes(phase);
  if (draftishPh){
    const ghost=deepClone(S);
    rebuildFieldFromRoster(ghost);
    paint(ghost.field.units, ghost.field);
  }else{
    paint((S && S.field && S.field.units) || [], (S && S.field) || fieldEmpty());
  }

  const row=$("cardRow"), overlay=$("overlay"), note=$("pickNote");
  if (!draftishPh){
    overlay.style.display="none"; row.style.display="none"; note.style.display="none"; row.innerHTML="";
    return;
  }
  overlay.style.display="block";

  const di=(S && S.draftIndex) ? S.draftIndex|0 : 0;
  const sk=pKey(meIndex);
  const pickedIndex = (S && S.selections && S.selections[sk]) ? S.selections[sk][di] : null;

  if (phase==="faction-select"){
    const already = S && S.factions && S.factions[sk];
    if (already){
      row.style.display="none"; row.innerHTML="";
      note.textContent="FACTION LOCKED: "+already;
      note.style.display="block"; return;
    }
    row.style.display="flex"; row.innerHTML=""; note.style.display="none";
    ["Helions","Aesir","Vanir"].forEach(f=>{
      const el=document.createElement("div"); el.className="card";
      const units = (FACTIONS[f]||[]).map(k=>unitEmoji(k)+" "+TROOPS[k].name).join(" ¬∑ ");
      el.innerHTML=''+
        '<div class="meta">FACTION</div>'+
        '<div class="title">'+f+'</div>'+
        '<div class="desc">'+units+'</div>';
      el.onclick=()=> chooseFaction(f);
      row.appendChild(el);
    });
    return;
  }

  if (phase==="loser-bonus"){
    const loserKey = S ? S.bonusFor : null;
    if (loserKey !== sk){
      row.style.display="none"; row.innerHTML="";
      note.textContent="Opponent bonus pick‚Ä¶";
      note.style.display="block"; return;
    }
  }

  const pack=(S && S.currentPacks && S.currentPacks[sk]) ? S.currentPacks[sk] : [];
  if (pickedIndex!=null){
    row.style.display="none"; row.innerHTML="";
    const picked = pack[pickedIndex];
    const label = picked
      ? (picked.type==="troop"
          ? picked.name
          : ((picked.special==="upgrade"?"Upgrade ":"Double ")+(TROOPS[picked.for] ? TROOPS[picked.for].name : "")))
      : "(auto)";
    note.textContent="Selected: "+label;
    note.style.display="block";
    return;
  }

  row.style.display="flex"; row.innerHTML=""; note.style.display="none";
  for(let i=0;i<pack.length;i++){
    const c=pack[i];
    const el=document.createElement("div"); el.className="card";
    if (c.type==="troop"){
      const tro = TROOPS[c.key];
      const armor = Math.max(0, (tro.base && tro.base.armor) ? (tro.base.armor|0) : 0);
      const trueTag = tro.trueDamage ? ' ¬∑ true dmg' : '';
      el.innerHTML=''+
        '<div class="meta">'+tro.faction+' ¬∑ '+(tro.role==="back"?"Backline":"Frontline")+' ¬∑ Armor '+armor+trueTag+'</div>'+
        '<div class="title">'+c.emoji+' '+c.name+'</div>'+
        '<div class="desc">'+(tro.role==="back"?"Support / ranged":"Frontline pressure")+' from '+tro.faction+'. Armor reduces incoming hit damage.</div>';
    }else{
      const nn=TROOPS[c.for]?.name||"Type";
      el.innerHTML=''+
        '<div class="meta">SPECIAL</div>'+
        '<div class="title">'+c.emoji+' '+(c.name || (c.special==="upgrade"?"Upgrade":"Double"))+'</div>'+
        '<div class="desc">'+(c.special==="upgrade"?"Upgrade ":"Double ")+nn+' in your roster.</div>';
    }
    (function(idx){
      el.onclick=function(){ chooseCard(idx); };
    })(i);
    row.appendChild(el);
  }
}

/* -------- transactional player actions -------- */
async function chooseFaction(fac){
  if(!S) return;
  const sk=pKey(meIndex);
  try{
    await runTransaction(db, async (tx)=>{
      const snap = await tx.get(stateRef);
      if (!snap.exists()) return;
      const data = snap.data();
      const currentFaction = data && data.factions && data.factions[sk];
      if (currentFaction) return;
      const phase = data.phase;
      if (phase !== "faction-select") return;
      const newFacs = data.factions || {p0:null,p1:null};
      newFacs[sk] = fac;
      tx.update(stateRef, { factions: newFacs });
    });
  }catch(e){
    console.error("chooseFaction failed", e);
  }
}
async function chooseCard(i){
  if(!S) return;
  const di=S.draftIndex|0;
  const sk=pKey(meIndex);
  try{
    await runTransaction(db, async (tx)=>{
      const snap = await tx.get(stateRef);
      if (!snap.exists()) return;
      const data = snap.data();
      if (data.phase!=="draft" && data.phase!=="draft-after" && data.phase!=="loser-bonus") return;

      const selections = data.selections || {p0:[],p1:[]};
      if (!selections.p0) selections.p0 = [];
      if (!selections.p1) selections.p1 = [];

      const curSel = selections[sk][di];
      if (curSel!=null) return;

      const pack = (data.currentPacks && data.currentPacks[sk]) ? data.currentPacks[sk] : [];
      if (!pack || !pack.length) return;

      selections[sk][di] = i;
      tx.update(stateRef, { selections: selections });
    });
  }catch(e){
    console.error("chooseCard failed", e);
  }
}

/* Listeners */
function startListeners(){
  if (listenersStarted) return;
  listenersStarted = true;

  onSnapshot(lobbyRef, async (snap)=>{
  if (!snap.exists()) return;

  const lob = snap.data() || {};
  lobbyPlayers = (Array.isArray(lob.players) ? lob.players : []).slice(0,2);
  isHost = (lob.host === username);

  if (isHost) {
    await ensureStateExists();
    await syncPlayersIntoStateIfNeeded();
    startHostLoops();
  }

  const curPlayers = (S && Array.isArray(S.players)) ? S.players : lobbyPlayers;
  let idx = curPlayers.indexOf(username);
  if (idx < 0) idx = 0;
  meIndex = Math.max(0, Math.min(1, idx));

  fitBoard();
  render();
}, (err)=>{
  console.error("lobby listener failed", err);
});

let lastFxSeen=new Set();
onSnapshot(stateRef,(snap)=>{
  if(!snap.exists()) return;
  S=snap.data();
  const current = S.players || lobbyPlayers || [];
  let idx = current.indexOf(username);
  if (idx < 0) idx = 0;
  meIndex = Math.max(0, Math.min(1, idx));
  render();

  const list=(S.field && S.field.fx) ? S.field.fx : [];
  for(let i=0;i<list.length;i++){
    const ev=list[i];
    if (lastFxSeen.has(ev.id)) continue;
    lastFxSeen.add(ev.id);
    if (ev.type==="beam") renderBeam(ev,false);
    if (ev.type==="hbeam") renderBeam(ev,true);
    if (ev.type==="burst") renderBurst(ev);
    if (ev.type==="transport") renderTransport(ev);
    if (ev.type==="impact") renderImpact(ev);
    if (ev.type==="storm") renderStorm(ev);
    if (ev.type==="status") renderStatusPop(ev);
    setTimeout(()=> lastFxSeen.delete(ev.id), ev.ttl+200);
  }
}, (err)=>{
  console.error("state listener failed", err);
});
}

onAuthStateChanged(auth, (user) => {
  if (!user) return;
  console.log("Signed in as anon uid:", user.uid);
  startListeners();
});

/* Fullscreen */
$("fsBtn").onclick = async ()=>{
  try{
    if (!document.fullscreenElement) await document.documentElement.requestFullscreen();
    else await document.exitFullscreen();
  }catch(e){
    console.warn(e);
  }
};
</script>

</body>
</html>






















