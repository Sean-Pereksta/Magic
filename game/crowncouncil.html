<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>üëë Crown & Council (Multiplayer)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<style>
  :root{
    --bg:#fff7f7; --ink:#0f172a; --muted:#64748b; --card:#fff; --br:#f3e2e2;
    --accent:#b91c1c; --accent-2:#991b1b; --accent-soft:#fee2e2;
    --good:#16a34a; --warn:#f59e0b; --bad:#ef4444;
    --shadow:0 10px 30px rgba(15,23,42,.08); --radius:16px; --tap:52px;
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
  html,body{height:100%}
  body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;color:var(--ink);background:var(--bg)}

  .shell{max-width:1200px;margin:0 auto;padding:10px 12px 28px}
  .topbar{display:flex;align-items:center;justify-content:space-between;gap:12px;margin:8px 0;flex-wrap:wrap}
  .leftrow{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .badge{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border:1px solid var(--br);border-radius:999px;background:var(--card);box-shadow:var(--shadow);font-weight:800}
  .btn{appearance:none;border:1px solid var(--br);background:var(--accent);color:#fff;border-radius:12px;padding:12px 14px;font-weight:800;cursor:pointer}
  .btn:hover{background:var(--accent-2)}
  .btn-ghost{background:#fff;color:var(--ink)}
  .btn-ghost:hover{background:#fff5f5}
  .btn-sm{padding:9px 12px;border-radius:10px}
  .card{background:var(--card);border:1px solid var(--br);border-radius:var(--radius);box-shadow:var(--shadow)}
  .card-head{padding:12px 14px;border-bottom:1px solid var(--br);display:flex;align-items:center;justify-content:space-between;gap:10px}
  .card-title{font-weight:900}
  .card-body{padding:14px}
  .muted{color:var(--muted)}

  .layout{display:grid;grid-template-columns:1.2fr 2fr;gap:12px}
  @media (max-width:980px){ .layout{grid-template-columns:1fr} }

  /* HUD panels */
  .scorebar{display:flex;flex-wrap:wrap;gap:8px}
  .pill{display:inline-flex;align-items:center;gap:8px;padding:6px 8px;border-radius:999px;border:1px solid var(--br);background:#fff}
  .dot{width:12px;height:12px;border-radius:50%}

  /* Map window */
  .map-wrap{position:relative;height:68vh;min-height:420px;border-radius:16px;border:1px solid var(--br);overflow:hidden;background:#fff}
  .map-toolbar{position:absolute;z-index:5;top:10px;left:10px;display:flex;gap:8px;flex-wrap:wrap}
  .map-window{position:absolute;inset:0;overflow:hidden;touch-action:none;background:repeating-linear-gradient(0deg,#fef2f2 0,#fef2f2 20px,#fff 20px,#fff 40px)}
  .map-canvas{position:absolute;top:0;left:0;will-change:transform}
  .tile{position:absolute;width:48px;height:48px;border:1px solid #e5e7eb;border-radius:8px;background:#f8fafc;
        display:flex;align-items:center;justify-content:center;font-weight:900;user-select:none}
  .tile.owned{border-width:2px}
  .tile.sel{outline:3px solid #111827}
  .tile.enemy{filter:saturate(1.15)}
  .tile .u{font-size:13px;background:#fff;border:1px solid #e5e7eb;border-radius:8px;padding:2px 6px}

  /* Orders */
  .orders{display:grid;grid-template-columns:1fr;gap:8px}
  .order{display:flex;align-items:center;justify-content:space-between;padding:8px;border:1px solid var(--br);border-radius:10px;background:#fff}
  .order small{color:var(--muted)}
  .order .del{cursor:pointer;border:none;background:#fff;color:var(--bad);font-weight:900}

  /* Diplomacy & chat */
  .diplomacy{display:grid;gap:8px}
  .chat{height:180px;border:1px solid var(--br);border-radius:12px;padding:8px;overflow:auto;background:#fff}

  /* Modals */
  .modal-back{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;padding:16px;z-index:1000}
  .modal{width:min(720px,96vw);background:#fff;border-radius:16px;border:1px solid var(--br);box-shadow:var(--shadow);overflow:hidden}
  .modal .head{padding:12px 14px;border-bottom:1px solid var(--br);display:flex;justify-content:space-between;align-items:center}
  .modal .body{padding:14px}

  /* Sticky footer for mobile actions */
  .mobile-actions{display:flex;gap:8px;position:sticky;bottom:0;padding-top:8px;background:linear-gradient(180deg, transparent, #fff);}

  /* Fullscreen hints */
  .fs-hint{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<div class="shell">
  <div class="topbar">
    <div class="leftrow">
      <span class="badge">üëë Crown & Council</span>
      <span id="statusBadge" class="badge">Loading‚Ä¶</span>
      <span id="roundBadge" class="badge">R0</span>
      <span id="timerBadge" class="badge">‚è±Ô∏è ‚Äî</span>
      <span id="levyBadge" class="badge" title="Anti-snowball: if someone holds >40% land, others get +1 atk this round" style="display:none">üõ°Ô∏è Levy +1</span>
    </div>
    <div class="leftrow">
      <button id="fitBtn" class="btn btn-ghost" title="Fullscreen / Fit">‚õ∂ Fit</button>
      <a href="/index.html" class="btn btn-ghost">üè† Hub</a>
    </div>
  </div>

  <div class="layout">
    <!-- LEFT: HUD -->
    <div class="col">
      <!-- Scoreboard -->
      <div class="card">
        <div class="card-head">
          <div class="card-title">Scoreboard</div>
          <div id="coalitionMeter" class="muted">Coalition: ‚Äî</div>
        </div>
        <div class="card-body">
          <div id="scorebar" class="scorebar"></div>
        </div>
      </div>

      <!-- Orders & Actions -->
      <div class="card" style="margin-top:12px">
        <div class="card-head">
          <div class="card-title">Orders (simultaneous)</div>
          <div class="muted fs-hint">Tap a tile to select; tap neighbor to target.</div>
        </div>
        <div class="card-body">
          <div class="orders" id="ordersList"></div>

          <div class="mobile-actions">
            <button id="attackBtn" class="btn btn-sm" title="Attack from selected to target">‚öîÔ∏è Attack</button>
            <button id="fortifyBtn" class="btn btn-sm" title="Fortify selected (+1 up to cap)">üõ°Ô∏è Fortify</button>
            <button id="recruitBtn" class="btn btn-sm" title="Recruit on selected (+1 up to cap)">üßë‚Äçüéì Recruit</button>
            <button id="holdBtn" class="btn btn-sm btn-ghost" title="No action">‚úã Hold</button>
            <button id="submitBtn" class="btn" style="margin-left:auto">‚úÖ Submit</button>
          </div>
        </div>
      </div>

      <!-- Diplomacy -->
      <div class="card" style="margin-top:12px">
        <div class="card-head">
          <div class="card-title">Diplomacy & Micro-Deals</div>
          <button id="dealBtn" class="btn btn-ghost btn-sm">ü§ù Propose Deal</button>
        </div>
        <div class="card-body">
          <div id="chatBox" class="chat" aria-live="polite"></div>
          <div class="diplomacy">
            <div style="display:flex;gap:8px">
              <input id="chatInput" class="btn-ghost" style="flex:1;border:1px solid var(--br);border-radius:10px;padding:10px" placeholder="Type to chat (e.g., 'I‚Äôll hit C5 if you spare B4')" />
              <button id="chatSend" class="btn btn-sm">Send</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- RIGHT: Map -->
    <div class="col">
      <div class="card">
        <div class="card-head">
          <div class="card-title">Map</div>
          <div class="muted">Drag to pan. Pinch/zoom via device zoom if needed.</div>
        </div>
        <div class="card-body">
          <div class="map-wrap">
            <div class="map-toolbar">
              <button id="centerBtn" class="btn btn-ghost btn-sm">üéØ Center</button>
              <button id="clearSelBtn" class="btn btn-ghost btn-sm">üßΩ Clear Sel.</button>
            </div>
            <div class="map-window" id="mapWindow">
              <div class="map-canvas" id="mapCanvas"></div>
            </div>
          </div>
        </div>
      </div>
      <div class="muted" style="margin-top:6px">Tip: Add orders quickly‚Äîeverything resolves together on reveal.</div>
    </div>
  </div>
</div>

<!-- Deal Modal -->
<div id="dealModalBack" class="modal-back">
  <div class="modal">
    <div class="head">
      <div class="card-title">ü§ù Propose a Deal</div>
      <button id="closeDeal" class="btn btn-ghost btn-sm">Close</button>
    </div>
    <div class="body">
      <div style="display:grid;gap:10px">
        <select id="dealTo" style="padding:10px;border:1px solid var(--br);border-radius:10px">
          <option value="">‚Äî Choose player ‚Äî</option>
        </select>
        <select id="dealType" style="padding:10px;border:1px solid var(--br);border-radius:10px">
          <option value="nonaggr">Non-aggression (N rounds)</option>
          <option value="target">I‚Äôll attack <tile> if you spare <tile></option>
          <option value="support">Support attack on <tile></option>
        </select>
        <input id="dealNote" placeholder="Details (e.g., 'I‚Äôll hit D7 this round')" style="padding:10px;border:1px solid var(--br);border-radius:10px"/>
        <button id="sendDeal" class="btn">Send Proposal</button>
      </div>
    </div>
  </div>
</div>

<!-- Firebase + Game Script -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import {
    getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, runTransaction,
    collection, addDoc, serverTimestamp
  } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

  // ---------- CONFIG ----------
  const firebaseConfig = {
    apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
    authDomain: "bible-game-246c0.firebaseapp.com",
    projectId: "bible-game-246c0",
    storageBucket: "bible-game-246c0.appspot.com",
    messagingSenderId: "959619818996",
    appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // ---------- PARAMS ----------
  const params = new URLSearchParams(location.search);
  const gameId = params.get("gameId");
  const username = params.get("username");
  if (!gameId || !username) { alert("Missing gameId or username. Launch from the lobby."); }

  // ---------- DOCS ----------
  const lobbyRef = doc(db, "lobbies", gameId);
  const stateRef = doc(db, "lobbies", gameId, "crown", "state");
  const chatRef  = collection(db, "lobbies", gameId, "crown_chat");

  // ---------- CONSTANTS / TUNABLES ----------
  const GRID_W = 22;           // width in tiles (big enough to need panning)
  const GRID_H = 16;           // height in tiles
  const TILE  = 52;            // px tile spacing (size + gutters)
  const MAX_UNITS = 6;         // cap per tile
  const ROUND_SECONDS = 25;    // timer per planning phase
  const CAPTURE_BONUS = 1;     // +1 on newly captured tiles
  const ATTRITION_MIN_STACK = 5;
  const ATTRITION_ENEMY_NEI = 2;
  const LEADER_SHARE_FOR_LEVY = 0.40; // >40% land -> others get Levy +1 attack

  const PLAYER_COLORS = ["#ef4444","#3b82f6","#10b981","#f59e0b"];
  let players = [];
  let isHost = false;

  // runtime
  let state = null;
  let myOrdersLocal = [];       // local staging until submit
  let selectedFrom = null;      // tile id
  let selectedTo   = null;      // tile id (neighbor)
  let pan = {x:0, y:0};
  let panning = false, lastPt = null;

  const $ = id => document.getElementById(id);
  function setStatus(t){ $("statusBadge").textContent = t; }

  // ---------- UI: Fullscreen ----------
  $("fitBtn").onclick = async () => {
    try{
      if (!document.fullscreenElement) { await document.documentElement.requestFullscreen(); }
      else { await document.exitFullscreen(); }
    }catch(e){}
  };

  // ---------- INIT BOARD DOM ----------
  const mapCanvas = $("mapCanvas");
  const mapWindow = $("mapWindow");
  function buildBoardDOM(){
    mapCanvas.style.width = (GRID_W * TILE) + "px";
    mapCanvas.style.height = (GRID_H * TILE) + "px";
    mapCanvas.innerHTML = "";

    for(let r=0;r<GRID_H;r++){
      for(let c=0;c<GRID_W;c++){
        const id = r*GRID_W+c;
        const d = document.createElement("div");
        d.className = "tile";
        d.style.left = (c*TILE+2) + "px";
        d.style.top  = (r*TILE+2) + "px";
        d.dataset.id = id;
        const u = document.createElement("div");
        u.className = "u"; u.textContent = "1";
        d.appendChild(u);
        d.addEventListener("click", ()=> onTileTap(id));
        mapCanvas.appendChild(d);
      }
    }
    centerMap();
  }
  buildBoardDOM();

  function centerMap(){
    const W = mapWindow.clientWidth, H = mapWindow.clientHeight;
    const fullW = GRID_W * TILE, fullH = GRID_H * TILE;
    pan.x = Math.max(0, (fullW - W)/2 * -1);
    pan.y = Math.max(0, (fullH - H)/2 * -1);
    applyPan();
  }
  $("centerBtn").onclick = centerMap;
  $("clearSelBtn").onclick = ()=>{ selectedFrom=null; selectedTo=null; highlightSelection(); };

  function applyPan(){ mapCanvas.style.transform = `translate(${pan.x}px, ${pan.y}px)`; }

  // touch / mouse pan
  mapWindow.addEventListener("pointerdown", (e)=>{ panning=true; lastPt={x:e.clientX,y:e.clientY}; mapWindow.setPointerCapture(e.pointerId); });
  mapWindow.addEventListener("pointermove", (e)=>{
    if (!panning) return;
    const dx = e.clientX - lastPt.x, dy = e.clientY - lastPt.y;
    lastPt = {x:e.clientX,y:e.clientY};
    pan.x += dx; pan.y += dy; applyPan();
  });
  mapWindow.addEventListener("pointerup", ()=> panning=false);
  mapWindow.addEventListener("pointercancel", ()=> panning=false);

  // ---------- STATE HELPERS ----------
  function colorIndex(name){ const idx = players.slice().sort().indexOf(name); return Math.max(0, idx) % 4; }

  function neighborsOf(id){
    const r = Math.floor(id/GRID_W), c = id%GRID_W;
    const N = [];
    if (r>0) N.push(id-GRID_W);
    if (r<GRID_H-1) N.push(id+GRID_W);
    if (c>0) N.push(id-1);
    if (c<GRID_W-1) N.push(id+1);
    return N;
  }

  function tileEl(id){ return mapCanvas.querySelector(`.tile[data-id="${id}"]`); }

  // ---------- FIRESTORE BOOTSTRAP ----------
  onSnapshot(lobbyRef, (snap)=>{
    const d = snap.data(); if (!d) return;
    players = (d.players||[]).slice(0,4);
    isHost = (d.host === username);
    renderScorebar();
  });

  onSnapshot(stateRef, (snap)=>{
    if (!snap.exists()){
      if (isHost) bootstrapState();
      return;
    }
    state = snap.data();
    renderAll();
    // auto step to resolve if host timer ticks out happens in hostTick()
    if (isHost) hostEnsureTimer();
  });

  async function bootstrapState(){
    const lob = await getDoc(lobbyRef);
    const lp = (lob.exists() && Array.isArray(lob.data().players)) ? lob.data().players.slice(0,4) : [username];

    // Seed territories: assign each player a cluster; others neutral
    const T = GRID_W*GRID_H;
    const territories = Array.from({length:T}, (_,id)=>({
      id, owner: null, units: 1, neighbors: neighborsOf(id)
    }));

    // four starting corners-ish
    const seeds = [
      1*GRID_W + 1,
      1*GRID_W + (GRID_W-2),
      (GRID_H-2)*GRID_W + 1,
      (GRID_H-2)*GRID_W + (GRID_W-2)
    ];
    lp.forEach((name, i)=>{
      const s = seeds[i] ?? (Math.floor(Math.random()*T));
      territories[s].owner = name;
      territories[s].units = 3;
      // also paint 2 neighbors lightly
      for (const nb of territories[s].neighbors.slice(0,2)){
        if (!territories[nb].owner){ territories[nb].owner = name; territories[nb].units = 2; }
      }
    });

    const init = {
      phase: "plan",
      round: 0,
      players: lp,
      orders: {},             // { [player]: Order[] }
      territories,
      roundEndsAt: Date.now() + ROUND_SECONDS*1000,
      levyRound: false,       // set each round if leader >40%
      lastResolveAt: Date.now()
    };
    await setDoc(stateRef, init);
  }

  // ---------- RENDER ----------
  function renderAll(){
    if (!state) return;
    setStatus(state.phase==="plan" ? "Planning" : (state.phase==="reveal"?"Reveal":"Resolving"));
    $("roundBadge").textContent = `R${state.round}`;
    // timer
    if (state.phase==="plan" && state.roundEndsAt){
      const s = Math.max(0, Math.ceil((state.roundEndsAt - Date.now())/1000));
      $("timerBadge").textContent = `‚è±Ô∏è ${s}s`;
    } else $("timerBadge").textContent = "‚è±Ô∏è ‚Äî";

    renderBoard();
    renderScorebar();
    renderOrders();
    renderCoalition();
    $("levyBadge").style.display = state.levyRound ? "inline-flex" : "none";
  }

  function renderBoard(){
    const terrs = state.territories||[];
    for (const t of terrs){
      const el = tileEl(t.id); if (!el) continue;
      el.classList.remove("owned","sel","enemy");
      const u = el.querySelector(".u"); if (u) u.textContent = t.units;
      if (t.owner){
        el.classList.add("owned");
        el.style.borderColor = PLAYER_COLORS[colorIndex(t.owner)];
        el.style.background = "#ffffff";
      }else{
        el.style.borderColor = "#e5e7eb";
        el.style.background = "#f8fafc";
      }
    }
    highlightSelection();
  }

  function highlightSelection(){
    mapCanvas.querySelectorAll(".tile").forEach(el=> el.classList.remove("sel","enemy"));
    if (selectedFrom!=null){
      const a = tileEl(selectedFrom); if (a) a.classList.add("sel");
      if (selectedTo!=null){
        const b = tileEl(selectedTo); if (b) b.classList.add("sel");
      } else {
        // show enemies around
        for (const nb of neighborsOf(selectedFrom)){
          const tt = state.territories[nb];
          if (tt?.owner && tt.owner!==username){ const e=tileEl(nb); if(e) e.classList.add("enemy"); }
        }
      }
    }
  }

  function renderScorebar(){
    const bar = $("scorebar");
    const terrs = state?.territories || [];
    const counts = {};
    players.forEach(p=>counts[p]=0);
    for (const t of terrs){ if (t.owner) counts[t.owner]=(counts[t.owner]||0)+1; }

    bar.innerHTML = "";
    const names = players.slice().sort();
    for (const n of names){
      const pill = document.createElement("div"); pill.className="pill";
      const dot = document.createElement("span"); dot.className="dot"; dot.style.background = PLAYER_COLORS[colorIndex(n)];
      const nm = document.createElement("span"); nm.textContent = n;
      const sc = document.createElement("span"); sc.className="muted"; sc.textContent = `‚Äî ${counts[n]||0}`;
      pill.appendChild(dot); pill.appendChild(nm); pill.appendChild(sc);
      bar.appendChild(pill);
    }
  }

  function renderCoalition(){
    const terrs = state?.territories || [];
    const totalOwned = terrs.filter(t=>!!t.owner).length || 1;
    const tally = {};
    for (const t of terrs){ if (t.owner) tally[t.owner]=(tally[t.owner]||0)+1; }
    let leader = null, top = 0;
    for (const [k,v] of Object.entries(tally)){ if (v>top){ top=v; leader=k; } }
    const share = top/totalOwned;
    $("coalitionMeter").textContent =
      leader ? `Leader: ${leader} (${Math.round(share*100)}%), Coalition ${(share>LEADER_SHARE_FOR_LEVY)?"ACTIVE":"idle"}` : "Coalition: ‚Äî";
  }

  function renderOrders(){
    const box = $("ordersList"); box.innerHTML = "";
    (myOrdersLocal||[]).forEach((o,i)=>{
      const row = document.createElement("div"); row.className="order";
      const txt = document.createElement("div");
      txt.innerHTML = `<strong>${o.type.toUpperCase()}</strong> <small>${o.from!=null?`from ${labelOf(o.from)} `:""}${o.to!=null?`‚Üí ${labelOf(o.to)}`:""}</small>`;
      const del = document.createElement("button"); del.className="del"; del.textContent="‚úñ";
      del.onclick = ()=>{ myOrdersLocal.splice(i,1); renderOrders(); };
      row.appendChild(txt); row.appendChild(del);
      box.appendChild(row);
    });
  }

  function labelOf(id){
    const r = Math.floor(id/GRID_W), c = id%GRID_W;
    return String.fromCharCode(65+r) + (c+1);
  }

  // ---------- INPUT: ORDER BUTTONS ----------
  $("attackBtn").onclick = ()=>{
    if (selectedFrom==null || selectedTo==null) return alert("Select a source you own and a neighboring target.");
    const a = state.territories[selectedFrom];
    const b = state.territories[selectedTo];
    if (!a || a.owner!==username) return alert("You must attack from your tile.");
    if (!neighborsOf(selectedFrom).includes(selectedTo)) return alert("Target must be adjacent.");
    if (a.units<=1) return alert("Need >1 unit to attack (leaves 1 behind).");
    myOrdersLocal.push({type:"attack", from:selectedFrom, to:selectedTo});
    renderOrders();
  };
  $("fortifyBtn").onclick = ()=>{
    if (selectedFrom==null) return alert("Select one of your tiles.");
    const a = state.territories[selectedFrom];
    if (!a || a.owner!==username) return alert("You can only fortify your tile.");
    myOrdersLocal.push({type:"fortify", from:selectedFrom});
    renderOrders();
  };
  $("recruitBtn").onclick = ()=>{
    if (selectedFrom==null) return alert("Select one of your tiles.");
    const a = state.territories[selectedFrom];
    if (!a || a.owner!==username) return alert("You can only recruit on your tile.");
    myOrdersLocal.push({type:"recruit", from:selectedFrom});
    renderOrders();
  };
  $("holdBtn").onclick = ()=>{
    myOrdersLocal.push({type:"hold"});
    renderOrders();
  };
  $("submitBtn").onclick = submitMyOrders;

  async function submitMyOrders(){
    if (!state || state.phase!=="plan") return;
    await runTransaction(db, async (tx)=>{
      const s = await tx.get(stateRef);
      if (!s.exists()) throw new Error("no state");
      const d = s.data();
      const os = Object.assign({}, d.orders||{});
      os[username] = (myOrdersLocal||[]).slice(0,12); // soft cap
      tx.update(stateRef, { orders: os });
    });
    // keep local (so you can see), or clear if you prefer:
    // myOrdersLocal = []; renderOrders();
  }

  // tile tap -> pick from / to
  function onTileTap(id){
    const t = state?.territories?.[id]; if (!t) return;
    if (selectedFrom==null){
      selectedFrom = id; selectedTo=null;
    } else if (selectedFrom===id){
      selectedFrom=null; selectedTo=null;
    } else {
      if (neighborsOf(selectedFrom).includes(id)) selectedTo=id; else selectedFrom=id, selectedTo=null;
    }
    highlightSelection();
  }

  // ---------- DIPLOMACY ----------
  $("dealBtn").onclick = ()=> openDealModal();
  $("closeDeal").onclick = ()=> $("dealModalBack").style.display="none";
  $("sendDeal").onclick = sendDeal;
  $("chatSend").onclick = sendChat;
  $("chatInput").addEventListener("keydown", (e)=>{ if (e.key==="Enter") sendChat(); });

  function openDealModal(){
    const sel = $("dealTo"); sel.innerHTML = `<option value="">‚Äî Choose player ‚Äî</option>`;
    players.filter(p=>p!==username).forEach(p=>{
      const opt = document.createElement("option"); opt.value=p; opt.textContent=p; sel.appendChild(opt);
    });
    $("dealNote").value = "";
    $("dealModalBack").style.display = "flex";
  }

  async function sendDeal(){
    const to = $("dealTo").value; if (!to) return;
    const type = $("dealType").value; const note = $("dealNote").value.trim();
    await addDoc(chatRef, { user: username, kind:"deal", to, type, note, at: serverTimestamp() });
    $("dealModalBack").style.display = "none";
  }
  async function sendChat(){
    const v = $("chatInput").value.trim(); if (!v) return;
    await addDoc(chatRef, { user: username, kind:"chat", msg:v, at: serverTimestamp() });
    $("chatInput").value = "";
  }

  onSnapshot(chatRef, (snap)=>{
    const box = $("chatBox");
    box.innerHTML = "";
    snap.docs.sort((a,b)=> (a.data().at?.seconds||0) - (b.data().at?.seconds||0)).forEach(d=>{
      const m = d.data();
      const row = document.createElement("div");
      if (m.kind==="deal"){
        row.innerHTML = `<strong>ü§ù ${m.user}</strong> ‚Üí <em>${m.to}</em>: <span class="muted">${m.type}</span> ‚Äî ${m.note||""}`;
      } else {
        row.innerHTML = `<strong>${m.user}:</strong> ${m.msg}`;
      }
      box.appendChild(row);
    });
    box.scrollTop = box.scrollHeight;
  });

  // ---------- HOST: TIMER & RESOLUTION ----------
  let _tickTimer = null;
  function hostEnsureTimer(){
    if (!isHost) return;
    clearInterval(_tickTimer);
    _tickTimer = setInterval(checkTick, 300);
  }
  async function checkTick(){
    const s = await getDoc(stateRef); if (!s.exists()) return;
    const d = s.data();
    if (d.phase!=="plan") return;
    const msLeft = (d.roundEndsAt||0) - Date.now();
    if (msLeft <= 0){
      clearInterval(_tickTimer);
      await autoHoldAndResolve(d);
    }
  }

  async function autoHoldAndResolve(cur){
    // fill HOLDs for empty players
    const os = Object.assign({}, cur.orders||{});
    for (const p of (cur.players||[])){
      if (!os[p] || os[p].length===0) os[p] = [{type:"hold"}];
    }
    await updateDoc(stateRef, { orders: os });
    await resolveRound();
  }

  async function resolveRound(){
    let d = (await getDoc(stateRef)).data();
    if (!d || d.phase!=="plan") return;

    // Step 1: mark levy round
    const lev = computeLevy(d);
    d.levyRound = lev.active;

    // Step 2: REVEAL (briefly)
    await updateDoc(stateRef, { phase: "reveal", levyRound: d.levyRound });
    // optional tiny pause for animation
    await new Promise(r=>setTimeout(r, 250));

    // Step 3: RESOLVE
    d = (await getDoc(stateRef)).data();
    if (!d) return;
    const terrs = d.territories;
    const orders = d.orders||{};

    // Collate attacks by edge (from->to); resolve all after collecting
    const capturedThisRound = new Set();

    // Apply non-combat first: fortify/recruit (cap)
    for (const [p, list] of Object.entries(orders)){
      for (const o of (list||[])){
        if (o.type==="fortify" && validOwnTile(terrs,o.from,p)){
          terrs[o.from].units = Math.min(MAX_UNITS, terrs[o.from].units + 1);
        }
        if (o.type==="recruit" && validOwnTile(terrs,o.from,p)){
          terrs[o.from].units = Math.min(MAX_UNITS, terrs[o.from].units + 1);
        }
      }
    }

    // Build attack bundles (could be multi-attack on same target)
    const edges = {};
    function key(f,t){ return f+"-"+t; }
    for (const [p, list] of Object.entries(orders)){
      for (const o of (list||[])){
        if (o.type!=="attack") continue;
        if (!validOwnTile(terrs,o.from,p)) continue;
        if (!neighborsOf(o.from).includes(o.to)) continue;
        if (terrs[o.from].units<=1) continue;
        const k = key(o.from,o.to);
        (edges[k]||(edges[k]=[])).push({player:p, from:o.from, to:o.to});
      }
    }

    // Execute each attack edge
    for (const [k, list] of Object.entries(edges)){
      const {from,to} = list[0];
      const src = terrs[from], dst = terrs[to];
      const leaving = 1; // must leave at least 1 behind
      const attackUnitsByPlayer = {};

      // multiple orders from same or diff players all push from same 'from'? (rare)
      // We'll collapse to a single push from the tile owner at resolve time:
      const ownerAtLaunch = src.owner;
      if (!ownerAtLaunch) continue;
      if (src.units<=1) continue;

      // Attacker sends all but 1
      let send = Math.max(0, src.units - leaving);

      // Levy applies if active and attacker is NOT the leader
      const levyBonus = (d.levyRound && ownerAtLaunch!==levyLeader(d)) ? 1 : 0;

      // defender info
      const defOwner = dst.owner;
      const defBase  = dst.units;
      if (send<=0) continue;

      // Simple Risk-lite odds: jittered comparison
      const atkPower = (send + levyBonus) * (0.9 + Math.random()*0.3);
      const defPower = defBase * (0.9 + Math.random()*0.3);

      if (atkPower > defPower){
        // attacker wins: move survivors
        const survivors = Math.max(1, Math.min(MAX_UNITS, Math.round(send * 0.6)));
        src.units = leaving;
        dst.owner = ownerAtLaunch;
        dst.units = survivors;
        capturedThisRound.add(to);
      } else {
        // defender holds: attacker loses most of what he sent
        const loss = Math.max(1, Math.round(send * 0.7));
        src.units = Math.max(leaving, src.units - loss);
        // defender loses some too
        dst.units = Math.max(1, Math.round(defBase * 0.6));
      }
    }

    // Capture bonus
    for (const tid of capturedThisRound){
      terrs[tid].units = Math.min(MAX_UNITS, terrs[tid].units + CAPTURE_BONUS);
    }

    // Frontline attrition (‚â•5 units & ‚â•2 hostile neighbors)
    for (const t of terrs){
      if (!t.owner) continue;
      if (t.units < ATTRITION_MIN_STACK) continue;
      const hostile = t.neighbors.map(id=>terrs[id]).filter(n=>n && n.owner && n.owner!==t.owner).length;
      if (hostile >= ATTRITION_ENEMY_NEI){
        t.units = Math.max(1, t.units - 1);
      }
    }

    // Clear orders, advance round & timer
    const next = {
      phase: "plan",
      round: (d.round||0)+1,
      territories: terrs,
      orders: {},
      roundEndsAt: Date.now() + ROUND_SECONDS*1000,
      levyRound: false,
      lastResolveAt: Date.now()
    };
    await updateDoc(stateRef, next);
  }

  function validOwnTile(terrs, id, p){ const t=terrs[id]; return !!t && t.owner===p; }

  function computeLevy(d){
    const terrs = d.territories||[];
    const totalOwned = terrs.filter(t=>!!t.owner).length || 1;
    const tally = {};
    for (const t of terrs){ if (t.owner) tally[t.owner]=(tally[t.owner]||0)+1; }
    let leader=null, top=0;
    for (const [k,v] of Object.entries(tally)){ if (v>top){top=v; leader=k;} }
    const share = top/totalOwned;
    return { active: share>LEADER_SHARE_FOR_LEVY, leader, share };
  }
  function levyLeader(d){ return computeLevy(d).leader; }

  // ---------- UTIL ----------
  // nothing ‚Äì inline above

</script>
</body>
</html>
