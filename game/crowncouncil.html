<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>‚öîÔ∏è Draft Brawl ‚Äî Factions (2P)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<style>
  :root{
    --bg:#ffffff; --ink:#0f172a; --muted:#64748b; --line:#e5e7eb;
    --panel:#ffffff; --shadow:0 10px 30px rgba(2,6,23,.08);
    --rad:16px; --rad-sm:12px;

    --cell:40px; --gap:4px;
    --l1:#dcfce7; --l2:#dbeafe; --l3:#fee2e2;
    --p0:#b91c1c; --p1:#1d4ed8;
    --poison:#fde2e2; /* red-tinted */
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}

  .topbar{
    position:sticky; top:0; z-index:30;
    background:#fff; border-bottom:1px solid var(--line);
    padding:8px 10px; display:flex; align-items:center; justify-content:space-between; gap:10px;
  }
  .row{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
  .badge{display:inline-flex;gap:8px;align-items:center;padding:8px 12px;border:1px solid var(--line);border-radius:999px;background:#fff;box-shadow:var(--shadow);font-weight:800}
  .btn{appearance:none;border:1px solid var(--line);border-radius:12px;padding:10px 12px;font-weight:800;cursor:pointer;background:#111827;color:#fff}
  .btn.ghost{background:#fff;color:var(--ink)}
  .btn:hover{filter:brightness(1.05)}

  .window{ padding:8px; }
  .viewport{
    position:relative; width:100%; height:calc(100dvh - 70px);
    border:1px solid var(--line); border-radius:14px; overflow:hidden; background:#fff;
    cursor:grab; user-select:none; touch-action:none; /* smoother mobile drag */
  }
  .viewport:active{ cursor:grabbing; }
  .canvas{ position:absolute; left:0; top:0; transform:translate3d(0,0,0) }

  .board{ position:relative }
  .cells{position:relative;display:grid;grid-template-columns:repeat(var(--w),var(--cell));grid-auto-rows:var(--cell);gap:var(--gap)}
  .cell{
    width:var(--cell);height:var(--cell);
    border:1px solid #e2e8f0;border-radius:10px;background:#f8fafc;
    position:relative;overflow:hidden;
  }
  .lvl{position:absolute;inset:0;border-radius:8px;opacity:.85;pointer-events:none}
  .cell.l1 .lvl{background:var(--l1)}
  .cell.l2 .lvl{background:var(--l2)}
  .cell.l3 .lvl{background:var(--l3)}

  .hitflash{ position:absolute; inset:0; background:rgba(255,255,255,.9); animation:flash .12s ease; pointer-events:none }
  @keyframes flash{ from{opacity:.9} to{opacity:0} }

  .dmg{
    position:absolute; left:50%; top:40%; transform:translate(-50%,-50%);
    font-weight:900; font-size:12px; color:#b91c1c; text-shadow:0 1px 0 rgba(0,0,0,.15);
    animation:dmg 600ms ease-out forwards; pointer-events:none;
  }
  @keyframes dmg{
    0%{opacity:0; transform:translate(-50%,-40%) scale(.9)}
    10%{opacity:1;}
    100%{opacity:0; transform:translate(-50%,-100%) scale(1)}
  }

  .unit{
    position:absolute; inset:0; display:grid; place-items:center;
    font-size:22px; z-index:2; pointer-events:none;
  }
  .tag{position:absolute;top:3px;left:4px;padding:1px 6px;border-radius:999px;background:#fff;border:1px solid var(--line);font-size:10px;font-weight:900;color:#475569;z-index:3}
  .hp{position:absolute;left:4px;right:4px;bottom:3px;height:5px;border-radius:4px;background:#e2e8f0;overflow:hidden;z-index:3}
  .hp>i{display:block;height:100%;background:linear-gradient(90deg,#22c55e,#16a34a)}
  .p0 .tag{color:var(--p0);border-color:#fecaca}
  .p1 .tag{color:var(--p1);border-color:#bfdbfe}

  .poison{ position:absolute; inset:0; background:var(--poison); opacity:.6; z-index:1 }

  /* overlay + draft cards */
  .overlay{position:absolute;inset:0;background:rgba(255,255,255,.55);display:none;z-index:40}
  .cardRow{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);display:flex;gap:10px;z-index:50;flex-wrap:wrap;justify-content:center}
  .card{width:min(240px,34vw);background:#fff;border:1px solid var(--line);border-radius:14px;box-shadow:var(--shadow);padding:12px 14px;cursor:pointer;display:grid;gap:6px;user-select:none}
  .card:hover{background:#f8fafc}
  .title{font-weight:900}
  .desc{color:var(--muted);font-size:.92rem}

  .pickNote{
    position:absolute;left:50%;top:12%;transform:translateX(-50%);
    z-index:60;background:#fff;border:1px solid var(--line);border-radius:999px;box-shadow:var(--shadow);
    padding:8px 14px;font-weight:900;display:none;
  }

  .toast{position:fixed;left:50%;bottom:18px;transform:translateX(-50%);padding:10px 14px;background:#fff;border:1px solid var(--line);border-radius:12px;box-shadow:var(--shadow);font-weight:800;z-index:200;display:none}

  /* beam layer */
  .beams{ position:absolute; left:0; top:0; width:1px; height:1px; transform:translate3d(0,0,0); pointer-events:none; }
  .beam{
    position:absolute; height:3px; border-radius:3px; background:linear-gradient(90deg,rgba(59,130,246,.9),rgba(239,68,68,.9));
    opacity:.9; transform-origin:0 50%; animation:beamfade .35s ease-out forwards;
  }
  @keyframes beamfade{ to{ opacity:0 } }
</style>
</head>
<body>
  <div class="topbar">
    <div class="row">
      <span class="badge">‚öîÔ∏è Draft Brawl ‚Äî Factions</span>
      <span id="phaseBadge" class="badge">‚Äî</span>
    </div>
    <div class="row">
      <span id="p0Badge" class="badge">P0 ‚Äî ‚ù§‚ù§‚ù§‚ù§</span>
      <span id="p1Badge" class="badge">P1 ‚Äî ‚ù§‚ù§‚ù§‚ù§</span>
      <span id="timerBadge" class="badge">‚è≥ ‚Äî</span>
      <button id="fsBtn" class="btn ghost">‚õ∂ Fullscreen</button>
    </div>
  </div>

  <div class="window">
    <div id="viewport" class="viewport" aria-label="Game board">
      <div id="canvas" class="canvas">
        <div class="board">
          <div id="cells" class="cells" style="--w:8; --cell:40px; --gap:4px"></div>
        </div>
        <div id="beams" class="beams"></div>
      </div>
      <div id="overlay" class="overlay"></div>
      <div id="cardRow" class="cardRow" style="display:none"></div>
      <div id="pickNote" class="pickNote"></div>
    </div>
  </div>

  <div id="toast" class="toast"></div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, runTransaction } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

/* ------------ Pace (slower again) ------------ */
const PACE = {
  tickMs: 560,       // slower tick
  atkMult: 2.25,     // longer cooldowns
  moveSteps: 1,
  poisonDotMs: 850,
  poisonSlowMs: 1000,
};

/* ------------ Firebase ------------ */
const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);

/* ------------ URL params ------------ */
const params   = new URLSearchParams(location.search);
const gameId   = params.get("gameId");
const username = params.get("username");
if (!gameId || !username){ alert("Missing gameId or username."); }

const lobbyRef = doc(db,"lobbies",gameId);
const stateRef = doc(db,"lobbies",gameId,"crowncouncil","state");

/* ------------ DOM helpers ------------ */
const $ = (id)=>document.getElementById(id);
const toast = (t)=>{ const x=$("toast"); x.textContent=t; x.style.display="block"; clearTimeout(window.__t); window.__t=setTimeout(()=>x.style.display="none",1500); };
const pKey = (i)=> i===0 ? "p0" : "p1";

/* ------------ Viewport pan w/ inertia ------------ */
const viewport = $("viewport"), canvas = $("canvas");
let pan={x:12,y:12}, dragging=false, last={x:0,y:0}, lastTime=0, v={x:0,y:0}, anim=null;
function applyPan(){ canvas.style.transform=`translate(${pan.x}px,${pan.y}px)`; }

function onDown(e){ dragging=true; last={x:e.clientX,y:e.clientY}; lastTime=performance.now(); v.x=v.y=0; if(anim){cancelAnimationFrame(anim); anim=null;} }
function onMove(e){
  if(!dragging) return;
  const t=performance.now();
  const dx=e.clientX-last.x, dy=e.clientY-last.y;
  const dt=Math.max(1, t-lastTime);
  pan.x+=dx; pan.y+=dy; applyPan();
  v.x=dx/dt*16; v.y=dy/dt*16; // px/frame-ish
  last={x:e.clientX,y:e.clientY}; lastTime=t;
}
function onUp(){ dragging=false; inertia(); }
function inertia(){
  const friction=0.92;
  function step(){
    v.x*=friction; v.y*=friction;
    pan.x+=v.x; pan.y+=v.y; applyPan();
    if (Math.hypot(v.x,v.y) > 0.4) anim=requestAnimationFrame(step);
    else anim=null;
  }
  step();
}
viewport.addEventListener("pointerdown", onDown, {passive:true});
viewport.addEventListener("pointermove", onMove, {passive:true});
viewport.addEventListener("pointerup", onUp, {passive:true});
viewport.addEventListener("pointercancel", onUp, {passive:true});
applyPan();

/* ------------ Beam visuals ------------ */
const beamsEl = $("beams");
const CELL=40, GAP=4;
const H=28, W=8; // <-- NEW: 8x28
function centerPx(x,y){
  const left = x*(CELL+GAP) + CELL/2;
  const top  = y*(CELL+GAP) + CELL/2;
  return {left, top};
}
function drawBeam(x1,y1,x2,y2){
  const a = centerPx(x1,y1), b=centerPx(x2,y2);
  const dx=b.left-a.left, dy=b.top-a.top;
  const len=Math.hypot(dx,dy);
  const ang=Math.atan2(dy,dx);
  const el=document.createElement("div");
  el.className="beam";
  el.style.left = a.left + "px";
  el.style.top  = a.top  + "px";
  el.style.width = Math.max(1,len) + "px";
  el.style.transform = `rotate(${ang}rad)`;
  beamsEl.appendChild(el);
  setTimeout(()=>el.remove(), 350);
}

/* ------------ Board ------------ */
const cellsEl=$("cells");
function buildBoard(){
  cellsEl.style.setProperty("--w", W);
  cellsEl.innerHTML="";
  for (let y=0;y<H;y++){
    for (let x=0;x<W;x++){
      const d=document.createElement("div");
      d.className="cell";
      d.dataset.x=x; d.dataset.y=y;
      d.innerHTML=`
        <div class="lvl"></div>
        <div class="unit"></div>
        <div class="tag"></div>
        <div class="hp"><i style="width:0%"></i></div>`;
      cellsEl.appendChild(d);
    }
  }
}
buildBoard();
const idx=(x,y)=> y*W+x;
const xy =(i)=> ({x:i%W,y:Math.floor(i/W)});
const inside=(x,y)=> x>=0 && x<W && y>=0 && y<H;

/* ------------ Unit templates ------------ */
const R = (hp,dmg,range,cd)=>({hp,dmg,range,cd});
const M = (hp,dmg,cd)=>({hp,dmg,range:1,cd});

/* Troops (balance changes applied) */
const TROOPS = {
  /* Vanir */
  rifleman: { faction:"Vanir", name:"Riflemen", emoji:"üî´", role:"back",  base:{...R(7,4,4,1200)}, spawn:2 },
  vrocket:  { faction:"Vanir", name:"Rockets",   emoji:"üöÄ", role:"back",  base:{...R(8,4,10,2000), splash1:true, knock:true} },
  vguard:   { faction:"Vanir", name:"Vanir Guard", emoji:"üõ°Ô∏è", role:"front", base:{...M(18,3,800)}, splash1:true },
  miner:    { faction:"Vanir", name:"Miners",    emoji:"‚õèÔ∏è", role:"front", base:{...M(16,2,800), spd:2, hunterRanged:true}, spawn:2 },

  /* Aesir (Phaser HP lowered) */
  phaser:   { faction:"Aesir", name:"Phasers",   emoji:"‚ú®", role:"back",  base:{...R(6,3,4,900), blink50:true}, spawn:2 },
  blade:    { faction:"Aesir", name:"Blademasters", emoji:"‚öîÔ∏è", role:"front", base:{...M(12,6,700), spd:2}, spawn:2 },
  storm:    { faction:"Aesir", name:"Storm Seer", emoji:"üå©Ô∏è", role:"back",  base:{...R(7,3,3,1100), chain3:true} },
  guardian: { faction:"Aesir", name:"Guardian",  emoji:"üõ°Ô∏è", role:"front", base:{...M(22,4,900), splash1:true, knock:true} },

  /* Helions (Defiler HP raised; BloodBurst explodes on contact & death) */
  hellspawn:{ faction:"Helions", name:"Hell Spawn", emoji:"üî•", role:"front", base:{...M(6,2,600), spd:3}, spawn:3 },
  roach:    { faction:"Helions", name:"Roaches",  emoji:"üêû", role:"back",  base:{...R(10,3,3,1300)}, spawn:2 },
  defiler:  { faction:"Helions", name:"Defiler",  emoji:"üßü", role:"front", base:{...M(26,4,900), splash1:true} }, /* 20 -> 26 */
  blood:    { faction:"Helions", name:"BloodBurst", emoji:"ü©∏", role:"front", base:{...M(9,3,0), kamikaze:true, paints:true}, spawn:2 }
};

const FACTIONS = {
  Vanir:  ["rifleman","vrocket","vguard","miner"],
  Aesir:  ["phaser","blade","storm","guardian"],
  Helions:["hellspawn","roach","defiler","blood"]
};
const ALL_FACTIONS = ["Helions","Aesir","Vanir"];
const FACTION_EMOJI = { Helions:"üî•", Aesir:"‚ö°", Vanir:"üßä" };

const levelMult=(l)=> [1,1,1.5,2][l] || 1;
const levelClass=(l)=> l>=3?"l3":(l>=2?"l2":"l1");

/* ------------ State ------------ */
let S=null;
let meIndex=0;
let lobbyPlayers = [];
let isHost = false;

/* ------------ Roster helpers ------------ */
function rosterAdd(roster, type, inc=1){
  const f=roster.find(r=>r.type===type);
  if (f) f.count+=inc; else roster.push({type, lvl:1, count:inc});
}
function rosterDoubleOneSpecific(roster, type){
  const f=roster.find(r=>r.type===type);
  if (!f) return;
  f.count += Math.max(1,f.count);
}
function rosterUpgradeOneSpecific(roster, type){
  const f=roster.find(r=>r.type===type && r.lvl<3);
  if (!f) return;
  f.lvl++;
}

/* ------------ Spawn bands / formation ------------ */
function bandRows(p, role){
  if (p===0){
    return role==="back" ? [0,1,2] : [4,5,6,7];
  }else{
    return role==="back" ? [27,26,25] : [23,22,21,20];
  }
}
function rowSlot(state,row){
  const cx=Math.floor(W/2), order=[0,-1,1,-2,2,-3,3,-4,4];
  for(const dx of order){
    const x=Math.max(0,Math.min(W-1,cx+dx));
    if (!state.field.units.some(o=>o.x===x && o.y===row)) return {x,y:row};
  }
  return null;
}
function spawnSlot(state,p,typeKey){
  const role = TROOPS[typeKey]?.role || "front";
  const rows = bandRows(p, role);
  for(const r of rows){
    const pos=rowSlot(state,r); if (pos) return pos;
  }
  // fallback: scan half
  const y0 = (p===0? 0 : Math.max(0, H-14));
  const y1 = (p===0? 13 : H-1);
  for(let y=y0;y<=y1;y++){ for(let x=0;x<W;x++){
    if (!state.field.units.some(o=>o.x===x && o.y===y)) return {x,y};
  }}
  return {x:Math.floor(W/2), y:(p===0?1:H-2)};
}
function placeUnit(state,p,key,lvl){
  const t=TROOPS[key]; if(!t) return;
  const spawnCount = Math.max(1, t.spawn||1);
  for(let k=0;k<spawnCount;k++){
    const pos=spawnSlot(state,p,key);
    const b=t.base;
    const u={
      id:crypto.randomUUID(), p, type:key, emoji:t.emoji, role:t.role, faction:t.faction,
      lvl, x:pos.x, y:pos.y,
      maxhp:Math.round((b.hp||10)*levelMult(lvl)), hp:Math.round((b.hp||10)*levelMult(lvl)),
      dmg:Math.round((b.dmg||3)*levelMult(lvl)),
      spd: b.spd ?? 1, range:b.range ?? 1, cd: Math.round((b.cd ?? 600)*PACE.atkMult),
      splash1:!!b.splash1, knock:!!b.knock, hunterRanged:!!b.hunterRanged,
      blink50:!!b.blink50, blinked:false,
      chain3:!!b.chain3,
      kamikaze:!!b.kamikaze, paints:!!b.paints, fuse:0,
      nextAtk:0, slowUntil:0
    };
    state.field.units.push(u);
  }
}
function rebuildFieldFromRoster(state){
  state.field={units:[], poison:[]};
  for(let p=0;p<2;p++){
    const rk = pKey(p);
    const roster = (state.roster?.[rk]||[]);
    const fronts = roster.filter(r=>TROOPS[r.type]?.role==="front");
    const backs  = roster.filter(r=>TROOPS[r.type]?.role!=="front");
    for(const r of fronts){ for(let c=0;c<r.count;c++) placeUnit(state,p,r.type,r.lvl); }
    for(const r of backs ){ for(let c=0;c<r.count;c++) placeUnit(state,p,r.type,r.lvl); }
  }
}

/* ------------ Packs (reduced special odds) ------------ */
function ownedTypes(roster){ return (roster||[]).filter(r=>r.count>0).map(r=>r.type); }
function uniqueSample(arr, n){
  const bag=[...arr]; const out=[];
  while(out.length<n && bag.length){
    const j=Math.floor(Math.random()*bag.length);
    out.push(bag.splice(j,1)[0]);
  }
  return out;
}

function buildSpecialChoicesReduced(roster){
  const types = ownedTypes(roster);
  if (!types.length) return [];
  const picks=[];
  // ~35% chance to see an Upgrade
  if (Math.random()<0.35){
    const up = types[Math.floor(Math.random()*types.length)];
    picks.push({type:"special", special:"upgrade", for:up, name:`Upgrade ${TROOPS[up].name}`, emoji:"‚¨ÜÔ∏è"});
  }
  // ~25% chance to see a Double
  if (Math.random()<0.25){
    const db = types[Math.floor(Math.random()*types.length)];
    picks.push({type:"special", special:"double", for:db, name:`Double ${TROOPS[db].name}`, emoji:"üÉè"});
  }
  return picks;
}

function filterPackForPlayer(roster, faction){
  const poolTypes = FACTIONS[faction] || [];
  const troopCards = poolTypes.map(k=>({type:"troop", key:k, name:TROOPS[k].name, emoji:TROOPS[k].emoji, role:TROOPS[k].role}));
  const specials = buildSpecialChoicesReduced(roster);
  const pool = [...troopCards, ...specials];

  const out=[];
  while(out.length<3 && pool.length){
    const pick = pool.splice(Math.floor(Math.random()*pool.length),1)[0];
    if (pick.type==="troop"){
      if (!out.some(o=>o.type==="troop" && o.key===pick.key)) out.push(pick);
    }else{
      if (!out.some(o=>o.type==="special" && o.special===pick.special && o.for===pick.for)) out.push(pick);
    }
  }
  // pad with random troops if needed
  while(out.length<3 && troopCards.length){
    const t = troopCards[Math.floor(Math.random()*troopCards.length)];
    if (!out.some(o=>o.type==="troop" && o.key===t.key)) out.push(t);
  }
  return out.slice(0,3);
}

/* ------------ Stains / Poison ------------ */
function paintPoison(state, cx, cy, durMs=7000){
  const until = Date.now()+durMs;
  state.field.poison = state.field.poison || [];
  for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){
    const x=cx+dx, y=cy+dy; if(!inside(x,y)) continue;
    state.field.poison.push({x,y,until});
  }
}

/* ------------ Render helpers ------------ */
function flashAt(x,y, dmgNum=0){
  const i=idx(x,y); const cell=cellsEl.children[i]; if (!cell) return;
  const f=document.createElement("div"); f.className="hitflash"; cell.appendChild(f);
  setTimeout(()=>f.remove(), 140);
  if (dmgNum>0){
    const t=document.createElement("div"); t.className="dmg"; t.textContent = `-${dmgNum}`;
    cell.appendChild(t); setTimeout(()=>t.remove(), 650);
  }
}
function paint(units, field){
  const map=new Map();
  for(const u of units){ map.set(idx(u.x,u.y), u); }
  const now=Date.now();
  for(let i=0;i<W*H;i++){
    const d=cellsEl.children[i];
    const u=map.get(i);
    d.className="cell";
    const {x,y} = xy(i);
    d.querySelector(".poison")?.remove();
    if ((field?.poison||[]).some(p=>p.x===x&&p.y===y&&p.until>now)){
      const t=document.createElement("div"); t.className="poison"; d.appendChild(t);
    }
    const lvl=d.querySelector(".lvl"), tag=d.querySelector(".tag"), hp=d.querySelector(".hp>i"), uni=d.querySelector(".unit");
    if(u){
      d.classList.add(levelClass(u.lvl), u.p===0?"p0":"p1");
      uni.textContent = u.emoji; tag.textContent = (S?.players?.[u.p]|| (u.p===0?"P0":"P1"));
      hp.style.width = Math.max(0,Math.round(100*u.hp/u.maxhp))+"%";
    }else{
      uni.textContent=""; tag.textContent=""; hp.style.width="0%";
    }
  }
}
function render(){
  const p0n = (S?.players?.[0]) || lobbyPlayers[0] || "P0";
  const p1n = (S?.players?.[1]) || lobbyPlayers[1] || "P1";
  const lives = S?.lives || [4,4];

  $("p0Badge").textContent = `${p0n} ‚Äî ${"‚ù§".repeat(lives[0])}`;
  $("p1Badge").textContent = `${p1n} ‚Äî ${"‚ù§".repeat(lives[1])}`;

  let phase = S?.phase || (lobbyPlayers.length<2 ? "waiting-for-players" : "bootstrapping");
  $("phaseBadge").textContent = phase.replaceAll("-"," ");
  const showDraft = ["faction-select","draft","loser-bonus","draft-after"].includes(phase);

  const tleft = showDraft ? Math.max(0,(S?.phaseEndsAt||0) - Date.now()) : 0;
  $("timerBadge").textContent = showDraft ? `‚è≥ ${Math.ceil(tleft/1000)}s` : (phase==="waiting-for-players" ? "‚è≥ waiting‚Ä¶" : "‚è≥ ‚Äî");

  if (showDraft){
    const ghost=structuredClone(S);
    rebuildFieldFromRoster(ghost);
    paint(ghost.field.units, ghost.field);
  }else{
    paint(S?.field?.units||[], S?.field);
  }

  const row=$("cardRow");
  const overlay=$("overlay");
  const note=$("pickNote");

  if (!showDraft){
    overlay.style.display = "none";
    row.style.display     = "none";
    note.style.display    = "none";
    row.innerHTML = "";
    return;
  }

  overlay.style.display = "block";

  const di = S?.draftIndex|0;
  const sk = pKey(meIndex);
  const pickedIndex = S?.selections?.[sk]?.[di];

  if (phase==="faction-select"){
    const alreadyFac = (S?.factions?.[sk] != null);
    if (alreadyFac){
      row.style.display="none"; row.innerHTML="";
      note.textContent = `Selected: ${S.factions[sk]}`;
      note.style.display="block";
      return;
    }
    row.style.display="flex"; row.innerHTML=""; note.style.display="none";
    ["Helions","Aesir","Vanir"].forEach((fac)=>{
      const el=document.createElement("div"); el.className="card";
      el.innerHTML=`<div class="title">${FACTION_EMOJI[fac]} ${fac}</div>
        <div class="desc">${FACTIONS[fac].map(k=>TROOPS[k].emoji+" "+TROOPS[k].name).join(" ¬∑ ")}</div>`;
      el.onclick=()=> chooseFaction(fac);
      row.appendChild(el);
    });
    return;
  }

  const pack = (S?.currentPacks?.[sk] || []);
  if (pickedIndex!=null){
    row.style.display="none"; row.innerHTML="";
    const picked = pack[pickedIndex];
    const label = picked
      ? (picked.type==="troop" ? picked.name : `${picked.special==="upgrade"?"Upgrade":"Double"} ${TROOPS[picked.for]?.name||""}`)
      : "(auto)";
    note.textContent = `Selected: ${label}`;
    note.style.display="block";
    return;
  }

  row.style.display="flex"; row.innerHTML=""; note.style.display="none";
  pack.forEach((c,i)=>{
    const el=document.createElement("div"); el.className="card";
    if (c.type==="troop"){
      el.innerHTML=`<div class="title">${c.emoji} ${c.name}</div><div class="desc">${c.role==="back"?"Backline":"Frontline"} ‚Äî ${TROOPS[c.key].faction}</div>`;
    }else{
      const nn = TROOPS[c.for]?.name || "Type";
      el.innerHTML=`<div class="title">${c.emoji} ${c.name|| (c.special==="upgrade"?"Upgrade":"Double")}</div><div class="desc">${c.special==="upgrade"?"Upgrade":"Double"} ${nn}</div>`;
    }
    el.onclick = ()=> chooseCard(i);
    row.appendChild(el);
  });
}

async function chooseFaction(fac){
  if(!S) return;
  const sk=pKey(meIndex);
  if (S.factions?.[sk]) return;
  await updateDoc(stateRef, { [`factions.${sk}`]: fac });
}
async function chooseCard(i){
  if(!S) return;
  const di=S.draftIndex|0;
  const sk=pKey(meIndex);
  const already = S.selections?.[sk]?.[di];
  if (already!=null) return;
  await updateDoc(stateRef, { [`selections.${sk}.${di}`]: i });
}

/* ------------ Targeting + movement ------------ */
function nearestEnemy(u,units){ let b=null,bd=1e9; for(const v of units){ if(v.p===u.p) continue; const d=Math.abs(v.x-u.x)+Math.abs(v.y-u.y); if(d<bd){bd=d;b=v;} } return b; }
function nearestEnemyRangedPriority(u,units){
  const ranged = units.filter(v=>v.p!==u.p && TROOPS[v.type]?.role==="back");
  if (ranged.length){
    let b=null,bd=1e9; for(const v of ranged){ const d=Math.abs(v.x-u.x)+Math.abs(v.y-u.y); if(d<bd){bd=d;b=v;} } return b;
  }
  return nearestEnemy(u,units);
}
function cellFree(units,x,y){ return inside(x,y) && !units.some(o=>o.x===x&&o.y===y); }
function tryKnock(cx,cy,t,units){ if(!t) return; const dx=Math.sign(t.x-cx), dy=Math.sign(t.y-cy); const nx=t.x+dx, ny=t.y+dy; if(cellFree(units,nx,ny)){ t.x=nx;t.y=ny; } }
function splash(units,x,y,dmg,srcP,kn=false){
  for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){
    if(!dx&&!dy) continue;
    const nx=x+dx,ny=y+dy; if(!inside(nx,ny)) continue;
    const hit=units.find(o=>o.p!==srcP&&o.x===nx&&o.y===ny);
    if(hit){ hit.hp-=dmg; flashAt(nx,ny,dmg); if(kn) tryKnock(x,y,hit,units); }
  }
}
function chainLightning(units, startTarget, srcP, hops=3, dmg=3){
  let cur = startTarget; let left=hops;
  const hitSet=new Set();
  while(cur && left>0){
    cur.hp -= dmg; flashAt(cur.x,cur.y,dmg); hitSet.add(cur.id);
    let cand=null,bd=1e9;
    for(const v of units){
      if(v.p===srcP || hitSet.has(v.id)) continue;
      const d=Math.abs(v.x-cur.x)+Math.abs(v.y-cur.y);
      if(d<=2 && d<bd){ bd=d; cand=v; }
    }
    cur=cand; left--;
  }
}
function stepToward(u,t,units){
  const dx=Math.sign(t.x-u.x), dy=Math.sign(t.y-u.y);
  const opts=[];
  if (Math.abs(t.y-u.y) >= Math.abs(t.x-u.x)) opts.push([u.x,u.y+Math.sign(t.y-u.y)],[u.x+dx,u.y]);
  else opts.push([u.x+dx,u.y],[u.x,u.y+Math.sign(t.y-u.y)]);
  opts.push([u.x+dx,u.y-dy],[u.x-dx,u.y+dy],[u.x-dx,u.y],[u.x,u.y-dy]);
  for(const [nx,ny] of opts){ if(cellFree(units,nx,ny)){ u.x=nx;u.y=ny;return; } }
}
function blinkIfNeeded(u){
  if (!u.blink50 || u.blinked) return;
  if (u.hp <= 0.5*u.maxhp){
    const dir = (u.p===0? -1 : +1);
    for(let i=0;i<3;i++){
      const nx=u.x, ny=u.y+dir;
      if (u.p===0 && ny<0) break;
      if (u.p===1 && ny>=H) break;
      if (cellFree(S.field.units,nx,ny)){ u.x=nx;u.y=ny; }
    }
    u.blinked=true;
  }
}

/* ------------ Battle utilities ------------ */
function applyPoisonSlowAndDot(field, units){
  const now=Date.now();
  (field.poison||[]).forEach(p=>{
    if (p.until<=now) return;
    for(const u of units){
      if (u.x===p.x && u.y===p.y){
        u.slowUntil = Math.max(u.slowUntil||0, now+PACE.poisonSlowMs);
        if (!u._poisonTick || now - u._poisonTick >= PACE.poisonDotMs){
          u._poisonTick = now;
          u.hp = u.hp - 1;
          flashAt(u.x,u.y,1);
        }
      }
    }
  });
}

function rangedBeamIfApplicable(u,t){
  // Consider anything with range>1 or special ranged behaviors
  const isRanged = (u.range||1)>1 || u.type==="vrocket" || u.type==="phaser" || u.type==="roach" || u.type==="rifleman" || u.chain3;
  if (!isRanged) return;
  drawBeam(u.x,u.y,t.x,t.y);
}

function attack(u,t,now,units,field){
  const manhattan = (Math.abs(u.x-t.x)+Math.abs(u.y-t.y));
  const inRange = manhattan <= (u.range||1);
  if(inRange){
    if (now >= (u.nextAtk||0)){
      if (u.kamikaze){
        // Contact explosion (also kills self)
        rangedBeamIfApplicable(u,t);
        t.hp -= u.dmg; flashAt(t.x,t.y,u.dmg);
        splash(units,u.x,u.y, Math.max(1,Math.floor(u.dmg*0.8)), u.p, true);
        if (u.paints) paintPoison(S, u.x, u.y, 7000);
        u.hp = 0;
      } else if (u.type==="vrocket"){
        rangedBeamIfApplicable(u,t);
        t.hp -= u.dmg; flashAt(t.x,t.y,u.dmg);
        splash(units,t.x,t.y, Math.max(1,Math.floor(u.dmg*0.6)), u.p, true);
      } else if (u.chain3){
        rangedBeamIfApplicable(u,t);
        chainLightning(units,t,u.p,3, u.dmg);
      } else {
        if ((u.range||1)>1) rangedBeamIfApplicable(u,t);
        t.hp -= u.dmg; flashAt(t.x,t.y,u.dmg);
        if (u.splash1) splash(units,t.x,t.y, Math.max(1,Math.floor(u.dmg*0.6)), u.p, !!u.knock);
      }
      u.nextAtk = now + (u.cd||600);
    }
    return true;
  }
  return false;
}

/* ------------ INIT ------------ */
async function ensureStateExists(){
  const lobSnap = await getDoc(lobbyRef);
  if (!lobSnap.exists()) return false;
  const lob = lobSnap.data();
  lobbyPlayers = (Array.isArray(lob.players)? lob.players : []).slice(0,2);
  isHost = lob.host === username;

  let created=false;
  await runTransaction(db, async (tx)=>{
    const st = await tx.get(stateRef);
    if (st.exists()) return;

    const now=Date.now();
    const baseDoc = {
      inited:true,
      players: lobbyPlayers,
      lives:[4,4],
      phase: lobbyPlayers.length<2 ? "waiting" : "faction-select",
      phaseEndsAt: lobbyPlayers.length<2 ? 0 : (now+20_000),
      roster:{ p0:[], p1:[] },
      factions:{ p0:null, p1:null },
      field:{ units:[], poison:[] },
      selections:{ p0:[], p1:[] },
      currentPacks:{ p0:[], p1:[] },
      draftIndex:0,
      winner:null
    };
    tx.set(stateRef, baseDoc);
    created=true;
  });
  return created;
}

async function syncPlayersIntoStateIfNeeded(){
  const stSnap = await getDoc(stateRef);
  if (!stSnap.exists()) return;
  const st = stSnap.data();
  const cur = Array.isArray(st.players) ? st.players : [];
  const want = lobbyPlayers.slice(0,2);
  if (want.length && (cur.length!==want.length || cur.some((n,i)=>n!==want[i]))){
    await updateDoc(stateRef, { players: want });
  }
}

/* ------------ Host loop ------------ */
let hostTick=null, battleTick=null;

function startHostLoops(){
  if(hostTick) return;
  hostTick=setInterval(async ()=>{
    const snap=await getDoc(stateRef); if(!snap.exists()) return;
    const d=snap.data();

    if (d.phase==="waiting" && lobbyPlayers.length>=2){
      await updateDoc(stateRef, {
        phase:"faction-select",
        phaseEndsAt: Date.now()+20_000
      });
      return;
    }

    const now=Date.now();

    if (d.phase==="faction-select" && now >= (d.phaseEndsAt||0)){
      const fx = {...(d.factions||{})};
      if (!fx.p0) fx.p0 = ALL_FACTIONS[Math.floor(Math.random()*ALL_FACTIONS.length)];
      if (!fx.p1) fx.p1 = ALL_FACTIONS[Math.floor(Math.random()*ALL_FACTIONS.length)];
      await updateDoc(stateRef,{
        factions:fx,
        phase:"draft",
        draftIndex:0,
        selections:{p0:[],p1:[]},
        currentPacks:{
          p0: filterPackForPlayer(d.roster?.p0||[], fx.p0),
          p1: filterPackForPlayer(d.roster?.p1||[], fx.p1)
        },
        phaseEndsAt: Date.now()+10_000
      });
      return;
    }

    const isDraftish=["draft","loser-bonus","draft-after"].includes(d.phase);
    if (isDraftish && now >= (d.phaseEndsAt||0)){
      const di=d.draftIndex|0;
      const sel=d.selections||{p0:[],p1:[]};
      const fx = d.factions || {};

      ["p0","p1"].forEach(sk=>{
        if (sel[sk][di]==null){
          const pack=(d.currentPacks?.[sk]||[]);
          sel[sk][di] = Math.floor(Math.random()*Math.max(1,pack.length));
        }
      });

      const roster = d.roster || {p0:[],p1:[]};
      ["p0","p1"].forEach(sk=>{
        const pack=(d.currentPacks?.[sk]||[]);
        const pick=pack[ sel[sk][di] ];
        if (!pick) return;
        if (pick.type==="troop"){
          rosterAdd(roster[sk], pick.key, 1);
        }else if (pick.type==="special"){
          if (pick.special==="double") rosterDoubleOneSpecific(roster[sk], pick.for);
          if (pick.special==="upgrade") rosterUpgradeOneSpecific(roster[sk], pick.for);
        }
      });

      if (d.phase==="draft"){
        const nextIx=di+1;
        if (nextIx>=3){
          const next={...d, roster, selections:{p0:[],p1:[]}, draftIndex:0, currentPacks:{p0:[],p1:[]}, phase:"battle", phaseEndsAt:0};
          rebuildFieldFromRoster(next);
          await updateDoc(stateRef,next);
          runBattle();
        }else{
          await updateDoc(stateRef,{
            roster, selections:sel, draftIndex:nextIx,
            currentPacks:{
              p0: filterPackForPlayer(roster.p0, fx.p0),
              p1: filterPackForPlayer(roster.p1, fx.p1)
            },
            phaseEndsAt: Date.now()+10_000
          });
        }
        return;
      }

      if (d.phase==="loser-bonus"){
        await updateDoc(stateRef,{
          roster, selections:{p0:[],p1:[]}, draftIndex:0,
          currentPacks:{
            p0: filterPackForPlayer(roster.p0, fx.p0),
            p1: filterPackForPlayer(roster.p1, fx.p1)
          },
          phase:"draft-after", phaseEndsAt: Date.now()+10_000
        });
        return;
      }

      if (d.phase==="draft-after"){
        const nextIx=di+1;
        if (nextIx>=3){
          const next={...d, roster, selections:{p0:[],p1:[]}, draftIndex:0, currentPacks:{p0:[],p1:[]}, phase:"battle", phaseEndsAt:0};
          rebuildFieldFromRoster(next);
          await updateDoc(stateRef,next);
          runBattle();
        }else{
          await updateDoc(stateRef,{
            roster, selections:sel, draftIndex:nextIx,
            currentPacks:{
              p0: filterPackForPlayer(roster.p0, fx.p0),
              p1: filterPackForPlayer(roster.p1, fx.p1)
            },
            phaseEndsAt: Date.now()+10_000
          });
        }
        return;
      }
    }

    if (d.phase==="battle" && !battleTick) runBattle();
  }, 260);
}

/* ------------ Battle loop ------------ */
function runBattle(){
  if(battleTick) return;
  battleTick=setInterval(async ()=>{
    const snap=await getDoc(stateRef); if(!snap.exists()){ clearInterval(battleTick); battleTick=null; return; }
    const d=snap.data(); if(d.phase!=="battle"){ clearInterval(battleTick); battleTick=null; return; }
    const st=structuredClone(d);
    const units=st.field.units;
    const now=Date.now();

    applyPoisonSlowAndDot(st.field, units);

    for(const u of units){ blinkIfNeeded(u); }

    for(const u of units){
      let t = u.hunterRanged ? nearestEnemyRangedPriority(u,units) : nearestEnemy(u,units);
      if(!t) continue;

      if(!attack(u,t,now,units,st.field)){
        const slowed = (u.slowUntil && u.slowUntil>now);
        const steps = Math.max(1, slowed ? 1 : PACE.moveSteps);
        for(let s=0;s<steps;s++){
          t = u.hunterRanged ? nearestEnemyRangedPriority(u,units) : nearestEnemy(u,units);
          if(!t) break;
          stepToward(u,t,units);
          if ((Math.abs(u.x-t.x)+Math.abs(u.y-t.y))<= (u.range||1)) break;
        }
      }
    }

    // handle deaths; ensure kamikaze painters explode on death too
    const dead = st.field.units.filter(u=>u.hp<=0);
    for(const u of dead){
      if (u.paints){ paintPoison(st, u.x, u.y, 7000); }
    }
    st.field.units = st.field.units.filter(u=>u.hp>0);

    const a0=st.field.units.some(u=>u.p===0), a1=st.field.units.some(u=>u.p===1);
    if(!a0 || !a1){
      clearInterval(battleTick); battleTick=null;
      const loser = a0?1:0;
      const lives=[...(st.lives||[4,4])]; lives[loser]=Math.max(0,lives[loser]-1);
      const winner = lives[0]===0 ? st.players[1] : (lives[1]===0 ? st.players[0] : null);

      const next = {
        ...st, lives,
        phase: winner ? "game-over" : "loser-bonus",
        phaseEndsAt: winner ? 0 : Date.now()+10_000,
        selections:{p0:[],p1:[]},
        currentPacks: winner ? {p0:[],p1:[]} : {
          p0: filterPackForPlayer(st.roster.p0, st.factions.p0),
          p1: filterPackForPlayer(st.roster.p1, st.factions.p1)
        },
        draftIndex:0,
        winner: winner || null
      };
      await updateDoc(stateRef,next);
    }else{
      await updateDoc(stateRef,st);
    }
  }, PACE.tickMs);
}

/* ------------ Live listeners ------------ */
onSnapshot(lobbyRef, async (snap)=>{
  if (!snap.exists()) return;
  const lob = snap.data();
  lobbyPlayers = (Array.isArray(lob.players)? lob.players : []).slice(0,2);
  isHost = lob.host === username;

  await ensureStateExists();
  await syncPlayersIntoStateIfNeeded();

  const currentPlayers = S?.players || lobbyPlayers;
  meIndex = Math.max(0, (currentPlayers||[]).indexOf(username));

  if (isHost) startHostLoops();

  render();
});

onSnapshot(stateRef,(snap)=>{
  if(!snap.exists()) return;
  S=snap.data();
  const currentPlayers = S.players || lobbyPlayers;
  meIndex = Math.max(0, (currentPlayers||[]).indexOf(username));
  render();
});

/* ------------ Fullscreen ------------ */
$("fsBtn").onclick = async ()=>{
  try{
    if (!document.fullscreenElement) await document.documentElement.requestFullscreen();
    else await document.exitFullscreen();
  }catch(e){}
};
</script>
</body>
</html>













