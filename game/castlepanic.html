<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>ğŸ° Wall Defense â€” Co-op Card Siege</title>
<style>
  :root{
    --bg:#0b1014; --panel:#0e1726; --ink:#e6efff; --muted:#9fb3c8; --card:#111827; --br:#1f2a44;
    --good:#22c55e; --warn:#eab308; --bad:#ef4444; --accent:#60a5fa;
    --tap:64px; --rad:16px; --shadow:0 10px 30px rgba(2,6,23,.35);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; background:radial-gradient(1000px 600px at 50% -150px,#162239,#0b1014);
    color:var(--ink);
  }
  .wrap{
    height:100svh; max-width:1100px; margin:0 auto; display:grid; grid-template-rows:auto 1fr auto; gap:10px; padding:10px;
  }
  .top{
    display:grid; gap:10px; grid-template-columns:1fr auto; align-items:stretch;
  }
  .status{
    background:var(--panel); border:1px solid var(--br); border-radius:var(--rad); padding:8px 10px; display:grid; gap:6px; min-width:260px;
  }
  .row{display:flex; align-items:center; justify-content:space-between; gap:8px}
  .hpbar{height:10px; background:#0e1627; border:1px solid var(--br); border-radius:999px; overflow:hidden}
  .hpbar>i{display:block; height:100%; background:linear-gradient(90deg,#22c55e,#60a5fa); width:100%}
  .chips{display:flex; gap:6px; flex-wrap:wrap}
  .chip{
    background:#0f1b2e; border:1px solid var(--br); padding:6px 10px; border-radius:999px; font-weight:700; font-size:13px; display:flex; gap:8px; align-items:center
  }
  .chip[data-cur="true"]{outline:2px solid var(--accent); box-shadow:0 0 0 4px rgba(96,165,250,.15)}
  .topBtns{display:flex; gap:8px; align-items:center}
  .btn{appearance:none; border:none; border-radius:12px; padding:10px 12px; font-weight:900; cursor:pointer; color:#081321; background:#9cc8ff;}
  .btn.secondary{background:#c3d4ee; color:#0b1322}
  .btn.warn{background:#ffd59b}
  .btn.danger{background:#ff9ca8}

  /* Battlefield window */
  .boardWrap{
    background:var(--panel); border:1px solid var(--br); border-radius:var(--rad); padding:8px; display:grid; grid-template-rows:auto 1fr; gap:8px; min-height:0;
  }
  .legend{display:flex; gap:10px; flex-wrap:wrap; font-size:13px; color:var(--muted)}
  .view{
    position:relative; overflow:hidden; border:1px solid var(--br); border-radius:12px; min-height:360px;
    touch-action:none; background:#0b1422;
  }
  canvas{display:block; width:100%; height:100%}
  .aimDot{
    pointer-events:none; position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    width:18px; height:18px; border-radius:50%; background:#99c3ff88; border:2px solid #99c3ff;
    display:none;
  }

  /* Hand & actions */
  .bottom{
    display:grid; grid-template-columns:1fr auto; gap:10px; align-items:stretch;
  }
  .hand{
    background:var(--panel); border:1px solid var(--br); border-radius:var(--rad); padding:8px; display:grid; grid-template-columns:repeat(3,1fr); gap:8px;
  }
  .card{
    background:linear-gradient(180deg,#0f1d33,#0a1222); border:1px solid var(--br); border-radius:12px; padding:10px; display:grid; gap:6px; min-height:96px;
    box-shadow:var(--shadow); cursor:pointer; user-select:none
  }
  .card .name{font-weight:900; font-size:14px; line-height:1.1}
  .card .desc{font-size:12px; color:var(--muted)}
  .card[data-disabled="true"]{opacity:.45; filter:grayscale(.2); pointer-events:none}
  .card[data-aim="true"]{outline:2px solid var(--accent); box-shadow:0 0 0 6px rgba(96,165,250,.15)}
  .tag{font-size:11px; padding:3px 7px; border-radius:999px; border:1px solid #334; background:#0b1629; color:#a9c2ff; width:max-content}

  .actions{
    background:var(--panel); border:1px solid var(--br); border-radius:var(--rad); padding:8px; display:grid; gap:8px; min-width:210px
  }
  .bar{display:flex; gap:8px; flex-wrap:wrap}
  .pill{background:#0f1b2e; border:1px solid var(--br); padding:6px 10px; border-radius:999px; font-size:12px}
  .log{max-height:9lh; overflow:auto; font-size:12px; color:#a9b8d6}
  .muted{color:var(--muted)}

  @media (max-width:720px){
    .top{grid-template-columns:1fr}
    .status{min-width:unset}
    .bottom{grid-template-columns:1fr}
    .hand{grid-template-columns:repeat(2,1fr)}
  }
</style>
</head>
<body>
<div class="wrap">
  <!-- TOP -->
  <div class="top">
    <div class="status">
      <div class="row"><div>ğŸ—“ï¸ <b>Turn</b></div><div id="turnNum">1</div></div>
      <div class="row">
        <div>ğŸ° <b>Castle</b></div>
        <div style="flex:1; margin:0 8px" class="hpbar"><i id="hpFill" style="width:100%"></i></div>
        <div id="hpLbl">30/30</div>
      </div>
      <div class="row"><div>ğŸ‘¥ <b>Player</b></div><div id="turnLabel">P1</div></div>
      <div class="chips" id="playersBar"></div>
      <div class="topBtns">
        <button class="btn secondary" id="fsBtn">ğŸ“± Fullscreen</button>
        <button class="btn" id="endBtn">End Turn</button>
      </div>
    </div>
    <div class="boardWrap">
      <div class="legend">
        <span>ğŸ§± Wall</span>
        <span>âš”ï¸ Knight</span>
        <span>ğŸ¹ Archer</span>
        <span>ğŸ§™â€â™‚ï¸ Wizard</span>
        <span>ğŸ‘º Goblin</span>
        <span>ğŸ§Œ Orc</span>
        <span>ğŸ—¿ Troll</span>
        <span>ğŸºğŸ¹ Gnoll</span>
        <span>ğŸ§™â€â™€ï¸ Witch</span>
        <span>ğŸ‘ï¸ Cyclops</span>
        <span>ğŸ‰ Dragon</span>
      </div>
      <div class="view" id="view">
        <canvas id="cv"></canvas>
        <div class="aimDot" id="aimDot"></div>
      </div>
    </div>
  </div>

  <!-- BOTTOM -->
  <div class="bottom">
    <div class="hand" id="hand"></div>
    <div class="actions">
      <div class="bar">
        <span class="pill">ğŸƒ Deck: <b id="deckCount">0</b></span>
        <span class="pill">â™»ï¸ Discard: <b id="discardCount">0</b></span>
        <span class="pill">ğŸ«± Hand: <b id="handCount">0</b></span>
      </div>
      <div class="log" id="log"></div>
      <div class="muted">Tip: Play 1 card per turn. Troops & enemies act at the start of each player's turn. Drag the field to pan. When aiming siege, drag from the dot.</div>
    </div>
  </div>
</div>

<script>
/* ============================================================
   Config & helpers
   ============================================================ */
const TILE = 36;
const GRID_W = 46;  // width in tiles
const GRID_H = 18;  // height in tiles
const WALL_X  = 2;  // wall column (allies spawn near here)
const ENEMY_SPAWN_X = GRID_W - 3;

const CASTLE_MAX_HP = 30;
const HAND_SIZE = 3;

function uid(){ return Math.random().toString(36).slice(2,9); }
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function dist(a,b){ return Math.abs(a.x-b.x)+Math.abs(a.y-b.y); } // manhattan
function inBounds(x,y){ return x>=0 && y>=0 && x<GRID_W && y<GRID_H; }
function getParam(name){
  const m = new RegExp('[?&]'+name+'=([^&#]*)').exec(location.search);
  return m ? decodeURIComponent(m[1].replace(/\+/g,'%20')) : null;
}

const EMOJI = {
  wall: "ğŸ§±",
  knight: "âš”ï¸",
  archer: "ğŸ¹",
  wizard: "ğŸ§™â€â™‚ï¸",
  goblin: "ğŸ‘º",
  orc: "ğŸ§Œ",
  troll: "ğŸ—¿",
  gnoll: "ğŸº",
  witch: "ğŸ§™â€â™€ï¸",
  cyclops: "ğŸ‘ï¸",
  dragon: "ğŸ‰",
  fire: "ğŸ”¥",
  rubble: "ğŸ’¥"
};

// Enemy tiers unlock every 5 turns: 1..5 goblins, add orcs, add trolls, add gnoll+witch,
// add cyclops, add dragon
function tierForTurn(turn){
  return Math.floor((turn-1)/5)+1;
}

/* ============================================================
   Game State
   ============================================================ */
const state = {
  turn: 1,
  castleHP: CASTLE_MAX_HP,
  players: [],       // { name, deck:[], discard:[], hand:[] }
  curP: 0,
  actedThisTurn: false,
  grid: [],          // occupancy id grid
  units: {},         // id -> {id, side:'ally'|'enemy'|'wall'|'effect', kind, hp,max, dmg, range, speed, splash, x,y, ai:'ranged'|'melee', burnTurns:0}
  burns: {},         // key "x,y" -> remaining turns of burn
  targetAiming: null,// {cardIndex, weapon:'catapult'|'ballista'}
  dragging:false, dragStart:null, viewOffset:{x:0,y:0}, viewScale:1,
  gameOver:false
};

// Firebase hooks (no-op for now). Plug your RTDB/Firestore here if desired.
const FirebaseSync = {
  isMyTurn: ()=> true, // multi-device gate
  onAdvance: ()=>{},   // broadcast state diff
};

/* ============================================================
   Deck & Cards
   ============================================================ */
function starterDeck(){
  const d = [];
  // troops
  d.push(makeTroopCard("knight"));
  d.push(makeTroopCard("archer"));
  d.push(makeTroopCard("wizard"));
  d.push(makeTroopCard("knight"));
  // siege
  d.push(makeSiegeCard("catapult"));
  d.push(makeSiegeCard("ballista"));
  // upgrades
  d.push(makeUpgradeCard());
  d.push(makeUpgradeCard());
  // duplicate to make a fuller deck
  d.push(makeTroopCard("archer"));
  d.push(makeSiegeCard("catapult"));
  return d;
}

function makeTroopCard(kind){ return {id:uid(), type:"troop", kind, level:1, name:cap(kind)+" (Lv1)", desc:`Summon ${cap(kind)}s near the wall. Count scales with level.`}; }
function makeSiegeCard(kind){ 
  const nm = kind==="catapult"?"Catapult":"Ballista";
  return {id:uid(), type:"siege", kind, level:1, name:`${nm} (Lv1)`, desc:(kind==="catapult"?"Splash at target.":"Pierces along path; extra dmg at impact.")};
}
function makeUpgradeCard(){ return {id:uid(), type:"upgrade", name:"Upgrade", desc:"Click this, then click a card in your hand to level it up."}; }

function cap(s){ return s[0].toUpperCase()+s.slice(1); }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }

function initPlayers(n=1){
  const arr=[];
  for(let i=0;i<n;i++){
    const deck = shuffle(starterDeck());
    arr.push({name:`P${i+1}`, deck, discard:[], hand:[]});
  }
  state.players = arr;
  for(const p of state.players){ drawUpTo(p); }
}

function draw(p){
  if(!p.deck.length){
    if(!p.discard.length) return null;
    log(`ğŸ”„ ${p.name} reshuffled.`);
    p.deck = shuffle(p.discard.splice(0));
  }
  return p.deck.pop();
}
function drawUpTo(p){
  while(p.hand.length < HAND_SIZE){
    const c = draw(p); if(!c) break;
    p.hand.push(c);
  }
}
function discardCard(p, idx){
  const [c] = p.hand.splice(idx,1);
  p.discard.push(c);
}
function levelUpCard(card){
  card.level = Math.min(10, (card.level||1)+1);
  if(card.type==="troop"){
    card.name = `${cap(card.kind)} (Lv${card.level})`;
  }else if(card.type==="siege"){
    const nm = card.kind==="catapult"?"Catapult":"Ballista";
    card.name = `${nm} (Lv${card.level})`;
  }
}

/* ============================================================
   Grid & Units
   ============================================================ */
function keyXY(x,y){ return `${x},${y}`; }

function clearGrid(){
  state.grid = [];
  for(let y=0;y<GRID_H;y++){
    const row = new Array(GRID_W).fill(null);
    state.grid.push(row);
  }
}
function placeUnit(u){
  if(!inBounds(u.x,u.y)) return false;
  if(state.grid[u.y][u.x]) return false;
  state.units[u.id]=u;
  state.grid[u.y][u.x]=u.id;
  return true;
}
function moveUnit(u, nx, ny){
  if(!inBounds(nx,ny)) return false;
  if(state.grid[ny][nx]) return false;
  state.grid[u.y][u.x]=null;
  u.x = nx; u.y = ny;
  state.grid[ny][nx]=u.id;
  return true;
}
function removeUnit(u){
  if(state.grid[u.y]?.[u.x]===u.id){ state.grid[u.y][u.x]=null; }
  delete state.units[u.id];
}

function makeWall(){
  for(let y=0;y<GRID_H;y++){
    const id = uid();
    const w = {id, side:'wall', kind:'wall', emoji:EMOJI.wall, hp:9999, max:9999, dmg:0, range:0, speed:0, x:WALL_X, y};
    placeUnit(w);
  }
}

function countFreeNearWall(){
  let free=0;
  for(let y=0;y<GRID_H;y++){
    const x = WALL_X+1;
    if(!state.grid[y][x]) free++;
  }
  return free;
}

/* ----- Allied Troops ----- */
function troopStats(kind, level=1){
  // level can modestly increase dmg/hp
  const base = {
    knight: {hp:4, dmg:2, range:1, speed:1, ai:'melee'},
    archer: {hp:3, dmg:2, range:4, speed:1, ai:'ranged'},
    wizard: {hp:3, dmg:1, range:3, speed:1, ai:'rangedSplash'},
  }[kind];
  const hp = base.hp + Math.floor((level-1)/2);
  const dmg = base.dmg + Math.floor((level-1)/3);
  return {hp, dmg, range:base.range, speed:base.speed, ai:base.ai};
}
function summonTroops(kind, level){
  // Number spawned = ceil(level/2), min 1, max 4
  const count = Math.min(4, Math.max(1, Math.ceil(level/2)));
  let placed=0;
  for(let y=0;y<GRID_H && placed<count;y++){
    const x = WALL_X+1;
    if(!state.grid[y][x]){
      const st = troopStats(kind, level);
      const u = {
        id:uid(), side:'ally', kind, emoji:(kind==='knight'?EMOJI.knight:kind==='archer'?EMOJI.archer:EMOJI.wizard),
        hp:st.hp, max:st.hp, dmg:st.dmg, range:st.range, speed:st.speed, splash:(kind==='wizard'?1:0),
        x, y
      };
      placeUnit(u);
      placed++;
    }
  }
  if(placed<count){ log(`âš ï¸ Not enough space near the wall. Spawned ${placed}/${count}.`); }
}

/* ----- Enemies & Waves ----- */
function enemyDef(kind, lvl){
  // scale hp slowly with tier/level
  const scale = 1 + Math.floor((lvl-1)/5)*0.25 + (lvl*0.02);
  const table = {
    goblin: {hp:2, dmg:1, range:1, speed:2, ai:'melee'},
    orc:    {hp:5, dmg:2, range:1, speed:1, ai:'melee'},
    troll:  {hp:10,dmg:3, range:1, speed:1, ai:'meleeSplash'},
    gnoll:  {hp:4, dmg:2, range:3, speed:1, ai:'ranged'},
    witch:  {hp:4, dmg:1, range:3, speed:1, ai:'rangedSplash'},
    cyclops:{hp:12,dmg:4, range:1, speed:1, ai:'meleeKnock'},
    dragon: {hp:18,dmg:3, range:4, speed:1, ai:'rangedSplashWide'},
  }[kind];
  return {
    hp: Math.ceil(table.hp*scale),
    dmg: table.dmg,
    range: table.range,
    speed: table.speed,
    ai: table.ai
  };
}
function emojiForEnemy(kind){
  return {
    goblin:EMOJI.goblin, orc:EMOJI.orc, troll:EMOJI.troll, gnoll:EMOJI.gnoll,
    witch:EMOJI.witch, cyclops:EMOJI.cyclops, dragon:EMOJI.dragon
  }[kind];
}
function spawnWave(turn){
  const tier = tierForTurn(turn);
  // choose a few spawns based on tier
  // base count grows with tier
  const count = Math.min(6, 2 + Math.floor(tier/2));
  for(let i=0;i<count;i++){
    const pool = [];
    if(tier>=1){ pool.push("goblin"); }
    if(tier>=2){ pool.push("orc"); }
    if(tier>=3){ pool.push("troll"); }
    if(tier>=4){ pool.push("gnoll","witch"); }
    if(tier>=5){ pool.push("cyclops"); }
    if(tier>=6){ pool.push("dragon"); }

    const kind = pool[(Math.random()*pool.length)|0];
    const y = (Math.random()*GRID_H)|0;
    const def = enemyDef(kind, turn);
    const u = {
      id:uid(), side:'enemy', kind, emoji:emojiForEnemy(kind),
      hp:def.hp, max:def.hp, dmg:def.dmg, range:def.range, speed:def.speed, ai:def.ai,
      x:ENEMY_SPAWN_X, y
    };
    if(!state.grid[y][ENEMY_SPAWN_X]) placeUnit(u);
  }
  log(`ğŸ‘¹ Enemy wave (T${tier}) arrived.`);
}

/* ============================================================
   Turn Engine
   ============================================================ */
function curPlayer(){ return state.players[state.curP]; }

function endTurn(){
  if(state.gameOver) return;
  if(!FirebaseSync.isMyTurn()) return;
  if(!state.actedThisTurn){
    // If player did nothing, still allowed to end turn
  }
  // Next player
  state.curP = (state.curP+1) % state.players.length;
  state.turn += 1;
  state.actedThisTurn = false;

  // Start-of-turn resolution:
  // 1) burns tick
  tickBurns();
  // 2) allies auto act (move or attack)
  alliesAct();
  // 3) enemies resolve (enemy-by-enemy)
  enemiesAct();
  // 4) apply castle damage from enemies adjacent to wall (or at wall)
  applyCastleDamage();

  // Spawn new wave
  spawnWave(state.turn);

  // Draw up to 3 for new current player
  drawUpTo(curPlayer());

  // Lose check
  if(state.castleHP<=0){ gameOver(false); return; }

  renderAll();
  FirebaseSync.onAdvance();
}

function startGame(players=1){
  state.turn=1; state.castleHP=CASTLE_MAX_HP; state.curP=0; state.actedThisTurn=false; state.gameOver=false;
  state.burns = {};
  clearGrid();
  state.units = {};
  initPlayers(players);
  makeWall();
  spawnWave(state.turn);
  renderAll();
}

/* ============================================================
   Auto Actions
   ============================================================ */
function enemiesAct(){
  // resolve enemy by enemy in a fixed order (left-to-right, top-to-bottom)
  const ids = Object.values(state.units).filter(u=>u.side==='enemy').sort((a,b)=> (a.x-b.x)|| (a.y-b.y)).map(u=>u.id);
  for(const id of ids){
    const u = state.units[id]; if(!u) continue;
    doEnemyAction(u);
  }
}
function alliesAct(){
  const ids = Object.values(state.units).filter(u=>u.side==='ally').sort((a,b)=> (b.x-a.x)|| (a.y-b.y)).map(u=>u.id);
  for(const id of ids){
    const u = state.units[id]; if(!u) continue;
    doAllyAction(u);
  }
}

function nearestTarget(u, targets){
  let best=null, bestD=1e9;
  for(const t of targets){
    const d = Math.abs(u.x-t.x)+Math.abs(u.y-t.y);
    if(d<bestD){ bestD=d; best=t; }
  }
  return best;
}

function tilesInLine(a,b){
  // simple Bresenham-ish for straight-ish lines (we mostly move on x with small y adjust)
  const path=[];
  let x=a.x, y=a.y;
  while(x!==b.x || y!==b.y){
    if(x<b.x) x++; else if(x>b.x) x--;
    if(y<b.y) y++; else if(y>b.y) y--;
    path.push({x,y});
    if(path.length>GRID_W+GRID_H) break;
  }
  return path;
}

function canAttack(att, tgt){
  return (Math.abs(att.x-tgt.x)+Math.abs(att.y-tgt.y)) <= att.range;
}

function hitUnit(target, dmg){
  if(target.side==='wall'){
    // wall soaks, castle behind takes when enemies reach WALL_X
    // do nothing to wall
    return 0;
  }
  target.hp -= dmg;
  if(target.hp<=0){
    removeUnit(target);
    return 1;
  }
  return 0;
}

function splashAt(x,y, radius, dmg, sideFilter=null){
  const killed = [];
  for(let iy=y-radius; iy<=y+radius; iy++){
    for(let ix=x-radius; ix<=x+radius; ix++){
      if(!inBounds(ix,iy)) continue;
      const id = state.grid[iy][ix];
      if(!id) continue;
      const u = state.units[id];
      if(!u) continue;
      if(sideFilter && u.side!==sideFilter) continue;
      if(u.side==='wall') continue;
      if(Math.abs(ix-x)+Math.abs(iy-y) <= radius){
        if(hitUnit(u,dmg)) killed.push(u);
      }
    }
  }
  return killed.length;
}

function stepToward(u, tx, ty, steps){
  // attempt to move steps tiles toward target (avoid collisions)
  for(let s=0;s<steps;s++){
    const dx = Math.sign(tx - u.x);
    const dy = Math.sign(ty - u.y);
    // prefer x movement
    if(dx && moveUnit(u, u.x+dx, u.y)) continue;
    if(dy && moveUnit(u, u.x, u.y+dy)) continue;
    // try side-step
    if(dy && moveUnit(u, u.x, u.y+dy)) continue;
    // stuck
    break;
  }
}

function doEnemyAction(u){
  if(!u) return;
  // targets: nearest ally; if none, walk toward wall
  const allies = Object.values(state.units).filter(v=>v.side==='ally');
  if(allies.length){
    const t = nearestTarget(u, allies);
    if(canAttack(u,t)){
      // attack (some variants)
      if(u.ai==='melee'){ hitUnit(t, u.dmg); }
      else if(u.ai==='meleeSplash'){ splashAt(t.x,t.y,1,u.dmg,'ally'); }
      else if(u.ai==='meleeKnock'){ // cyclops
        hitUnit(t, u.dmg);
        // knockback 1 tile away from enemy
        const kx = t.x + Math.sign(t.x-u.x);
        const ky = t.y + Math.sign(t.y-u.y);
        if(inBounds(kx,ky) && !state.grid[ky][kx]) moveUnit(t,kx,ky);
      }
      else if(u.ai==='ranged'){ hitUnit(t, u.dmg); }
      else if(u.ai==='rangedSplash'){ splashAt(t.x,t.y,1,u.dmg,'ally'); }
      else if(u.ai==='rangedSplashWide'){ splashAt(t.x,t.y,2,u.dmg,'ally'); }
      return;
    }else{
      stepToward(u, t.x, t.y, u.speed);
      return;
    }
  }else{
    // march to wall
    stepToward(u, WALL_X, u.y, u.speed);
  }
}

function doAllyAction(u){
  // allies prefer closest enemy; if in range, attack else advance toward right
  const enemies = Object.values(state.units).filter(v=>v.side==='enemy');
  if(!enemies.length) return;
  const t = nearestTarget(u, enemies);
  if(canAttack(u,t)){
    if(u.splash){ splashAt(t.x,t.y,u.splash,u.dmg,'enemy'); }
    else hitUnit(t, u.dmg);
  }else{
    // push forward (to the right) up to speed
    stepToward(u, u.x+10, u.y, u.speed);
  }
}

function applyCastleDamage(){
  // any enemy that reaches x<=WALL_X damages castle (1 each) and stays put
  let hits=0;
  for(const u of Object.values(state.units)){
    if(u.side==='enemy' && u.x<=WALL_X){
      hits += 1;
    }
  }
  if(hits>0){
    state.castleHP = Math.max(0, state.castleHP - hits);
    log(`ğŸ’¥ Castle takes ${hits} damage.`);
  }
}

/* ============================================================
   Burns (catapult Lv10)
   ============================================================ */
function tickBurns(){
  const keys = Object.keys(state.burns);
  for(const k of keys){
    state.burns[k] -= 1;
    if(state.burns[k] <= 0) delete state.burns[k];
  }
  // apply damage to enemies standing on burning tiles
  let burned=0;
  for(const k of Object.keys(state.burns)){
    const [xS,yS]=k.split(','); const x=+xS, y=+yS;
    const id = state.grid[y]?.[x];
    if(!id) continue;
    const u = state.units[id];
    if(u && u.side==='enemy'){
      if(hitUnit(u, 1)) burned++;
    }
  }
  if(burned>0) log(`ğŸ”¥ Burned ${burned} enemy.`);
}

/* ============================================================
   Cards â€” Interactions
   ============================================================ */
let upgradeWaiting = null; // if player clicked Upgrade, then must click a card

function playCard(idx){
  if(state.gameOver) return;
  if(!FirebaseSync.isMyTurn()) { log("â³ Not your turn."); return; }
  if(state.actedThisTurn) { log("ğŸ›‘ You already played a card this turn."); return; }

  const p = curPlayer();
  const c = p.hand[idx];
  if(!c) return;

  if(c.type==="upgrade"){
    upgradeWaiting = {fromIndex: idx};
    renderHand(); // visually mark
    log("â¬†ï¸ Select a card in your hand to upgrade.");
    return;
  }

  if(upgradeWaiting){
    // Expect user to click a card to upgrade
    if(idx === upgradeWaiting.fromIndex){
      log("âŒ Choose a different card to upgrade.");
      return;
    }
    levelUpCard(p.hand[idx]);
    log(`ğŸ”§ Upgraded "${p.hand[idx].name}".`);
    // discard the upgrade card
    discardCard(p, upgradeWaiting.fromIndex);
    upgradeWaiting = null;
    state.actedThisTurn = true;
    renderAll();
    // Auto end turn after a short beat
    setTimeout(endTurn, 350);
    return;
  }

  if(c.type==="troop"){
    summonTroops(c.kind, c.level||1);
    log(`ğŸ›¡ï¸ Summoned ${cap(c.kind)}(s) (Lv${c.level}).`);
    discardCard(p, idx);
    state.actedThisTurn = true;
    renderAll();
    setTimeout(endTurn, 350);
    return;
  }

  if(c.type==="siege"){
    // enter aiming mode
    state.targetAiming = {cardIndex: idx, weapon:c.kind, level:c.level||1};
    showAimDot(true);
    renderHand();
    log(`ğŸ¯ Aim the ${c.kind==='catapult'?'Catapult':'Ballista'} â€” drag from the dot and release.`);
    return;
  }
}

function onHandClick(idx){
  // route clicks depending on upgrade mode
  if(upgradeWaiting && state.players[state.curP].hand[idx]?.type!=="upgrade"){
    playCard(idx); // upgrade path handled inside
    return;
  }
  playCard(idx);
}

/* ============================================================
   Siege aiming + resolution
   ============================================================ */
const viewEl = document.getElementById('view');
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
const aimDot = document.getElementById('aimDot');

let aimDrag = null; // {start:{x,y}, cur:{x,y}}

function showAimDot(show){
  aimDot.style.display = show ? 'block' : 'none';
}
function screenCenter(){ const r=viewEl.getBoundingClientRect(); return {x:r.width/2, y:r.height/2}; }

function toWorld(px,py){
  const r = viewEl.getBoundingClientRect();
  const x = (px - r.left)/state.viewScale + state.viewOffset.x;
  const y = (py - r.top)/state.viewScale  + state.viewOffset.y;
  return {x,y};
}
function worldToTile(wx,wy){
  return { tx: Math.floor(wx/TILE), ty: Math.floor(wy/TILE) };
}
function tileCenter(tx,ty){
  return { x: tx*TILE + TILE/2, y: ty*TILE + TILE/2 };
}

function onPointerDown(e){
  const isAim = !!state.targetAiming;
  if(isAim){
    const c = screenCenter();
    aimDrag = { start:{x:c.x,y:c.y}, cur:{x:c.x,y:c.y} };
  }else{
    // start panning
    state.dragging = true;
    state.dragStart = {mx:e.clientX, my:e.clientY, ox:state.viewOffset.x, oy:state.viewOffset.y};
  }
}
function onPointerMove(e){
  if(state.dragging && state.dragStart){
    const dx = (state.dragStart.mx - e.clientX)/state.viewScale;
    const dy = (state.dragStart.my - e.clientY)/state.viewScale;
    state.viewOffset.x = clamp(state.dragStart.ox + dx, 0, GRID_W*TILE - 50);
    state.viewOffset.y = clamp(state.dragStart.oy + dy, 0, GRID_H*TILE - 50);
    renderCanvas();
  }
  if(aimDrag){
    aimDrag.cur = {x:e.clientX - viewEl.getBoundingClientRect().left, y:e.clientY - viewEl.getBoundingClientRect().top};
    renderCanvas(); // show line
  }
}
function onPointerUp(e){
  if(aimDrag && state.targetAiming){
    // compute vector from center to current -> aim direction and power
    const c = screenCenter();
    const vx = (aimDrag.start.x - aimDrag.cur.x);
    const vy = (aimDrag.start.y - aimDrag.cur.y);
    resolveSiegeShot(vx, vy);
    aimDrag = null;
    state.targetAiming = null;
    showAimDot(false);
  }
  state.dragging=false; state.dragStart=null;
}

viewEl.addEventListener('pointerdown', onPointerDown);
viewEl.addEventListener('pointermove', onPointerMove);
viewEl.addEventListener('pointerup', onPointerUp);
viewEl.addEventListener('pointerleave', onPointerUp);
viewEl.addEventListener('wheel', (e)=>{ // zoom (optional)
  e.preventDefault();
  const s = clamp(state.viewScale - Math.sign(e.deltaY)*0.05, 0.6, 1.5);
  state.viewScale = s; renderCanvas();
},{passive:false});

function resolveSiegeShot(vx,vy){
  const p = curPlayer();
  const a = state.targetAiming;
  const card = p.hand[a.cardIndex];
  if(!card) return;
  const len = Math.hypot(vx,vy);
  if(len<10){ log("âŒ Too soft. Try pulling further."); return; }
  const powerTiles = Math.min(16, Math.max(3, Math.floor(len/40) )); // distance in tiles
  const dirx = vx/len, diry = vy/len; // direction from center outward
  // convert center to world tile as origin: center is the wall area-ish. We'll cast a ray from WALL_X+2 mid row.
  // But better: ray from the center of the visible screen in world coords.
  const r = viewEl.getBoundingClientRect();
  const wx = state.viewOffset.x + r.width/state.viewScale/2;
  const wy = state.viewOffset.y + r.height/state.viewScale/2;
  let {tx,ty} = worldToTile(wx,wy);

  // clamp start
  tx = clamp(tx, 0, GRID_W-1);
  ty = clamp(ty, 0, GRID_H-1);

  if(card.kind === 'catapult'){
    // fly to target tile; no path damage; splash at end
    let cx=tx, cy=ty;
    for(let i=0;i<powerTiles;i++){
      cx = clamp(Math.round(tx + dirx*i), 0, GRID_W-1);
      cy = clamp(Math.round(ty + diry*i), 0, GRID_H-1);
    }
    const splashR = (card.level>=10)?2 : (card.level>=5?2:1);
    const dmg = 1 + Math.floor((card.level-1)/2);
    const killed = splashAt(cx,cy,splashR,dmg,'enemy');
    if(card.level>=5){
      // debris spray: random tiles in wide area
      let extraHits=0;
      for(let i=0;i<5;i++){
        const rx = clamp(cx + ((Math.random()*5)|0)-2, 0, GRID_W-1);
        const ry = clamp(cy + ((Math.random()*5)|0)-2, 0, GRID_H-1);
        extraHits += splashAt(rx,ry,0,1,'enemy');
      }
      if(extraHits) log(`ğŸ’¥ Debris hit ${extraHits}.`);
    }
    if(card.level>=10){
      // set burn for next turn (1 extra tick of damage)
      for(let yy=cy-1; yy<=cy+1; yy++){
        for(let xx=cx-1; xx<=cx+1; xx++){
          if(!inBounds(xx,yy)) continue;
          state.burns[keyXY(xx,yy)] = 2; // lasts through the next turn's tick
        }
      }
    }
    log(`ğŸª¨ Catapult impact at ${cx},${cy}. ${killed} down.`);
  }else{
    // ballista: pierce along path, extra damage at final tile
    let cx=tx, cy=ty; let last={x:cx,y:cy};
    const lineHits = [];
    for(let i=1;i<=powerTiles;i++){
      cx = clamp(Math.round(tx + dirx*i), 0, GRID_W-1);
      cy = clamp(Math.round(ty + diry*i), 0, GRID_H-1);
      last={x:cx,y:cy};
      const id = state.grid[cy][cx];
      if(id){
        const u = state.units[id];
        if(u && u.side==='enemy'){
          lineHits.push(u);
        }
      }
    }
    // apply line damage
    let killed=0;
    const base = 1 + Math.floor((card.level-1)/3);
    for(const u of lineHits){ if(hitUnit(u, base)) killed++; }
    // extra impact damage at last tile
    const id2 = state.grid[last.y][last.x];
    if(id2){
      const u2 = state.units[id2];
      if(u2 && u2.side==='enemy'){
        if(hitUnit(u2, base+1)) killed++;
        // knockback at Lv10
        if(card.level>=10){
          const kx = u2.x + Math.sign(u2.x - tx);
          if(inBounds(kx,u2.y) && !state.grid[u2.y][kx]) moveUnit(u2,kx,u2.y);
        }
      }
    }
    // Tri-shot at L5
    if(card.level>=5){
      const offsets=[[0,0],[ -diry*0.6, dirx*0.6 ], [ diry*0.6, -dirx*0.6 ]];
      for(let b=1;b<offsets.length;b++){
        let lx=tx, ly=ty;
        for(let i=1;i<=powerTiles;i++){
          const ax = clamp(Math.round(tx + (dirx+offsets[b][0]) * i), 0, GRID_W-1);
          const ay = clamp(Math.round(ty + (diry+offsets[b][1]) * i), 0, GRID_H-1);
          const id = state.grid[ay][ax];
          if(id){
            const u = state.units[id];
            if(u && u.side==='enemy'){
              if(hitUnit(u, base)) killed++;
            }
          }
          lx=ax; ly=ay;
        }
        // extra at end tip (less)
        const id3 = state.grid[ly][lx];
        if(id3){
          const u3 = state.units[id3];
          if(u3 && u3.side==='enemy'){ if(hitUnit(u3, base)) killed++; }
        }
      }
    }
    log(`ğŸ¹ Ballista fired. ${killed} down.`);
  }

  // discard card & end turn
  const idx = a.cardIndex;
  discardCard(p, idx);
  state.actedThisTurn = true;
  renderAll();
  setTimeout(endTurn, 350);
}

/* ============================================================
   UI: Rendering
   ============================================================ */
function qs(s){ return document.querySelector(s); }
function log(msg){
  const el = qs('#log');
  const line = document.createElement('div');
  const ts = new Date().toLocaleTimeString();
  line.innerHTML = `<span style="opacity:.6">[${ts}]</span> ${msg}`;
  el.appendChild(line);
  el.scrollTop = el.scrollHeight;
}

function renderAll(){
  renderStatus();
  renderPlayers();
  renderHand();
  renderCanvas();
}

function renderStatus(){
  qs('#turnNum').textContent = state.turn;
  qs('#turnLabel').textContent = curPlayer().name;
  const hpPct = Math.round(state.castleHP/CASTLE_MAX_HP*100);
  qs('#hpFill').style.width = Math.max(0,hpPct)+'%';
  qs('#hpLbl').textContent = `${state.castleHP}/${CASTLE_MAX_HP}`;
  qs('#deckCount').textContent = curPlayer().deck.length;
  qs('#discardCount').textContent = curPlayer().discard.length;
  qs('#handCount').textContent = curPlayer().hand.length;
  qs('#endBtn').disabled = state.gameOver || !FirebaseSync.isMyTurn();
}

function renderPlayers(){
  const bar = qs('#playersBar'); bar.innerHTML="";
  state.players.forEach((p,i)=>{
    const chip = document.createElement('div');
    chip.className='chip';
    chip.dataset.cur = (i===state.curP);
    chip.innerHTML = `<span>ğŸ‘¤</span><b>${p.name}</b> <span style="opacity:.7">ğŸƒ${p.hand.length}</span>`;
    bar.appendChild(chip);
  });
}

function renderHand(){
  const h = qs('#hand'); h.innerHTML="";
  const p = curPlayer();
  p.hand.forEach((c,idx)=>{
    const el = document.createElement('div');
    el.className='card';
    el.onclick = ()=> onHandClick(idx);
    const name = document.createElement('div'); name.className='name'; name.textContent = c.name;
    const desc = document.createElement('div'); desc.className='desc'; desc.textContent = c.desc;
    const tag = document.createElement('div'); tag.className='tag'; tag.textContent = c.type==='troop'? 'Summon' : (c.type==='siege' ? 'Attack' : 'Upgrade');
    el.appendChild(name); el.appendChild(desc); el.appendChild(tag);
    if(upgradeWaiting && upgradeWaiting.fromIndex===idx) el.setAttribute('data-aim','true');
    if(state.targetAiming && state.targetAiming.cardIndex===idx) el.setAttribute('data-aim','true');
    if(state.actedThisTurn) el.setAttribute('data-disabled','true');
    if(!FirebaseSync.isMyTurn()) el.setAttribute('data-disabled','true');
    h.appendChild(el);
  });
}

/* ===== Canvas drawing ===== */
function resizeCanvas(){
  const r = viewEl.getBoundingClientRect();
  cv.width = Math.max(300, Math.floor(r.width  * devicePixelRatio));
  cv.height= Math.max(220, Math.floor(r.height * devicePixelRatio));
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
window.addEventListener('resize', ()=>{ resizeCanvas(); renderCanvas(); });

function drawGrid(){
  const w = cv.width/devicePixelRatio, h = cv.height/devicePixelRatio;
  ctx.save();
  ctx.translate(-state.viewOffset.x*state.viewScale, -state.viewOffset.y*state.viewScale);
  ctx.scale(state.viewScale, state.viewScale);

  // background
  ctx.fillStyle = '#0b1422';
  ctx.fillRect(state.viewOffset.x, state.viewOffset.y, w/state.viewScale, h/state.viewScale);

  // tiles
  ctx.strokeStyle = '#1a2742';
  ctx.lineWidth = 1;
  for(let y=0;y<GRID_H;y++){
    for(let x=0;x<GRID_W;x++){
      ctx.strokeRect(x*TILE, y*TILE, TILE, TILE);
    }
  }

  // burning tiles highlight
  for(const k of Object.keys(state.burns)){
    const [xS,yS]=k.split(','); const x=+xS, y=+yS;
    ctx.fillStyle = 'rgba(255,80,60,0.15)';
    ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
  }

  // wall band
  ctx.fillStyle = 'rgba(120,160,255,0.08)';
  ctx.fillRect(WALL_X*TILE, 0, TILE, GRID_H*TILE);

  // aim line
  if(aimDrag && state.targetAiming){
    const c = screenCenter();
    const sx = state.viewOffset.x + (c.x/state.viewScale);
    const sy = state.viewOffset.y + (c.y/state.viewScale);
    const ex = state.viewOffset.x + (aimDrag.cur.x/state.viewScale);
    const ey = state.viewOffset.y + (aimDrag.cur.y/state.viewScale);
    ctx.strokeStyle = '#9cc8ff';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(sx,sy); ctx.lineTo(ex,ey); ctx.stroke();

    // arrow head
    const ang = Math.atan2(ey-sy, ex-sx);
    ctx.beginPath();
    ctx.moveTo(ex,ey);
    ctx.lineTo(ex - 12*Math.cos(ang-0.4), ey - 12*Math.sin(ang-0.4));
    ctx.lineTo(ex - 12*Math.cos(ang+0.4), ey - 12*Math.sin(ang+0.4));
    ctx.closePath(); ctx.fillStyle='#9cc8ff'; ctx.fill();
  }

  // units
  ctx.textAlign='center'; ctx.textBaseline='middle';
  for(const u of Object.values(state.units)){
    const px = u.x*TILE + TILE/2;
    const py = u.y*TILE + TILE/2;
    // token
    ctx.font = '22px system-ui,Segoe UI,Apple Color Emoji,Segoe UI Emoji';
    ctx.fillText(u.emoji, px, py);
    // hp
    if(u.side!=='wall'){
      ctx.fillStyle = '#99c3ff';
      ctx.font = '11px system-ui';
      ctx.fillText(`${u.hp}`, px, py + 14);
      ctx.fillStyle = '#e6efff';
    }
  }

  ctx.restore();
}

function renderCanvas(){
  resizeCanvas();
  const w = cv.width/devicePixelRatio, h = cv.height/devicePixelRatio;
  ctx.clearRect(0,0,w,h);
  drawGrid();

  // center the aim dot
  const c = screenCenter();
  aimDot.style.left = c.x+'px';
  aimDot.style.top  = c.y+'px';
}

/* ============================================================
   Controls
   ============================================================ */
document.getElementById('endBtn').addEventListener('click', endTurn);
document.getElementById('fsBtn').addEventListener('click', ()=>{
  if(document.fullscreenElement) document.exitFullscreen();
  else document.documentElement.requestFullscreen();
});

/* ============================================================
   Game Over
   ============================================================ */
function gameOver(win){
  state.gameOver = true;
  log(win ? "ğŸ† Victory!" : "â˜ ï¸ Defeat â€” the castle fell.");
  document.getElementById('endBtn').disabled = true;
}

/* ============================================================
   Boot
   ============================================================ */
// read ?players=N (fallback 2), clamp 1â€“4
const pParam = parseInt(getParam('players') || '', 10);
const PLAYER_COUNT = clamp(isNaN(pParam) ? 2 : pParam, 1, 4);

startGame(PLAYER_COUNT);
</script>
</body>
</html>



