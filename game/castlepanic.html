<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>üè∞ Base War ‚Äî Elemental Siege</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
  <style>
    :root{
      --bg:#020617;
      --panel:#020617;
      --card:#0b1120;
      --ink:#e5e7eb;
      --muted:#9ca3af;
      --accent:#f97316;
      --accent-soft:#fed7aa;
      --good:#22c55e;
      --bad:#ef4444;
      --radius:20px;
      --shadow:0 18px 40px rgba(15,23,42,.7);
      --tap:56px;
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color:transparent;}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:
        radial-gradient(1200px 900px at -10% -20%, rgba(248,113,113,.28), transparent 60%),
        radial-gradient(1200px 900px at 110% -10%, rgba(249,115,22,.25), transparent 60%),
        #020617;
      color:var(--ink);
      min-height:100vh;
      display:flex;
      flex-direction:column;
    }
    .shell{
      max-width:960px;
      margin:0 auto;
      padding:10px 10px 24px;
      width:100%;
    }

    /* HUD */
    .hud{
      margin-top:10px;
      margin-bottom:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .hud-row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .player-panel{
      flex:1 1 0;
      background:linear-gradient(135deg,rgba(15,23,42,.96),rgba(15,23,42,.9));
      border-radius:var(--radius);
      padding:8px 10px;
      border:1px solid rgba(148,163,184,.6);
      box-shadow:0 10px 26px rgba(15,23,42,.8);
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .player-name{
      display:flex;
      align-items:center;
      justify-content:space-between;
      font-size:.92rem;
      font-weight:800;
      color:#f9fafb;
    }
    .role-label{
      font-size:.78rem;
      color:var(--muted);
    }
    .hp-wrap{
      display:flex;
      align-items:center;
      gap:8px;
      font-size:.8rem;
      color:var(--muted);
    }
    .hp-bar{
      flex:1;
      height:10px;
      border-radius:999px;
      background:rgba(15,23,42,1);
      border:1px solid rgba(51,65,85,.9);
      overflow:hidden;
    }
    .hp-fill{
      height:100%;
      width:100%;
      background:linear-gradient(90deg,#22c55e,#facc15,#fb923c,#ef4444);
      transition:width .2s ease-out;
    }
    .vs-pill{
      width:46px;
      height:46px;
      border-radius:999px;
      display:grid;
      place-items:center;
      background:radial-gradient(circle at 30% 20%,#fee2e2,#f97316);
      color:#111827;
      font-weight:900;
      border:2px solid rgba(248,250,252,.95);
      box-shadow:0 10px 32px rgba(0,0,0,.75);
      font-size:.9rem;
    }

    .meta-row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      font-size:.84rem;
      color:var(--muted);
    }
    .gold-pill{
      display:inline-flex;
      align-items:center;
      gap:7px;
      padding:6px 12px;
      border-radius:999px;
      background:rgba(15,23,42,.95);
      border:1px solid rgba(251,191,36,.7);
      color:#fef3c7;
      box-shadow:0 10px 24px rgba(0,0,0,.8);
    }
    .gold-pill span.coin{
      width:16px;
      height:16px;
      border-radius:50%;
      background:radial-gradient(circle at 30% 30%,#fef9c3,#facc15,#d97706);
      border:1px solid rgba(120,53,15,.9);
      box-shadow:0 0 0 1px rgba(252,211,77,.5);
    }
    .meta-right{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .tag{
      padding:4px 9px;
      border-radius:999px;
      border:1px solid rgba(148,163,184,.7);
      font-size:.74rem;
      color:var(--muted);
    }
    #statusText{
      font-size:.8rem;
      color:var(--muted);
    }
    .btn-ghost{
      border-radius:999px;
      border:1px solid rgba(148,163,184,.8);
      background:rgba(15,23,42,.85);
      color:var(--muted);
      font-size:.8rem;
      padding:7px 10px;
      display:inline-flex;
      align-items:center;
      gap:6px;
      cursor:pointer;
    }

    /* Game card */
    .game-card{
      background:var(--card);
      border-radius:24px;
      border:1px solid rgba(148,163,184,.6);
      box-shadow:var(--shadow);
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .game-head{
      padding:10px 14px;
      border-bottom:1px solid rgba(31,41,55,.95);
      background:
        radial-gradient(circle at 0% 0%,rgba(248,250,252,.16),transparent 55%),
        radial-gradient(circle at 100% 0%,rgba(251,191,36,.18),transparent 60%);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-size:.86rem;
      color:var(--muted);
    }
    .game-head-title{
      display:flex;
      align-items:center;
      gap:8px;
      font-weight:700;
      color:#e5e7eb;
    }
    .game-body{
      padding:10px 10px 12px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    /* Board */
    .board{
      position:relative;
      border-radius:20px;
      border:1px solid rgba(30,64,175,.6);
      background:
        linear-gradient(135deg,rgba(15,23,42,1),rgba(15,23,42,.96)),
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='160' height='160' viewBox='0 0 160 160'%3E%3Cdefs%3E%3CradialGradient id='g' cx='20%25' cy='0%25' r='90%25'%3E%3Cstop stop-color='%2327313b' stop-opacity='0.7' offset='0%25'/%3E%3Cstop stop-color='%230b1120' stop-opacity='0.0' offset='100%25'/%3E%3C/radialGradient%3E%3C/defs%3E%3Crect width='160' height='160' fill='%230b1120'/%3E%3Ccircle cx='30' cy='0' r='80' fill='url(%23g)'/%3E%3C/svg%3E");
      background-size:cover;
      min-height:230px;
      overflow:hidden;
    }
    .lane{
      position:absolute;
      left:0; right:0;
      height:33.333%;
      border-top:1px dashed rgba(51,65,85,.8);
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:0 8px;
      pointer-events:none;
    }
    .lane:first-child{ top:0; border-top:none; }
    .lane:nth-child(2){ top:33.333%; }
    .lane:nth-child(3){ bottom:0; }

    .base-icon{
      width:54px;
      height:54px;
      border-radius:18px;
      display:grid;
      place-items:center;
      font-size:26px;
      background:radial-gradient(circle at 30% 20%,#e5e7eb,#cbd5f5);
      border:2px solid rgba(148,163,184,.9);
      box-shadow:0 12px 32px rgba(0,0,0,.8);
    }
    .base-icon.enemy{
      background:radial-gradient(circle at 30% 20%,#fee2e2,#fecaca);
      border-color:rgba(248,113,113,.9);
    }

    .unit{
      position:absolute;
      width:20px;
      height:20px;
      border-radius:999px;
      display:grid;
      place-items:center;
      font-size:13px;
      color:#0b1120;
      pointer-events:none;
      animation-duration: 1700ms;
      animation-timing-function: cubic-bezier(.25,.8,.25,1);
      animation-fill-mode:forwards;
    }
    .unit.fire{
      background:radial-gradient(circle at 30% 30%,#fed7aa,#fb923c,#b45309);
      box-shadow:0 0 0 2px rgba(251,146,60,.5), 0 0 20px rgba(248,113,113,.8);
    }
    .unit.ice{
      background:radial-gradient(circle at 30% 30%,#e0f2fe,#7dd3fc,#0369a1);
      box-shadow:0 0 0 2px rgba(56,189,248,.5), 0 0 20px rgba(125,211,252,.8);
    }
    .unit.stone{
      background:radial-gradient(circle at 30% 30%,#e5e7eb,#9ca3af,#475569);
      box-shadow:0 0 0 2px rgba(148,163,184,.6), 0 0 20px rgba(148,163,184,.9);
    }
    .unit.from-me{
      animation-name:wave-out;
    }
    .unit.from-enemy{
      animation-name:wave-in;
    }
    @keyframes wave-out{
      from{ transform:translate3d(0,0,0); opacity:1; }
      to{ transform:translate3d(520px,-10px,0); opacity:0; }
    }
    @keyframes wave-in{
      from{ transform:translate3d(520px,0,0); opacity:1; }
      to{ transform:translate3d(-520px,-10px,0); opacity:0; }
    }

    .board-msg{
      position:absolute;
      inset:0;
      display:grid;
      place-items:center;
      font-size:.86rem;
      color:var(--muted);
      text-shadow:0 2px 6px rgba(0,0,0,.9);
      pointer-events:none;
      padding:0 16px;
      text-align:center;
    }

    /* Towers section */
    .towers-section{
      margin-top:8px;
      background:rgba(15,23,42,.95);
      border-radius:16px;
      padding:8px 10px;
      border:1px solid rgba(30,64,175,.8);
    }
    .towers-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      font-size:.84rem;
      color:var(--muted);
      margin-bottom:6px;
    }
    .towers-label{
      display:flex;
      align-items:center;
      gap:6px;
    }
    .tower-row{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .tower-pill{
      flex:0 0 auto;
      min-width:72px;
      padding:6px 8px;
      border-radius:999px;
      background:rgba(15,23,42,.9);
      border:1px solid rgba(148,163,184,.6);
      display:flex;
      align-items:center;
      gap:6px;
      font-size:.78rem;
      cursor:pointer;
      color:#e5e7eb;
    }
    .tower-pill.empty{
      border-style:dashed;
      color:var(--muted);
    }
    .tower-dot{
      width:16px;
      height:16px;
      border-radius:999px;
    }
    .tower-dot.fire{
      background:radial-gradient(circle at 30% 30%,#fed7aa,#fb923c,#b45309);
    }
    .tower-dot.ice{
      background:radial-gradient(circle at 30% 30%,#e0f2fe,#7dd3fc,#0369a1);
    }
    .tower-dot.stone{
      background:radial-gradient(circle at 30% 30%,#e5e7eb,#9ca3af,#475569);
    }

    /* Controls */
    .controls{
      margin-top:8px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .tier-row{
      display:flex;
      gap:6px;
      flex-wrap:wrap;
    }
    .tier-btn{
      flex:1 1 0;
      min-width:0;
      border-radius:999px;
      border:1px solid rgba(148,163,184,.7);
      background:rgba(15,23,42,.9);
      color:var(--muted);
      font-size:.8rem;
      padding:6px 10px;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:6px;
      cursor:pointer;
    }
    .tier-btn[aria-pressed="true"]{
      border-color:#fb923c;
      background:radial-gradient(circle at 30% 20%,#fed7aa,#fb923c);
      color:#111827;
    }

    .unit-row{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .btn{
      cursor:pointer;
      border-radius:999px;
      border:1px solid rgba(248,250,252,.1);
      background:linear-gradient(135deg,#f97316,#ea580c);
      color:#111827;
      font-weight:700;
      font-size:.85rem;
      padding:9px 12px;
      box-shadow:0 10px 24px rgba(0,0,0,.7);
      flex:1 1 90px;
      min-width:0;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:6px;
    }
    .btn span.small{
      font-size:.74rem;
      opacity:.85;
    }
    .btn:disabled{
      opacity:.4;
      box-shadow:none;
      cursor:default;
    }
    .btn-secondary{
      background:rgba(15,23,42,.9);
      border-color:rgba(148,163,184,.7);
      color:#e5e7eb;
      box-shadow:0 10px 22px rgba(0,0,0,.75);
      font-size:.8rem;
    }

    /* Tower overlay */
    .tower-overlay{
      position:fixed;
      left:50%;
      bottom:14px;
      transform:translateX(-50%) translateY(120%);
      background:#020617;
      border-radius:16px;
      border:1px solid rgba(148,163,184,.7);
      box-shadow:0 18px 40px rgba(0,0,0,.9);
      padding:10px 12px 10px;
      width:min(360px, 94vw);
      color:#e5e7eb;
      z-index:40;
      transition:transform .2s ease-out, opacity .2s;
      opacity:0;
    }
    .tower-overlay.show{
      transform:translateX(-50%) translateY(0);
      opacity:1;
    }
    .tower-overlay-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      margin-bottom:6px;
      font-size:.86rem;
    }
    .tower-overlay-actions{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }

    .tiny-btn{
      border-radius:999px;
      border:1px solid rgba(148,163,184,.7);
      background:rgba(15,23,42,.9);
      color:#e5e7eb;
      font-size:.78rem;
      padding:6px 10px;
      display:inline-flex;
      align-items:center;
      gap:6px;
      cursor:pointer;
    }

    /* Toast + error overlay */
    .toast{
      position:fixed;
      left:50%;
      bottom:18px;
      transform:translateX(-50%) translateY(80px);
      background:rgba(15,23,42,.98);
      color:#e5e7eb;
      padding:8px 14px;
      border-radius:999px;
      border:1px solid rgba(148,163,184,.7);
      box-shadow:0 10px 30px rgba(0,0,0,.85);
      font-size:.8rem;
      opacity:0;
      pointer-events:none;
      transition:opacity .18s, transform .18s;
      z-index:60;
    }
    .toast.show{
      opacity:1;
      transform:translateX(-50%) translateY(0);
    }

    .overlay{
      position:fixed;
      inset:0;
      background:radial-gradient(circle at 10% 0%,rgba(248,113,113,.25),transparent 60%), rgba(15,23,42,.96);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:80;
    }
    .overlay.hidden{ display:none; }
    .overlay-card{
      background:#020617;
      border-radius:20px;
      padding:18px 18px 16px;
      border:1px solid rgba(248,113,113,.6);
      box-shadow:0 18px 45px rgba(0,0,0,.9);
      max-width:360px;
      width:90%;
      color:#fee2e2;
      text-align:center;
      font-size:.9rem;
    }
    .overlay-card h2{
      margin:0 0 8px;
      font-size:1.05rem;
      font-weight:800;
    }
    .overlay-card button{
      border-radius:999px;
      border:none;
      background:#f97316;
      color:#111827;
      font-weight:700;
      padding:8px 14px;
      cursor:pointer;
      margin-top:8px;
    }

    @media (max-width:720px){
      .shell{ padding:8px 8px 20px; }
      .player-panel{ padding:8px; }
      .board{ min-height:210px; }
      .btn{ width:100%; }
      .unit-row{ flex-direction:column; }
      .tier-row{ flex-direction:row; }
    }
  </style>
</head>
<body>
  <div class="shell">
    <!-- HUD -->
    <div class="hud">
      <div class="hud-row">
        <div class="player-panel">
          <div class="player-name">
            <span id="youName">You</span>
            <span class="role-label" id="youRole">Connecting‚Ä¶</span>
          </div>
          <div class="hp-wrap">
            <div class="hp-bar"><div id="yourHpFill" class="hp-fill"></div></div>
            <span id="yourHpText">400</span>
          </div>
        </div>
        <div class="vs-pill">VS</div>
        <div class="player-panel">
          <div class="player-name">
            <span id="oppName">Opponent</span>
            <span class="role-label" id="oppRole">Waiting‚Ä¶</span>
          </div>
          <div class="hp-wrap">
            <div class="hp-bar"><div id="oppHpFill" class="hp-fill"></div></div>
            <span id="oppHpText">400</span>
          </div>
        </div>
      </div>

      <div class="meta-row">
        <div class="gold-pill">
          <span class="coin"></span>
          <span>Gold: <strong id="goldAmount">0</strong></span>
          <span style="font-size:.78rem;opacity:.85;">Gen <span id="genLevel">1</span></span>
        </div>
        <div class="meta-right">
          <span id="statusText">Connecting to lobby‚Ä¶</span>
          <span id="buffText" class="tag">No buffs</span>
          <button id="fullBtn" class="btn-ghost" type="button">‚õ∂ Fullscreen</button>
        </div>
      </div>
    </div>

    <!-- GAME -->
    <div class="game-card">
      <div class="game-head">
        <div class="game-head-title">
          <span>üè∞ Base War ‚Äî Elemental Siege</span>
        </div>
        <div id="gameIdLabel"></div>
      </div>
      <div class="game-body">
        <div class="board" id="board">
          <div class="lane" data-lane="0">
            <div class="base-icon">üõ°Ô∏è</div>
            <div class="base-icon enemy">üî•</div>
          </div>
          <div class="lane" data-lane="1">
            <div class="base-icon">üõ°Ô∏è</div>
            <div class="base-icon enemy">üî•</div>
          </div>
          <div class="lane" data-lane="2">
            <div class="base-icon">üõ°Ô∏è</div>
            <div class="base-icon enemy">üî•</div>
          </div>
          <div class="board-msg" id="boardMessage">Waiting for game state‚Ä¶</div>
        </div>

        <!-- Towers -->
        <div class="towers-section">
          <div class="towers-head">
            <div class="towers-label">
              <span>üóº Your Towers</span>
            </div>
            <button id="buyTowerBtn" class="tiny-btn" type="button">
              ‚ûï New Tower
            </button>
          </div>
          <div id="towerRow" class="tower-row"><!-- towers --></div>
        </div>

        <!-- Controls -->
        <div class="controls">
          <div class="tier-row">
            <button class="tier-btn" id="tier1Btn" type="button" aria-pressed="true">Tier I</button>
            <button class="tier-btn" id="tier2Btn" type="button" aria-pressed="false">Tier II</button>
            <button class="tier-btn" id="tier3Btn" type="button" aria-pressed="false">Tier III</button>
          </div>
          <div class="unit-row" id="unitRow">
            <!-- unit buttons injected -->
          </div>
          <div class="unit-row">
            <button id="genBtn" class="btn btn-secondary" type="button">
              <span>‚öôÔ∏è Upgrade Generator</span>
              <span class="small" id="genCostLabel">(‚Äì)</span>
            </button>
            <button id="scanBtn" class="btn btn-secondary" type="button">
              <span>üì° Scout Enemy</span>
              <span class="small" id="scanCostLabel">(35g)</span>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Tower overlay -->
  <div id="towerOverlay" class="tower-overlay">
    <div class="tower-overlay-head">
      <span id="towerOverlayTitle">Tower</span>
      <button id="towerOverlayClose" class="tiny-btn" type="button">‚úï</button>
    </div>
    <div id="towerOverlayBody" style="font-size:.8rem;margin-bottom:6px;"></div>
    <div id="towerOverlayActions" class="tower-overlay-actions"></div>
  </div>

  <!-- Toast -->
  <div id="toast" class="toast"></div>

  <!-- Fatal overlay -->
  <div id="errorOverlay" class="overlay hidden">
    <div class="overlay-card">
      <h2>Unable to join match</h2>
      <p id="errorMessage"></p>
      <button onclick="window.location.href='/'">Back to Hub</button>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import {
      getFirestore, doc, getDoc, setDoc, onSnapshot,
      collection, addDoc, runTransaction, serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
    import {
      getAuth, signInAnonymously, onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

    // ---- Firebase config (same project) ----
    const firebaseConfig = {
      apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
      authDomain: "bible-game-246c0.firebaseapp.com",
      databaseURL: "https://bible-game-246c0-default-rtdb.firebaseio.com",
      projectId: "bible-game-246c0",
      storageBucket: "bible-game-246c0.firebasestorage.app",
      messagingSenderId: "959619818996",
      appId: "1:959619818996:web:5a9fbf492e23c765e445a1",
      measurementId: "G-8PR6LVKSH3"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    // ---- URL params from Game Hub ----
    const params = new URLSearchParams(window.location.search);
    const lobbyId = params.get("gameId");
    const username = (params.get("username") || "").trim();

    // ---- DOM refs ----
    const youNameEl = document.getElementById("youName");
    const oppNameEl = document.getElementById("oppName");
    const youRoleEl = document.getElementById("youRole");
    const oppRoleEl = document.getElementById("oppRole");
    const statusEl = document.getElementById("statusText");
    const gameIdLabelEl = document.getElementById("gameIdLabel");
    const yourHpFillEl = document.getElementById("yourHpFill");
    const oppHpFillEl = document.getElementById("oppHpFill");
    const yourHpTextEl = document.getElementById("yourHpText");
    const oppHpTextEl = document.getElementById("oppHpText");
    const goldEl = document.getElementById("goldAmount");
    const genLevelEl = document.getElementById("genLevel");
    const buffTextEl = document.getElementById("buffText");
    const boardEl = document.getElementById("board");
    const boardMsgEl = document.getElementById("boardMessage");
    const fullBtn = document.getElementById("fullBtn");
    const towerRowEl = document.getElementById("towerRow");
    const buyTowerBtn = document.getElementById("buyTowerBtn");
    const tier1Btn = document.getElementById("tier1Btn");
    const tier2Btn = document.getElementById("tier2Btn");
    const tier3Btn = document.getElementById("tier3Btn");
    const unitRowEl = document.getElementById("unitRow");
    const genBtn = document.getElementById("genBtn");
    const scanBtn = document.getElementById("scanBtn");
    const genCostLabelEl = document.getElementById("genCostLabel");
    const scanCostLabelEl = document.getElementById("scanCostLabel");
    const toastEl = document.getElementById("toast");
    const overlayEl = document.getElementById("errorOverlay");
    const overlayMsgEl = document.getElementById("errorMessage");
    const towerOverlayEl = document.getElementById("towerOverlay");
    const towerOverlayTitleEl = document.getElementById("towerOverlayTitle");
    const towerOverlayBodyEl = document.getElementById("towerOverlayBody");
    const towerOverlayActionsEl = document.getElementById("towerOverlayActions");
    const towerOverlayCloseBtn = document.getElementById("towerOverlayClose");

    // ---- Game constants ----
    const MAX_BASE_HP = 400;
    const MAX_TOWERS = 4;

    const ELEMENT_COUNTER = {
      fire: "stone",
      stone: "ice",
      ice: "fire"
    };

    const UNITS = {
      // Tier 1
      f1: { id:"f1", name:"Emberlings", emoji:"üî•", element:"fire", tier:1,
            cost:20, count:5, hp:10, damage:5, killGold:3, hitGold:3, special:null },
      i1: { id:"i1", name:"Frost Scouts", emoji:"‚ùÑÔ∏è", element:"ice", tier:1,
            cost:22, count:4, hp:11, damage:6, killGold:3, hitGold:3, special:"heal-lite" },
      s1: { id:"s1", name:"Pebble Guard", emoji:"ü™®", element:"stone", tier:1,
            cost:25, count:3, hp:14, damage:8, killGold:4, hitGold:3, special:null },
      // Tier 2
      f2: { id:"f2", name:"Flame Knights", emoji:"‚öîÔ∏è", element:"fire", tier:2,
            cost:40, count:4, hp:18, damage:15, killGold:5, hitGold:5, special:null },
      i2: { id:"i2", name:"Aurora Priests", emoji:"üíß", element:"ice", tier:2,
            cost:42, count:4, hp:18, damage:14, killGold:5, hitGold:5, special:"heal" },
      s2: { id:"s2", name:"Shard Swarm", emoji:"üåÄ", element:"stone", tier:2,
            cost:45, count:4, hp:16, damage:14, killGold:5, hitGold:5, special:"split" },
      // Tier 3
      f3: { id:"f3", name:"Inferno Titan", emoji:"üåã", element:"fire", tier:3,
            cost:70, count:3, hp:28, damage:30, killGold:8, hitGold:7, special:null },
      i3: { id:"i3", name:"Glacier Warden", emoji:"üßä", element:"ice", tier:3,
            cost:72, count:3, hp:30, damage:28, killGold:8, hitGold:7, special:"heal-lite" },
      s3: { id:"s3", name:"Obsidian Colossus", emoji:"üóø", element:"stone", tier:3,
            cost:80, count:4, hp:30, damage:30, killGold:9, hitGold:8, special:"split" }
    };

    const TOWER_POWER_PER_LEVEL = [0, 40, 65, 95]; // index 1..3
    const BASE_INCOME_PER_SEC = 3.5;

    const SCAN_COST = 35;
    const SCAN_BUFF_DURATION_MS = 20000; // 20s
    const MOMENTUM_DURATION_MS = 15000; // 15s
    const TOWER_BUFF_DURATION_MS = 12000; // 12s

    // ---- Local state ----
    const state = {
      seat: null,           // 1, 2, or 'spec'
      isSpectator: false,
      isHost: false,
      myName: username || "You",
      oppName: "Opponent",
      gameRef: null,
      cmdsRef: null,
      gameData: null,
      currentTier: 1,
      selectedTowerIndex: null
    };

    // ---- Basic helpers ----
    function showFatal(msg){
      overlayMsgEl.textContent = msg;
      overlayEl.classList.remove("hidden");
      statusEl.textContent = msg;
      disableAllActions();
    }
    function disableAllActions(){
      document.querySelectorAll(".btn, .tiny-btn, .tier-btn").forEach(b=>{ b.disabled = true; });
    }

    let toastTimer = null;
    function showToast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      if (toastTimer) clearTimeout(toastTimer);
      toastTimer = setTimeout(()=> toastEl.classList.remove("show"), 1700);
    }

    // ---- Fullscreen ----
    fullBtn.addEventListener("click", () => {
      if (!document.fullscreenElement){
        document.documentElement.requestFullscreen?.();
      } else {
        document.exitFullscreen?.();
      }
    });

    // ---- Auth + init ----
    if (!lobbyId || !username){
      showFatal("Missing lobby or username. Launch this game from the Game Hub.");
    } else {
      gameIdLabelEl.textContent = `Lobby: ${lobbyId.slice(0,8)}‚Ä¶`;
      statusEl.textContent = "Signing in‚Ä¶";
      signInAnonymously(auth).catch(err => {
        console.error("Anon sign-in failed", err);
        showFatal("Authentication error. Please reopen via the hub.");
      });

      onAuthStateChanged(auth, (user) => {
        if (!user) return;
        initFromLobby().catch(err => {
          console.error(err);
          showFatal("Error joining this match. It may have been closed.");
        });
      });
    }

    async function initFromLobby(){
      statusEl.textContent = "Connecting to lobby‚Ä¶";
      const lobbyRef = doc(db, "lobbies", lobbyId);
      const lobbySnap = await getDoc(lobbyRef);
      if (!lobbySnap.exists()){
        showFatal("Lobby not found. It may have expired.");
        return;
      }
      const lobby = lobbySnap.data();
      const players = Array.isArray(lobby.players) ? lobby.players : [];
      const hostName = lobby.host || null;

      const myIndex = players.indexOf(username);
      if (myIndex === -1){
        showFatal("You are not listed as a player in this lobby.");
        return;
      }

      // Seating: first two are players, rest spectators
      if (myIndex === 0) state.seat = 1;
      else if (myIndex === 1) state.seat = 2;
      else {
        state.seat = "spec";
        state.isSpectator = true;
      }
      state.isHost = (username === hostName);
      state.myName = username;
      state.oppName = (state.seat === 1 ? players[1] : players[0]) || "Waiting‚Ä¶";

      youNameEl.textContent = state.myName;
      oppNameEl.textContent = state.oppName;
      youRoleEl.textContent = state.isSpectator ? "Spectating" : (state.isHost ? "Host" : "Guest");
      oppRoleEl.textContent = state.oppName === "Waiting‚Ä¶" ? "Not joined" :
                              (state.seat === 1 ? "Seat 2" : "Seat 1");

      if (state.isSpectator){
        statusEl.textContent = "You are spectating this match.";
      } else {
        statusEl.textContent = "Connected. Build towers and send waves!";
      }

      // Game doc under /games_basewar/{lobbyId}
      state.gameRef = doc(db, "games_basewar", lobbyId);
      state.cmdsRef = collection(state.gameRef, "commands");

      const gameSnap = await getDoc(state.gameRef);
      if (!gameSnap.exists() && state.isHost){
        await setDoc(state.gameRef, {
          createdAt: serverTimestamp(),
          lobbyId,
          p1Name: players[0] || null,
          p2Name: players[1] || null,
          status: "playing",
          maxBase: MAX_BASE_HP,
          base1: MAX_BASE_HP,
          base2: MAX_BASE_HP,
          gold1: 100,
          gold2: 100,
          gen1: 1,
          gen2: 1,
          incomePerSec1: BASE_INCOME_PER_SEC,
          incomePerSec2: BASE_INCOME_PER_SEC,
          lastIncomeMs1: Date.now(),
          lastIncomeMs2: Date.now(),
          momentumUntil1: 0,
          momentumUntil2: 0,
          towerBuffUntil1: 0,
          towerBuffUntil2: 0,
          scanBuffUntil1: 0,
          scanBuffUntil2: 0,
          scanBuffElement1: null,
          scanBuffElement2: null,
          towers1: [],
          towers2: [],
          lastCmdTs: 0
        }, { merge:true });
      }

      // Listen to game state
      onSnapshot(state.gameRef, (snap) => {
        if (!snap.exists()) return;
        state.gameData = snap.data();
        updateFromGame();
      });

      // Listen to commands for visuals / host effects
      onSnapshot(state.cmdsRef, (snap) => {
        snap.docChanges().forEach(ch => {
          if (ch.type !== "added") return;
          const cmd = ch.doc.data();
          handleCommandVisual(cmd);
          if (state.isHost){
            processCommand(cmd).catch(err => console.error("processCommand error", err));
          }
        });
      });

      setupLocalUI();
    }

    // ---- UI update ----
    function updateFromGame(){
      const d = state.gameData;
      if (!d) return;

      const base1 = d.base1 ?? MAX_BASE_HP;
      const base2 = d.base2 ?? MAX_BASE_HP;
      const gold1 = d.gold1 ?? 0;
      const gold2 = d.gold2 ?? 0;
      const gen1 = d.gen1 ?? 1;
      const gen2 = d.gen2 ?? 1;
      const status = d.status || "playing";

      let myBase, oppBase, myGold, myGen, side;
      if (state.seat === 1){
        side = 1;
        myBase = base1; oppBase = base2;
        myGold = gold1; myGen = gen1;
      } else if (state.seat === 2){
        side = 2;
        myBase = base2; oppBase = base1;
        myGold = gold2; myGen = gen2;
      } else {
        // spectator: mirror p1 as "left"
        side = 1;
        myBase = base1; oppBase = base2;
        myGold = 0; myGen = gen1;
      }

      const myPct = Math.max(0, Math.min(100, (myBase / MAX_BASE_HP) * 100));
      const oppPct = Math.max(0, Math.min(100, (oppBase / MAX_BASE_HP) * 100));
      yourHpFillEl.style.width = myPct + "%";
      oppHpFillEl.style.width = oppPct + "%";
      yourHpTextEl.textContent = String(myBase);
      oppHpTextEl.textContent = String(oppBase);

      if (!state.isSpectator){
        goldEl.textContent = String(Math.floor(myGold));
        genLevelEl.textContent = String(myGen);
      } else {
        goldEl.textContent = "-";
        genLevelEl.textContent = String(myGen);
      }

      // Buff text
      const now = Date.now();
      let buffs = [];
      if (!state.isSpectator){
        const mKey = side === 1 ? "momentumUntil1" : "momentumUntil2";
        if ((d[mKey] ?? 0) > now) buffs.push("Momentum +10% gold");
        const scanKey = side === 1 ? "scanBuffUntil1" : "scanBuffUntil2";
        const scanElKey = side === 1 ? "scanBuffElement1" : "scanBuffElement2";
        if ((d[scanKey] ?? 0) > now && d[scanElKey]){
          buffs.push(`Scout: ${capitalize(d[scanElKey])} units 10% cheaper`);
        }
      }
      const buffText = buffs.length ? buffs.join(" ‚Ä¢ ") : "No buffs";
      buffTextEl.textContent = buffText;

      // Towers
      renderTowers();

      // Board status / victory
      if (status === "ended" || myBase <= 0 || oppBase <= 0){
        let msg = "Battle over.";
        if (!state.isSpectator){
          if (myBase <= 0 && oppBase <= 0) msg = "Draw!";
          else if (myBase <= 0) msg = "Defeat!";
          else if (oppBase <= 0) msg = "Victory!";
        } else {
          if (base1 <= 0 && base2 <= 0) msg = "Draw!";
          else if (base1 <= 0) msg = `${state.p2Name || "Player 2"} wins!`;
          else if (base2 <= 0) msg = `${state.p1Name || "Player 1"} wins!`;
        }
        boardMsgEl.textContent = msg;
        statusEl.textContent = msg;
        disableAllActions();
      } else {
        boardMsgEl.textContent = "Send elemental waves and upgrade towers to break the enemy base.";
      }

      // Update costs labels
      updateCostLabels();
    }

    function renderTowers(){
      const d = state.gameData;
      if (!d) return;
      const side = (state.seat === 2) ? 2 : 1; // spectator sees p1's towers
      const key = side === 1 ? "towers1" : "towers2";
      const towers = Array.isArray(d[key]) ? d[key] : [];
      towerRowEl.innerHTML = "";

      towers.forEach((t, idx) => {
        const pill = document.createElement("button");
        pill.type = "button";
        pill.className = "tower-pill";
        pill.dataset.index = String(idx);

        const dot = document.createElement("span");
        dot.className = "tower-dot";
        if (t.element === "fire") dot.classList.add("fire");
        else if (t.element === "ice") dot.classList.add("ice");
        else if (t.element === "stone") dot.classList.add("stone");
        else {
          pill.classList.add("empty");
        }

        const label = document.createElement("span");
        if (!t.element || t.element === "none" || t.level === 0){
          label.textContent = "Empty slot";
        } else {
          label.textContent = `${capitalize(t.element)} Lv${t.level || 1}`;
        }

        pill.appendChild(dot);
        pill.appendChild(label);
        towerRowEl.appendChild(pill);
      });

      // If we can still buy towers, show a faint ghost slot
      if (!state.isSpectator && towers.length < MAX_TOWERS){
        const ghost = document.createElement("div");
        ghost.className = "tower-pill empty";
        ghost.innerHTML = "<span class='tower-dot'></span><span>New slot‚Ä¶</span>";
        towerRowEl.appendChild(ghost);
      }
    }

    function updateCostLabels(){
      const d = state.gameData;
      if (!d) return;
      const side = (state.seat === 2) ? 2 : 1;

      // Gen cost
      const genCost = calcGenCost(d, side);
      genCostLabelEl.textContent = `(${genCost}g)`;

      // Scan cost
      scanCostLabelEl.textContent = `(${SCAN_COST}g)`;

      // Unit buttons (if any rendered)
      const now = Date.now();
      const scanUntilKey = side === 1 ? "scanBuffUntil1" : "scanBuffUntil2";
      const scanElKey = side === 1 ? "scanBuffElement1" : "scanBuffElement2";
      const buffActive = (d[scanUntilKey] ?? 0) > now;
      const buffElement = buffActive ? d[scanElKey] : null;

      document.querySelectorAll("[data-unit-id]").forEach(btn => {
        const id = btn.dataset.unitId;
        const u = UNITS[id];
        if (!u) return;
        const baseCost = u.cost;
        let cost = baseCost;
        if (buffActive && buffElement && u.element === buffElement){
          cost = Math.floor(baseCost * 0.9);
        }
        const costSpan = btn.querySelector(".small");
        if (costSpan) costSpan.textContent = `${cost}g`;
      });
    }

    function setupLocalUI(){
      // Spectators cannot act
      if (state.isSpectator){
        disableAllActions();
      }

      // Tier buttons
      function setTier(t){
        state.currentTier = t;
        tier1Btn.setAttribute("aria-pressed", t === 1 ? "true" : "false");
        tier2Btn.setAttribute("aria-pressed", t === 2 ? "true" : "false");
        tier3Btn.setAttribute("aria-pressed", t === 3 ? "true" : "false");
        renderUnitButtons();
        updateCostLabels();
      }
      tier1Btn.addEventListener("click", ()=> setTier(1));
      tier2Btn.addEventListener("click", ()=> setTier(2));
      tier3Btn.addEventListener("click", ()=> setTier(3));
      renderUnitButtons();

      // Buttons
      if (!state.isSpectator){
        buyTowerBtn.addEventListener("click", onBuyTowerClick);
        towerRowEl.addEventListener("click", onTowerRowClick);
        genBtn.addEventListener("click", onGenUpgradeClick);
        scanBtn.addEventListener("click", onScanClick);
        unitRowEl.addEventListener("click", onUnitRowClick);
      } else {
        buyTowerBtn.disabled = true;
        genBtn.disabled = true;
        scanBtn.disabled = true;
      }

      towerOverlayCloseBtn.addEventListener("click", hideTowerOverlay);
    }

    function renderUnitButtons(){
      unitRowEl.innerHTML = "";
      const tier = state.currentTier;
      const ids = Object.values(UNITS).filter(u => u.tier === tier).map(u => u.id);
      ids.forEach(id => {
        const u = UNITS[id];
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "btn";
        btn.dataset.unitId = id;

        const left = document.createElement("span");
        left.textContent = `${u.emoji} ${u.name}`;
        const right = document.createElement("span");
        right.className = "small";
        right.textContent = `${u.cost}g`;

        btn.appendChild(left);
        btn.appendChild(right);
        unitRowEl.appendChild(btn);
      });
    }

    // ---- Local UI handlers ----
    function onUnitRowClick(ev){
      const btn = ev.target.closest("[data-unit-id]");
      if (!btn || state.isSpectator || !state.gameData) return;
      const id = btn.dataset.unitId;
      const d = state.gameData;
      const side = (state.seat === 2) ? 2 : 1;
      const cost = calcWaveCost(d, side, id);
      const goldKey = side === 1 ? "gold1" : "gold2";
      const currentGold = d[goldKey] ?? 0;
      if (currentGold < cost){
        showToast("Not enough gold for that wave.");
        return;
      }
      sendWave(id).catch(err => {
        console.error(err);
        showToast("Failed to send wave.");
      });
    }

    function onGenUpgradeClick(){
      if (state.isSpectator || !state.gameData) return;
      const d = state.gameData;
      const side = (state.seat === 2) ? 2 : 1;
      const cost = calcGenCost(d, side);
      const goldKey = side === 1 ? "gold1" : "gold2";
      const currentGold = d[goldKey] ?? 0;
      if (currentGold < cost){
        showToast("Not enough gold to upgrade generator.");
        return;
      }
      sendGenUpgrade().catch(err => {
        console.error(err);
        showToast("Failed to upgrade generator.");
      });
    }

    function onScanClick(){
      if (state.isSpectator || !state.gameData) return;
      const d = state.gameData;
      const side = (state.seat === 2) ? 2 : 1;
      const goldKey = side === 1 ? "gold1" : "gold2";
      const currentGold = d[goldKey] ?? 0;
      if (currentGold < SCAN_COST){
        showToast("Not enough gold to scout.");
        return;
      }
      showScanInfo(); // immediate info
      sendScan().catch(err => {
        console.error(err);
        showToast("Failed to send scout.");
      });
    }

    function onBuyTowerClick(){
      if (state.isSpectator || !state.gameData) return;
      const d = state.gameData;
      const side = (state.seat === 2) ? 2 : 1;
      const towersKey = side === 1 ? "towers1" : "towers2";
      const towers = Array.isArray(d[towersKey]) ? d[towersKey] : [];
      if (towers.length >= MAX_TOWERS){
        showToast("Tower cap reached.");
        return;
      }
      const cost = calcTowerSlotCost(d, side);
      const goldKey = side === 1 ? "gold1" : "gold2";
      const currentGold = d[goldKey] ?? 0;
      if (currentGold < cost){
        showToast("Not enough gold for a new tower slot.");
        return;
      }
      sendTowerSlot().catch(err => {
        console.error(err);
        showToast("Failed to buy tower slot.");
      });
    }

    function onTowerRowClick(ev){
      if (state.isSpectator || !state.gameData) return;
      const pill = ev.target.closest(".tower-pill");
      if (!pill || !pill.dataset.index) return;
      const idx = parseInt(pill.dataset.index, 10);
      openTowerOverlay(idx);
    }

    // ---- Cost helpers (use same formulas as host) ----
    function calcGenCost(d, side){
      const genKey = side === 1 ? "gen1" : "gen2";
      const gen = d[genKey] ?? 1;
      if (gen >= 4) return Infinity;
      return 60 + (gen - 1) * 40; // 60,100,140
    }

    function calcTowerSlotCost(d, side){
      const towersKey = side === 1 ? "towers1" : "towers2";
      const towers = Array.isArray(d[towersKey]) ? d[towersKey] : [];
      const base = 45;
      return base + towers.length * 25; // 45,70,95,120
    }

    function calcTowerUpgradeCost(d, side, index){
      const towersKey = side === 1 ? "towers1" : "towers2";
      const towers = Array.isArray(d[towersKey]) ? d[towersKey] : [];
      const t = towers[index];
      if (!t) return Infinity;
      const lvl = t.level || 0;
      if (lvl >= 3) return Infinity;
      return lvl === 0 ? 30 : (lvl === 1 ? 50 : 80); // if someone path-set with 0, treat as 30
    }

    function calcWaveCost(d, side, unitId){
      const u = UNITS[unitId];
      if (!u) return Infinity;
      const baseCost = u.cost;
      const now = Date.now();
      const scanUntilKey = side === 1 ? "scanBuffUntil1" : "scanBuffUntil2";
      const scanElKey = side === 1 ? "scanBuffElement1" : "scanBuffElement2";
      const buffActive = (d[scanUntilKey] ?? 0) > now;
      const buffElement = buffActive ? d[scanElKey] : null;
      let cost = baseCost;
      if (buffActive && buffElement && u.element === buffElement){
        cost = Math.floor(baseCost * 0.9);
      }
      return cost;
    }

    // ---- Commands: send from client ----
    async function sendWave(unitId){
      if (!state.cmdsRef || state.isSpectator) return;
      const side = (state.seat === 2) ? 2 : 1;
      await addDoc(state.cmdsRef, {
        cmd: "wave",
        side,
        unitId,
        createdAt: serverTimestamp()
      });
      spawnUnitVisual(unitId, side, /*fromMe*/ true);
    }

    async function sendGenUpgrade(){
      if (!state.cmdsRef || state.isSpectator) return;
      const side = (state.seat === 2) ? 2 : 1;
      await addDoc(state.cmdsRef, {
        cmd: "gen",
        side,
        createdAt: serverTimestamp()
      });
    }

    async function sendScan(){
      if (!state.cmdsRef || state.isSpectator) return;
      const side = (state.seat === 2) ? 2 : 1;
      await addDoc(state.cmdsRef, {
        cmd: "scan",
        side,
        createdAt: serverTimestamp()
      });
    }

    async function sendTowerSlot(){
      if (!state.cmdsRef || state.isSpectator) return;
      const side = (state.seat === 2) ? 2 : 1;
      await addDoc(state.cmdsRef, {
        cmd: "towerSlot",
        side,
        createdAt: serverTimestamp()
      });
    }

    async function sendTowerPath(index, element){
      if (!state.cmdsRef || state.isSpectator) return;
      const side = (state.seat === 2) ? 2 : 1;
      await addDoc(state.cmdsRef, {
        cmd: "towerPath",
        side,
        index,
        element,
        createdAt: serverTimestamp()
      });
      hideTowerOverlay();
    }

    async function sendTowerUpgrade(index){
      if (!state.cmdsRef || state.isSpectator) return;
      const side = (state.seat === 2) ? 2 : 1;
      await addDoc(state.cmdsRef, {
        cmd: "towerUp",
        side,
        index,
        createdAt: serverTimestamp()
      });
      hideTowerOverlay();
    }

    // ---- Host: process commands on gameRef ----
    async function processCommand(cmd){
      if (!state.isHost || !state.gameRef) return;

      await runTransaction(db, async (tx) => {
        const snap = await tx.get(state.gameRef);
        if (!snap.exists()) return;
        const d = snap.data();
        const cmdTs = cmd.createdAt && cmd.createdAt.toMillis ? cmd.createdAt.toMillis() : 0;
        const lastTs = d.lastCmdTs ?? 0;
        if (cmdTs <= lastTs) return; // already processed

        const nowMs = Date.now();
        const updates = {};
        // Tick passive income for both sides
        applyIncome(d, updates, 1, nowMs);
        applyIncome(d, updates, 2, nowMs);

        switch (cmd.cmd){
          case "wave":
            applyWave(d, updates, cmd, nowMs);
            break;
          case "gen":
            applyGenUpgrade(d, updates, cmd, nowMs);
            break;
          case "towerSlot":
            applyTowerSlot(d, updates, cmd, nowMs);
            break;
          case "towerPath":
            applyTowerPath(d, updates, cmd, nowMs);
            break;
          case "towerUp":
            applyTowerUpgrade(d, updates, cmd, nowMs);
            break;
          case "scan":
            applyScan(d, updates, cmd, nowMs);
            break;
        }

        updates.lastCmdTs = cmdTs;
        tx.update(state.gameRef, updates);
      });
    }

    function applyIncome(d, updates, side, nowMs){
      const goldKey = side === 1 ? "gold1" : "gold2";
      const incomeKey = side === 1 ? "incomePerSec1" : "incomePerSec2";
      const lastKey = side === 1 ? "lastIncomeMs1" : "lastIncomeMs2";
      const momentumKey = side === 1 ? "momentumUntil1" : "momentumUntil2";

      const last = d[lastKey] ?? nowMs;
      let dt = (nowMs - last) / 1000;
      if (dt <= 0.1){
        updates[lastKey] = nowMs;
        d[lastKey] = nowMs;
        return;
      }
      dt = Math.min(dt, 30); // clamp
      const baseRate = d[incomeKey] ?? BASE_INCOME_PER_SEC;
      let rate = baseRate;
      const hasMomentum = (d[momentumKey] ?? 0) > nowMs;
      if (hasMomentum) rate *= 1.1; // 10% momentum bonus

      const delta = Math.floor(rate * dt);
      if (delta > 0){
        const newGold = (d[goldKey] ?? 0) + delta;
        d[goldKey] = newGold;
        updates[goldKey] = newGold;
      }
      d[lastKey] = nowMs;
      updates[lastKey] = nowMs;
    }

    function applyWave(d, updates, cmd, nowMs){
      const side = cmd.side === 2 ? 2 : 1;
      const enemy = side === 1 ? 2 : 1;
      const unit = UNITS[cmd.unitId];
      if (!unit) return;

      const goldKeyAtk = side === 1 ? "gold1" : "gold2";
      const goldKeyDef = enemy === 1 ? "gold1" : "gold2";
      let goldAtk = d[goldKeyAtk] ?? 0;
      let goldDef = d[goldKeyDef] ?? 0;

      const cost = getWaveCostFromData(d, side, unit, nowMs);
      if (goldAtk < cost){
        // Not enough gold; ignore
        return;
      }
      goldAtk -= cost;

      const baseKeyEnemy = enemy === 1 ? "base1" : "base2";
      const baseKeyAtk = side === 1 ? "base1" : "base2";
      const genKeyAtk = side === 1 ? "gen1" : "gen2";
      const genKeyDef = enemy === 1 ? "gen1" : "gen2";
      const towersKeyDef = enemy === 1 ? "towers1" : "towers2";

      const maxBase = d.maxBase ?? MAX_BASE_HP;
      const oldEnemyBase = d[baseKeyEnemy] ?? maxBase;
      const myBase = d[baseKeyAtk] ?? maxBase;
      const enemyBase = oldEnemyBase;

      const atkGen = d[genKeyAtk] ?? 1;
      const defGen = d[genKeyDef] ?? 1;
      const towersDef = Array.isArray(d[towersKeyDef]) ? d[towersKeyDef] : [];

      // Defense power from towers
      let defensePower = computeDefensePower(d, towersDef, unit, defGen, enemy, nowMs);

      // Effective wave stats
      let effectiveCount = unit.count;
      let hpPerUnit = unit.hp;
      if (unit.special === "split"){
        effectiveCount = Math.round(effectiveCount * 1.6);
      }
      let rawKills = Math.round(defensePower / (hpPerUnit || 1));
      let kills = Math.min(effectiveCount, rawKills);
      if (unit.special === "heal" || unit.special === "heal-lite"){
        kills = Math.max(0, Math.round(kills * (unit.special === "heal" ? 0.7 : 0.8)));
      }
      const survivors = Math.max(0, effectiveCount - kills);

      // Damage
      let dmgMult = 1 + (atkGen - 1) * 0.2;
      // mild underdog help: if my base far behind, slight more damage
      if (myBase + 60 < enemyBase){
        dmgMult *= 1.1;
      }
      let damage = Math.round(survivors * unit.damage * dmgMult);
      if (damage <= 0 && survivors > 0) damage = 1;

      // Gold rewards
      const killGold = kills * unit.killGold;
      const hitGold = survivors * unit.hitGold;
      goldAtk += hitGold;
      goldDef += killGold;

      let newEnemyBase = Math.max(0, enemyBase - damage);

      d[goldKeyAtk] = goldAtk; updates[goldKeyAtk] = goldAtk;
      d[goldKeyDef] = goldDef; updates[goldKeyDef] = goldDef;
      d[baseKeyEnemy] = newEnemyBase; updates[baseKeyEnemy] = newEnemyBase;

      // Momentum buff for attacker
      if (damage > 0){
        const mKey = side === 1 ? "momentumUntil1" : "momentumUntil2";
        const until = nowMs + MOMENTUM_DURATION_MS;
        d[mKey] = until;
        updates[mKey] = until;
      }

      // Tower buff when base crosses 10% thresholds
      if (damage > 0 && newEnemyBase > 0){
        const chunk = maxBase / 10;
        const oldBucket = Math.floor(oldEnemyBase / chunk);
        const newBucket = Math.floor(newEnemyBase / chunk);
        if (newBucket < oldBucket){
          const buffKey = enemy === 1 ? "towerBuffUntil1" : "towerBuffUntil2";
          const until = nowMs + TOWER_BUFF_DURATION_MS;
          d[buffKey] = until;
          updates[buffKey] = until;
        }
      }

      if (newEnemyBase <= 0){
        d.status = "ended";
        updates.status = "ended";
      }
    }

    function computeDefensePower(d, towers, unit, genDef, side, nowMs){
      let total = 0;
      for (const t of towers){
        const lvl = t.level || 0;
        if (!lvl) continue;
        let p = TOWER_POWER_PER_LEVEL[lvl] || 0;
        const te = t.element;
        const ue = unit.element;
        if (te && ue){
          if (te === ELEMENT_COUNTER[ue]){
            p *= 1.25; // tower strong vs this unit
          } else if (ue === ELEMENT_COUNTER[te]){
            p *= 0.8; // tower weak vs this unit
          }
        }
        total += p;
      }
      // scale by defender generator
      total *= 1 + (genDef - 1) * 0.18;

      // tower buff from low HP
      const buffKey = side === 1 ? "towerBuffUntil1" : "towerBuffUntil2";
      if ((d[buffKey] ?? 0) > nowMs){
        total *= 1.25;
      }
      return total;
    }

    function getWaveCostFromData(d, side, unit, nowMs){
      const baseCost = unit.cost;
      const scanUntilKey = side === 1 ? "scanBuffUntil1" : "scanBuffUntil2";
      const scanElKey = side === 1 ? "scanBuffElement1" : "scanBuffElement2";
      const buffActive = (d[scanUntilKey] ?? 0) > nowMs;
      const buffElement = buffActive ? d[scanElKey] : null;
      let cost = baseCost;
      if (buffActive && buffElement && unit.element === buffElement){
        cost = Math.floor(baseCost * 0.9);
      }
      return cost;
    }

    function applyGenUpgrade(d, updates, cmd, nowMs){
      const side = cmd.side === 2 ? 2 : 1;
      const goldKey = side === 1 ? "gold1" : "gold2";
      const genKey = side === 1 ? "gen1" : "gen2";
      const incomeKey = side === 1 ? "incomePerSec1" : "incomePerSec2";

      let gold = d[goldKey] ?? 0;
      let gen = d[genKey] ?? 1;
      if (gen >= 4) return;
      const cost = 60 + (gen - 1) * 40;
      if (gold < cost) return;
      gold -= cost;
      gen += 1;
      const income = (d[incomeKey] ?? BASE_INCOME_PER_SEC) + 1.3;

      d[goldKey] = gold; updates[goldKey] = gold;
      d[genKey] = gen; updates[genKey] = gen;
      d[incomeKey] = income; updates[incomeKey] = income;
    }

    function applyTowerSlot(d, updates, cmd, nowMs){
      const side = cmd.side === 2 ? 2 : 1;
      const goldKey = side === 1 ? "gold1" : "gold2";
      const towersKey = side === 1 ? "towers1" : "towers2";

      let gold = d[goldKey] ?? 0;
      const towers = Array.isArray(d[towersKey]) ? d[towersKey].slice() : [];
      if (towers.length >= MAX_TOWERS) return;

      const cost = calcTowerSlotCost(d, side);
      if (gold < cost) return;
      gold -= cost;

      towers.push({ element:"none", level:0 });
      d[goldKey] = gold; updates[goldKey] = gold;
      d[towersKey] = towers; updates[towersKey] = towers;
    }

    function applyTowerPath(d, updates, cmd, nowMs){
      const side = cmd.side === 2 ? 2 : 1;
      const towersKey = side === 1 ? "towers1" : "towers2";
      const towers = Array.isArray(d[towersKey]) ? d[towersKey].slice() : [];
      const idx = cmd.index;
      const element = cmd.element;
      if (typeof idx !== "number" || !towers[idx]) return;
      if (!["fire","ice","stone"].includes(element)) return;

      const t = towers[idx];
      if (t.element && t.element !== "none" && t.level >= 1){
        // already pathed; ignore
        return;
      }
      t.element = element;
      t.level = 1;
      towers[idx] = t;
      d[towersKey] = towers;
      updates[towersKey] = towers;
    }

    function applyTowerUpgrade(d, updates, cmd, nowMs){
      const side = cmd.side === 2 ? 2 : 1;
      const goldKey = side === 1 ? "gold1" : "gold2";
      const towersKey = side === 1 ? "towers1" : "towers2";
      let gold = d[goldKey] ?? 0;
      const towers = Array.isArray(d[towersKey]) ? d[towersKey].slice() : [];
      const idx = cmd.index;
      if (typeof idx !== "number" || !towers[idx]) return;
      const t = towers[idx];
      const lvl = t.level || 0;
      if (!t.element || t.element === "none") return;
      if (lvl >= 3) return;
      const cost = lvl === 0 ? 30 : (lvl === 1 ? 50 : 80);
      if (gold < cost) return;

      gold -= cost;
      t.level = lvl + 1;
      towers[idx] = t;

      d[goldKey] = gold; updates[goldKey] = gold;
      d[towersKey] = towers; updates[towersKey] = towers;
    }

    function applyScan(d, updates, cmd, nowMs){
      const side = cmd.side === 2 ? 2 : 1;
      const enemy = side === 1 ? 2 : 1;
      const goldKey = side === 1 ? "gold1" : "gold2";
      let gold = d[goldKey] ?? 0;
      if (gold < SCAN_COST) return;
      gold -= SCAN_COST;

      const towersKeyEnemy = enemy === 1 ? "towers1" : "towers2";
      const towersEnemy = Array.isArray(d[towersKeyEnemy]) ? d[towersKeyEnemy] : [];

      // Count enemy towers by element
      const counts = {fire:0,ice:0,stone:0};
      for (const t of towersEnemy){
        if (t.element === "fire") counts.fire++;
        else if (t.element === "ice") counts.ice++;
        else if (t.element === "stone") counts.stone++;
      }
      let dominant = null;
      let best = 0;
      for (const k of ["fire","ice","stone"]){
        if (counts[k] > best){
          best = counts[k];
          dominant = k;
        }
      }

      let buffElement = null;
      if (dominant){
        buffElement = ELEMENT_COUNTER[dominant] || null;
      }

      const scanBuffUntilKey = side === 1 ? "scanBuffUntil1" : "scanBuffUntil2";
      const scanBuffElementKey = side === 1 ? "scanBuffElement1" : "scanBuffElement2";

      const until = nowMs + SCAN_BUFF_DURATION_MS;
      d[goldKey] = gold; updates[goldKey] = gold;
      d[scanBuffUntilKey] = until; updates[scanBuffUntilKey] = until;
      d[scanBuffElementKey] = buffElement; updates[scanBuffElementKey] = buffElement;
    }

    // ---- Command visuals for all clients ----
    function handleCommandVisual(cmd){
      if (cmd.cmd === "wave"){
        const fromSide = cmd.side === 2 ? 2 : 1;
        const fromMe = (!state.isSpectator &&
                        ((state.seat === 1 && fromSide === 1) ||
                         (state.seat === 2 && fromSide === 2)));
        spawnUnitVisual(cmd.unitId, fromSide, fromMe);
      }
      if (cmd.cmd === "scan"){
        // Small flavor: show scan text
        if (!state.isSpectator){
          const mySide = (state.seat === 2) ? 2 : 1;
          if (cmd.side === mySide){
            showToast("Scout launched ‚Äî counter window open!");
          } else {
            // enemy scanned you
            showToast("Enemy scout is scanning your defenses‚Ä¶");
          }
        }
      }
    }

    function spawnUnitVisual(unitId, fromSide, fromMe){
      const u = UNITS[unitId];
      if (!u) return;
      const lanes = boardEl.querySelectorAll(".lane");
      if (!lanes.length) return;
      const idx = Math.floor(Math.random()*lanes.length);
      const lane = lanes[idx];

      const unitDiv = document.createElement("div");
      unitDiv.className = "unit";
      unitDiv.classList.add(u.element || "fire");
      unitDiv.classList.add(fromSide === 1 ? "from-me" : "from-enemy");
      unitDiv.textContent = u.emoji;

      const boardRect = boardEl.getBoundingClientRect();
      const laneRect = lane.getBoundingClientRect();
      const y = laneRect.top + laneRect.height/2 - boardRect.top - 10;
      const x = fromSide === 1 ? 10 : (boardRect.width - 30);

      unitDiv.style.top = y + "px";
      unitDiv.style.left = x + "px";

      boardEl.appendChild(unitDiv);
      setTimeout(()=> unitDiv.remove(), 1800);
    }

    // ---- Tower overlay ----
    function openTowerOverlay(index){
      const d = state.gameData;
      if (!d) return;
      const side = (state.seat === 2) ? 2 : 1;
      const towersKey = side === 1 ? "towers1" : "towers2";
      const towers = Array.isArray(d[towersKey]) ? d[towersKey] : [];
      const t = towers[index];
      if (!t) return;

      state.selectedTowerIndex = index;
      towerOverlayActionsEl.innerHTML = "";

      if (!t.element || t.element === "none" || !t.level){
        towerOverlayTitleEl.textContent = `Tower Slot #${index+1}`;
        towerOverlayBodyEl.textContent = "Choose an element path for this tower.";
        ["fire","ice","stone"].forEach(el => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "tiny-btn";
          btn.innerHTML = `${emojiForElement(el)} ${capitalize(el)} Path`;
          btn.addEventListener("click", ()=> sendTowerPath(index, el).catch(err => {
            console.error(err);
            showToast("Failed to set tower path.");
          }));
          towerOverlayActionsEl.appendChild(btn);
        });
      } else {
        towerOverlayTitleEl.textContent = `${capitalize(t.element)} Tower #${index+1}`;
        const lvl = t.level || 1;
        towerOverlayBodyEl.textContent = lvl >= 3
          ? "This tower is max level."
          : `Current level: ${lvl}. Upgrade to level ${lvl+1}?`;
        if (lvl < 3){
          const cost = calcTowerUpgradeCost(d, side, index);
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "tiny-btn";
          btn.innerHTML = `‚¨ÜÔ∏è Upgrade (${cost}g)`;
          btn.addEventListener("click", ()=> {
            const goldKey = side === 1 ? "gold1" : "gold2";
            const currentGold = d[goldKey] ?? 0;
            if (currentGold < cost){
              showToast("Not enough gold to upgrade tower.");
              return;
            }
            sendTowerUpgrade(index).catch(err => {
              console.error(err);
              showToast("Failed to upgrade tower.");
            });
          });
          towerOverlayActionsEl.appendChild(btn);
        }
      }

      towerOverlayEl.classList.add("show");
    }

    function hideTowerOverlay(){
      towerOverlayEl.classList.remove("show");
      state.selectedTowerIndex = null;
    }

    // ---- Scan info ----
    function showScanInfo(){
      const d = state.gameData;
      if (!d) return;
      const side = (state.seat === 2) ? 2 : 1;
      const enemy = side === 1 ? 2 : 1;
      const towersKeyEnemy = enemy === 1 ? "towers1" : "towers2";
      const towersEnemy = Array.isArray(d[towersKeyEnemy]) ? d[towersKeyEnemy] : [];
      const genEnemy = enemy === 1 ? (d.gen1 ?? 1) : (d.gen2 ?? 1);

      const counts = {fire:0,ice:0,stone:0};
      for (const t of towersEnemy){
        if (t.element === "fire") counts.fire++;
        else if (t.element === "ice") counts.ice++;
        else if (t.element === "stone") counts.stone++;
      }

      const msg = `Enemy generator Lv${genEnemy}. Towers ‚Äî Fire: ${counts.fire}, Ice: ${counts.ice}, Stone: ${counts.stone}.`;
      showToast(msg);
    }

    // ---- Small helpers ----
    function capitalize(s){
      if (!s) return "";
      return s.charAt(0).toUpperCase() + s.slice(1);
    }

    function emojiForElement(el){
      if (el === "fire") return "üî•";
      if (el === "ice") return "‚ùÑÔ∏è";
      if (el === "stone") return "ü™®";
      return "üóº";
    }
  </script>
</body>
</html>




