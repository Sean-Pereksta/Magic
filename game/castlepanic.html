<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>ğŸ° Wall Defense â€” Co-op Card Siege</title>
<style>
  :root{
    --bg:#0b1014; --panel:#0e1726; --ink:#e6efff; --muted:#9fb3c8; --card:#111827; --br:#1f2a44;
    --good:#22c55e; --warn:#eab308; --bad:#ef4444; --accent:#60a5fa;
    --tap:64px; --rad:16px; --shadow:0 10px 30px rgba(2,6,23,.35);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; background:radial-gradient(1000px 600px at 50% -150px,#162239,#0b1014);
    color:var(--ink);
  }
  .wrap{
    height:100svh; max-width:1100px; margin:0 auto; display:grid; grid-template-rows:auto 1fr auto; gap:10px; padding:10px;
  }
  .top{
    display:grid; gap:10px; grid-template-columns:1fr auto; align-items:stretch;
  }
  .status{
    background:var(--panel); border:1px solid var(--br); border-radius:var(--rad); padding:8px 10px; display:grid; gap:6px; min-width:260px;
  }
  .row{display:flex; align-items:center; justify-content:space-between; gap:8px}
  .hpbar{height:10px; background:#0e1627; border:1px solid var(--br); border-radius:999px; overflow:hidden}
  .hpbar>i{display:block; height:100%; background:linear-gradient(90deg,#22c55e,#60a5fa); width:100%}
  .chips{display:flex; gap:6px; flex-wrap:wrap}
  .chip{
    background:#0f1b2e; border:1px solid var(--br); padding:6px 10px; border-radius:999px; font-weight:700; font-size:13px; display:flex; gap:8px; align-items:center
  }
  .chip[data-cur="true"]{outline:2px solid var(--accent); box-shadow:0 0 0 4px rgba(96,165,250,.15)}
  .topBtns{display:flex; gap:8px; align-items:center}
  .btn{appearance:none; border:none; border-radius:12px; padding:10px 12px; font-weight:900; cursor:pointer; color:#081321; background:#9cc8ff;}
  .btn.secondary{background:#c3d4ee; color:#0b1322}
  .btn.warn{background:#ffd59b}
  .btn.danger{background:#ff9ca8}

  /* Battlefield window */
  .boardWrap{
    background:var(--panel); border:1px solid var(--br); border-radius:var(--rad); padding:8px; display:grid; grid-template-rows:auto 1fr; gap:8px; min-height:0;
  }
  .legend{display:flex; gap:10px; flex-wrap:wrap; font-size:13px; color:var(--muted)}
  .view{
    position:relative; overflow:hidden; border:1px solid var(--br); border-radius:12px; min-height:360px;
    touch-action:none; background:#0b1422;
  }
  canvas{display:block; width:100%; height:100%}

  /* Hand & actions */
  .bottom{
    display:grid; grid-template-columns:1fr auto; gap:10px; align-items:stretch;
  }
  .hand{
    background:var(--panel); border:1px solid var(--br); border-radius:var(--rad); padding:8px; display:grid; grid-template-columns:repeat(3,1fr); gap:8px;
  }
  .card{
    background:linear-gradient(180deg,#0f1d33,#0a1222); border:1px solid var(--br); border-radius:12px; padding:10px; display:grid; gap:6px; min-height:96px;
    box-shadow:var(--shadow); cursor:pointer; user-select:none
  }
  .card .name{font-weight:900; font-size:14px; line-height:1.1}
  .card .desc{font-size:12px; color:var(--muted)}
  .card[data-disabled="true"]{opacity:.45; filter:grayscale(.2); pointer-events:none}
  .card[data-aim="true"]{outline:2px solid var(--accent); box-shadow:0 0 0 6px rgba(96,165,250,.15)}
  .tag{font-size:11px; padding:3px 7px; border-radius:999px; border:1px solid #334; background:#0b1629; color:#a9c2ff; width:max-content}

  .actions{
    background:var(--panel); border:1px solid var(--br); border-radius:var(--rad); padding:8px; display:grid; gap:8px; min-width:210px
  }
  .bar{display:flex; gap:8px; flex-wrap:wrap}
  .pill{background:#0f1b2e; border:1px solid var(--br); padding:6px 10px; border-radius:999px; font-size:12px}
  .log{max-height:9lh; overflow:auto; font-size:12px; color:#a9b8d6}
  .muted{color:var(--muted)}

  @media (max-width:720px){
    .top{grid-template-columns:1fr}
    .status{min-width:unset}
    .bottom{grid-template-columns:1fr}
    .hand{grid-template-columns:repeat(2,1fr)}
  }
</style>
</head>
<body>
<div class="wrap">
  <!-- TOP -->
  <div class="top">
    <div class="status">
      <div class="row"><div>ğŸ—“ï¸ <b>Turn</b></div><div id="turnNum">1</div></div>
      <div class="row">
        <div>ğŸ° <b>Castle</b></div>
        <div style="flex:1; margin:0 8px" class="hpbar"><i id="hpFill" style="width:100%"></i></div>
        <div id="hpLbl">30/30</div>
      </div>
      <div class="row"><div>ğŸ‘¥ <b>Player</b></div><div id="turnLabel">P1</div></div>
      <div class="chips" id="playersBar"></div>
      <div class="topBtns">
        <button class="btn secondary" id="fsBtn">ğŸ“± Fullscreen</button>
        <button class="btn" id="endBtn">End Turn</button>
      </div>
    </div>
    <div class="boardWrap">
      <div class="legend">
        <span>ğŸ§± Wall</span>
        <span>âš”ï¸ Knight</span>
        <span>ğŸ¹ Archer</span>
        <span>ğŸ§™â€â™‚ï¸ Wizard</span>
        <span>ğŸ‘º Goblin</span>
        <span>ğŸ§Œ Orc</span>
        <span>ğŸ—¿ Troll</span>
        <span>ğŸºğŸ¹ Gnoll</span>
        <span>ğŸ§™â€â™€ï¸ Witch</span>
        <span>ğŸ‘ï¸ Cyclops</span>
        <span>ğŸ‰ Dragon</span>
      </div>
      <div class="view" id="view">
        <canvas id="cv"></canvas>
      </div>
    </div>
  </div>

  <!-- BOTTOM -->
  <div class="bottom">
    <div class="hand" id="hand"></div>
    <div class="actions">
      <div class="bar">
        <span class="pill">ğŸƒ Deck: <b id="deckCount">0</b></span>
        <span class="pill">â™»ï¸ Discard: <b id="discardCount">0</b></span>
        <span class="pill">ğŸ«± Hand: <b id="handCount">0</b></span>
      </div>
      <div class="log" id="log"></div>
      <div class="muted">Tip: Click a tile to fire siege. Ballista pierces to that tile; Catapult splashes on that tile. Troops auto-move toward the nearest enemy each turn.</div>
    </div>
  </div>
</div>

<script>
/* ============================================================
   Config & helpers
   ============================================================ */
const TILE = 36;
const GRID_W = 46;  // width in tiles
const GRID_H = 18;  // height in tiles
const WALL_X  = 2;  // wall column (allies spawn near here)
const ENEMY_SPAWN_X = GRID_W - 3;

const CASTLE_MAX_HP = 30;
const HAND_SIZE = 3;

function uid(){ return Math.random().toString(36).slice(2,9); }
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function inBounds(x,y){ return x>=0 && y>=0 && x<GRID_W && y<GRID_H; }
function getParam(name){
  const m = new RegExp('[?&]'+name+'=([^&#]*)').exec(location.search);
  return m ? decodeURIComponent(m[1].replace(/\+/g,'%20')) : null;
}
function randRange(n){ return (Math.random()*n)|0; }
function shuffled(arr){ const a=arr.slice(); for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]];} return a; }

const EMOJI = {
  wall: "ğŸ§±",
  knight: "âš”ï¸",
  archer: "ğŸ¹",
  wizard: "ğŸ§™â€â™‚ï¸",
  goblin: "ğŸ‘º",
  orc: "ğŸ§Œ",
  troll: "ğŸ—¿",
  gnoll: "ğŸº",
  witch: "ğŸ§™â€â™€ï¸",
  cyclops: "ğŸ‘ï¸",
  dragon: "ğŸ‰",
};

/* ============================================================
   Game State
   ============================================================ */
const state = {
  turn: 1,
  castleHP: CASTLE_MAX_HP,
  players: [],
  curP: 0,
  actedThisTurn: false,
  grid: [],
  units: {},
  targetAiming: null, // {cardIndex, weapon, level}
  dragging:false, dragStart:null, viewOffset:{x:0,y:0}, viewScale:1,
  gameOver:false,
  highlights: [] // {x,y,ttl,type:'path'|'splash'}
};

// Placeholder sync (no-op)
const FirebaseSync = {
  isMyTurn: ()=> true,
  onAdvance: ()=>{},  // broadcast state/highlights if you wire RTDB/Firestore
};

/* ============================================================
   Deck & Cards
   ============================================================ */
function starterDeck(){
  const d = [];
  d.push(makeTroopCard("knight"));
  d.push(makeTroopCard("archer"));
  d.push(makeTroopCard("wizard"));
  d.push(makeTroopCard("knight"));
  d.push(makeSiegeCard("catapult"));
  d.push(makeSiegeCard("ballista"));
  d.push(makeUpgradeCard());
  d.push(makeUpgradeCard());
  d.push(makeTroopCard("archer"));
  d.push(makeSiegeCard("catapult"));
  return d;
}

function makeTroopCard(kind){ return {id:uid(), type:"troop", kind, level:1, name:cap(kind)+" (Lv1)", desc:`Summon ${cap(kind)}s near the wall. Count scales with level.`}; }
function makeSiegeCard(kind){ 
  const nm = kind==="catapult"?"Catapult":"Ballista";
  return {id:uid(), type:"siege", kind, level:1, name:`${nm} (Lv1)`, desc:(kind==="catapult"?"Splash at clicked tile.":"Pierces to clicked tile; extra at impact.")};
}
function makeUpgradeCard(){ return {id:uid(), type:"upgrade", name:"Upgrade", desc:"Click this, then click a card in your hand to level it up."}; }

function cap(s){ return s[0].toUpperCase()+s.slice(1); }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }

function initPlayers(n=1){
  const arr=[];
  for(let i=0;i<n;i++){
    const deck = shuffle(starterDeck());
    arr.push({name:`P${i+1}`, deck, discard:[], hand:[]});
  }
  state.players = arr;
  for(const p of state.players){ drawUpTo(p); }
}

function draw(p){
  if(!p.deck.length){
    if(!p.discard.length) return null;
    log(`ğŸ”„ ${p.name} reshuffled.`);
    p.deck = shuffle(p.discard.splice(0));
  }
  return p.deck.pop();
}
function drawUpTo(p){
  while(p.hand.length < HAND_SIZE){
    const c = draw(p); if(!c) break;
    p.hand.push(c);
  }
}
function discardCard(p, idx){
  const [c] = p.hand.splice(idx,1);
  p.discard.push(c);
}
function levelUpCard(card){
  card.level = Math.min(10, (card.level||1)+1);
  if(card.type==="troop"){
    card.name = `${cap(card.kind)} (Lv${card.level})`;
  }else if(card.type==="siege"){
    const nm = card.kind==="catapult"?"Catapult":"Ballista";
    card.name = `${nm} (Lv${card.level})`;
  }
}

/* ============================================================
   Grid & Units
   ============================================================ */
function clearGrid(){
  state.grid = [];
  for(let y=0;y<GRID_H;y++){
    const row = new Array(GRID_W).fill(null);
    state.grid.push(row);
  }
}
function placeUnit(u){
  if(!inBounds(u.x,u.y)) return false;
  if(state.grid[u.y][u.x]) return false;
  state.units[u.id]=u;
  state.grid[u.y][u.x]=u.id;
  return true;
}
function moveUnit(u, nx, ny){
  if(!inBounds(nx,ny)) return false;
  if(state.grid[ny][nx]) return false;
  state.grid[u.y][u.x]=null;
  u.x = nx; u.y = ny;
  state.grid[ny][nx]=u.id;
  return true;
}
function removeUnit(u){
  if(state.grid[u.y]?.[u.x]===u.id){ state.grid[u.y][u.x]=null; }
  delete state.units[u.id];
}

function makeWall(){
  for(let y=0;y<GRID_H;y++){
    const id = uid();
    const w = {id, side:'wall', kind:'wall', emoji:EMOJI.wall, hp:9999, max:9999, dmg:0, range:0, speed:0, x:WALL_X, y};
    placeUnit(w);
  }
}

/* ------- Spawn helper: random Y, shift columns if full ------- */
function findSpawnSpot(startCol){
  const yOrder = shuffled([...Array(GRID_H).keys()]);
  let x = startCol;
  while(x < GRID_W){
    for(const y of yOrder){
      if(!state.grid[y][x]) return {x,y};
    }
    x++; // column full â†’ move right
  }
  return null;
}

/* ----- Allied Troops ----- */
function troopStats(kind, level=1){
  const base = {
    knight: {hp:4, dmg:2, range:1, speed:1, ai:'melee'},
    archer: {hp:3, dmg:2, range:4, speed:1, ai:'ranged'},
    wizard: {hp:3, dmg:1, range:3, speed:1, ai:'rangedSplash'},
  }[kind];
  const hp = base.hp + Math.floor((level-1)/2);
  const dmg = base.dmg + Math.floor((level-1)/3);
  return {hp, dmg, range:base.range, speed:base.speed, ai:base.ai};
}
function summonTroops(kind, level){
  // Number spawned = ceil(level/2), min 1, max 4
  const count = Math.min(4, Math.max(1, Math.ceil(level/2)));
  let placed=0;
  const startCol = WALL_X+1;
  for(let i=0;i<count;i++){
    const spot = findSpawnSpot(startCol);
    if(!spot){ log(`âš ï¸ No space to summon more ${cap(kind)}s (${placed}/${count}).`); break; }
    const st = troopStats(kind, level);
    const u = {
      id:uid(), side:'ally', kind,
      emoji:(kind==='knight'?EMOJI.knight:kind==='archer'?EMOJI.archer:EMOJI.wizard),
      hp:st.hp, max:st.hp, dmg:st.dmg, range:st.range, speed:st.speed, splash:(kind==='wizard'?1:0),
      x:spot.x, y:spot.y
    };
    placeUnit(u);
    placed++;
  }
  if(placed<count){ log(`âš ï¸ Spawned ${placed}/${count}.`); }
}

/* ----- Enemies & Waves ----- */
function tierForTurn(turn){ return Math.floor((turn-1)/5)+1; }

function enemyDef(kind, lvl){
  const scale = 1 + Math.floor((lvl-1)/5)*0.25 + (lvl*0.02);
  const table = {
    goblin: {hp:2, dmg:1, range:1, speed:2, ai:'melee'},
    orc:    {hp:5, dmg:2, range:1, speed:1, ai:'melee'},
    troll:  {hp:10,dmg:3, range:1, speed:1, ai:'meleeSplash'},
    gnoll:  {hp:4, dmg:2, range:3, speed:1, ai:'ranged'},
    witch:  {hp:4, dmg:1, range:3, speed:1, ai:'rangedSplash'},
    cyclops:{hp:12,dmg:4, range:1, speed:1, ai:'meleeKnock'},
    dragon: {hp:18,dmg:3, range:4, speed:1, ai:'rangedSplashWide'},
  }[kind];
  return {
    hp: Math.ceil(table.hp*scale),
    dmg: table.dmg,
    range: table.range,
    speed: table.speed,
    ai: table.ai
  };
}
function emojiForEnemy(kind){
  return {
    goblin:"ğŸ‘º", orc:"ğŸ§Œ", troll:"ğŸ—¿", gnoll:"ğŸº", witch:"ğŸ§™â€â™€ï¸",
    cyclops:"ğŸ‘ï¸", dragon:"ğŸ‰"
  }[kind];
}
function spawnWave(turn){
  const tier = tierForTurn(turn);
  const count = Math.min(6, 2 + Math.floor(tier/2));
  for(let i=0;i<count;i++){
    const pool = [];
    if(tier>=1){ pool.push("goblin"); }
    if(tier>=2){ pool.push("orc"); }
    if(tier>=3){ pool.push("troll"); }
    if(tier>=4){ pool.push("gnoll","witch"); }
    if(tier>=5){ pool.push("cyclops"); }
    if(tier>=6){ pool.push("dragon"); }
    const kind = pool[(Math.random()*pool.length)|0];
    const y = randRange(GRID_H);
    const def = enemyDef(kind, turn);
    const u = {id:uid(), side:'enemy', kind, emoji:emojiForEnemy(kind),
      hp:def.hp, max:def.hp, dmg:def.dmg, range:def.range, speed:def.speed, ai:def.ai,
      x:ENEMY_SPAWN_X, y};
    if(!state.grid[y][ENEMY_SPAWN_X]) placeUnit(u);
  }
  log(`ğŸ‘¹ Enemy wave (T${tier}) arrived.`);
}

/* ============================================================
   Turn Engine
   ============================================================ */
function curPlayer(){ return state.players[state.curP]; }

function endTurn(){
  if(state.gameOver) return;
  if(!FirebaseSync.isMyTurn()) return;
  state.curP = (state.curP+1) % state.players.length;
  state.turn += 1;
  state.actedThisTurn = false;

  tickHighlights();
  alliesAct();
  enemiesAct();
  applyCastleDamage();
  spawnWave(state.turn);
  drawUpTo(curPlayer());

  if(state.castleHP<=0){ gameOver(false); return; }

  renderAll();
  FirebaseSync.onAdvance();
}

function startGame(players=1){
  state.turn=1; state.castleHP=CASTLE_MAX_HP; state.curP=0; state.actedThisTurn=false; state.gameOver=false;
  state.highlights=[];
  clearGrid();
  state.units = {};
  initPlayers(players);
  makeWall();
  spawnWave(state.turn);
  renderAll();
}

/* ============================================================
   Auto Actions (nearest enemy movement)
   ============================================================ */
function nearestTarget(u, targets){
  let best=null, bestD=1e9;
  for(const t of targets){
    const d = Math.abs(u.x-t.x)+Math.abs(u.y-t.y);
    if(d<bestD){ bestD=d; best=t; }
  }
  return best;
}
function canAttack(att, tgt){
  return (Math.abs(att.x-tgt.x)+Math.abs(att.y-tgt.y)) <= att.range;
}
function hitUnit(target, dmg){
  if(target.side==='wall') return 0;
  target.hp -= dmg;
  if(target.hp<=0){ removeUnit(target); return 1; }
  return 0;
}
function splashAt(x,y, radius, dmg, sideFilter=null){
  let killed=0;
  for(let iy=y-radius; iy<=y+radius; iy++){
    for(let ix=x-radius; ix<=x+radius; ix++){
      if(!inBounds(ix,iy)) continue;
      if(Math.abs(ix-x)+Math.abs(iy-y) > radius) continue;
      const id = state.grid[iy][ix];
      if(!id) continue;
      const u = state.units[id];
      if(!u) continue;
      if(u.side==='wall') continue;
      if(sideFilter && u.side!==sideFilter) continue;
      killed += hitUnit(u, dmg);
    }
  }
  return killed;
}
function stepToward(u, tx, ty, steps){
  for(let s=0;s<steps;s++){
    const dx = Math.sign(tx - u.x);
    const dy = Math.sign(ty - u.y);
    // try x first, then y
    if(dx && moveUnit(u, u.x+dx, u.y)) continue;
    if(dy && moveUnit(u, u.x, u.y+dy)) continue;
    // try swapping priority
    if(dy && moveUnit(u, u.x, u.y+dy)) continue;
    // stuck
    break;
  }
}
function enemiesAct(){
  const ids = Object.values(state.units).filter(u=>u.side==='enemy').sort((a,b)=> (a.x-b.x)|| (a.y-b.y)).map(u=>u.id);
  for(const id of ids){
    const u = state.units[id]; if(!u) continue;
    const allies = Object.values(state.units).filter(v=>v.side==='ally');
    if(allies.length){
      const t = nearestTarget(u, allies);
      if(canAttack(u,t)){
        if(u.ai==='melee'){ hitUnit(t, u.dmg); }
        else if(u.ai==='meleeSplash'){ splashAt(t.x,t.y,1,u.dmg,'ally'); }
        else if(u.ai==='meleeKnock'){ hitUnit(t,u.dmg); const kx=t.x+Math.sign(t.x-u.x), ky=t.y+Math.sign(t.y-u.y); if(inBounds(kx,ky)&&!state.grid[ky][kx]) moveUnit(t,kx,ky); }
        else if(u.ai==='ranged'){ hitUnit(t, u.dmg); }
        else if(u.ai==='rangedSplash'){ splashAt(t.x,t.y,1,u.dmg,'ally'); }
        else if(u.ai==='rangedSplashWide'){ splashAt(t.x,t.y,2,u.dmg,'ally'); }
      }else{
        stepToward(u, t.x, t.y, u.speed);
      }
    }else{
      stepToward(u, WALL_X, u.y, u.speed);
    }
  }
}
function alliesAct(){
  const ids = Object.values(state.units).filter(u=>u.side==='ally').sort((a,b)=> (b.x-a.x)|| (a.y-b.y)).map(u=>u.id);
  for(const id of ids){
    const u = state.units[id]; if(!u) continue;
    const enemies = Object.values(state.units).filter(v=>v.side==='enemy');
    if(!enemies.length) continue;
    const t = nearestTarget(u, enemies);
    if(canAttack(u,t)){
      if(u.splash){ splashAt(t.x,t.y,u.splash,u.dmg,'enemy'); }
      else hitUnit(t, u.dmg);
    }else{
      // move TOWARD nearest enemy (requested change)
      stepToward(u, t.x, t.y, u.speed);
    }
  }
}
function applyCastleDamage(){
  let hits=0;
  for(const u of Object.values(state.units)){
    if(u.side==='enemy' && u.x<=WALL_X){
      hits += 1;
    }
  }
  if(hits>0){
    state.castleHP = Math.max(0, state.castleHP - hits);
    log(`ğŸ’¥ Castle takes ${hits} damage.`);
  }
}

/* ============================================================
   Highlights (shared-visible)
   ============================================================ */
function addHighlight(tiles, type='path', ttl=3){
  for(const t of tiles){
    state.highlights.push({x:t.x, y:t.y, ttl, type});
  }
}
function tickHighlights(){
  state.highlights.forEach(h=>h.ttl--);
  state.highlights = state.highlights.filter(h=>h.ttl>0);
}

/* ============================================================
   Cards â€” Interactions
   ============================================================ */
let upgradeWaiting = null; // after clicking Upgrade

function playCard(idx){
  if(state.gameOver) return;
  if(!FirebaseSync.isMyTurn()) { log("â³ Not your turn."); return; }
  if(state.actedThisTurn) { log("ğŸ›‘ You already played a card this turn."); return; }

  const p = curPlayer();
  const c = p.hand[idx];
  if(!c) return;

  if(c.type==="upgrade"){
    upgradeWaiting = {fromIndex: idx};
    renderHand();
    log("â¬†ï¸ Select a different card in your hand to upgrade.");
    return;
  }

  if(upgradeWaiting){
    if(idx === upgradeWaiting.fromIndex){
      log("âŒ Choose a different card to upgrade.");
      return;
    }
    levelUpCard(p.hand[idx]);
    log(`ğŸ”§ Upgraded "${p.hand[idx].name}".`);
    discardCard(p, upgradeWaiting.fromIndex);
    upgradeWaiting = null;
    state.actedThisTurn = true;
    renderAll();
    setTimeout(endTurn, 350);
    return;
  }

  if(c.type==="troop"){
    summonTroops(c.kind, c.level||1);
    log(`ğŸ›¡ï¸ Summoned ${cap(c.kind)}(s) (Lv${c.level}).`);
    discardCard(p, idx);
    state.actedThisTurn = true;
    renderAll();
    setTimeout(endTurn, 350);
    return;
  }

  if(c.type==="siege"){
    state.targetAiming = {cardIndex: idx, weapon:c.kind, level:c.level||1};
    renderHand();
    log(`ğŸ¯ Click a tile to fire the ${c.kind==='catapult'?'Catapult':'Ballista'}.`);
    return;
  }
}

function onHandClick(idx){
  if(upgradeWaiting && state.players[state.curP].hand[idx]?.type!=="upgrade"){
    playCard(idx);
    return;
  }
  playCard(idx);
}

/* ============================================================
   Siege (CLICK targeting)
   ============================================================ */
const viewEl = document.getElementById('view');
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');

function toWorld(px,py){
  const r = viewEl.getBoundingClientRect();
  const x = (px - r.left)/state.viewScale + state.viewOffset.x;
  const y = (py - r.top)/state.viewScale  + state.viewOffset.y;
  return {x,y};
}
function worldToTile(wx,wy){
  return { tx: Math.floor(wx/TILE), ty: Math.floor(wy/TILE) };
}
function tileCenter(tx,ty){
  return { x: tx*TILE + TILE/2, y: ty*TILE + TILE/2 };
}

function onPointerDown(e){
  // Aiming mode â†’ resolve shot at clicked tile
  if(state.targetAiming){
    const w = toWorld(e.clientX, e.clientY);
    const {tx,ty} = worldToTile(w.x,w.y);
    if(!inBounds(tx,ty)){ log("âŒ Click inside the battlefield."); return; }
    resolveSiegeClick(tx,ty);
    return;
  }
  // otherwise start panning
  state.dragging = true;
  state.dragStart = {mx:e.clientX, my:e.clientY, ox:state.viewOffset.x, oy:state.viewOffset.y};
}
function onPointerMove(e){
  if(state.dragging && state.dragStart){
    const dx = (state.dragStart.mx - e.clientX)/state.viewScale;
    const dy = (state.dragStart.my - e.clientY)/state.viewScale;
    state.viewOffset.x = clamp(state.dragStart.ox + dx, 0, GRID_W*TILE - 50);
    state.viewOffset.y = clamp(state.dragStart.oy + dy, 0, GRID_H*TILE - 50);
    renderCanvas();
  }
}
function onPointerUp(){ state.dragging=false; state.dragStart=null; }

viewEl.addEventListener('pointerdown', onPointerDown);
viewEl.addEventListener('pointermove', onPointerMove);
viewEl.addEventListener('pointerup', onPointerUp);
viewEl.addEventListener('pointerleave', onPointerUp);
viewEl.addEventListener('wheel', (e)=>{
  e.preventDefault();
  state.viewScale = clamp(state.viewScale - Math.sign(e.deltaY)*0.05, 0.6, 1.5);
  renderCanvas();
},{passive:false});

function resolveSiegeClick(tx,ty){
  const p = curPlayer();
  const a = state.targetAiming;
  const card = p.hand[a.cardIndex];
  if(!card) return;

  if(card.kind === 'catapult'){
    // Splash only at the clicked tile (no path hits)
    const splashR = (card.level>=10)?2 : (card.level>=5?2:1);
    const dmg = 1 + Math.floor((card.level-1)/2);
    const affected = [];
    for(let y=ty-splashR; y<=ty+splashR; y++){
      for(let x=tx-splashR; x<=tx+splashR; x++){
        if(!inBounds(x,y)) continue;
        if(Math.abs(x-tx)+Math.abs(y-ty) <= splashR) affected.push({x,y});
      }
    }
    addHighlight(affected,'splash',3);
    const killed = splashAt(tx,ty,splashR,dmg,'enemy');
    log(`ğŸª¨ Catapult impact at ${tx},${ty}. ${killed} down.`);
  }else{
    // Ballista: pierce in a straight row from the wall lane to the clicked tile y
    const y = ty;
    const startX = WALL_X+1;
    const dir = tx >= startX ? 1 : -1;
    const path = [];
    let killed=0;
    const base = 1 + Math.floor((card.level-1)/3);

    for(let x=startX; dir>0 ? x<=tx : x>=tx; x+=dir){
      path.push({x, y});
      const id = state.grid[y][x];
      if(id){
        const u = state.units[id];
        if(u && u.side==='enemy'){
          killed += hitUnit(u, base);
        }
      }
    }
    // extra impact on final tile if enemy there
    const id2 = state.grid[y][tx];
    if(id2){
      const u2 = state.units[id2];
      if(u2 && u2.side==='enemy'){
        killed += hitUnit(u2, base+1);
      }
    }
    // L5: two side mini-lines (slight vertical offsets)
    if(card.level>=5){
      for(const oy of [-1,1]){
        const yy = clamp(y+oy,0,GRID_H-1);
        for(let x=startX; dir>0 ? x<=tx : x>=tx; x+=dir){
          if(!inBounds(x,yy)) continue;
          const id = state.grid[yy][x];
          if(id){
            const u = state.units[id];
            if(u && u.side==='enemy'){
              killed += hitUnit(u, base);
            }
          }
        }
      }
    }
    // L10: tiny knockback on impact tile, if space
    if(card.level>=10){
      const idK = state.grid[y][tx];
      if(idK){
        const uK = state.units[idK];
        if(uK && uK.side==='enemy'){
          const kx = clamp(uK.x + 1, 0, GRID_W-1);
          if(inBounds(kx,uK.y) && !state.grid[uK.y][kx]) moveUnit(uK,kx,uK.y);
        }
      }
    }

    addHighlight(path,'path',3);
    log(`ğŸ¹ Ballista fired to ${tx},${ty}. ${killed} down.`);
  }

  // discard card & end turn
  discardCard(p, a.cardIndex);
  state.actedThisTurn = true;
  state.targetAiming = null;
  renderAll();
  setTimeout(endTurn, 350);
}

/* ============================================================
   UI: Rendering
   ============================================================ */
function qs(s){ return document.querySelector(s); }
function log(msg){
  const el = qs('#log');
  const line = document.createElement('div');
  const ts = new Date().toLocaleTimeString();
  line.innerHTML = `<span style="opacity:.6">[${ts}]</span> ${msg}`;
  el.appendChild(line);
  el.scrollTop = el.scrollHeight;
}
function renderAll(){
  renderStatus();
  renderPlayers();
  renderHand();
  renderCanvas();
}
function renderStatus(){
  qs('#turnNum').textContent = state.turn;
  qs('#turnLabel').textContent = curPlayer().name;
  const hpPct = Math.round(state.castleHP/CASTLE_MAX_HP*100);
  qs('#hpFill').style.width = Math.max(0,hpPct)+'%';
  qs('#hpLbl').textContent = `${state.castleHP}/${CASTLE_MAX_HP}`;
  qs('#deckCount').textContent = curPlayer().deck.length;
  qs('#discardCount').textContent = curPlayer().discard.length;
  qs('#handCount').textContent = curPlayer().hand.length;
  qs('#endBtn').disabled = state.gameOver || !FirebaseSync.isMyTurn();
}
function renderPlayers(){
  const bar = qs('#playersBar'); bar.innerHTML="";
  state.players.forEach((p,i)=>{
    const chip = document.createElement('div');
    chip.className='chip';
    chip.dataset.cur = (i===state.curP);
    chip.innerHTML = `<span>ğŸ‘¤</span><b>${p.name}</b> <span style="opacity:.7">ğŸƒ${p.hand.length}</span>`;
    bar.appendChild(chip);
  });
}
function renderHand(){
  const h = qs('#hand'); h.innerHTML="";
  const p = curPlayer();
  p.hand.forEach((c,idx)=>{
    const el = document.createElement('div');
    el.className='card';
    el.onclick = ()=> onHandClick(idx);
    const name = document.createElement('div'); name.className='name'; name.textContent = c.name;
    const desc = document.createElement('div'); desc.className='desc'; desc.textContent = c.desc;
    const tag = document.createElement('div'); tag.className='tag'; tag.textContent = c.type==='troop'? 'Summon' : (c.type==='siege' ? 'Attack' : 'Upgrade');
    el.appendChild(name); el.appendChild(desc); el.appendChild(tag);
    if(upgradeWaiting && upgradeWaiting.fromIndex===idx) el.setAttribute('data-aim','true');
    if(state.targetAiming && state.targetAiming.cardIndex===idx) el.setAttribute('data-aim','true');
    if(state.actedThisTurn) el.setAttribute('data-disabled','true');
    if(!FirebaseSync.isMyTurn()) el.setAttribute('data-disabled','true');
    h.appendChild(el);
  });
}

/* ===== Canvas drawing ===== */
function resizeCanvas(){
  const r = viewEl.getBoundingClientRect();
  cv.width = Math.max(300, Math.floor(r.width  * devicePixelRatio));
  cv.height= Math.max(220, Math.floor(r.height * devicePixelRatio));
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
window.addEventListener('resize', ()=>{ resizeCanvas(); renderCanvas(); });

function renderCanvas(){
  resizeCanvas();
  const w = cv.width/devicePixelRatio, h = cv.height/devicePixelRatio;
  ctx.clearRect(0,0,w,h);

  ctx.save();
  ctx.translate(-state.viewOffset.x*state.viewScale, -state.viewOffset.y*state.viewScale);
  ctx.scale(state.viewScale, state.viewScale);

  // background
  ctx.fillStyle = '#0b1422';
  ctx.fillRect(state.viewOffset.x, state.viewOffset.y, w/state.viewScale, h/state.viewScale);

  // grid
  ctx.strokeStyle = '#1a2742';
  ctx.lineWidth = 1;
  for(let y=0;y<GRID_H;y++){
    for(let x=0;x<GRID_W;x++){
      ctx.strokeRect(x*TILE, y*TILE, TILE, TILE);
    }
  }

  // wall band
  ctx.fillStyle = 'rgba(120,160,255,0.08)';
  ctx.fillRect(WALL_X*TILE, 0, TILE, GRID_H*TILE);

  // highlights
  for(const hlt of state.highlights){
    ctx.fillStyle = hlt.type==='splash' ? 'rgba(255,120,80,0.22)' : 'rgba(120,200,255,0.22)';
    ctx.fillRect(hlt.x*TILE, hlt.y*TILE, TILE, TILE);
    ctx.strokeStyle = hlt.type==='splash' ? 'rgba(255,140,110,0.6)' : 'rgba(130,210,255,0.6)';
    ctx.strokeRect(hlt.x*TILE+1, hlt.y*TILE+1, TILE-2, TILE-2);
  }

  // units
  ctx.textAlign='center'; ctx.textBaseline='middle';
  for(const u of Object.values(state.units)){
    const px = u.x*TILE + TILE/2;
    const py = u.y*TILE + TILE/2;
    ctx.font = '22px system-ui,Segoe UI,Apple Color Emoji,Segoe UI Emoji';
    ctx.fillText(u.emoji, px, py);
    if(u.side!=='wall'){
      ctx.fillStyle = '#99c3ff';
      ctx.font = '11px system-ui';
      ctx.fillText(`${u.hp}`, px, py + 14);
      ctx.fillStyle = '#e6efff';
    }
  }

  ctx.restore();
}

/* ============================================================
   Controls
   ============================================================ */
document.getElementById('endBtn').addEventListener('click', endTurn);
document.getElementById('fsBtn').addEventListener('click', ()=>{
  if(document.fullscreenElement) document.exitFullscreen();
  else document.documentElement.requestFullscreen();
});

/* ============================================================
   Game Over
   ============================================================ */
function gameOver(win){
  state.gameOver = true;
  log(win ? "ğŸ† Victory!" : "â˜ ï¸ Defeat â€” the castle fell.");
  document.getElementById('endBtn').disabled = true;
}

/* ============================================================
   Boot
   ============================================================ */
// read ?players=N (fallback 1), clamp 1â€“4
const pParam = parseInt(getParam('players') || '', 10);
const PLAYER_COUNT = clamp(isNaN(pParam) ? 1 : pParam, 1, 4);

startGame(PLAYER_COUNT);
renderAll();
</script>
</body>
</html>




