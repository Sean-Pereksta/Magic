<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>üè∞ Base War ‚Äî Elemental Siege</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
  <style>
    :root{
      --bg:#020617;
      --panel:#020617;
      --card:#0b1120;
      --ink:#e5e7eb;
      --muted:#9ca3af;
      --accent:#f97316;
      --accent-soft:#fed7aa;
      --good:#22c55e;
      --bad:#ef4444;
      --radius:20px;
      --shadow:0 18px 40px rgba(15,23,42,.7);
      --tap:56px;
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color:transparent;}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:
        radial-gradient(1200px 900px at -10% -20%, rgba(248,113,113,.28), transparent 60%),
        radial-gradient(1200px 900px at 110% -10%, rgba(249,115,22,.25), transparent 60%),
        #020617;
      color:var(--ink);
      min-height:100vh;
      display:flex;
      flex-direction:column;
    }
    .shell{
      max-width:960px;
      margin:0 auto;
      padding:10px 10px 24px;
      width:100%;
    }

    /* HUD */
    .hud{
      margin-top:10px;
      margin-bottom:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .hud-row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .player-panel{
      flex:1 1 0;
      background:linear-gradient(135deg,rgba(15,23,42,.96),rgba(15,23,42,.9));
      border-radius:var(--radius);
      padding:8px 10px;
      border:1px solid rgba(148,163,184,.6);
      box-shadow:0 10px 26px rgba(15,23,42,.8);
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .player-name{
      display:flex;
      align-items:center;
      justify-content:space-between;
      font-size:.92rem;
      font-weight:800;
      color:#f9fafb;
    }
    .role-label{
      font-size:.78rem;
      color:var(--muted);
    }
    .hp-wrap{
      display:flex;
      align-items:center;
      gap:8px;
      font-size:.8rem;
      color:var(--muted);
    }
    .hp-bar{
      flex:1;
      height:10px;
      border-radius:999px;
      background:rgba(15,23,42,1);
      border:1px solid rgba(51,65,85,.9);
      overflow:hidden;
    }
    .hp-fill{
      height:100%;
      width:100%;
      background:linear-gradient(90deg,#22c55e,#facc15,#fb923c,#ef4444);
      transition:width .2s ease-out;
    }
    .vs-pill{
      width:46px;
      height:46px;
      border-radius:999px;
      display:grid;
      place-items:center;
      background:radial-gradient(circle at 30% 20%,#fee2e2,#f97316);
      color:#111827;
      font-weight:900;
      border:2px solid rgba(248,250,252,.95);
      box-shadow:0 10px 32px rgba(0,0,0,.75);
      font-size:.9rem;
    }

    .meta-row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      font-size:.84rem;
      color:var(--muted);
    }
    .gold-pill{
      display:inline-flex;
      align-items:center;
      gap:7px;
      padding:6px 12px;
      border-radius:999px;
      background:rgba(15,23,42,.95);
      border:1px solid rgba(251,191,36,.7);
      color:#fef3c7;
      box-shadow:0 10px 24px rgba(0,0,0,.8);
    }
    .gold-pill span.coin{
      width:16px;
      height:16px;
      border-radius:50%;
      background:radial-gradient(circle at 30% 30%,#fef9c3,#facc15,#d97706);
      border:1px solid rgba(120,53,15,.9);
      box-shadow:0 0 0 1px rgba(252,211,77,.5);
    }
    .meta-right{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .tag{
      padding:4px 9px;
      border-radius:999px;
      border:1px solid rgba(148,163,184,.7);
      font-size:.74rem;
      color:var(--muted);
    }
    #statusText{
      font-size:.8rem;
      color:var(--muted);
    }
    .btn-ghost{
      border-radius:999px;
      border:1px solid rgba(148,163,184,.8);
      background:rgba(15,23,42,.85);
      color:var(--muted);
      font-size:.8rem;
      padding:7px 10px;
      display:inline-flex;
      align-items:center;
      gap:6px;
      cursor:pointer;
    }

    /* Game card */
    .game-card{
      background:var(--card);
      border-radius:24px;
      border:1px solid rgba(148,163,184,.6);
      box-shadow:var(--shadow);
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .game-head{
      padding:10px 14px;
      border-bottom:1px solid rgba(31,41,55,.95);
      background:
        radial-gradient(circle at 0% 0%,rgba(248,250,252,.16),transparent 55%),
        radial-gradient(circle at 100% 0%,rgba(251,191,36,.18),transparent 60%);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-size:.86rem;
      color:var(--muted);
    }
    .game-head-title{
      display:flex;
      align-items:center;
      gap:8px;
      font-weight:700;
      color:#e5e7eb;
    }
    .game-body{
      padding:10px 10px 12px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    /* Board */
    .board{
      position:relative;
      border-radius:20px;
      border:1px solid rgba(30,64,175,.6);
      background:
        linear-gradient(135deg,rgba(15,23,42,1),rgba(15,23,42,.96)),
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='160' height='160' viewBox='0 0 160 160'%3E%3Cdefs%3E%3CradialGradient id='g' cx='20%25' cy='0%25' r='90%25'%3E%3Cstop stop-color='%2327313b' stop-opacity='0.7' offset='0%25'/%3E%3Cstop stop-color='%230b1120' stop-opacity='0.0' offset='100%25'/%3E%3C/radialGradient%3E%3C/defs%3E%3Crect width='160' height='160' fill='%230b1120'/%3E%3Ccircle cx='30' cy='0' r='80' fill='url(%23g)'/%3E%3C/svg%3E");
      background-size:cover;
      min-height:230px;
      overflow:hidden;
    }
    .lane{
      position:absolute;
      left:0; right:0;
      height:33.333%;
      border-top:1px dashed rgba(51,65,85,.8);
      display:flex;
      align-items:center;
      justify-content:flex-start;
      padding:0 8px;
      pointer-events:none;
    }
    .lane:first-child{ top:0; border-top:none; }
    .lane:nth-child(2){ top:33.333%; }
    .lane:nth-child(3){ bottom:0; }

    .base-icon{
      width:54px;
      height:54px;
      border-radius:18px;
      display:grid;
      place-items:center;
      font-size:26px;
      background:radial-gradient(circle at 30% 20%,#e5e7eb,#cbd5f5);
      border:2px solid rgba(148,163,184,.9);
      box-shadow:0 12px 32px rgba(0,0,0,.8);
    }
    .base-icon.base-hit{
      animation:baseHit .25s ease-out;
    }
    @keyframes baseHit{
      0%{transform:scale(1); box-shadow:0 12px 32px rgba(0,0,0,.8);}
      50%{transform:scale(1.12); box-shadow:0 0 26px rgba(248,113,113,.95);}
      100%{transform:scale(1); box-shadow:0 12px 32px rgba(0,0,0,.8);}
    }

    /* Board towers */
    .tower-node{
      position:absolute;
      width:28px;
      height:28px;
      border-radius:999px;
      display:grid;
      place-items:center;
      font-size:16px;
      background:radial-gradient(circle at 30% 30%,#1f2937,#020617);
      border:1px solid rgba(148,163,184,.85);
      box-shadow:0 8px 18px rgba(0,0,0,.7);
      color:#f9fafb;
      cursor:pointer;
      z-index:5;
    }
    .tower-node.mine{
      box-shadow:0 0 0 1px rgba(251,191,36,.7), 0 10px 26px rgba(0,0,0,.9);
    }

    /* Marching enemy units */
    .unit{
      position:absolute;
      width:22px;
      height:22px;
      border-radius:999px;
      display:grid;
      place-items:center;
      font-size:13px;
      color:#0b1120;
      pointer-events:none;
      transform:translate(-9999px,-9999px);
      z-index:6;
    }
    .unit.march{
      transition:transform .1s linear;
    }
    .unit.fire{
      background:radial-gradient(circle at 30% 30%,#fed7aa,#fb923c,#b45309);
      box-shadow:0 0 0 2px rgba(251,146,60,.5), 0 0 20px rgba(248,113,113,.8);
    }
    .unit.ice{
      background:radial-gradient(circle at 30% 30%,#e0f2fe,#7dd3fc,#0369a1);
      box-shadow:0 0 0 2px rgba(56,189,248,.5), 0 0 20px rgba(125,211,252,.8);
    }
    .unit.stone{
      background:radial-gradient(circle at 30% 30%,#e5e7eb,#9ca3af,#475569);
      box-shadow:0 0 0 2px rgba(148,163,184,.6), 0 0 20px rgba(148,163,184,.9);
    }
    .unit-hit{
      opacity:.75;
      transform:scale(.85);
    }
    .unit-dead{
      opacity:0;
      transform:scale(.35);
      transition:opacity .18s linear, transform .18s linear;
    }

    .unit-hp{
      position:absolute;
      left:50%;
      bottom:-5px;
      transform:translateX(-50%);
      width:22px;
      height:3px;
      border-radius:999px;
      background:rgba(15,23,42,.9);
      overflow:hidden;
    }
    .unit-hp-fill{
      height:100%;
      width:100%;
      background:linear-gradient(90deg,#22c55e,#facc15,#ef4444);
    }

    /* Tower shots */
    .shot{
      position:absolute;
      width:6px;
      height:6px;
      border-radius:999px;
      background:radial-gradient(circle at 30% 30%,#fef3c7,#facc15,#b45309);
      box-shadow:0 0 10px rgba(250,204,21,.9);
      pointer-events:none;
      transition:transform .35s linear, opacity .35s linear;
      z-index:4;
    }

    .board-msg{
      position:absolute;
      inset:0;
      display:grid;
      place-items:center;
      font-size:.86rem;
      color:var(--muted);
      text-shadow:0 2px 6px rgba(0,0,0,.9);
      pointer-events:none;
      padding:0 16px;
      text-align:center;
    }

    /* Towers section */
    .towers-section{
      margin-top:8px;
      background:rgba(15,23,42,.95);
      border-radius:16px;
      padding:8px 10px;
      border:1px solid rgba(30,64,175,.8);
    }
    .towers-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      font-size:.84rem;
      color:var(--muted);
      margin-bottom:6px;
    }
    .towers-label{
      display:flex;
      align-items:center;
      gap:6px;
    }
    .tower-row{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .tower-pill{
      flex:0 0 auto;
      min-width:72px;
      padding:6px 8px;
      border-radius:999px;
      background:rgba(15,23,42,.9);
      border:1px solid rgba(148,163,184,.6);
      display:flex;
      align-items:center;
      gap:6px;
      font-size:.78rem;
      cursor:pointer;
      color:#e5e7eb;
    }
    .tower-pill.empty{
      border-style:dashed;
      color:var(--muted);
    }
    .tower-dot{
      width:16px;
      height:16px;
      border-radius:999px;
    }
    .tower-dot.fire{
      background:radial-gradient(circle at 30% 30%,#fed7aa,#fb923c,#b45309);
    }
    .tower-dot.ice{
      background:radial-gradient(circle at 30% 30%,#e0f2fe,#7dd3fc,#0369a1);
    }
    .tower-dot.stone{
      background:radial-gradient(circle at 30% 30%,#e5e7eb,#9ca3af,#475569);
    }

    /* Controls */
    .controls{
      margin-top:8px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .tier-row{
      display:flex;
      gap:6px;
      flex-wrap:wrap;
    }
    .tier-btn{
      flex:1 1 0;
      min-width:0;
      border-radius:999px;
      border:1px solid rgba(148,163,184,.7);
      background:rgba(15,23,42,.9);
      color:var(--muted);
      font-size:.8rem;
      padding:6px 10px;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:6px;
      cursor:pointer;
    }
    .tier-btn[aria-pressed="true"]{
      border-color:#fb923c;
      background:radial-gradient(circle at 30% 20%,#fed7aa,#fb923c);
      color:#111827;
    }

    .unit-row{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .btn{
      cursor:pointer;
      border-radius:999px;
      border:1px solid rgba(248,250,252,.1);
      background:linear-gradient(135deg,#f97316,#ea580c);
      color:#111827;
      font-weight:700;
      font-size:.85rem;
      padding:9px 12px;
      box-shadow:0 10px 24px rgba(0,0,0,.7);
      flex:1 1 90px;
      min-width:0;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:6px;
    }
    .btn span.small{
      font-size:.74rem;
      opacity:.85;
    }
    .btn:disabled{
      opacity:.4;
      box-shadow:none;
      cursor:default;
    }
    .btn-secondary{
      background:rgba(15,23,42,.9);
      border-color:rgba(148,163,184,.7);
      color:#e5e7eb;
      box-shadow:0 10px 22px rgba(0,0,0,.75);
      font-size:.8rem;
    }

    /* Tower overlay ‚Äì centered */
    .tower-overlay{
      position:fixed;
      left:50%;
      top:50%;
      transform:translate(-50%, -50%) scale(.9);
      background:#020617;
      border-radius:16px;
      border:1px solid rgba(148,163,184,.7);
      box-shadow:0 18px 40px rgba(0,0,0,.9);
      padding:10px 12px 10px;
      width:min(360px, 94vw);
      color:#e5e7eb;
      z-index:40;
      transition:transform .2s ease-out, opacity .2s;
      opacity:0;
      pointer-events:none;
    }
    .tower-overlay.show{
      transform:translate(-50%, -50%) scale(1);
      opacity:1;
      pointer-events:auto;
    }
    .tower-overlay-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      margin-bottom:6px;
      font-size:.86rem;
    }
    .tower-overlay-actions{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }

    .tiny-btn{
      border-radius:999px;
      border:1px solid rgba(148,163,184,.7);
      background:rgba(15,23,42,.9);
      color:#e5e7eb;
      font-size:.78rem;
      padding:6px 10px;
      display:inline-flex;
      align-items:center;
      gap:6px;
      cursor:pointer;
    }

    /* Radial tower element picker */
    .tower-overlay.radial-mode .tower-overlay-actions{
      position:relative;
      height:116px;
      justify-content:center;
    }
    .tower-overlay.radial-mode .tower-opt{
      position:absolute;
    }
    .tower-overlay.radial-mode .tower-opt-fire{
      top:0;
      left:50%;
      transform:translateX(-50%);
    }
    .tower-overlay.radial-mode .tower-opt-ice{
      top:44px;
      left:16%;
    }
    .tower-overlay.radial-mode .tower-opt-stone{
      top:44px;
      right:16%;
    }
    .tower-overlay.radial-mode .tower-opt-close{
      bottom:-2px;
      left:50%;
      transform:translateX(-50%);
    }

    /* Toast + error overlay */
    .toast{
      position:fixed;
      left:50%;
      bottom:18px;
      transform:translateX(-50%) translateY(80px);
      background:rgba(15,23,42,.98);
      color:#e5e7eb;
      padding:8px 14px;
      border-radius:999px;
      border:1px solid rgba(148,163,184,.7);
      box-shadow:0 10px 30px rgba(0,0,0,.85);
      font-size:.8rem;
      opacity:0;
      pointer-events:none;
      transition:opacity .18s, transform .18s;
      z-index:60;
    }
    .toast.show{
      opacity:1;
      transform:translateX(-50%) translateY(0);
    }

    .overlay{
      position:fixed;
      inset:0;
      background:radial-gradient(circle at 10% 0%,rgba(248,113,113,.25),transparent 60%), rgba(15,23,42,.96);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:80;
    }
    .overlay.hidden{ display:none; }
    .overlay-card{
      background:#020617;
      border-radius:20px;
      padding:18px 18px 16px;
      border:1px solid rgba(248,113,113,.6);
      box-shadow:0 18px 45px rgba(0,0,0,.9);
      max-width:360px;
      width:90%;
      color:#fee2e2;
      text-align:center;
      font-size:.9rem;
    }
    .overlay-card h2{
      margin:0 0 8px;
      font-size:1.05rem;
      font-weight:800;
    }
    .overlay-card button{
      border-radius:999px;
      border:none;
      background:#f97316;
      color:#111827;
      font-weight:700;
      padding:8px 14px;
      cursor:pointer;
      margin-top:8px;
    }

    @media (max-width:720px){
      .shell{ padding:8px 8px 20px; }
      .player-panel{ padding:8px; }
      .board{ min-height:210px; }
      .btn{ width:100%; }
      .unit-row{ flex-direction:column; }
      .tier-row{ flex-direction:row; }
    }
  </style>
</head>
<body>
  <div class="shell">
    <!-- HUD -->
    <div class="hud">
      <div class="hud-row">
        <div class="player-panel">
          <div class="player-name">
            <span id="youName">You</span>
            <span class="role-label" id="youRole">Connecting‚Ä¶</span>
          </div>
          <div class="hp-wrap">
            <div class="hp-bar"><div id="yourHpFill" class="hp-fill"></div></div>
            <span id="yourHpText">400</span>
          </div>
        </div>
        <div class="vs-pill">VS</div>
        <div class="player-panel">
          <div class="player-name">
            <span id="oppName">Opponent</span>
            <span class="role-label" id="oppRole">Waiting‚Ä¶</span>
          </div>
          <div class="hp-wrap">
            <div class="hp-bar"><div id="oppHpFill" class="hp-fill"></div></div>
            <span id="oppHpText">400</span>
          </div>
        </div>
      </div>

      <div class="meta-row">
        <div class="gold-pill">
          <span class="coin"></span>
          <span>Gold: <strong id="goldAmount">0</strong></span>
          <span style="font-size:.78rem;opacity:.85;">Gen <span id="genLevel">1</span></span>
        </div>
        <div class="meta-right">
          <span id="statusText">Connecting to lobby‚Ä¶</span>
          <button id="fullBtn" class="btn-ghost" type="button">‚õ∂ Fullscreen</button>
        </div>
      </div>
    </div>

    <!-- GAME -->
    <div class="game-card">
      <div class="game-head">
        <div class="game-head-title">
          <span>üè∞ Base War ‚Äî Elemental Siege</span>
        </div>
        <div id="gameIdLabel"></div>
      </div>
      <div class="game-body">
        <div class="board" id="board">
          <div class="lane" data-lane="0">
            <div class="base-icon">üõ°Ô∏è</div>
          </div>
          <div class="lane" data-lane="1">
            <div class="base-icon">üõ°Ô∏è</div>
          </div>
          <div class="lane" data-lane="2">
            <div class="base-icon">üõ°Ô∏è</div>
          </div>
          <div class="board-msg" id="boardMessage">Waiting for game state‚Ä¶</div>
        </div>

        <!-- Towers -->
        <div class="towers-section">
          <div class="towers-head">
            <div class="towers-label">
              <span>üóº Your Towers</span>
            </div>
            <button id="buyTowerBtn" class="tiny-btn" type="button">
              ‚ûï New Tower Slot
            </button>
          </div>
          <div id="towerRow" class="tower-row"><!-- towers --></div>
        </div>

        <!-- Controls -->
        <div class="controls">
          <div class="tier-row">
            <button class="tier-btn" id="tier1Btn" type="button" aria-pressed="true">Tier I</button>
            <button class="tier-btn" id="tier2Btn" type="button" aria-pressed="false">Tier II</button>
            <button class="tier-btn" id="tier3Btn" type="button" aria-pressed="false">Tier III</button>
          </div>
          <div class="unit-row" id="unitRow">
            <!-- unit buttons injected -->
          </div>
          <div class="unit-row">
            <button id="scoutBtn" class="btn btn-secondary" type="button">
              <span>üëÅÔ∏è Scout Enemy</span>
              <span class="small" id="scoutCostLabel">(10g)</span>
            </button>
            <button id="genBtn" class="btn btn-secondary" type="button">
              <span>‚öôÔ∏è Upgrade Generator</span>
              <span class="small" id="genCostLabel">(‚Äì)</span>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Tower overlay -->
  <div id="towerOverlay" class="tower-overlay">
    <div class="tower-overlay-head">
      <span id="towerOverlayTitle">Tower</span>
      <button id="towerOverlayClose" class="tiny-btn" type="button">‚úï</button>
    </div>
    <div id="towerOverlayBody" style="font-size:.8rem;margin-bottom:6px;"></div>
    <div id="towerOverlayActions" class="tower-overlay-actions"></div>
  </div>

  <!-- Toast -->
  <div id="toast" class="toast"></div>

  <!-- Fatal overlay -->
  <div id="errorOverlay" class="overlay hidden">
    <div class="overlay-card">
      <h2>Unable to join match</h2>
      <p id="errorMessage"></p>
      <button onclick="window.location.href='/'">Back to Hub</button>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import {
      getFirestore, doc, getDoc, setDoc, onSnapshot,
      collection, addDoc, runTransaction, serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
    import {
      getAuth, signInAnonymously, onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

    // ---- Firebase config ----
    const firebaseConfig = {
      apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
      authDomain: "bible-game-246c0.firebaseapp.com",
      databaseURL: "https://bible-game-246c0-default-rtdb.firebaseio.com",
      projectId: "bible-game-246c0",
      storageBucket: "bible-game-246c0.firebasestorage.app",
      messagingSenderId: "959619818996",
      appId: "1:959619818996:web:5a9fbf492e23c765e445a1",
      measurementId: "G-8PR6LVKSH3"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    // ---- URL params from Game Hub ----
    const params = new URLSearchParams(window.location.search);
    const lobbyId = params.get("gameId");
    const username = (params.get("username") || "").trim();

    // ---- DOM refs ----
    const youNameEl = document.getElementById("youName");
    const oppNameEl = document.getElementById("oppName");
    const youRoleEl = document.getElementById("youRole");
    const oppRoleEl = document.getElementById("oppRole");
    const statusEl = document.getElementById("statusText");
    const gameIdLabelEl = document.getElementById("gameIdLabel");
    const yourHpFillEl = document.getElementById("yourHpFill");
    const oppHpFillEl = document.getElementById("oppHpFill");
    const yourHpTextEl = document.getElementById("yourHpText");
    const oppHpTextEl = document.getElementById("oppHpText");
    const goldEl = document.getElementById("goldAmount");
    const genLevelEl = document.getElementById("genLevel");
    const boardEl = document.getElementById("board");
    const boardMsgEl = document.getElementById("boardMessage");
    const fullBtn = document.getElementById("fullBtn");
    const towerRowEl = document.getElementById("towerRow");
    const buyTowerBtn = document.getElementById("buyTowerBtn");
    const tier1Btn = document.getElementById("tier1Btn");
    const tier2Btn = document.getElementById("tier2Btn");
    const tier3Btn = document.getElementById("tier3Btn");
    const unitRowEl = document.getElementById("unitRow");
    const genBtn = document.getElementById("genBtn");
    const genCostLabelEl = document.getElementById("genCostLabel");
    const scoutBtn = document.getElementById("scoutBtn");
    const scoutCostLabelEl = document.getElementById("scoutCostLabel");
    const toastEl = document.getElementById("toast");
    const overlayEl = document.getElementById("errorOverlay");
    const overlayMsgEl = document.getElementById("errorMessage");
    const towerOverlayEl = document.getElementById("towerOverlay");
    const towerOverlayTitleEl = document.getElementById("towerOverlayTitle");
    const towerOverlayBodyEl = document.getElementById("towerOverlayBody");
    const towerOverlayActionsEl = document.getElementById("towerOverlayActions");
    const towerOverlayCloseBtn = document.getElementById("towerOverlayClose");

    // ---- Game constants ----
    const MAX_BASE_HP = 400;
    const MAX_TOWERS = 4;
    const SCOUT_COST = 10;

    const ELEMENT_COUNTER = {
      fire: "stone",
      stone: "ice",
      ice: "fire"
    };

    const UNITS = {
      // Tier 1
      f1: { id:"f1", name:"Emberlings", emoji:"üî•", element:"fire", tier:1,
            cost:20, count:5, hp:10, damage:5, killGold:3, hitGold:3 },
      i1: { id:"i1", name:"Frost Scouts", emoji:"‚ùÑÔ∏è", element:"ice", tier:1,
            cost:22, count:4, hp:11, damage:6, killGold:3, hitGold:3 },
      s1: { id:"s1", name:"Pebble Guard", emoji:"ü™®", element:"stone", tier:1,
            cost:25, count:3, hp:14, damage:8, killGold:4, hitGold:3 },
      // Tier 2
      f2: { id:"f2", name:"Flame Knights", emoji:"‚öîÔ∏è", element:"fire", tier:2,
            cost:40, count:4, hp:18, damage:15, killGold:5, hitGold:5 },
      i2: { id:"i2", name:"Aurora Priests", emoji:"üíß", element:"ice", tier:2,
            cost:42, count:4, hp:18, damage:14, killGold:5, hitGold:5 },
      s2: { id:"s2", name:"Shard Swarm", emoji:"üåÄ", element:"stone", tier:2,
            cost:45, count:4, hp:16, damage:14, killGold:5, hitGold:5 },
      // Tier 3
      f3: { id:"f3", name:"Inferno Titan", emoji:"üåã", element:"fire", tier:3,
            cost:70, count:3, hp:28, damage:30, killGold:8, hitGold:7 },
      i3: { id:"i3", name:"Glacier Warden", emoji:"üßä", element:"ice", tier:3,
            cost:72, count:3, hp:30, damage:28, killGold:8, hitGold:7 },
      s3: { id:"s3", name:"Obsidian Colossus", emoji:"üóø", element:"stone", tier:3,
            cost:80, count:4, hp:30, damage:30, killGold:9, hitGold:8 }
    };

    // Towers intentionally not crazy-strong
    const TOWER_POWER_PER_LEVEL = [0, 30, 55, 80]; // index 1..3
    const BASE_INCOME_PER_SEC = 3.5;

    const START_TOWERS = [
      { element:"none", level:0, lane:0 },
      { element:"none", level:0, lane:1 },
      { element:"none", level:0, lane:2 }
    ];

    // ---- Local state ----
    const state = {
      seat: null,           // 1, 2, or 'spec'
      isSpectator: false,
      isHost: false,
      myName: username || "You",
      oppName: "Opponent",
      gameRef: null,
      cmdsRef: null,
      gameData: null,
      currentTier: 1,
      selectedTowerIndex: null
    };

    // ---- Toast + full-screen helpers ----
    let toastTimer = null;
    function showToast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      if (toastTimer) clearTimeout(toastTimer);
      toastTimer = setTimeout(()=> toastEl.classList.remove("show"), 1700);
    }
    function showFatal(msg){
      overlayMsgEl.textContent = msg;
      overlayEl.classList.remove("hidden");
      statusEl.textContent = msg;
      disableAllActions();
    }
    function disableAllActions(){
      document.querySelectorAll(".btn, .tiny-btn, .tier-btn").forEach(b => b.disabled = true);
    }
    fullBtn.addEventListener("click", () => {
      if (!document.fullscreenElement){
        document.documentElement.requestFullscreen?.();
      } else {
        document.exitFullscreen?.();
      }
    });

    // ---- Board geometry + visuals ----
    let boardGeom = null;           // { boardRect, lanesGeom: [{y, baseX, spawnX}, ...] }
    let boardTowerNodes = [];       // [{ el, side, laneIndex, x, y, level, element }, ...]
    let marchingUnits = [];         // [{ el, laneIndex, progress, duration, spawnX, baseX, x, y, hp, maxHp, hpFill, unitId, baseDamage }, ...]
    let lastAnimTime = null;
    let lastShotTime = 0;
    const MARCH_DURATION_MS = 6500;
    const SHOT_INTERVAL_MS = 350;

    // Local base-damage batching (combat is fully local, only HP deltas are synced)
    let pendingBaseDamage = 0;
    let pendingDamageTimer = null;
    const BASE_HIT_BATCH_MS = 200;

    function registerBaseHit(damage){
      if (state.isSpectator || damage <= 0) return;
      pendingBaseDamage += damage;
      if (!pendingDamageTimer){
        pendingDamageTimer = setTimeout(() => {
          const dmg = pendingBaseDamage;
          pendingBaseDamage = 0;
          pendingDamageTimer = null;
          if (dmg > 0){
            sendBaseDamage(dmg).catch(err => console.error("sendBaseDamage failed", err));
          }
        }, BASE_HIT_BATCH_MS);
      }
    }

    function computeBoardGeom(){
      if (!boardEl) return;
      const boardRect = boardEl.getBoundingClientRect();
      const lanesEls = boardEl.querySelectorAll(".lane");
      const lanesGeom = [];
      lanesEls.forEach(lane => {
        const base = lane.querySelector(".base-icon");
        if (!base) return;
        const baseRect = base.getBoundingClientRect();
        const y = baseRect.top + baseRect.height/2 - boardRect.top;
        const baseX = baseRect.left + baseRect.width/2 - boardRect.left;
        const spawnX = boardRect.width - 28; // enemy spawn from far right
        lanesGeom.push({ y, baseX, spawnX });
      });
      boardGeom = { boardRect, lanesGeom };
    }

    window.addEventListener("resize", ()=>{
      boardGeom = null;
      if (state.gameData){
        computeBoardGeom();
        renderBoardTowers();
      }
    });

    // ---- Auth + init ----
    if (!lobbyId || !username){
      showFatal("Missing lobby or username. Launch this game from the Game Hub.");
    } else {
      gameIdLabelEl.textContent = `Lobby: ${lobbyId.slice(0,8)}‚Ä¶`;
      statusEl.textContent = "Signing in‚Ä¶";
      signInAnonymously(auth).catch(err => {
        console.error("Anon sign-in failed", err);
        showFatal("Authentication error. Please reopen via the hub.");
      });

      onAuthStateChanged(auth, (user) => {
        if (!user) return;
        initFromLobby().catch(err => {
          console.error(err);
          showFatal("Error joining this match. It may have been closed.");
        });
      });
    }

    async function initFromLobby(){
      statusEl.textContent = "Connecting to lobby‚Ä¶";
      const lobbyRef = doc(db, "lobbies", lobbyId);
      const lobbySnap = await getDoc(lobbyRef);
      if (!lobbySnap.exists()){
        showFatal("Lobby not found. It may have expired.");
        return;
      }
      const lobby = lobbySnap.data();
      const players = Array.isArray(lobby.players) ? lobby.players : [];
      const hostName = lobby.host || null;

      const myIndex = players.indexOf(username);
      if (myIndex === -1){
        showFatal("You are not listed as a player in this lobby.");
        return;
      }

      if (myIndex === 0) state.seat = 1;
      else if (myIndex === 1) state.seat = 2;
      else {
        state.seat = "spec";
        state.isSpectator = true;
      }
      state.isHost = (username === hostName);
      state.myName = username;
      state.oppName = (state.seat === 1 ? players[1] : players[0]) || "Waiting‚Ä¶";

      youNameEl.textContent = state.myName;
      oppNameEl.textContent = state.oppName;
      youRoleEl.textContent = state.isSpectator ? "Spectating" : (state.isHost ? "Host" : "Guest");
      oppRoleEl.textContent = state.oppName === "Waiting‚Ä¶" ? "Not joined" :
                              (state.seat === 1 ? "Seat 2" : "Seat 1");

      if (state.isSpectator){
        statusEl.textContent = "You are spectating this match.";
      } else {
        statusEl.textContent = "Connected. Build towers and send waves!";
      }

      state.gameRef = doc(db, "games_basewar", lobbyId);
      state.cmdsRef = collection(state.gameRef, "commands");

      const gameSnap = await getDoc(state.gameRef);
      if (!gameSnap.exists() && state.isHost){
        const nowMs = Date.now();
        await setDoc(state.gameRef, {
          createdAt: serverTimestamp(),
          lobbyId,
          p1Name: players[0] || null,
          p2Name: players[1] || null,
          status: "playing",
          maxBase: MAX_BASE_HP,
          base1: MAX_BASE_HP,
          base2: MAX_BASE_HP,
          gold1: 100,
          gold2: 100,
          gen1: 1,
          gen2: 1,
          incomePerSec1: BASE_INCOME_PER_SEC,
          incomePerSec2: BASE_INCOME_PER_SEC,
          lastIncomeMs1: nowMs,
          lastIncomeMs2: nowMs,
          towers1: START_TOWERS.map(t => ({...t})),
          towers2: START_TOWERS.map(t => ({...t})),
          lastCmdTs: 0
        }, { merge:true });
      }

      onSnapshot(state.gameRef, (snap) => {
        if (!snap.exists()) return;
        state.gameData = snap.data();
        updateFromGame();
      });

      onSnapshot(state.cmdsRef, (snap) => {
        snap.docChanges().forEach(ch => {
          if (ch.type !== "added") return;
          const cmd = ch.doc.data();
          handleCommandVisual(cmd);
          // Process commands on both players (transaction + lastCmdTs keeps it safe)
          processCommand(cmd).catch(err => console.error("processCommand error", err));
        });
      });

      setupLocalUI();
    }

    // ---- UI update ----
    function updateFromGame(){
      const d = state.gameData;
      if (!d) return;

      const base1 = d.base1 ?? MAX_BASE_HP;
      const base2 = d.base2 ?? MAX_BASE_HP;
      const gold1 = d.gold1 ?? 0;
      const gold2 = d.gold2 ?? 0;
      const gen1 = d.gen1 ?? 1;
      const gen2 = d.gen2 ?? 1;
      const status = d.status || "playing";

      let myBase, oppBase, myGold, myGen;
      if (state.seat === 1){
        myBase = base1; oppBase = base2;
        myGold = gold1; myGen = gen1;
      } else if (state.seat === 2){
        myBase = base2; oppBase = base1;
        myGold = gold2; myGen = gen2;
      } else {
        myBase = base1; oppBase = base2;
        myGold = 0; myGen = gen1;
      }

      const myPct = Math.max(0, Math.min(100, (myBase / MAX_BASE_HP) * 100));
      const oppPct = Math.max(0, Math.min(100, (oppBase / MAX_BASE_HP) * 100));
      yourHpFillEl.style.width = myPct + "%";
      oppHpFillEl.style.width = oppPct + "%";
      yourHpTextEl.textContent = String(myBase);
      oppHpTextEl.textContent = String(oppBase);

      if (!state.isSpectator){
        goldEl.textContent = String(Math.floor(myGold));
        genLevelEl.textContent = String(myGen);
      } else {
        goldEl.textContent = "-";
        genLevelEl.textContent = String(myGen);
      }

      renderTowersList();
      renderBoardTowers();

      if (status === "ended" || myBase <= 0 || oppBase <= 0){
        let msg = "Battle over.";
        if (!state.isSpectator){
          if (myBase <= 0 && oppBase <= 0) msg = "Draw!";
          else if (myBase <= 0) msg = "Defeat!";
          else if (oppBase <= 0) msg = "Victory!";
        } else {
          if (base1 <= 0 && base2 <= 0) msg = "Draw!";
          else if (base1 <= 0) msg = `${state.p2Name || "Player 2"} wins!`;
          else if (base2 <= 0) msg = `${state.p1Name || "Player 1"} wins!`;
        }
        boardMsgEl.textContent = msg;
        statusEl.textContent = msg;
        disableAllActions();
      } else {
        boardMsgEl.textContent = "Defend your base with towers and send waves at your opponent.";
      }

      updateCostLabels();
    }

    function renderTowersList(){
      const d = state.gameData;
      if (!d) return;
      const side = (state.seat === 2) ? 2 : 1;
      const towersKey = side === 1 ? "towers1" : "towers2";
      const towers = Array.isArray(d[towersKey]) ? d[towersKey] : [];
      towerRowEl.innerHTML = "";

      towers.forEach((t, idx) => {
        const pill = document.createElement("button");
        pill.type = "button";
        pill.className = "tower-pill";
        pill.dataset.index = String(idx);

        const dot = document.createElement("span");
        dot.className = "tower-dot";
        if (t.element === "fire") dot.classList.add("fire");
        else if (t.element === "ice") dot.classList.add("ice");
        else if (t.element === "stone") dot.classList.add("stone");
        else {
          pill.classList.add("empty");
        }

        const label = document.createElement("span");
        if (!t.element || t.element === "none" || t.level === 0){
          label.textContent = `Slot ${idx+1} (Empty)`;
        } else {
          label.textContent = `${capitalize(t.element)} Lv${t.level || 1}`;
        }

        pill.appendChild(dot);
        pill.appendChild(label);
        towerRowEl.appendChild(pill);
      });

      if (!state.isSpectator && towers.length < MAX_TOWERS){
        const ghost = document.createElement("div");
        ghost.className = "tower-pill empty";
        ghost.innerHTML = "<span class='tower-dot'></span><span>Add slot‚Ä¶</span>";
        towerRowEl.appendChild(ghost);
      }
    }

    function renderBoardTowers(){
      boardEl.querySelectorAll(".tower-node").forEach(n => n.remove());
      boardTowerNodes = [];
      if (!state.gameData) return;
      if (!boardGeom) computeBoardGeom();
      if (!boardGeom) return;

      const lanesGeom = boardGeom.lanesGeom;
      const laneCount = lanesGeom.length || 1;
      const mySide = (state.seat === 2 ? 2 : 1);

      const towersKey = mySide === 1 ? "towers1" : "towers2";
      const towers = Array.isArray(state.gameData[towersKey]) ? state.gameData[towersKey] : [];

      towers.forEach((t, idx) => {
        const laneIndex = typeof t.lane === "number" ? (t.lane % laneCount) : (idx % laneCount);
        const laneInfo = lanesGeom[laneIndex];
        if (!laneInfo) return;

        const baseX = laneInfo.baseX;
        const offsetIndex = Math.floor(idx / laneCount);
        const offset = 40 + offsetIndex * 24; // towers to the right of your base
        const x = baseX + offset;
        const y = laneInfo.y;

        const node = document.createElement("div");
        node.className = "tower-node mine";
        node.style.left = (x - 14) + "px";
        node.style.top = (y - 14) + "px";
        node.dataset.side = String(mySide);
        node.dataset.index = String(idx);

        const emoji = (!t.element || t.element === "none") ? "üóº" : emojiForElement(t.element);
        node.textContent = emoji;
        boardEl.appendChild(node);

        boardTowerNodes.push({
          el: node,
          side: mySide,
          laneIndex,
          x,
          y,
          level: t.level || 0,
          element: t.element || "none"
        });
      });
    }

    function updateCostLabels(){
      const d = state.gameData;
      if (!d) return;
      const side = (state.seat === 2) ? 2 : 1;
      const genCost = calcGenCost(d, side);
      genCostLabelEl.textContent = genCost === Infinity ? "(Max)" : `(${genCost}g)`;
      scoutCostLabelEl.textContent = `(${SCOUT_COST}g)`;

      document.querySelectorAll("[data-unit-id]").forEach(btn => {
        const id = btn.dataset.unitId;
        const u = UNITS[id];
        if (!u) return;
        const costSpan = btn.querySelector(".small");
        if (costSpan) costSpan.textContent = `${u.cost}g`;
      });
    }

    // ---- Local UI setup ----
    function setupLocalUI(){
      if (state.isSpectator){
        disableAllActions();
      }

      function setTier(t){
        state.currentTier = t;
        tier1Btn.setAttribute("aria-pressed", t === 1 ? "true" : "false");
        tier2Btn.setAttribute("aria-pressed", t === 2 ? "true" : "false");
        tier3Btn.setAttribute("aria-pressed", t === 3 ? "true" : "false");
        renderUnitButtons();
        updateCostLabels();
      }
      tier1Btn.addEventListener("click", ()=> setTier(1));
      tier2Btn.addEventListener("click", ()=> setTier(2));
      tier3Btn.addEventListener("click", ()=> setTier(3));
      renderUnitButtons();

      if (!state.isSpectator){
        buyTowerBtn.addEventListener("click", onBuyTowerClick);
        towerRowEl.addEventListener("click", onTowerRowClick);
        genBtn.addEventListener("click", onGenUpgradeClick);
        scoutBtn.addEventListener("click", onScoutClick);
        unitRowEl.addEventListener("click", onUnitRowClick);
        boardEl.addEventListener("click", onBoardTowerClick);
      } else {
        buyTowerBtn.disabled = true;
        genBtn.disabled = true;
        scoutBtn.disabled = true;
      }

      towerOverlayCloseBtn.addEventListener("click", hideTowerOverlay);
    }

    function renderUnitButtons(){
      unitRowEl.innerHTML = "";
      const tier = state.currentTier;
      const ids = Object.values(UNITS).filter(u => u.tier === tier).map(u => u.id);
      ids.forEach(id => {
        const u = UNITS[id];
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "btn";
        btn.dataset.unitId = id;

        const left = document.createElement("span");
        left.textContent = `${u.emoji} ${u.name}`;
        const right = document.createElement("span");
        right.className = "small";
        right.textContent = `${u.cost}g`;

        btn.appendChild(left);
        btn.appendChild(right);
        unitRowEl.appendChild(btn);
      });
    }

    // ---- Local UI handlers ----
    function onUnitRowClick(ev){
      const btn = ev.target.closest("[data-unit-id]");
      if (!btn || state.isSpectator || !state.gameData) return;
      const id = btn.dataset.unitId;
      const d = state.gameData;
      const side = (state.seat === 2) ? 2 : 1;
      const cost = calcWaveCost(d, side, id);
      const goldKey = side === 1 ? "gold1" : "gold2";
      const currentGold = d[goldKey] ?? 0;
      if (currentGold < cost){
        showToast("Not enough gold for that wave.");
        return;
      }
      sendWave(id).catch(err => {
        console.error(err);
        showToast("Failed to send wave.");
      });
    }

    function onGenUpgradeClick(){
      if (state.isSpectator || !state.gameData) return;
      const d = state.gameData;
      const side = (state.seat === 2) ? 2 : 1;
      const cost = calcGenCost(d, side);
      const goldKey = side === 1 ? "gold1" : "gold2";
      const currentGold = d[goldKey] ?? 0;
      if (currentGold < cost){
        showToast("Not enough gold to upgrade generator.");
        return;
      }
      sendGenUpgrade().catch(err => {
        console.error(err);
        showToast("Failed to upgrade generator.");
      });
    }

    function onScoutClick(){
      if (state.isSpectator || !state.gameData) return;
      const d = state.gameData;
      const side = (state.seat === 2) ? 2 : 1;
      const goldKey = side === 1 ? "gold1" : "gold2";
      const currentGold = d[goldKey] ?? 0;
      if (currentGold < SCOUT_COST){
        showToast("Not enough gold to scout.");
        return;
      }
      sendScout().catch(err => {
        console.error(err);
        showToast("Failed to send scout.");
      });
    }

    function onBuyTowerClick(){
      if (state.isSpectator || !state.gameData) return;
      const d = state.gameData;
      const side = (state.seat === 2) ? 2 : 1;
      const towersKey = side === 1 ? "towers1" : "towers2";
      const towers = Array.isArray(d[towersKey]) ? d[towersKey] : [];
      if (towers.length >= MAX_TOWERS){
        showToast("Tower cap reached.");
        return;
      }
      const cost = calcTowerSlotCost(d, side);
      const goldKey = side === 1 ? "gold1" : "gold2";
      const currentGold = d[goldKey] ?? 0;
      if (currentGold < cost){
        showToast("Not enough gold for a new tower slot.");
        return;
      }
      sendTowerSlot().catch(err => {
        console.error(err);
        showToast("Failed to buy tower slot.");
      });
    }

    function onTowerRowClick(ev){
      if (state.isSpectator || !state.gameData) return;
      const pill = ev.target.closest(".tower-pill");
      if (!pill || !pill.dataset.index) return;
      const idx = parseInt(pill.dataset.index, 10);
      openTowerOverlay(idx);
    }

    function onBoardTowerClick(ev){
      if (state.isSpectator || !state.gameData) return;
      const node = ev.target.closest(".tower-node");
      if (!node) return;
      const side = parseInt(node.dataset.side, 10);
      const mySide = (state.seat === 2 ? 2 : 1);
      if (side !== mySide) return;
      const idx = parseInt(node.dataset.index, 10);
      openTowerOverlay(idx);
    }

    // ---- Cost helpers ----
    function calcGenCost(d, side){
      const genKey = side === 1 ? "gen1" : "gen2";
      const gen = d[genKey] ?? 1;
      if (gen >= 4) return Infinity;
      return 50 + (gen - 1) * 40; // 50,90,130
    }

    function calcTowerSlotCost(d, side){
      const towersKey = side === 1 ? "towers1" : "towers2";
      const towers = Array.isArray(d[towersKey]) ? d[towersKey] : [];
      const base = 45;
      return base + towers.length * 25; // 45,70,95,120
    }

    function calcTowerUpgradeCost(d, side, index){
      const towersKey = side === 1 ? "towers1" : "towers2";
      const towers = Array.isArray(d[towersKey]) ? d[towersKey] : [];
      const t = towers[index];
      if (!t) return Infinity;
      const lvl = t.level || 0;
      if (lvl >= 3) return Infinity;
      return lvl === 0 ? 30 : (lvl === 1 ? 50 : 80);
    }

    function calcWaveCost(d, side, unitId){
      const u = UNITS[unitId];
      if (!u) return Infinity;
      return u.cost;
    }

    // ---- Commands: client ‚Üí Firestore ----
    async function sendWave(unitId){
      if (!state.cmdsRef || state.isSpectator) return;
      const side = (state.seat === 2) ? 2 : 1;
      await addDoc(state.cmdsRef, {
        cmd: "wave",
        side,
        unitId,
        createdAt: serverTimestamp()
      });
    }

    async function sendGenUpgrade(){
      if (!state.cmdsRef || state.isSpectator) return;
      const side = (state.seat === 2) ? 2 : 1;
      await addDoc(state.cmdsRef, {
        cmd: "gen",
        side,
        createdAt: serverTimestamp()
      });
    }

    async function sendScout(){
      if (!state.cmdsRef || state.isSpectator) return;
      const side = (state.seat === 2) ? 2 : 1;
      await addDoc(state.cmdsRef, {
        cmd: "scout",
        side,
        createdAt: serverTimestamp()
      });
    }

    async function sendTowerSlot(){
      if (!state.cmdsRef || state.isSpectator) return;
      const side = (state.seat === 2) ? 2 : 1;
      await addDoc(state.cmdsRef, {
        cmd: "towerSlot",
        side,
        createdAt: serverTimestamp()
      });
    }

    async function sendTowerPath(index, element){
      if (!state.cmdsRef || state.isSpectator) return;
      const side = (state.seat === 2) ? 2 : 1;
      await addDoc(state.cmdsRef, {
        cmd: "towerPath",
        side,
        index,
        element,
        createdAt: serverTimestamp()
      });
      hideTowerOverlay();
    }

    async function sendTowerUpgrade(index){
      if (!state.cmdsRef || state.isSpectator) return;
      const side = (state.seat === 2) ? 2 : 1;
      await addDoc(state.cmdsRef, {
        cmd: "towerUp",
        side,
        index,
        createdAt: serverTimestamp()
      });
      hideTowerOverlay();
    }

    async function sendBaseDamage(damage){
      if (!state.cmdsRef || state.isSpectator) return;
      const side = (state.seat === 2) ? 2 : 1; // the base that got hit (you)
      await addDoc(state.cmdsRef, {
        cmd: "baseHit",
        side,
        damage,
        createdAt: serverTimestamp()
      });
    }

    // ---- Host/Players: process commands ----
    async function processCommand(cmd){
      // Let each non-spectator client process via transaction; lastCmdTs keeps it safe
      if (state.isSpectator || !state.gameRef) return;

      await runTransaction(db, async (tx) => {
        const snap = await tx.get(state.gameRef);
        if (!snap.exists()) return;
        const d = snap.data();
        const cmdTs = cmd.createdAt && cmd.createdAt.toMillis ? cmd.createdAt.toMillis() : 0;
        const lastTs = d.lastCmdTs ?? 0;
        if (cmdTs <= lastTs) return;

        const nowMs = Date.now();
        const updates = {};

        applyIncome(d, updates, 1, nowMs);
        applyIncome(d, updates, 2, nowMs);

        switch (cmd.cmd){
          case "wave":
            applyWave(d, updates, cmd);
            break;
          case "gen":
            applyGenUpgrade(d, updates, cmd);
            break;
          case "scout":
            applyScout(d, updates, cmd);
            break;
          case "towerSlot":
            applyTowerSlot(d, updates, cmd);
            break;
          case "towerPath":
            applyTowerPath(d, updates, cmd);
            break;
          case "towerUp":
            applyTowerUpgrade(d, updates, cmd);
            break;
          case "baseHit":
            applyBaseHit(d, updates, cmd);
            break;
        }

        updates.lastCmdTs = cmdTs;
        tx.update(state.gameRef, updates);
      });
    }

    function applyIncome(d, updates, side, nowMs){
      const goldKey = side === 1 ? "gold1" : "gold2";
      const incomeKey = side === 1 ? "incomePerSec1" : "incomePerSec2";
      const lastKey = side === 1 ? "lastIncomeMs1" : "lastIncomeMs2";

      const last = d[lastKey] ?? nowMs;
      let dt = (nowMs - last) / 1000;
      if (dt <= 0.1){
        updates[lastKey] = nowMs;
        d[lastKey] = nowMs;
        return;
      }
      dt = Math.min(dt, 30);
      const baseRate = d[incomeKey] ?? BASE_INCOME_PER_SEC;
      const delta = Math.floor(baseRate * dt);
      if (delta > 0){
        const newGold = (d[goldKey] ?? 0) + delta;
        d[goldKey] = newGold;
        updates[goldKey] = newGold;
      }
      d[lastKey] = nowMs;
      updates[lastKey] = nowMs;
    }

    // SERVER: ONLY pay for the wave; combat is fully local on each client
    function applyWave(d, updates, cmd){
      const side = cmd.side === 2 ? 2 : 1;
      const unit = UNITS[cmd.unitId];
      if (!unit) return;

      const goldKeyAtk = side === 1 ? "gold1" : "gold2";
      let goldAtk = d[goldKeyAtk] ?? 0;
      const cost = unit.cost;

      if (goldAtk < cost) return; // not enough gold; ignore

      goldAtk -= cost;
      d[goldKeyAtk] = goldAtk;
      updates[goldKeyAtk] = goldAtk;
    }

    // Left in place though unused now (old server-side defense calc)
    function computeDefensePower(d, towers, unit, defGen){
      let total = 0;
      for (const t of towers){
        const lvl = t.level || 0;
        if (!lvl || !t.element || t.element === "none") continue;
        let p = TOWER_POWER_PER_LEVEL[lvl] || 0;
        const te = t.element;
        const ue = unit.element;
        if (te && ue){
          if (te === ELEMENT_COUNTER[ue]){
            p *= 1.35; // strong vs that element
          } else if (ue === ELEMENT_COUNTER[te]){
            p *= 0.75; // weak vs that element
          }
        }
        total += p;
      }
      total *= 1 + (defGen - 1) * 0.18;
      return total;
    }

    function applyGenUpgrade(d, updates, cmd){
      const side = cmd.side === 2 ? 2 : 1;
      const goldKey = side === 1 ? "gold1" : "gold2";
      const genKey = side === 1 ? "gen1" : "gen2";
      const incomeKey = side === 1 ? "incomePerSec1" : "incomePerSec2";

      let gold = d[goldKey] ?? 0;
      let gen = d[genKey] ?? 1;
      if (gen >= 4) return;
      const cost = 50 + (gen - 1) * 40;
      if (gold < cost) return;

      gold -= cost;
      gen += 1;
      const income = (d[incomeKey] ?? BASE_INCOME_PER_SEC) + 1.3;

      d[goldKey] = gold; updates[goldKey] = gold;
      d[genKey] = gen; updates[genKey] = gen;
      d[incomeKey] = income; updates[incomeKey] = income;
    }

    function applyScout(d, updates, cmd){
      const side = cmd.side === 2 ? 2 : 1;
      const goldKey = side === 1 ? "gold1" : "gold2";
      let gold = d[goldKey] ?? 0;
      const cost = SCOUT_COST;
      if (gold < cost) return;
      gold -= cost;
      d[goldKey] = gold;
      updates[goldKey] = gold;
    }

    function applyTowerSlot(d, updates, cmd){
      const side = cmd.side === 2 ? 2 : 1;
      const goldKey = side === 1 ? "gold1" : "gold2";
      const towersKey = side === 1 ? "towers1" : "towers2";

      let gold = d[goldKey] ?? 0;
      const towers = Array.isArray(d[towersKey]) ? d[towersKey].slice() : [];
      if (towers.length >= MAX_TOWERS) return;

      const cost = calcTowerSlotCost(d, side);
      if (gold < cost) return;
      gold -= cost;

      const laneCount = 3;
      const lane = towers.length % laneCount;
      towers.push({ element:"none", level:0, lane });

      d[goldKey] = gold; updates[goldKey] = gold;
      d[towersKey] = towers; updates[towersKey] = towers;
    }

    function applyTowerPath(d, updates, cmd){
      const side = cmd.side === 2 ? 2 : 1;
      const towersKey = side === 1 ? "towers1" : "towers2";
      const towers = Array.isArray(d[towersKey]) ? d[towersKey].slice() : [];
      const idx = cmd.index;
      const element = cmd.element;
      if (typeof idx !== "number" || !towers[idx]) return;
      if (!["fire","ice","stone"].includes(element)) return;

      const t = towers[idx];
      if (t.element && t.element !== "none" && t.level >= 1){
        return;
      }
      t.element = element;
      t.level = 1;
      towers[idx] = t;
      d[towersKey] = towers;
      updates[towersKey] = towers;
    }

    function applyTowerUpgrade(d, updates, cmd){
      const side = cmd.side === 2 ? 2 : 1;
      const goldKey = side === 1 ? "gold1" : "gold2";
      const towersKey = side === 1 ? "towers1" : "towers2";
      let gold = d[goldKey] ?? 0;
      const towers = Array.isArray(d[towersKey]) ? d[towersKey].slice() : [];
      const idx = cmd.index;
      if (typeof idx !== "number" || !towers[idx]) return;
      const t = towers[idx];
      const lvl = t.level || 0;
      if (!t.element || t.element === "none") return;
      if (lvl >= 3) return;
      const cost = lvl === 0 ? 30 : (lvl === 1 ? 50 : 80);
      if (gold < cost) return;

      gold -= cost;
      t.level = lvl + 1;
      towers[idx] = t;

      d[goldKey] = gold; updates[goldKey] = gold;
      d[towersKey] = towers; updates[towersKey] = towers;
    }

    function applyBaseHit(d, updates, cmd){
      // Defender reports how much damage their base took from local combat.
      const side = cmd.side === 2 ? 2 : 1;
      const baseKey = side === 1 ? "base1" : "base2";
      const maxBase = d.maxBase ?? MAX_BASE_HP;
      const current = d[baseKey] ?? maxBase;
      const dmg = Math.max(0, cmd.damage || 0);
      if (!dmg) return;

      const next = Math.max(0, current - dmg);
      d[baseKey] = next;
      updates[baseKey] = next;

      if (next <= 0){
        d.status = "ended";
        updates.status = "ended";
      }
    }

    // ---- Command visuals ----
    function handleCommandVisual(cmd){
      if (cmd.cmd === "wave"){
        const attackerSide = cmd.side === 2 ? 2 : 1;
        const targetSide = attackerSide === 1 ? 2 : 1;

        if (!state.isSpectator && state.seat === targetSide){
          spawnIncomingWave(cmd.unitId);
          showToast("Enemy wave incoming!");
        } else if (!state.isSpectator && state.seat === attackerSide){
          showToast("Wave sent!");
        }
      } else if (cmd.cmd === "scout"){
        const side = cmd.side === 2 ? 2 : 1;
        if (!state.isSpectator && state.seat === side){
          showScoutReport();
        }
      }
    }

    function showScoutReport(){
      const d = state.gameData;
      if (!d) return;
      const mySide = (state.seat === 2 ? 2 : 1);
      const enemySide = mySide === 1 ? 2 : 1;
      const baseKey = enemySide === 1 ? "base1" : "base2";
      const genKey = enemySide === 1 ? "gen1" : "gen2";
      const towersKey = enemySide === 1 ? "towers1" : "towers2";

      const base = d[baseKey] ?? MAX_BASE_HP;
      const gen = d[genKey] ?? 1;
      const towers = Array.isArray(d[towersKey]) ? d[towersKey] : [];
      const activeTowers = towers.filter(t => t.element && t.element !== "none" && (t.level || 0) > 0).length;

      const msg = `Scout report ‚Äî Enemy base: ${base} HP, Generator Lv${gen}, Active towers: ${activeTowers}/${towers.length}.`;
      showToast(msg);
      statusEl.textContent = msg;
    }

    // Incoming wave: purely visual on the defending client. Base damage only on collision.
    function spawnIncomingWave(unitId){
      const u = UNITS[unitId];
      if (!u || !boardEl) return;
      if (!boardGeom) computeBoardGeom();
      if (!boardGeom) return;

      const lanesGeom = boardGeom.lanesGeom;
      if (!lanesGeom || !lanesGeom.length) return;

      const laneIndex = Math.floor(Math.random() * lanesGeom.length);
      const laneInfo = lanesGeom[laneIndex];

      const count = Math.min(u.count, 7);
      const maxHp = u.hp * 2.2; // a bit beefier so towers need a few hits

      for (let i = 0; i < count; i++){
        const unitDiv = document.createElement("div");
        unitDiv.className = "unit march";
        unitDiv.classList.add(u.element || "fire");
        unitDiv.textContent = u.emoji;

        const hpWrap = document.createElement("div");
        hpWrap.className = "unit-hp";
        const hpFill = document.createElement("div");
        hpFill.className = "unit-hp-fill";
        hpWrap.appendChild(hpFill);
        unitDiv.appendChild(hpWrap);

        boardEl.appendChild(unitDiv);

        const offset = -0.12 * i;

        marchingUnits.push({
          el: unitDiv,
          laneIndex,
          progress: offset,
          duration: MARCH_DURATION_MS,
          spawnX: laneInfo.spawnX,
          baseX: laneInfo.baseX,
          x: laneInfo.spawnX,
          y: laneInfo.y,
          hp: maxHp,
          maxHp,
          hpFill,
          unitId,
          baseDamage: u.damage || 5
        });
      }

      if (!lastAnimTime){
        requestAnimationFrame(animateUnits);
      }
    }

    function animateUnits(timestamp){
      if (!lastAnimTime) lastAnimTime = timestamp;
      const dt = timestamp - lastAnimTime;
      lastAnimTime = timestamp;

      if (!boardGeom) computeBoardGeom();
      if (!boardGeom){
        marchingUnits.forEach(u => u.el.remove());
        marchingUnits = [];
        lastAnimTime = null;
        return;
      }
      const lanesGeom = boardGeom.lanesGeom;
      const maxProgress = 1;

      for (let i = marchingUnits.length - 1; i >= 0; i--){
        const u = marchingUnits[i];
        const laneInfo = lanesGeom[u.laneIndex];
        if (!laneInfo){
          u.el.remove();
          marchingUnits.splice(i,1);
          continue;
        }

        u.progress += dt / u.duration;
        const clamped = Math.min(maxProgress, u.progress);

        const x = u.spawnX + (u.baseX - u.spawnX) * clamped;
        u.x = x;
        u.y = laneInfo.y;

        u.el.style.transform = `translate(${x - 11}px, ${laneInfo.y - 11}px)`;

        // Only when a unit REACHES the base do we deal damage
        if (u.progress >= maxProgress){
          u.el.classList.add("unit-hit");
          flashBaseHit(u.laneIndex);

          if (!state.isSpectator){
            const dmg = u.baseDamage || 0;
            if (dmg > 0){
              registerBaseHit(dmg);
            }
          }

          setTimeout(() => u.el.remove(), 200);
          marchingUnits.splice(i,1);
          continue;
        }
      }

      const now = performance.now();
      if (now - lastShotTime > SHOT_INTERVAL_MS && marchingUnits.length > 0){
        lastShotTime = now;
        spawnDefenderShots();
      }

      if (marchingUnits.length > 0){
        requestAnimationFrame(animateUnits);
      } else {
        lastAnimTime = null;
      }
    }

    function flashBaseHit(laneIndex){
      if (!boardEl) return;
      const lane = boardEl.querySelector(`.lane[data-lane="${laneIndex}"] .base-icon`);
      if (!lane) return;
      lane.classList.remove("base-hit");
      void lane.offsetWidth; // force reflow
      lane.classList.add("base-hit");
    }

    // Towers: shoot the closest enemy in their lane
    function spawnDefenderShots(){
      if (!state.gameData || !boardGeom) return;
      if (state.isSpectator) return;
      if (!marchingUnits.length) return;

      const mySide = (state.seat === 2 ? 2 : 1);

      // Group enemies by lane
      const unitsByLane = new Map();
      marchingUnits.forEach(u => {
        const arr = unitsByLane.get(u.laneIndex) || [];
        arr.push(u);
        unitsByLane.set(u.laneIndex, arr);
      });

      // Group my towers by lane
      const myTowers = boardTowerNodes.filter(
        t => t.side === mySide && t.level > 0 && t.element !== "none"
      );
      if (!myTowers.length) return;

      const towersByLane = new Map();
      myTowers.forEach(t => {
        const arr = towersByLane.get(t.laneIndex) || [];
        arr.push(t);
        towersByLane.set(t.laneIndex, arr);
      });

      // Each lane: ALL towers focus the single closest enemy to the base
      for (const [laneIndex, laneTowers] of towersByLane){
        const laneUnits = unitsByLane.get(laneIndex);
        if (!laneUnits || !laneUnits.length) continue;

        // They march from right ‚Üí left; closest to base = smallest x
        let target = laneUnits[0];
        for (let i = 1; i < laneUnits.length; i++){
          if (laneUnits[i].x < target.x){
            target = laneUnits[i];
          }
        }

        laneTowers.forEach(tower => {
          spawnShot(tower, target);
          applyVisualHit(target, tower);
        });
      }
    }

    function spawnShot(tower, unit){
      const shot = document.createElement("div");
      shot.className = "shot";

      const sx = tower.x;
      const sy = tower.y;
      const ux = unit.x;
      const uy = unit.y;

      shot.style.left = (sx - 3) + "px";
      shot.style.top = (sy - 3) + "px";
      boardEl.appendChild(shot);

      const dx = ux - sx;
      const dy = uy - sy;

      requestAnimationFrame(() => {
        shot.style.transform = `translate(${dx}px, ${dy}px)`;
        shot.style.opacity = "0";
      });

      setTimeout(() => shot.remove(), 360);
    }

    function applyVisualHit(u, tower){
      const lvl = tower.level || 1;
      let base = TOWER_POWER_PER_LEVEL[lvl] || 30;
      if (tower.element && u.el.classList.contains(tower.element)){
        // same element, small bonus
        base *= 1.1;
      }
      const dmg = base * 0.45;
      u.hp -= dmg;
      if (u.hp <= 0){
        u.hp = 0;
        u.hpFill.style.width = "0%";
        u.el.classList.add("unit-dead");
        setTimeout(() => u.el.remove(), 180);
        const idx = marchingUnits.indexOf(u);
        if (idx >= 0) marchingUnits.splice(idx,1);
      } else {
        const pct = Math.max(0, Math.min(100, (u.hp / u.maxHp) * 100));
        u.hpFill.style.width = pct + "%";
      }
    }

    // ---- Tower overlay ----
    function openTowerOverlay(index){
      const d = state.gameData;
      if (!d) return;
      const side = (state.seat === 2) ? 2 : 1;
      const towersKey = side === 1 ? "towers1" : "towers2";
      const towers = Array.isArray(d[towersKey]) ? d[towersKey] : [];
      const t = towers[index];
      if (!t) return;

      state.selectedTowerIndex = index;
      towerOverlayActionsEl.innerHTML = "";

      if (!t.element || t.element === "none" || !t.level){
        towerOverlayTitleEl.textContent = `Tower Slot #${index+1}`;
        towerOverlayBodyEl.textContent = "Choose an element path for this tower.";
        towerOverlayEl.classList.add("radial-mode");

        ["fire","ice","stone"].forEach(el => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "tiny-btn tower-opt tower-opt-" + el;
          btn.innerHTML = `${emojiForElement(el)} ${capitalize(el)}`;
          btn.addEventListener("click", () => {
            sendTowerPath(index, el).catch(err => {
              console.error(err);
              showToast("Failed to set tower path.");
            });
          });
          towerOverlayActionsEl.appendChild(btn);
        });

        const closeBtn = document.createElement("button");
        closeBtn.type = "button";
        closeBtn.className = "tiny-btn tower-opt tower-opt-close";
        closeBtn.textContent = "Close";
        closeBtn.addEventListener("click", hideTowerOverlay);
        towerOverlayActionsEl.appendChild(closeBtn);
      } else {
        towerOverlayEl.classList.remove("radial-mode");
        towerOverlayTitleEl.textContent = `${capitalize(t.element)} Tower #${index+1}`;
        const lvl = t.level || 1;
        if (lvl >= 3){
          towerOverlayBodyEl.textContent = "This tower is max level.";
        } else {
          const cost = calcTowerUpgradeCost(d, side, index);
          towerOverlayBodyEl.textContent = `Current level: ${lvl}. Upgrade to level ${lvl+1} for ${cost} gold?`;

          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "tiny-btn";
          btn.innerHTML = `‚¨ÜÔ∏è Upgrade (${cost}g)`;
          btn.addEventListener("click", () => {
            const goldKey = side === 1 ? "gold1" : "gold2";
            const currentGold = d[goldKey] ?? 0;
            if (currentGold < cost){
              showToast("Not enough gold to upgrade tower.");
              return;
            }
            sendTowerUpgrade(index).catch(err => {
              console.error(err);
              showToast("Failed to upgrade tower.");
            });
          });
          towerOverlayActionsEl.appendChild(btn);
        }
      }

      towerOverlayEl.classList.add("show");
    }

    function hideTowerOverlay(){
      towerOverlayEl.classList.remove("show");
      towerOverlayEl.classList.remove("radial-mode");
      state.selectedTowerIndex = null;
    }

    // ---- Small helpers ----
    function capitalize(s){
      if (!s) return "";
      return s.charAt(0).toUpperCase() + s.slice(1);
    }

    function emojiForElement(el){
      if (el === "fire") return "üî•";
      if (el === "ice") return "‚ùÑÔ∏è";
      if (el === "stone") return "ü™®";
      return "üóº";
    }
  </script>
</body>
</html>





