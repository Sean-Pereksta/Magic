<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ü™≥ Roach Run ‚Äî Online Pac Maze (2P, Firebase)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
  <style>
    :root{
      --bg:#020617;
      --panel:#0b1120;
      --ink:#e5e7eb;
      --muted:#9ca3af;
      --accent:#38bdf8;
      --accent-soft:#0ea5e9;
      --good:#22c55e;
      --bad:#ef4444;
      --radius:14px;
      --shadow:0 18px 40px rgba(0,0,0,.7);
    }
    *{box-sizing:border-box;-webkit-tap-highlight-color:transparent;}
    html,body{
      margin:0;
      padding:0;
      height:100%;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      background:radial-gradient(circle at top,#0f172a 0,#020617 55%);
      color:var(--ink);
      overflow:hidden;
    }
    body{
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
    }
    .shell{
      flex:1;
      display:flex;
      flex-direction:column;
      width:100%;
      max-width:900px;
      padding:8px 8px calc(8px + env(safe-area-inset-bottom));
      gap:8px;
    }

    .top-bar{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:8px;
      padding:8px 12px;
      border-radius:var(--radius);
      background:rgba(15,23,42,.95);
      border:1px solid #1f2937;
      box-shadow:var(--shadow);
      font-size:.85rem;
    }
    .top-left{
      display:flex;
      flex-direction:column;
      gap:4px;
      flex:1;
      min-width:0;
    }
    .title-row{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .game-title{
      font-weight:700;
      display:flex;
      align-items:center;
      gap:6px;
    }
    .pill-row{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
    }
    .pill{
      border-radius:999px;
      border:1px solid #1f2937;
      padding:3px 9px;
      background:#020617;
      display:inline-flex;
      align-items:center;
      gap:5px;
      font-size:.78rem;
      color:var(--muted);
      white-space:nowrap;
    }
    .pill strong{color:var(--ink);font-weight:600;}
    .description{
      font-size:.75rem;
      color:var(--muted);
    }

    .top-right{
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      gap:4px;
    }
    #fullscreenBtn{
      border-radius:999px;
      border:1px solid #1f2937;
      background:#020617;
      padding:4px 8px;
      font-size:.78rem;
      color:var(--ink);
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:4px;
    }
    #fullscreenBtn:active{
      transform:scale(.97);
    }
    .mini-label{
      font-size:.75rem;
      color:var(--muted);
      margin-bottom:2px;
    }
    #oppMini{
      border-radius:10px;
      border:1px solid #1f2937;
      background:#020617;
      box-shadow:0 10px 25px rgba(0,0,0,.6);
      width:140px;
      height:110px;
    }

    .main-game{
      flex:1;
      display:flex;
      flex-direction:column;
      gap:8px;
      min-height:0;
    }
    .game-panel{
      flex:1;
      border-radius:var(--radius);
      background:rgba(15,23,42,.96);
      border:1px solid #1f2937;
      box-shadow:var(--shadow);
      padding:8px;
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:0;
    }
    #gameCanvas{
      width:100%;
      max-width:600px;
      aspect-ratio:11/9;
      border-radius:10px;
      border:1px solid #111827;
      background:#020617;
      touch-action:none;
    }

    .joystick-bar{
      height:140px;
      border-radius:var(--radius);
      background:rgba(15,23,42,.96);
      border:1px solid #1f2937;
      box-shadow:var(--shadow);
      padding:6px 12px 10px;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .joystick-label{
      font-size:.78rem;
      color:var(--muted);
      display:flex;
      justify-content:space-between;
      align-items:center;
    }
    .joystick-area{
      flex:1;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .joystick-outer{
      position:relative;
      width:100px;
      height:100px;
      border-radius:999px;
      border:2px solid #1f2937;
      background:radial-gradient(circle at 30% 30%,#1f2937,#020617);
      box-shadow:0 10px 30px rgba(0,0,0,.8) inset;
      touch-action:none;
    }
    .joystick-inner{
      position:absolute;
      width:44px;
      height:44px;
      border-radius:999px;
      background:radial-gradient(circle at 30% 30%,#38bdf8,#0ea5e9);
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      box-shadow:0 0 12px rgba(56,189,248,.7);
      pointer-events:none;
    }

    @media (min-width:900px){
      .joystick-bar{
        max-width:480px;
        align-self:center;
      }
    }

    .overlay{
      position:fixed;
      inset:0;
      background:rgba(15,23,42,.96);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:40;
    }
    .overlay-card{
      border-radius:18px;
      padding:18px 22px;
      border:1px solid #1f2937;
      background:radial-gradient(circle at top,#0f172a,#020617);
      box-shadow:var(--shadow);
      text-align:center;
      max-width:320px;
      color:var(--ink);
    }
    .overlay-card h2{
      margin:0 0 6px;
    }
    .overlay-card p{
      margin:4px 0;
      font-size:.9rem;
      color:var(--muted);
    }
    .overlay-card button{
      margin-top:10px;
      border-radius:999px;
      border:1px solid #1f2937;
      padding:7px 14px;
      font-size:.85rem;
      cursor:pointer;
      background:linear-gradient(135deg,#0ea5e9,#22c55e);
      color:#020617;
      font-weight:600;
    }

    .waiting{
      font-size:.8rem;
      color:var(--muted);
    }
  </style>
</head>
<body>
<div class="shell">
  <div class="top-bar">
    <div class="top-left">
      <div class="title-row">
        <div class="game-title">
          ü™≥ <span>Roach Run ‚Äî Online Pac Maze</span>
        </div>
        <div class="pill"><span>You:</span> <strong id="youLabel">‚Ä¶</strong></div>
        <div class="pill">
          <span>Score</span>
          <strong id="scoreLabel">0</strong>
        </div>
        <div class="pill">
          <span>Opponent</span>
          <strong id="oppScoreLabel">‚Äî</strong>
        </div>
      </div>
      <div class="pill-row">
        <div class="pill">
          <span>Level</span> <strong id="levelLabel">1</strong>
        </div>
        <div class="pill">
          <span>Lives</span> <strong id="livesLabel">3</strong>
        </div>
        <div class="pill">
          <span>Wins</span> <strong id="winsLabel">0</strong>
        </div>
        <div class="pill" id="statusPill">
          <span>Status:</span> <strong id="statusLabel">Waiting for Firebase‚Ä¶</strong>
        </div>
      </div>
      <div class="description">
        Clear pellets for points (+50 each cleared board). Pickups attack the <strong>other</strong> player:
        extra spiders, slime that slows, and blocked tunnels. Camera follows your roach.
      </div>
    </div>
    <div class="top-right">
      <button id="fullscreenBtn">‚õ∂ Fullscreen</button>
      <div class="mini-label">
        Other Player View
        <span id="oppMiniStatus" class="waiting">(waiting‚Ä¶)</span>
      </div>
      <canvas id="oppMini" width="140" height="110"></canvas>
    </div>
  </div>

  <div class="main-game">
    <div class="game-panel">
      <canvas id="gameCanvas"></canvas>
    </div>
    <div class="joystick-bar">
      <div class="joystick-label">
        <span>Touch Joystick (mobile) ‚Ä¢ WASD / Arrow keys (desktop)</span>
        <span id="connectionLabel" class="waiting"></span>
      </div>
      <div class="joystick-area">
        <div class="joystick-outer" id="joystickOuter">
          <div class="joystick-inner" id="joystickInner"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="gameOverOverlay" class="overlay">
  <div class="overlay-card">
    <h2 id="gameOverTitle">Game Over</h2>
    <p id="gameOverText"></p>
    <button onclick="location.reload()">üîÅ Play Again</button>
  </div>
</div>

<script type="module">
  // ---------- FIREBASE ----------
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import {
    getFirestore, doc, collection, setDoc, updateDoc,
    onSnapshot, serverTimestamp, arrayUnion
  } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
  import {
    getAuth, signInAnonymously, onAuthStateChanged
  } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

  const firebaseConfig = {
    apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
    authDomain: "bible-game-246c0.firebaseapp.com",
    projectId: "bible-game-246c0",
    storageBucket: "bible-game-246c0.appspot.com",
    messagingSenderId: "959619818996",
    appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const auth = getAuth(app);

  // ---------- DOM ----------
  const youLabel = document.getElementById("youLabel");
  const scoreLabel = document.getElementById("scoreLabel");
  const oppScoreLabel = document.getElementById("oppScoreLabel");
  const levelLabel = document.getElementById("levelLabel");
  const livesLabel = document.getElementById("livesLabel");
  const winsLabel = document.getElementById("winsLabel");
  const statusLabel = document.getElementById("statusLabel");
  const statusPill = document.getElementById("statusPill");
  const connectionLabel = document.getElementById("connectionLabel");
  const oppMiniStatus = document.getElementById("oppMiniStatus");
  const fullscreenBtn = document.getElementById("fullscreenBtn");
  const gameCanvas = document.getElementById("gameCanvas");
  const oppMiniCanvas = document.getElementById("oppMini");
  const gameOverOverlay = document.getElementById("gameOverOverlay");
  const gameOverTitle = document.getElementById("gameOverTitle");
  const gameOverText = document.getElementById("gameOverText");
  const joystickOuter = document.getElementById("joystickOuter");
  const joystickInner = document.getElementById("joystickInner");

  const gCtx = gameCanvas.getContext("2d");
  const miniCtx = oppMiniCanvas.getContext("2d");

  // ---------- GAME CONFIG ----------
  const GAME_COLLECTION = "roach_race_games"; // new game collection, same project
  const params = new URLSearchParams(window.location.search);
  const gameId = params.get("gameId") || "dev-roach-run";
  const displayName = (params.get("username") || "Guest").trim() || "Guest";

  const MAZE_ROWS = 15;
  const MAZE_COLS = 19;
  const TILE_SIZE = 32; // internal render tile size
  const VIEW_COLS = 11;
  const VIEW_ROWS = 9;

  const MAZE = [
    "###################",
    "#........#........#",
    "#.####.#.#.####.#.#",
    "#.#..#.#.#.#..#.#.#",
    "#.#..#.#.#.#..#.#.#",
    "#.####.#.#.####.#.#",
    "...................",
    "###.###.###.###.###",
    "#........#........#",
    "#.####.#.#.####.#.#",
    "#.#..#.#.#.#..#.#.#",
    "#.#..#.#.#.#..#.#.#",
    "#.####.#.#.####.#.#",
    "#........#........#",
    "###################"
  ];

  // Teleport tiles (wrap left/right)
  const TELEPORTS = [
    {x:0, y:6},
    {x:18, y:6}
  ];

  // ---------- FIREBASE STATE ----------
  let currentUser = null;
  let gameRef = null;
  let playersCol = null;
  let playerRef = null;
  let myData = null;
  let opponentData = null;
  let opponentId = null;

  let snapshotIntervalId = null;
  const processedEffectIds = new Set();

  // ---------- LOCAL GAME STATE ----------
  let roach = null;
  let spiders = [];
  let pellets = [];
  let pelletsLeft = 0;
  let slimeTiles = []; // {x,y,expiresAt}
  let powerups = [];   // {x,y,type,expiresAt}
  let powerupTimer = 0;

  let score = 0;
  let level = 1;
  let lives = 3;
  let wins = 0;
  let isDead = false;
  let gameOver = false;
  let victory = false;
  let winRecorded = false;

  let teleportBlockedUntil = 0;
  let nowMs = performance.now();

  // movement / input
  let lastFrameTime = performance.now();
  let gameStarted = false;

  // keyboard next direction
  const nextDir = {x:0, y:0};

  // ---------- HELPER: MAZE ----------
  function isWall(x,y){
    if(x < 0 || x >= MAZE_COLS || y < 0 || y >= MAZE_ROWS) return true;
    return MAZE[y][x] === "#";
  }
  function isTeleportTile(x,y){
    return TELEPORTS.some(t => t.x === x && t.y === y);
  }
  function otherTeleport(x,y){
    const idx = TELEPORTS.findIndex(t => t.x === x && t.y === y);
    if(idx === -1) return null;
    const other = TELEPORTS[1-idx];
    return {x:other.x, y:other.y};
  }

  function initPellets(){
    pellets = [];
    pelletsLeft = 0;
    for(let y=0;y<MAZE_ROWS;y++){
      const row = [];
      for(let x=0;x<MAZE_COLS;x++){
        const ch = MAZE[y][x];
        if(ch === "."){
          row.push(true);
          pelletsLeft++;
        }else{
          row.push(false);
        }
      }
      pellets.push(row);
    }
  }

  function resetGameBoard(){
    level = 1;
    score = 0;
    lives = 3;
    teleportBlockedUntil = 0;
    slimeTiles = [];
    powerups = [];
    powerupTimer = 0;

    initPellets();

    roach = {
      tileX: 9,
      tileY: 6,
      dirX: 0,
      dirY: 0,
      speed: 5,     // tiles per second
      slowFactor: 1,
      slowUntil: 0
    };

    spiders = [
      {tileX:3, tileY:6, dirX:1, dirY:0, speed:4, color:"#ef4444", ai:"chaser"},   // red
      {tileX:15,tileY:6, dirX:-1,dirY:0, speed:4, color:"#0ea5e9", ai:"ambush"},  // blue
      {tileX:1, tileY:5, dirX:1, dirY:0, speed:3.5, color:"#a855f7", ai:"wander"},// purple
      {tileX:17,tileY:5, dirX:-1,dirY:0, speed:3.5, color:"#facc15", ai:"patrol"} // yellow
    ];

    gameStarted = true;
    isDead = false;
    gameOver = false;
    victory = false;
    winRecorded = false;

    updateHud();
  }

  function newLevel(){
    level++;
    score += 50; // bonus per cleared board
    initPellets();

    // tweak speeds slightly
    roach.speed *= 1.03;
    spiders.forEach(s => s.speed *= 1.06);

    slimeTiles = [];
    powerups = [];
    powerupTimer = 0;
    teleportBlockedUntil = 0;

    // reset roach position
    roach.tileX = 9;
    roach.tileY = 6;
    roach.dirX = 0;
    roach.dirY = 0;
    roach.slowFactor = 1;
    roach.slowUntil = 0;

    updateHud();
  }

  // ---------- MOVEMENT ----------
  function setNextDir(dx,dy){
    nextDir.x = dx;
    nextDir.y = dy;
  }

  function canMoveFrom(tileX,tileY,dx,dy){
    let nx = tileX + dx;
    let ny = tileY + dy;

    // teleports: treat as passable even if at edge
    if(nx < 0 || nx >= MAZE_COLS || ny < 0 || ny >= MAZE_ROWS){
      return true;
    }
    return !isWall(nx,ny);
  }

  function applyTeleportIfNeeded(entity){
    if(!isTeleportTile(entity.tileX, entity.tileY)) return;
    if(nowMs < teleportBlockedUntil){
      // tile is just a cul-de-sac while blocked
      return;
    }
    const other = otherTeleport(entity.tileX, entity.tileY);
    if(other){
      entity.tileX = other.x;
      entity.tileY = other.y;
    }
  }

  function handleRoachTileEvents(){
    const tx = roach.tileX;
    const ty = roach.tileY;

    // pellet
    if(ty>=0 && ty<MAZE_ROWS && tx>=0 && tx<MAZE_COLS){
      if(pellets[ty][tx]){
        pellets[ty][tx] = false;
        pelletsLeft--;
        score += 10;
        if(pelletsLeft <= 0){
          newLevel();
        }
      }
    }

    // slime
    for(const s of slimeTiles){
      if(s.x === tx && s.y === ty){
        roach.slowFactor = 0.4;
        roach.slowUntil = nowMs + 1500; // 1.5s slow
        break;
      }
    }

    // powerups
    for(let i=powerups.length-1;i>=0;i--){
      const p = powerups[i];
      if(p.x === tx && p.y === ty){
        powerups.splice(i,1);
        triggerPowerup(p.type);
      }
    }
  }

  function triggerPowerup(type){
    if(!opponentId) return; // nothing to hit yet
    const oppRef = doc(playersCol, opponentId);
    const effect = {
      id: "e_"+Date.now()+"_"+Math.random().toString(16).slice(2,7),
      type,
      createdAt: Date.now()
    };
    updateDoc(oppRef,{
      incomingEffects: arrayUnion(effect)
    }).catch(console.error);
  }

  function updateRoach(dt){
    if(isDead || !roach) return;

    // slow logic
    if(roach.slowFactor < 1 && nowMs > roach.slowUntil){
      roach.slowFactor = 1;
    }

    // attempt to change dir if we have input
    if((nextDir.x !== roach.dirX || nextDir.y !== roach.dirY)){
      if(canMoveFrom(roach.tileX, roach.tileY, nextDir.x, nextDir.y)){
        roach.dirX = nextDir.x;
        roach.dirY = nextDir.y;
      }
    }

    if(roach.dirX === 0 && roach.dirY === 0) return;

    const speedTilesPerSec = roach.speed * roach.slowFactor;
    let moveAmount = speedTilesPerSec * dt;
    // move in discrete steps of <=1 tile
    while(moveAmount > 0){
      const step = Math.min(moveAmount, 1);
      let nx = roach.tileX + roach.dirX;
      let ny = roach.tileY + roach.dirY;

      // teleport wrap attempt
      let tentativeX = nx;
      let tentativeY = ny;

      // allow stepping into teleport tile even if at edge
      if(tentativeX < 0 || tentativeX >= MAZE_COLS || tentativeY < 0 || tentativeY >= MAZE_ROWS){
        // wrap will be applied when entity sits in teleport tile; here just move
      }else if(isWall(tentativeX,tentativeY)){
        // hit wall, stop moving
        roach.dirX = 0;
        roach.dirY = 0;
        break;
      }

      roach.tileX = tentativeX;
      roach.tileY = tentativeY;
      applyTeleportIfNeeded(roach);
      handleRoachTileEvents();
      moveAmount -= step;
      // only one tile per frame effectively; small dt means 1 step
      break;
    }
  }

  function availableDirs(tileX,tileY,currentDir){
    const dirs = [
      {x:1,y:0},
      {x:-1,y:0},
      {x:0,y:-1},
      {x:0,y:1}
    ];
    const out = [];
    for(const d of dirs){
      // avoid going out-of-bounds into walls
      const nx = tileX + d.x;
      const ny = tileY + d.y;
      if(nx < 0 || nx >= MAZE_COLS || ny < 0 || ny >= MAZE_ROWS){
        continue;
      }
      if(isWall(nx,ny)) continue;
      // don't backtrack unless there's no other choice
      if(currentDir && d.x === -currentDir.x && d.y === -currentDir.y) continue;
      out.push(d);
    }
    if(!out.length && currentDir){
      // forced to backtrack
      out.push({x:-currentDir.x, y:-currentDir.y});
    }
    return out;
  }

  function updateSpiders(dt){
    for(const s of spiders){
      if(!s) continue;
      const speedTilesPerSec = s.speed;
      let moveAmount = speedTilesPerSec * dt;
      while(moveAmount > 0){
        const step = Math.min(moveAmount, 1);

        // choose direction at intersections (approx: whenever previous step finished)
        const dirs = availableDirs(s.tileX, s.tileY, {x:s.dirX,y:s.dirY});
        if(dirs.length){
          let chosen = dirs[0];
          if(s.ai === "chaser"){
            // minimize manhattan distance to roach
            let best = Infinity;
            for(const d of dirs){
              const nx = s.tileX + d.x;
              const ny = s.tileY + d.y;
              const dist = Math.abs(nx - roach.tileX) + Math.abs(ny - roach.tileY);
              if(dist < best){
                best = dist;
                chosen = d;
              }
            }
          }else if(s.ai === "wander"){
            chosen = dirs[Math.floor(Math.random()*dirs.length)];
          }else if(s.ai === "ambush"){
            // aim towards tile slightly ahead of roach
            const targetX = roach.tileX + roach.dirX*2;
            const targetY = roach.tileY + roach.dirY*2;
            let best = Infinity;
            for(const d of dirs){
              const nx = s.tileX + d.x;
              const ny = s.tileY + d.y;
              const dist = Math.abs(nx - targetX) + Math.abs(ny - targetY);
              if(dist < best){
                best = dist;
                chosen = d;
              }
            }
          }else if(s.ai === "patrol"){
            // favor horizontal moves
            const horiz = dirs.filter(d=>d.y===0);
            if(horiz.length){
              chosen = horiz[Math.floor(Math.random()*horiz.length)];
            }else{
              chosen = dirs[Math.floor(Math.random()*dirs.length)];
            }
          }
          s.dirX = chosen.x;
          s.dirY = chosen.y;
        }

        const nx = s.tileX + s.dirX;
        const ny = s.tileY + s.dirY;

        if(nx < 0 || nx >= MAZE_COLS || ny < 0 || ny >= MAZE_ROWS || isWall(nx,ny)){
          // reverse
          s.dirX = -s.dirX;
          s.dirY = -s.dirY;
          break;
        }

        s.tileX = nx;
        s.tileY = ny;
        applyTeleportIfNeeded(s);

        moveAmount -= step;
        break;
      }
    }
  }

  function checkCollisions(){
    if(isDead) return;
    for(const s of spiders){
      if(!s) continue;
      if(s.tileX === roach.tileX && s.tileY === roach.tileY){
        // hit!
        lives--;
        if(lives <= 0){
          lives = 0;
          isDead = true;
          statusLabel.textContent = "You are out!";
        }else{
          // respawn in center row
          roach.tileX = 9;
          roach.tileY = 6;
          roach.dirX = 0;
          roach.dirY = 0;
          roach.slowFactor = 1;
        }
        updateHud();
        break;
      }
    }
  }

  // ---------- SLIME & POWERUPS ----------
  function updateSlimeAndPowerups(dt){
    // remove expired slime
    const t = nowMs;
    slimeTiles = slimeTiles.filter(s => s.expiresAt > t);
    powerups = powerups.filter(p => p.expiresAt > t);

    // spawn occasional powerups
    powerupTimer += dt;
    if(powerupTimer > 6 && powerups.length < 3){
      powerupTimer = 0;
      // random walkable tile
      const candidates = [];
      for(let y=0;y<MAZE_ROWS;y++){
        for(let x=0;x<MAZE_COLS;x++){
          if(isWall(x,y)) continue;
          // avoid spawn on teleports
          if(isTeleportTile(x,y)) continue;
          candidates.push({x,y});
        }
      }
      if(candidates.length){
        const spot = candidates[Math.floor(Math.random()*candidates.length)];
        const types = ["EXTRA_SPIDER","SLIME","BLOCK_TUNNELS"];
        const type = types[Math.floor(Math.random()*types.length)];
        powerups.push({
          x:spot.x,
          y:spot.y,
          type,
          expiresAt: t + 15000 // 15s lifetime
        });
      }
    }
  }

  function applyEffect(effect){
    if(processedEffectIds.has(effect.id)) return;
    processedEffectIds.add(effect.id);

    if(effect.type === "EXTRA_SPIDER"){
      // spawn new spider near center row
      spiders.push({
        tileX:9,
        tileY:6,
        dirX: (Math.random() < 0.5 ? 1 : -1),
        dirY:0,
        speed:3.8 + Math.random()*1.2,
        color:"#f97316",
        ai:"wander"
      });
    }else if(effect.type === "SLIME"){
      // spawn some slime tiles in random corridors
      const tNow = Date.now();
      for(let i=0;i<5;i++){
        const x = Math.floor(Math.random()*MAZE_COLS);
        const y = Math.floor(Math.random()*MAZE_ROWS);
        if(isWall(x,y)) continue;
        slimeTiles.push({
          x,y,
          expiresAt: tNow + 10000
        });
      }
    }else if(effect.type === "BLOCK_TUNNELS"){
      teleportBlockedUntil = Date.now() + 10000; // 10s
    }
  }

  // ---------- RENDER ----------
  function renderGame(){
    const canvasWidth = VIEW_COLS * TILE_SIZE;
    const canvasHeight = VIEW_ROWS * TILE_SIZE;
    gameCanvas.width = canvasWidth;
    gameCanvas.height = canvasHeight;

    const ctx = gCtx;
    ctx.clearRect(0,0,canvasWidth,canvasHeight);
    ctx.fillStyle = "#020617";
    ctx.fillRect(0,0,canvasWidth,canvasHeight);

    if(!roach){
      ctx.fillStyle = "#9ca3af";
      ctx.font = "16px system-ui";
      ctx.textAlign = "center";
      ctx.fillText("Connecting to Firebase‚Ä¶", canvasWidth/2, canvasHeight/2);
      return;
    }

    // camera centered on roach
    let camX = roach.tileX + 0.5 - VIEW_COLS/2;
    let camY = roach.tileY + 0.5 - VIEW_ROWS/2;
    camX = Math.max(0, Math.min(MAZE_COLS - VIEW_COLS, camX));
    camY = Math.max(0, Math.min(MAZE_ROWS - VIEW_ROWS, camY));
    const startX = Math.floor(camX);
    const startY = Math.floor(camY);

    // draw tiles
    for(let vy=0;vy<VIEW_ROWS;vy++){
      const my = startY + vy;
      if(my < 0 || my >= MAZE_ROWS) continue;
      for(let vx=0;vx<VIEW_COLS;vx++){
        const mx = startX + vx;
        if(mx < 0 || mx >= MAZE_COLS) continue;
        const ch = MAZE[my][mx];
        const x = vx * TILE_SIZE;
        const y = vy * TILE_SIZE;

        if(ch === "#"){
          ctx.fillStyle = "#020617";
          ctx.fillRect(x,y,TILE_SIZE,TILE_SIZE);
          ctx.fillStyle = "#1f2937";
          ctx.fillRect(x+4,y+4,TILE_SIZE-8,TILE_SIZE-8);
        }else{
          ctx.fillStyle = "#020617";
          ctx.fillRect(x,y,TILE_SIZE,TILE_SIZE);
          ctx.fillStyle = "#030712";
          ctx.fillRect(x+2,y+2,TILE_SIZE-4,TILE_SIZE-4);
        }
      }
    }

    // pellets
    ctx.fillStyle = "#facc15";
    for(let vy=0;vy<VIEW_ROWS;vy++){
      const my = startY + vy;
      if(my < 0 || my >= MAZE_ROWS) continue;
      for(let vx=0;vx<VIEW_COLS;vx++){
        const mx = startX + vx;
        if(mx < 0 || mx >= MAZE_COLS) continue;
        if(pellets[my] && pellets[my][mx]){
          const cx = (vx+0.5)*TILE_SIZE;
          const cy = (vy+0.5)*TILE_SIZE;
          ctx.beginPath();
          ctx.arc(cx,cy,3,0,Math.PI*2);
          ctx.fill();
        }
      }
    }

    // slime tiles
    ctx.fillStyle = "rgba(34,197,94,0.6)";
    for(const s of slimeTiles){
      const vx = s.x - startX;
      const vy = s.y - startY;
      if(vx < 0 || vx >= VIEW_COLS || vy < 0 || vy >= VIEW_ROWS) continue;
      const x = vx * TILE_SIZE;
      const y = vy * TILE_SIZE;
      ctx.fillRect(x+4,y+4,TILE_SIZE-8,TILE_SIZE-8);
    }

    // powerups
    for(const p of powerups){
      const vx = p.x - startX;
      const vy = p.y - startY;
      if(vx < 0 || vx >= VIEW_COLS || vy < 0 || vy >= VIEW_ROWS) continue;
      const x = vx * TILE_SIZE;
      const y = vy * TILE_SIZE;
      ctx.save();
      ctx.translate(x + TILE_SIZE/2, y + TILE_SIZE/2);
      ctx.font = "18px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      let emoji = "‚≠ê";
      if(p.type === "EXTRA_SPIDER") emoji = "üï∑Ô∏è";
      else if(p.type === "SLIME") emoji = "üü¢";
      else if(p.type === "BLOCK_TUNNELS") emoji = "üö´";
      ctx.fillText(emoji,0,1);
      ctx.restore();
    }

    // roach
    const r_vx = roach.tileX - camX;
    const r_vy = roach.tileY - camY;
    const rx = r_vx * TILE_SIZE + TILE_SIZE/2;
    const ry = r_vy * TILE_SIZE + TILE_SIZE/2;
    ctx.font = "22px system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("ü™≥", rx, ry + 1);

    // spiders
    for(const s of spiders){
      const svx = s.tileX - camX;
      const svy = s.tileY - camY;
      if(svx < 0 || svx >= VIEW_COLS || svy < 0 || svy >= VIEW_ROWS) continue;
      const sx = svx*TILE_SIZE + TILE_SIZE/2;
      const sy = svy*TILE_SIZE + TILE_SIZE/2;
      ctx.beginPath();
      ctx.fillStyle = s.color || "#e5e7eb";
      ctx.arc(sx,sy,10,0,Math.PI*2);
      ctx.fill();
      ctx.font = "16px system-ui";
      ctx.fillStyle = "#020617";
      ctx.fillText("üï∑Ô∏è",sx,sy+1);
    }

    // teleports highlight if blocked
    if(nowMs < teleportBlockedUntil){
      ctx.fillStyle = "rgba(248,113,113,0.55)";
      for(const t of TELEPORTS){
        const vx = t.x - camX;
        const vy = t.y - camY;
        if(vx < 0 || vx >= VIEW_COLS || vy < 0 || vy >= VIEW_ROWS) continue;
        const x = vx*TILE_SIZE;
        const y = vy*TILE_SIZE;
        ctx.fillRect(x+4,y+4,TILE_SIZE-8,TILE_SIZE-8);
      }
    }
  }

  function renderOpponentMini(){
    const ctx = miniCtx;
    const w = oppMiniCanvas.width;
    const h = oppMiniCanvas.height;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "#020617";
    ctx.fillRect(0,0,w,h);

    if(!opponentData || !opponentData.snapshot){
      ctx.fillStyle = "#64748b";
      ctx.font = "11px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("No opponent yet", w/2, h/2);
      oppMiniStatus.textContent = "(waiting‚Ä¶)";
      return;
    }
    oppMiniStatus.textContent = "";

    const tileW = w / MAZE_COLS;
    const tileH = h / MAZE_ROWS;

    // walls
    for(let y=0;y<MAZE_ROWS;y++){
      for(let x=0;x<MAZE_COLS;x++){
        if(MAZE[y][x] === "#"){
          ctx.fillStyle = "#020617";
          ctx.fillRect(x*tileW,y*tileH,tileW,tileH);
          ctx.fillStyle = "#111827";
          ctx.fillRect(x*tileW+1,y*tileH+1,tileW-2,tileH-2);
        }else{
          ctx.fillStyle = "#020617";
          ctx.fillRect(x*tileW,y*tileH,tileW,tileH);
          ctx.fillStyle = "#030712";
          ctx.fillRect(x*tileW+1,y*tileH+1,tileW-2,tileH-2);
        }
      }
    }

    // roach
    const snap = opponentData.snapshot;
    if(snap.roach){
      const rx = (snap.roach.x + 0.5)*tileW;
      const ry = (snap.roach.y + 0.5)*tileH;
      ctx.font = "13px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("ü™≥",rx,ry+0.5);
    }

    // spiders
    if(Array.isArray(snap.spiders)){
      for(const s of snap.spiders){
        const sx = (s.x+0.5)*tileW;
        const sy = (s.y+0.5)*tileH;
        ctx.beginPath();
        ctx.fillStyle = s.color || "#e5e7eb";
        ctx.arc(sx,sy,Math.min(tileW,tileH)*0.35,0,Math.PI*2);
        ctx.fill();
      }
    }
  }

  // ---------- HUD ----------
  function updateHud(){
    scoreLabel.textContent = score;
    levelLabel.textContent = level;
    livesLabel.textContent = lives;
    winsLabel.textContent = wins;
  }

  function updateStatus(text,color){
    statusLabel.textContent = text;
    if(color === "good"){
      statusPill.style.borderColor = "#16a34a";
    }else if(color === "bad"){
      statusPill.style.borderColor = "#dc2626";
    }else{
      statusPill.style.borderColor = "#1f2937";
    }
  }

  // ---------- GAME LOOP ----------
  function gameLoop(ts){
    const dt = Math.min(0.05, (ts - lastFrameTime)/1000);
    lastFrameTime = ts;
    nowMs = ts;

    if(gameStarted && !gameOver){
      updateSlimeAndPowerups(dt);
      updateRoach(dt);
      updateSpiders(dt);
      checkCollisions();
    }

    renderGame();
    renderOpponentMini();
    requestAnimationFrame(gameLoop);
  }
  requestAnimationFrame(gameLoop);

  // ---------- JOYSTICK ----------
  let joyActive = false;
  let joyOrigin = {x:0,y:0};

  joystickOuter.addEventListener("touchstart",(e)=>{
    const t = e.touches[0];
    const rect = joystickOuter.getBoundingClientRect();
    joyActive = true;
    joyOrigin = {
      x: t.clientX - rect.left,
      y: t.clientY - rect.top
    };
    joystickInner.style.transform = `translate(${joyOrigin.x-22}px,${joyOrigin.y-22}px)`;
    e.preventDefault();
  },{passive:false});

  joystickOuter.addEventListener("touchmove",(e)=>{
    if(!joyActive) return;
    const rect = joystickOuter.getBoundingClientRect();
    const t = e.touches[0];
    let dx = (t.clientX - rect.left) - joyOrigin.x;
    let dy = (t.clientY - rect.top) - joyOrigin.y;
    const dist = Math.hypot(dx,dy);
    const max = 32;
    if(dist > max){
      dx = dx / dist * max;
      dy = dy / dist * max;
    }
    joystickInner.style.transform = `translate(${joyOrigin.x+dx-22}px,${joyOrigin.y+dy-22}px)`;

    const threshold = 6;
    let dirX = 0, dirY = 0;
    if(Math.abs(dx) > Math.abs(dy)){
      if(dx > threshold) dirX = 1;
      else if(dx < -threshold) dirX = -1;
    }else{
      if(dy > threshold) dirY = 1;
      else if(dy < -threshold) dirY = -1;
    }
    setNextDir(dirX,dirY);
    e.preventDefault();
  },{passive:false});

  joystickOuter.addEventListener("touchend",()=>{
    joyActive = false;
    joystickInner.style.transform = "translate(-50%,-50%)";
  });

  // Keyboard controls
  window.addEventListener("keydown",(e)=>{
    let dx=0,dy=0;
    if(e.key === "ArrowUp" || e.key === "w" || e.key === "W") dy = -1;
    else if(e.key === "ArrowDown" || e.key === "s" || e.key === "S") dy = 1;
    else if(e.key === "ArrowLeft" || e.key === "a" || e.key === "A") dx = -1;
    else if(e.key === "ArrowRight" || e.key === "d" || e.key === "D") dx = 1;
    else return;
    setNextDir(dx,dy);
    e.preventDefault();
  });

  // ---------- FULLSCREEN ----------
  fullscreenBtn.addEventListener("click",()=>{
    const el = document.documentElement;
    if(!document.fullscreenElement){
      el.requestFullscreen?.();
    }else{
      document.exitFullscreen?.();
    }
  });

  // ---------- FIREBASE JOIN ----------
  function showGameOver(title,text,isWin){
    gameOver = true;
    victory = !!isWin;
    gameOverTitle.textContent = title;
    gameOverText.textContent = text;
    gameOverOverlay.style.display = "flex";

    if(victory && !winRecorded && playerRef){
      winRecorded = true;
      const newWins = (myData && typeof myData.wins === "number") ? (myData.wins+1) : (wins+1);
      wins = newWins;
      updateDoc(playerRef,{wins:newWins}).catch(console.error);
      updateHud();
    }
  }

  function determineWinner(){
    if(!myData) return;
    const myDead = isDead || !!myData.dead;
    const oppDead = opponentData && opponentData.dead;
    const myScore = score;
    const oppScore = opponentData ? (opponentData.score || 0) : 0;

    if(gameOver) return;

    if(myDead && oppDead){
      if(myScore > oppScore){
        showGameOver("Victory!","You outscored your opponent.",true);
      }else if(myScore < oppScore){
        showGameOver("Defeat","Your opponent outscored you.",false);
      }else{
        showGameOver("Tie","Both roaches fell with equal score.",false);
      }
    }else if(myDead && !oppDead){
      if(oppScore > myScore){
        showGameOver("Defeat","You ran out of lives while already behind.",false);
      }
    }else if(!myDead && oppDead){
      if(myScore > oppScore){
        showGameOver("Victory!","Opponent ran out of lives while you were ahead.",true);
      }
    }
  }

  async function pushSnapshot(){
    if(!playerRef || !myData || !roach) return;
    const snap = {
      score,
      level,
      lives,
      dead:isDead,
      roach:{x:roach.tileX, y:roach.tileY},
      spiders: spiders.map(s=>({x:s.tileX,y:s.tileY,color:s.color})),
      pelletsLeft
    };
    try{
      await updateDoc(playerRef,{
        score,
        level,
        lives,
        dead:isDead,
        snapshot:snap,
        lastSnapshot: serverTimestamp()
      });
    }catch(e){
      console.error(e);
    }
  }

  function handleMyDocUpdate(data){
    myData = data;
    if(typeof data.score === "number") score = data.score;
    if(typeof data.level === "number") level = data.level;
    if(typeof data.lives === "number") lives = data.lives;
    if(typeof data.wins === "number") wins = data.wins;

    youLabel.textContent = data.name || displayName;
    updateHud();

    // apply new effects
    if(Array.isArray(data.incomingEffects)){
      for(const eff of data.incomingEffects){
        if(eff && eff.id){
          applyEffect(eff);
        }
      }
    }

    determineWinner();
  }

  function handlePlayersSnapshot(snap){
    opponentData = null;
    opponentId = null;
    snap.forEach(docSnap=>{
      const d = docSnap.data();
      if(docSnap.id === currentUser.uid){
        myData = d;
      }else if(!opponentData){
        opponentData = d;
        opponentId = docSnap.id;
      }
    });

    if(myData){
      handleMyDocUpdate(myData);
    }

    if(opponentData){
      oppScoreLabel.textContent = opponentData.score ?? 0;
      connectionLabel.textContent = "Opponent connected";
      updateStatus("In match", "good");
    }else{
      oppScoreLabel.textContent = "‚Äî";
      connectionLabel.textContent = "Waiting for second player‚Ä¶";
      updateStatus("Waiting for opponent", null);
    }

    determineWinner();
  }

  async function joinGame(user){
    currentUser = user;
    gameRef = doc(db, GAME_COLLECTION, gameId);
    playersCol = collection(gameRef,"players");
    playerRef = doc(playersCol, user.uid);

    youLabel.textContent = displayName;
    connectionLabel.textContent = "Joining game‚Ä¶";

    await setDoc(playerRef,{
      uid:user.uid,
      name:displayName,
      score:0,
      level:1,
      lives:3,
      wins:0,
      dead:false,
      createdAt:serverTimestamp()
    },{merge:true});

    onSnapshot(playersCol, handlePlayersSnapshot);
    onSnapshot(playerRef,(snap)=>{
      if(snap.exists()){
        handleMyDocUpdate(snap.data());
      }
    });

    if(snapshotIntervalId) clearInterval(snapshotIntervalId);
    snapshotIntervalId = setInterval(pushSnapshot, 3000);

    resetGameBoard();
    updateStatus("In match (or waiting for opponent)", "good");
  }

  // ---------- AUTH ----------
  signInAnonymously(auth).catch(err=>{
    console.error(err);
    updateStatus("Auth failed", "bad");
    alert("Failed to sign in anonymously to Firebase: "+err.message);
  });

  onAuthStateChanged(auth,(user)=>{
    if(!user) return;
    joinGame(user).catch(e=>{
      console.error(e);
      updateStatus("Error joining game", "bad");
    });
  });
</script>
</body>
</html>






