<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>üè∞ Castle Panic ‚Äî Competitive Node War (2P, Firebase)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
  <style>
    :root{
      --bg:#020617;
      --panel:#0b1120;
      --ink:#e5e7eb;
      --muted:#9ca3af;
      --accent:#38bdf8;
      --accent-soft:#0ea5e9;
      --p1:#16a34a;
      --p2:#b91c1c;
      --contested:#facc15;
      --neutral:#4b5563;
      --radius:14px;
      --shadow:0 18px 40px rgba(0,0,0,.7);
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color:transparent;}
    html,body{
      margin:0;
      padding:0;
      height:100%;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      background:radial-gradient(circle at top,#0f172a 0,#020617 55%);
      color:var(--ink);
      overflow:hidden;
    }
    body{
      display:flex;
      flex-direction:column;
      align-items:center;
    }
    .shell{
      flex:1;
      display:flex;
      flex-direction:column;
      width:100%;
      max-width:1200px;
      padding:8px 8px calc(8px + env(safe-area-inset-bottom));
      gap:8px;
    }
    .top-bar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      padding:8px 12px;
      border-radius:var(--radius);
      background:rgba(15,23,42,.95);
      border:1px solid #1f2937;
      box-shadow:var(--shadow);
      font-size:.9rem;
    }
    .top-left,.top-right{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .game-title{
      display:flex;
      align-items:center;
      gap:6px;
      font-weight:700;
    }
    .pill{
      border-radius:999px;
      border:1px solid #1f2937;
      padding:4px 10px;
      background:rgba(15,23,42,.95);
      display:inline-flex;
      align-items:center;
      gap:6px;
      font-size:.78rem;
      color:var(--muted);
    }
    .pill strong{color:var(--ink); font-weight:600;}

    .hp-bar{
      position:relative;
      width:90px;
      height:8px;
      border-radius:999px;
      background:#020617;
      overflow:hidden;
      border:1px solid #1f2937;
    }
    .hp-fill{
      position:absolute;
      inset:0;
      background:linear-gradient(90deg,#16a34a,#facc15,#ef4444);
      width:100%;
      transition:width .18s linear;
    }

    .main{
      flex:1;
      display:flex;
      gap:8px;
      min-height:0;
    }
    @media (max-width:900px){
      .main{flex-direction:column;}
    }

    .panel{
      border-radius:var(--radius);
      background:rgba(15,23,42,.96);
      border:1px solid #1f2937;
      box-shadow:var(--shadow);
      padding:10px;
      min-height:0;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .panel-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:.85rem;
      color:var(--muted);
    }

    .board-panel{
      flex:1.1;
    }
    .side-panel{
      flex:0.9;
      min-width:260px;
    }

    .board-grid{
      flex:1;
      display:grid;
      grid-template-columns:repeat(6, minmax(0,1fr));
      grid-auto-rows:minmax(46px,1fr);
      gap:4px;
      padding:4px;
    }
    .node-cell{
      border-radius:12px;
      border:1px solid #1f2937;
      background:#020617;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      font-size:.78rem;
      cursor:pointer;
      position:relative;
      overflow:hidden;
      transition:transform .08s ease, box-shadow .08s ease, border-color .1s ease;
    }
    .node-main-label{
      font-size:.8rem;
    }
    .node-sub{
      font-size:.7rem;
      opacity:.85;
    }
    .node-eco-tag,
    .node-base-tag{
      position:absolute;
      top:4px;
      left:6px;
      font-size:.8rem;
      opacity:.9;
    }
    .node-cell:hover{
      transform:translateY(-1px);
      box-shadow:0 8px 18px rgba(0,0,0,.7);
      border-color:var(--accent-soft);
    }
    .node-selected{
      box-shadow:0 0 0 2px var(--accent-soft);
    }
    .node-p1{
      background:radial-gradient(circle at top,#14532d,#022c22);
      border-color:var(--p1);
    }
    .node-p2{
      background:radial-gradient(circle at top,#7f1d1d,#020617);
      border-color:var(--p2);
    }
    .node-contested{
      background:radial-gradient(circle at top,#facc15,#451a03);
      border-color:var(--contested);
      color:#111827;
    }
    .node-neutral{
      background:radial-gradient(circle at top,#374151,#020617);
      border-color:var(--neutral);
    }

    .btn{
      border-radius:999px;
      border:1px solid #1f2937;
      background:#020617;
      padding:6px 10px;
      font-size:.8rem;
      color:var(--ink);
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:4px;
    }
    .btn[disabled]{
      opacity:.4;
      cursor:default;
    }
    .btn-primary{
      border-color:var(--accent-soft);
      background:linear-gradient(135deg,#0ea5e9,#22c55e);
      color:#0f172a;
      font-weight:600;
    }

    .build-section-title{
      font-size:.8rem;
      color:var(--muted);
      margin-top:4px;
      margin-bottom:2px;
      font-weight:600;
    }
    .build-bar{
      display:flex;
      flex-wrap:wrap;
      gap:4px;
      padding:4px;
      border-radius:999px;
      border:1px solid #1f2937;
      background:rgba(15,23,42,.95);
      font-size:.76rem;
      align-items:center;
    }
    .build-pill{
      border-radius:999px;
      border:1px solid #1f2937;
      padding:3px 7px;
      display:inline-flex;
      align-items:center;
      gap:4px;
      cursor:pointer;
      background:#020617;
      color:var(--muted);
      white-space:nowrap;
    }
    .build-pill span.cost{
      opacity:.7;
      font-size:.72rem;
    }
    .build-pill.active{
      border-color:var(--accent-soft);
      color:var(--ink);
      background:radial-gradient(circle at top,#0ea5e9,#22c55e);
    }

    .small{
      font-size:.76rem;
      color:var(--muted);
    }
    .resource-line{
      font-size:.8rem;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .resource-line span strong{
      color:var(--ink);
    }

    .log-box{
      flex:1;
      min-height:80px;
      border-radius:10px;
      border:1px solid #1f2937;
      background:#020617;
      padding:6px 8px;
      font-size:.75rem;
      color:var(--muted);
      overflow:auto;
    }
    .log-line{
      margin-bottom:2px;
    }

    .winner-banner{
      position:fixed;
      inset:0;
      background:rgba(15,23,42,.94);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:40;
    }
    .winner-card{
      border-radius:18px;
      padding:18px 22px;
      border:1px solid #1f2937;
      background:radial-gradient(circle at top,#0f172a,#020617);
      box-shadow:var(--shadow);
      text-align:center;
      max-width:320px;
    }
    .winner-card h2{
      margin:0 0 6px;
    }
    .winner-card p{
      margin:4px 0;
      font-size:.9rem;
      color:var(--muted);
    }
  </style>
</head>
<body>
  <div class="shell">
    <div class="top-bar">
      <div class="top-left">
        <div class="game-title">
          üè∞ <span>Castle Panic</span>
        </div>
        <div class="pill">
          <span>You:</span> <strong id="youLabel">‚Ä¶</strong>
        </div>
        <div class="pill">
          <span>Side:</span> <strong id="sideLabel">‚Ä¶</strong>
        </div>
        <div class="pill">
          <span>Time:</span> <strong id="timeLabel">0:00</strong>
        </div>
      </div>
      <div class="top-right">
        <div class="pill">
          <span>P1 Castle</span>
          <div class="hp-bar">
            <div id="p1HpFill" class="hp-fill"></div>
          </div>
        </div>
        <div class="pill">
          <span>P2 Castle</span>
          <div class="hp-bar">
            <div id="p2HpFill" class="hp-fill"></div>
          </div>
        </div>
        <button id="fullscreenBtn" class="btn">‚õ∂ Fullscreen</button>
      </div>
    </div>

    <div class="main">
      <div class="panel board-panel">
        <div class="panel-header">
          <span>Battlefield ‚Äî 6√ó6 Nodes</span>
          <span class="small">
            Teal = only P1 ¬∑ Red = only P2 ¬∑ Yellow = both ¬∑ Grey = empty ¬∑ üí∞ = Eco ¬∑ üè∞ = Castles
          </span>
        </div>
        <div id="boardGrid" class="board-grid"></div>
      </div>

      <div class="panel side-panel">
        <div class="panel-header">
          <span>Build & Stats</span>
        </div>

        <div class="resource-line" id="resourceLine"></div>

        <div class="build-section-title">Structures (Gold)</div>
        <div class="build-bar" id="buildingBar"></div>

        <div class="build-section-title">Troops (Point Costs)</div>
        <div class="build-bar" id="troopBar"></div>

        <div class="small" style="margin-top:6px;">
          <strong>Core Rules:</strong><br/>
          ‚Ä¢ <strong>Gold</strong> builds structures. Generated every 5s + bonus per green üí∞ node you control.<br/>
          ‚Ä¢ <strong>Barracks</strong> ‚Üí Footman pts ‚öîÔ∏è ¬∑ <strong>Den</strong> ‚Üí Raider pts ü¶ä ¬∑ <strong>Armory</strong> ‚Üí Advanced pts ‚öôÔ∏è.<br/>
          ‚Ä¢ Troops cost points (not gold). Points are spent when you deploy them.<br/>
          ‚Ä¢ Knight / Archer / Catapult / Ballista / Glaive can only be built on nodes you control or adjacent.<br/>
          ‚Ä¢ <strong>Thief</strong> & <strong>Assassin</strong> can be built on <em>any</em> node (even the enemy castle) but are fragile.<br/>
          ‚Ä¢ On contested nodes, every second a mini battle resolves: catapults hit multiple enemies, glaives chain, ballistas fire heavy shots on cooldown, and raiders prefer sniping buildings.<br/>
          ‚Ä¢ When a castle‚Äôs HP hits 0, that side loses; the other is declared winner.
        </div>

        <div class="log-box" id="logBox"></div>
      </div>
    </div>
  </div>

  <div id="winnerOverlay" class="winner-banner">
    <div class="winner-card">
      <h2 id="winnerTitle">Winner!</h2>
      <p id="winnerText"></p>
      <button class="btn btn-primary" onclick="location.reload()">üîÅ Play Again</button>
    </div>
  </div>

  <script type="module">
    // ---------- FIREBASE ----------
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import {
      getFirestore, doc, setDoc, getDoc, updateDoc, runTransaction,
      collection, getDocs, onSnapshot, serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
    import {
      getAuth, signInAnonymously, onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

    const firebaseConfig = {
      apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
      authDomain: "bible-game-246c0.firebaseapp.com",
      projectId: "bible-game-246c0",
      storageBucket: "bible-game-246c0.appspot.com",
      messagingSenderId: "959619818996",
      appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
    };
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    // ---------- CONFIG ----------
    const GRID_SIZE = 6;
    const CASTLE_HP = 80;
    const INCOME_INTERVAL = 5; // seconds
    const GAME_COLLECTION = "castlepanic_games";

    // Castles: base on opposite sides
    const CASTLES = {
      A: { x: 2, y: 0 }, // P1 near top
      B: { x: 3, y: 5 }  // P2 near bottom
    };

    // Eco nodes: corners + middle 2√ó2
    const ECO_NODES = [
      {x:0,y:0},{x:5,y:0},{x:0,y:5},{x:5,y:5},
      {x:2,y:2},{x:3,y:2},{x:2,y:3},{x:3,y:3}
    ];

    // Buildings (gold)
    const BUILDINGS = {
      barracks: { key:"barracks", name:"Barracks", emoji:"üèïÔ∏è", goldCost:20, gen:{footman:1} },
      den:      { key:"den",      name:"Den",      emoji:"üï≥Ô∏è", goldCost:20, gen:{raider:1} },
      armory:   { key:"armory",   name:"Armory",   emoji:"‚öíÔ∏è", goldCost:25, gen:{advanced:1} }
    };

    // Units (points)
    const UNITS = {
      knight: {
        key:"knight", name:"Knight", emoji:"üõ°Ô∏è",
        hp:10, dmg:4, cost:{footman:1}, raider:false
      },
      archer: {
        key:"archer", name:"Archer", emoji:"üèπ",
        hp:6, dmg:3, cost:{footman:1}, raider:false
      },
      catapult: {
        key:"catapult", name:"Catapult", emoji:"üß±",
        hp:8, dmg:2, cost:{advanced:2}, raider:false, aoe:true
      },
      ballista: {
        key:"ballista", name:"Ballista", emoji:"üéØ",
        hp:8, dmg:6, cost:{advanced:2}, raider:false, cooldownMax:3
      },
      glaive: {
        key:"glaive", name:"Glaive", emoji:"üåÄ",
        hp:7, dmg:2, cost:{advanced:1}, raider:false, chain3:true
      },
      thief: {
        key:"thief", name:"Thief", emoji:"üïµÔ∏è",
        hp:4, dmg:1, cost:{raider:1}, raider:true
      },
      assassin: {
        key:"assassin", name:"Assassin", emoji:"üó°Ô∏è",
        hp:5, dmg:3, cost:{raider:1, advanced:1}, raider:true
      }
    };

    // ---------- GLOBAL STATE ----------
    const params = new URLSearchParams(window.location.search);
    const gameId = params.get("gameId") || "dev-castlepanic";
    const displayName = (params.get("username") || "Guest").trim() || "Guest";
    const gameRef = doc(db, GAME_COLLECTION, gameId);
    const nodesCol = collection(gameRef, "nodes");

    let currentUser = null;
    let playerRef = null;
    let myPlayer = null;
    let latestGame = null;
    let nodesState = {}; // id -> node data
    let isHost = false;
    let hostTickHandle = null;
    let hostTicking = false;
    let selectedBuild = null; // {kind:"building"|"unit", key:"..."}
    let joined = false;

    // ---------- DOM ----------
    const youLabel = document.getElementById("youLabel");
    const sideLabel = document.getElementById("sideLabel");
    const timeLabel = document.getElementById("timeLabel");
    const p1HpFill = document.getElementById("p1HpFill");
    const p2HpFill = document.getElementById("p2HpFill");
    const fullscreenBtn = document.getElementById("fullscreenBtn");

    const boardGridEl = document.getElementById("boardGrid");
    const buildingBarEl = document.getElementById("buildingBar");
    const troopBarEl = document.getElementById("troopBar");
    const resourceLineEl = document.getElementById("resourceLine");
    const logBoxEl = document.getElementById("logBox");

    const winnerOverlay = document.getElementById("winnerOverlay");
    const winnerTitle = document.getElementById("winnerTitle");
    const winnerText = document.getElementById("winnerText");

    function log(msg){
      const div = document.createElement("div");
      div.className = "log-line";
      div.textContent = msg;
      logBoxEl.appendChild(div);
      logBoxEl.scrollTop = logBoxEl.scrollHeight;
      console.log("[CASTLE]", msg);
    }

    function formatTime(sec){
      sec = Math.max(0, Math.floor(sec||0));
      const m = Math.floor(sec/60);
      const s = sec % 60;
      return `${m}:${s.toString().padStart(2,"0")}`;
    }

    function isEco(x,y){
      return ECO_NODES.some(n=>n.x===x && n.y===y);
    }

    function neighbors(x,y){
      const res=[];
      const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of dirs){
        const nx=x+dx, ny=y+dy;
        if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<GRID_SIZE) res.push({x:nx,y:ny});
      }
      return res;
    }

    function nodeKey(row,col){
      return `${row}_${col}`;
    }

    // ---------- AUTH ----------
    signInAnonymously(auth).catch(err=>{
      console.error(err);
      alert("Failed to sign in anonymously to Firebase: "+err.message);
    });

    onAuthStateChanged(auth, async (user)=>{
      if(!user) return;
      currentUser = user;
      if(joined) return;
      joined = true;
      playerRef = doc(gameRef,"players",user.uid);
      youLabel.textContent = displayName;
      await joinGame();
    });

    // ---------- JOIN / INIT GAME ----------
async function joinGame(){
  try{
    await runTransaction(db, async (tx)=>{
      // üîπ READS FIRST (no writes before these)
      const gameSnap = await tx.get(gameRef);
      const isNew = !gameSnap.exists();
      let gameData = isNew ? null : gameSnap.data();

      const playerSnap = await tx.get(playerRef); // <-- moved BEFORE any tx.set/tx.update

      // üîπ Now we can safely write
      if(isNew){
        // create game
        gameData = {
          createdAt: serverTimestamp(),
          hostUid: currentUser.uid,
          status: "running",
          timeSeconds: 0,
          baseA: { hp: CASTLE_HP, maxHp: CASTLE_HP },
          baseB: { hp: CASTLE_HP, maxHp: CASTLE_HP },
          slotAUid: currentUser.uid,
          slotBUid: null,
          winnerSide: null
        };
        tx.set(gameRef, gameData);

        // init nodes
        for(let y=0;y<GRID_SIZE;y++){
          for(let x=0;x<GRID_SIZE;x++){
            const id = nodeKey(y,x);
            const baseA = (x===CASTLES.A.x && y===CASTLES.A.y);
            const baseB = (x===CASTLES.B.x && y===CASTLES.B.y);
            const eco = isEco(x,y);
            let type = "normal";
            if(baseA) type = "baseA";
            else if(baseB) type = "baseB";
            else if(eco) type = "eco";

            const nodeDocRef = doc(nodesCol, id);
            const buildings = [];
            if(baseA){
              buildings.push({
                id:"castleA",
                owner:"A",
                kind:"castle",
                x,y,
                hp:CASTLE_HP,
                maxHp:CASTLE_HP
              });
            }
            if(baseB){
              buildings.push({
                id:"castleB",
                owner:"B",
                kind:"castle",
                x,y,
                hp:CASTLE_HP,
                maxHp:CASTLE_HP
              });
            }

            tx.set(nodeDocRef,{
              id,
              row:y,
              col:x,
              type,
              units:[],
              buildings
            });
          }
        }
      }

      // üîπ Assign side for this player (A/B/spec)
      let side = "spectator";
      if(gameData.slotAUid === currentUser.uid){
        side = "A";
      }else if(gameData.slotBUid === currentUser.uid){
        side = "B";
      }else if(!gameData.slotAUid){
        side = "A";
        tx.update(gameRef,{slotAUid: currentUser.uid});
      }else if(!gameData.slotBUid){
        side = "B";
        tx.update(gameRef,{slotBUid: currentUser.uid});
      }else{
        side = "spectator";
      }

      if(!playerSnap.exists()){
        tx.set(playerRef,{
          uid: currentUser.uid,
          name: displayName,
          side,
          gold: 40,
          footmanPts: 0,
          raiderPts: 0,
          advancedPts: 0,
          joinedAt: serverTimestamp()
        });
      }else{
        tx.update(playerRef,{
          name: displayName,
          side
        });
      }
    });

    // üîπ listeners (unchanged)
    onSnapshot(gameRef,(snap)=>{
      if(!snap.exists()) return;
      latestGame = snap.data();
      renderMeta();
      syncHostRole();
    });

    onSnapshot(playerRef,(snap)=>{
      if(!snap.exists()) return;
      myPlayer = snap.data();
      sideLabel.textContent =
        myPlayer.side==="A" ? "P1" :
        myPlayer.side==="B" ? "P2" :
        "Spectator";
      renderResources();
    });

    onSnapshot(nodesCol,(snap)=>{
      nodesState = {};
      snap.forEach(d=>{
        nodesState[d.id] = d.data();
      });
      renderBoard();
      renderResources();
    });

    log("Joined Firebase game: "+gameId);
  }catch(e){
    console.error(e);
    alert("Error joining game: "+e.message);
  }
}

    // ---------- META / HOST ----------
    function renderMeta(){
      if(!latestGame) return;
      timeLabel.textContent = formatTime(latestGame.timeSeconds || 0);

      const baseA = latestGame.baseA || {hp:0,maxHp:1};
      const baseB = latestGame.baseB || {hp:0,maxHp:1};
      const pctA = Math.max(0,Math.min(100,(baseA.hp/baseA.maxHp)*100));
      const pctB = Math.max(0,Math.min(100,(baseB.hp/baseB.maxHp)*100));
      p1HpFill.style.width = pctA + "%";
      p2HpFill.style.width = pctB + "%";

      if(latestGame.status==="finished" && latestGame.winnerSide && !winnerOverlay.style.display){
        showWinner(latestGame.winnerSide);
      }
    }

    function syncHostRole(){
      if(!latestGame || !currentUser) return;
      const shouldBeHost = latestGame.hostUid === currentUser.uid;
      if(shouldBeHost && !isHost){
        isHost = true;
        startHostLoop();
        log("You are host ‚Äî running simulation.");
      }else if(!shouldBeHost && isHost){
        isHost = false;
        stopHostLoop();
        log("Host role moved to another client.");
      }
    }

    function startHostLoop(){
      if(hostTickHandle) clearInterval(hostTickHandle);
      hostTickHandle = setInterval(()=>hostTick().catch(console.error), 1000);
    }
    function stopHostLoop(){
      if(hostTickHandle){
        clearInterval(hostTickHandle);
        hostTickHandle = null;
      }
    }

    async function hostTick(){
      if(!isHost || hostTicking) return;
      hostTicking = true;
      try{
        const gSnap = await getDoc(gameRef);
        if(!gSnap.exists()){ hostTicking=false; return; }
        const game = gSnap.data();
        if(game.status && game.status!=="running"){ hostTicking=false; return; }

        let timeSeconds = (game.timeSeconds || 0) + 1;
        const updates = { timeSeconds };

        // combat every second
        const combatResult = await processCombat(game);
        if(combatResult && combatResult.winnerSide && game.status!=="finished"){
          updates.status = "finished";
          updates.winnerSide = combatResult.winnerSide;
        }

        // income
        if(timeSeconds % INCOME_INTERVAL === 0 && game.status==="running"){
          await applyIncomeTick();
        }

        // compute castle hp from nodes
        const baseHp = computeBaseHpFromNodes();
        updates.baseA = baseHp.baseA;
        updates.baseB = baseHp.baseB;

        if(updates.baseA.hp <=0 && !updates.winnerSide){
          updates.status = "finished";
          updates.winnerSide = "B";
        }else if(updates.baseB.hp <=0 && !updates.winnerSide){
          updates.status = "finished";
          updates.winnerSide = "A";
        }

        await updateDoc(gameRef, updates);
      }catch(e){
        console.error("hostTick error", e);
      }
      hostTicking = false;
    }

    function computeBaseHpFromNodes(){
      let hpA = 0, hpB = 0;
      for(const key in nodesState){
        const n = nodesState[key];
        if(!n || !n.buildings) continue;
        for(const b of n.buildings){
          if(b.kind==="castle" && b.owner==="A") hpA = b.hp;
          if(b.kind==="castle" && b.owner==="B") hpB = b.hp;
        }
      }
      return {
        baseA:{ hp:Math.max(0,hpA), maxHp:CASTLE_HP },
        baseB:{ hp:Math.max(0,hpB), maxHp:CASTLE_HP }
      };
    }

    async function applyIncomeTick(){
      const playersSnap = await getDocs(collection(gameRef,"players"));
      const ecoControl = computeEcoControl();

      const updates = [];
      playersSnap.forEach(ps=>{
        const p = ps.data();
        if(p.side!=="A" && p.side!=="B") return;
        const side = p.side;
        let goldGain = 3; // base
        const extraEco = ecoControl[side] || 0;
        goldGain += extraEco; // +1 per eco node controlled

        let footmanPts = p.footmanPts || 0;
        let raiderPts = p.raiderPts || 0;
        let advancedPts = p.advancedPts || 0;

        // building generation
        for(const key in nodesState){
          const n = nodesState[key];
          if(!n || !n.buildings) continue;
          for(const b of n.buildings){
            if(b.owner !== side) continue;
            const def = BUILDINGS[b.kind];
            if(!def || !def.gen) continue;
            if(def.gen.footman) footmanPts += def.gen.footman;
            if(def.gen.raider) raiderPts += def.gen.raider;
            if(def.gen.advanced) advancedPts += def.gen.advanced;
          }
        }

        updates.push(updateDoc(ps.ref,{
          gold:(p.gold||0)+goldGain,
          footmanPts,
          raiderPts,
          advancedPts
        }));
      });

      if(updates.length) await Promise.all(updates);
    }

    function computeEcoControl(){
      const result = {A:0,B:0};
      for(const nKey in nodesState){
        const n = nodesState[nKey];
        if(!n) continue;
        if(n.type!=="eco") continue;
        const control = getNodeControl(n);
        if(control==="A") result.A++;
        else if(control==="B") result.B++;
      }
      return result;
    }

    // ---------- COMBAT ----------
    function getNodeControl(node){
      const units = node.units || [];
      const buildings = node.buildings || [];
      let hasA=false, hasB=false;
      for(const u of units){
        if(u.owner==="A") hasA=true;
        if(u.owner==="B") hasB=true;
      }
      for(const b of buildings){
        if(b.owner==="A") hasA=true;
        if(b.owner==="B") hasB=true;
      }
      if(hasA && hasB) return "contested";
      if(hasA) return "A";
      if(hasB) return "B";
      return "none";
    }

    // Helper pickers for combat
    function randomFrom(arr){
      if(!arr.length) return null;
      const idx = Math.floor(Math.random()*arr.length);
      return arr[idx];
    }

    function randomOthers(arr,excludeId,limit){
      const pool = arr.filter(t=>t.id!==excludeId);
      const out=[];
      while(pool.length && out.length<limit){
        const idx = Math.floor(Math.random()*pool.length);
        out.push(pool[idx]);
        pool.splice(idx,1);
      }
      return out;
    }

    function resolveUnitAttack(attacker, enemyUnits, enemyBuildings){
      const def = UNITS[attacker.kind];
      if(!def) return;

      // BALLISTA: big hit but on cooldown
      if(def.key==="ballista"){
        attacker.cooldown = (attacker.cooldown || 0) - 1;
        if(attacker.cooldown > 0){
          return;
        }
        // prioritize castles -> other buildings -> units
        const castles = enemyBuildings.filter(b=>b.kind==="castle");
        const nonCastleBuildings = enemyBuildings.filter(b=>b.kind!=="castle");
        const unitTargets = enemyUnits;
        let target = randomFrom(castles) || randomFrom(nonCastleBuildings) || randomFrom(unitTargets);
        if(!target) return;

        target.hp -= def.dmg; // heavy shot
        attacker.cooldown = def.cooldownMax || 3;
        return;
      }

      // THIEF / ASSASSIN: prefer buildings, then units
      if(def.key==="thief" || def.key==="assassin"){
        const buildingTargets = enemyBuildings;
        const unitTargets = enemyUnits;
        const target = randomFrom(buildingTargets) || randomFrom(unitTargets);
        if(!target) return;
        target.hp -= def.dmg;
        return;
      }

      // CATAPULT: splash, up to 3 different targets
      if(def.aoe){
        const allTargets = [...enemyUnits, ...enemyBuildings];
        if(!allTargets.length) return;
        for(let i=0;i<3;i++){
          const t = randomFrom(allTargets);
          if(!t) break;
          t.hp -= def.dmg;
        }
        return;
      }

      // GLAIVE: hit one, then chain to up to 2 more
      if(def.chain3){
        const allTargets = [...enemyUnits, ...enemyBuildings];
        if(!allTargets.length) return;
        const primary = randomFrom(allTargets);
        if(!primary) return;
        primary.hp -= def.dmg;
        const others = randomOthers(allTargets, primary.id, 2);
        for(const o of others){
          o.hp -= def.dmg;
        }
        return;
      }

      // DEFAULT: knight / archer etc. single-target DPS
      const allTargets = [...enemyUnits, ...enemyBuildings];
      const target = randomFrom(allTargets);
      if(!target) return;
      target.hp -= def.dmg;
    }

    async function processCombat(game){
      const nodeUpdates = [];
      let castleADead = false;
      let castleBDead = false;

      for(const key in nodesState){
        const node = nodesState[key];
        if(!node) continue;
        let units = (node.units || []).map(u=>({...u}));
        let buildings = (node.buildings || []).map(b=>({...b}));

        const hasA = units.some(u=>u.owner==="A") || buildings.some(b=>b.owner==="A");
        const hasB = units.some(u=>u.owner==="B") || buildings.some(b=>b.owner==="B");
        if(!(hasA && hasB)) continue; // only run combat if both present

        // Partition
        const unitsA = units.filter(u=>u.owner==="A");
        const unitsB = units.filter(u=>u.owner==="B");
        const bldA = buildings.filter(b=>b.owner==="A");
        const bldB = buildings.filter(b=>b.owner==="B");

        // A attacks B
        const enemyUnitsForA = unitsB;
        const enemyBldForA = bldB;
        for(const u of unitsA){
          resolveUnitAttack(u, enemyUnitsForA, enemyBldForA);
        }

        // B attacks A
        const enemyUnitsForB = unitsA;
        const enemyBldForB = bldA;
        for(const u of unitsB){
          resolveUnitAttack(u, enemyUnitsForB, enemyBldForB);
        }

        // Clean up death (keep castles even at 0hp so base HP can be read)
        const mergedUnits = [...unitsA, ...unitsB].filter(u=>u.hp>0);
        const mergedBuildings = [...bldA, ...bldB].filter(b=>{
          if(b.kind==="castle") return true;
          return b.hp > 0;
        });

        // Check castle HP
        for(const b of mergedBuildings){
          if(b.kind==="castle" && b.owner==="A" && b.hp<=0){
            castleADead = true;
          }
          if(b.kind==="castle" && b.owner==="B" && b.hp<=0){
            castleBDead = true;
          }
        }

        nodeUpdates.push(
          setDoc(doc(nodesCol,key),{
            units: mergedUnits,
            buildings: mergedBuildings
          },{merge:true})
        );
      }

      if(nodeUpdates.length) await Promise.all(nodeUpdates);

      let winnerSide = null;
      if(castleADead && !castleBDead) winnerSide = "B";
      if(castleBDead && !castleADead) winnerSide = "A";
      // if both dead same tick, winnerSide stays null (tie) ‚Äî game status won't flip here

      return { winnerSide };
    }

    // ---------- RENDER ----------
    function buildBars(){
      buildingBarEl.innerHTML = "";
      troopBarEl.innerHTML = "";

      for(const key in BUILDINGS){
        const def = BUILDINGS[key];
        const btn = document.createElement("button");
        btn.type="button";
        btn.className="build-pill";
        btn.dataset.kind="building";
        btn.dataset.key=def.key;
        btn.innerHTML = `${def.emoji} ${def.name} <span class="cost">(${def.goldCost}üí∞)</span>`;
        btn.onclick = ()=> selectBuild("building", def.key);
        buildingBarEl.appendChild(btn);
      }

      for(const key in UNITS){
        const def = UNITS[key];
        const costStr = costToString(def.cost);
        const btn = document.createElement("button");
        btn.type="button";
        btn.className="build-pill";
        btn.dataset.kind="unit";
        btn.dataset.key=def.key;
        btn.innerHTML = `${def.emoji} ${def.name} <span class="cost">(${costStr})</span>`;
        btn.onclick = ()=> selectBuild("unit", def.key);
        troopBarEl.appendChild(btn);
      }
    }

    function costToString(cost){
      const parts = [];
      if(cost.footman) parts.push(`${cost.footman}‚öîÔ∏è`);
      if(cost.raider) parts.push(`${cost.raider}ü¶ä`);
      if(cost.advanced) parts.push(`${cost.advanced}‚öôÔ∏è`);
      return parts.join(" + ") || "free";
    }

    function selectBuild(kind,key){
      if(!myPlayer) return;
      selectedBuild = { kind, key };
      document.querySelectorAll(".build-pill").forEach(el=>{
        const k = el.dataset.key;
        const kd = el.dataset.kind;
        el.classList.toggle("active", kd===kind && k===key);
      });
    }

    function renderBoard(){
      buildBars();
      boardGridEl.innerHTML = "";
      for(let y=0;y<GRID_SIZE;y++){
        for(let x=0;x<GRID_SIZE;x++){
          const id = nodeKey(y,x);
          const node = nodesState[id] || { row:y,col:x,units:[],buildings:[],type:"normal" };

          const cell = document.createElement("div");
          cell.className="node-cell";
          cell.dataset.row = y;
          cell.dataset.col = x;

          const control = getNodeControl(node);
          if(control==="A") cell.classList.add("node-p1");
          else if(control==="B") cell.classList.add("node-p2");
          else if(control==="contested") cell.classList.add("node-contested");
          else cell.classList.add("node-neutral");

          const isEcoNode = node.type==="eco";
          const isBaseA = node.type==="baseA";
          const isBaseB = node.type==="baseB";

          if(isEcoNode){
            const tag = document.createElement("div");
            tag.className="node-eco-tag";
            tag.textContent="üí∞";
            cell.appendChild(tag);
          }
          if(isBaseA || isBaseB){
            const tag = document.createElement("div");
            tag.className="node-base-tag";
            tag.textContent="üè∞";
            cell.appendChild(tag);
          }

          const main = document.createElement("div");
          main.className="node-main-label";
          if(isBaseA) main.textContent="P1 Castle";
          else if(isBaseB) main.textContent="P2 Castle";
          else if(isEcoNode) main.textContent="Eco";
          else main.textContent = `(${x+1},${y+1})`;
          cell.appendChild(main);

          const sub = document.createElement("div");
          sub.className="node-sub";
          const units = node.units || [];
          const blds = node.buildings || [];
          const countA = units.filter(u=>u.owner==="A").length + blds.filter(b=>b.owner==="A").length;
          const countB = units.filter(u=>u.owner==="B").length + blds.filter(b=>b.owner==="B").length;
          const pieces = [];
          if(countA) pieces.push(`P1:${countA}`);
          if(countB) pieces.push(`P2:${countB}`);
          sub.textContent = pieces.length ? pieces.join(" ¬∑ ") : "Empty";
          cell.appendChild(sub);

          cell.addEventListener("click", onCellClick);
          boardGridEl.appendChild(cell);
        }
      }
    }

    function renderResources(){
      if(!myPlayer) return;
      resourceLineEl.innerHTML = `
        <span><strong>${myPlayer.side==="A"?"P1":myPlayer.side==="B"?"P2":"Spec"}</strong> Gold: ${myPlayer.gold ?? 0}üí∞</span>
        <span>‚öîÔ∏è Footman: <strong>${myPlayer.footmanPts ?? 0}</strong></span>
        <span>ü¶ä Raider: <strong>${myPlayer.raiderPts ?? 0}</strong></span>
        <span>‚öôÔ∏è Advanced: <strong>${myPlayer.advancedPts ?? 0}</strong></span>
      `;
      renderMeta();
    }

    function showWinner(side){
      const winnerTextSide = side==="A" ? "Player 1" : "Player 2";
      const loser = side==="A" ? "Player 2" : "Player 1";
      winnerTitle.textContent = `${winnerTextSide} Wins!`;
      winnerText.textContent = `${winnerTextSide} destroyed ${loser}'s castle.`;
      winnerOverlay.style.display = "flex";
    }

    // ---------- BUILDING RULES ----------
    function canBuildHereForSide(side,row,col,unitDefOrNull,isBuilding){
      const node = nodesState[nodeKey(row,col)];
      if(!node) return false;

      if(isBuilding){
        if(node.type==="baseA" || node.type==="baseB") return false;
      }else if(unitDefOrNull && unitDefOrNull.raider){
        // raider units (thief/assassin) can go anywhere
        return true;
      }

      // Non-raider troops & structures: must be on a node you control or adjacent
      const control = getNodeControl(node);
      if(control===side) return true;
      const adj = neighbors(col,row);
      for(const n of adj){
        const adjNode = nodesState[nodeKey(n.y,n.x)];
        if(adjNode && getNodeControl(adjNode)===side) return true;
      }
      return false;
    }

    // ---------- PLACE BUILDING / UNIT ----------
    async function onCellClick(e){
      if(!myPlayer) return;
      if(latestGame && latestGame.status==="finished") return;
      const row = Number(e.currentTarget.dataset.row);
      const col = Number(e.currentTarget.dataset.col);
      const side = myPlayer.side;
      if(side!=="A" && side!=="B"){
        log("Spectators cannot build.");
        return;
      }
      if(!selectedBuild){
        log("Select a structure or troop to build first.");
        return;
      }

      const nodeId = nodeKey(row,col);
      const build = selectedBuild;

      try{
        if(build.kind==="building"){
          await placeBuilding(side,nodeId,row,col,build.key);
        }else{
          await placeUnit(side,nodeId,row,col,build.key);
        }
      }catch(err){
        log("Build failed: "+err.message);
      }
    }

    async function placeBuilding(side,nodeId,row,col,key){
      const def = BUILDINGS[key];
      if(!def) throw new Error("Unknown building.");

      if(!canBuildHereForSide(side,row,col,null,true)){
        throw new Error("Structures must be built in or next to your territory and not on castles.");
      }

      await runTransaction(db, async (tx)=>{
        const pSnap = await tx.get(playerRef);
        if(!pSnap.exists()) throw new Error("Player missing.");
        const p = pSnap.data();
        if(p.side!==side) throw new Error("Side mismatch.");
        if((p.gold || 0) < def.goldCost) throw new Error("Not enough gold.");

        const nodeRef = doc(nodesCol,nodeId);
        const nSnap = await tx.get(nodeRef);
        if(!nSnap.exists()) throw new Error("Node missing.");
        const node = nSnap.data();
        node.buildings = node.buildings || [];

        node.buildings.push({
          id:"b_"+Date.now()+"_"+Math.random().toString(16).slice(2,6),
          owner:side,
          kind:def.key,
          x:col,
          y:row,
          hp:12,
          maxHp:12
        });

        tx.update(playerRef,{ gold:(p.gold||0)-def.goldCost });
        tx.set(nodeRef,{ buildings:node.buildings },{merge:true});
      });
      log(`${side==="A"?"P1":"P2"} built ${def.name} at (${col+1},${row+1}).`);
    }

    function hasCost(cost,p){
      if(cost.footman && (p.footmanPts||0) < cost.footman) return false;
      if(cost.raider && (p.raiderPts||0) < cost.raider) return false;
      if(cost.advanced && (p.advancedPts||0) < cost.advanced) return false;
      return true;
    }
    function spendCost(cost,p){
      const result = {...p};
      if(cost.footman) result.footmanPts = (result.footmanPts||0) - cost.footman;
      if(cost.raider) result.raiderPts = (result.raiderPts||0) - cost.raider;
      if(cost.advanced) result.advancedPts = (result.advancedPts||0) - cost.advanced;
      return result;
    }

    async function placeUnit(side,nodeId,row,col,key){
      const def = UNITS[key];
      if(!def) throw new Error("Unknown troop.");

      if(!canBuildHereForSide(side,row,col,def,false)){
        if(def.raider){
          throw new Error("You cannot place there.");
        }else{
          throw new Error("Non-raider troops must be built in or next to your territory.");
        }
      }

      await runTransaction(db, async (tx)=>{
        const pSnap = await tx.get(playerRef);
        if(!pSnap.exists()) throw new Error("Player missing.");
        const p = pSnap.data();
        if(p.side!==side) throw new Error("Side mismatch.");
        if(!hasCost(def.cost,p)) throw new Error("Not enough points.");

        const updatedP = spendCost(def.cost,p);

        const nodeRef = doc(nodesCol,nodeId);
        const nSnap = await tx.get(nodeRef);
        if(!nSnap.exists()) throw new Error("Node missing.");
        const node = nSnap.data();
        node.units = node.units || [];

        node.units.push({
          id:"u_"+Date.now()+"_"+Math.random().toString(16).slice(2,6),
          owner:side,
          kind:def.key,
          x:col,
          y:row,
          hp:def.hp,
          maxHp:def.hp,
          cooldown:0
        });

        tx.update(playerRef,{
          footmanPts: updatedP.footmanPts || 0,
          raiderPts: updatedP.raiderPts || 0,
          advancedPts: updatedP.advancedPts || 0
        });
        tx.set(nodeRef,{ units:node.units },{merge:true});
      });
      log(`${side==="A"?"P1":"P2"} deployed ${def.name} at (${col+1},${row+1}).`);
    }

    // ---------- FULLSCREEN ----------
    fullscreenBtn.addEventListener("click",()=>{
      const el = document.documentElement;
      if(!document.fullscreenElement){
        el.requestFullscreen?.();
      }else{
        document.exitFullscreen?.();
      }
    });

    // ---------- BOOT ----------
    log("Connecting to Firebase and waiting for authentication‚Ä¶");
    buildBars(); // initial UI
  </script>
</body>
</html>






