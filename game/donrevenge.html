<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>üõ∞Ô∏è Grid Overlord ‚Äî Co-op Node Defense</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
  <style>
    :root{
      --bg:#020617;
      --panel:#0b1120;
      --ink:#e5e7eb;
      --muted:#9ca3af;
      --accent:#38bdf8;
      --accent-soft:#0ea5e9;
      --danger:#ef4444;
      --enemy:#b91c1c;
      --player:#16a34a;
      --contested:#facc15;
      --neutral:#4b5563;
      --radius:14px;
      --shadow:0 18px 40px rgba(0,0,0,.7);
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color:transparent;}
    html,body{
      margin:0;
      padding:0;
      height:100%;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      background:radial-gradient(circle at top,#0f172a 0,#020617 55%);
      color:var(--ink);
      overflow:hidden;
    }
    body{
      display:flex;
      flex-direction:column;
      align-items:center;
    }
    .shell{
      flex:1;
      display:flex;
      flex-direction:column;
      width:100%;
      max-width:1200px;
      padding:8px 8px calc(8px + env(safe-area-inset-bottom));
      gap:8px;
    }
    .top-bar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      padding:8px 12px;
      border-radius:var(--radius);
      background:rgba(15,23,42,.95);
      border:1px solid #1f2937;
      box-shadow:var(--shadow);
      font-size:.9rem;
    }
    .top-left,.top-right{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .game-title{
      display:flex;
      align-items:center;
      gap:6px;
      font-weight:700;
    }
    .pill{
      border-radius:999px;
      border:1px solid #1f2937;
      padding:4px 10px;
      background:rgba(15,23,42,.95);
      display:inline-flex;
      align-items:center;
      gap:6px;
      font-size:.78rem;
      color:var(--muted);
    }
    .pill strong{color:var(--ink); font-weight:600;}

    .hp-bar{
      position:relative;
      width:90px;
      height:8px;
      border-radius:999px;
      background:#020617;
      overflow:hidden;
      border:1px solid #1f2937;
    }
    .hp-fill{
      position:absolute;
      inset:0;
      background:linear-gradient(90deg,#16a34a,#facc15,#ef4444);
      width:100%;
      transition:width .18s linear;
    }

    .main{
      flex:1;
      display:flex;
      gap:8px;
      min-height:0;
    }
    @media (max-width:900px){
      .main{flex-direction:column;}
    }

    .panel{
      border-radius:var(--radius);
      background:rgba(15,23,42,.96);
      border:1px solid #1f2937;
      box-shadow:var(--shadow);
      padding:10px;
      min-height:0;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .panel-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:.85rem;
      color:var(--muted);
    }

    .board-panel{
      flex:1.1;
    }
    .side-panel{
      flex:0.9;
      min-width:260px;
    }

    .board-grid{
      flex:1;
      display:grid;
      grid-template-columns:repeat(7, minmax(0,1fr));
      grid-auto-rows:minmax(40px,1fr);
      gap:4px;
      padding:4px;
    }
    .node-cell{
      border-radius:12px;
      border:1px solid #1f2937;
      background:#020617;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      font-size:.8rem;
      cursor:pointer;
      position:relative;
      overflow:hidden;
      transition:transform .08s ease, box-shadow .08s ease, border-color .1s ease;
    }
    .node-cell span{pointer-events:none;}
    .node-owner{
      font-size:.72rem;
      opacity:.85;
    }
    .node-cell:hover{
      transform:translateY(-1px);
      box-shadow:0 8px 18px rgba(0,0,0,.7);
      border-color:var(--accent-soft);
    }
    .node-base-tag,
    .node-eco-tag{
      position:absolute;
      top:4px;
      left:6px;
      font-size:.75rem;
      opacity:.9;
    }

    .node-player{
      background:radial-gradient(circle at top,#15803d,#022c22);
      border-color:#16a34a;
    }
    .node-enemy{
      background:radial-gradient(circle at top,#7f1d1d,#020617);
      border-color:#b91c1c;
    }
    .node-neutral{
      background:radial-gradient(circle at top,#374151,#020617);
      border-color:#4b5563;
    }
    .node-contested{
      background:radial-gradient(circle at top,#facc15,#451a03);
      border-color:#facc15;
      color:#111827;
    }
    .node-selected{
      box-shadow:0 0 0 2px var(--accent-soft);
    }

    .btn{
      border-radius:999px;
      border:1px solid #1f2937;
      background:#020617;
      padding:6px 10px;
      font-size:.8rem;
      color:var(--ink);
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:4px;
    }
    .btn[disabled]{
      opacity:.4;
      cursor:default;
    }
    .btn-primary{
      border-color:var(--accent-soft);
      background:linear-gradient(135deg,#0ea5e9,#22c55e);
      color:#0f172a;
      font-weight:600;
    }

    .node-info-box{
      flex:1;
      min-height:80px;
      border-radius:10px;
      border:1px solid #1f2937;
      background:#020617;
      padding:6px 8px;
      font-size:.78rem;
      color:var(--muted);
      overflow:auto;
    }

    .log-box{
      height:120px;
      border-radius:10px;
      border:1px solid #1f2937;
      background:#020617;
      padding:6px 8px;
      font-size:.75rem;
      color:var(--muted);
      overflow:auto;
    }
    .log-line{margin-bottom:2px;}

    /* Mini battlefield preview in node details */
    .mini-grid{
      margin-top:6px;
      display:grid;
      grid-template-columns:repeat(10, minmax(0,1fr));
      gap:1px;
      padding:4px;
      border-radius:8px;
      background:#020617;
      border:1px solid #1f2937;
      max-width:220px;
    }
    .mini-grid-cell{
      width:100%;
      aspect-ratio:1/1;
      border-radius:3px;
      background:#030712;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:.65rem;
      color:#e5e7eb;
      opacity:.9;
    }
    .mini-grid-cell.bg-player{ background:#052e16; }
    .mini-grid-cell.bg-enemy{ background:#43171f; }
    .mini-grid-cell.bg-front{ background:#020617; }

    /* Battle overlay */
    .overlay{
      position:fixed;
      inset:0;
      background:rgba(15,23,42,.96);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:40;
    }
    .overlay-inner{
      width:min(1020px, 100vw - 12px);
      height:min(620px, 100vh - 16px);
      border-radius:var(--radius);
      border:1px solid #1f2937;
      background:radial-gradient(circle at top,#020617,#020617);
      box-shadow:var(--shadow);
      padding:8px;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .battle-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:.85rem;
      color:var(--muted);
    }
    .battle-main{
      flex:1;
      display:flex;
      gap:6px;
      min-height:0;
    }
    .battle-grid-wrap{
      flex:1;
      border-radius:12px;
      border:1px solid #1f2937;
      background:#020617;
      padding:4px;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      overflow:hidden;
    }
    .battle-grid{
      display:grid;
      grid-template-columns:repeat(10, minmax(0,1fr));
      grid-auto-rows:minmax(0,1fr);
      gap:2px;
      width:100%;
      max-width:520px;
      aspect-ratio:1/1;
      position:relative;
      z-index:1;
    }
    .battle-cell{
      border-radius:4px;
      background:#020617;
      border:1px solid #111827;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:1.1rem;
      position:relative;
      cursor:pointer;
      overflow:hidden;
    }
    .battle-cell-bg-player{
      background:#022c22;
    }
    .battle-cell-bg-enemy{
      background:#111827;
    }
    .battle-cell-bg-frontline{
      background:#1e293b;
    }
    .battle-cell .hp-bar-mini{
      position:absolute;
      bottom:1px;
      left:2px;
      right:2px;
      height:3px;
      border-radius:999px;
      background:#020617;
      overflow:hidden;
    }
    .battle-cell .hp-bar-mini-fill{
      height:100%;
      background:linear-gradient(90deg,#22c55e,#f97316,#ef4444);
      width:100%;
    }

    /* Hitline overlay */
    .hitline-layer{
      position:absolute;
      inset:4px;
      pointer-events:none;
      z-index:2;
    }
    .hitline{
      position:absolute;
      height:2px;
      background:rgba(148,163,184,.85);
      transform-origin:0 50%;
      opacity:.9;
    }
    .hitline.player{
      background:rgba(56,189,248,.9);
    }
    .hitline.enemy{
      background:rgba(248,113,113,.9);
    }

    .battle-side{
      width:220px;
      border-radius:12px;
      border:1px solid #1f2937;
      background:#020617;
      padding:6px;
      font-size:.78rem;
      display:flex;
      flex-direction:column;
      gap:4px;
      color:var(--muted);
    }

    .build-bar{
      display:flex;
      flex-wrap:wrap;
      gap:4px;
      padding:4px;
      border-radius:999px;
      border:1px solid #1f2937;
      background:rgba(15,23,42,.95);
      font-size:.76rem;
      align-items:center;
    }
    .build-pill{
      border-radius:999px;
      border:1px solid #1f2937;
      padding:3px 7px;
      display:inline-flex;
      align-items:center;
      gap:4px;
      cursor:pointer;
      background:#020617;
      color:var(--muted);
    }
    .build-pill.active{
      border-color:var(--accent-soft);
      color:var(--ink);
      background:radial-gradient(circle at top,#0ea5e9,#22c55e);
    }

    .tag{
      border-radius:999px;
      padding:2px 6px;
      border:1px solid #1f2937;
      font-size:.7rem;
      display:inline-flex;
      align-items:center;
      gap:4px;
    }
    .tag-base{border-color:var(--accent); color:var(--accent);}
    .tag-enemy{border-color:var(--danger); color:var(--danger);}
    .tag-green{border-color:var(--player); color:var(--player);}

    .small{
      font-size:.76rem;
      color:var(--muted);
    }
  </style>
</head>
<body>
  <div class="shell">
    <div class="top-bar">
      <div class="top-left">
        <div class="game-title">
          üõ∞Ô∏è <span>Grid Overlord</span>
        </div>
        <div class="pill">
          <span>Player:</span> <strong id="playerNameLabel">‚Ä¶</strong>
        </div>
        <div class="pill">
          <span>Time:</span> <strong id="timeLabel">0:00</strong>
        </div>
        <div class="pill">
          <span>Credits:</span> <strong id="moneyLabel">0</strong>
        </div>
      </div>
      <div class="top-right">
        <div class="pill">
          <span>Base</span>
          <div class="hp-bar">
            <div id="baseHpFill" class="hp-fill"></div>
          </div>
        </div>
        <button class="btn" id="fullscreenBtn">‚õ∂ Fullscreen</button>
      </div>
    </div>

    <div class="main">
      <div class="panel board-panel">
        <div class="panel-header">
          <span>Galaxy Map ‚Äî Control Nodes</span>
          <span class="small">Green = You ¬∑ Red = Alien ¬∑ Yellow = Contested ¬∑ üí∞ = Eco</span>
        </div>
        <div id="boardGrid" class="board-grid"></div>
      </div>

      <div class="panel side-panel">
        <div class="panel-header">
          <span>Node Details</span>
        </div>
        <div id="nodeInfo" class="node-info-box">
          <div>Select a node on the left to inspect or enter its battlefield.</div>
        </div>
        <div style="display:flex;gap:6px;margin-top:4px;">
          <button id="openBattleBtn" class="btn btn-primary" disabled>Enter Area</button>
          <button id="upgradeBaseBtn" class="btn" disabled>Upgrade Generator</button>
        </div>
        <div id="baseInfo" class="small" style="margin-top:6px;display:none;">
          Generator Lv <span id="baseLevelLabel">1</span> ¬∑ +<span id="incomeLabel">0</span> base credits / 5s per player (plus eco bonuses) ¬∑ Next upgrade: <span id="baseUpgradeCostLabel">0</span>
        </div>

        <div style="margin-top:8px;font-size:.78rem;color:var(--muted);">
          <strong>How it works:</strong><br/>
          - Aliens expand every 45s from red tiles into neighbors.<br/>
          - Some nodes are economic (üí∞). When green, they boost credits for everyone each income tick.<br/>
          - If they touch your green zones, those nodes become <span style="color:#facc15;">contested</span> and spawn attack waves.<br/>
          - Enemy nodes grow <span style="color:#22c55e;">spine nests üåµ</span> and alien armies over time.<br/>
          - Build troops & towers in node battlefields (first 3 columns) to hold the line.<br/>
          - Survive to 20 minutes for victory. If the base falls, everyone loses.
        </div>

        <div class="log-box" id="logBox"></div>
      </div>
    </div>
  </div>

  <!-- Battle Overlay -->
  <div id="battleOverlay" class="overlay" style="display:none;">
    <div class="overlay-inner">
      <div class="battle-header">
        <div>
          <span id="battleNodeLabel">Node</span>
          <span id="battleOwnerTag" class="tag tag-green" style="margin-left:6px;">Player</span>
        </div>
        <div style="display:flex;align-items:center;gap:6px;">
          <span class="small">Build only in the first 3 columns.</span>
          <button id="leaveBattleBtn" class="btn">‚¨Ö Leave</button>
        </div>
      </div>
      <div class="battle-main">
        <div class="battle-grid-wrap">
          <div id="battleGrid" class="battle-grid"></div>
        </div>
        <div class="battle-side">
          <div><strong>Troops</strong></div>
          <div class="build-bar" id="troopBar"></div>
          <div style="margin-top:4px;"><strong>Towers</strong></div>
          <div class="build-bar" id="towerBar"></div>
          <div style="margin-top:4px;font-size:.76rem;">
            <div>Click a type, then click a tile in the first 3 columns to place it.</div>
            <div style="margin-top:4px;">
              <span class="tag tag-base">Base node</span> has the generator. Enemies that reach the left side damage it.
            </div>
          </div>
          <div style="margin-top:4px;font-size:.76rem;">
            <strong>Synergies:</strong><br/>
            - üßë‚Äç‚öïÔ∏è Medics heal nearby allies.<br/>
            - ‚≠ê Sergeants boost troop damage near them.<br/>
            - üõ°Ô∏è Shield towers reduce damage taken near them.<br/>
            - üì° Signal towers empower nearby units & towers.<br/>
            - ‚ö° Tesla towers chain lightning between aliens.<br/>
            - üåµ Enemy piercer nests focus high damage.<br/>
            - üåµ Enemy shredder nests chip everything in range.
          </div>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    // ---------------- FIREBASE SETUP (Auth + Firestore) ----------------
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import {
      getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot,
      collection, runTransaction, serverTimestamp, getDocs
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
    import {
      getAuth, signInAnonymously, onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

    const firebaseConfig = {
      apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
      authDomain: "bible-game-246c0.firebaseapp.com",
      projectId: "bible-game-246c0",
      storageBucket: "bible-game-246c0.appspot.com",
      messagingSenderId: "959619818996",
      appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
    };
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    // ---------------- CONSTANTS / CONFIG ----------------
    const BOARD_SIZE = 7; // macro grid size
    const BATTLE_W = 10;
    const BATTLE_H = 10;
    const SPREAD_INTERVAL = 45; // seconds
    const INCOME_INTERVAL = 5;  // seconds
    const ENEMY_BUILD_INTERVAL = 30; // seconds
    const WAVE_MINUTES_1 = 5;
    const WAVE_MINUTES_2 = 10;
    const GAME_WIN_TIME = 20 * 60; // 20 minutes in seconds

    const ECO_BONUS_PER_NODE = 1; // extra credits per eco node per income tick (global)

    const params = new URLSearchParams(window.location.search);
    const gameId = params.get("gameId") || "dev-overlord";
    const displayName = (params.get("username") || "Guest").trim() || "Guest";

    const gameRef = doc(db, "grid_overlord_games", gameId);
    const nodesCol = collection(gameRef, "nodes");

    // Troops & towers definitions
    const TROOPS = {
      rifle:   { key:"rifle",   name:"Rifleman",      emoji:"üî´", baseHp:12, dmg:3, range:3, cost:8 },
      phase:   { key:"phase",   name:"Phase Blade",   emoji:"üó°Ô∏è", baseHp:18, dmg:4, range:1, cost:10 },
      bomber:  { key:"bomber",  name:"Photon Bomber", emoji:"üí£", baseHp:10, dmg:3, range:3, splash:true, cost:12 },
      medic:   { key:"medic",   name:"Medic",         emoji:"üßë‚Äç‚öïÔ∏è", baseHp:10, heal:3, range:2, cost:10 },
      sergeant:{ key:"sergeant",name:"Space Sergeant",emoji:"‚≠ê", baseHp:14, dmg:2, range:2, buff:true, cost:14 },
      sniper:  { key:"sniper",  name:"Ion Sniper",    emoji:"üéØ", baseHp:8,  dmg:5, range:5, cost:14 }
    };

    const TOWERS = {
      laser:  { key:"laser",  name:"Laser Tower",  emoji:"üî∫", dmg:4, range:4, cost:14 },
      tesla:  { key:"tesla",  name:"Tesla Coil",   emoji:"‚ö°", dmg:3, range:3, chain:true, cost:16 },
      shield: { key:"shield", name:"Shield Tower", emoji:"üõ°Ô∏è", range:2, shield:true, cost:12 },
      signal: { key:"signal", name:"Signal Tower", emoji:"üì°", range:2, buff:true, cost:16 }
    };

    // Enemy types (aliens)
    const ENEMIES = {
      bug:      { key:"bug",      emoji:"üêú", baseHp:10, dmg:2, speed:1 },
      spitter:  { key:"spitter",  emoji:"ü™≤", baseHp:14, dmg:3, speed:1 },
      brute:    { key:"brute",    emoji:"ü¶Ç", baseHp:26, dmg:5, speed:1 },
      behemoth: { key:"behemoth", emoji:"üëæ", baseHp:40, dmg:6, speed:1 }
    };

    // ---------------- LOCAL STATE ----------------
    let currentUser = null;
    let playerRef = null;
    let myPlayer = null;
    let latestGame = null;
    let nodesState = {}; // nodeId -> nodeData
    let isHost = false;
    let hostTickHandle = null;
    let hostTicking = false;

    let selectedNodeId = null;
    let selectedNode = null;

    let currentBuild = { type:null, category:null }; // {type:'rifle', category:'troop'|'tower'}

    let battleUnsub = null;

    // ---------------- DOM REFS ----------------
    const playerNameLabel = document.getElementById("playerNameLabel");
    const timeLabel = document.getElementById("timeLabel");
    const moneyLabel = document.getElementById("moneyLabel");
    const baseHpFill = document.getElementById("baseHpFill");
    const boardGridEl = document.getElementById("boardGrid");
    const nodeInfoEl = document.getElementById("nodeInfo");
    const logBoxEl = document.getElementById("logBox");
    const openBattleBtn = document.getElementById("openBattleBtn");
    const upgradeBaseBtn = document.getElementById("upgradeBaseBtn");
    const baseInfoEl = document.getElementById("baseInfo");
    const baseLevelLabel = document.getElementById("baseLevelLabel");
    const incomeLabel = document.getElementById("incomeLabel");
    const baseUpgradeCostLabel = document.getElementById("baseUpgradeCostLabel");

    const battleOverlay = document.getElementById("battleOverlay");
    const battleNodeLabel = document.getElementById("battleNodeLabel");
    const battleOwnerTag = document.getElementById("battleOwnerTag");
    const battleGridEl = document.getElementById("battleGrid");
    const troopBarEl = document.getElementById("troopBar");
    const towerBarEl = document.getElementById("towerBar");
    const leaveBattleBtn = document.getElementById("leaveBattleBtn");

    // ---------------- UTILS ----------------
    function log(msg){
      if(!logBoxEl) return;
      const div = document.createElement("div");
      div.className = "log-line";
      div.textContent = msg;
      logBoxEl.appendChild(div);
      logBoxEl.scrollTop = logBoxEl.scrollHeight;
      console.log("[GRID]", msg);
    }

    function nodeKey(row,col){ return `${row}_${col}`; }

    function parseKey(key){
      const [r,c]=key.split("_").map(Number);
      return {row:r,col:c};
    }

    function formatTime(sec){
      sec = Math.max(0, Math.floor(sec||0));
      const m = Math.floor(sec/60);
      const s = sec % 60;
      return `${m}:${s.toString().padStart(2,"0")}`;
    }

    function neighborsOf(row,col){
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      const out=[];
      for(const [dr,dc] of dirs){
        const nr = row+dr, nc = col+dc;
        if(nr>=0 && nr<BOARD_SIZE && nc>=0 && nc<BOARD_SIZE){
          out.push(nodeKey(nr,nc));
        }
      }
      return out;
    }

    // ---------------- AUTH + JOIN ----------------
    let joined = false;
    signInAnonymously(auth).catch(err=>{
      console.error(err);
      alert("Failed to sign in anonymously to Firebase: "+err.message);
    });

    onAuthStateChanged(auth, async (user)=>{
      if(!user) return;
      currentUser = user;
      if(joined) return;
      joined = true;
      playerRef = doc(gameRef,"players",user.uid);
      playerNameLabel.textContent = displayName;
      await joinGame();
    });

    async function joinGame(){
      try{
        await runTransaction(db, async (tx)=>{
          const center = Math.floor(BOARD_SIZE/2);

          // üîπ READS FIRST
          const gameSnap = await tx.get(gameRef);
          const isNewGame = !gameSnap.exists();
          const gameData = isNewGame ? null : gameSnap.data();

          const playerSnap = await tx.get(playerRef);

          // üîπ GAME / NODE CREATION AFTER ALL READS
          if(isNewGame){
            const baseHp = 120;
            const baseLevel = 1;
            const baseIncomePerPlayer = 4; // reduced base income
            tx.set(gameRef,{
              createdAt: serverTimestamp(),
              hostUid: currentUser.uid,
              status:"running",
              timeSeconds:0,
              base:{
                hp:baseHp,
                maxHp:baseHp,
                level:baseLevel,
                incomePerPlayer:baseIncomePerPlayer,
                upgradeCost:60
              },
              winAtSeconds: GAME_WIN_TIME
            });

            // seed nodes (center/player ring, enemy edge, eco ring)
            for(let r=0;r<BOARD_SIZE;r++){
              for(let c=0;c<BOARD_SIZE;c++){
                const id = nodeKey(r,c);

                const manhattan = Math.abs(r-center)+Math.abs(c-center);
                let owner;
                if(r===center && c===center){
                  owner = "player";
                }else if(manhattan === 1){
                  owner = "player";
                }else if(
                  (r===0 && (c===1 || c===BOARD_SIZE-2)) ||
                  (r===BOARD_SIZE-1 && (c===1 || c===BOARD_SIZE-2)) ||
                  (c===0 && (r===1 || r===BOARD_SIZE-2)) ||
                  (c===BOARD_SIZE-1 && (r===1 || r===BOARD_SIZE-2))
                ){
                  // only a few edge launch points instead of full ring
                  owner = "enemy";
                }else{
                  owner = "neutral";
                }

                let type = "normal";
                if(r===center && c===center) type = "base";
                else if(manhattan === 2) type = "eco";

                const nodeDocRef = doc(nodesCol, id);

                tx.set(nodeDocRef,{
                  id,
                  row:r,
                  col:c,
                  owner,
                  type,
                  spreadChance:0.33,
                  pendingWave:false,
                  battlefield:{
                    width:BATTLE_W,
                    height:BATTLE_H,
                    troops:[],
                    towers:[],
                    aliens:[],
                    spines:[],
                    hitLines:[]
                  }
                });
              }
            }
          }else{
            if(!gameData.hostUid){
              tx.update(gameRef,{hostUid: currentUser.uid});
            }
          }

          // üîπ PLAYER DOC AFTER READS
          if(!playerSnap.exists()){
            tx.set(playerRef,{
              uid: currentUser.uid,
              name: displayName,
              money: 30,          // start a bit tighter
              incomeBonus: 0,
              joinedAt: serverTimestamp()
            });
          }else{
            tx.update(playerRef,{ name: displayName });
          }
        });

        // Subscriptions
        onSnapshot(gameRef, (snap)=>{
          if(!snap.exists()) return;
          latestGame = snap.data();
          renderGameMeta();
          syncHostRole();
        });

        onSnapshot(nodesCol, (snap)=>{
          nodesState = {};
          snap.forEach(d=>{ nodesState[d.id]=d.data(); });
          renderBoard();
          if(selectedNodeId){
            selectedNode = nodesState[selectedNodeId] || null;
            renderNodeDetails();
          }
        });

        onSnapshot(playerRef, (snap)=>{
          if(!snap.exists()) return;
          myPlayer = snap.data();
          moneyLabel.textContent = Math.floor(myPlayer.money || 0);
        });

        log("Joined game: "+gameId);
      }catch(e){
        console.error(e);
        alert("Error joining game: "+e.message);
      }
    }

    // ---------------- RENDER: GAME META ----------------
    function renderGameMeta(){
      if(!latestGame) return;
      const sec = latestGame.timeSeconds || 0;
      timeLabel.textContent = formatTime(sec);

      const base = latestGame.base || {hp:0,maxHp:1,level:1,incomePerPlayer:0,upgradeCost:0};
      const hp = Math.max(0, base.hp || 0);
      const max = Math.max(1, base.maxHp || 1);
      const pct = Math.max(0, Math.min(100, (hp/max)*100));
      baseHpFill.style.width = pct + "%";

      baseInfoEl.style.display = "block";
      baseLevelLabel.textContent = base.level ?? 1;
      incomeLabel.textContent = base.incomePerPlayer ?? 0;
      baseUpgradeCostLabel.textContent = base.upgradeCost ?? 0;

      if(latestGame.status === "lost"){
        log("‚ö† Base destroyed. Game over for all players.");
      }else if(latestGame.status === "won"){
        log("‚úÖ You survived the full duration! Victory.");
      }
    }

    // ---------------- RENDER: WORLD BOARD ----------------
    function renderBoard(){
      if(!boardGridEl) return;
      boardGridEl.innerHTML = "";
      const center = Math.floor(BOARD_SIZE/2);

      for(let r=0;r<BOARD_SIZE;r++){
        for(let c=0;c<BOARD_SIZE;c++){
          const key = nodeKey(r,c);
          const node = nodesState[key];
          const div = document.createElement("div");
          div.className = "node-cell";
          if(node){
            if(node.owner==="player") div.classList.add("node-player");
            else if(node.owner==="enemy") div.classList.add("node-enemy");
            else if(node.owner==="neutral") div.classList.add("node-neutral");
            else if(node.owner==="contested") div.classList.add("node-contested");
            if(key===selectedNodeId) div.classList.add("node-selected");
          }

          const title = document.createElement("span");
          title.textContent =
            (r===center && c===center) ? "Base" :
            (node && node.type==="eco") ? "Eco" :
            `Node ${r+1}-${c+1}`;
          div.appendChild(title);

          const ownerSpan = document.createElement("span");
          ownerSpan.className = "node-owner";
          ownerSpan.textContent = node ? (
            node.owner==="player" ? "You" :
            node.owner==="enemy" ? "Aliens" :
            node.owner==="contested" ? "Contested" :
            "Neutral"
          ) : "‚Ä¶";
          div.appendChild(ownerSpan);

          if(node && node.type==="base"){
            const tag = document.createElement("div");
            tag.className = "node-base-tag";
            tag.textContent = "‚ö°";
            div.appendChild(tag);
          }else if(node && node.type==="eco"){
            const tag = document.createElement("div");
            tag.className = "node-eco-tag";
            tag.textContent = "üí∞";
            div.appendChild(tag);
          }

          div.addEventListener("click",()=>{
            selectedNodeId = key;
            selectedNode = node || null;
            renderBoard();
            renderNodeDetails();
          });

          boardGridEl.appendChild(div);
        }
      }
    }

    function appendMiniGrid(container, node){
      const bf = node.battlefield || {width:BATTLE_W,height:BATTLE_H,troops:[],towers:[],aliens:[],spines:[]};
      const troops = bf.troops || [];
      const towers = bf.towers || [];
      const aliens = bf.aliens || [];
      const spines = bf.spines || [];

      function getCell(x,y){
        const res = {troop:null,tower:null,alien:null,spine:null};
        res.troop = troops.find(t=>t.x===x && t.y===y) || null;
        res.tower = towers.find(t=>t.x===x && t.y===y) || null;
        res.alien = aliens.find(a=>a.x===x && a.y===y) || null;
        res.spine = spines.find(s=>s.x===x && s.y===y) || null;
        return res;
      }

      const grid = document.createElement("div");
      grid.className = "mini-grid";

      for(let y=0;y<BATTLE_H;y++){
        for(let x=0;x<BATTLE_W;x++){
          const cell = document.createElement("div");
          cell.className = "mini-grid-cell";

          if(x<=2) cell.classList.add("bg-player");
          else if(x>=BATTLE_W-3) cell.classList.add("bg-enemy");
          else cell.classList.add("bg-front");

          const {troop,tower,alien,spine} = getCell(x,y);
          let emoji = "";
          if(spine){
            emoji = "üåµ";
          }else if(tower){
            const def = TOWERS[tower.kind] || TOWERS.laser;
            emoji = def.emoji;
          }else if(troop){
            const def = TROOPS[troop.kind] || TROOPS.rifle;
            emoji = def.emoji;
          }
          if(alien){
            const def = ENEMIES[alien.type] || ENEMIES.bug;
            emoji = def.emoji;
          }
          cell.textContent = emoji;
          grid.appendChild(cell);
        }
      }

      container.appendChild(grid);
    }

    function renderNodeDetails(){
      if(!selectedNodeId || !selectedNode){
        nodeInfoEl.innerHTML = "<div>Select a node on the left.</div>";
        openBattleBtn.disabled = true;
        upgradeBaseBtn.disabled = true;
        return;
      }
      let html = "";
      html += `<div><strong>${selectedNode.type==="base" ? "Base Node" : selectedNode.type==="eco" ? "Eco Node" : "Node"} ${selectedNode.row+1}-${selectedNode.col+1}</strong></div>`;
      const ownerName =
        selectedNode.owner==="player" ? "You (controlled)" :
        selectedNode.owner==="enemy" ? "Aliens" :
        selectedNode.owner==="contested" ? "Contested" :
        "Neutral";
      html += `<div style="margin-top:4px;">Owner: <strong>${ownerName}</strong></div>`;

      if(selectedNode.type==="base"){
        const base = latestGame?.base || {};
        html += `<div style="margin-top:6px;">This node contains the <strong>central generator</strong>. Enemies that reach the left side of this battlefield damage the generator HP. Upgrading the generator increases credits per 5 seconds for all players.<br/>Next upgrade cost: <strong>${base.upgradeCost ?? 0}</strong> credits.</div>`;
      }else if(selectedNode.type==="eco"){
        html += `<div style="margin-top:6px;">This is an <strong>economic node</strong>. When it's <span style="color:#22c55e;">green</span> (your control), it adds bonus credits every income tick. Aliens would love to steal this.</div>`;
      }else if(selectedNode.owner==="player"){
        html += `<div style="margin-top:6px;">You can build defenses and troops here. Any node where you have structures and no aliens present remains <span style="color:#22c55e;">green</span>, letting you expand outward.</div>`;
      }else if(selectedNode.owner==="enemy"){
        html += `<div style="margin-top:6px;">Alien-controlled. They slowly amass <strong>spine nests</strong> and alien squads here over time. Clear them out and plant your defenses to claim it.</div>`;
      }else if(selectedNode.owner==="contested"){
        html += `<div style="margin-top:6px;">Aliens are actively assaulting this node. Expect waves of bugs from the right side of the battlefield, plus spine nests if this node is deep in alien lines.</div>`;
      }

      nodeInfoEl.innerHTML = html;
      appendMiniGrid(nodeInfoEl, selectedNode);

      openBattleBtn.disabled = false;

      if(selectedNode.type==="base"){
        upgradeBaseBtn.disabled = false;
      }else{
        upgradeBaseBtn.disabled = true;
      }
    }

    // ---------------- HOST ROLE / LOOP ----------------
    function syncHostRole(){
      if(!latestGame || !currentUser) return;
      const hostUid = latestGame.hostUid;
      const shouldBeHost = hostUid === currentUser.uid;
      if(shouldBeHost && !isHost){
        isHost = true;
        startHostLoop();
        log("You are host ‚Äî running Overlord simulation.");
      }else if(!shouldBeHost && isHost){
        isHost = false;
        stopHostLoop();
        log("Another player is host now.");
      }
    }

    function startHostLoop(){
      if(hostTickHandle) clearInterval(hostTickHandle);
      hostTickHandle = setInterval(()=>hostTick().catch(console.error), 1000);
    }
    function stopHostLoop(){
      if(hostTickHandle){
        clearInterval(hostTickHandle);
        hostTickHandle = null;
      }
    }

    async function hostTick(){
      if(!isHost || hostTicking) return;
      hostTicking = true;
      try{
        const gSnap = await getDoc(gameRef);
        if(!gSnap.exists()) { hostTicking=false; return; }
        const game = gSnap.data();
        if(game.status && game.status!=="running"){ hostTicking=false; return; }

        let timeSeconds = (game.timeSeconds || 0) + 1;
        const updates = { timeSeconds };

        // base HP check
        const base = game.base || {hp:0,maxHp:1,level:1,incomePerPlayer:0,upgradeCost:60};
        if(base.hp <= 0 && game.status!=="lost"){
          updates.status = "lost";
          await updateDoc(gameRef, updates);
          hostTicking=false;
          return;
        }
        if(timeSeconds >= game.winAtSeconds && game.status!=="won"){
          updates.status = "won";
        }

        // apply simple update first
        await updateDoc(gameRef, updates);
        latestGame = {...game,...updates};

        // Income tick
        if(timeSeconds % INCOME_INTERVAL === 0){
          await applyIncomeTick(latestGame);
        }

        // Spread tick
        if(timeSeconds % SPREAD_INTERVAL === 0){
          await applySpreadTick(latestGame);
        }

        // Enemy build-up tick
        if(timeSeconds % ENEMY_BUILD_INTERVAL === 0){
          await growEnemyForces(latestGame);
        }

        // Battle simulations per node
        await simulateBattles(latestGame);

      }catch(e){
        console.error("hostTick error", e);
      }
      hostTicking=false;
    }

    async function applyIncomeTick(game){
      const base = game.base || {incomePerPlayer:0};
      const baseIncome = base.incomePerPlayer || 0;

      // eco bonus based on number of eco nodes under player control
      let ecoCount = 0;
      for(const key in nodesState){
        const n = nodesState[key];
        if(!n) continue;
        if(n.type === "eco" && n.owner === "player") ecoCount++;
      }
      const ecoBonus = ecoCount * ECO_BONUS_PER_NODE;
      const income = baseIncome + ecoBonus;

      if(income <= 0) return;
      const playersSnap = await getDocs(collection(gameRef,"players"));
      const batchUpdates = [];
      for(const docSnap of playersSnap.docs){
        const p = docSnap.data();
        const extra = p.incomeBonus || 0;
        const money = (p.money||0) + income + extra;
        batchUpdates.push(updateDoc(docSnap.ref,{ money }));
      }
      await Promise.all(batchUpdates);
    }

    async function applySpreadTick(game){
      const nodeUpdates = [];

      for(const key in nodesState){
        const node = nodesState[key];
        if(!node) continue;
        if(node.owner==="enemy") continue;
        const {row,col} = node;
        const neighbors = neighborsOf(row,col);
        const hasEnemyNeighbor = neighbors.some(nk=>{
          const nn = nodesState[nk];
          return nn && nn.owner==="enemy";
        });
        if(!hasEnemyNeighbor) continue;

        let chance = typeof node.spreadChance === "number" ? node.spreadChance : 0.33;
        const roll = Math.random();
        const nodeRef = doc(nodesCol, key);

        if(roll < chance){
          // spread succeeds
          let newOwner = node.owner;
          let pendingWave = node.pendingWave || false;
          if(node.owner === "player"){
            newOwner = "contested";
            pendingWave = true; // wave will spawn on next battle sim
          }else if(node.owner === "neutral"){
            newOwner = "enemy";
          }else if(node.owner === "contested"){
            newOwner = "enemy";
          }
          node.owner = newOwner;
          node.spreadChance = 0.33;
          node.pendingWave = pendingWave;
          nodeUpdates.push(setDoc(nodeRef,{
            owner:newOwner,
            spreadChance:0.33,
            pendingWave
          },{merge:true}));
          log(`Alien influence spread into node ${row+1}-${col+1} (${newOwner}).`);
        }else{
          // fail -> increase chance up to cap
          chance = Math.min(0.95, chance + 0.15);
          node.spreadChance = chance;
          nodeUpdates.push(setDoc(nodeRef,{ spreadChance:chance },{merge:true}));
        }
      }

      if(nodeUpdates.length) await Promise.all(nodeUpdates);
    }

    // Helper to seed enemy spine towers
    function spawnSpine(bf, x, y, variant){
      const v = variant || "piercer";
      let maxHp = v==="piercer" ? 26 : 20;
      let dmg = v==="piercer" ? 5 : 1;
      let poisonTicks = v==="piercer" ? 6 : 2;
      const range = 3;

      bf.spines = bf.spines || [];
      bf.spines.push({
        id:`sp_${Date.now()}_${Math.random().toString(16).slice(2,6)}`,
        x,y,
        hp:maxHp,
        maxHp,
        range,
        dmg,
        poisonTicks,
        cooldown:0,
        cooldownMax:3,
        variant:v // "piercer" | "shredder"
      });
    }

    function ensureSpinesForEnemyNode(node,bf){
      bf.spines = bf.spines || [];
      if(bf.spines.length>0) return false;

      const mid = Math.floor(BATTLE_H/2);
      const x = BATTLE_W-3;
      const positions = [
        {x, y:mid-2},
        {x, y:mid},
        {x, y:mid+2}
      ].filter(p=>p.y>=1 && p.y<BATTLE_H-1);

      positions.forEach((p,i)=>{
        const variant = (i===1 ? "shredder" : "piercer");
        spawnSpine(bf, p.x, p.y, variant);
      });

      return true;
    }

    async function growEnemyForces(game){
      const timeSeconds = game.timeSeconds || 0;
      const minutes = timeSeconds / 60;
      const maxAliensBase = 4 + Math.floor(minutes * 3);    // scales with time
      const maxSpinesBase = 2 + Math.floor(minutes / 4);    // slow tower growth

      const batch = [];

      for(const key in nodesState){
        const node = nodesState[key];
        if(!node) continue;
        if(node.owner !== "enemy") continue;

        const bf = node.battlefield || {
          width:BATTLE_W,height:BATTLE_H,
          troops:[],towers:[],aliens:[],spines:[]
        };
        bf.aliens = bf.aliens || [];
        bf.spines = bf.spines || [];

        const maxAliens = Math.min(40, maxAliensBase);
        const maxSpines = Math.min(8, maxSpinesBase);

        let changed = false;

        // Build more aliens up to max
        if(bf.aliens.length < maxAliens){
          const deficit = maxAliens - bf.aliens.length;
          const spawnCount = Math.min(4 + Math.floor(minutes), deficit);
          for(let i=0;i<spawnCount;i++){
            const row = 1 + (i % (BATTLE_H-2));
            const x = BATTLE_W-1;
            let typeKey = "bug";
            if(minutes > 8){
              if(i%4===0) typeKey="behemoth";
              else if(i%3===0) typeKey="brute";
              else if(i%2===0) typeKey="spitter";
            }else if(minutes > 4){
              if(i%3===0) typeKey="brute";
              else if(i%2===0) typeKey="spitter";
            }else if(minutes > 2){
              if(i%2===0) typeKey="spitter";
            }
            const def = ENEMIES[typeKey];
            bf.aliens.push({
              id:"a_"+Date.now()+"_"+Math.random().toString(16).slice(2,6),
              x,
              y:row,
              type:typeKey,
              hp:def.baseHp,
              maxHp:def.baseHp
            });
          }
          changed = true;
        }

        // Build more spines up to max
        if(bf.spines.length < maxSpines){
          const needed = maxSpines - bf.spines.length;
          for(let i=0;i<needed;i++){
            // random lane near right side
            const x = BATTLE_W-3 - (i%2); // stagger slightly
            const y = 1 + Math.floor(Math.random()*(BATTLE_H-2));
            const variant = (Math.random()<0.5 ? "piercer" : "shredder");
            spawnSpine(bf,x,y,variant);
          }
          changed = true;
        }

        if(changed){
          const nodeRef = doc(nodesCol,key);
          batch.push(setDoc(nodeRef,{
            battlefield:bf
          },{merge:true}));
        }
      }

      if(batch.length) await Promise.all(batch);
    }

    async function simulateBattles(game){
      const timeSeconds = game.timeSeconds || 0;
      const batch = [];

      for(const key in nodesState){
        const node = nodesState[key];
        if(!node) continue;
        let changed = false;
        const bf = node.battlefield || {
          width:BATTLE_W, height:BATTLE_H,
          troops:[], towers:[], aliens:[], spines:[], hitLines:[]
        };

        // reset hitLines each simulation step
        bf.hitLines = [];

        // Ensure enemy nodes have spine towers
        if(node.owner==="enemy"){
          if(ensureSpinesForEnemyNode(node,bf)){
            changed = true;
          }
        }

        // Spawn pending wave on contested nodes
        if(node.owner==="contested" && node.pendingWave){
          spawnAlienWaveForNode(node, bf, timeSeconds);
          node.pendingWave = false;
          changed = true;
        }

        // Basic alien + defense simulation
        const hasPlayerStuff = (bf.troops && bf.troops.length) || (bf.towers && bf.towers.length);
        const hasAliens = (bf.aliens && bf.aliens.length) || (bf.spines && bf.spines.length);
        if(hasPlayerStuff || hasAliens){
          const result = simulateBattlefieldStep(node, bf, game);
          if(result.changed) changed = true;

          // if aliens reached base node left edge, damage generator
          if(result.baseDamage > 0 && node.type==="base"){
            const base = game.base || {hp:0};
            const newHp = Math.max(0, (base.hp||0) - result.baseDamage);
            await updateDoc(gameRef,{ "base.hp": newHp, status: newHp<=0 ? "lost" : game.status });
            game.base.hp = newHp;
            if(newHp<=0){
              log(`‚ö† Generator destroyed at base node. Game over for all players.`);
            }else{
              log(`‚ö† Generator took ${result.baseDamage} damage from aliens at base node.`);
            }
          }

          // capture / loss logic per node
          const anyPlayerStuff = (bf.troops && bf.troops.length) || (bf.towers && bf.towers.length);
          const anyAlienStuff = (bf.aliens && bf.aliens.length) || (bf.spines && bf.spines.length);

          if(node.owner==="contested"){
            if(!anyAlienStuff && anyPlayerStuff){
              node.owner = "player";
              changed = true;
              log(`‚úÖ Node ${node.row+1}-${node.col+1} held. Back to your control.`);
            }else if(!anyPlayerStuff && anyAlienStuff){
              node.owner = "enemy";
              changed = true;
              log(`‚ùå Node ${node.row+1}-${node.col+1} was overrun by aliens.`);
            }
          }else if(node.owner==="enemy"){
            if(anyPlayerStuff && !anyAlienStuff){
              node.owner = "player";
              changed = true;
              log(`‚öî You captured an enemy node (${node.row+1}-${node.col+1}).`);
            }
          }else if(node.owner==="player"){
            if(anyPlayerStuff && anyAlienStuff){
              node.owner = "contested";
              node.pendingWave = false;
              changed = true;
              log(`‚ö† Node ${node.row+1}-${node.col+1} is now contested.`);
            }
          }

          // special: if base node ever becomes enemy-controlled, game over
          if(node.type==="base" && node.owner==="enemy"){
            await updateDoc(gameRef,{ status:"lost", "base.hp":0 });
            log("‚ö† Aliens captured the base node. Game over for all players.");
          }
        }

        if(changed){
          const nodeRef = doc(nodesCol, key);
          batch.push(setDoc(nodeRef,{
            owner: node.owner,
            pendingWave: node.pendingWave || false,
            battlefield: bf
          },{merge:true}));
        }
      }

      if(batch.length) await Promise.all(batch);
    }

    function spawnAlienWaveForNode(node, bf, timeSeconds){
      const minutes = timeSeconds / 60;
      let tier = 1;
      if(minutes >= WAVE_MINUTES_2) tier = 3;
      else if(minutes >= WAVE_MINUTES_1) tier = 2;

      const waveSize = tier===1 ? 6 : tier===2 ? 10 : 14;

      bf.aliens = bf.aliens || [];
      for(let i=0;i<waveSize;i++){
        const row = 1 + (i % (BATTLE_H-2)); // avoid very top/bottom
        const x = BATTLE_W-1;
        let typeKey = "bug";

        if(tier===1){
          typeKey = (i%4===0) ? "spitter" : "bug";
        }else if(tier===2){
          if(i%3===0) typeKey = "spitter";
          else typeKey = "bug";
        }else{
          if(i===0 || (i===waveSize-1 && waveSize>8)){
            typeKey = "behemoth";
          }else if(i%3===0){
            typeKey = "brute";
          }else if(i%2===0){
            typeKey = "spitter";
          }else{
            typeKey = "bug";
          }
        }

        const def = ENEMIES[typeKey];
        bf.aliens.push({
          id: "a_"+Date.now()+"_"+Math.random().toString(16).slice(2,6),
          x,
          y:row,
          type:typeKey,
          hp:def.baseHp,
          maxHp:def.baseHp
        });
      }
      log(`Alien wave spawned in node ${node.row+1}-${node.col+1} (tier ${tier}).`);
    }

    function addHitLine(bf, kind, x1,y1,x2,y2){
      bf.hitLines = bf.hitLines || [];
      bf.hitLines.push({kind, x1,y1,x2,y2});
    }

    function simulateBattlefieldStep(node, bf, game){
      const aliens = bf.aliens || [];
      const troops = bf.troops || [];
      const towers = bf.towers || [];
      const spines = bf.spines || [];
      let changed = false;
      let baseDamage = 0;

      // Ongoing poison on troops
      for(const t of troops){
        if(t.poisonTicks && t.poisonTicks > 0){
          t.hp -= 1;
          t.poisonTicks--;
          changed = true;
        }
      }

      // Precompute synergy buffs
      const damageBuffMap = {}; // entity id -> scalar
      const shieldMap = {};     // entity id -> shieldScalar
      const entityById = {};

      for(const t of troops){ entityById[t.id] = t; }
      for(const tw of towers){ entityById[tw.id] = tw; }

      // Signal towers buff nearby damage
      for(const tw of towers){
        if(tw.kind!=="signal") continue;
        const def = TOWERS.signal;
        const buffRadius = def.range || 2;
        for(const id in entityById){
          const e = entityById[id];
          const dist = Math.abs(e.x - tw.x) + Math.abs(e.y - tw.y);
          if(dist <= buffRadius){
            damageBuffMap[id] = (damageBuffMap[id]||1) * 1.25;
          }
        }
      }
      // Sergeants buff troops
      for(const t of troops){
        if(t.kind!=="sergeant") continue;
        const radius = TROOPS.sergeant.range || 2;
        for(const tt of troops){
          const dist = Math.abs(tt.x - t.x) + Math.abs(tt.y - t.y);
          if(dist <= radius){
            damageBuffMap[tt.id] = (damageBuffMap[tt.id]||1) * 1.15;
          }
        }
      }
      // Shield towers reduce damage to allies
      for(const tw of towers){
        if(tw.kind!=="shield") continue;
        const radius = TOWERS.shield.range || 2;
        for(const id in entityById){
          const e = entityById[id];
          const dist = Math.abs(e.x - tw.x) + Math.abs(e.y - tw.y);
          if(dist <= radius){
            shieldMap[id] = (shieldMap[id]||1) * 0.65; // 35% damage taken
          }
        }
      }

      // Helper: nearest enemy (alien or spine)
      function nearestEnemyFrom(x,y,range){
        let best=null, bestD=999, bestType=null;
        for(const a of aliens){
          if(a.hp<=0) continue;
          const d = Math.abs(a.x-x)+Math.abs(a.y-y);
          if(d<=range && d<bestD){
            best=a; bestD=d; bestType="alien";
          }
        }
        for(const s of spines){
          if(s.hp<=0) continue;
          const d = Math.abs(s.x-x)+Math.abs(s.y-y);
          if(d<=range && d<bestD){
            best=s; bestD=d; bestType="spine";
          }
        }
        return best ? {type:bestType, enemy:best} : null;
      }

      // Troops
      for(const t of troops){
        if(t.hp<=0) continue;
        const def = TROOPS[t.kind] || TROOPS.rifle;
        if(t.kind==="medic"){
          // heal lowest HP ally within range
          let best=null, bestPct=1.1;
          for(const ally of troops){
            if(ally.hp<=0) continue;
            const d = Math.abs(ally.x - t.x)+Math.abs(ally.y - t.y);
            if(d <= (def.range || 2)){
              const pct = ally.hp/ally.maxHp;
              if(pct < bestPct){
                bestPct = pct;
                best = ally;
              }
            }
          }
          if(best && best.hp < best.maxHp){
            best.hp = Math.min(best.maxHp, best.hp + (def.heal||3));
            changed = true;
          }
        }else{
          const range = def.range || 2;
          const targetInfo = nearestEnemyFrom(t.x,t.y,range);
          if(targetInfo){
            let dmg = def.dmg || 2;
            const buff = damageBuffMap[t.id] || 1;
            dmg = Math.round(dmg * buff);
            if(def.splash){
              const tx = targetInfo.enemy.x;
              const ty = targetInfo.enemy.y;
              addHitLine(bf,"player",t.x,t.y,tx,ty);
              for(const a of aliens){
                const d = Math.abs(a.x - tx)+Math.abs(a.y - ty);
                if(d<=1) { a.hp -= dmg; changed=true; }
              }
              for(const s of spines){
                const d = Math.abs(s.x - tx)+Math.abs(s.y - ty);
                if(d<=1) { s.hp -= dmg; changed=true; }
              }
            }else{
              addHitLine(bf,"player",t.x,t.y,targetInfo.enemy.x,targetInfo.enemy.y);
              if(targetInfo.type==="alien"){
                targetInfo.enemy.hp -= dmg;
              }else{
                targetInfo.enemy.hp -= dmg;
              }
              changed = true;
            }
          }
        }
      }

      // Towers
      for(const tw of towers){
        const def = TOWERS[tw.kind] || TOWERS.laser;
        if(def.shield || def.buff) continue; // already handled via buffs / shields
        const range = def.range || 3;
        const targetInfo = nearestEnemyFrom(tw.x,tw.y,range);
        if(!targetInfo) continue;
        let dmg = def.dmg || 2;
        const buff = damageBuffMap[tw.id] || 1;
        dmg = Math.round(dmg * buff);
        if(def.chain){
          const tx = targetInfo.enemy.x;
          const ty = targetInfo.enemy.y;
          const chainTargets = [];
          for(const a of aliens){
            if(a.hp<=0) continue;
            const d = Math.abs(a.x - tx)+Math.abs(a.y - ty);
            if(d<=1) chainTargets.push({type:"alien", ref:a});
          }
          for(const s of spines){
            if(s.hp<=0) continue;
            const d = Math.abs(s.x - tx)+Math.abs(s.y - ty);
            if(d<=1) chainTargets.push({type:"spine", ref:s});
          }
          if(chainTargets.length===0){
            chainTargets.push({type:targetInfo.type, ref:targetInfo.enemy});
          }
          chainTargets.slice(0,3).forEach(tObj=>{
            addHitLine(bf,"player",tw.x,tw.y,tObj.ref.x,tObj.ref.y);
            tObj.ref.hp -= dmg;
          });
          changed = true;
        }else{
          addHitLine(bf,"player",tw.x,tw.y,targetInfo.enemy.x,targetInfo.enemy.y);
          targetInfo.enemy.hp -= dmg;
          changed = true;
        }
      }

      // Spine towers: attack troops & towers, variant-based
      for(const s of spines){
        if(s.hp<=0) continue;
        s.cooldown = (s.cooldown||0) - 1;
        if(s.cooldown > 0) continue;

        const range = s.range || 3;
        const variant = s.variant || "piercer";

        // collect all troops + towers in range
        const inRangeTroops = [];
        const inRangeTowers = [];
        for(const t of troops){
          if(t.hp<=0) continue;
          const d = Math.abs(t.x - s.x)+Math.abs(t.y - s.y);
          if(d <= range) inRangeTroops.push(t);
        }
        for(const tw of towers){
          if(tw.hp<=0) continue;
          const d = Math.abs(tw.x - s.x)+Math.abs(tw.y - s.y);
          if(d <= range) inRangeTowers.push(tw);
        }

        if(variant === "shredder"){
          let swung = false;
          const dmgLow = s.dmg || 1;
          for(const t of inRangeTroops){
            let finalDmg = dmgLow;
            const shield = shieldMap[t.id] || 1;
            finalDmg = Math.max(1, Math.round(finalDmg * shield));
            t.hp -= finalDmg;
            addHitLine(bf,"enemy",s.x,s.y,t.x,t.y);
            swung = true;
          }
          for(const tw of inRangeTowers){
            let finalDmg = dmgLow;
            const shield = shieldMap[tw.id] || 1;
            finalDmg = Math.max(1, Math.round(finalDmg * shield));
            tw.hp -= finalDmg;
            addHitLine(bf,"enemy",s.x,s.y,tw.x,tw.y);
            swung = true;
          }
          if(swung){
            s.cooldown = s.cooldownMax || 3;
            changed = true;
          }
        }else{
          // piercer: pick best target (troop or tower) and slam it
          let best=null, bestD=999, bestType=null;
          for(const t of inRangeTroops){
            const d = Math.abs(t.x - s.x)+Math.abs(t.y - s.y);
            if(d<bestD){ best=t; bestD=d; bestType="troop"; }
          }
          for(const tw of inRangeTowers){
            const d = Math.abs(tw.x - s.x)+Math.abs(tw.y - s.y);
            if(d<bestD){ best=tw; bestD=d; bestType="tower"; }
          }
          if(best){
            let finalDmg = s.dmg || 3;
            const shield = shieldMap[best.id] || 1;
            finalDmg = Math.max(1, Math.round(finalDmg * shield));
            best.hp -= finalDmg;
            if(bestType==="troop"){
              best.poisonTicks = Math.max(best.poisonTicks||0, s.poisonTicks || 5);
            }
            addHitLine(bf,"enemy",s.x,s.y,best.x,best.y);
            s.cooldown = s.cooldownMax || 3;
            changed = true;
          }
        }
      }

      // Remove dead aliens & spines
      for(const a of aliens){
        if(a.hp<=0){
          a.dead = true;
          changed = true;
        }
      }
      bf.aliens = aliens.filter(a=>!a.dead);

      for(const s of spines){
        if(s.hp<=0){
          s.dead = true;
          changed = true;
        }
      }
      bf.spines = spines.filter(s=>!s.dead);

      // Alien movement
      for(const a of bf.aliens){
        const newX = a.x-1;
        if(newX>=0){
          a.x = newX;
          changed = true;
        }else{
          if(node.type==="base"){
            baseDamage += ENEMIES[a.type]?.dmg || 2;
          }
          a.dead = true;
          changed = true;
        }
      }
      bf.aliens = bf.aliens.filter(a=>!a.dead);

      // Aliens damage adjacent troops or towers (melee)
      for(const a of bf.aliens){
        const def = ENEMIES[a.type] || ENEMIES.bug;
        const dmg = def.dmg || 2;
        let bestEntity=null, bestD=2, bestType=null;

        for(const t of troops){
          if(t.hp<=0) continue;
          const d = Math.abs(t.x - a.x)+Math.abs(t.y - a.y);
          if(d<=1 && d<bestD){ bestEntity=t; bestD=d; bestType="troop"; }
        }
        for(const tw of towers){
          if(tw.hp<=0) continue;
          const d = Math.abs(tw.x - a.x)+Math.abs(tw.y - a.y);
          if(d<=1 && d<bestD){ bestEntity=tw; bestD=d; bestType="tower"; }
        }

        if(bestEntity){
          const shield = shieldMap[bestEntity.id] || 1;
          let finalDmg = Math.max(1, Math.round(dmg * shield));
          bestEntity.hp -= finalDmg;
          addHitLine(bf,"enemy",a.x,a.y,bestEntity.x,bestEntity.y);
          changed = true;
        }
      }

      // Remove dead troops & towers
      for(const t of troops){
        if(t.hp<=0) t.dead=true;
      }
      bf.troops = troops.filter(t=>!t.dead);

      for(const tw of towers){
        if(tw.hp<=0) tw.dead=true;
      }
      bf.towers = towers.filter(tw=>!tw.dead);

      return {changed, baseDamage};
    }

    // ---------------- BATTLE UI ----------------
    function buildBattleBars(){
      // Troops
      troopBarEl.innerHTML = "";
      for(const key in TROOPS){
        const def = TROOPS[key];
        const pill = document.createElement("button");
        pill.type="button";
        pill.className = "build-pill";
        pill.dataset.type = def.key;
        pill.dataset.category = "troop";
        pill.innerHTML = `${def.emoji} ${def.name} <span style="opacity:.7;">(${def.cost})</span>`;
        pill.onclick = ()=>selectBuild(def.key,"troop");
        troopBarEl.appendChild(pill);
      }
      // Towers
      towerBarEl.innerHTML = "";
      for(const key in TOWERS){
        const def = TOWERS[key];
        const pill = document.createElement("button");
        pill.type="button";
        pill.className = "build-pill";
        pill.dataset.type = def.key;
        pill.dataset.category = "tower";
        pill.innerHTML = `${def.emoji} ${def.name} <span style="opacity:.7;">(${def.cost})</span>`;
        pill.onclick = ()=>selectBuild(def.key,"tower");
        towerBarEl.appendChild(pill);
      }
    }

    function selectBuild(type,category){
      currentBuild = {type,category};
      document.querySelectorAll(".build-pill").forEach(el=>{
        const t = el.dataset.type;
        const cat = el.dataset.category;
        el.classList.toggle("active", t===type && cat===category);
      });
    }

    function openBattleForNode(nodeId){
      if(!nodeId || !nodesState[nodeId]) return;
      selectedNodeId = nodeId;
      selectedNode = nodesState[nodeId];
      renderBoard();
      renderNodeDetails();

      if(battleUnsub) battleUnsub();
      const nodeRef = doc(nodesCol, nodeId);
      battleUnsub = onSnapshot(nodeRef,(snap)=>{
        if(!snap.exists()) return;
        const node = snap.data();
        nodesState[nodeId] = node;
        renderBattlefield(node);
      });

      buildBattleBars();
      const {row,col} = parseKey(nodeId);
      battleNodeLabel.textContent = (selectedNode.type==="base" ? "Base Node" : selectedNode.type==="eco" ? "Eco Node" : "Node") + ` ${row+1}-${col+1}`;
      updateBattleOwnerTag(selectedNode);
      battleOverlay.style.display = "flex";
    }

    function updateBattleOwnerTag(node){
      const owner = node.owner;
      battleOwnerTag.textContent =
        owner==="player" ? "Player-controlled" :
        owner==="enemy" ? "Alien-controlled" :
        owner==="contested" ? "Contested" :
        "Neutral";
      battleOwnerTag.className = "tag";
      if(owner==="player") battleOwnerTag.classList.add("tag-green");
      else if(owner==="enemy") battleOwnerTag.classList.add("tag-enemy");
      else if(owner==="contested") battleOwnerTag.classList.add("tag-base");
    }

    function renderBattlefield(node){
      const bf = node.battlefield || {width:BATTLE_W,height:BATTLE_H,troops:[],towers:[],aliens:[],spines:[],hitLines:[]};
      battleGridEl.innerHTML = "";
      const troops = bf.troops || [];
      const towers = bf.towers || [];
      const aliens = bf.aliens || [];
      const spines = bf.spines || [];

      function getCellContents(x,y){
        const res = {troop:null,tower:null,alien:null,spine:null};
        res.troop = troops.find(t=>t.x===x && t.y===y) || null;
        res.tower = towers.find(tw=>tw.x===x && tw.y===y) || null;
        res.alien = aliens.find(a=>a.x===x && a.y===y) || null;
        res.spine = spines.find(s=>s.x===x && s.y===y) || null;
        return res;
      }

      for(let y=0;y<BATTLE_H;y++){
        for(let x=0;x<BATTLE_W;x++){
          const cell = document.createElement("div");
          cell.className = "battle-cell";
          if(x<=2) cell.classList.add("battle-cell-bg-player");
          else if(x>=BATTLE_W-3) cell.classList.add("battle-cell-bg-enemy");
          else cell.classList.add("battle-cell-bg-frontline");

          const {troop,tower,alien,spine} = getCellContents(x,y);
          let emoji = "";
          let hp = null, maxHp = null;

          if(spine){
            emoji = "üåµ";
            hp = spine.hp;
            maxHp = spine.maxHp;
          }else if(tower){
            const def = TOWERS[tower.kind] || TOWERS.laser;
            emoji = def.emoji;
            hp = tower.hp;
            maxHp = tower.maxHp;
          }else if(troop){
            const def = TROOPS[troop.kind] || TROOPS.rifle;
            emoji = def.emoji;
            hp = troop.hp;
            maxHp = troop.maxHp;
          }
          if(alien){
            const def = ENEMIES[alien.type] || ENEMIES.bug;
            emoji = def.emoji;
            hp = alien.hp;
            maxHp = alien.maxHp;
          }

          if(emoji){
            cell.textContent = emoji;
          }else{
            cell.textContent = "";
          }

          if(hp != null && maxHp != null){
            const bar = document.createElement("div");
            bar.className = "hp-bar-mini";
            const fill = document.createElement("div");
            fill.className = "hp-bar-mini-fill";
            const pct = Math.max(0, Math.min(100, (hp/maxHp)*100));
            fill.style.width = pct + "%";
            bar.appendChild(fill);
            cell.appendChild(bar);
          }

          cell.addEventListener("click",()=>{
            onBattleCellClick(x,y,node);
          });

          battleGridEl.appendChild(cell);
        }
      }

      // Draw hitlines
      const wrap = battleGridEl.parentElement;
      if(wrap){
        wrap.querySelectorAll(".hitline-layer").forEach(el=>el.remove());
        const layer = document.createElement("div");
        layer.className = "hitline-layer";
        const lines = bf.hitLines || [];
        for(const l of lines){
          const lineEl = document.createElement("div");
          lineEl.className = "hitline " + (l.kind==="enemy" ? "enemy" : "player");

          const x1p = ((l.x1 + 0.5) / BATTLE_W) * 100;
          const y1p = ((l.y1 + 0.5) / BATTLE_H) * 100;
          const dx = (l.x2 - l.x1) / BATTLE_W;
          const dy = (l.y2 - l.y1) / BATTLE_H;
          const length = Math.sqrt(dx*dx + dy*dy) * 100;
          const angle = Math.atan2((l.y2 - l.y1),(l.x2 - l.x1)) * 180 / Math.PI;

          lineEl.style.left = x1p + "%";
          lineEl.style.top = y1p + "%";
          lineEl.style.width = Math.max(5,length) + "%";
          lineEl.style.transform = `translate(0,-50%) rotate(${angle}deg)`;

          layer.appendChild(lineEl);
        }
        wrap.appendChild(layer);
      }

      updateBattleOwnerTag(node);
    }

    async function onBattleCellClick(x,y,node){
      if(!currentBuild.type || !currentBuild.category){
        log("Select a troop or tower type first.");
        return;
      }
      if(x > 2){
        log("You can only place in the first 3 columns.");
        return;
      }
      if(!myPlayer){
        log("Player data not loaded yet.");
        return;
      }
      const cost =
        currentBuild.category==="troop" ? TROOPS[currentBuild.type].cost :
        TOWERS[currentBuild.type].cost;

      if((myPlayer.money || 0) < cost){
        log("Not enough credits.");
        return;
      }

      try{
        await runTransaction(db, async (tx)=>{
          const pSnap = await tx.get(playerRef);
          if(!pSnap.exists()) throw new Error("Player missing.");
          const p = pSnap.data();
          if((p.money||0) < cost) throw new Error("Not enough credits.");

          const nodeRef = doc(nodesCol, selectedNodeId);
          const nSnap = await tx.get(nodeRef);
          if(!nSnap.exists()) throw new Error("Node missing.");
          const n = nSnap.data();
          const bf = n.battlefield || {width:BATTLE_W,height:BATTLE_H,troops:[],towers:[],aliens:[],spines:[],hitLines:[]};

          const occupied =
            (bf.troops||[]).some(t=>t.x===x && t.y===y) ||
            (bf.towers||[]).some(tw=>tw.x===x && tw.y===y) ||
            (bf.spines||[]).some(s=>s.x===x && s.y===y);

          if(occupied) throw new Error("Cannot build on occupied tile.");

          if(currentBuild.category==="troop"){
            const def = TROOPS[currentBuild.type];
            bf.troops = bf.troops || [];
            bf.troops.push({
              id:"t_"+Date.now()+"_"+Math.random().toString(16).slice(2,6),
              x,y,
              kind:def.key,
              hp:def.baseHp,
              maxHp:def.baseHp
            });
          }else{
            const def = TOWERS[currentBuild.type];
            bf.towers = bf.towers || [];
            bf.towers.push({
              id:"tw_"+Date.now()+"_"+Math.random().toString(16).slice(2,6),
              x,y,
              kind:def.key,
              hp:18,
              maxHp:18
            });
          }

          tx.update(playerRef,{ money:(p.money||0)-cost });
          tx.set(nodeRef,{ battlefield:bf },{merge:true});
        });
        log(`Built ${currentBuild.category==="troop" ? TROOPS[currentBuild.type].name : TOWERS[currentBuild.type].name} at (${x+1},${y+1}).`);
      }catch(e){
        log("Build failed: "+e.message);
      }
    }

    // ---------------- UI BUTTONS ----------------
    openBattleBtn.addEventListener("click",()=>{
      if(!selectedNodeId) return;
      openBattleForNode(selectedNodeId);
    });

    leaveBattleBtn.addEventListener("click",()=>{
      battleOverlay.style.display = "none";
      if(battleUnsub){ battleUnsub(); battleUnsub=null; }
    });

    upgradeBaseBtn.addEventListener("click", async ()=>{
      if(!latestGame || !myPlayer) return;
      if(!selectedNode || selectedNode.type!=="base") return;
      try{
        await runTransaction(db, async (tx)=>{
          const gSnap = await tx.get(gameRef);
          const pSnap = await tx.get(playerRef);
          if(!gSnap.exists() || !pSnap.exists()) throw new Error("Missing game or player.");
          const g = gSnap.data();
          const p = pSnap.data();
          const base = g.base || {level:1,upgradeCost:60,incomePerPlayer:4};
          const cost = base.upgradeCost || 60;
          if((p.money||0) < cost) throw new Error("Not enough credits for upgrade.");
          const newLevel = (base.level||1)+1;
          const newIncome = (base.incomePerPlayer||4) + 3;
          const newCost = Math.round(cost*1.7);
          tx.update(playerRef,{ money: (p.money||0)-cost });
          tx.update(gameRef,{
            base:{
              ...base,
              level:newLevel,
              incomePerPlayer:newIncome,
              upgradeCost:newCost
            }
          });
        });
        log("‚ö° Generator upgraded. All players gain more credits per tick.");
      }catch(e){
        log("Upgrade failed: "+e.message);
      }
    });

    document.getElementById("fullscreenBtn").addEventListener("click",()=>{
      const el = document.documentElement;
      if(!document.fullscreenElement){
        el.requestFullscreen?.();
      }else{
        document.exitFullscreen?.();
      }
    });

    // ---------------- INIT ----------------
    log("Connecting to Firebase and waiting for authentication‚Ä¶");
  </script>
</body>
</html>











