<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>üõ∞Ô∏è Grid Overlord ‚Äî Co-op Node Defense</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
  <style>
    :root{
      --bg:#020617;
      --panel:#0b1120;
      --ink:#e5e7eb;
      --muted:#9ca3af;
      --accent:#38bdf8;
      --accent-soft:#0ea5e9;
      --danger:#ef4444;
      --enemy:#b91c1c;
      --player:#16a34a;
      --contested:#facc15;
      --neutral:#4b5563;
      --radius:14px;
      --shadow:0 18px 40px rgba(0,0,0,.7);
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color:transparent;}
    html,body{
      margin:0;
      padding:0;
      height:100%;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      background:radial-gradient(circle at top,#0f172a 0,#020617 55%);
      color:var(--ink);
      overflow:hidden;
    }
    body{
      display:flex;
      flex-direction:column;
      align-items:center;
    }
    .shell{
      flex:1;
      display:flex;
      flex-direction:column;
      width:100%;
      max-width:1200px;
      padding:8px 8px calc(8px + env(safe-area-inset-bottom));
      gap:8px;
    }
    .top-bar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      padding:8px 12px;
      border-radius:var(--radius);
      background:rgba(15,23,42,.95);
      border:1px solid #1f2937;
      box-shadow:var(--shadow);
      font-size:.9rem;
    }
    .top-left,.top-right{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .game-title{
      display:flex;
      align-items:center;
      gap:6px;
      font-weight:700;
    }
    .pill{
      border-radius:999px;
      border:1px solid #1f2937;
      padding:4px 10px;
      background:rgba(15,23,42,.95);
      display:inline-flex;
      align-items:center;
      gap:6px;
      font-size:.78rem;
      color:var(--muted);
    }
    .pill strong{color:var(--ink); font-weight:600;}

    .hp-bar{
      position:relative;
      width:90px;
      height:8px;
      border-radius:999px;
      background:#020617;
      overflow:hidden;
      border:1px solid #1f2937;
    }
    .hp-fill{
      position:absolute;
      inset:0;
      background:linear-gradient(90deg,#16a34a,#facc15,#ef4444);
      width:100%;
      transition:width .18s linear;
    }

    .main{
      flex:1;
      display:flex;
      gap:8px;
      min-height:0;
    }
    @media (max-width:900px){
      .main{flex-direction:column;}
    }

    .panel{
      border-radius:var(--radius);
      background:rgba(15,23,42,.96);
      border:1px solid #1f2937;
      box-shadow:var(--shadow);
      padding:10px;
      min-height:0;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .panel-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:.85rem;
      color:var(--muted);
    }

    .board-panel{
      flex:1.1;
    }
    .side-panel{
      flex:0.9;
      min-width:260px;
    }

    .board-grid{
      flex:1;
      display:grid;
      grid-template-columns:repeat(7, minmax(0,1fr));
      grid-auto-rows:minmax(40px,1fr);
      gap:4px;
      padding:4px;
    }
    .node-cell{
      border-radius:12px;
      border:1px solid #1f2937;
      background:#020617;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      font-size:.8rem;
      cursor:pointer;
      position:relative;
      overflow:hidden;
      transition:transform .08s ease, box-shadow .08s ease, border-color .1s ease;
    }
    .node-cell span{pointer-events:none;}
    .node-owner{
      font-size:.72rem;
      opacity:.85;
    }
    .node-cell:hover{
      transform:translateY(-1px);
      box-shadow:0 8px 18px rgba(0,0,0,.7);
      border-color:var(--accent-soft);
    }
    .node-base-tag,
    .node-eco-tag{
      position:absolute;
      top:4px;
      left:6px;
      font-size:.75rem;
      opacity:.9;
    }

    .node-player{
      background:radial-gradient(circle at top,#15803d,#022c22);
      border-color:#16a34a;
    }
    .node-enemy{
      background:radial-gradient(circle at top,#7f1d1d,#020617);
      border-color:#b91c1c;
    }
    .node-neutral{
      background:radial-gradient(circle at top,#374151,#020617);
      border-color:#4b5563;
    }
    .node-contested{
      background:radial-gradient(circle at top,#facc15,#451a03);
      border-color:#facc15;
      color:#111827;
    }
    .node-selected{
      box-shadow:0 0 0 2px var(--accent-soft);
    }

    .btn{
      border-radius:999px;
      border:1px solid #1f2937;
      background:#020617;
      padding:6px 10px;
      font-size:.8rem;
      color:var(--ink);
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:4px;
    }
    .btn[disabled]{
      opacity:.4;
      cursor:default;
    }
    .btn-primary{
      border-color:var(--accent-soft);
      background:linear-gradient(135deg,#0ea5e9,#22c55e);
      color:#0f172a;
      font-weight:600;
    }

    .node-info-box{
      flex:1;
      min-height:80px;
      border-radius:10px;
      border:1px solid #1f2937;
      background:#020617;
      padding:6px 8px;
      font-size:.78rem;
      color:var(--muted);
      overflow:auto;
    }

    .log-box{
      height:120px;
      border-radius:10px;
      border:1px solid #1f2937;
      background:#020617;
      padding:6px 8px;
      font-size:.75rem;
      color:var(--muted);
      overflow:auto;
    }
    .log-line{margin-bottom:2px;}

    /* Mini battlefield preview in node details */
    .mini-grid{
      margin-top:6px;
      display:grid;
      grid-template-columns:repeat(10, minmax(0,1fr));
      gap:1px;
      padding:4px;
      border-radius:8px;
      background:#020617;
      border:1px solid #1f2937;
      max-width:220px;
    }
    .mini-grid-cell{
      width:100%;
      aspect-ratio:1/1;
      border-radius:3px;
      background:#030712;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:.65rem;
      color:#e5e7eb;
      opacity:.9;
    }
    .mini-grid-cell.bg-player{ background:#052e16; }
    .mini-grid-cell.bg-enemy{ background:#43171f; }
    .mini-grid-cell.bg-front{ background:#020617; }

    /* Battle overlay */
    .overlay{
      position:fixed;
      inset:0;
      background:rgba(15,23,42,.96);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:40;
    }
    .overlay-inner{
      width:min(1020px, 100vw - 12px);
      height:min(620px, 100vh - 16px);
      border-radius:var(--radius);
      border:1px solid #1f2937;
      background:radial-gradient(circle at top,#020617,#020617);
      box-shadow:var(--shadow);
      padding:8px;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .battle-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:.85rem;
      color:var(--muted);
    }
    .battle-main{
      flex:1;
      display:flex;
      gap:6px;
      min-height:0;
    }
    .battle-grid-wrap{
      flex:1;
      border-radius:12px;
      border:1px solid #1f2937;
      background:#020617;
      padding:4px;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      overflow:hidden;
    }
    .battle-grid{
      display:grid;
      grid-template-columns:repeat(10, minmax(0,1fr));
      grid-auto-rows:minmax(0,1fr);
      gap:2px;
      width:100%;
      max-width:520px;
      aspect-ratio:1/1;
      position:relative;
      z-index:1;
    }
    .battle-cell{
      border-radius:4px;
      background:#020617;
      border:1px solid #111827;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:1.1rem;
      position:relative;
      cursor:pointer;
      overflow:hidden;
    }
    .battle-cell-bg-player{
      background:#022c22;
    }
    .battle-cell-bg-enemy{
      background:#111827;
    }
    .battle-cell-bg-frontline{
      background:#1e293b;
    }
    .battle-cell .hp-bar-mini{
      position:absolute;
      bottom:1px;
      left:2px;
      right:2px;
      height:3px;
      border-radius:999px;
      background:#020617;
      overflow:hidden;
    }
    .battle-cell .hp-bar-mini-fill{
      height:100%;
      background:linear-gradient(90deg,#22c55e,#f97316,#ef4444);
      width:100%;
    }

    /* Hitline overlay */
    .hitline-layer{
      position:absolute;
      inset:4px;
      pointer-events:none;
      z-index:2;
    }
    .hitline{
      position:absolute;
      height:2px;
      background:rgba(148,163,184,.85);
      transform-origin:0 50%;
      opacity:.9;
    }
    .hitline.player{
      background:rgba(56,189,248,.9);
    }
    .hitline.enemy{
      background:rgba(248,113,113,.9);
    }

    .battle-side{
      width:220px;
      border-radius:12px;
      border:1px solid #1f2937;
      background:#020617;
      padding:6px;
      font-size:.78rem;
      display:flex;
      flex-direction:column;
      gap:4px;
      color:var(--muted);
    }

    .build-bar{
      display:flex;
      flex-wrap:wrap;
      gap:4px;
      padding:4px;
      border-radius:999px;
      border:1px solid #1f2937;
      background:rgba(15,23,42,.95);
      font-size:.76rem;
      align-items:center;
    }
    .build-pill{
      border-radius:999px;
      border:1px solid #1f2937;
      padding:3px 7px;
      display:inline-flex;
      align-items:center;
      gap:4px;
      cursor:pointer;
      background:#020617;
      color:var(--muted);
    }
    .build-pill.active{
      border-color:var(--accent-soft);
      color:var(--ink);
      background:radial-gradient(circle at top,#0ea5e9,#22c55e);
    }

    .tag{
      border-radius:999px;
      padding:2px 6px;
      border:1px solid #1f2937;
      font-size:.7rem;
      display:inline-flex;
      align-items:center;
      gap:4px;
    }
    .tag-base{border-color:var(--accent); color:var(--accent);}
    .tag-enemy{border-color:var(--danger); color:var(--danger);}
    .tag-green{border-color:var(--player); color:var(--player);}

    .small{
      font-size:.76rem;
      color:var(--muted);
    }
  </style>
</head>
<body>
  <div class="shell">
    <div class="top-bar">
      <div class="top-left">
        <div class="game-title">
          üõ∞Ô∏è <span>Grid Overlord</span>
        </div>
        <div class="pill">
          <span>Player:</span> <strong id="playerNameLabel">‚Ä¶</strong>
        </div>
        <div class="pill">
          <span>Time:</span> <strong id="timeLabel">0:00</strong>
        </div>
        <div class="pill">
          <span>Credits:</span> <strong id="moneyLabel">0</strong>
        </div>
      </div>
      <div class="top-right">
        <div class="pill">
          <span>Base</span>
          <div class="hp-bar">
            <div id="baseHpFill" class="hp-fill"></div>
          </div>
        </div>
        <button class="btn" id="fullscreenBtn">‚õ∂ Fullscreen</button>
      </div>
    </div>

    <div class="main">
      <div class="panel board-panel">
        <div class="panel-header">
          <span>Galaxy Map ‚Äî Control Nodes</span>
          <span class="small">
            Green = Only you ¬∑ Red = Only aliens ¬∑ Yellow = Both ¬∑ Grey = Empty ¬∑ üí∞ = Eco
          </span>
        </div>
        <div id="boardGrid" class="board-grid"></div>
      </div>

      <div class="panel side-panel">
        <div class="panel-header">
          <span>Node Details</span>
        </div>
        <div id="nodeInfo" class="node-info-box">
          <div>Select a node on the left to inspect or enter its battlefield.</div>
        </div>
        <div style="display:flex;gap:6px;margin-top:4px;">
          <button id="openBattleBtn" class="btn btn-primary" disabled>Enter Area</button>
          <button id="upgradeBaseBtn" class="btn" disabled>Upgrade Generator</button>
        </div>
        <div id="baseInfo" class="small" style="margin-top:6px;display:none;">
          Generator Lv <span id="baseLevelLabel">1</span> ¬∑ +<span id="incomeLabel">0</span> base credits / 5s per player (plus eco bonuses) ¬∑ Next upgrade: <span id="baseUpgradeCostLabel">0</span>
        </div>

        <div style="margin-top:8px;font-size:.78rem;color:var(--muted);">
          <strong>How it works:</strong><br/>
          - Aliens expand every 45s from red tiles into neighbors, flagging waves in nearby nodes.<br/>
          - Some nodes are economic (üí∞). When green, they boost credits each income tick.<br/>
          - Enemy nodes (red) stockpile aliens and spine nests over time.<br/>
          - Zone color is based only on who is present:<br/>
          &nbsp;&nbsp;‚Ä¢ Green = only your troops/towers (including üîã generator)<br/>
          &nbsp;&nbsp;‚Ä¢ Red = only aliens/spines<br/>
          &nbsp;&nbsp;‚Ä¢ Yellow = both sides<br/>
          &nbsp;&nbsp;‚Ä¢ Grey = nobody present<br/>
          - The base node has a üîã generator at the back. If aliens destroy it, everyone loses.
        </div>

        <div class="log-box" id="logBox"></div>
      </div>
    </div>
  </div>

  <!-- Battle Overlay -->
  <div id="battleOverlay" class="overlay" style="display:none;">
    <div class="overlay-inner">
      <div class="battle-header">
        <div>
          <span id="battleNodeLabel">Node</span>
          <span id="battleOwnerTag" class="tag tag-green" style="margin-left:6px;">Player</span>
        </div>
        <div style="display:flex;align-items:center;gap:6px;">
          <span class="small">Build only in the first 3 columns.</span>
          <button id="leaveBattleBtn" class="btn">‚¨Ö Leave</button>
        </div>
      </div>
      <div class="battle-main">
        <div class="battle-grid-wrap">
          <div id="battleGrid" class="battle-grid"></div>
        </div>
        <div class="battle-side">
          <div><strong>Troops</strong></div>
          <div class="build-bar" id="troopBar"></div>
          <div style="margin-top:4px;"><strong>Towers</strong></div>
          <div class="build-bar" id="towerBar"></div>
          <div style="margin-top:4px;font-size:.76rem;">
            <div>Click a type, then click a tile in the first 3 columns to place it.</div>
            <div style="margin-top:4px;">
              <span class="tag tag-base">Base node</span> has the üîã generator at the far left. If aliens destroy it, the run ends.
            </div>
          </div>
          <div style="margin-top:4px;font-size:.76rem;">
            <strong>Synergies:</strong><br/>
            - üßë‚Äç‚öïÔ∏è Medics heal nearby allies.<br/>
            - ‚≠ê Sergeants boost troop damage near them.<br/>
            - üõ°Ô∏è Shield towers reduce damage taken near them.<br/>
            - üì° Signal towers empower nearby units & towers.<br/>
            - ‚ö° Tesla towers chain lightning between aliens.<br/>
            - üåµ Piercer nests focus high damage on one target.<br/>
            - üåµ Shredder nests chip all targets in range.
          </div>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    // ---------------- FIREBASE SETUP ----------------
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import {
      getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot,
      collection, runTransaction, serverTimestamp, getDocs
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
    import {
      getAuth, signInAnonymously, onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

    const firebaseConfig = {
      apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
      authDomain: "bible-game-246c0.firebaseapp.com",
      projectId: "bible-game-246c0",
      storageBucket: "bible-game-246c0.appspot.com",
      messagingSenderId: "959619818996",
      appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
    };
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    // ---------------- CONFIG ----------------
    const BOARD_SIZE = 7;
    const BATTLE_W = 10;
    const BATTLE_H = 10;
    const SPREAD_INTERVAL = 45;
    const INCOME_INTERVAL = 5;
    const ENEMY_BUILD_INTERVAL = 30;
    const WAVE_MINUTES_1 = 5;
    const WAVE_MINUTES_2 = 10;
    const GAME_WIN_TIME = 20 * 60;
    const ECO_BONUS_PER_NODE = 1;

    const params = new URLSearchParams(window.location.search);
    const gameId = params.get("gameId") || "dev-overlord";
    const displayName = (params.get("username") || "Guest").trim() || "Guest";

    const gameRef = doc(db, "grid_overlord_games", gameId);
    const nodesCol = collection(gameRef, "nodes");

    const TROOPS = {
      rifle:   { key:"rifle",   name:"Rifleman",      emoji:"üî´", baseHp:12, dmg:3, range:3, cost:8 },
      phase:   { key:"phase",   name:"Phase Blade",   emoji:"üó°Ô∏è", baseHp:18, dmg:4, range:1, cost:10 },
      bomber:  { key:"bomber",  name:"Photon Bomber", emoji:"üí£", baseHp:10, dmg:3, range:3, splash:true, cost:12 },
      medic:   { key:"medic",   name:"Medic",         emoji:"üßë‚Äç‚öïÔ∏è", baseHp:10, heal:3, range:2, cost:10 },
      sergeant:{ key:"sergeant",name:"Space Sergeant",emoji:"‚≠ê", baseHp:14, dmg:2, range:2, buff:true, cost:14 },
      sniper:  { key:"sniper",  name:"Ion Sniper",    emoji:"üéØ", baseHp:8,  dmg:5, range:5, cost:14 }
    };

    const TOWERS = {
      laser:  { key:"laser",  name:"Laser Tower",  emoji:"üî∫", dmg:4, range:4, cost:14 },
      tesla:  { key:"tesla",  name:"Tesla Coil",   emoji:"‚ö°", dmg:3, range:3, chain:true, cost:16 },
      shield: { key:"shield", name:"Shield Tower", emoji:"üõ°Ô∏è", range:2, shield:true, cost:12 },
      signal: { key:"signal", name:"Signal Tower", emoji:"üì°", range:2, buff:true, cost:16 }
    };

    const ENEMIES = {
      bug:      { key:"bug",      emoji:"üêú", baseHp:10, dmg:2, speed:1 },
      spitter:  { key:"spitter",  emoji:"ü™≤", baseHp:14, dmg:3, speed:1 },
      brute:    { key:"brute",    emoji:"ü¶Ç", baseHp:26, dmg:5, speed:1 },
      behemoth: { key:"behemoth", emoji:"üëæ", baseHp:40, dmg:6, speed:1 }
    };

    // ---------------- STATE ----------------
    let currentUser = null;
    let playerRef = null;
    let myPlayer = null;
    let latestGame = null;
    let nodesState = {};
    let isHost = false;
    let hostTickHandle = null;
    let hostTicking = false;

    let selectedNodeId = null;
    let selectedNode = null;
    let currentBuild = { type:null, category:null };
    let battleUnsub = null;

    // ---------------- DOM ----------------
    const playerNameLabel = document.getElementById("playerNameLabel");
    const timeLabel = document.getElementById("timeLabel");
    const moneyLabel = document.getElementById("moneyLabel");
    const baseHpFill = document.getElementById("baseHpFill");
    const boardGridEl = document.getElementById("boardGrid");
    const nodeInfoEl = document.getElementById("nodeInfo");
    const logBoxEl = document.getElementById("logBox");
    const openBattleBtn = document.getElementById("openBattleBtn");
    const upgradeBaseBtn = document.getElementById("upgradeBaseBtn");
    const baseInfoEl = document.getElementById("baseInfo");
    const baseLevelLabel = document.getElementById("baseLevelLabel");
    const incomeLabel = document.getElementById("incomeLabel");
    const baseUpgradeCostLabel = document.getElementById("baseUpgradeCostLabel");

    const battleOverlay = document.getElementById("battleOverlay");
    const battleNodeLabel = document.getElementById("battleNodeLabel");
    const battleOwnerTag = document.getElementById("battleOwnerTag");
    const battleGridEl = document.getElementById("battleGrid");
    const troopBarEl = document.getElementById("troopBar");
    const towerBarEl = document.getElementById("towerBar");
    const leaveBattleBtn = document.getElementById("leaveBattleBtn");

    // ---------------- UTILS ----------------
    function log(msg){
      if(!logBoxEl) return;
      const div = document.createElement("div");
      div.className = "log-line";
      div.textContent = msg;
      logBoxEl.appendChild(div);
      logBoxEl.scrollTop = logBoxEl.scrollHeight;
      console.log("[GRID]", msg);
    }
    function nodeKey(row,col){ return `${row}_${col}`; }
    function parseKey(key){
      const [r,c]=key.split("_").map(Number);
      return {row:r,col:c};
    }
    function formatTime(sec){
      sec = Math.max(0, Math.floor(sec||0));
      const m = Math.floor(sec/60);
      const s = sec % 60;
      return `${m}:${s.toString().padStart(2,"0")}`;
    }
    function neighborsOf(row,col){
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      const out=[];
      for(const [dr,dc] of dirs){
        const nr = row+dr, nc = col+dc;
        if(nr>=0 && nr<BOARD_SIZE && nc>=0 && nc<BOARD_SIZE){
          out.push(nodeKey(nr,nc));
        }
      }
      return out;
    }

    // ---------------- AUTH / JOIN ----------------
    let joined = false;
    signInAnonymously(auth).catch(err=>{
      console.error(err);
      alert("Failed to sign in anonymously to Firebase: "+err.message);
    });

    onAuthStateChanged(auth, async (user)=>{
      if(!user) return;
      currentUser = user;
      if(joined) return;
      joined = true;
      playerRef = doc(gameRef,"players",user.uid);
      playerNameLabel.textContent = displayName;
      await joinGame();
    });

    async function joinGame(){
      try{
        await runTransaction(db, async (tx)=>{
          const center = Math.floor(BOARD_SIZE/2);

          const gameSnap = await tx.get(gameRef);
          const isNewGame = !gameSnap.exists();
          const gameData = isNewGame ? null : gameSnap.data();
          const playerSnap = await tx.get(playerRef);

          if(isNewGame){
            const baseHp = 120;
            const baseLevel = 1;
            const baseIncomePerPlayer = 4; // lowered income
            tx.set(gameRef,{
              createdAt: serverTimestamp(),
              hostUid: currentUser.uid,
              status:"running",
              timeSeconds:0,
              base:{
                hp:baseHp,
                maxHp:baseHp,
                level:baseLevel,
                incomePerPlayer:baseIncomePerPlayer,
                upgradeCost:60
              },
              winAtSeconds: GAME_WIN_TIME
            });

            for(let r=0;r<BOARD_SIZE;r++){
              for(let c=0;c<BOARD_SIZE;c++){
                const id = nodeKey(r,c);
                const manhattan = Math.abs(r-center)+Math.abs(c-center);
                let owner;
                if(r===center && c===center){
                  owner = "player";
                }else if(manhattan === 1){
                  owner = "player";
                }else if(
                  (r===0 && (c===1 || c===BOARD_SIZE-2)) ||
                  (r===BOARD_SIZE-1 && (c===1 || c===BOARD_SIZE-2)) ||
                  (c===0 && (r===1 || r===BOARD_SIZE-2)) ||
                  (c===BOARD_SIZE-1 && (r===1 || r===BOARD_SIZE-2))
                ){
                  owner = "enemy";
                }else{
                  owner = "neutral";
                }

                let type = "normal";
                if(r===center && c===center) type = "base";
                else if(manhattan === 2) type = "eco";

                const nodeDocRef = doc(nodesCol, id);

                const battlefield = {
                  width:BATTLE_W,
                  height:BATTLE_H,
                  troops:[],
                  towers:[],
                  aliens:[],
                  spines:[],
                  hitLines:[]
                };

                if(type === "base"){
                  const midY = Math.floor(BATTLE_H/2);
                  battlefield.towers.push({
                    id:"generator",
                    x:0,
                    y:midY,
                    kind:"generator",
                    hp:baseHp,
                    maxHp:baseHp
                  });
                }

                tx.set(nodeDocRef,{
                  id,
                  row:r,
                  col:c,
                  owner,
                  type,
                  spreadChance:0.33,
                  pendingWave:false,
                  battlefield
                });
              }
            }
          }else{
            if(!gameData.hostUid){
              tx.update(gameRef,{hostUid: currentUser.uid});
            }
          }

          if(!playerSnap.exists()){
            tx.set(playerRef,{
              uid: currentUser.uid,
              name: displayName,
              money: 30,
              incomeBonus: 0,
              joinedAt: serverTimestamp()
            });
          }else{
            tx.update(playerRef,{ name: displayName });
          }
        });

        onSnapshot(gameRef, (snap)=>{
          if(!snap.exists()) return;
          latestGame = snap.data();
          renderGameMeta();
          syncHostRole();
        });

        onSnapshot(nodesCol, (snap)=>{
          nodesState = {};
          snap.forEach(d=>{ nodesState[d.id]=d.data(); });
          renderBoard();
          if(selectedNodeId){
            selectedNode = nodesState[selectedNodeId] || null;
            renderNodeDetails();
          }
        });

        onSnapshot(playerRef, (snap)=>{
          if(!snap.exists()) return;
          myPlayer = snap.data();
          moneyLabel.textContent = Math.floor(myPlayer.money || 0);
        });

        log("Joined game: "+gameId);
      }catch(e){
        console.error(e);
        alert("Error joining game: "+e.message);
      }
    }

    // ---------------- RENDER META ----------------
    function renderGameMeta(){
      if(!latestGame) return;
      const sec = latestGame.timeSeconds || 0;
      timeLabel.textContent = formatTime(sec);

      const base = latestGame.base || {hp:0,maxHp:1,level:1,incomePerPlayer:0,upgradeCost:0};
      const hp = Math.max(0, base.hp || 0);
      const max = Math.max(1, base.maxHp || 1);
      const pct = Math.max(0, Math.min(100, (hp/max)*100));
      baseHpFill.style.width = pct + "%";

      baseInfoEl.style.display = "block";
      baseLevelLabel.textContent = base.level ?? 1;
      incomeLabel.textContent = base.incomePerPlayer ?? 0;
      baseUpgradeCostLabel.textContent = base.upgradeCost ?? 0;

      if(latestGame.status === "lost"){
        log("‚ö† Base destroyed. Game over for all players.");
      }else if(latestGame.status === "won"){
        log("‚úÖ You survived the full duration! Victory.");
      }
    }

    // ---------------- RENDER BOARD ----------------
    function renderBoard(){
      if(!boardGridEl) return;
      boardGridEl.innerHTML = "";
      const center = Math.floor(BOARD_SIZE/2);

      for(let r=0;r<BOARD_SIZE;r++){
        for(let c=0;c<BOARD_SIZE;c++){
          const key = nodeKey(r,c);
          const node = nodesState[key];
          const div = document.createElement("div");
          div.className = "node-cell";
          if(node){
            if(node.owner==="player") div.classList.add("node-player");
            else if(node.owner==="enemy") div.classList.add("node-enemy");
            else if(node.owner==="neutral") div.classList.add("node-neutral");
            else if(node.owner==="contested") div.classList.add("node-contested");
            if(key===selectedNodeId) div.classList.add("node-selected");
          }

          const title = document.createElement("span");
          title.textContent =
            (r===center && c===center) ? "Base" :
            (node && node.type==="eco") ? "Eco" :
            `Node ${r+1}-${c+1}`;
          div.appendChild(title);

          const ownerSpan = document.createElement("span");
          ownerSpan.className = "node-owner";
          ownerSpan.textContent = node ? (
            node.owner==="player" ? "You" :
            node.owner==="enemy" ? "Aliens" :
            node.owner==="contested" ? "Contested" :
            "Neutral"
          ) : "‚Ä¶";
          div.appendChild(ownerSpan);

          if(node && node.type==="base"){
            const tag = document.createElement("div");
            tag.className = "node-base-tag";
            tag.textContent = "üîã";
            div.appendChild(tag);
          }else if(node && node.type==="eco"){
            const tag = document.createElement("div");
            tag.className = "node-eco-tag";
            tag.textContent = "üí∞";
            div.appendChild(tag);
          }

          div.addEventListener("click",()=>{
            selectedNodeId = key;
            selectedNode = node || null;
            renderBoard();
            renderNodeDetails();
          });

          boardGridEl.appendChild(div);
        }
      }
    }

    function appendMiniGrid(container, node){
      const bf = node.battlefield || {width:BATTLE_W,height:BATTLE_H,troops:[],towers:[],aliens:[],spines:[]};
      const troops = bf.troops || [];
      const towers = bf.towers || [];
      const aliens = bf.aliens || [];
      const spines = bf.spines || [];

      function getCell(x,y){
        const res = {troop:null,tower:null,alien:null,spine:null};
        res.troop = troops.find(t=>t.x===x && t.y===y) || null;
        res.tower = towers.find(t=>t.x===x && t.y===y) || null;
        res.alien = aliens.find(a=>a.x===x && a.y===y) || null;
        res.spine = spines.find(s=>s.x===x && s.y===y) || null;
        return res;
      }

      const grid = document.createElement("div");
      grid.className = "mini-grid";

      for(let y=0;y<BATTLE_H;y++){
        for(let x=0;x<BATTLE_W;x++){
          const cell = document.createElement("div");
          cell.className = "mini-grid-cell";

          if(x<=2) cell.classList.add("bg-player");
          else if(x>=BATTLE_W-3) cell.classList.add("bg-enemy");
          else cell.classList.add("bg-front");

          const {troop,tower,alien,spine} = getCell(x,y);
          let emoji = "";
          if(spine){
            emoji = "üåµ";
          }else if(tower){
            if(tower.kind === "generator"){
              emoji = "üîã";
            }else{
              const def = TOWERS[tower.kind] || TOWERS.laser;
              emoji = def.emoji;
            }
          }else if(troop){
            const def = TROOPS[troop.kind] || TROOPS.rifle;
            emoji = def.emoji;
          }
          if(alien){
            const def = ENEMIES[alien.type] || ENEMIES.bug;
            emoji = def.emoji;
          }
          cell.textContent = emoji;
          grid.appendChild(cell);
        }
      }

      container.appendChild(grid);
    }

    function renderNodeDetails(){
      if(!selectedNodeId || !selectedNode){
        nodeInfoEl.innerHTML = "<div>Select a node on the left.</div>";
        openBattleBtn.disabled = true;
        upgradeBaseBtn.disabled = true;
        return;
      }
      let html = "";
      html += `<div><strong>${selectedNode.type==="base" ? "Base Node" : selectedNode.type==="eco" ? "Eco Node" : "Node"} ${selectedNode.row+1}-${selectedNode.col+1}</strong></div>`;
      const ownerName =
        selectedNode.owner==="player" ? "You (green ‚Äî only your forces)" :
        selectedNode.owner==="enemy" ? "Aliens (red ‚Äî only alien forces)" :
        selectedNode.owner==="contested" ? "Contested (yellow ‚Äî both sides)" :
        "Neutral (no one present)";
      html += `<div style="margin-top:4px;">Owner: <strong>${ownerName}</strong></div>`;

      if(selectedNode.type==="base"){
        const base = latestGame?.base || {};
        html += `<div style="margin-top:6px;">
          This node contains the <strong>central üîã generator</strong> at the far-left column.
          Aliens must physically reach and destroy it to end the run.
          Upgrading the generator increases credits per 5 seconds for all players.<br/>
          Next upgrade cost: <strong>${base.upgradeCost ?? 0}</strong> credits.
        </div>`;
      }else if(selectedNode.type==="eco"){
        html += `<div style="margin-top:6px;">This is an <strong>economic node</strong>. When it's green (only your forces present), it adds bonus credits every income tick.</div>`;
      }else{
        html += `<div style="margin-top:6px;">Node control is purely determined by who is standing here. Build defenses and troops to turn it green, clear out aliens to remove red, or press into yellow zones to contest them.</div>`;
      }

      nodeInfoEl.innerHTML = html;
      appendMiniGrid(nodeInfoEl, selectedNode);

      openBattleBtn.disabled = false;
      upgradeBaseBtn.disabled = selectedNode.type!=="base";
    }

    // ---------------- HOST ROLE ----------------
    function syncHostRole(){
      if(!latestGame || !currentUser) return;
      const hostUid = latestGame.hostUid;
      const shouldBeHost = hostUid === currentUser.uid;
      if(shouldBeHost && !isHost){
        isHost = true;
        startHostLoop();
        log("You are host ‚Äî running Overlord simulation.");
      }else if(!shouldBeHost && isHost){
        isHost = false;
        stopHostLoop();
        log("Another player is host now.");
      }
    }
    function startHostLoop(){
      if(hostTickHandle) clearInterval(hostTickHandle);
      hostTickHandle = setInterval(()=>hostTick().catch(console.error), 1000);
    }
    function stopHostLoop(){
      if(hostTickHandle){
        clearInterval(hostTickHandle);
        hostTickHandle = null;
      }
    }

    async function hostTick(){
      if(!isHost || hostTicking) return;
      hostTicking = true;
      try{
        const gSnap = await getDoc(gameRef);
        if(!gSnap.exists()) { hostTicking=false; return; }
        const game = gSnap.data();
        if(game.status && game.status!=="running"){ hostTicking=false; return; }

        let timeSeconds = (game.timeSeconds || 0) + 1;
        const updates = { timeSeconds };

        const base = game.base || {hp:0,maxHp:1,level:1,incomePerPlayer:0,upgradeCost:60};
        if(base.hp <= 0 && game.status!=="lost"){
          updates.status = "lost";
          await updateDoc(gameRef, updates);
          hostTicking=false;
          return;
        }
        if(timeSeconds >= game.winAtSeconds && game.status!=="won"){
          updates.status = "won";
        }

        await updateDoc(gameRef, updates);
        latestGame = {...game,...updates};

        if(timeSeconds % INCOME_INTERVAL === 0){
          await applyIncomeTick(latestGame);
        }
        if(timeSeconds % SPREAD_INTERVAL === 0){
          await applySpreadTick(latestGame);
        }
        if(timeSeconds % ENEMY_BUILD_INTERVAL === 0){
          await growEnemyForces(latestGame);
        }

        await simulateBattles(latestGame);
      }catch(e){
        console.error("hostTick error", e);
      }
      hostTicking=false;
    }

    async function applyIncomeTick(game){
      const base = game.base || {incomePerPlayer:0};
      const baseIncome = base.incomePerPlayer || 0;

      let ecoCount = 0;
      for(const key in nodesState){
        const n = nodesState[key];
        if(!n) continue;
        if(n.type === "eco" && n.owner === "player") ecoCount++;
      }
      const ecoBonus = ecoCount * ECO_BONUS_PER_NODE;
      const income = baseIncome + ecoBonus;
      if(income <= 0) return;

      const playersSnap = await getDocs(collection(gameRef,"players"));
      const batchUpdates = [];
      for(const docSnap of playersSnap.docs){
        const p = docSnap.data();
        const extra = p.incomeBonus || 0;
        const money = (p.money||0) + income + extra;
        batchUpdates.push(updateDoc(docSnap.ref,{ money }));
      }
      await Promise.all(batchUpdates);
    }

    async function applySpreadTick(game){
      const nodeUpdates = [];

      for(const key in nodesState){
        const node = nodesState[key];
        if(!node) continue;
        if(node.owner === "enemy") continue; // enemies already own it
        const {row,col} = node;
        const neighbors = neighborsOf(row,col);
        const hasEnemyNeighbor = neighbors.some(nk=>{
          const nn = nodesState[nk];
          return nn && nn.owner === "enemy";
        });
        if(!hasEnemyNeighbor) continue;

        let chance = typeof node.spreadChance === "number" ? node.spreadChance : 0.33;
        const roll = Math.random();
        const nodeRef = doc(nodesCol, key);

        if(roll < chance){
          node.spreadChance = 0.33;
          node.pendingWave = true;
          nodeUpdates.push(setDoc(nodeRef,{
            spreadChance:0.33,
            pendingWave:true
          },{merge:true}));
          log(`Alien pressure builds in node ${row+1}-${col+1} ‚Äî wave incoming.`);
        }else{
          chance = Math.min(0.95, chance + 0.15);
          node.spreadChance = chance;
          nodeUpdates.push(setDoc(nodeRef,{ spreadChance:chance },{merge:true}));
        }
      }

      if(nodeUpdates.length) await Promise.all(nodeUpdates);
    }

    function spawnSpine(bf, x, y, variant){
      const v = variant || "piercer";
      let maxHp = v==="piercer" ? 26 : 20;
      let dmg = v==="piercer" ? 5 : 1;
      let poisonTicks = v==="piercer" ? 6 : 2;
      const range = 3;

      bf.spines = bf.spines || [];
      bf.spines.push({
        id:`sp_${Date.now()}_${Math.random().toString(16).slice(2,6)}`,
        x,y,
        hp:maxHp,
        maxHp,
        range,
        dmg,
        poisonTicks,
        cooldown:0,
        cooldownMax:3,
        variant:v
      });
    }

    function ensureSpinesForEnemyNode(node,bf){
      bf.spines = bf.spines || [];
      if(bf.spines.length>0) return false;

      const mid = Math.floor(BATTLE_H/2);
      const x = BATTLE_W-3;
      const positions = [
        {x, y:mid-2},
        {x, y:mid},
        {x, y:mid+2}
      ].filter(p=>p.y>=1 && p.y<BATTLE_H-1);

      positions.forEach((p,i)=>{
        const variant = (i===1 ? "shredder" : "piercer");
        spawnSpine(bf, p.x, p.y, variant);
      });

      return true;
    }

    async function growEnemyForces(game){
      const timeSeconds = game.timeSeconds || 0;
      const minutes = timeSeconds / 60;
      const maxAliensBase = 4 + Math.floor(minutes * 3);
      const maxSpinesBase = 2 + Math.floor(minutes / 4);

      const batch = [];

      for(const key in nodesState){
        const node = nodesState[key];
        if(!node) continue;
        if(node.owner !== "enemy") continue;

        const bf = node.battlefield || {
          width:BATTLE_W,height:BATTLE_H,
          troops:[],towers:[],aliens:[],spines:[]
        };
        bf.aliens = bf.aliens || [];
        bf.spines = bf.spines || [];

        const maxAliens = Math.min(40, maxAliensBase);
        const maxSpines = Math.min(8, maxSpinesBase);

        let changed = false;

        if(bf.aliens.length < maxAliens){
          const deficit = maxAliens - bf.aliens.length;
          const spawnCount = Math.min(4 + Math.floor(minutes), deficit);
          for(let i=0;i<spawnCount;i++){
            const row = 1 + (i % (BATTLE_H-2));
            const x = BATTLE_W-1;
            let typeKey = "bug";
            if(minutes > 8){
              if(i%4===0) typeKey="behemoth";
              else if(i%3===0) typeKey="brute";
              else if(i%2===0) typeKey="spitter";
            }else if(minutes > 4){
              if(i%3===0) typeKey="brute";
              else if(i%2===0) typeKey="spitter";
            }else if(minutes > 2){
              if(i%2===0) typeKey="spitter";
            }
            const def = ENEMIES[typeKey];
            bf.aliens.push({
              id:"a_"+Date.now()+"_"+Math.random().toString(16).slice(2,6),
              x,
              y:row,
              type:typeKey,
              hp:def.baseHp,
              maxHp:def.baseHp
            });
          }
          changed = true;
        }

        if(bf.spines.length < maxSpines){
          const needed = maxSpines - bf.spines.length;
          for(let i=0;i<needed;i++){
            const x = BATTLE_W-3 - (i%2);
            const y = 1 + Math.floor(Math.random()*(BATTLE_H-2));
            const variant = (Math.random()<0.5 ? "piercer" : "shredder");
            spawnSpine(bf,x,y,variant);
          }
          changed = true;
        }

        if(changed){
          const nodeRef = doc(nodesCol,key);
          batch.push(setDoc(nodeRef,{ battlefield:bf },{merge:true}));
        }
      }

      if(batch.length) await Promise.all(batch);
    }

    async function simulateBattles(game){
      const timeSeconds = game.timeSeconds || 0;
      const batch = [];
      let baseGeneratorHp = null;

      for(const key in nodesState){
        const node = nodesState[key];
        if(!node) continue;
        let changed = false;
        const bf = node.battlefield || {
          width:BATTLE_W, height:BATTLE_H,
          troops:[], towers:[], aliens:[], spines:[], hitLines:[]
        };

        bf.hitLines = [];

        if(node.owner === "enemy"){
          if(ensureSpinesForEnemyNode(node,bf)){
            changed = true;
          }
        }

        if(node.pendingWave){
          spawnAlienWaveForNode(node, bf, timeSeconds);
          node.pendingWave = false;
          changed = true;
        }

        const hadStuff =
          (bf.troops && bf.troops.length) ||
          (bf.towers && bf.towers.length) ||
          (bf.aliens && bf.aliens.length) ||
          (bf.spines && bf.spines.length);

        if(hadStuff){
          const result = simulateBattlefieldStep(node, bf, game);
          if(result.changed) changed = true;
        }

        const hasPlayerStuff = (bf.troops && bf.troops.length) || (bf.towers && bf.towers.length);
        const hasEnemyStuff  = (bf.aliens && bf.aliens.length) || (bf.spines && bf.spines.length);
        let newOwner;
        if(hasPlayerStuff && !hasEnemyStuff) newOwner = "player";
        else if(!hasPlayerStuff && hasEnemyStuff) newOwner = "enemy";
        else if(hasPlayerStuff && hasEnemyStuff) newOwner = "contested";
        else newOwner = "neutral";

        if(newOwner !== node.owner){
          node.owner = newOwner;
          changed = true;
        }

        if(node.type === "base"){
          const gen = (bf.towers || []).find(tw => tw.kind === "generator");
          if(gen){
            baseGeneratorHp = gen.hp;
          }else{
            baseGeneratorHp = 0;
          }
        }

        if(changed){
          const nodeRef = doc(nodesCol, key);
          batch.push(setDoc(nodeRef,{
            owner: node.owner,
            pendingWave: node.pendingWave || false,
            battlefield: bf
          },{merge:true}));
        }
      }

      if(batch.length) await Promise.all(batch);

      if(baseGeneratorHp != null){
        const newHp = Math.max(0, Math.round(baseGeneratorHp));
        const status = newHp <= 0 ? "lost" : (game.status || "running");
        await updateDoc(gameRef,{
          "base.hp": newHp,
          status
        });
        if(newHp <= 0){
          log("‚ö† Generator destroyed. Game over for all players.");
        }
      }
    }

    function spawnAlienWaveForNode(node, bf, timeSeconds){
      const minutes = timeSeconds / 60;
      let tier = 1;
      if(minutes >= WAVE_MINUTES_2) tier = 3;
      else if(minutes >= WAVE_MINUTES_1) tier = 2;

      const waveSize = tier===1 ? 6 : tier===2 ? 10 : 14;

      bf.aliens = bf.aliens || [];
      for(let i=0;i<waveSize;i++){
        const row = 1 + (i % (BATTLE_H-2));
        const x = BATTLE_W-1;
        let typeKey = "bug";

        if(tier===1){
          typeKey = (i%4===0) ? "spitter" : "bug";
        }else if(tier===2){
          if(i%3===0) typeKey = "spitter";
          else typeKey = "bug";
        }else{
          if(i===0 || (i===waveSize-1 && waveSize>8)){
            typeKey = "behemoth";
          }else if(i%3===0){
            typeKey = "brute";
          }else if(i%2===0){
            typeKey = "spitter";
          }else{
            typeKey = "bug";
          }
        }

        const def = ENEMIES[typeKey];
        bf.aliens.push({
          id: "a_"+Date.now()+"_"+Math.random().toString(16).slice(2,6),
          x,
          y:row,
          type:typeKey,
          hp:def.baseHp,
          maxHp:def.baseHp
        });
      }
      log(`Alien wave spawned in node ${node.row+1}-${node.col+1} (tier ${tier}).`);
    }

    function addHitLine(bf, kind, x1,y1,x2,y2){
      bf.hitLines = bf.hitLines || [];
      bf.hitLines.push({kind, x1,y1,x2,y2});
    }

    function simulateBattlefieldStep(node, bf, game){
      const aliens = bf.aliens || [];
      const troops = bf.troops || [];
      const towers = bf.towers || [];
      const spines = bf.spines || [];
      let changed = false;

      for(const t of troops){
        if(t.poisonTicks && t.poisonTicks > 0){
          t.hp -= 1;
          t.poisonTicks--;
          changed = true;
        }
      }

      const damageBuffMap = {};
      const shieldMap = {};
      const entityById = {};

      for(const t of troops){ entityById[t.id] = t; }
      for(const tw of towers){ entityById[tw.id] = tw; }

      for(const tw of towers){
        if(tw.kind!=="signal") continue;
        const def = TOWERS.signal;
        const buffRadius = def.range || 2;
        for(const id in entityById){
          const e = entityById[id];
          const dist = Math.abs(e.x - tw.x) + Math.abs(e.y - tw.y);
          if(dist <= buffRadius){
            damageBuffMap[id] = (damageBuffMap[id]||1) * 1.25;
          }
        }
      }
      for(const t of troops){
        if(t.kind!=="sergeant") continue;
        const radius = TROOPS.sergeant.range || 2;
        for(const tt of troops){
          const dist = Math.abs(tt.x - t.x) + Math.abs(tt.y - t.y);
          if(dist <= radius){
            damageBuffMap[tt.id] = (damageBuffMap[tt.id]||1) * 1.15;
          }
        }
      }
      for(const tw of towers){
        if(tw.kind!=="shield") continue;
        const radius = TOWERS.shield.range || 2;
        for(const id in entityById){
          const e = entityById[id];
          const dist = Math.abs(e.x - tw.x) + Math.abs(e.y - tw.y);
          if(dist <= radius){
            shieldMap[id] = (shieldMap[id]||1) * 0.65;
          }
        }
      }

      function nearestEnemyFrom(x,y,range){
        let best=null, bestD=999, bestType=null;
        for(const a of aliens){
          if(a.hp<=0) continue;
          const d = Math.abs(a.x-x)+Math.abs(a.y-y);
          if(d<=range && d<bestD){
            best=a; bestD=d; bestType="alien";
          }
        }
        for(const s of spines){
          if(s.hp<=0) continue;
          const d = Math.abs(s.x-x)+Math.abs(s.y-y);
          if(d<=range && d<bestD){
            best=s; bestD=d; bestType="spine";
          }
        }
        return best ? {type:bestType, enemy:best} : null;
      }

      for(const t of troops){
        if(t.hp<=0) continue;
        const def = TROOPS[t.kind] || TROOPS.rifle;
        if(t.kind==="medic"){
          let best=null, bestPct=1.1;
          for(const ally of troops){
            if(ally.hp<=0) continue;
            const d = Math.abs(ally.x - t.x)+Math.abs(ally.y - t.y);
            if(d <= (def.range || 2)){
              const pct = ally.hp/ally.maxHp;
              if(pct < bestPct){
                bestPct = pct;
                best = ally;
              }
            }
          }
          if(best && best.hp < best.maxHp){
            best.hp = Math.min(best.maxHp, best.hp + (def.heal||3));
            changed = true;
          }
        }else{
          const range = def.range || 2;
          const targetInfo = nearestEnemyFrom(t.x,t.y,range);
          if(targetInfo){
            let dmg = def.dmg || 2;
            const buff = damageBuffMap[t.id] || 1;
            dmg = Math.round(dmg * buff);
            if(def.splash){
              const tx = targetInfo.enemy.x;
              const ty = targetInfo.enemy.y;
              addHitLine(bf,"player",t.x,t.y,tx,ty);
              for(const a of aliens){
                const d = Math.abs(a.x - tx)+Math.abs(a.y - ty);
                if(d<=1) { a.hp -= dmg; changed=true; }
              }
              for(const s of spines){
                const d = Math.abs(s.x - tx)+Math.abs(s.y - ty);
                if(d<=1) { s.hp -= dmg; changed=true; }
              }
            }else{
              addHitLine(bf,"player",t.x,t.y,targetInfo.enemy.x,targetInfo.enemy.y);
              if(targetInfo.type==="alien"){
                targetInfo.enemy.hp -= dmg;
              }else{
                targetInfo.enemy.hp -= dmg;
              }
              changed = true;
            }
          }
        }
      }

      for(const tw of towers){
        if(tw.kind === "generator") continue; // generator doesn't attack
        const def = TOWERS[tw.kind] || TOWERS.laser;
        if(def.shield || def.buff) continue;
        const range = def.range || 3;
        const targetInfo = nearestEnemyFrom(tw.x,tw.y,range);
        if(!targetInfo) continue;
        let dmg = def.dmg || 2;
        const buff = damageBuffMap[tw.id] || 1;
        dmg = Math.round(dmg * buff);
        if(def.chain){
          const tx = targetInfo.enemy.x;
          const ty = targetInfo.enemy.y;
          const chainTargets = [];
          for(const a of aliens){
            if(a.hp<=0) continue;
            const d = Math.abs(a.x - tx)+Math.abs(a.y - ty);
            if(d<=1) chainTargets.push({type:"alien", ref:a});
          }
          for(const s of spines){
            if(s.hp<=0) continue;
            const d = Math.abs(s.x - tx)+Math.abs(s.y - ty);
            if(d<=1) chainTargets.push({type:"spine", ref:s});
          }
          if(chainTargets.length===0){
            chainTargets.push({type:targetInfo.type, ref:targetInfo.enemy});
          }
          chainTargets.slice(0,3).forEach(tObj=>{
            addHitLine(bf,"player",tw.x,tw.y,tObj.ref.x,tObj.ref.y);
            tObj.ref.hp -= dmg;
          });
          changed = true;
        }else{
          addHitLine(bf,"player",tw.x,tw.y,targetInfo.enemy.x,targetInfo.enemy.y);
          targetInfo.enemy.hp -= dmg;
          changed = true;
        }
      }

      for(const s of spines){
        if(s.hp<=0) continue;
        s.cooldown = (s.cooldown||0) - 1;
        if(s.cooldown > 0) continue;

        const range = s.range || 3;
        const variant = s.variant || "piercer";

        const inRangeTroops = [];
        const inRangeTowers = [];
        for(const t of troops){
          if(t.hp<=0) continue;
          const d = Math.abs(t.x - s.x)+Math.abs(t.y - s.y);
          if(d <= range) inRangeTroops.push(t);
        }
        for(const tw of towers){
          if(tw.hp<=0) continue;
          const d = Math.abs(tw.x - s.x)+Math.abs(tw.y - s.y);
          if(d <= range) inRangeTowers.push(tw);
        }

        if(variant === "shredder"){
          let swung = false;
          const dmgLow = s.dmg || 1;
          for(const t of inRangeTroops){
            let finalDmg = dmgLow;
            const shield = shieldMap[t.id] || 1;
            finalDmg = Math.max(1, Math.round(finalDmg * shield));
            t.hp -= finalDmg;
            addHitLine(bf,"enemy",s.x,s.y,t.x,t.y);
            swung = true;
          }
          for(const tw of inRangeTowers){
            let finalDmg = dmgLow;
            const shield = shieldMap[tw.id] || 1;
            finalDmg = Math.max(1, Math.round(finalDmg * shield));
            tw.hp -= finalDmg;
            addHitLine(bf,"enemy",s.x,s.y,tw.x,tw.y);
            swung = true;
          }
          if(swung){
            s.cooldown = s.cooldownMax || 3;
            changed = true;
          }
        }else{
          let best=null, bestD=999, bestType=null;
          for(const t of inRangeTroops){
            const d = Math.abs(t.x - s.x)+Math.abs(t.y - s.y);
            if(d<bestD){ best=t; bestD=d; bestType="troop"; }
          }
          for(const tw of inRangeTowers){
            const d = Math.abs(tw.x - s.x)+Math.abs(tw.y - s.y);
            if(d<bestD){ best=tw; bestD=d; bestType="tower"; }
          }
          if(best){
            let finalDmg = s.dmg || 3;
            const shield = shieldMap[best.id] || 1;
            finalDmg = Math.max(1, Math.round(finalDmg * shield));
            best.hp -= finalDmg;
            if(bestType==="troop"){
              best.poisonTicks = Math.max(best.poisonTicks||0, s.poisonTicks || 5);
            }
            addHitLine(bf,"enemy",s.x,s.y,best.x,best.y);
            s.cooldown = s.cooldownMax || 3;
            changed = true;
          }
        }
      }

      for(const a of aliens){
        const newX = a.x-1;
        if(newX>=0){
          a.x = newX;
          changed = true;
        }
      }

      for(const a of aliens){
        const def = ENEMIES[a.type] || ENEMIES.bug;
        const dmg = def.dmg || 2;
        let bestEntity=null, bestD=2, bestType=null;

        for(const t of troops){
          if(t.hp<=0) continue;
          const d = Math.abs(t.x - a.x)+Math.abs(t.y - a.y);
          if(d<=1 && d<bestD){ bestEntity=t; bestD=d; bestType="troop"; }
        }
        for(const tw of towers){
          if(tw.hp<=0) continue;
          const d = Math.abs(tw.x - a.x)+Math.abs(tw.y - a.y);
          if(d<=1 && d<bestD){ bestEntity=tw; bestD=d; bestType="tower"; }
        }

        if(bestEntity){
          const shield = shieldMap[bestEntity.id] || 1;
          let finalDmg = Math.max(1, Math.round(dmg * shield));
          bestEntity.hp -= finalDmg;
          addHitLine(bf,"enemy",a.x,a.y,bestEntity.x,bestEntity.y);
          changed = true;
        }
      }

      for(const a of aliens){
        if(a.hp<=0) a.dead = true;
      }
      bf.aliens = aliens.filter(a=>!a.dead);

      for(const s of spines){
        if(s.hp<=0) s.dead=true;
      }
      bf.spines = spines.filter(s=>!s.dead);

      for(const t of troops){
        if(t.hp<=0) t.dead=true;
      }
      bf.troops = troops.filter(t=>!t.dead);

      for(const tw of towers){
        if(tw.hp<=0) tw.dead=true;
      }
      bf.towers = towers.filter(tw=>!tw.dead);

      return {changed};
    }

    // ---------------- BATTLE UI ----------------
    function buildBattleBars(){
      troopBarEl.innerHTML = "";
      for(const key in TROOPS){
        const def = TROOPS[key];
        const pill = document.createElement("button");
        pill.type="button";
        pill.className = "build-pill";
        pill.dataset.type = def.key;
        pill.dataset.category = "troop";
        pill.innerHTML = `${def.emoji} ${def.name} <span style="opacity:.7;">(${def.cost})</span>`;
        pill.onclick = ()=>selectBuild(def.key,"troop");
        troopBarEl.appendChild(pill);
      }
      towerBarEl.innerHTML = "";
      for(const key in TOWERS){
        const def = TOWERS[key];
        const pill = document.createElement("button");
        pill.type="button";
        pill.className = "build-pill";
        pill.dataset.type = def.key;
        pill.dataset.category = "tower";
        pill.innerHTML = `${def.emoji} ${def.name} <span style="opacity:.7;">(${def.cost})</span>`;
        pill.onclick = ()=>selectBuild(def.key,"tower");
        towerBarEl.appendChild(pill);
      }
    }

    function selectBuild(type,category){
      currentBuild = {type,category};
      document.querySelectorAll(".build-pill").forEach(el=>{
        const t = el.dataset.type;
        const cat = el.dataset.category;
        el.classList.toggle("active", t===type && cat===category);
      });
    }

    function openBattleForNode(nodeId){
      if(!nodeId || !nodesState[nodeId]) return;
      selectedNodeId = nodeId;
      selectedNode = nodesState[nodeId];
      renderBoard();
      renderNodeDetails();

      if(battleUnsub) battleUnsub();
      const nodeRef = doc(nodesCol, nodeId);
      battleUnsub = onSnapshot(nodeRef,(snap)=>{
        if(!snap.exists()) return;
        const node = snap.data();
        nodesState[nodeId] = node;
        renderBattlefield(node);
      });

      buildBattleBars();
      const {row,col} = parseKey(nodeId);
      battleNodeLabel.textContent = (selectedNode.type==="base" ? "Base Node" : selectedNode.type==="eco" ? "Eco Node" : "Node") + ` ${row+1}-${col+1}`;
      updateBattleOwnerTag(selectedNode);
      battleOverlay.style.display = "flex";
    }

    function updateBattleOwnerTag(node){
      const owner = node.owner;
      battleOwnerTag.textContent =
        owner==="player" ? "Player-only (green)" :
        owner==="enemy" ? "Alien-only (red)" :
        owner==="contested" ? "Both present (yellow)" :
        "Empty (neutral)";
      battleOwnerTag.className = "tag";
      if(owner==="player") battleOwnerTag.classList.add("tag-green");
      else if(owner==="enemy") battleOwnerTag.classList.add("tag-enemy");
      else if(owner==="contested") battleOwnerTag.classList.add("tag-base");
    }

    function renderBattlefield(node){
      const bf = node.battlefield || {width:BATTLE_W,height:BATTLE_H,troops:[],towers:[],aliens:[],spines:[],hitLines:[]};
      battleGridEl.innerHTML = "";
      const troops = bf.troops || [];
      const towers = bf.towers || [];
      const aliens = bf.aliens || [];
      const spines = bf.spines || [];

      function getCellContents(x,y){
        const res = {troop:null,tower:null,alien:null,spine:null};
        res.troop = troops.find(t=>t.x===x && t.y===y) || null;
        res.tower = towers.find(tw=>tw.x===x && tw.y===y) || null;
        res.alien = aliens.find(a=>a.x===x && a.y===y) || null;
        res.spine = spines.find(s=>s.x===x && s.y===y) || null;
        return res;
      }

      for(let y=0;y<BATTLE_H;y++){
        for(let x=0;x<BATTLE_W;x++){
          const cell = document.createElement("div");
          cell.className = "battle-cell";
          if(x<=2) cell.classList.add("battle-cell-bg-player");
          else if(x>=BATTLE_W-3) cell.classList.add("battle-cell-bg-enemy");
          else cell.classList.add("battle-cell-bg-frontline");

          const {troop,tower,alien,spine} = getCellContents(x,y);
          let emoji = "";
          let hp = null, maxHp = null;

          if(spine){
            emoji = "üåµ";
            hp = spine.hp;
            maxHp = spine.maxHp;
          }else if(tower){
            if(tower.kind === "generator"){
              emoji = "üîã";
            }else{
              const def = TOWERS[tower.kind] || TOWERS.laser;
              emoji = def.emoji;
            }
            hp = tower.hp;
            maxHp = tower.maxHp;
          }else if(troop){
            const def = TROOPS[troop.kind] || TROOPS.rifle;
            emoji = def.emoji;
            hp = troop.hp;
            maxHp = troop.maxHp;
          }
          if(alien){
            const def = ENEMIES[alien.type] || ENEMIES.bug;
            emoji = def.emoji;
            hp = alien.hp;
            maxHp = alien.maxHp;
          }

          if(emoji){
            cell.textContent = emoji;
          }else{
            cell.textContent = "";
          }

          if(hp != null && maxHp != null){
            const bar = document.createElement("div");
            bar.className = "hp-bar-mini";
            const fill = document.createElement("div");
            fill.className = "hp-bar-mini-fill";
            const pct = Math.max(0, Math.min(100, (hp/maxHp)*100));
            fill.style.width = pct + "%";
            bar.appendChild(fill);
            cell.appendChild(bar);
          }

          cell.addEventListener("click",()=>{
            onBattleCellClick(x,y,node);
          });

          battleGridEl.appendChild(cell);
        }
      }

      const wrap = battleGridEl.parentElement;
      if(wrap){
        wrap.querySelectorAll(".hitline-layer").forEach(el=>el.remove());
        const layer = document.createElement("div");
        layer.className = "hitline-layer";
        const lines = bf.hitLines || [];
        for(const l of lines){
          const lineEl = document.createElement("div");
          lineEl.className = "hitline " + (l.kind==="enemy" ? "enemy" : "player");

          const x1p = ((l.x1 + 0.5) / BATTLE_W) * 100;
          const y1p = ((l.y1 + 0.5) / BATTLE_H) * 100;
          const dx = (l.x2 - l.x1) / BATTLE_W;
          const dy = (l.y2 - l.y1) / BATTLE_H;
          const length = Math.sqrt(dx*dx + dy*dy) * 100;
          const angle = Math.atan2((l.y2 - l.y1),(l.x2 - l.x1)) * 180 / Math.PI;

          lineEl.style.left = x1p + "%";
          lineEl.style.top = y1p + "%";
          lineEl.style.width = Math.max(5,length) + "%";
          lineEl.style.transform = `translate(0,-50%) rotate(${angle}deg)`;

          layer.appendChild(lineEl);
        }
        wrap.appendChild(layer);
      }

      updateBattleOwnerTag(node);
    }

    async function onBattleCellClick(x,y,node){
      if(!currentBuild.type || !currentBuild.category){
        log("Select a troop or tower type first.");
        return;
      }
      if(x > 2){
        log("You can only place in the first 3 columns.");
        return;
      }
      if(!myPlayer){
        log("Player data not loaded yet.");
        return;
      }
      const cost =
        currentBuild.category==="troop" ? TROOPS[currentBuild.type].cost :
        TOWERS[currentBuild.type].cost;

      if((myPlayer.money || 0) < cost){
        log("Not enough credits.");
        return;
      }

      try{
        await runTransaction(db, async (tx)=>{
          const pSnap = await tx.get(playerRef);
          if(!pSnap.exists()) throw new Error("Player missing.");
          const p = pSnap.data();
          if((p.money||0) < cost) throw new Error("Not enough credits.");

          const nodeRef = doc(nodesCol, selectedNodeId);
          const nSnap = await tx.get(nodeRef);
          if(!nSnap.exists()) throw new Error("Node missing.");
          const n = nSnap.data();
          const bf = n.battlefield || {width:BATTLE_W,height:BATTLE_H,troops:[],towers:[],aliens:[],spines:[],hitLines:[]};

          const occupied =
            (bf.troops||[]).some(t=>t.x===x && t.y===y) ||
            (bf.towers||[]).some(tw=>tw.x===x && tw.y===y) ||
            (bf.spines||[]).some(s=>s.x===x && s.y===y);

          if(occupied) throw new Error("Cannot build on occupied tile.");

          if(currentBuild.category==="troop"){
            const def = TROOPS[currentBuild.type];
            bf.troops = bf.troops || [];
            bf.troops.push({
              id:"t_"+Date.now()+"_"+Math.random().toString(16).slice(2,6),
              x,y,
              kind:def.key,
              hp:def.baseHp,
              maxHp:def.baseHp
            });
          }else{
            const def = TOWERS[currentBuild.type];
            bf.towers = bf.towers || [];
            bf.towers.push({
              id:"tw_"+Date.now()+"_"+Math.random().toString(16).slice(2,6),
              x,y,
              kind:def.key,
              hp:18,
              maxHp:18
            });
          }

          tx.update(playerRef,{ money:(p.money||0)-cost });
          tx.set(nodeRef,{ battlefield:bf },{merge:true});
        });
        log(`Built ${currentBuild.category==="troop" ? TROOPS[currentBuild.type].name : TOWERS[currentBuild.type].name} at (${x+1},${y+1}).`);
      }catch(e){
        log("Build failed: "+e.message);
      }
    }

    // ---------------- UI BUTTONS ----------------
    openBattleBtn.addEventListener("click",()=>{
      if(!selectedNodeId) return;
      openBattleForNode(selectedNodeId);
    });

    leaveBattleBtn.addEventListener("click",()=>{
      battleOverlay.style.display = "none";
      if(battleUnsub){ battleUnsub(); battleUnsub=null; }
    });

    upgradeBaseBtn.addEventListener("click", async ()=>{
      if(!latestGame || !myPlayer) return;
      if(!selectedNode || selectedNode.type!=="base") return;
      try{
        await runTransaction(db, async (tx)=>{
          const gSnap = await tx.get(gameRef);
          const pSnap = await tx.get(playerRef);
          if(!gSnap.exists() || !pSnap.exists()) throw new Error("Missing game or player.");
          const g = gSnap.data();
          const p = pSnap.data();
          const base = g.base || {level:1,upgradeCost:60,incomePerPlayer:4};
          const cost = base.upgradeCost || 60;
          if((p.money||0) < cost) throw new Error("Not enough credits for upgrade.");
          const newLevel = (base.level||1)+1;
          const newIncome = (base.incomePerPlayer||4) + 3;
          const newCost = Math.round(cost*1.7);
          tx.update(playerRef,{ money: (p.money||0)-cost });
          tx.update(gameRef,{
            base:{
              ...base,
              level:newLevel,
              incomePerPlayer:newIncome,
              upgradeCost:newCost
            }
          });
        });
        log("‚ö° Generator upgraded. All players gain more credits per tick.");
      }catch(e){
        log("Upgrade failed: "+e.message);
      }
    });

    document.getElementById("fullscreenBtn").addEventListener("click",()=>{
      const el = document.documentElement;
      if(!document.fullscreenElement){
        el.requestFullscreen?.();
      }else{
        document.exitFullscreen?.();
      }
    });

    log("Connecting to Firebase and waiting for authentication‚Ä¶");
  </script>
</body>
</html>











