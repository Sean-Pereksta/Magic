<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>üè∞ Base Defense: Trump Revenge (4P)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
  <style>
    :root{
      --bg:#020617;
      --panel:#020617;
      --ink:#e5e7eb;
      --muted:#9ca3af;
      --accent:#f97316;
      --accent-soft:#1f2937;
      --danger:#ef4444;
      --good:#22c55e;
      --border:#1f2937;
      --radius:14px;
      --cellSize: min(5vh, 5vw);
    }
    @media (max-width:768px){
      :root{
        --cellSize: min(8vh, 8vw); /* bigger zoom on mobile */
      }
    }

    *{box-sizing:border-box; -webkit-tap-highlight-color:transparent;}
    html,body{
      margin:0; padding:0;
      height:100%;
      background:radial-gradient(circle at top,#0f172a 0,#020617 55%);
      color:var(--ink);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      overflow:hidden;
    }
    body{
      display:flex;
      flex-direction:column;
    }

    .shell{
      flex:1;
      display:flex;
      flex-direction:column;
      max-width:1200px;
      margin:0 auto;
      width:100%;
      padding:8px 8px calc(8px + env(safe-area-inset-bottom));
      gap:8px;
    }

    .top-bar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      padding:6px 10px;
      background:rgba(15,23,42,.9);
      border-radius:var(--radius);
      border:1px solid var(--border);
      box-shadow:0 6px 18px rgba(0,0,0,.6);
    }
    .top-left{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .game-title{
      font-weight:700;
      font-size:.9rem;
      display:flex;
      align-items:center;
      gap:4px;
    }
    .pill{
      border-radius:999px;
      padding:4px 8px;
      font-size:.75rem;
      border:1px solid var(--border);
      background:rgba(15,23,42,.9);
      display:inline-flex;
      align-items:center;
      gap:4px;
    }

    .hp-bar{
      width:90px;
      height:8px;
      border-radius:999px;
      border:1px solid var(--border);
      background:#020617;
      overflow:hidden;
    }
    .hp-fill{
      height:100%;
      background:linear-gradient(90deg,#22c55e,#facc15,#ef4444);
      width:0%;
      transition:width .12s linear;
    }
    .small{
      font-size:.75rem;
      color:var(--muted);
    }

    .top-right{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    /* Abilities bar */
    .abilities{
      display:flex;
      gap:4px;
      align-items:center;
      flex-wrap:wrap;
      padding:4px 6px;
      background:rgba(15,23,42,.9);
      border-radius:999px;
      border:1px solid var(--border);
      box-shadow:0 6px 18px rgba(0,0,0,.5);
      max-width:60%;
      overflow:hidden;
    }
    .ability-tile{
      position:relative;
      width:32px;
      height:32px;
      border-radius:6px;
      border:1px solid var(--border);
      background:#020617;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:.75rem;
    }
    .ability-tile span{
      pointer-events:none;
    }
    .ability-cooldown{
      position:absolute;
      inset:0;
      background:rgba(15,23,42,.8);
      transform-origin:bottom;
      transform:scaleY(0);
      transition:transform .1s linear;
    }

    .grid-wrapper{
      flex:1;
      background:radial-gradient(circle at top,#111827 0,#020617 60%);
      border-radius:var(--radius);
      border:1px solid var(--border);
      padding:6px;
      box-shadow:0 18px 40px rgba(0,0,0,.7);
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:0;
    }

    #grid{
      display:grid;
      gap:1px;
      background:#020617;
      touch-action:none;
    }
    .cell{
      width:var(--cellSize);
      height:var(--cellSize);
      background:#020617;
      position:relative;
      border-radius:2px;
      overflow:hidden;
    }
    .cell-path{
      background:#0b1120;
    }
    .cell-terrain{
      background:radial-gradient(circle at 30% 20%,#1f2937 0,#020617 55%);
    }
    .cell-base{
      background:radial-gradient(circle at 30% 20%,#111827 0,#020617 60%);
      box-shadow:inset 0 0 10px rgba(250,250,250,.1);
    }

    .cell-highlight{
      box-shadow:0 0 0 2px rgba(234,179,8,.6) inset;
    }

    .danger-telegraph{
      position:absolute;
      inset:0;
      background:rgba(239,68,68,.35);
      box-shadow:0 0 0 1px rgba(248,113,113,.9) inset;
    }
    .danger-explosion{
      position:absolute;
      inset:15%;
      border-radius:50%;
      background:radial-gradient(circle,#f97316 0,#b91c1c 55%,transparent 70%);
      opacity:.9;
    }
    .laser-line{
      position:absolute;
      inset:30%;
      border-radius:999px;
      background:linear-gradient(90deg,#f97316,#facc15);
      box-shadow:0 0 12px rgba(250,204,21,.8);
    }

    .shield-ring{
      position:absolute;
      inset:15%;
      border-radius:50%;
      border:2px solid rgba(34,197,94,.8);
      box-shadow:0 0 10px rgba(34,197,94,.7);
    }

    .entity{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:calc(var(--cellSize)*0.5);
      pointer-events:none;
    }

    /* Very visible friendly shots */
    .entity.proj-friendly{
      font-size:calc(var(--cellSize)*0.7);
      color:#facc15;
      text-shadow:0 0 6px rgba(250,204,21,.9);
    }

    .hp-chip{
      position:absolute;
      left:50%;
      bottom:1px;
      transform:translateX(-50%);
      min-width:60%;
      height:3px;
      border-radius:999px;
      background:rgba(15,23,42,.7);
      overflow:hidden;
    }
    .hp-chip-fill{
      height:100%;
      background:linear-gradient(90deg,#22c55e,#f97316,#ef4444);
      width:100%;
    }

    .btn-small{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:4px 6px;
      border-radius:999px;
      border:1px solid var(--border);
      background:#020617;
      color:var(--ink);
      font-size:.7rem;
      cursor:pointer;
    }

    /* Level up modal */
    .modal-backdrop{
      position:fixed;
      inset:0;
      background:rgba(15,23,42,.8);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:30;
    }
    .modal{
      width:min(360px, 95vw);
      background:#020617;
      border-radius:var(--radius);
      border:1px solid var(--border);
      box-shadow:0 18px 50px rgba(0,0,0,.9);
      padding:12px;
    }
    .modal h2{
      margin:0 0 6px;
      font-size:1rem;
    }
    .modal p{
      margin:0 0 8px;
      font-size:.8rem;
      color:var(--muted);
    }
    .modal-options{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .option-btn{
      border-radius:10px;
      border:1px solid var(--border);
      background:#020617;
      padding:6px 8px;
      cursor:pointer;
      text-align:left;
      font-size:.8rem;
    }
    .option-btn:hover{
      border-color:#f97316;
      box-shadow:0 0 0 1px rgba(249,115,22,.3);
    }
    .option-title{
      font-weight:700;
      margin-bottom:2px;
    }
    .option-desc{
      font-size:.78rem;
      color:var(--muted);
    }
  </style>
</head>
<body>
  <div class="shell">
    <div class="top-bar">
      <div class="top-left">
        <div class="game-title">
          üè∞ <span>Trump Revenge</span>
        </div>
        <div class="pill">
          <span id="playerName">Player</span>
        </div>
        <div class="pill">
          Base
          <div class="hp-bar"><div id="baseHpFill" class="hp-fill"></div></div>
        </div>
        <div class="pill">
          You
          <div class="hp-bar"><div id="playerHpFill" class="hp-fill"></div></div>
        </div>
        <div class="pill">
          <span id="levelLabel">Lv 1</span>
          <span class="small" id="xpLabel">(0 / 10 XP)</span>
        </div>
      </div>
      <div class="top-right">
        <div class="abilities" id="abilitiesBar">
          <span class="small">Abilities</span>
        </div>
        <button class="btn-small" id="fullscreenBtn">‚õ∂</button>
      </div>
    </div>

    <div class="grid-wrapper">
      <div id="grid"></div>
    </div>
  </div>

  <!-- Level-up modal -->
  <div id="levelModal" class="modal-backdrop" style="display:none;">
    <div class="modal">
      <h2>New Ability!</h2>
      <p>Choose 1 auto-trigger ability for your hero.</p>
      <div id="modalOptions" class="modal-options"></div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import {
      getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot,
      collection, serverTimestamp, runTransaction
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    // --- CONFIG ---
    const firebaseConfig = {
      apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
      authDomain: "bible-game-246c0.firebaseapp.com",
      projectId: "bible-game-246c0",
      storageBucket: "bible-game-246c0.appspot.com",
      messagingSenderId: "959619818996",
      appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
    };
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // --- URL PARAMS ---
    const params = new URLSearchParams(window.location.search);
    const gameId = params.get("gameId") || "dev-room";
    const username = (params.get("username") || "Guest").trim();
    document.getElementById("playerName").textContent = username;

    // --- WORLD vs VIEWPORT ---
    const WORLD_W = 60;
    const WORLD_H = 11;
    const VIEW_W = 18;
    const VIEW_H = 11;

    const BASE_COL = 1;
    const PATH_ROWS_MAIN = [4,5,6];

    // Make full horizontal corridor
    const terrain = [];
    for(let y=0;y<WORLD_H;y++){
      terrain[y] = [];
      for(let x=0;x<WORLD_W;x++){
        let type = "space";
        if (x===0 || x===WORLD_W-1 || y===0 || y===WORLD_H-1){
          type = "terrain";
        }
        if (x>0 && x<WORLD_W-1 && PATH_ROWS_MAIN.includes(y)){
          type = "path";
        }
        if (x <= BASE_COL && PATH_ROWS_MAIN.includes(y)){
          type = "base";
        }
        terrain[y][x] = type;
      }
    }

    const gridEl = document.getElementById("grid");
    gridEl.style.gridTemplateColumns = `repeat(${VIEW_W}, var(--cellSize))`;
    gridEl.style.gridTemplateRows = `repeat(${VIEW_H}, var(--cellSize))`;

    const cells = [];
    for(let vy=0;vy<VIEW_H;vy++){
      for(let vx=0;vx<VIEW_W;vx++){
        const c = document.createElement("div");
        c.className = "cell";
        gridEl.appendChild(c);
        if(!cells[vy]) cells[vy]=[];
        cells[vy][vx] = c;

        c.addEventListener("click", ()=> onCellClick(vx,vy));
        c.addEventListener("touchstart", (e)=>{ e.preventDefault(); onCellClick(vx,vy); }, {passive:false});
      }
    }

    function log(msg){
      console.log("[GAME]", msg);
      const logEl = document.getElementById("log");
      if(!logEl) return;
      const line = document.createElement("div");
      line.textContent = msg;
      logEl.appendChild(line);
      logEl.scrollTop = logEl.scrollHeight;
    }

    // Camera centered on player
    function getCamera(){
      const px = localPlayerState ? Math.round(localPlayerState.x) : BASE_COL;
      const py = localPlayerState ? Math.round(localPlayerState.y) : Math.floor(WORLD_H/2);
      let left = px - Math.floor(VIEW_W/2);
      let top  = py - Math.floor(VIEW_H/2);
      left = Math.max(0, Math.min(WORLD_W - VIEW_W, left));
      top  = Math.max(0, Math.min(WORLD_H - VIEW_H, top));
      return {left, top};
    }

    // Corridor towers + boss far down lane
    function createCorridorTowers(){
      const towers = [];
      const lanes = PATH_ROWS_MAIN;

      const towerCols = [
        {col:22, tier:1, type:"charger"},
        {col:30, tier:2, type:"scatter"},
        {col:38, tier:3, type:"rocket"},
        {col:46, tier:4, type:"laser"},
        {col:54, tier:5, type:"storm"}
      ];
      function pushTower(col,row,tier,type){
        const baseHP = 45 + tier*25;
        const cdBase = Math.max(4, 9 - tier);
        towers.push({
          id:`tw_${col}_${row}`,
          role:"tower",
          mobile:false,
          type,
          x:col,
          y:row,
          hp:baseHP,
          maxHp:baseHP,
          cd:cdBase,
          telegraph:0,
          aim:null,
          lane:"mid",
          tier
        });
      }
      towerCols.forEach(set=>{
        for(const row of lanes){
          pushTower(set.col,row,set.tier,set.type);
        }
      });
      // Final boss
      const bossRow = PATH_ROWS_MAIN[Math.floor(PATH_ROWS_MAIN.length/2)];
      const bossHP = 400;
      towers.push({
        id:"boss_main",
        role:"tower",
        boss:true,
        mobile:false,
        type:"voider",
        x:WORLD_W-3,
        y:bossRow,
        hp:bossHP,
        maxHp:bossHP,
        cd:5,
        telegraph:0,
        aim:null,
        lane:"boss",
        tier:6
      });
      return towers;
    }

    // --- GAME FIREBASE STRUCTURE ---
    const gameRef = doc(db, "games_trumprev", gameId);
    const playerRef = doc(db, "games_trumprev", gameId, "players", username);

    let isHost = false;
    let hostTickHandle = null;
    let latestGame = null;
    let latestPlayers = {};
    let localPlayerState = null;

    // --- CLASSES / ABILITIES ---
    const CLASSES = [
      { key:"vanguard", emoji:"üõ°Ô∏è", name:"Vanguard", hp:18, range:3, dmg:3, speed:1 },
      { key:"ranger",   emoji:"üèπ", name:"Ranger",   hp:14, range:5, dmg:4, speed:1 },
      { key:"aegis",    emoji:"‚ú®", name:"Aegis",    hp:16, range:3, dmg:2, speed:1 }
    ];

    const ABILITY_POOL = [
      {
        key:"rapidfire",
        name:"Rapid Volley",
        desc:"+25% attack speed.",
        kind:"passive",
        effect:{ atkSpeedMult:1.25 }
      },
      {
        key:"powershot",
        name:"Power Shot",
        desc:"+2 damage per hit.",
        kind:"passive",
        effect:{ dmgBonus:2 }
      },
      {
        key:"barrierPulse",
        name:"Barrier Pulse",
        desc:"Periodic shield pulses reduce nearby damage.",
        kind:"auto",
        effect:{ shieldPulse:true }
      },
      {
        key:"knightBoost",
        name:"Knight Drill",
        desc:"+40% knight HP & damage.",
        kind:"passive",
        effect:{ knightBoost:true }
      },
      {
        key:"regenAura",
        name:"Regen Aura",
        desc:"Slowly regenerate HP over time.",
        kind:"auto",
        effect:{ regen:true }
      },
      {
        key:"blastNova",
        name:"Blast Nova",
        desc:"Periodic AoE blast around you.",
        kind:"auto",
        effect:{ nova:true }
      }
    ];

    // --- INITIAL JOIN / HOST CLAIM ---
    async function joinGame(){
      await runTransaction(db, async (tx)=>{
        const snap = await tx.get(gameRef);
        if(!snap.exists()){
          const baseHP = 100;
          const initial = {
            host: username,
            createdAt: serverTimestamp(),
            status:"running",
            tick:0,
            base:{ hp:baseHP, maxHp:baseHP },
            enemies: createCorridorTowers(),
            knights:[],
            projectiles:[],
            dangerCells:[],
            shieldPulses:[]
          };
          tx.set(gameRef, initial);
          isHost = true;
          log("You are host ‚Äî running simulation.");
        }else{
          const d = snap.data();
          if(!d.host){
            tx.update(gameRef, { host:username });
            isHost = true;
            log("You became host.");
          }else{
            isHost = (d.host === username);
          }
        }
      });

      const pSnap = await getDoc(playerRef);
      if(!pSnap.exists()){
        const classIdx = Math.floor(Math.random()*CLASSES.length);
        const cls = CLASSES[classIdx];
        const spawn = { x:BASE_COL, y:5 };
        await setDoc(playerRef,{
          id:username,
          classIndex:classIdx,
          x:spawn.x, y:spawn.y,
          targetX:spawn.x, targetY:spawn.y,
          hp:cls.hp, maxHp:cls.hp,
          level:1,
          xp:0,
          nextLevelXp:10,
          knightLevel:1,
          abilities:[],
          pendingChoice:null,
          lastInputAt:Date.now(),
          lastUpdated:serverTimestamp()
        });
        log(`Joined as ${CLASSES[classIdx].emoji} ${CLASSES[classIdx].name}`);
      }else{
        log("Rejoined game.");
      }

      subscribeGame();
      subscribePlayers();
      if(isHost) startHostLoop();
    }

    // --- SUBSCRIPTIONS ---
    function subscribeGame(){
      onSnapshot(gameRef,(snap)=>{
        if(!snap.exists()) return;
        latestGame = snap.data();
        renderBase();
        renderBoard();
        syncHostLoopState();
      });
    }

    function subscribePlayers(){
      const col = collection(db,"games_trumprev",gameId,"players");
      onSnapshot(col,(snap)=>{
        latestPlayers = {};
        snap.forEach(d=>{
          latestPlayers[d.id]=d.data();
          if(d.id===username) localPlayerState = d.data();
        });
        renderBoard();
        checkLevelUpModal();
      });
    }

    // --- HOST LOOP ---
    const TICK_MS = 380; // slower for clarity
    const SHIELD_PERIOD = 24;
    const NOVA_PERIOD = 30;

    function startHostLoop(){
      if(hostTickHandle) clearInterval(hostTickHandle);
      hostTickHandle = setInterval(()=>hostTick().catch(()=>{}), TICK_MS);
    }
    function stopHostLoop(){
      if(hostTickHandle) clearInterval(hostTickHandle);
      hostTickHandle = null;
    }
    function syncHostLoopState(){
      if(!latestGame) return;
      if(!isHost && hostTickHandle){
        stopHostLoop();
      }else if(isHost && !hostTickHandle){
        startHostLoop();
      }
    }

    function randInt(min,max){
      return Math.floor(Math.random()*(max-min+1))+min;
    }
    function dist(a,b){
      return Math.abs(a.x-b.x)+Math.abs(a.y-b.y);
    }
    function isWalkable(x,y){
      if(x<0||x>=WORLD_W||y<0||y>=WORLD_H) return false;
      const t = terrain[y][x];
      return t==="path" || t==="base" || t==="terrain";
    }

    function computeDerivedStats(p){
      const out = {
        atkSpeedMult:1,
        dmgBonus:0,
        knightHpMult:1,
        knightDmgMult:1,
        regen:false,
        shieldPulse:false,
        nova:false
      };
      const abilities = p.abilities || [];
      for(const ab of abilities){
        const eff = ab.effect || {};
        if(eff.atkSpeedMult) out.atkSpeedMult *= eff.atkSpeedMult;
        if(eff.dmgBonus) out.dmgBonus += eff.dmgBonus;
        if(eff.knightBoost){
          out.knightHpMult *= 1.4;
          out.knightDmgMult *= 1.4;
        }
        if(eff.regen) out.regen = true;
        if(eff.shieldPulse) out.shieldPulse = true;
        if(eff.nova) out.nova = true;
      }
      return out;
    }

    function nearest(list, from, maxRange=999){
      let best=null, bestD=9999;
      for(const e of list){
        if(e.hp!==undefined && e.hp<=0) continue;
        const d = dist(e,from);
        if(d<=maxRange && d<bestD){
          best=e; bestD=d;
        }
      }
      return best;
    }

    function pickRandomAbilities(n){
      const copy = [...ABILITY_POOL];
      const out=[];
      while(out.length<n && copy.length){
        const idx = Math.floor(Math.random()*copy.length);
        out.push(copy.splice(idx,1)[0]);
      }
      return out;
    }

    function isCellShielded(cell, shieldPulses){
      if(!shieldPulses || !shieldPulses.length) return false;
      return shieldPulses.some(sp=>{
        if(sp.ttl<=0) return false;
        const d = Math.abs(sp.x-cell.x)+Math.abs(sp.y-cell.y);
        return d <= (sp.radius||2);
      });
    }

    // Per-enemy attack range (no global map snipers)
    function getEnemyRange(e){
      let baseRange = 6;
      switch(e.type){
        case "charger": baseRange = 4; break;
        case "scatter": baseRange = 5; break;
        case "rocket":  baseRange = 8; break;
        case "laser":   baseRange = 7; break;
        case "sniper":  baseRange = 10; break;
        case "storm":   baseRange = 6; break;
        case "voider":  baseRange = 7; break;
        default: baseRange = 6;
      }
      if(e.boss) baseRange += 3;
      if(typeof e.tier === "number") baseRange += Math.min(3, e.tier*0.5);
      return baseRange;
    }

    function beginTelegraph(g,e,players,basePos){
      const cells=[];
      const kindSelect = e.type;
      const range = getEnemyRange(e);

      const clampTarget = (t)=>{
        if(!t) return null;
        return dist(e,t) <= range ? t : null;
      };

      if(kindSelect==="charger"){
        let target = clampTarget(players.length ? nearest(players,e,range) : null);
        if(!target && dist(e,basePos) <= range) target = basePos;
        if(!target) return;
        const dx = Math.sign(target.x - e.x);
        const dy = Math.sign(target.y - e.y);
        const tx = e.x+dx;
        const ty = e.y+dy;
        if(isWalkable(tx,ty)) cells.push({x:tx,y:ty});
        e.aim = {kind:"charger", cells};
        e.telegraph = 2;

      }else if(kindSelect==="scatter"){
        // Always local area around them
        for(let i=0;i<5;i++){
          const rx = e.x + randInt(-2,2);
          const ry = e.y + randInt(-1,1);
          if(isWalkable(rx,ry)) cells.push({x:rx,y:ry});
        }
        e.aim = {kind:"scatter", cells};
        e.telegraph = 3;

      }else if(kindSelect==="rocket"){
        let target = clampTarget(players.length ? nearest(players,e,range) : null);
        if(!target && dist(e,basePos) <= range) target = basePos;
        if(!target) return;
        const targetRow = target.y;
        const maxWidth = Math.min(range, e.x - BASE_COL);
        const startX = e.x-1;
        const endX = Math.max(BASE_COL, e.x - maxWidth);
        for(let x=startX;x>=endX;x--){
          if(isWalkable(x,targetRow)) cells.push({x,y:targetRow});
        }
        e.aim = {kind:"rocket", cells};
        e.telegraph = 3;

      }else if(kindSelect==="laser"){
        const mid = e.y;
        const up = Math.max(1, mid-2);
        const down = Math.min(WORLD_H-2, mid+2);
        for(let yy=up; yy<=down; yy++){
          if(isWalkable(e.x-1,yy)) cells.push({x:e.x-1,y:yy});
        }
        e.aim = {kind:"laser", cells};
        e.telegraph = 3;

      }else if(kindSelect==="sniper"){
        let target = clampTarget(players.length ? nearest(players,e,range) : null);
        if(!target && dist(e,basePos) <= range) target = basePos;
        if(!target) return;
        cells.push({x:target.x,y:target.y});
        e.aim = {kind:"sniper", cells};
        e.telegraph = 4;

      }else if(kindSelect==="storm"){
        const cx = e.x-1;
        const cy = e.y;
        const plus = [
          {x:cx,y:cy},
          {x:cx+1,y:cy},
          {x:cx-1,y:cy},
          {x:cx,y:cy+1},
          {x:cx,y:cy-1}
        ];
        for(const c of plus){
          if(isWalkable(c.x,c.y)) cells.push(c);
        }
        e.aim = {kind:"storm", cells};
        e.telegraph = 3;

      }else if(kindSelect==="voider"){
        const cx = e.x-1;
        const cy = e.y;
        for(let dy=-1;dy<=1;dy++){
          for(let dx=-1;dx<=1;dx++){
            const nx = cx+dx;
            const ny = cy+dy;
            if(isWalkable(nx,ny)) cells.push({x:nx,y:ny});
          }
        }
        e.aim = {kind:"voider", cells};
        e.telegraph = 4;
      }

      for(const c of cells){
        g.dangerCells.push({
          x:c.x,y:c.y,
          type:"telegraph",
          ttl:e.telegraph
        });
      }
    }

    function resolveEnemyAttack(g,e){
      if(!e.aim) return;
      const kind = e.aim.kind;
      const cells = e.aim.cells || [];
      if(!cells.length) return;

      const damagePlayers = (cell,dmg)=>{
        for(const id in latestPlayers){
          const p = latestPlayers[id];
          const px = Math.round(p.x);
          const py = Math.round(p.y);
          if(px===cell.x && py===cell.y){
            let finalD = dmg;
            if(isCellShielded({x:px,y:py}, g.shieldPulses)){
              finalD = Math.ceil(dmg*0.4);
            }
            const maxHp = p.maxHp ?? p.hp ?? 10;
            let hpVal = p.hp ?? maxHp;
            hpVal -= finalD;
            if(hpVal<0) hpVal=0;
            p.hp = hpVal;
          }
        }
        for(const k of g.knights){
          if(k.x===cell.x && k.y===cell.y){
            let finalD = dmg;
            if(isCellShielded({x:k.x,y:k.y}, g.shieldPulses)){
              finalD = Math.ceil(dmg*0.4);
            }
            k.hp -= finalD;
          }
        }
        if(cell.x<=BASE_COL && PATH_ROWS_MAIN.includes(cell.y)){
          let finalD = dmg;
          if(isCellShielded({x:BASE_COL,y:cell.y}, g.shieldPulses)){
            finalD = Math.ceil(dmg*0.4);
          }
          g.base.hp -= finalD;
        }
      };

      if(kind==="charger"){
        const cell = cells[0];
        if(!cell) return;
        damagePlayers(cell,6);
      }else if(kind==="scatter"){
        for(const c of cells){
          damagePlayers(c,4);
          g.dangerCells.push({x:c.x,y:c.y,type:"explosion",ttl:2});
        }
      }else if(kind==="rocket"){
        for(const c of cells){
          damagePlayers(c,5);
          g.dangerCells.push({x:c.x,y:c.y,type:"explosion",ttl:2});
        }
      }else if(kind==="laser"){
        for(const c of cells){
          damagePlayers(c,3);
          g.dangerCells.push({x:c.x,y:c.y,type:"laser",ttl:2});
        }
      }else if(kind==="sniper"){
        const cell = cells[0];
        if(!cell) return;
        damagePlayers(cell,10);
        g.dangerCells.push({x:cell.x,y:cell.y,type:"explosion",ttl:3});
      }else if(kind==="storm"){
        for(const c of cells){
          damagePlayers(c,5);
          g.dangerCells.push({x:c.x,y:c.y,type:"explosion",ttl:2});
        }
      }else if(kind==="voider"){
        for(const c of cells){
          damagePlayers(c,7);
          g.dangerCells.push({x:c.x,y:c.y,type:"explosion",ttl:3});
        }
      }
    }

    async function hostTick(){
      if(!latestGame) return;
      const g = structuredClone(latestGame);
      if(g.status!=="running") return;

      const players = latestPlayers;
      const playerList = Object.values(players);
      const numPlayers = playerList.length || 1;

      g.base = g.base || {hp:100,maxHp:100};
      g.enemies = g.enemies || [];
      g.knights = g.knights || [];
      g.projectiles = g.projectiles || [];
      g.dangerCells = g.dangerCells || [];
      g.shieldPulses = g.shieldPulses || [];

      const derivedStats = {};
      for(const p of playerList){
        derivedStats[p.id] = computeDerivedStats(p);
      }

      const anyBossOrTower = g.enemies.some(e=>e.boss || e.role==="tower");

      // Mobile waves from far right
      if(anyBossOrTower){
        const waveIndex = Math.floor((g.tick||0)/300);
        const spawnChance = 0.08 + 0.04*(numPlayers-1);
        if(Math.random() < spawnChance){
          const laneRows = PATH_ROWS_MAIN;
          const y = laneRows[randInt(0,laneRows.length-1)];
          const x = WORLD_W-2;

          let pool = ["charger","scatter","rocket","laser"];
          if(waveIndex>=2) pool.push("sniper");
          if(waveIndex>=4) pool.push("storm");
          if(waveIndex>=6) pool.push("voider");
          const type = pool[Math.floor(Math.random()*pool.length)];

          const hpBase = 18 + waveIndex*6 + numPlayers*4;
          const enemy = {
            id:`m_${Date.now()}_${Math.random().toString(16).slice(2,6)}`,
            role:"mob",
            mobile:true,
            type,
            x,y,
            hp:Math.round(hpBase),
            maxHp:Math.round(hpBase),
            cd: randInt(5,9),
            telegraph:0,
            aim:null,
            lane:"mid",
            tier:waveIndex+1
          };
          g.enemies.push(enemy);
        }
      }

      // Players move
      for(const p of playerList){
        const cls = CLASSES[p.classIndex ?? 0];
        const speed = (cls?.speed || 1);
        for(let step=0;step<speed;step++){
          const dx = Math.sign((p.targetX??p.x)-p.x);
          const dy = Math.sign((p.targetY??p.y)-p.y);
          if(dx===0 && dy===0) break;
          const nx = p.x + dx;
          const ny = p.y + dy;
          if(isWalkable(nx,ny)){
            p.x = nx; p.y = ny;
          }else break;
        }
      }

      // Knights
      if(g.tick % 18 === 0){
        for(const p of playerList){
          const ds = derivedStats[p.id];
          const spawnY = p.y;
          const kx = BASE_COL;
          const ky = spawnY;
          let baseHp = 10 + (p.knightLevel||1)*3;
          let baseDmg = 3 + (p.knightLevel||1);
          if(ds.knightHpMult) baseHp = Math.round(baseHp * ds.knightHpMult);
          if(ds.knightDmgMult) baseDmg = Math.round(baseDmg * ds.knightDmgMult);

          g.knights.push({
            id:`k_${p.id}_${Date.now()}_${Math.random().toString(16).slice(2,5)}`,
            owner:p.id,
            x:kx,
            y:ky,
            hp:baseHp,
            maxHp:baseHp,
            dmg:baseDmg
          });
        }
      }

      for(const k of g.knights){
        let target = null;
        for(const e of g.enemies){
          if(dist(k,e)<=1){ target=e; break; }
        }
        if(target){
          const dmg = k.dmg || 3;
          target.hp-=dmg;
          if(target.hp<=0) target.dead=true;
        }else{
          const nx = Math.min(WORLD_W-2, k.x+1);
          if(isWalkable(nx,k.y)) k.x = nx;
        }
      }
      g.knights = g.knights.filter(k=>k.hp>0);

      // Enemy AI
      const basePos = {x:BASE_COL, y:5};
      const friendTargets = [];
      for(const p of playerList){
        friendTargets.push({x:p.x,y:p.y, hp:p.hp ?? p.maxHp ?? 1});
      }
      for(const k of g.knights){
        friendTargets.push({x:k.x,y:k.y, hp:k.hp});
      }
      friendTargets.push(basePos);

      for(const e of g.enemies){
        if(e.hp<=0){ e.dead=true; continue; }

        if(e.telegraph>0){
          e.telegraph--;
          if(e.telegraph===0 && e.aim){
            resolveEnemyAttack(g,e);
            e.cd = randInt(5,9);
            e.aim = null;
          }
        }else{
          e.cd = (e.cd || 0) - 1;
          if(e.cd<=0){
            beginTelegraph(g,e,playerList,basePos);
          }
        }

        if(e.role==="mob" && e.telegraph===0){
          const target = nearest(friendTargets, e, 999);
          if(target){
            const dx = Math.sign(target.x - e.x);
            const dy = Math.sign(target.y - e.y);
            let moved=false;
            if(dx!==0 && isWalkable(e.x+dx,e.y)){
              e.x += dx; moved=true;
            }
            if(!moved && dy!==0 && isWalkable(e.x,e.y+dy)){
              e.y += dy; moved=true;
            }

            if(e.x<=BASE_COL && PATH_ROWS_MAIN.includes(e.y)){
              g.base.hp -= 2;
              e.dead = true;
            }
          }
        }
      }
      g.enemies = g.enemies.filter(e=>!e.dead);

      // Ability autos
      for(const p of playerList){
        const ds = derivedStats[p.id];
        if(ds.shieldPulse && g.tick % SHIELD_PERIOD===0){
          g.shieldPulses.push({
            x:p.x,
            y:p.y,
            radius:2,
            ttl:5
          });
        }
        if(ds.nova && g.tick % NOVA_PERIOD===0){
          for(const e of g.enemies){
            if(dist(e,p)<=2 && e.hp>0){
              e.hp -= 4 + (p.level||1);
              if(e.hp<=0) e.dead=true;
            }
          }
          const novaCells = [];
          for(let dy=-2; dy<=2; dy++){
            for(let dx=-2; dx<=2; dx++){
              if(Math.abs(dx)+Math.abs(dy)>2) continue;
              const nx = p.x+dx;
              const ny = p.y+dy;
              if(isWalkable(nx,ny)){
                novaCells.push({x:nx,y:ny});
              }
            }
          }
          for(const c of novaCells){
            g.dangerCells.push({
              x:c.x,y:c.y,type:"explosion",ttl:2
            });
          }
        }
      }
      g.enemies = g.enemies.filter(e=>!e.dead);

      // Player auto-fire & projectiles
      for(const p of playerList){
        const cls = CLASSES[p.classIndex ?? 0];
        if(!cls) continue;
        const ds = derivedStats[p.id];
        const atkSpeedMult = ds.atkSpeedMult || 1;
        const dmgBonus = ds.dmgBonus || 0;
        const attackRoll = 0.35 * atkSpeedMult;
        if(Math.random() < attackRoll){
          const enemy = nearest(g.enemies, p, cls.range || 3);
          if(enemy){
            const dmg = (cls.dmg||2) + dmgBonus;
            g.projectiles.push({
              id:`proj_${Date.now()}_${Math.random().toString(16).slice(2,5)}`,
              x:p.x, y:p.y,
              tx:enemy.x, ty:enemy.y,
              owner:p.id,
              dmg,
              t:0, tMax:4
            });
          }
        }
      }

      for(const proj of g.projectiles){
        proj.t++;
        if(proj.t>=proj.tMax){
          const hit = g.enemies.find(e=>e.x===proj.tx && e.y===proj.ty && !e.dead);
          if(hit){
            hit.hp-=proj.dmg;
            if(hit.hp<=0) hit.dead=true;
          }
          proj.done=true;
        }
      }
      g.enemies = g.enemies.filter(e=>!e.dead);
      g.projectiles = g.projectiles.filter(p=>!p.done);

      // XP / Level
      for(const p of playerList){
        let live = latestPlayers[p.id] || {};
        if(typeof live.xp==="number") p.xp = live.xp;
        if(typeof live.level==="number") p.level = live.level;
        if(typeof live.nextLevelXp==="number") p.nextLevelXp = live.nextLevelXp;
        if(live.abilities) p.abilities = live.abilities;

        const anyNear = g.enemies.some(e=>dist(e,p)<=4);
        if(anyNear) p.xp = (p.xp||0)+0.3;

        if(p.xp >= (p.nextLevelXp||10)){
          p.xp -= p.nextLevelXp;
          p.level = (p.level||1)+1;
          p.nextLevelXp = Math.round((p.nextLevelXp||10)*1.35);
          if(p.level % 5 === 0){
            const options = pickRandomAbilities(3);
            p.pendingChoice = { options, pickedIndex:null };
          }
        }
      }

      // Decay telegraphs & shields
      g.dangerCells = (g.dangerCells||[]).map(dc=>({ ...dc, ttl:dc.ttl-1 })).filter(dc=>dc.ttl>0);
      g.shieldPulses = (g.shieldPulses||[]).map(sp=>({ ...sp, ttl:sp.ttl-1 })).filter(sp=>sp.ttl>0);

      const towersAlive = g.enemies.some(e=>e.boss || e.role==="tower");
      if(g.base.hp<=0){
        g.status = "defeat";
      }else if(!towersAlive && g.enemies.length===0){
        g.status = "victory";
      }

      g.tick = (g.tick||0)+1;
      await setDoc(gameRef,g,{merge:true});

      for(const p of playerList){
        const baseLive = latestPlayers[p.id] || {};
        const liveMaxHp = baseLive.maxHp ?? p.maxHp ?? baseLive.hp ?? p.hp ?? 10;
        let hp = baseLive.hp ?? p.hp ?? liveMaxHp;
        let maxHp = liveMaxHp;

        if(baseLive.abilities){
          if(baseLive.abilities.some(a=>a.effect?.regen)){
            hp = Math.min(maxHp, hp+0.05);
          }
        }
        hp = Math.min(maxHp, hp);

        await setDoc(doc(db,"games_trumprev",gameId,"players",p.id),{
          x:p.x, y:p.y,
          hp, maxHp,
          level:p.level||1,
          xp:p.xp||0,
          nextLevelXp:p.nextLevelXp||10,
          pendingChoice:p.pendingChoice||baseLive.pendingChoice||null,
          lastUpdated:serverTimestamp()
        },{merge:true});
      }

      if(g.status==="defeat"){
        stopHostLoop();
        log("Base destroyed! Defeat.");
      }else if(g.status==="victory"){
        stopHostLoop();
        log("All towers and waves cleared! Victory.");
      }
    }

    // --- RENDERING ---
    function renderBase(){
      if(!latestGame) return;
      const baseHpFill = document.getElementById("baseHpFill");
      const hp = latestGame.base?.hp ?? 0;
      const max = latestGame.base?.maxHp ?? 1;
      const pct = Math.max(0,Math.min(100,(hp/max)*100));
      baseHpFill.style.width = pct+"%";
    }

    function renderBoard(){
      if(!latestGame) return;
      const cam = getCamera();
      const left = cam.left;
      const top = cam.top;

      // Clear & paint terrain
      for(let vy=0;vy<VIEW_H;vy++){
        for(let vx=0;vx<VIEW_W;vx++){
          const cell = cells[vy][vx];
          cell.innerHTML = "";
          cell.className = "cell";

          const wx = left + vx;
          const wy = top + vy;

          if(wx>=0 && wx<WORLD_W && wy>=0 && wy<WORLD_H){
            const t = terrain[wy][wx];
            if(t==="terrain") cell.classList.add("cell-terrain");
            if(t==="path") cell.classList.add("cell-path");
            if(t==="base") cell.classList.add("cell-base");
          }
        }
      }

      const dcs = latestGame.dangerCells || [];
      for(const dc of dcs){
        const vx = dc.x - left;
        const vy = dc.y - top;
        if(vx<0||vx>=VIEW_W||vy<0||vy>=VIEW_H) continue;
        const cell = cells[vy][vx];
        let overlay;
        if(dc.type==="telegraph"){
          overlay = document.createElement("div");
          overlay.className="danger-telegraph";
        }else if(dc.type==="explosion"){
          overlay = document.createElement("div");
          overlay.className="danger-explosion";
        }else if(dc.type==="laser"){
          overlay = document.createElement("div");
          overlay.className="laser-line";
        }
        if(overlay) cell.appendChild(overlay);
      }

      for(const sp of (latestGame.shieldPulses||[])){
        const vx = sp.x - left;
        const vy = sp.y - top;
        if(vx<0||vx>=VIEW_W||vy<0||vy>=VIEW_H) continue;
        const cell = cells[vy][vx];
        const ring = document.createElement("div");
        ring.className="shield-ring";
        cell.appendChild(ring);
      }

      // Base icons near left
      for(let y of PATH_ROWS_MAIN){
        for(let x=0;x<=BASE_COL;x++){
          const vx = x - left;
          const vy = y - top;
          if(vx<0||vx>=VIEW_W||vy<0||vy>=VIEW_H) continue;
          const cell = cells[vy][vx];
          const ent = document.createElement("div");
          ent.className="entity";
          ent.textContent = "üè∞";
          cell.appendChild(ent);
        }
      }

      // Knights
      for(const k of (latestGame.knights||[])){
        if(k.hp<=0) continue;
        const vx = Math.round(k.x - left);
        const vy = Math.round(k.y - top);
        if(vx<0||vx>=VIEW_W||vy<0||vy>=VIEW_H) continue;
        const cell = cells[vy][vx];
        const ent = document.createElement("div");
        ent.className="entity";
        ent.textContent = "‚öîÔ∏è";
        cell.appendChild(ent);

        const hpBar = document.createElement("div");
        hpBar.className="hp-chip";
        const fill = document.createElement("div");
        fill.className="hp-chip-fill";
        const maxHp = k.maxHp ?? k.hp ?? 1;
        const hp = Math.min(maxHp, k.hp ?? maxHp);
        const pct = Math.max(0,Math.min(100,(hp/maxHp)*100));
        fill.style.width = pct+"%";
        hpBar.appendChild(fill);
        cell.appendChild(hpBar);
      }

      // Enemies (towers + mobs)
      for(const e of (latestGame.enemies||[])){
        if(e.hp<=0) continue;
        const vx = Math.round(e.x - left);
        const vy = Math.round(e.y - top);
        if(vx<0||vx>=VIEW_W||vy<0||vy>=VIEW_H) continue;
        const cell = cells[vy][vx];
        const ent = document.createElement("div");
        ent.className="entity";
        let emoji="üëæ";
        if(e.type==="charger") emoji = e.role==="tower" ? "üóº" : "üêó";
        else if(e.type==="scatter") emoji="üí£";
        else if(e.type==="rocket") emoji="üöÄ";
        else if(e.type==="laser") emoji="üî∫";
        else if(e.type==="sniper") emoji="üéØ";
        else if(e.type==="storm") emoji="üå©Ô∏è";
        else if(e.type==="voider") emoji = e.boss ? "üëë" : "üï≥Ô∏è";
        ent.textContent = emoji;
        cell.appendChild(ent);

        const hpBar = document.createElement("div");
        hpBar.className="hp-chip";
        const fill = document.createElement("div");
        fill.className="hp-chip-fill";
        const maxHp = e.maxHp ?? e.hp ?? 1;
        const hp = Math.min(maxHp, e.hp ?? maxHp);
        const pct = Math.max(0,Math.min(100,(hp/maxHp)*100));
        fill.style.width = pct+"%";
        hpBar.appendChild(fill);
        cell.appendChild(hpBar);
      }

      // Projectiles (friendly)
      for(const proj of (latestGame.projectiles||[])){
        const tMax = proj.tMax || 1;
        const tNow = Math.min(proj.t || 0, tMax);
        const prog = tNow / tMax;
        const wx = Math.round(proj.x + (proj.tx - proj.x)*prog);
        const wy = Math.round(proj.y + (proj.ty - proj.y)*prog);
        const vx = wx - left;
        const vy = wy - top;
        if(vx<0||vx>=VIEW_W||vy<0||vy>=VIEW_H) continue;
        const cell = cells[vy][vx];
        const ent = document.createElement("div");
        ent.className="entity proj-friendly";
        ent.textContent = "‚óè";
        cell.appendChild(ent);
      }

      // Players
      for(const id in latestPlayers){
        const p = latestPlayers[id];
        const wx = Math.round(p.x);
        const wy = Math.round(p.y);
        const vx = wx - left;
        const vy = wy - top;
        if(vx<0||vx>=VIEW_W||vy<0||vy>=VIEW_H) continue;
        const cell = cells[vy][vx];
        const ent = document.createElement("div");
        ent.className="entity";
        const cls = CLASSES[p.classIndex ?? 0];
        const emoji = cls?.emoji || "üßç";
        ent.textContent = emoji;
        if(id===username) cell.classList.add("cell-highlight");
        cell.appendChild(ent);

        const hpBar = document.createElement("div");
        hpBar.className="hp-chip";
        const fill = document.createElement("div");
        fill.className="hp-chip-fill";
        const maxHp = p.maxHp ?? p.hp ?? 1;
        const hp = Math.min(maxHp, p.hp ?? maxHp);
        const pct = Math.max(0,Math.min(100,(hp/maxHp)*100));
        fill.style.width = pct+"%";
        hpBar.appendChild(fill);
        cell.appendChild(hpBar);
      }

      // HUD for your HP + XP + abilities
      if(localPlayerState){
        const lvl = localPlayerState.level||1;
        const xp = localPlayerState.xp||0;
        const nxp = localPlayerState.nextLevelXp||10;
        document.getElementById("levelLabel").textContent = `Lv ${lvl}`;
        document.getElementById("xpLabel").textContent = `(${Math.round(xp)} / ${nxp} XP)`;

        const pMax = localPlayerState.maxHp ?? localPlayerState.hp ?? 1;
        const pHp = Math.min(pMax, localPlayerState.hp ?? pMax);
        const pPct = Math.max(0,Math.min(100,(pHp/pMax)*100));
        document.getElementById("playerHpFill").style.width = pPct+"%";

        renderAbilities(localPlayerState);
      }
    }

    function renderAbilities(p){
      const bar = document.getElementById("abilitiesBar");
      bar.innerHTML = "";
      const label = document.createElement("span");
      label.className="small";
      label.textContent = "Abilities";
      bar.appendChild(label);

      const abilities = p.abilities || [];
      const tick = latestGame?.tick ?? 0;

      for(const a of abilities){
        const tile = document.createElement("div");
        tile.className="ability-tile";

        const iconSpan = document.createElement("span");
        iconSpan.textContent =
          a.key==="rapidfire" ? "‚ö°" :
          a.key==="powershot" ? "üí•" :
          a.key==="barrierPulse" ? "üõ°Ô∏è" :
          a.key==="knightBoost" ? "‚öîÔ∏è" :
          a.key==="regenAura" ? "‚ûï" :
          a.key==="blastNova" ? "üí£" : "‚òÖ";

        const cdOverlay = document.createElement("div");
        cdOverlay.className="ability-cooldown";

        let ratio = 0;
        if(a.effect?.shieldPulse){
          const rem = SHIELD_PERIOD - (tick % SHIELD_PERIOD);
          ratio = rem / SHIELD_PERIOD;
        }else if(a.effect?.nova){
          const rem = NOVA_PERIOD - (tick % NOVA_PERIOD);
          ratio = rem / NOVA_PERIOD;
        }else{
          ratio = 0;
        }
        cdOverlay.style.transform = `scaleY(${Math.min(1,Math.max(0,ratio))})`;

        tile.appendChild(cdOverlay);
        tile.appendChild(iconSpan);
        bar.appendChild(tile);
      }
    }

    // --- INPUT: TAP TO MOVE (viewport -> world) ---
    async function onCellClick(vx,vy){
      if(!localPlayerState) return;
      const cam = getCamera();
      const wx = cam.left + vx;
      const wy = cam.top + vy;
      if(!isWalkable(wx,wy)) return;
      try{
        await setDoc(playerRef,{
          targetX:wx,
          targetY:wy,
          lastInputAt:Date.now()
        },{merge:true});
      }catch(e){
        console.error(e);
      }
    }

    // --- LEVEL-UP MODAL ---
    function checkLevelUpModal(){
      if(!localPlayerState) return;
      const pending = localPlayerState.pendingChoice;
      const modal = document.getElementById("levelModal");
      const optionsBox = document.getElementById("modalOptions");
      if(pending && pending.options && pending.options.length && (pending.pickedIndex==null)){
        modal.style.display="flex";
        optionsBox.innerHTML = "";
        pending.options.forEach((opt,idx)=>{
          const btn = document.createElement("button");
          btn.type="button";
          btn.className="option-btn";
          btn.innerHTML = `<div class="option-title">${opt.name}</div><div class="option-desc">${opt.desc}</div>`;
          btn.onclick = ()=> chooseAbility(idx, opt);
          optionsBox.appendChild(btn);
        });
      }else{
        modal.style.display="none";
      }
    }

    async function chooseAbility(index, ability){
      try{
        const pSnap = await getDoc(playerRef);
        if(!pSnap.exists()) return;
        const p = pSnap.data();
        const abilities = p.abilities || [];
        abilities.push(ability);
        await setDoc(playerRef,{
          abilities,
          pendingChoice:{
            options:p.pendingChoice?.options || [],
            pickedIndex:index
          }
        },{merge:true});
        log(`Gained ability: ${ability.name}`);
      }catch(e){
        console.error(e);
      }
    }

    // --- FULLSCREEN ---
    document.getElementById("fullscreenBtn").addEventListener("click",()=>{
      const el = document.documentElement;
      if(!document.fullscreenElement){
        el.requestFullscreen?.();
      }else{
        document.exitFullscreen?.();
      }
    });

    // --- START ---
    joinGame().catch(err=>{
      console.error(err);
      alert("Error joining game: "+err.message);
    });
  </script>
</body>
</html>




