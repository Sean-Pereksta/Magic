<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ğŸ­ Cat vs Mouse</title>

<style>
  body {
    font-family: sans-serif;
    text-align: center;
    background: #f4f4f4;
    margin: 0;
    padding: 0;
  }

  h1 {
    margin: 10px 0;
  }

  #cheeseDisplay {
    font-size: 18px;
    font-weight: bold;
    margin: 10px 0;
    color: #333;
  }

  #grid {
    display: grid;
    justify-content: center;
    grid-template-columns: repeat(30, 20px);
    grid-template-rows: repeat(30, 20px);
    margin: 0 auto;
    position: relative;
    z-index: 0;
  }
  #gridWrapper {
  width: 400px;  /* 20 columns * 20px each */
  height: 400px; /* 20 rows * 20px each */
  border: 3px solid black;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 0 auto;
  background: #eaeaea;
}

#grid {
  display: grid;
  /* These will still be set dynamically */
}


  .cell {
    width: 20px;
    height: 20px;
    text-align: center;
    font-size: 16px;
    position: relative;
    background: #c8f7c5;
  }

  .name {
    font-size: 10px;
    position: absolute;
    top: -12px;
    left: 0;
    right: 0;
    text-align: center;
  }

  .health-bar {
    position: absolute;
    top: -6px;
    left: 0;
    height: 3px;
    background-color: red;
    border-radius: 1px;
  }

  #catHealthContainer {
    margin-top: 10px;
  }

  #catHealthBar {
    height: 20px;
    width: 300px;
    background: lightgray;
    position: relative;
    border-radius: 8px;
    margin: 0 auto;
  }

  #catHealthFill {
    height: 100%;
    width: 100%;
    background: red;
    border-radius: 8px;
  }

  #catHealthText {
    position: absolute;
    width: 100%;
    top: 0;
    text-align: center;
    font-weight: bold;
  }
  .ox-raging {
  box-shadow: 0 0 10px 4px red;
  border-radius: 4px;
}


  #mobileControls {
    display: none;
    margin: 15px auto;
    z-index: 10;
    position: relative;
  }

   button, select {
    font-size: 20px;       /* ğŸ” Bigger text */
    padding: 14px 20px;    /* ğŸ”³ Larger tap area */
    margin: 6px;
  }

  html, body {
  touch-action: manipulation;
}
  
  @media (max-width: 768px) {
    #mobileControls {
      display: block;
    }

    #grid {
      margin-top: 10px;
    }

    #cheeseDisplay {
      font-size: 20px;
    }
  }
</style>


<body>
<h1 style="text-align: center;">ğŸ± Cat vs ğŸ­ Mouse</h1>

<!-- ğŸ§° Build Options & Controls -->
<div style="text-align: center; margin-bottom: 10px;">
  <p style="margin: 5px 0; font-size: 14px; color: #444;">
    ğŸ® Arrow keys to move | A/W/S/D to build | 1â€“7 to select building | Space = Upgrade Menu
  </p>
<p id="buildInfo" style="margin: 10px 0; font-size: 13px; font-weight: bold; color: #333;"></p>


</div>
<!-- ğŸ”™ Return Button -->
<div id="returnButton" style="display:none; margin-top: 20px; text-align: center;">
  <button onclick="returnToLobby()" style="padding: 10px 20px; font-size: 16px;">ğŸ”™ Return to Lobby</button>
</div>

<!-- ğŸ€ Wave Countdown -->
<div id="waveCountdown">ğŸ€ Next wave: ?</div>



<!-- ğŸ”² Main Game + Sidebar Layout -->
<div style="display: flex; justify-content: center; align-items: flex-start; gap: 20px; margin-top: 20px;">

  <!-- ğŸ“Š Left Sidebar -->
  <div style="width: 200px; font-size: 14px;">
    <p><strong>ğŸ§€ Cheese:</strong> <span id="cheeseCount">0</span></p>
    <p><strong>âš¡ Advancement Points:</strong> <span id="advPoints">0</span></p>
    <p><strong>ğŸ”¨ Selected Build:</strong> <span id="buildType">None</span></p>
    <div id="abilityStatus" style="margin-top: 10px;"></div>
    <p id="advPointMessage" style="color: green; font-weight: bold; display: none; margin: 5px 0;">
      ğŸŸ¢ You gained an advancement point!
    </p>
    <p id="status"></p>
    <div id="playerStatus" style="margin-top: 10px;"></div>
    <div id="hostDisplay" style="margin-top: 10px; font-weight: bold; color: #333;"></div>


    <!-- ğŸ”§ Upgrade Menu -->
    <div id="upgradeMenu" style="display:none; background:#eee; border:2px solid #888; padding:10px; margin-top:10px;">
      <h3>ğŸ”§ Upgrade Menu</h3>
      <div id="mobileUpgradeButtons" style="margin: 10px 0;"></div>
      <p><b>1</b> â€“ ğŸƒ <strong>Speedster</strong><br>
         <b>2</b> â€“ ğŸ§€ <strong>Scavenger</strong><br>
         <b>3</b> â€“ ğŸ <strong>Flea Master</strong><br>
         <b>4</b> â€“ ğŸ§± <strong>Wall Master</strong><br>
         <b>5</b> â€“ ğŸª¤ <strong>Trapmaster</strong><br>
         <b>6</b> â€“ ğŸŒ€ <strong>Blink</strong></p>
      <p>Chosen: <span id="chosenUpgrades"></span></p>
    </div>
  </div>

  <!-- ğŸ® Main Game Grid + Controls -->
  <div>
    <div id="gridWrapper">
  <div id="grid"></div>
</div>


  <!-- ğŸ“± Mobile Controls -->
<div id="mobileControls" style="margin-top: 20px; display: none;">
  <!-- Movement -->
  <div style="margin-bottom: 12px;">
    <div>
      <button data-move="up" aria-label="Move Up">â¬†ï¸</button><br>
      <button data-move="left" aria-label="Move Left">â¬…ï¸</button>
      <button data-move="down" aria-label="Move Down">â¬‡ï¸</button>
      <button data-move="right" aria-label="Move Right">â¡ï¸</button>
    </div>
  </div>

  <!-- Build Placement -->
  <div style="margin-bottom: 12px;">
    <div>
      <button data-place="w" aria-label="Build Up">â¬†ï¸ Build</button>
      <button data-place="a" aria-label="Build Left">â¬…ï¸</button>
      <button data-place="s" aria-label="Build Down">â¬‡ï¸</button>
      <button data-place="d" aria-label="Build Right">â¡ï¸</button>
    </div>
  </div>

  <!-- Mode Toggle -->
  <div style="margin-bottom: 12px;">
    <button onclick="toggleMobileMode()">ğŸ” Switch to Upgrades</button>
  </div>

  <!-- Structure Buttons -->
 <div id="structureButtons" style="margin-top: 10px;">
  <strong>Select Structure:</strong><br>
  <button>ğŸ§±</button>
  <button>ğŸ”«</button>
  <button>ğŸª³</button>
  <button>ğŸ­</button>
  <button>ğŸ’</button>
  <button>ğŸ—¼</button>
  <button>ğŸ¦â€ğŸ”¥</button>
</div>


  <!-- Upgrade Buttons -->
  <div id="upgradeButtons" style="display: none; margin-bottom: 12px;">
    <strong>Upgrades:</strong><br>
    <button onclick="selectUpgrade('1')">1 â€“ Speedster</button>
    <button onclick="selectUpgrade('2')">2 â€“ Scavenger</button>
    <button onclick="selectUpgrade('3')">3 â€“ Flea Master</button>
    <button onclick="selectUpgrade('4')">4 â€“ Wall Master</button>
    <button onclick="selectUpgrade('5')">5 â€“ Trapmaster</button>
    <button onclick="selectUpgrade('6')">6 â€“ Blink</button>
  </div>

  <!-- Special Actions -->
  <div>
    <button data-upgrade>ğŸ› ï¸ Upgrades</button>
    <button data-blink>ğŸŒ€ Blink</button>
    <button data-trap>ğŸª¤ Trap</button>
  </div>
</div>


    <!-- â¤ï¸ Cat Health Bar -->
    <div id="catHealthContainer" style="margin-top: 10px;">
      <div id="catHealthBar" style="height: 20px; width: 300px; background: lightgray; position: relative; margin: 0 auto; border-radius: 8px;">
        <div id="catHealthFill" style="height: 100%; width: 100%; background: red; border-radius: 8px;"></div>
        <div id="catHealthText" style="position: absolute; width: 100%; top: 0; text-align: center; font-weight: bold;">
          â¤ï¸ 1000 / 1000
        </div>
      </div>
    </div>
  </div>
</div>




<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getFirestore,
  doc,
  getDoc,
  setDoc,
  updateDoc,
  deleteDoc, // ğŸ‘ˆ ADD THIS
  onSnapshot,
  collection,
  getDocs,
  increment
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";


const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

const urlParams = new URLSearchParams(window.location.search);
const gameId = urlParams.get("gameId");
let username = urlParams.get("username");
  username = username.trim().toLowerCase(); // âœ… Normalize once


const gridSize = 30;
const gridElement = document.getElementById("grid");
let grid = [];
  let gameData = {};

const structureClasses = {
  defender: {
    label: "ğŸ›¡ Defender",
    defense: ["ğŸ’", "ğŸŒ³", "ğŸŒ¿"],
    economic: ["ğŸ—¼", "ğŸ­"],
    attack: ["ğŸ”«"]
  },
  engineer: {
    label: "ğŸ”§ Engineer",
    defense: ["ğŸ§±", "ğŸ’"],
    economic: ["ğŸ­", "ğŸ—¼", "ğŸ¦â€ğŸ”¥", "âš™ï¸"],
    attack: ["ğŸª³", "ğŸš€"]
  },
  striker: {
    label: "âš” Striker",
    defense: ["ğŸ§±", "ğŸ’", "ğŸŒ³", "ğŸŒ¿"],
    economic: ["ğŸ¦â€ğŸ”¥", "ğŸ­"],
    attack: ["ğŸ”«", "ğŸš€", "ğŸª³"]
  }
};
  const structureInfo = {
  "ğŸ§±": { cost: 1, health: 15 },
  "ğŸ”«": { cost: 3, health: 5 },
  "ğŸª³": { cost: 5, health: 10 },
  "ğŸ­": { cost: 4, health: 5 },
  "ğŸ’": { cost: 6, health: 75 },
  "ğŸ—¼": { cost: 24, health: 25 },
  "ğŸ¦â€ğŸ”¥": { cost: 40, health: 20 },
  "ğŸš€": { cost: 30, health: 20 },
  "ğŸŒ³": { cost: 20, health: 20 },
  "ğŸŒ¿": { cost: 4, health: 9 }  // vine wall
};
  const buildNames = {
  "ğŸ§±": "Wall ğŸ§± (Cost: 1)",
  "ğŸ”«": "Turret ğŸ”« (Cost: 3)",
  "ğŸª³": "Flea Nest ğŸª³ (Cost: 5)",
  "ğŸ­": "Cheese Generator ğŸ­ (Cost: 4)",
  "ğŸ’": "Super Wall ğŸ’ (Cost: 6)",
  "ğŸ—¼": "Cheese Beacon ğŸ—¼ (Cost: 24)",
  "ğŸ¦â€ğŸ”¥": "Phoenix Cheese ğŸ¦â€ğŸ”¥ (Cost: 40)",
  "ğŸš€": "Rocket Tower ğŸš€ (Cost: 30)",
  "ğŸŒ³": "Oak Tree ğŸŒ³ (Cost: 20)",
  "ğŸŒ¿": "Vine Wall ğŸŒ¿ (Cost: 4)"
};



let playerPos = { x: 1, y: 1 };
let catPos = { x: 15, y: 15 };
let gameStarted = false;
let selectedBuild = null;
let cheeseCount = 0;
let isAlive = true;
let catHealth = 1000;
let players = {};
let isHost = false;
let canMove = true;
const moveCooldown = 225;
let catPower = 0;
let catMoveInterval = null;
let ratPower = 1;

let advancementPoints = 0;
let upgradeMenuOpen = false;
let selectedUpgrades = []; // âœ… Only one declaration
let fleaSpawnCooldown = 1500;
let fleaMasterActive = false;
let cheesePickupBonus = 0;
let wallMasterActive = false;
let hostInitialized = false;
  let trapmasterActive = false;
let lastTrapTime = 0;
  let squirrels = []; // ğŸ¿ï¸ Friendly units


let blinkActive = false;
let lastBlinkTime = 0;
let lastDirection = { dx: 0, dy: 0 }; // Tracks arrow key direction
  let showingUpgrades = false;
  let localRatTimer = 40;
  let ratSpawnIntervalStarted = false;
  let currentRatWave = null;


let structureHealth = {}; // key: "x_y", value: health
let fleas = [];
  let rats = []; // ğŸ€
  let termites = []; // ğŸ›
  let traps = []; // Each: {x, y, placedAt}
  let oxen = [];
  let isRatSpawning = false;








for (let y = 0; y < gridSize; y++) {
  grid[y] = [];
  for (let x = 0; x < gridSize; x++) {
    const cell = document.createElement("div");
    cell.className = "cell";
    cell.id = `cell-${x}-${y}`;
    gridElement.appendChild(cell);
    grid[y][x] = "";
  }
}

function renderGrid() {
  const viewSize = 20;
  const halfView = Math.floor(viewSize / 2);
  const viewport = document.getElementById("grid");
  viewport.innerHTML = ""; // Clear old cells

  // Force grid to always be 20x20 visual size
  viewport.style.gridTemplateColumns = `repeat(${viewSize}, 20px)`;
  viewport.style.gridTemplateRows = `repeat(${viewSize}, 20px)`;
  viewport.style.width = "400px";
  viewport.style.height = "400px";

  const centerX = playerPos.x;
  const centerY = playerPos.y;
  const startX = centerX - halfView;
  const startY = centerY - halfView;

  const generatorTriggers = new Set();
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      if (grid[y][x] === "ğŸ­") {
        for (const p of Object.values(players)) {
          if (p.alive !== false) {
            const dx = Math.abs(p.x - x);
            const dy = Math.abs(p.y - y);
            if (dx + dy <= 9) {
              generatorTriggers.add(`${x}_${y}`);
              break;
            }
          }
        }
      }
    }
  }

  const beaconBoosted = new Set();
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      if (grid[y][x] === "ğŸ—¼") {
        for (let dy = -2; dy <= 2; dy++) {
          for (let dx = -2; dx <= 2; dx++) {
            const tx = x + dx;
            const ty = y + dy;
            if (tx >= 0 && tx < gridSize && ty >= 0 && ty < gridSize) {
              const tSymbol = grid[ty][tx];
              if (["ğŸ”«", "ğŸ­", "ğŸª³", "ğŸš€"].includes(tSymbol)) {
                beaconBoosted.add(`${tx}_${ty}`);
              }
            }
          }
        }
      }
    }
  }

  for (let row = 0; row < viewSize; row++) {
    for (let col = 0; col < viewSize; col++) {
      const x = startX + col;
      const y = startY + row;
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.id = `cell-${x}-${y}`;

      if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
        const key = `${x}_${y}`;
        const symbol = grid[y][x];

        if (beaconBoosted.has(key)) {
          cell.style.background = "#ff8a8a";
        } else if (generatorTriggers.has(key)) {
          cell.style.background = "#fff977";
        } else {
          cell.style.background = "#c8f7c5";
        }

        cell.textContent = symbol === "ğŸ—¼" ? "ğŸ—¼" : symbol;
      } else {
        cell.style.background = "#888"; // Out-of-bounds
        cell.textContent = "";
      }

      viewport.appendChild(cell);
    }
  }

  // ğŸ­ Players
  for (const name in players) {
    const p = players[name];
    if (!p.alive) continue;
    const cell = document.getElementById(`cell-${p.x}-${p.y}`);
    if (cell) {
      cell.textContent = "ğŸ­";
      const nameTag = document.createElement("div");
      nameTag.className = "name";
      nameTag.textContent = name;
      cell.appendChild(nameTag);
    }
  }

  // ğŸ Fleas
  for (const flea of fleas) {
    const cell = document.getElementById(`cell-${flea.x}-${flea.y}`);
    if (cell) cell.textContent = "ğŸ";
  }
  for (const s of squirrels) {
  const cell = document.getElementById(`cell-${s.x}-${s.y}`);
  if (cell) cell.textContent = "ğŸ¿ï¸";
}
// ğŸ¤– Catcher Bots (colored by phase)
for (const bot of catcherBots) {
  const cell = document.getElementById(`cell-${bot.x}-${bot.y}`);
  if (cell) {
    cell.textContent = "ğŸ¤–";
    cell.style.backgroundColor = bot.phase === "toRat" ? "#ff9999" : "#99ccff"; // red or blue
  }
}



  // ğŸ€ Rats
  for (const rat of rats) {
    if (rat.health <= 0) continue;
const cell = document.getElementById(`cell-${rat.x}-${rat.y}`);

    if (cell) {
      cell.textContent = "ğŸ€";
      const healthTag = document.createElement("div");
      healthTag.className = "name";
      healthTag.style.color = "brown";
      healthTag.textContent = `â¤ï¸${rat.health}`;
      cell.appendChild(healthTag);
    }
  }

  // ğŸ‚ Oxen
for (const ox of oxen) {
  const cell = document.getElementById(`cell-${ox.x}-${ox.y}`);
  if (cell) {
    cell.textContent = "ğŸ‚";

    // ğŸ”¥ Add red aura if raging
    if (ox.rageUntil && Date.now() < ox.rageUntil) {
      cell.classList.add("ox-raging");
    } else {
      cell.classList.remove("ox-raging");
    }

    // â¤ï¸ Health display
    const hpTag = document.createElement("div");
    hpTag.className = "name";
    hpTag.style.color = "orange";
    hpTag.textContent = `â¤ï¸${ox.health}`;
    cell.appendChild(hpTag);
  }
}



  // ğŸ› Termites
  for (const termite of termites) {
    const cell = document.getElementById(`cell-${termite.x}-${termite.y}`);

    if (cell) cell.textContent = "ğŸ›";
  }

  // ğŸ§± ğŸª³ ğŸ’ Structure health bars
  for (let key in structureHealth) {
    const [xStr, yStr] = key.split("_");
    const x = parseInt(xStr), y = parseInt(yStr);
    const symbol = grid[y][x];
    const cell = document.getElementById(`cell-${x}-${y}`);
    if (cell && ["ğŸ§±", "ğŸª³", "ğŸ’", "ğŸš€"].includes(symbol)) {
      const bar = document.createElement("div");
      bar.className = "health-bar";
      const hp = structureHealth[key];
      bar.style.width = `${Math.max(10, Math.min(100, hp * 3))}%`;
      bar.style.background = symbol === "ğŸ’" ? "blue" : (symbol === "ğŸ§±" ? "gray" : "purple");
      bar.style.height = "3px";
      bar.style.marginTop = "-10px";
      cell.appendChild(bar);
    }
  }

  // ğŸ± Cat
const catCell = document.getElementById(`cell-${catPos.x}-${catPos.y}`);
  if (catCell) {
    catCell.textContent = "ğŸ±";
    const levelTag = document.createElement("div");
    levelTag.className = "name";
    levelTag.style.color = "red";
    levelTag.innerHTML = `âš¡Lv.${catPower}`;
    catCell.appendChild(levelTag);

    const bar = document.createElement("div");
    bar.className = "health-bar";
    const barWidth = Math.max(10, Math.min(100, (catHealth / (catPower * 10)) * 100));
    bar.style.width = `${barWidth}%`;
    bar.style.background = "red";
    bar.style.height = "3px";
    bar.style.marginTop = "-10px";
    catCell.appendChild(bar);
  }

  // ğŸ§ Player Status
  const statusDiv = document.getElementById("playerStatus");
  statusDiv.innerHTML = "";
  for (const name in players) {
    const p = players[name];
    const statusSpan = document.createElement("span");
    statusSpan.style.marginRight = "10px";
    statusSpan.style.fontWeight = "bold";
    statusSpan.style.color = p.alive ? "green" : "red";
    statusSpan.textContent = `${name}: ${p.alive ? "ALIVE" : "DEAD"}`;
    statusDiv.appendChild(statusSpan);
  }
}


function updateHostDisplay() {
  const hostName = gameData?.host || "Unknown";
  document.getElementById("hostDisplay").textContent = `ğŸ‘‘ Host: ${hostName}`;
}


async function movePlayer(dx, dy) {
  if (!gameStarted || !isAlive) return;

  const newX = Math.max(0, Math.min(gridSize - 1, playerPos.x + dx));
  const newY = Math.max(0, Math.min(gridSize - 1, playerPos.y + dy));

  playerPos = { x: newX, y: newY };
  savePosition();

  // ğŸŒ¿ Destroy vine on contact
  if (grid[newY][newX] === "ğŸŒ¿") {
    grid[newY][newX] = "";
    const key = `${newX}_${newY}`;
    delete structureHealth[key];
    await deleteDoc(doc(db, `games/${gameId}/structures/${key}`));
  }

  checkCheese();
  renderGrid();
}

async function spawnRatWave() {
  if (!isHost || catPower <= 0) return;

  const waveTag = Date.now();
  currentRatWave = waveTag;

  const allOffsets = [
    { x: 0, y: 0 }, { x: 1, y: 0 }, { x: -1, y: 0 },
    { x: 0, y: 1 }, { x: 0, y: -1 }, { x: 1, y: 1 },
    { x: -1, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 1 },
    { x: 2, y: 0 }, { x: 0, y: 2 }, { x: -2, y: 0 }, { x: 0, y: -2 },
    { x: 2, y: 1 }, { x: 1, y: 2 }, { x: -1, y: 2 }, { x: -2, y: 1 },
    { x: -2, y: -1 }, { x: -1, y: -2 }, { x: 1, y: -2 }, { x: 2, y: -1 }
  ];

  const availableSpots = allOffsets
    .map(offset => ({ x: catPos.x + offset.x, y: catPos.y + offset.y }))
    .filter(pos =>
      pos.x >= 0 && pos.x < gridSize &&
      pos.y >= 0 && pos.y < gridSize &&
      grid[pos.y][pos.x] === "" &&
      !rats.some(r => r.x === pos.x && r.y === pos.y) &&
      !oxen.some(o => o.x === pos.x && o.y === pos.y)
    );

  const usedKeys = new Set();

  // ğŸ‚ OXEN â€“ spawn earlier at catPower >= 14
  const oxCount = catPower >= 14 ? Math.floor((catPower - 5) / 10) + 1 : 0;
  let oxSpawned = 0;
  for (let i = 0; i < availableSpots.length && oxSpawned < oxCount; i++) {
    const spot = availableSpots[i];
    const key = `${spot.x}_${spot.y}`;
    if (usedKeys.has(key)) continue;
    usedKeys.add(key);

    const id = `ox_${crypto.randomUUID()}`;
    const ox = { x: spot.x, y: spot.y, health: ratPower * 35, id };
    await setDoc(doc(db, `games/${gameId}/oxen/${id}`), ox);
    oxSpawned++;
  }

  // ğŸ€ RATS
  const maxRats = catPower;
  let ratsSpawned = 0;
  for (let i = 0; i < availableSpots.length && ratsSpawned < maxRats; i++) {
    const spot = availableSpots[i];
    const key = `${spot.x}_${spot.y}`;
    if (usedKeys.has(key)) continue;
    usedKeys.add(key);

    const id = `rat_${crypto.randomUUID()}`;
    const rat = { x: spot.x, y: spot.y, health: ratPower * 5, id, wave: waveTag };
    await setDoc(doc(db, `games/${gameId}/rats/${id}`), rat);
    ratsSpawned++;
  }

  console.log(`âœ… Wave spawned: ğŸ‚ ${oxSpawned} oxen, ğŸ€ ${ratsSpawned} rats`);
}

async function returnToLobby() {
  const urlParams = new URLSearchParams(window.location.search);
  const username = urlParams.get("username") || "";
  console.log("ğŸ” Returning to lobby with username:", username);
  const safeUsername = encodeURIComponent(username.trim());

  // ğŸ† Award win if cat is defeated
  if (catHealth <= 0) {
    try {
      const usersSnap = await getDocs(collection(db, "users"));
      let matched = null;

      usersSnap.forEach(docSnap => {
        const data = docSnap.data();
        if (data.username?.toLowerCase() === username.trim().toLowerCase()) {
          matched = { id: docSnap.id, wins: data.wins || 0 };
        }
      });

      if (matched) {
        await updateDoc(doc(db, "users", matched.id), {
          wins: matched.wins + 1
        });
        console.log(`ğŸ† Win awarded to ${matched.id}`);
      } else {
        console.warn("âš ï¸ No matching user found to award win.");
      }
    } catch (err) {
      console.error("ğŸ”¥ Error awarding win:", err);
    }
  }

  window.location.href = `/lobby/lobby.html?username=${safeUsername}`;
}

window.returnToLobby = returnToLobby;

function updateCatHealthBar() {
  const bar = document.getElementById("catHealthFill");
  const text = document.getElementById("catHealthText");

  // Set a constant visual bar width (e.g., 300px) and fill percentage capped at 100%
  const percent = Math.min(100, (catHealth / 1000) * 100); // Optional visual scale

  bar.style.width = percent + "%";
  text.textContent = `â¤ï¸ ${catHealth}`; // Just show current value
}


function move(dir) {
  if (!canMove || !isAlive) return;
  if (dir === 'up') movePlayer(0, -1);
  else if (dir === 'down') movePlayer(0, 1);
  else if (dir === 'left') movePlayer(-1, 0);
  else if (dir === 'right') movePlayer(1, 0);
  triggerMoveCooldown();
}



function place(dir) {
  if (!canMove || !isAlive || selectedBuild === null) {
    console.log("ğŸš« Can't place: either dead, can't move, or no build selected.");
    return;
  }
  console.log("ğŸ› ï¸ Building", selectedBuild, "towards", dir);
  placeStructure(dir);
}


function selectBuild(key) {
  const symbol = window.myBuildKeys?.[key];
  if (!symbol) {
    console.warn("ğŸš« No structure assigned to this key.");
    selectedBuild = null;
    document.getElementById("buildType").textContent = "Unavailable";
    return;
  }

  selectedBuild = key;
  document.getElementById("buildType").textContent = buildNames[symbol] || "Unknown Structure";
}

function showBuildKeys() {
  const map = window.myBuildKeys;
  if (!map || !playerClass || !structureClasses[playerClass]) return;

 const costMap = {
  "ğŸ§±": 1,
  "ğŸ”«": 3,
  "ğŸª³": 5,
  "ğŸ­": 4,
  "ğŸ’": 6,
  "ğŸ—¼": 24,
  "ğŸ¦â€ğŸ”¥": 40,
  "ğŸš€": 30,
  "ğŸŒ³": 20,
  "ğŸŒ¿": 4,
  "âš™ï¸": 12 
};


  let html = `<strong>ğŸ“ ${structureClasses[playerClass].label}</strong><br><br>`;

  for (let i = 1; i <= 6; i++) {
    const emoji = map[i];
    if (emoji) {
      html += `${emoji} (${i}, ğŸ§€${costMap[emoji] || "?"}) &nbsp; | &nbsp; `;
    }
  }

  // Remove final separator
  html = html.replace(/&nbsp; \| &nbsp; $/, "");
  document.getElementById("buildInfo").innerHTML = html;
}


function toggleMobileMode() {
  showingUpgrades = !showingUpgrades;
  document.getElementById("structureButtons").style.display = showingUpgrades ? "none" : "block";
  document.getElementById("upgradeButtons").style.display = showingUpgrades ? "block" : "none";
}
function toggleUpgradeMenu() {
  upgradeMenuOpen = !upgradeMenuOpen;
  document.getElementById("upgradeMenu").style.display = upgradeMenuOpen ? "block" : "none";
}
function selectUpgrade(key) {
  if (!upgradeMenuOpen || advancementPoints <= 0) return;

  const upgradeMap = {
    "1": "Speedster",
    "2": "Scavenger",
    "3": "Flea Master",
    "4": "Wall Master",
    "5": "Trapmaster",
    "6": "Blink"
  };

  const upgrade = upgradeMap[key];
  if (!selectedUpgrades.includes(upgrade)) {
    selectedUpgrades.push(upgrade);
    advancementPoints--;

    document.getElementById("advPoints").textContent = advancementPoints;
    document.getElementById("chosenUpgrades").textContent = selectedUpgrades.join(", ");
    console.log(`ğŸ†™ Chose upgrade: ${upgrade}`);

    // Effects
    if (upgrade === "Speedster") moveCooldown = 50;
    if (upgrade === "Scavenger") cheesePickupBonus = 3;
    if (upgrade === "Flea Master") fleaMasterActive = true;
    if (upgrade === "Wall Master") wallMasterActive = true;
    if (upgrade === "Trapmaster") trapmasterActive = true;
    if (upgrade === "Blink") blinkActive = true;
  }
}
function tryBlink() {
  const event = new KeyboardEvent('keydown', { key: 'b' });
  window.dispatchEvent(event);
}
function setupMobileControls() {
  // Movement buttons
  document.querySelectorAll('[data-move]').forEach(btn => {
    btn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const dir = btn.getAttribute('data-move');
      move(dir);
    });
  });

  // Build/place buttons
  document.querySelectorAll('[data-place]').forEach(btn => {
    btn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const dir = btn.getAttribute('data-place');
      place(dir);
    });
  });

const structureKeys = ["1", "2", "3", "4", "5", "6", "7"];
structureKeys.forEach(key => {
  // Since first two children are <strong> and <br>, buttons start at 3rd child
  const nthChildIndex = parseInt(key, 10) + 2; // Add 2 to shift past <strong> and <br>

  const emojiButton = document.querySelector(`#structureButtons :nth-child(${nthChildIndex})`);
  if (emojiButton) {
    emojiButton.addEventListener('touchstart', (e) => {
      e.preventDefault();
      console.log("ğŸ“± Selected structure:", key);
      selectBuild(key);
    });
  }
});



  // Upgrade menu toggle
  const upgradeBtn = document.querySelector('[data-upgrade]');
  if (upgradeBtn) {
    upgradeBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      toggleUpgradeMenu();
    });
  }

  // Blink ability
  const blinkBtn = document.querySelector('[data-blink]');
  if (blinkBtn) {
    blinkBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      tryBlink();
    });
  }

  // Trap placement
  const trapBtn = document.querySelector('[data-trap]');
  if (trapBtn) {
    trapBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      placeTrap();
    });
  }
}



  function renderMobileUpgradeButtons() {
  const container = document.getElementById("mobileUpgradeButtons");
  container.innerHTML = "";

  const upgrades = [
    { key: "1", name: "Speedster" },
    { key: "2", name: "Scavenger" },
    { key: "3", name: "Flea Master" },
    { key: "4", name: "Wall Master" },
    { key: "5", name: "Trapmaster" },
    { key: "6", name: "Blink" },
  ];

  for (let u of upgrades) {
    const btn = document.createElement("button");
    btn.textContent = `${u.key} â€“ ${u.name}`;
    btn.style.margin = "4px";
    btn.onclick = () => {
      const event = new KeyboardEvent("keydown", { key: u.key });
      window.dispatchEvent(event);
    };
    container.appendChild(btn);
  }
}


function updateAbilityStatus() {
  const statusDiv = document.getElementById("abilityStatus");
  let content = "";

  const now = Date.now();

  if (blinkActive) {
    const cooldown = 8000;
    const remaining = Math.max(0, cooldown - (now - lastBlinkTime));
    const ready = remaining === 0;
    content += `ğŸŒ€ Blink [B]: <span style="color:${ready ? 'green' : 'gray'}">${ready ? "Ready!" : (Math.ceil(remaining / 1000) + "s")}</span><br>`;
  }

  if (trapmasterActive) {
    const cooldown = 20000;
    const remaining = Math.max(0, cooldown - (now - lastTrapTime));
    const ready = remaining === 0;
    content += `ğŸª¤ Trap [T]: <span style="color:${ready ? 'green' : 'gray'}">${ready ? "Ready!" : (Math.ceil(remaining / 1000) + "s")}</span><br>`;
  }

  statusDiv.innerHTML = content;
}


function savePosition() {
  const cleanUsername = username.trim().toLowerCase();
  const playerRef = doc(db, `games/${gameId}/players/${cleanUsername}`);

  const payload = {
    x: playerPos.x,
    y: playerPos.y,
    cheese: cheeseCount
  };
  setDoc(playerRef, payload, { merge: true });
}


function startCatBehaviorLoop() {
  if (catMoveInterval) clearInterval(catMoveInterval);

  // ğŸ•’ Speed = faster interval as power increases
  const speed = Math.max(200, 1300 - catPower * 40); // e.g. power 10 = 500ms
  catMoveInterval = setInterval(() => {
    if (gameStarted) catBehavior();
  }, speed);
}


function checkCheese() {
  if (grid[playerPos.y][playerPos.x] === "ğŸ§€") {
    grid[playerPos.y][playerPos.x] = "";
    cheeseCount += 3 + cheesePickupBonus;
    document.getElementById("cheeseCount").textContent = cheeseCount;
    savePosition();
    renderGrid();
  }
}

async function placeStructure(dir) {
  if (!gameStarted || !isAlive || !selectedBuild) return;

  let tx = playerPos.x, ty = playerPos.y;
  if (dir === 'w') ty--;
  if (dir === 'a') tx--;
  if (dir === 's') ty++;
  if (dir === 'd') tx++;
  if (tx < 0 || ty < 0 || tx >= gridSize || ty >= gridSize) return;

  const symbol = myBuildKeys[selectedBuild];
  if (!symbol || !structureInfo[symbol]) return;

  const { cost, health } = structureInfo[symbol];
  if (cheeseCount < cost) return;

  const key = `${tx}_${ty}`;
  if (grid[ty][tx] === "") {
    grid[ty][tx] = symbol;
    structureHealth[key] = health;
    cheeseCount -= cost;
    document.getElementById("cheeseCount").textContent = cheeseCount;
    savePosition();

    await setDoc(doc(db, `games/${gameId}/structures/${key}`), {
      x: tx,
      y: ty,
      type: symbol,
      health
    });

    renderGrid();
  }
}




function spawnCheese() {
  let spawned = 0;
  let attempts = 0;
  const maxAttempts = 100; // avoid infinite loop if grid is full

  while (spawned < 4 && attempts < maxAttempts) {
    const x = Math.floor(Math.random() * gridSize);
    const y = Math.floor(Math.random() * gridSize);
    if (grid[y][x] === "") {
      grid[y][x] = "ğŸ§€";
      spawned++;
    }
    attempts++;
  }

  renderGrid();
}


async function damageStructure(x, y, damageAmount = (1 + Math.floor(catPower / 3))) {
  const key = `${x}_${y}`;
  const symbol = grid[y][x];

  if (structureHealth[key] !== undefined) {
    structureHealth[key] -= damageAmount;
    console.log(`ğŸ’¥ Damaged ${symbol} at (${x}, ${y}) â†’ HP: ${structureHealth[key]}`);
    
    if (structureHealth[key] <= 0) {
      grid[y][x] = "";
      delete structureHealth[key];
      await deleteDoc(doc(db, `games/${gameId}/structures/${key}`));
    } else {
      await updateDoc(doc(db, `games/${gameId}/structures/${key}`), {
        health: structureHealth[key]
      });
    }
  } else if (["ğŸ§±", "ğŸ’", "ğŸŒ¿"].includes(symbol)) {
    // ğŸ’£ Untracked structure fallback
    console.warn(`âš ï¸ Destroying untracked wall at (${x}, ${y})`);
    grid[y][x] = "";
    await deleteDoc(doc(db, `games/${gameId}/structures/${key}`));
  }

  renderGrid();
}



async function syncMyFleas() {
  const fleasRef = collection(db, `games/${gameId}/fleas`);
  const snapshot = await getDocs(fleasRef);

  const batchDeletes = [];
  snapshot.forEach(docSnap => {
    if (docSnap.id.startsWith(username)) {
      batchDeletes.push(deleteDoc(docSnap.ref));
    }
  });
  await Promise.all(batchDeletes);

  for (let i = 0; i < fleas.length; i++) {
    await setDoc(doc(db, `games/${gameId}/fleas/${username}_${i}`), fleas[i]);
  }
}

async function syncMyRats() {
  const ratsRef = collection(db, `games/${gameId}/rats`);
  const snapshot = await getDocs(ratsRef);

  const batchDeletes = [];
  snapshot.forEach(docSnap => {
    if (docSnap.id.startsWith(username)) {
      batchDeletes.push(deleteDoc(docSnap.ref));
    }
  });
  await Promise.all(batchDeletes);

  for (let i = 0; i < rats.length; i++) {
    await setDoc(doc(db, `games/${gameId}/rats/${username}_${i}`), rats[i]);
  }
}


async function turretAttack() {
  const hitLocations = [];

  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      if (grid[y][x] === "ğŸ”«") {
        let bonusDamage = 0;
        for (let dy = -2; dy <= 2; dy++) {
          for (let dx = -2; dx <= 2; dx++) {
            const nx = x + dx;
            const ny = y + dy;
            if (
              nx >= 0 && nx < gridSize &&
              ny >= 0 && ny < gridSize &&
              grid[ny][nx] === "ğŸ—¼"
            ) {
              bonusDamage++;
            }
          }
        }

        const damage = 2 + bonusDamage;
        const targets = [];

        const distToCat = Math.abs(catPos.x - x) + Math.abs(catPos.y - y);
        if (distToCat <= 5 && catHealth > 0) {
          targets.push({
            type: "cat",
            x: catPos.x,
            y: catPos.y,
            health: catHealth
          });
        }

        for (let rat of rats) {
          const dist = Math.abs(rat.x - x) + Math.abs(rat.y - y);
          if (dist <= 5 && rat.health > 0) {
            targets.push({ ...rat, type: "rat" });
          }
        }

        for (let ox of oxen) {
          const dist = Math.abs(ox.x - x) + Math.abs(ox.y - y);
          if (dist <= 5 && ox.health > 0) {
            targets.push({ ...ox, type: "ox" });
          }
        }

        if (targets.length === 0) continue;

        targets.sort((a, b) => {
          const da = Math.abs(a.x - x) + Math.abs(a.y - y);
          const db = Math.abs(b.x - x) + Math.abs(b.y - y);
          return da - db;
        });

        const target = targets[0];
        target.health -= damage;
        hitLocations.push({ x: target.x, y: target.y });

        // ğŸ” Sync to Firebase
        if (target.type === "cat") {
          catHealth = target.health;
          await updateDoc(doc(db, `games/${gameId}`), {
            cat: { x: catPos.x, y: catPos.y, health: catHealth }
          });
          if (catHealth <= 0) {
            document.getElementById("status").textContent = "ğŸ‰ Mice win!";
            document.getElementById("returnButton").style.display = "block";
          }
        } else if (target.type === "rat") {
          const rat = rats.find(r => r.id === target.id);
          if (rat) rat.health = target.health;
          if (target.id) {
            await updateDoc(doc(db, `games/${gameId}/rats/${target.id}`), {
              health: target.health
            });
          }
        } else if (target.type === "ox") {
          const ox = oxen.find(o => o.id === target.id);
          if (ox) ox.health = target.health;
          if (target.id) {
            await updateDoc(doc(db, `games/${gameId}/oxen/${target.id}`), {
              health: target.health
            });
          }
        }
      }
    }
  }

  // ğŸ§¹ Cleanup
  for (let i = rats.length - 1; i >= 0; i--) {
    if (rats[i].health <= 0) {
      await deleteDoc(doc(db, `games/${gameId}/rats/${rats[i].id}`));
      rats.splice(i, 1);
    }
  }

  for (let i = oxen.length - 1; i >= 0; i--) {
    if (oxen[i].health <= 0) {
      await deleteDoc(doc(db, `games/${gameId}/oxen/${oxen[i].id}`));
      oxen.splice(i, 1);
    }
  }

  // ğŸ§± Re-render updated grid
  renderGrid();

  // ğŸ’¥ Visual bang effect AFTER grid update
  for (const { x, y } of hitLocations) {
    const cell = document.getElementById(`cell-${x}-${y}`);
    if (cell) {
      const original = cell.textContent;
      cell.textContent = "ğŸ’¥";
      setTimeout(() => {
        cell.textContent = original;
      }, 200);
    }
  }
}
  async function squirrelAcornAttack() {
  if (!isHost) return;

  const hitLocations = [];

  for (let squirrel of squirrels) {
    const { x, y, health } = squirrel;

    const targets = [
      ...rats.map(r => ({ ...r, type: "rat" })),
      ...oxen.map(o => ({ ...o, type: "ox" })),
      ...(catPos ? [{ x: catPos.x, y: catPos.y, type: "cat", health: catHealth }] : [])
    ];

    const validTargets = targets.filter(t => {
      const dist = Math.abs(t.x - x) + Math.abs(t.y - y);
      return dist === 1 || dist === 2;
    });

    if (validTargets.length === 0) continue;

    // Find closest
    validTargets.sort((a, b) => {
      const da = Math.abs(a.x - x) + Math.abs(a.y - y);
      const db = Math.abs(b.x - x) + Math.abs(b.y - y);
      return da - db;
    });

    const target = validTargets[0];
    const damage = 5;
    hitLocations.push({ x: target.x, y: target.y });

    if (target.type === "cat") {
      catHealth -= damage;
      await updateDoc(doc(db, `games/${gameId}`), {
        cat: { x: catPos.x, y: catPos.y, health: catHealth }
      });
      if (catHealth <= 0) {
        document.getElementById("status").textContent = "ğŸ‰ Mice win!";
        document.getElementById("returnButton").style.display = "block";
      }
    } else if (target.type === "rat") {
      const rat = rats.find(r => r.id === target.id);
      if (rat) rat.health = target.health - damage;
      if (target.id) {
        await updateDoc(doc(db, `games/${gameId}/rats/${target.id}`), {
          health: target.health - damage
        });
      }
    } else if (target.type === "ox") {
      const ox = oxen.find(o => o.id === target.id);
      if (ox) ox.health = target.health - damage;
      if (target.id) {
        await updateDoc(doc(db, `games/${gameId}/oxen/${target.id}`), {
          health: target.health - damage
        });
      }
    }
  }

  // Cleanup defeated rats/oxen
  for (let i = rats.length - 1; i >= 0; i--) {
    if (rats[i].health <= 0) {
      await deleteDoc(doc(db, `games/${gameId}/rats/${rats[i].id}`));
      rats.splice(i, 1);
    }
  }
  for (let i = oxen.length - 1; i >= 0; i--) {
    if (oxen[i].health <= 0) {
      await deleteDoc(doc(db, `games/${gameId}/oxen/${oxen[i].id}`));
      oxen.splice(i, 1);
    }
  }

  renderGrid();

  // ğŸŒ° Visual acorn impact effect
  for (const { x, y } of hitLocations) {
    const cell = document.getElementById(`cell-${x}-${y}`);
    if (cell) {
      const original = cell.textContent;
      cell.textContent = "ğŸŒ°";
      setTimeout(() => {
        cell.textContent = original;
      }, 200);
    }
  }
}







async function rocketTowerAttack() {
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      if (grid[y][x] === "ğŸš€") {
        // ğŸ”‹ Check for nearby beacon boost
        let boosted = false;
        for (let dy = -2; dy <= 2; dy++) {
          for (let dx = -2; dx <= 2; dx++) {
            const bx = x + dx;
            const by = y + dy;
            if (
              bx >= 0 && bx < gridSize &&
              by >= 0 && by < gridSize &&
              grid[by][bx] === "ğŸ—¼"
            ) {
              boosted = true;
              break;
            }
          }
          if (boosted) break;
        }

        // ğŸ” Find farthest valid enemy (rat, ox, cat) within 8 tiles
        let target = null;
        let maxDist = -1;

        // Check cat
        const distToCat = Math.abs(catPos.x - x) + Math.abs(catPos.y - y);
        if (catHealth > 0 && distToCat <= 8 && distToCat > maxDist) {
          maxDist = distToCat;
          target = { type: "cat", x: catPos.x, y: catPos.y };
        }

        // Check rats
        for (let rat of rats) {
          const dist = Math.abs(rat.x - x) + Math.abs(rat.y - y);
          if (rat.health > 0 && dist <= 8 && dist > maxDist) {
            maxDist = dist;
            target = { ...rat, type: "rat" };
          }
        }

        // Check oxen
        for (let ox of oxen) {
          const dist = Math.abs(ox.x - x) + Math.abs(ox.y - y);
          if (ox.health > 0 && dist <= 8 && dist > maxDist) {
            maxDist = dist;
            target = { ...ox, type: "ox" };
          }
        }

        if (target) {
          const mainDamage = boosted ? 20 : 15;
          const splashDamage = boosted ? 15 : 10;

          // ğŸ¯ Main target takes damage
          if (target.type === "cat") {
            catHealth -= mainDamage;
            await updateDoc(doc(db, `games/${gameId}`), {
              cat: { ...catPos, health: catHealth }
            });
          } else if (target.type === "rat") {
            target.health -= mainDamage;
            if (target.id) {
              await updateDoc(doc(db, `games/${gameId}/rats/${target.id}`), {
                health: target.health
              });
            }
          } else if (target.type === "ox") {
            target.health -= mainDamage;
            if (target.id) {
              await updateDoc(doc(db, `games/${gameId}/oxen/${target.id}`), {
                health: target.health
              });
            }
          }

          // ğŸ’¥ Splash damage to all enemies in 3x3
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              const sx = target.x + dx;
              const sy = target.y + dy;
              if (sx < 0 || sy < 0 || sx >= gridSize || sy >= gridSize) continue;

              // Skip main target
              if (sx === target.x && sy === target.y) continue;

              for (let rat of rats) {
                if (rat.x === sx && rat.y === sy && rat.health > 0) {
                  rat.health -= splashDamage;
                  if (rat.id) {
                    await updateDoc(doc(db, `games/${gameId}/rats/${rat.id}`), {
                      health: rat.health
                    });
                  }
                }
              }

              for (let ox of oxen) {
                if (ox.x === sx && ox.y === sy && ox.health > 0) {
                  ox.health -= splashDamage;
                  if (ox.id) {
                    await updateDoc(doc(db, `games/${gameId}/oxen/${ox.id}`), {
                      health: ox.health
                    });
                  }
                }
              }

              if (catPos.x === sx && catPos.y === sy && catHealth > 0) {
                catHealth -= splashDamage;
                await updateDoc(doc(db, `games/${gameId}`), {
                  cat: { ...catPos, health: catHealth }
                });
              }
            }
          }

          // ğŸ§¹ Cleanup
          for (let i = rats.length - 1; i >= 0; i--) {
            if (rats[i].health <= 0) {
              await deleteDoc(doc(db, `games/${gameId}/rats/${rats[i].id}`));
              rats.splice(i, 1);
            }
          }

          for (let i = oxen.length - 1; i >= 0; i--) {
            if (oxen[i].health <= 0) {
              await deleteDoc(doc(db, `games/${gameId}/oxen/${oxen[i].id}`));
              oxen.splice(i, 1);
            }
          }

          // ğŸ¨ Visual Effects
          renderGrid();

          const visuals = [];

          // Smoke trail
          const steps = Math.max(Math.abs(target.x - x), Math.abs(target.y - y));
          for (let i = 0; i <= steps; i++) {
            const sx = Math.round(x + (target.x - x) * (i / steps));
            const sy = Math.round(y + (target.y - y) * (i / steps));
            const cell = document.getElementById(`cell-${sx}-${sy}`);
            if (cell) {
              visuals.push({ cell, original: cell.textContent });
              cell.textContent = "ğŸ’¨";
            }
          }

          // Explosion effect
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              const fx = target.x + dx;
              const fy = target.y + dy;
              if (fx < 0 || fy < 0 || fx >= gridSize || fy >= gridSize) continue;
              const cell = document.getElementById(`cell-${fx}-${fy}`);
              if (cell) {
                visuals.push({ cell, original: cell.textContent });
                cell.textContent = "ğŸ’¥";
              }
            }
          }

          // â™»ï¸ Restore visuals after delay
          setTimeout(() => {
            for (const { cell, original } of visuals) {
              cell.textContent = original;
            }
          }, 300);
        }
      }
    }
  }
}





function findPath(startX, startY, targetX, targetY, allowTargetWall = false) {
  const queue = [[startX, startY, []]];
  const visited = new Set();
  visited.add(`${startX},${startY}`);

  const directions = [
    [1, 0], [-1, 0], [0, 1], [0, -1]
  ];

  while (queue.length > 0) {
    const [x, y, path] = queue.shift();
    if (x === targetX && y === targetY) return path;

    for (const [dx, dy] of directions) {
      const nx = x + dx;
      const ny = y + dy;
      const key = `${nx},${ny}`;

      if (
        nx >= 0 && nx < gridSize &&
        ny >= 0 && ny < gridSize &&
        !visited.has(key)
      ) {
        const isTarget = nx === targetX && ny === targetY;
        const cell = grid[ny][nx];

        const isWall = cell === "ğŸ§±" || cell === "ğŸ’" || cell === "ğŸŒ¿";
        const isWalkable = !isWall || (allowTargetWall && isTarget);

        if (isWalkable) {
          visited.add(key);
          queue.push([nx, ny, [...path, { x: nx, y: ny }]]);
        }
      }
    }
  }

  return null;
}

function triggerMoveCooldown() {
  canMove = false;
  setTimeout(() => canMove = true, moveCooldown);
}

  async function placeTrap() {
  const now = Date.now();
  if (now - lastTrapTime >= 20000) {
    const { x, y } = playerPos;
    const trapKey = `${x}_${y}`;
    if (grid[y][x] === "") {
      grid[y][x] = "ğŸª¤";
      lastTrapTime = now;

      await setDoc(doc(db, `games/${gameId}/traps/${trapKey}`), {
        x,
        y,
        placedAt: now
      });

      renderGrid();
    }
  }
}

function findSquirrelPath(sx, sy, tx, ty, stayAway = 2) {
  if (Math.abs(sx - tx) + Math.abs(sy - ty) <= stayAway) return null;

  const visited = new Set();
  const queue = [{ x: sx, y: sy, path: [] }];

  while (queue.length) {
    const { x, y, path } = queue.shift();
    const key = `${x}_${y}`;
    if (visited.has(key)) continue;
    visited.add(key);

    if (Math.abs(tx - x) + Math.abs(ty - y) <= stayAway) {
      return path[0]; // First step to closest allowed distance
    }

    const dirs = [
      { dx: 1, dy: 0 }, { dx: -1, dy: 0 },
      { dx: 0, dy: 1 }, { dx: 0, dy: -1 }
    ];

    for (let { dx, dy } of dirs) {
      const nx = x + dx;
      const ny = y + dy;
      const nextKey = `${nx}_${ny}`;

      if (
        nx >= 0 && ny >= 0 &&
        nx < gridSize && ny < gridSize &&
        !visited.has(nextKey)
      ) {
        queue.push({ x: nx, y: ny, path: [...path, { x: nx, y: ny }] });
      }
    }
  }

  return null;
}
function findNearestRat(x, y) {
  let minDist = Infinity;
  let closest = null;
  for (const rat of rats) {
    const dist = Math.abs(rat.x - x) + Math.abs(rat.y - y);
    if (dist < minDist) {
      minDist = dist;
      closest = rat;
    }
  }
  return closest;
}


function shuffle(arr) {
  return [...arr].sort(() => Math.random() - 0.5);
}

async function catBehavior() {
  console.log("ğŸ± Cat behavior running");

  // ğŸª¤ Trap check
  for (let trap of traps) {
    if (trap.x === catPos.x && trap.y === catPos.y) {
      console.log("ğŸª¤ Cat stepped on a trap!");
      clearInterval(catMoveInterval);

      setTimeout(() => {
        startCatBehaviorLoop();
      }, 5000);

      const trapKey = `${catPos.x}_${catPos.y}`;
      await deleteDoc(doc(db, `games/${gameId}/traps/${trapKey}`));

      const cell = document.getElementById(`cell-${catPos.x}-${catPos.y}`);
      if (cell) {
        cell.style.backgroundColor = "#ffaaaa";
        setTimeout(() => {
          cell.style.backgroundColor = "#c8f7c5";
        }, 300);
      }

      renderGrid();
      return;
    }
  }

  const aliveMice = Object.entries(players).filter(([_, p]) => p.alive);
  let target = null;
  let path = null;
  let mouseBlocked = true;

  // ğŸ­ Priority 1: Reachable mouse
  for (const [_, p] of aliveMice) {
    const pPath = findPath(catPos.x, catPos.y, p.x, p.y, false);
    if (pPath) {
      if (!path || pPath.length < path.length) {
        target = { x: p.x, y: p.y, type: "mouse" };
        path = pPath;
      }
      mouseBlocked = false;
    }
  }

  // ğŸ§± Priority 2: Break wall near blocked mice
  if (!target && mouseBlocked) {
    for (const [_, p] of aliveMice) {
      for (const [dx, dy] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
        const wx = p.x + dx, wy = p.y + dy;
        if (["ğŸ§±", "ğŸ­", "ğŸ’", "ğŸ—¼", "ğŸŒ¿"].includes(grid[wy]?.[wx])) {
          const wPath = findPath(catPos.x, catPos.y, wx, wy, true);
          if (wPath && (!path || wPath.length < path.length)) {
            target = { x: wx, y: wy, type: "wallToBreak" };
            path = wPath;
          }
        }
      }
    }
  }

  // ğŸ”« Priority 3: Reach structure
  if (!target) {
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        if (["ğŸ”«", "ğŸª³", "ğŸ—¼", "ğŸš€", "ğŸŒ³"].includes(grid[y][x])) {
          const sPath = findPath(catPos.x, catPos.y, x, y, false);
          if (sPath && (!path || sPath.length < path.length)) {
            target = { x, y, type: "structure" };
            path = sPath;
          }
        }
      }
    }
  }

  // ğŸŒ° Priority 4: Reach squirrel
  if (!target) {
    for (let squirrel of squirrels) {
      if (squirrel.health > 0) {
        const sPath = findPath(catPos.x, catPos.y, squirrel.x, squirrel.y, false);
        if (sPath && (!path || sPath.length < path.length)) {
          target = { x: squirrel.x, y: squirrel.y, type: "squirrel", id: squirrel.id };
          path = sPath;
        }
      }
    }
  }

  // ğŸ§± Fallback: Anything
  if (!target) {
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
       if (["ğŸ§±", "ğŸ”«", "ğŸª³", "ğŸ­", "ğŸ’", "ğŸ—¼", "ğŸš€", "ğŸŒ³", "ğŸŒ¿"].includes(grid[y][x])) {
          const fPath = findPath(catPos.x, catPos.y, x, y, false);
          if (fPath && (!path || fPath.length < path.length)) {
            target = { x, y, type: "fallback" };
            path = fPath;
          }
        }
      }
    }
  }

  if (target && path) {
    const next = path[1];
    if (next && !["ğŸ§±", "ğŸ’", "ğŸŒ¿"].includes(grid[next.y][next.x])) {
      catPos.x = next.x;
      catPos.y = next.y;
      console.log(`âœ… Cat moved to (${catPos.x}, ${catPos.y}) toward ${target.type}`);
    }
  }

  // ğŸ’¥ Attack adjacent structures or squirrels
  let attacked = false;
  for (let dy = -1; dy <= 1 && !attacked; dy++) {
    for (let dx = -1; dx <= 1 && !attacked; dx++) {
      const tx = catPos.x + dx, ty = catPos.y + dy;
      if (tx < 0 || tx >= gridSize || ty < 0 || ty >= gridSize) continue;

      const symbol = grid[ty][tx];
      if (["ğŸ§±", "ğŸ”«", "ğŸª³", "ğŸ­", "ğŸ’", "ğŸ—¼", "ğŸš€", "ğŸŒ³", "ğŸŒ¿"].includes(symbol)) {
        console.log(`ğŸ’¥ Cat attacked ${symbol} at (${tx}, ${ty})`);
        damageStructure(tx, ty);
        attacked = true;
      } else {
        for (let squirrel of squirrels) {
          if (squirrel.x === tx && squirrel.y === ty && squirrel.health > 0) {
            console.log(`ğŸ’¥ Cat attacked squirrel at (${tx}, ${ty})`);
            squirrel.health -= 3; // adjust cat's damage to squirrel here
            await updateDoc(doc(db, `games/${gameId}/squirrels/${squirrel.id}`), {
              health: squirrel.health
            });
            attacked = true;
            break;
          }
        }
      }
    }
  }

  // ğŸ’€ Kill mice
  for (const [name, p] of Object.entries(players)) {
    if ((p.alive ?? true) && catPos.x === p.x && catPos.y === p.y) {
      console.log(`ğŸ’€ Cat killed ${name}`);
      updateDoc(doc(db, `games/${gameId}/players/${name}`), { alive: false });
      if (name === username) {
        isAlive = false;
        document.getElementById("status").textContent = "ğŸ’€ You are dead!";
      }
    }
  }

  await updateDoc(doc(db, `games/${gameId}`), {
    cat: { x: catPos.x, y: catPos.y, health: catHealth }
  });

  updateCatHealthBar();
  renderGrid();
}



async function listenToGame() {

onSnapshot(collection(db, `games/${gameId}/structures`), (snap) => {
  // ğŸ§¹ Clear old structures from grid
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      if (["ğŸ§±", "ğŸ”«"].includes(grid[y][x])) {
        grid[y][x] = "";
      }
    }
  }

  structureHealth = {};

  // ğŸ§± Re-populate grid with structure data
  snap.forEach((docSnap) => {
    const data = docSnap.data(); // âœ… Correct variable
    const { x, y, type, health } = data;

    if (x !== undefined && y !== undefined && type) {
      grid[y][x] = type;
      structureHealth[`${x}_${y}`] = health;
    }
  });

  renderGrid();
});

  onSnapshot(collection(db, `games/${gameId}/fleas`), (snap) => {
  fleas = snap.docs.map(doc => doc.data());
  renderGrid();
});
onSnapshot(collection(db, `games/${gameId}/squirrels`), (snapshot) => {
  squirrels = snapshot.docs.map(doc => ({
    id: doc.id,      // âœ… Capture document ID
    ...doc.data()
  }));
  renderGrid();
});
onSnapshot(collection(db, `games/${gameId}/catcherBots`), (snap) => {
  catcherBots = snap.docs.map(doc => ({ ...doc.data(), id: doc.id }));
  renderGrid();
});

onSnapshot(collection(db, `games/${gameId}/rats`), (snap) => {
  const updatedRats = [];

  snap.forEach(doc => {
    const data = doc.data();

    // ğŸ§  If rat already exists in local array, update it
    const existing = rats.find(r => r.id === data.id);
    if (existing) {
      Object.assign(existing, data);
    } else {
      updatedRats.push(data); // new rat
    }
  });

  // ğŸ” Add any new ones without wiping existing living rats
  rats = [
    ...rats.filter(r => snap.docs.some(d => d.id === r.id)), // keep only those still in Firebase
    ...updatedRats
  ];

  renderGrid();
});


  onSnapshot(collection(db, `games/${gameId}/oxen`), (snap) => {
  oxen = snap.docs.map(doc => doc.data());
  renderGrid();
});



onSnapshot(doc(db, `games/${gameId}`), (docSnap) => {
  if (docSnap.exists()) {
    const data = docSnap.data();
    gameData = data;
    updateHostDisplay();

    // ğŸ± Host-only cat initialization
    if (
      isHost &&
      (!data.cat || typeof data.cat.x !== "number" || typeof data.cat.y !== "number")
    ) {
      const initialCat = {
        x: gridSize - 1,
        y: gridSize - 1,
        health: 1000
      };
      updateDoc(doc(db, `games/${gameId}`), { cat: initialCat });
    }

    // ğŸ± Sync cat state from Firebase
    const cat = data.cat || {};
    catPower = data.catPower || 0;
    catPos = { x: cat.x ?? 15, y: cat.y ?? 15 };

    if (typeof cat.health === "number") {
      catHealth = cat.health; // âœ… Don't override 0
    }

    updateCatHealthBar();     // âœ… Visually reflect latest health
    renderGrid();
  }
});

onSnapshot(collection(db, `games/${gameId}/termites`), (snap) => {
  termites = snap.docs.map(doc => doc.data());
  renderGrid();
});


onSnapshot(collection(db, `games/${gameId}/traps`), (snap) => {
  // ğŸ§¹ Clear all existing trap symbols from grid
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      if (grid[y][x] === "ğŸª¤") {
        grid[y][x] = ""; // âœ… Clear old traps
      }
    }
  }

  traps = []; // clear and rebuild trap list
  for (let docSnap of snap.docs) {
    const data = docSnap.data();
    traps.push({ x: data.x, y: data.y, placedAt: data.placedAt });
    grid[data.y][data.x] = "ğŸª¤";
  }

  renderGrid();
});



  onSnapshot(collection(db, `games/${gameId}/players`), (snap) => {
  players = {};
  snap.forEach((docSnap) => {
    players[docSnap.id.toLowerCase()] = docSnap.data(); // âœ… force lowercase key
  });
  renderGrid();
});

  const playerRef = doc(db, `games/${gameId}/players/${username}`);
const assignedClass = Object.keys(structureClasses)[Math.floor(Math.random() * 3)];

await setDoc(playerRef, {
  x: playerPos.x,
  y: playerPos.y,
  cheese: 0,
  alive: true,
  displayName: urlParams.get("username").trim(),
  playerClass: assignedClass
}, { merge: true });



onSnapshot(playerRef, (docSnap) => {
  if (!docSnap.exists()) return;

  const data = docSnap.data();
  playerPos = { x: data.x, y: data.y };
  isAlive = data.alive !== false;
  cheeseCount = data.cheese || 0;
  document.getElementById("cheeseCount").textContent = cheeseCount;

  // ğŸ“ Load class info
  const classKey = data.playerClass || "defender";
  window.playerClass = classKey;
  const classInfo = structureClasses[classKey];

  // âœ… Assign build keys once with no duplicates
  if (!window.myBuildKeys) {
    const defenseSet = shuffle(classInfo.defense).slice(0, 2);
    const attackSet = shuffle(classInfo.attack).slice(0, 2);
    const economicSet = shuffle(classInfo.economic).slice(0, 2);

    window.myBuildKeys = {
      1: defenseSet[0] || null,
      2: defenseSet[1] || defenseSet[0] || null,
      3: attackSet[0] || null,
      4: attackSet[1] || attackSet[0] || null,
      5: economicSet[0] || null,
      6: economicSet[1] || economicSet[0] || null,
    };

    console.log("ğŸ¯ Key assignment:", window.myBuildKeys);

    // ğŸ“‹ Display build info
    let buildDisplay = `<strong>ğŸ“ ${classInfo.label}</strong><br>`;
    for (let i = 1; i <= 6; i++) {
      const emoji = window.myBuildKeys[i];
      if (emoji && buildNames[emoji]) {
        buildDisplay += `${i}: ${buildNames[emoji]}<br>`;
      }
    }
     showBuildKeys();
  }

  document.getElementById("status").textContent = isAlive ? "" : "ğŸ’€ You are dead!";
  renderGrid();
});

}
window.addEventListener("keydown", (e) => {
  if (!isAlive) return;

  // Prevent arrow key scrolling
  if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) e.preventDefault();

  // Toggle upgrade menu
  if (e.key === " ") {
    upgradeMenuOpen = !upgradeMenuOpen;
    document.getElementById("upgradeMenu").style.display = upgradeMenuOpen ? "block" : "none";
    return;
  }

  // ğŸ’¡ Upgrade selection ONLY when menu is open
  if (upgradeMenuOpen && ["1", "2", "3", "4", "5", "6"].includes(e.key) && advancementPoints > 0) {
    let upgrade = "";
    if (e.key === "1") upgrade = "Speedster";
    else if (e.key === "2") upgrade = "Scavenger";
    else if (e.key === "3") upgrade = "Flea Master";
    else if (e.key === "4") upgrade = "Wall Master";
    else if (e.key === "5") upgrade = "Trapmaster";
    else if (e.key === "6") upgrade = "Blink";

    if (!selectedUpgrades.includes(upgrade)) {
      selectedUpgrades.push(upgrade);
      advancementPoints--;

      document.getElementById("advPoints").textContent = advancementPoints;
      document.getElementById("chosenUpgrades").textContent = selectedUpgrades.join(", ");
      console.log(`ğŸ†™ Chose upgrade: ${upgrade}`);

      // Effects
      if (upgrade === "Speedster") moveCooldown = 50;
      if (upgrade === "Scavenger") cheesePickupBonus = 3;
      if (upgrade === "Flea Master") fleaMasterActive = true;
      if (upgrade === "Wall Master") wallMasterActive = true;
      if (upgrade === "Trapmaster") trapmasterActive = true;
      if (upgrade === "Blink") blinkActive = true;
    }
    return;
  }

  // âœ… Movement (always allowed)
  if (canMove) {
    switch (e.key) {
      case "ArrowUp": lastDirection = { dx: 0, dy: -1 }; movePlayer(0, -1); triggerMoveCooldown(); break;
      case "ArrowDown": lastDirection = { dx: 0, dy: 1 }; movePlayer(0, 1); triggerMoveCooldown(); break;
      case "ArrowLeft": lastDirection = { dx: -1, dy: 0 }; movePlayer(-1, 0); triggerMoveCooldown(); break;
      case "ArrowRight": lastDirection = { dx: 1, dy: 0 }; movePlayer(1, 0); triggerMoveCooldown(); break;
    }
  }

  // ğŸŒ€ Blink (always works if active)
  if (blinkActive && e.key.toLowerCase() === "b") {
    const now = Date.now();
    if (now - lastBlinkTime >= 8000) {
      const dx = lastDirection.dx;
      const dy = lastDirection.dy;
      const nx = playerPos.x + dx * 5;
      const ny = playerPos.y + dy * 5;

      if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && grid[ny][nx] === "") {
        playerPos = { x: nx, y: ny };
        lastBlinkTime = now;
        console.log("ğŸŒ€ Blink activated!");
        savePosition();
        renderGrid();

        const cell = document.getElementById(`cell-${nx}-${ny}`);
        if (cell) {
          cell.style.backgroundColor = "#b3f0ff";
          setTimeout(() => {
            cell.style.backgroundColor = "#c8f7c5";
          }, 300);
        }
      } else {
        console.log("ğŸš« Blink failed â€“ tile blocked or out of bounds.");
      }
    } else {
      console.log("âŒ› Blink on cooldown");
    }
  }

  // âœ… Trap placement (only if unlocked, always allowed regardless of menu state)
  if (trapmasterActive && e.key.toLowerCase() === "t") {
    placeTrap();
  }

  // âœ… Structure selection (ONLY if upgrade menu is closed)
// âœ… Structure selection (ONLY if upgrade menu is closed)
if (!upgradeMenuOpen && ["1", "2", "3", "4", "5", "6", "7", "8", "9"].includes(e.key)) {
  selectBuild(e.key);
}



  // âœ… Build placement (always allowed)
  if (["w", "a", "s", "d"].includes(e.key)) {
    placeStructure(e.key);
  }
});





// After listenToGame():
listenToGame();
gameStarted = true;
 if (/Mobi|Android/i.test(navigator.userAgent)) {
  document.getElementById("mobileControls").style.display = "block";
  renderMobileUpgradeButtons();
  setupMobileControls(); // ğŸ”§ This is critical
}

// Place initial structures
grid[24][15] = "ğŸ§±";
grid[25][14] = "ğŸ§±";
grid[25][16] = "ğŸ§±";
renderGrid();

// Start cheese spawn and turret attack globally
setInterval(async () => {
  const gameSnap = await getDoc(doc(db, `games/${gameId}`));
  const gameData = gameSnap.data();

  if (!gameData?.nextRatWave || !gameStarted) return;

  const now = Date.now();

  if (isHost && now >= gameData.nextRatWave) {
    console.log("ğŸ¬ Time to spawn a new rat wave!");
    spawnRatWave(); // your wave logic
    const nextTime = now + 40000; // next wave in 40s
    await updateDoc(doc(db, `games/${gameId}`), { nextRatWave: nextTime });
  }

  const secondsLeft = Math.max(0, Math.floor((gameData.nextRatWave - now) / 1000));
  document.getElementById("waveCountdown").textContent = `ğŸ€ Next wave: ${secondsLeft}s`;
}, 1000);

  setInterval(() => {
  if (!gameStarted) return;

  // 1. Check if any players are alive
  const anyAlive = Object.values(players).some(p => p.alive !== false);

  // 2. Check if any Phoenix Cheese exists on the board
  let phoenixExists = false;
  for (let y = 0; y < gridSize && !phoenixExists; y++) {
    for (let x = 0; x < gridSize && !phoenixExists; x++) {
      if (grid[y][x] === "ğŸ¦â€ğŸ”¥") {
        phoenixExists = true;
      }
    }
  }

  // 3. If no players and no phoenixes â†’ Game Over
  if (!anyAlive && !phoenixExists) {
    document.getElementById("status").textContent = "ğŸ’€ All mice are dead. Game Over!";
    document.getElementById("returnButton").style.display = "block";
    document.getElementById("status").style.color = "red";
    document.getElementById("status").style.fontSize = "24px";
    document.getElementById("status").style.fontWeight = "bold";
    document.getElementById("status").style.background = "#fff0f0";
    document.getElementById("status").style.padding = "10px";
    document.getElementById("status").style.border = "2px solid red";
    document.getElementById("status").style.marginTop = "10px";

    gameStarted = false; // Optionally stop the game logic
  }
}, 1000);
if (!isHost) {
  setInterval(async () => {
    const gameSnap = await getDoc(doc(db, `games/${gameId}`));
    const data = gameSnap.data();
    if (data && data.cat && typeof data.cat.health === "number") {
      catHealth = data.cat.health;
      updateCatHealthBar();
    }
  }, 3000); // check every 3 seconds
}
setInterval(() => {
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      if (grid[y][x] === "ğŸŒ³") {
        // Try to drop cheese in nearby empty tiles
        const offsets = [
          { dx: 0, dy: 1 }, { dx: 1, dy: 0 }, { dx: 0, dy: -1 }, { dx: -1, dy: 0 },
          { dx: 1, dy: 1 }, { dx: -1, dy: -1 }, { dx: 1, dy: -1 }, { dx: -1, dy: 1 }
        ];

        for (let offset of offsets) {
          const cx = x + offset.dx;
          const cy = y + offset.dy;
          if (
            cx >= 0 && cx < gridSize &&
            cy >= 0 && cy < gridSize &&
            grid[cy][cx] === ""
          ) {
            grid[cy][cx] = "ğŸ§€";
            break; // Drop only 1 cheese per tree per interval
          }
        }
      }
    }
  }
  renderGrid();
}, 15000);

setInterval(() => {
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      if (grid[y][x] === "ğŸ­") {
        // ğŸŒŸ Visual flash
        const cell = document.getElementById(`cell-${x}-${y}`);
        if (cell) {
          cell.style.backgroundColor = "#fff977";
          setTimeout(() => {
            cell.style.backgroundColor = "#c8f7c5";
          }, 300);
        }

        // ğŸ”‹ Count nearby beacons within 2 tiles
        let bonusCheese = 0;
        for (let dy = -2; dy <= 2; dy++) {
          for (let dx = -2; dx <= 2; dx++) {
            const nx = x + dx;
            const ny = y + dy;
            if (
              nx >= 0 && nx < gridSize &&
              ny >= 0 && ny < gridSize &&
              grid[ny][nx] === "ğŸ—¼"
            ) {
              bonusCheese++;
            }
          }
        }

        // ğŸ§€ Reward each alive player nearby
        for (const [name, p] of Object.entries(players)) {
          if (p.alive !== false) {
            const dx = Math.abs(p.x - x);
            const dy = Math.abs(p.y - y);
            if (dx + dy <= 9) {
              if (name === username.trim().toLowerCase()) {
                const totalCheese = 1 + bonusCheese;
                cheeseCount += totalCheese;
                document.getElementById("cheeseCount").textContent = cheeseCount;
                updateDoc(doc(db, `games/${gameId}/players/${name}`), {
                  cheese: cheeseCount
                });
                console.log(`ğŸ’° Generator at (${x},${y}) gave ${totalCheese} cheese to ${name}`);
              }
            }
          }
        }
      }
    }
  }
}, 15000); // â² Every 10 seconds
  setInterval(() => {
  if (fleaMasterActive && isAlive) {
    syncMyFleas();
  }
}, 500);
setInterval(updateAbilityStatus, 1000);
setInterval(() => {
  if (!gameStarted || !isAlive) return;

  advancementPoints++;
  document.getElementById("advPoints").textContent = advancementPoints;

  const msg = document.getElementById("advPointMessage");
  msg.textContent = "ğŸŸ¢ You gained an advancement point!";
  msg.style.display = "block";

  setTimeout(() => {
    msg.style.display = "none";
  }, 2500); // Hide after 2.5 seconds
}, 180000); // every 3 minutes


setInterval(() => {
  if (!fleaMasterActive || !isAlive) return;

  const offsets = [
    { dx: 0, dy: 0 }, { dx: 1, dy: 0 }, { dx: -1, dy: 0 },
    { dx: 0, dy: 1 }, { dx: 0, dy: -1 }
  ];

  let spawned = 0;

  for (let offset of offsets) {
    const fx = playerPos.x + offset.dx;
    const fy = playerPos.y + offset.dy;

    if (
      fx >= 0 && fx < gridSize &&
      fy >= 0 && fy < gridSize &&
      !fleas.some(f => f.x === fx && f.y === fy)
    ) {
      const fleaId = `${fx}_${fy}_${Date.now()}`;
      setDoc(doc(db, `games/${gameId}/fleas/${fleaId}`), {
        x: fx,
        y: fy,
        lifetime: 15,
        createdBy: username
      });

      spawned++;
      if (spawned >= 3) break;
    }
  }
}, fleaSpawnCooldown);

  setInterval(spawnCheese, 10000);


// âœ… Wrap host logic in an async function
(async () => {
  const cleanUsername = username.trim().toLowerCase();
  const gameRef = doc(db, `games/${gameId}`);

  const docSnap = await getDoc(gameRef);
  const data = docSnap.exists() ? docSnap.data() : {};
  if (!data.host) {
    await setDoc(gameRef, { host: cleanUsername }, { merge: true });
  }

  const updatedSnap = await getDoc(gameRef);
  const host = updatedSnap.data().host;

if (host === cleanUsername && !hostInitialized) {
  hostInitialized = true;
  console.log("ğŸ‘‘ Confirmed host. Starting rat/termite spawning once.");
  isHost = true;
  console.log("ğŸ‘‘ You are host. Starting cat AI.");
  gameStarted = true;

  // ğŸ‘‡ Wrap this in an async block
  (async () => {
    const nextWaveTime = Date.now() + 30000; // first wave in 30s
    await updateDoc(doc(db, `games/${gameId}`), {
      nextRatWave: nextWaveTime
    });
    console.log("ğŸ•’ Scheduled first rat wave at", new Date(nextWaveTime).toLocaleTimeString());
  })();




  // Start initial cat behavior loop
  startCatBehaviorLoop();

  setInterval(async () => {
  if (gameStarted) {
    catPower++;

    const playerCount = Object.keys(players).length;
    catHealth += 15 * playerCount;

    console.log(`ğŸ”‹ Cat power increased to ${catPower} | Health +${15 * playerCount} â†’ ${catHealth}`);

    await updateDoc(doc(db, `games/${gameId}`), {
      catPower,
      cat: { ...catPos, health: catHealth }
    });

    startCatBehaviorLoop();
  }
}, 20000);
   setInterval(() => {
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      if (grid[y][x] === "ğŸª³") {
        // ğŸ” Count nearby cheese beacons
        let beaconBonus = 0;
        for (let dy = -2; dy <= 2; dy++) {
          for (let dx = -2; dx <= 2; dx++) {
            const nx = x + dx;
            const ny = y + dy;
            if (
              nx >= 0 && nx < gridSize &&
              ny >= 0 && ny < gridSize &&
              grid[ny][nx] === "ğŸ—¼"
            ) {
              beaconBonus++;
            }
          }
        }

        // ğŸ’¥ Total fleas to spawn
        const spawnCount = 1 + beaconBonus;

        for (let i = 0; i < spawnCount; i++) {
          // ğŸŒ€ Try to spawn in a random nearby offset from the nest
          const offsets = [
            { dx: 0, dy: 0 },
            { dx: 1, dy: 0 },
            { dx: -1, dy: 0 },
            { dx: 0, dy: 1 },
            { dx: 0, dy: -1 },
            { dx: 1, dy: 1 },
            { dx: -1, dy: -1 },
            { dx: 1, dy: -1 },
            { dx: -1, dy: 1 }
          ];

          const offset = offsets[Math.floor(Math.random() * offsets.length)];
          const fx = x + offset.dx;
          const fy = y + offset.dy;

          if (
            fx >= 0 && fx < gridSize &&
            fy >= 0 && fy < gridSize &&
            !fleas.some(f => f.x === fx && f.y === fy) // no overlap
          ) {
            fleas.push({ x: fx, y: fy, lifetime: 15 });
          }
        }
      }
    }
  }
}, 4000);
  setInterval(async () => {
  for (let i = fleas.length - 1; i >= 0; i--) {
    const flea = fleas[i];
    let target = null;
    let minDist = Infinity;

    // ğŸ” Target cat
    const distToCat = Math.abs(catPos.x - flea.x) + Math.abs(catPos.y - flea.y);
    if (distToCat < minDist) {
      minDist = distToCat;
      target = { x: catPos.x, y: catPos.y, type: "cat" };
    }

    // ğŸ” Target nearest rat
    for (let rat of rats) {
      const dist = Math.abs(rat.x - flea.x) + Math.abs(rat.y - flea.y);
      if (dist < minDist && rat.health > 0) {
        minDist = dist;
        target = { x: rat.x, y: rat.y, type: "rat", rat };
      }
    }

    // ğŸ” Target nearest ox
    for (let ox of oxen) {
      const dist = Math.abs(ox.x - flea.x) + Math.abs(ox.y - flea.y);
      if (dist < minDist && ox.health > 0) {
        minDist = dist;
        target = { x: ox.x, y: ox.y, type: "ox", ox };
      }
    }

    // ğŸš¶ Move flea
    if (target) {
      let dx = 0, dy = 0;
      const xDiff = target.x - flea.x;
      const yDiff = target.y - flea.y;

      if (Math.abs(xDiff) > Math.abs(yDiff)) {
        dx = Math.sign(xDiff);
      } else {
        dy = Math.sign(yDiff);
      }

      const newX = flea.x + dx;
      const newY = flea.y + dy;

      if (newX >= 0 && newX < gridSize && newY >= 0 && newY < gridSize) {
        flea.x = newX;
        flea.y = newY;
      }

      // ğŸ’¥ Attack if reached
      if (flea.x === target.x && flea.y === target.y) {
        flea.lifetime = 0;

        if (target.type === "cat") {
          catHealth -= 1;
          await updateDoc(doc(db, `games/${gameId}`), {
            cat: { ...catPos, health: catHealth }
          });
        } else if (target.type === "rat" && target.rat) {
  target.rat.health -= 5;
  const ratRef = doc(db, `games/${gameId}/rats/${target.rat.id}`);
  if (target.rat.health <= 0) {
    const index = rats.indexOf(target.rat);
    if (index !== -1) rats.splice(index, 1);
    await deleteDoc(ratRef);
  } else {
    await updateDoc(ratRef, { health: target.rat.health });
  }
} else if (target.type === "ox" && target.ox) {
  target.ox.health -= 5;
  const oxRef = doc(db, `games/${gameId}/oxen/${target.ox.id}`);
  if (target.ox.health <= 0) {
    const index = oxen.indexOf(target.ox);
    if (index !== -1) oxen.splice(index, 1);
    await deleteDoc(oxRef);
  } else {
    await updateDoc(oxRef, { health: target.ox.health });
  }
}

      }
    }

    // ğŸ§¼ Decrease lifetime and remove dead flea
    flea.lifetime--;
    if (flea.lifetime <= 0) {
      const fleaRef = doc(db, `games/${gameId}/fleas/${flea.id}`);
      await deleteDoc(fleaRef);
      fleas.splice(i, 1);
    }
  }

  renderGrid();
}, 400);



  setInterval(() => {
  if (!wallMasterActive || !isAlive) return;

  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      const tx = playerPos.x + dx;
      const ty = playerPos.y + dy;
      const key = `${tx}_${ty}`;
      if (
        tx >= 0 && tx < gridSize &&
        ty >= 0 && ty < gridSize &&
        (grid[ty][tx] === "ğŸ§±" || grid[ty][tx] === "ğŸ’") &&
        structureHealth[key] < 180
      ) {
        structureHealth[key] += 5;
        updateDoc(doc(db, `games/${gameId}/structures/${key}`), {
          health: structureHealth[key]
        });
      }
    }
  }
}, 1000);
 setInterval(async () => {
  for (let i = termites.length - 1; i >= 0; i--) {
    let termite = termites[i];
    let closestWall = null;
    let minDist = Infinity;

    // ğŸ” Find nearest wall
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        if (grid[y][x] === "ğŸ§±" || grid[y][x] === "ğŸ’" || grid[y][x] === "ğŸŒ¿") {
          const dist = Math.abs(termite.x - x) + Math.abs(termite.y - y);
          if (dist < minDist) {
            minDist = dist;
            closestWall = { x, y };
          }
        }
      }
    }

    if (closestWall) {
      const path = findPath(termite.x, termite.y, closestWall.x, closestWall.y, (x, y) => {
      return !["ğŸ§±", "ğŸ”«", "ğŸª³", "ğŸ­", "ğŸ’", "ğŸ—¼", "ğŸš€", "ğŸŒ³", "ğŸŒ¿"].includes(grid[y][x]);
      });

      if (path && path.length > 0) {
        const next = path[0];
        termite.x = next.x;
        termite.y = next.y;

        // âœ… Update termite position in Firestore
        if (termite.id) {
          await updateDoc(doc(db, `games/${gameId}/termites/${termite.id}`), {
            x: termite.x,
            y: termite.y
          });
        }
      }

      // ğŸ’¥ If on wall, damage it and self-destruct
      if (termite.x === closestWall.x && termite.y === closestWall.y) {
        await damageStructure(termite.x, termite.y, 40); // ğŸ›  40 damage to wall
        console.log("ğŸ’¥ Termite hit wall and died");

        if (termite.id) {
          await deleteDoc(doc(db, `games/${gameId}/termites/${termite.id}`));
        }

        termites.splice(i, 1); // remove locally
      }
    }
  }

  renderGrid();
}, 400);


 setInterval(async () => {
  if (!gameStarted) return;

  // ğŸ” Find a Phoenix Cheese tile
  let phoenixSpot = null;
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      if (grid[y][x] === "ğŸ¦â€ğŸ”¥") {
        phoenixSpot = { x, y };
        break;
      }
    }
    if (phoenixSpot) break;
  }

  if (!phoenixSpot) return; // No Phoenix Cheese exists

  // ğŸ” Find a dead player
  let revivedSomeone = false;
  for (const [name, p] of Object.entries(players)) {
    if (p.alive === false) {
      console.log(`ğŸ”¥ Phoenix Cheese revived ${name} at (${phoenixSpot.x}, ${phoenixSpot.y})`);

      // Revive the player and move them to the Phoenix
      await updateDoc(doc(db, `games/${gameId}/players/${name}`), {
        alive: true,
        x: phoenixSpot.x,
        y: phoenixSpot.y
      });

      revivedSomeone = true;
      break; // Only revive one player per check
    }
  }

  // âœ… Always remove Phoenix Cheese after use
  if (revivedSomeone) {
    const key = `${phoenixSpot.x}_${phoenixSpot.y}`;
    grid[phoenixSpot.y][phoenixSpot.x] = "";
    delete structureHealth[key];
    await deleteDoc(doc(db, `games/${gameId}/structures/${key}`));

    const cell = document.getElementById(`cell-${phoenixSpot.x}-${phoenixSpot.y}`);
    if (cell) {
      cell.style.backgroundColor = "#ff4d4d";
      setTimeout(() => {
        cell.style.backgroundColor = "#c8f7c5";
      }, 300);
    }

    renderGrid();
  }
}, 2000);

setInterval(async () => {
  const usedKeys = new Set();

  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      if (grid[y][x] === "ğŸŒ³") {
        const offsets = [
          { dx: 0, dy: 1 }, { dx: 1, dy: 0 }, { dx: 0, dy: -1 }, { dx: -1, dy: 0 },
          { dx: 1, dy: 1 }, { dx: -1, dy: -1 }, { dx: 1, dy: -1 }, { dx: -1, dy: 1 }
        ];

        for (let offset of offsets) {
          const sx = x + offset.dx;
          const sy = y + offset.dy;
          const key = `${sx}_${sy}`;

          if (
            sx >= 0 && sx < gridSize &&
            sy >= 0 && sy < gridSize &&
            grid[sy][sx] === "" &&
            !usedKeys.has(key)
          ) {
            usedKeys.add(key);

            const id = `squirrel_${crypto.randomUUID()}`;
            const squirrel = {
              id,
              x: sx,
              y: sy,
              health: 10,
              createdAt: Date.now()
            };

            await setDoc(doc(db, `games/${gameId}/squirrels/${id}`), squirrel);
            break; // spawn only 1 squirrel per tree per cycle
          }
        }
      }
    }
  }
}, 30000);



setInterval(turretAttack, 1500);
  setInterval(squirrelAcornAttack, 3000);
   setInterval(rocketTowerAttack, 3500);

  setInterval(() => {
  ratPower++;
  console.log(`ğŸ€ Rat Power increased! New base health: ${ratPower}`);
}, 120000); // 2 minutes = 120,000 ms 
setInterval(async () => {
  if (!gameStarted || catPower <= 0) return;

  const centerX = Math.floor(gridSize / 2);
  const centerY = Math.floor(gridSize / 2);
  const numToSpawn = Math.ceil(catPower / 2);
  const offsets = [
    { x: 0, y: 0 }, { x: 1, y: 0 }, { x: -1, y: 0 },
    { x: 0, y: 1 }, { x: 0, y: -1 }, { x: 1, y: 1 },
    { x: -1, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 1 }
  ];

  let spawned = 0;
  for (let i = 0; i < offsets.length && spawned < numToSpawn; i++) {
    const ox = centerX + offsets[i].x;
    const oy = centerY + offsets[i].y;

    if (
      ox >= 0 && ox < gridSize &&
      oy >= 0 && oy < gridSize &&
      !termites.some(t => t.x === ox && t.y === oy)
    ) {
      const id = `termite_${Date.now()}_${i}`;
      const termite = { x: ox, y: oy, id };
      await setDoc(doc(db, `games/${gameId}/termites/${id}`), termite);
      termites.push(termite); // âœ… push with id
      spawned++;
    }
  }

  console.log(`ğŸ› Spawned ${spawned} termites in center`);
}, 60000);
setInterval(async () => {
  const now = Date.now();

  // ğŸ” Trigger rage mode every 60s
  if (now % 60000 < 800) {
    for (const ox of oxen) {
      ox.rageUntil = now + 10000; // Rage for 10 seconds
    }
  }

  for (let i = oxen.length - 1; i >= 0; i--) {
    const ox = oxen[i];
    const isRaging = ox.rageUntil && Date.now() < ox.rageUntil;

    let target = null;

    if (isRaging) {
      // ğŸ¯ Rage mode: chase nearest player
      let minDist = Infinity;
      for (const name in players) {
        const player = players[name];
        if (player.alive) {
          const dist = Math.abs(ox.x - player.x) + Math.abs(ox.y - player.y);
          if (dist < minDist) {
            minDist = dist;
            target = { x: player.x, y: player.y, type: "player", name };
          }
        }
      }
    } else {
      // ğŸ¯ Normal mode: target walls
      let minDist = Infinity;
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          const symbol = grid[y][x];
      if (symbol === "ğŸ’" || symbol === "ğŸ§±" || symbol === "ğŸŒ³" || symbol === "ğŸŒ¿") {
            const dist = Math.abs(x - ox.x) + Math.abs(y - ox.y);
            const priority = symbol === "ğŸ’" ? 0 : 1;
            if (
              dist < minDist ||
              (dist === minDist && priority < (target?.priority ?? 1))
            ) {
              minDist = dist;
              target = { x, y, symbol, priority, type: "structure" };
            }
          }
        }
      }
    }

    if (target) {
      const walkable = (x, y) => {
        if (isRaging) return grid[y][x] === "";
return !["ğŸ§±", "ğŸ”«", "ğŸª³", "ğŸ­", "ğŸ’", "ğŸ—¼", "ğŸš€", "ğŸŒ³", "ğŸŒ¿"].includes(grid[y][x]);
      };

      const path = findPath(ox.x, ox.y, target.x, target.y, walkable);

      if (path && path.length > 0) {
        const next = path[0];
        const blockingSymbol = grid[next.y][next.x];
if (isRaging && ["ğŸ§±", "ğŸ’", "ğŸŒ¿"].includes(blockingSymbol)) {
          // ğŸ”¨ Attack blocking wall during rage
          await damageStructure(next.x, next.y, 20);
          console.log(`ğŸŸ¥ Ox smashes wall at (${next.x}, ${next.y})`);
        } else {
          ox.x = next.x;
          ox.y = next.y;
        }

        // ğŸ”„ Sync position
        if (ox.id) {
          await updateDoc(doc(db, `games/${gameId}/oxen/${ox.id}`), {
            x: ox.x,
            y: ox.y,
            health: ox.health,
            rageUntil: ox.rageUntil || 0
          });
        }
      }

      // ğŸ’¥ Attack if at or adjacent to target
      const dx = Math.abs(ox.x - target.x);
      const dy = Math.abs(ox.y - target.y);
      if ((dx === 0 && dy === 0) || dx + dy === 1) {
        if (target.type === "structure") {
          await damageStructure(target.x, target.y, 30);
          console.log(`ğŸ’¥ Ox attacks ${target.symbol} at (${target.x}, ${target.y})`);
        } else if (target.type === "player") {
          const playerRef = doc(db, `games/${gameId}/players/${target.name}`);
          await updateDoc(playerRef, { alive: false });
          console.log(`â˜ ï¸ Ox kills player ${target.name}`);
        }
        ox.health -= 1;
      }
    }

    // â˜ ï¸ Death cleanup
    if (ox.health <= 0) {
      if (ox.id) {
        await deleteDoc(doc(db, `games/${gameId}/oxen/${ox.id}`));
      }
      oxen.splice(i, 1);
    }
  }

  renderGrid();
}, 800);
setInterval(async () => {
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      if (grid[y][x] === "âš™ï¸") {
        const homeKey = `${x}_${y}`;

        // Check if bot already exists for this catcher
        const botExists = catcherBots.some(bot => bot.homeX === x && bot.homeY === y);
        if (!botExists) {
          const rat = findNearestRat(x, y);
          if (rat) {
            const newBot = {
              x,
              y,
              homeX: x,
              homeY: y,
              targetX: rat.x,
              targetY: rat.y,
              phase: "toRat"
            };
            const botRef = doc(collection(db, `games/${gameId}/catcherBots`));
            await setDoc(botRef, newBot);
          }
        }
      }
    }
  }
}, 20000);

for (let bot of [...catcherBots]) {
  const botRef = doc(db, `games/${gameId}/catcherBots/${bot.id}`);

  let { x, y, targetX, targetY, homeX, homeY, phase } = bot;

  const dx = Math.sign(targetX - x);
  const dy = Math.sign(targetY - y);

  if (dx !== 0) x += dx;
  else if (dy !== 0) y += dy;

  // ğŸ€ Rat reached
  if (phase === "toRat" && x === targetX && y === targetY) {
    const ratIndex = rats.findIndex(r => r.x === x && r.y === y);
    if (ratIndex !== -1) {
      const ratToRemove = rats[ratIndex];
      rats.splice(ratIndex, 1);
      await deleteDoc(doc(db, `games/${gameId}/rats/${ratToRemove.id}`));
    }

    await updateDoc(botRef, {
      x,
      y,
      targetX: homeX,
      targetY: homeY,
      phase: "returning"
    });
  }

  // ğŸ  Home reached
  else if (phase === "returning" && x === homeX && y === homeY) {
    await deleteDoc(botRef);
    cheeseCount++;
    document.getElementById("cheeseCount").textContent = cheeseCount;
  }

  // ğŸš¶ Regular move update
  else {
    await updateDoc(botRef, { x, y });
  }
}


 setInterval(async () => {
    if (!gameStarted) return;

    await updateDoc(doc(db, `games/${gameId}`), {
      cat: { ...catPos, health: catHealth }
    });

    console.log("ğŸ” Cat health sync:", catHealth);
  }, 3000);
setInterval(async () => {
  for (let squirrel of squirrels) {
    if (squirrel.health <= 0) continue;

    const { x: sx, y: sy } = squirrel;

    let target = null;
    let minDist = Infinity;

    // ğŸ¯ Look for nearby enemies within 5 tiles
    const enemies = [...rats, ...oxen];
    if (catPos && catHealth > 0) enemies.push({ ...catPos, type: "cat" });

    for (let e of enemies) {
      const dist = Math.abs(e.x - sx) + Math.abs(e.y - sy);
      if (dist <= 5 && dist < minDist) {
        minDist = dist;
        target = { x: e.x, y: e.y, type: "enemy" };
      }
    }

    // ğŸ­ If no enemy, follow closest alive mouse
    if (!target) {
      for (const [name, p] of Object.entries(players)) {
        if (p.alive !== false) {
          const dist = Math.abs(p.x - sx) + Math.abs(p.y - sy);
          if (dist < minDist) {
            minDist = dist;
            target = { x: p.x, y: p.y, type: "mouse" };
          }
        }
      }
    }

    if (!target) continue;

    const dist = Math.abs(target.x - sx) + Math.abs(target.y - sy);
    if (dist <= 2) continue; // Stay 2 tiles away from target

    // ğŸ§­ Path toward target (ignore obstacles, stay 2 away)
    const step = findSquirrelPath(sx, sy, target.x, target.y, 2);
    if (!step) continue;
    console.log(`ğŸ¿ Moving squirrel ${squirrel.id} from (${sx}, ${sy}) to (${step.x}, ${step.y})`);


    // ğŸ¿ Update local squirrel
    squirrel.x = step.x;
    squirrel.y = step.y;

    // ğŸ” Update only x/y in Firebase (preserve health)
    const squirrelRef = doc(db, `games/${gameId}/squirrels/${squirrel.id}`);
    await updateDoc(squirrelRef, {
      x: step.x,
      y: step.y
    });
  }

  // ğŸ§¹ Remove dead squirrels
  for (let i = squirrels.length - 1; i >= 0; i--) {
    if (squirrels[i].health <= 0) {
      const squirrelRef = doc(db, `games/${gameId}/squirrels/${squirrels[i].id}`);
      await deleteDoc(squirrelRef);
      squirrels.splice(i, 1);
    }
  }

  renderGrid();
}, 500);
setInterval(async () => {
  if (!isHost) return;

  const newVines = [];

  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      if (grid[y][x] === "ğŸŒ¿") {
        const directions = shuffle([
          { dx: 1, dy: 0 },
          { dx: -1, dy: 0 },
          { dx: 0, dy: 1 },
          { dx: 0, dy: -1 }
        ]);

        for (const { dx, dy } of directions) {
          const nx = x + dx, ny = y + dy;
          if (
            nx >= 0 && nx < gridSize &&
            ny >= 0 && ny < gridSize &&
            grid[ny][nx] === ""
          ) {
            newVines.push({ x: nx, y: ny });
            break; // âœ… Only spawn ONE vine per existing vine wall
          }
        }
      }
    }
  }

  for (const { x, y } of newVines) {
    const key = `${x}_${y}`;
    if (grid[y][x] === "") {
      grid[y][x] = "ğŸŒ¿";
      await setDoc(doc(db, `games/${gameId}/structures/${key}`), {
        x, y, type: "ğŸŒ¿"
      });
    }
  }

  renderGrid();
}, 12000);


setInterval(async () => {
  for (let rat of rats) {
    if (rat.health <= 0) continue;

    // â± Skip if currently trapped
    if (rat.trappedUntil && Date.now() < rat.trappedUntil) continue;

    // ğŸª¤ Check if stepped on a trap
    for (let trap of traps) {
      if (trap.x === rat.x && trap.y === rat.y) {
        console.log("ğŸª¤ Rat trapped!");
        rat.trappedUntil = Date.now() + 3000;

        // ğŸ§¹ Remove trap from Firestore
        const trapKey = `${rat.x}_${rat.y}`;
        await deleteDoc(doc(db, `games/${gameId}/traps/${trapKey}`));

        // ğŸ¨ Optional trap visual flash
        const cell = document.getElementById(`cell-${rat.x}-${rat.y}`);
        if (cell) {
          cell.style.backgroundColor = "#ffcccc";
          setTimeout(() => {
            cell.style.backgroundColor = "#c8f7c5";
          }, 300);
        }

        renderGrid();
        continue;
      }
    }

    let closestTarget = null;
    let minDist = Infinity;

    // ğŸ” Closest mouse
    for (const [name, p] of Object.entries(players)) {
      if (p.alive !== false) {
        const dist = Math.abs(p.x - rat.x) + Math.abs(p.y - rat.y);
        if (dist < minDist) {
          minDist = dist;
          closestTarget = { x: p.x, y: p.y, type: "mouse", name };
        }
      }
    }

    // ğŸ” Closest structure
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        if (["ğŸ§±", "ğŸ”«", "ğŸª³", "ğŸ­", "ğŸ’", "ğŸ—¼", "ğŸš€", "ğŸŒ³", "ğŸŒ¿"].includes(grid[y][x])) {
          const dist = Math.abs(x - rat.x) + Math.abs(y - rat.y);
          if (dist < minDist) {
            minDist = dist;
            closestTarget = { x, y, type: "structure" };
          }
        }
      }
    }

    // ğŸ” Closest squirrel
    for (let squirrel of squirrels) {
      const dist = Math.abs(squirrel.x - rat.x) + Math.abs(squirrel.y - rat.y);
      if (dist < minDist && squirrel.health > 0) {
        minDist = dist;
        closestTarget = { x: squirrel.x, y: squirrel.y, type: "squirrel", id: squirrel.id };
      }
    }

    // ğŸ§­ Pathfind
    if (closestTarget) {
      const path = findPath(rat.x, rat.y, closestTarget.x, closestTarget.y, (x, y) => {
      const isBlocked = ["ğŸ§±", "ğŸ­", "ğŸ’", "ğŸ—¼", "ğŸŒ¿"].includes(grid[y][x]);
        const isReviveCenter = x === Math.floor(gridSize / 2) && y === Math.floor(gridSize / 2);
        const ratOccupied = rats.some(r => r !== rat && r.x === x && r.y === y);
        return !isBlocked && !isReviveCenter && !ratOccupied;
      });

      if (path && path.length > 0) {
        const next = path[0];
        const ratInTheWay = rats.some(r => r !== rat && r.x === next.x && r.y === next.y);
        if (!ratInTheWay) {
          rat.x = next.x;
          rat.y = next.y;

          // ğŸ”„ Sync position
          await updateDoc(doc(db, `games/${gameId}/rats/${rat.id}`), {
            x: rat.x,
            y: rat.y
          });
        }
      }
    }

    // ğŸ’¥ Attack
    if (rat.x === closestTarget.x && rat.y === closestTarget.y) {
      if (closestTarget.type === "structure") {
        damageStructure(rat.x, rat.y, ratPower);
      } else if (closestTarget.type === "mouse") {
        const playerRef = doc(db, `games/${gameId}/players/${closestTarget.name}`);
        await updateDoc(playerRef, { alive: false });
        if (closestTarget.name === username) {
          isAlive = false;
          document.getElementById("status").textContent = "ğŸ’€ You are dead!";
        }
      } else if (closestTarget.type === "squirrel") {
        const squirrel = squirrels.find(s => s.id === closestTarget.id);
        if (squirrel) {
          squirrel.health -= ratPower;
          const squirrelRef = doc(db, `games/${gameId}/squirrels/${squirrel.id}`);
          await updateDoc(squirrelRef, { health: squirrel.health });
        }
      }
    }
  }

  // ğŸ§¹ Clean up dead rats
  for (let i = rats.length - 1; i >= 0; i--) {
    if (rats[i].health <= 0) {
      await deleteDoc(doc(db, `games/${gameId}/rats/${rats[i].id}`));
      rats.splice(i, 1);
    }
  }

  renderGrid();
}, 400);

}
})();



</script>
</body>
</html>
