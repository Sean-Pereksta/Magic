<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>ğŸ­ Cat vs Mouse</title>

  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      background: #f4f4f4;
      margin: 0;
      padding: 0;
    }
    h1 { margin: 10px 0; }

    #gridWrapper{
      width: 400px;
      height: 400px;
      border: 3px solid black;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto;
      background: #eaeaea;
    }
    #grid{
      display: grid;
      justify-content: center;
      margin: 0 auto;
      position: relative;
      z-index: 0;
    }

    .cell{
      width: 20px;
      height: 20px;
      text-align: center;
      font-size: 16px;
      position: relative;
      background: #c8f7c5;
    }
    .name{
      font-size: 10px;
      position: absolute;
      top: -12px;
      left: 0;
      right: 0;
      text-align: center;
      pointer-events:none;
      user-select:none;
    }
    .health-bar{
      position: absolute;
      top: -6px;
      left: 0;
      height: 3px;
      background-color: red;
      border-radius: 1px;
      pointer-events:none;
      user-select:none;
    }

    #catHealthContainer{ margin-top: 10px; }
    #catHealthBar{
      height: 20px;
      width: 300px;
      background: lightgray;
      position: relative;
      border-radius: 8px;
      margin: 0 auto;
    }
    #catHealthFill{
      height: 100%;
      width: 100%;
      background: red;
      border-radius: 8px;
    }
    #catHealthText{
      position: absolute;
      width: 100%;
      top: 0;
      text-align: center;
      font-weight: bold;
    }

    #mobileControls{
      display: none;
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 25;
      background: rgba(245,245,245,0.96);
      border-top: 2px solid #bbb;
      padding: 6px 8px calc(20px + env(safe-area-inset-bottom));
      box-shadow: 0 -8px 18px rgba(0,0,0,0.2);
    }

    .mobile-row{ display:flex; justify-content:center; align-items:center; gap:6px; flex-wrap:nowrap; margin:4px 0; }
    .mobile-row.controls-top{
      flex-wrap: wrap;
      gap: 8px;
    }
    #mobileControls .pad{ background:#fff; border:1px solid #999; border-radius:10px; }
    #mobileControls .active{ background:#d4e8ff; border-color:#5591d3; }

    .mobile-mini-btn{
      font-size: 13px;
      padding: 7px 9px;
      margin: 0;
      border-radius: 8px;
    }

    .analog-stick{
      width: 106px;
      height: 106px;
      border-radius: 50%;
      border: 2px solid #778;
      background: radial-gradient(circle at 35% 35%, #fefefe, #d9dce5);
      position: relative;
      touch-action: none;
      flex-shrink: 0;
    }

    .analog-thumb{
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: #667;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      box-shadow: inset 0 2px 4px rgba(255,255,255,0.35);
    }

    .analog-control{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:4px;
    }

    .analog-label{
      font-size:11px;
      font-weight:700;
      color:#333;
    }

    #mobileBuildPicker{
      display:flex;
      align-items:center;
      gap:6px;
      background:#fff;
      border:1px solid #999;
      border-radius:10px;
      padding:4px 5px;
      max-width: 185px;
    }

    #mobileBuildDisplay{
      min-width: 92px;
      font-size: 12px;
      font-weight: 700;
      line-height: 1.15;
    }

    #fullscreenBtn{
      position: fixed;
      top: 8px;
      right: 8px;
      z-index: 30;
      display: none;
      font-size: 14px;
      padding: 8px 10px;
      border-radius: 10px;
    }

    button, select{
      font-size: 20px;
      padding: 14px 20px;
      margin: 6px;
    }

    html, body { touch-action: manipulation; }

    @media (max-width: 768px){
      #mobileControls{ display: block; }
      #fullscreenBtn{ display: inline-block; }
      #grid{ margin-top: 10px; }
      body{ padding-bottom: 210px; }
      #gridWrapper{ width: min(96vw, 400px); height: min(96vw, 400px); }
      .cell{ width: min(20px, 96vw/30); height: min(20px, 96vw/30); font-size: 14px; }

      #selectionOverlay{
        align-items:flex-start;
        justify-content:center;
        padding:8px;
      }
      #selectionCard{
        margin-top:6px;
        max-height:calc(100vh - 16px);
        border-radius:12px;
        overflow-y:auto;
        -webkit-overflow-scrolling:touch;
      }
      #selectionGrid{ max-height:30vh; }
    }

    #waveCountdown{
      margin-top: 8px;
      font-weight: 700;
      font-size: 16px;
    }

    .structure-health-shell{
      position:absolute;
      left:1px;
      right:1px;
      top:-5px;
      height:3px;
      background:rgba(20,20,20,0.32);
      border-radius:8px;
      overflow:hidden;
      border:1px solid rgba(0,0,0,0.2);
      pointer-events:none;
    }

    .structure-health-fill{
      height:100%;
      border-radius:8px;
      transition:width 0.2s ease;
      background:linear-gradient(90deg,#ef4444,#f59e0b,#22c55e);
    }

    .combat-vfx{
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%, -50%);
      pointer-events:none;
      z-index:6;
      text-shadow: 0 0 6px rgba(0,0,0,0.35);
      user-select:none;
    }
    .vfx-flame{ animation:vfxFlame 0.45s ease-out forwards; }
    .vfx-hit{ animation:vfxHit 0.4s ease-out forwards; }
    .vfx-explosion{ animation:vfxExplosion 0.65s ease-out forwards; }
    .vfx-pop{ animation:vfxPop 0.45s ease-out forwards; }
    .vfx-claw{ animation:vfxClaw 0.55s ease-out forwards; color:#a30f0f; }

    #selectionOverlay{ position:fixed; inset:0; background:rgba(2,6,23,0.78); backdrop-filter: blur(3px); z-index:40; display:none; align-items:center; justify-content:center; padding:14px; }
    #selectionCard{ background:linear-gradient(180deg,#ffffff 0%,#f8fbff 100%); border-radius:14px; padding:14px; max-width:940px; width:100%; max-height:90vh; overflow:auto; border:1px solid #dbeafe; box-shadow:0 10px 30px rgba(15,23,42,0.25); }
    #selectionGrid{ display:grid; grid-template-columns:repeat(auto-fill,minmax(145px,1fr)); gap:8px; max-height:40vh; overflow:auto; padding-right:4px; }
    #slotList{ display:grid; grid-template-columns:repeat(auto-fit,minmax(115px,1fr)); gap:8px; margin-bottom:10px; }
    .slot-chip{ border:1px solid #bfdbfe; background:#eff6ff; border-radius:10px; padding:7px 8px; font-size:13px; text-align:left; min-height:44px; }
    .slot-chip.filled{ border-color:#60a5fa; background:#dbeafe; }
    .slot-chip.done{ opacity:0.9; }
    .sel-btn{ border:1px solid #bfdbfe; background:#f8fbff; border-radius:10px; padding:8px; font-size:13px; text-align:left; }
    .sel-btn.locked{ opacity:0.55; background:#e5e7eb; }
    .sel-btn.chosen{ border-color:#22c55e; background:#dcfce7; }
    #selectedBuildSlotsTop{ max-width:900px; margin:6px auto 0; font-size:13px; color:#1f2937; background:#eff6ff; border:1px solid #bfdbfe; border-radius:10px; padding:6px 10px; }

    @keyframes vfxFlame{
      0% { opacity:1; transform:translate(-50%, -50%) scale(0.4) rotate(-10deg); }
      50%{ opacity:0.95; transform:translate(-50%, -65%) scale(1.1) rotate(6deg); }
      100%{ opacity:0; transform:translate(-50%, -85%) scale(1.45) rotate(-3deg); }
    }
    @keyframes vfxHit{
      0% { opacity:1; transform:translate(-50%, -50%) scale(0.45); }
      100%{ opacity:0; transform:translate(-50%, -50%) scale(1.35); }
    }
    @keyframes vfxExplosion{
      0% { opacity:1; transform:translate(-50%, -50%) scale(0.3); }
      35% { opacity:1; transform:translate(-50%, -50%) scale(1.35); }
      100%{ opacity:0; transform:translate(-50%, -50%) scale(1.95); }
    }
    @keyframes vfxPop{
      0% { opacity:1; transform:translate(-50%, -50%) scale(0.2); }
      70%{ opacity:1; transform:translate(-50%, -50%) scale(1.2); }
      100%{ opacity:0; transform:translate(-50%, -50%) scale(1.55); }
    }
    @keyframes vfxClaw{
      0% { opacity:1; transform:translate(-50%, -50%) scale(0.5) rotate(-12deg); }
      55%{ opacity:1; transform:translate(-50%, -50%) scale(1.05) rotate(10deg); }
      100%{ opacity:0; transform:translate(-50%, -50%) scale(1.35) rotate(0deg); }
    }
  </style>
</head>

<body>
  <button id="fullscreenBtn" aria-label="Toggle full screen">â›¶ Fullscreen</button>
  <h1 style="text-align:center;">ğŸ± Cat vs ğŸ­ Mouse</h1>

  <div style="text-align:center; margin-bottom:10px;">
    <p style="margin:5px 0; font-size:14px; color:#444;">
      ğŸ® Arrow keys to move | A/W/S/D to build | 1â€“8 to select building | Space = Upgrade Menu
    </p>
    <p style="margin:10px 0; font-size:13px; font-weight:bold; color:#333;">
      ğŸ§± Wall | ğŸ”« Turret | ğŸª³ Flea Nest | ğŸ­ Generator | ğŸ’ Super Wall | ğŸ—¼ Beacon | ğŸ¦â€ğŸ”¥ Phoenix | ğŸš€ Rocket | ğŸ› ï¸ Repair
      <br>ğŸ§€ Cheese Farm | ğŸ‡ Rabbit Den | ğŸ›¡ï¸ Shield Tower | â˜„ï¸ Ultra Laser | âš¡ Tesla | ğŸŸ¢ Slime Tower
    </p>
  </div>

  <div id="returnButton" style="display:none; margin-top:20px; text-align:center;">
    <button onclick="returnToLobby()" style="padding:10px 20px; font-size:16px;">ğŸ”™ Return to Lobby</button>
  </div>

  <div id="selectionOverlay">
    <div id="selectionCard">
      <h3 style="margin:0 0 8px;">ğŸ—ï¸ Select up to 8 Structures (in order)</h3>
      <div id="selectionInfo" style="font-size:13px; margin-bottom:8px;"></div>
      <div id="difficultyPanel" style="margin:0 0 10px; padding:8px; border:1px solid #bbb; border-radius:8px; background:#f8fafc;">
        <div style="font-weight:bold; margin-bottom:4px;">ğŸšï¸ Difficulty Vote (locks when selection ends)</div>
        <div id="difficultyStatus" style="font-size:12px; color:#333; margin-bottom:6px;">Current: Medium</div>
        <div style="display:flex; flex-wrap:wrap; gap:4px;">
          <button class="difficulty-vote" data-diff="easy">Easy</button>
          <button class="difficulty-vote" data-diff="medium">Medium</button>
          <button class="difficulty-vote" data-diff="hard">Hard</button>
          <button class="difficulty-vote" data-diff="insane">Insane</button>
        </div>
      </div>
      <div id="selectedSlots" style="font-size:13px; margin-bottom:6px;"></div>
      <div id="slotList"></div>
      <div id="selectionGrid"></div>
      <div style="margin-top:8px; display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;">
        <button id="finishSelectionBtn" style="font-size:15px; padding:8px 12px;">âœ… Finalize Selection</button>
        <div id="selectionFinalizeMeta" style="font-size:13px; color:#374151;"></div>
      </div>
    </div>
  </div>

  <div id="selectedBuildSlotsTop">Slots â€” 1: _ | 2: _ | 3: _ | 4: _ | 5: _ | 6: _ | 7: _ | 8: _</div>

  <div id="waveCountdown">ğŸ€ Next wave: ?</div>

  <div style="display:flex; justify-content:center; align-items:flex-start; gap:20px; margin-top:20px;">
    <div style="width:200px; font-size:14px;">
      <p><strong>ğŸ§€ Cheese:</strong> <span id="cheeseCount">0</span></p>
      <p><strong>âš¡ Advancement Points:</strong> <span id="advPoints">0</span></p>
      <div style="margin:8px 0 10px;">
        <div style="font-weight:bold; margin-bottom:3px;">ğŸ­ Generator Cheese Timer</div>
        <div style="height:10px; border:1px solid #666; border-radius:8px; overflow:hidden; background:#f3f4f6;">
          <div id="generatorTimerFill" style="height:100%; width:0%; background:linear-gradient(90deg,#facc15,#f59e0b);"></div>
        </div>
        <div id="generatorTimerText" style="font-size:12px; color:#444; margin-top:2px;">No generators built.</div>
      </div>
      <div style="margin:6px 0 10px;">
        <div style="font-weight:bold; margin-bottom:3px;">ğŸ† Achievement Point Countdown</div>
        <div style="height:10px; border:1px solid #666; border-radius:8px; overflow:hidden; background:#f3f4f6;">
          <div id="advPointTimerFill" style="height:100%; width:0%; background:linear-gradient(90deg,#22c55e,#16a34a);"></div>
        </div>
        <div id="advPointTimerText" style="font-size:12px; color:#444; margin-top:2px;">Waiting for game startâ€¦</div>
      </div>
      <p><strong>ğŸ”¨ Selected Build:</strong> <span id="buildType">None</span></p>

      <div id="abilityStatus" style="margin-top:10px;"></div>

      <p id="advPointMessage" style="color:green; font-weight:bold; display:none; margin:5px 0;">
        ğŸŸ¢ You gained an advancement point!
      </p>

      <p id="status"></p>

      <div id="playerStatus" style="margin-top:10px;"></div>
      <div id="hostDisplay" style="margin-top:10px; font-weight:bold; color:#333;"></div>

      <div id="upgradeMenu" style="display:none; background:#eee; border:2px solid #888; padding:10px; margin-top:10px;">
        <h3>ğŸ”§ Upgrade Menu</h3>
        <div id="mobileUpgradeButtons" style="margin:10px 0;"></div>
        <p>
          <b>1</b> â€“ ğŸƒ <strong>Speedster</strong><br>
          <b>2</b> â€“ ğŸ§€ <strong>Scavenger</strong><br>
          <b>3</b> â€“ ğŸ <strong>Flea Master</strong><br>
          <b>4</b> â€“ ğŸ§± <strong>Wall Master</strong><br>
          <b>5</b> â€“ ğŸª¤ <strong>Trapmaster</strong><br>
          <b>6</b> â€“ ğŸŒ€ <strong>Blink</strong>
        </p>
        <p>Chosen: <span id="chosenUpgrades"></span></p>
      </div>
    </div>

    <div>
      <div id="gridWrapper"><div id="grid"></div></div>

      <div id="mobileControls" style="margin-top:20px; display:none;">
        <div class="mobile-row controls-top">
          <button class="mobile-mini-btn" data-upgrade>ğŸ› ï¸</button>
          <button class="mobile-mini-btn" data-blink>ğŸŒ€</button>
          <button class="mobile-mini-btn" data-trap>ğŸª¤</button>
          <div id="mobileBuildPicker">
            <button class="mobile-mini-btn" id="mobileBuildPrev" aria-label="Previous building">â¬…ï¸</button>
            <div id="mobileBuildDisplay">ğŸ§± Wall</div>
            <button class="mobile-mini-btn" id="mobileBuildNext" aria-label="Next building">â¡ï¸</button>
          </div>
        </div>

        <div class="mobile-row">
          <div class="analog-control">
            <div class="analog-label">ğŸš¶ Move</div>
            <div id="moveAnalogStick" class="analog-stick" aria-label="Movement analog stick">
              <div id="moveAnalogThumb" class="analog-thumb"></div>
            </div>
          </div>
          <div class="analog-control">
            <div class="analog-label">ğŸ—ï¸ Build</div>
            <div id="buildAnalogStick" class="analog-stick" aria-label="Build analog stick">
              <div id="buildAnalogThumb" class="analog-thumb"></div>
            </div>
          </div>
        </div>

        <div id="structureButtons" style="margin-top:10px; display:none;">
          <strong>Select Structure:</strong><br>
          <button data-struct="1">ğŸ§±</button>
          <button data-struct="2">ğŸ”«</button>
          <button data-struct="3">ğŸª³</button>
          <button data-struct="4">ğŸ­</button>
          <button data-struct="5">ğŸ’</button>
          <button data-struct="6">ğŸ—¼</button>
          <button data-struct="7">ğŸ¦â€ğŸ”¥</button>
          <button data-struct="8">ğŸš€</button>
          <button data-struct="9">ğŸ› ï¸</button>
        </div>

        <div id="upgradeButtons" style="display:none; margin-bottom:12px;">
          <strong>Upgrades:</strong><br>
          <button onclick="selectUpgrade('1')">1 â€“ Speedster</button>
          <button onclick="selectUpgrade('2')">2 â€“ Scavenger</button>
          <button onclick="selectUpgrade('3')">3 â€“ Flea Master</button>
          <button onclick="selectUpgrade('4')">4 â€“ Wall Master</button>
          <button onclick="selectUpgrade('5')">5 â€“ Trapmaster</button>
          <button onclick="selectUpgrade('6')">6 â€“ Blink</button>
        </div>

      </div>

      <div id="catHealthContainer" style="margin-top:10px;">
        <div id="catHealthBar">
          <div id="catHealthFill"></div>
          <div id="catHealthText">â¤ï¸ 1000 / 1000</div>
        </div>
      </div>
    </div>
  </div>

<script type="module">
  // ============================================================
  // Firebase (UPDATED to work with YOUR rules)
  // - Your rules allow: /lobbies/{gameId} and /lobbies/{gameId}/crowncouncil/{docId}
  // - Your rules require auth: request.auth != null
  // So we:
  //   âœ… sign in anonymously
  //   âœ… move all game docs from /games/... to /lobbies/{gameId}/crowncouncil/...
  // ============================================================

  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
  import {
    getFirestore,
    doc,
    getDoc,
    setDoc,
    updateDoc,
    deleteDoc,
    onSnapshot,
    collection,
    getDocs,
    runTransaction
  } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
    authDomain: "bible-game-246c0.firebaseapp.com",
    projectId: "bible-game-246c0"
  };

  const app = initializeApp(firebaseConfig);
  const db  = getFirestore(app);

  // âœ… Auth required by your rules
  const auth = getAuth(app);
  await signInAnonymously(auth);
  const uid = auth.currentUser.uid;

  // ============================================================
  // Routing (use lobbies + crowncouncil so rules allow it)
  // ============================================================
  const urlParams = new URLSearchParams(window.location.search);
  const gameId = urlParams.get("gameId") || "default";
  let username = (urlParams.get("username") || "guest").trim();
  const usernameNorm = username.toLowerCase();

  const lobbyRef = doc(db, `lobbies/${gameId}`);
  const ccCol    = collection(db, `lobbies/${gameId}/crowncouncil`);
  const ccRef    = (id) => doc(db, `lobbies/${gameId}/crowncouncil/${id}`);

  const ID = {
    STATE: "state",
    difficultyVote: (uid) => `difficultyvote_${uid}`,
    player: (uid) => `player_${uid}`,
    structure: (x,y) => `structure_${x}_${y}`,
    trap: (x,y) => `trap_${x}_${y}`,
    rat: (id) => `rat_${id}`,
    ox: (id) => `ox_${id}`,
    rabbit: (id) => `rabbit_${id}`,
    ratKing: (id) => `ratking_${id}`,
    vulture: (id) => `vulture_${id}`,
    termite: (id) => `termite_${id}`,
    flea: (id) => `flea_${id}`,
    // Player-fleas (so a player can â€œownâ€ their flea docs; host moves them)
    pflea: (uid, i) => `pflea_${uid}_${i}`
  };

  // ============================================================
  // Game state
  // ============================================================
  const gridSize = 30;
  const gridElement = document.getElementById("grid");
  const grid = Array.from({length:gridSize}, () => Array.from({length:gridSize}, () => ""));

  let gameStarted = false;

  let playerPos = { x: 1, y: 1 };
  let catPos    = { x: 15, y: 15 };

  let selectedBuild = null;
  let cheeseCount = 0;
  let isAlive = true;

  let catHealth = 1000;
  let maxCatHealth = 1000;
  let catPower  = 0;
  let ratPower  = 1;
  let currentDifficulty = "medium";
  let myDifficultyVote = "";
  let difficultyVotes = {};

  const DIFFICULTY_ORDER = ["easy", "medium", "hard", "insane"];
  const DIFFICULTY_SETTINGS = {
    easy:   { label:"Easy",   catStartHealth:1000, ratBaseHealth:4, oxBaseHealth:18 },
    medium: { label:"Medium", catStartHealth:1500, ratBaseHealth:5, oxBaseHealth:26 },
    hard:   { label:"Hard",   catStartHealth:2000, ratBaseHealth:6, oxBaseHealth:34 },
    insane: { label:"Insane", catStartHealth:3000, ratBaseHealth:8, oxBaseHealth:44 }
  };

  let canMove = true;
  let canBuild = true;
  let moveCooldown = 225; // âœ… was const before; upgrades change it
  let buildCooldown = 225;

  let advancementPoints = 0;
  let upgradeMenuOpen = false;
  let selectedUpgrades = [];

  let fleaSpawnCooldown = 1500;
  let fleaMasterActive = false;
  let cheesePickupBonus = 0;
  let wallMasterActive = false;
  let trapmasterActive = false;
  let blinkActive = false;

  let lastTrapTime = 0;
  let lastBlinkTime = 0;
  let lastDirection = { dx: 0, dy: 0 };

  let showingUpgrades = false;
  const CHEESE_PICKUP = "__CHEESE_PICKUP__";
  const CHEESE_PICKUP_SYMBOL = "ğŸ§€";

  const BUILD_DEFS = {
    1:{symbol:"ğŸ§±",name:"Wall",cost:1,hp:15,minWins:0},
    2:{symbol:"ğŸ”«",name:"Turret",cost:3,hp:5,minWins:0},
    3:{symbol:"ğŸª³",name:"Flea Nest",cost:5,hp:10,minWins:0},
    4:{symbol:"ğŸ­",name:"Generator",cost:4,hp:5,minWins:0},
    5:{symbol:"ğŸ’",name:"Super Wall",cost:6,hp:75,minWins:0},
    6:{symbol:"ğŸ—¼",name:"Cheese Beacon",cost:24,hp:25,minWins:0},
    7:{symbol:"ğŸ¦â€ğŸ”¥",name:"Phoenix Cheese",cost:40,hp:20,minWins:0},
    8:{symbol:"ğŸš€",name:"Rocket Tower",cost:30,hp:20,minWins:0},
    9:{symbol:"ğŸ› ï¸",name:"Repair Station",cost:12,hp:24,minWins:0},
    10:{symbol:"ğŸ§€",name:"Cheese Farm",cost:18,hp:20,minWins:5},
    11:{symbol:"ğŸ‡",name:"Rabbit Den",cost:22,hp:20,minWins:8},
    12:{symbol:"âš¡",name:"Tesla Tower",cost:25,hp:18,minWins:12},
    13:{symbol:"â˜„ï¸",name:"Ultra Laser",cost:35,hp:18,minWins:15},
    14:{symbol:"ğŸ›¡ï¸",name:"Shield Tower",cost:28,hp:22,minWins:20},
    15:{symbol:"ğŸŸ¢",name:"Slime Tower",cost:26,hp:20,minWins:25},
    16:{symbol:"ğŸ”®",name:"Teleporter Crystal",cost:20,hp:16,minWins:15},
    17:{symbol:"ğŸŒ°",name:"Acorn Tower",cost:32,hp:18,minWins:18},
    18:{symbol:"ğŸª­",name:"Whirlwind Fan",cost:24,hp:20,minWins:12}
  };
  const MAX_BUILD_SLOTS = 8;
  const BASE_BUILD_ORDER = [1,2,3,4,5,6,7,8];
  let mobileBuildOrder = [...BASE_BUILD_ORDER];
  let playerWins = 0;
  let selectedBuildSlots = [];
  let mySelectionDone = false;
  let selectionStates = {};
  let selectionDeadlineAt = null;
  let rabbitShots = [];
  let structureShields = {};

  let isHost = false;
  let hostInitialized = false;
  let catMoveInterval = null;

  // â€œRemoteâ€ objects pulled from Firestore
  let players = {}; // uid -> {x,y,cheese,alive,displayName}
  let structureHealth = {}; // key "x_y" -> hp
  let structures = new Map(); // key -> {x,y,type,health}

  let traps = [];     // {x,y,placedAt}
  let rats = [];      // {id,x,y,health,...}
  let oxen = [];      // {id,x,y,health}
  let rabbits = [];   // {id,x,y,health}
  let vultures = [];  // {id,x,y,health}
  let ratKings = [];  // {id,x,y,health}
  let termites = [];  // {id,x,y}
  let fleas = [];     // {id,x,y,lifetime,...}

  let lastPlayerWriteAt = 0;
  let lastPlayerPayload = null;
  let nextRatWaveAt = null;
  let combatVfx = [];
  let lastGeneratorPayoutAt = Date.now();
  let lastAdvPointAt = Date.now();
  let lastAcornShotAt = 0;
  let lastFanBurstAt = 0;

  const GENERATOR_PAYOUT_MS = 15000;
  const ADV_POINT_MS = 180000;

  const STRUCTURE_MAX_HP = {
    "ğŸ§±": 15, "ğŸ”«": 5, "ğŸª³": 10, "ğŸ­": 5,
    "ğŸ’": 75, "ğŸ—¼": 25, "ğŸ¦â€ğŸ”¥": 20, "ğŸš€": 20, "ğŸ› ï¸": 24,
    "ğŸ§€": 20, "ğŸ‡": 20, "âš¡": 18, "â˜„ï¸": 18, "ğŸ›¡ï¸": 22, "ğŸŸ¢": 20, "ğŸ”®": 16, "ğŸŒ°": 18, "ğŸª­": 20
  };

  function isCheesePickupCell(value){
    return value === CHEESE_PICKUP;
  }

  function canPlaceCheesePickupAt(x, y){
    if (x < 0 || y < 0 || x >= gridSize || y >= gridSize) return false;
    return grid[y][x] === "";
  }

  function tryPlaceCheesePickupAt(x, y){
    if (!canPlaceCheesePickupAt(x, y)) return false;
    grid[y][x] = CHEESE_PICKUP;
    return true;
  }

  const localTileSeed = Math.floor(Math.random() * 9973);

  function addCombatVfx(x, y, icon, className, durationMs = 450, size = 16){
    if (x<0 || y<0 || x>=gridSize || y>=gridSize) return;
    combatVfx.push({
      x, y, icon, className, size,
      expiresAt: Date.now() + durationMs
    });
  }

  function showClawHit(x, y){
    addCombatVfx(x, y, "ğŸ—¡ï¸", "vfx-claw", 560, 13);
    addCombatVfx(x, y, "âœ¦", "vfx-hit", 420, 10);
  }

  // ============================================================
  // UI helpers
  // ============================================================
  function updateHostDisplay(hostName){
    document.getElementById("hostDisplay").textContent = `ğŸ‘‘ Host: ${hostName || "Unknown"}`;
  }

  function updateCatHealthBar(){
    const bar  = document.getElementById("catHealthFill");
    const text = document.getElementById("catHealthText");
    const percent = Math.min(100, (catHealth / Math.max(1, maxCatHealth)) * 100);
    bar.style.width = percent + "%";
    text.textContent = `â¤ï¸ ${catHealth}`;
  }

  function toggleMobileMode(){
    showingUpgrades = !showingUpgrades;
    document.getElementById("structureButtons").style.display = showingUpgrades ? "none" : "block";
    document.getElementById("upgradeButtons").style.display   = showingUpgrades ? "block" : "none";
  }
  window.toggleMobileMode = toggleMobileMode;

  async function toggleFullscreen(){
    try {
      if (!document.fullscreenElement) await document.documentElement.requestFullscreen();
      else await document.exitFullscreen();
    } catch {}
  }

  function toggleUpgradeMenu(){
    upgradeMenuOpen = !upgradeMenuOpen;
    document.getElementById("upgradeMenu").style.display = upgradeMenuOpen ? "block" : "none";
  }

  function updateMobileBuildDisplay(){
    const display = document.getElementById("mobileBuildDisplay");
    if (!display) return;
    const def = BUILD_DEFS[selectedBuild];
    display.textContent = def ? `${def.symbol} ${def.name}` : "Select";
  }

  function selectBuild(value){
    selectedBuild = parseInt(value, 10);
    const def = BUILD_DEFS[selectedBuild];
    const text = def ? `${def.name} ${def.symbol} (Cost: ${def.cost})` : "None";
    document.getElementById("buildType").textContent = text;
    updateMobileBuildDisplay();
  }

  function getUnlockedBuildIds(){
    return Object.entries(BUILD_DEFS)
      .filter(([,def]) => playerWins >= (def.minWins || 0))
      .map(([id]) => Number(id));
  }

  function getLobbyParticipants(){
    return Object.entries(players).filter(([,p]) => p && p.uid);
  }

  function getActiveParticipantIds(){
    return getLobbyParticipants()
      .filter(([,p]) => (p?.alive ?? true) !== false)
      .map(([pu]) => pu);
  }

  function applyDifficulty(mode){
    const resolved = DIFFICULTY_SETTINGS[mode] ? mode : "medium";
    currentDifficulty = resolved;
    const cfg = DIFFICULTY_SETTINGS[resolved];
    maxCatHealth = cfg.catStartHealth;
    catHealth = Math.min(catHealth, maxCatHealth);
    updateCatHealthBar();
    updateDifficultyUI();
  }

  function computeDifficultyFromVotes(voteMap){
    const counts = { easy:0, medium:0, hard:0, insane:0 };
    const active = getActiveParticipantIds();
    for (const pu of active){
      const vote = voteMap?.[pu];
      if (counts[vote] !== undefined) counts[vote]++;
    }

    let best = "easy";
    let bestCount = -1;
    for (const key of DIFFICULTY_ORDER){
      const c = counts[key];
      if (c > bestCount){
        best = key;
        bestCount = c;
      }
    }
    if (bestCount <= 0) return "easy";
    return best;
  }

  function updateDifficultyUI(){
    const el = document.getElementById("difficultyStatus");
    if (!el) return;
    const label = DIFFICULTY_SETTINGS[currentDifficulty]?.label || "Medium";
    const myVoteLabel = myDifficultyVote ? (DIFFICULTY_SETTINGS[myDifficultyVote]?.label || myDifficultyVote) : "none";
    const activeVotes = getActiveParticipantIds().reduce((acc, pu) => {
      const vote = difficultyVotes[pu];
      if (vote) acc++;
      return acc;
    }, 0);
    el.textContent = `Current: ${label} â€¢ Your vote: ${myVoteLabel} â€¢ Active votes: ${activeVotes}`;

    document.querySelectorAll(".difficulty-vote").forEach(btn => {
      const key = btn.dataset.diff;
      btn.style.opacity = key === myDifficultyVote ? "1" : "0.75";
      btn.style.fontWeight = key === myDifficultyVote ? "700" : "500";
      btn.disabled = gameStarted;
    });
  }

  async function castDifficultyVote(mode){
    if (!DIFFICULTY_SETTINGS[mode]) return;
    myDifficultyVote = mode;
    updateDifficultyUI();
    await setDoc(ccRef(ID.difficultyVote(uid)), {
      kind: "difficultyvote",
      uid,
      vote: mode,
      updatedAt: Date.now()
    }, { merge:true });
  }

  async function hostSyncDifficultyVote(){
    if (!isHost) return;
    if (gameStarted) return;
    const selected = computeDifficultyFromVotes(difficultyVotes);
    if (selected === currentDifficulty) return;
    const nextHealth = DIFFICULTY_SETTINGS[selected].catStartHealth;
    await updateDoc(ccRef(ID.STATE), {
      difficulty: selected,
      cat: { x: catPos.x, y: catPos.y, health: nextHealth },
      updatedAt: Date.now()
    });
  }


  function getRatHealthForDifficulty(){
    const cfg = DIFFICULTY_SETTINGS[currentDifficulty] || DIFFICULTY_SETTINGS.medium;
    return cfg.ratBaseHealth * ratPower;
  }

  function getOxHealthForDifficulty(){
    const cfg = DIFFICULTY_SETTINGS[currentDifficulty] || DIFFICULTY_SETTINGS.medium;
    return cfg.oxBaseHealth * ratPower;
  }

  function listCombatEnemies(){
    return [
      ...rats.filter(r => (r.health ?? 0) > 0).map(r => ({ kind:"rat", enemy:r })),
      ...oxen.filter(o => (o.health ?? 0) > 0).map(o => ({ kind:"ox", enemy:o })),
      ...ratKings.filter(k => (k.health ?? 0) > 0).map(k => ({ kind:"ratking", enemy:k })),
      ...vultures.filter(v => (v.health ?? 0) > 0).map(v => ({ kind:"vulture", enemy:v }))
    ];
  }

  function getNearestCrystalTarget(fromX, fromY){
    let best = null;
    for (let y=0; y<gridSize; y++) for (let x=0; x<gridSize; x++){
      if (grid[y][x] !== "ğŸ”®") continue;
      const d = Math.abs(x-fromX)+Math.abs(y-fromY);
      if (d===0) continue;
      if (!best || d < best.d) best = { x, y, d };
    }
    return best;
  }

  async function maybeTeleportOnCrystal(){
    if (grid[playerPos.y]?.[playerPos.x] !== "ğŸ”®") return;
    const target = getNearestCrystalTarget(playerPos.x, playerPos.y);
    if (!target) return;
    playerPos = { x: target.x, y: target.y };
    await savePosition();
    addCombatVfx(target.x, target.y, "âœ¨", "vfx-pop", 520, 14);
  }

  function randomPushDestination(srcX, srcY, targetX, targetY, minPush=1, maxPush=2){
    const jitter = Math.floor(Math.random()*3)-1;
    const dx = Math.sign(targetX-srcX) + jitter;
    const dy = Math.sign(targetY-srcY) + (Math.floor(Math.random()*3)-1);
    const nx = Math.max(0, Math.min(gridSize-1, targetX + Math.sign(dx || 1) * (minPush + Math.floor(Math.random()*(maxPush-minPush+1)))));
    const ny = Math.max(0, Math.min(gridSize-1, targetY + Math.sign(dy) * (minPush + Math.floor(Math.random()*(maxPush-minPush+1)))));
    return {x:nx,y:ny};
  }

  async function fetchPlayerWins(){
    try {
      const usersSnap = await getDocs(collection(db, "users"));
      let wins = 0;
      usersSnap.forEach(docSnap => {
        const data = docSnap.data();
        if ((data.username || "").toLowerCase() === usernameNorm) wins = data.wins || 0;
      });
      playerWins = wins;
    } catch {
      playerWins = 0;
    }
  }

  function getSelectionDocId(uidVal){
    return `selection_${uidVal}`;
  }

  function cycleMobileBuild(direction){
    const current = mobileBuildOrder.indexOf(selectedBuild);
    const start = current === -1 ? 0 : current;
    const next = (start + direction + mobileBuildOrder.length) % mobileBuildOrder.length;
    selectBuild(String(mobileBuildOrder[next]));
  }

  function selectUpgrade(key){
    if (!upgradeMenuOpen || advancementPoints <= 0) return;

    const upgradeMap = {
      "1": "Speedster",
      "2": "Scavenger",
      "3": "Flea Master",
      "4": "Wall Master",
      "5": "Trapmaster",
      "6": "Blink"
    };

    const upgrade = upgradeMap[key];
    if (!upgrade || selectedUpgrades.includes(upgrade)) return;

    selectedUpgrades.push(upgrade);
    advancementPoints--;

    document.getElementById("advPoints").textContent = advancementPoints;
    document.getElementById("chosenUpgrades").textContent = selectedUpgrades.join(", ");

    if (upgrade === "Speedster") moveCooldown = 50;
    if (upgrade === "Scavenger") cheesePickupBonus = 7;
    if (upgrade === "Flea Master") fleaMasterActive = true;
    if (upgrade === "Wall Master") wallMasterActive = true;
    if (upgrade === "Trapmaster") trapmasterActive = true;
    if (upgrade === "Blink") blinkActive = true;
  }
  window.selectUpgrade = selectUpgrade;

  function renderMobileUpgradeButtons(){
    const container = document.getElementById("mobileUpgradeButtons");
    container.innerHTML = "";
    const upgrades = [
      { key:"1", name:"Speedster" },
      { key:"2", name:"Scavenger" },
      { key:"3", name:"Flea Master" },
      { key:"4", name:"Wall Master" },
      { key:"5", name:"Trapmaster" },
      { key:"6", name:"Blink" }
    ];
    for (const u of upgrades){
      const btn = document.createElement("button");
      btn.textContent = `${u.key} â€“ ${u.name}`;
      btn.style.margin = "4px";
      btn.onclick = () => {
        const event = new KeyboardEvent("keydown", { key: u.key });
        window.dispatchEvent(event);
      };
      container.appendChild(btn);
    }
  }

  function updateAbilityStatus(){
    const statusDiv = document.getElementById("abilityStatus");
    let content = "";
    const now = Date.now();

    if (blinkActive){
      const cooldown = 8000;
      const remaining = Math.max(0, cooldown - (now - lastBlinkTime));
      const ready = remaining === 0;
      content += `ğŸŒ€ Blink [B]: <span style="color:${ready ? 'green' : 'gray'}">${ready ? "Ready!" : (Math.ceil(remaining/1000)+"s")}</span><br>`;
    }

    if (trapmasterActive){
      const cooldown = 20000;
      const remaining = Math.max(0, cooldown - (now - lastTrapTime));
      const ready = remaining === 0;
      content += `ğŸª¤ Trap [T]: <span style="color:${ready ? 'green' : 'gray'}">${ready ? "Ready!" : (Math.ceil(remaining/1000)+"s")}</span><br>`;
    }

    statusDiv.innerHTML = content;
  }

  function updateEconomyTimersUI(){
    const now = Date.now();

    const genFill = document.getElementById("generatorTimerFill");
    const genText = document.getElementById("generatorTimerText");
    const me = players[uid] || { x: playerPos.x, y: playerPos.y, alive: isAlive };
    const nearbyGenerators = [];

    for (let y=0; y<gridSize; y++){
      for (let x=0; x<gridSize; x++){
        if (grid[y][x] !== "ğŸ­") continue;
        const dist = Math.abs((me.x ?? playerPos.x) - x) + Math.abs((me.y ?? playerPos.y) - y);
        if (dist <= 9) nearbyGenerators.push({x,y});
      }
    }

    const genElapsed = (now - lastGeneratorPayoutAt) % GENERATOR_PAYOUT_MS;
    const genProgress = Math.max(0, Math.min(100, (genElapsed / GENERATOR_PAYOUT_MS) * 100));
    const genRemaining = Math.max(0, Math.ceil((GENERATOR_PAYOUT_MS - genElapsed) / 1000));
    genFill.style.width = `${genProgress}%`;

    if (nearbyGenerators.length > 0){
      genText.textContent = `${nearbyGenerators.length} active near you â€¢ payout in ${genRemaining}s`;
    } else if (grid.some(row => row.includes("ğŸ­"))){
      genText.textContent = `Generators exist, move within 9 tiles â€¢ ${genRemaining}s`;
    } else {
      genText.textContent = "No generators built.";
    }

    const advFill = document.getElementById("advPointTimerFill");
    const advText = document.getElementById("advPointTimerText");
    if (!gameStarted || !isAlive){
      advFill.style.width = "0%";
      advText.textContent = !gameStarted ? "Waiting for game startâ€¦" : "Respawn/revive to resume countdown.";
      return;
    }

    const advElapsed = (now - lastAdvPointAt) % ADV_POINT_MS;
    const advProgress = Math.max(0, Math.min(100, (advElapsed / ADV_POINT_MS) * 100));
    const advRemainingMs = Math.max(0, ADV_POINT_MS - advElapsed);
    const advRemainingMin = Math.floor(advRemainingMs / 60000);
    const advRemainingSec = Math.ceil((advRemainingMs % 60000) / 1000).toString().padStart(2, "0");

    advFill.style.width = `${advProgress}%`;
    advText.textContent = `Next point in ${advRemainingMin}:${advRemainingSec}`;
  }

  // ============================================================
  // Rendering
  // ============================================================
  function renderGrid(){
    const now = Date.now();
    combatVfx = combatVfx.filter(v => v.expiresAt > now);

    const viewSize = 20;
    const halfView = Math.floor(viewSize/2);
    const viewport = document.getElementById("grid");
    viewport.innerHTML = "";

    viewport.style.gridTemplateColumns = `repeat(${viewSize}, 20px)`;
    viewport.style.gridTemplateRows    = `repeat(${viewSize}, 20px)`;
    viewport.style.width = "400px";
    viewport.style.height = "400px";

    const centerX = playerPos.x;
    const centerY = playerPos.y;
    const startX = centerX - halfView;
    const startY = centerY - halfView;

    // generator trigger highlighting
    const generatorTriggers = new Set();
    for (let y=0; y<gridSize; y++){
      for (let x=0; x<gridSize; x++){
        if (grid[y][x] === "ğŸ­"){
          for (const p of Object.values(players)){
            if ((p.alive ?? true) === false) continue;
            const dx = Math.abs((p.x ?? 0) - x);
            const dy = Math.abs((p.y ?? 0) - y);
            if (dx + dy <= 9){ generatorTriggers.add(`${x}_${y}`); break; }
          }
        }
      }
    }

    // beacon boosted tiles
    const beaconBoosted = new Set();
    const beaconWallBoosted = new Set();
    for (let y=0; y<gridSize; y++){
      for (let x=0; x<gridSize; x++){
        if (grid[y][x] === "ğŸ—¼"){
          for (let dy=-2; dy<=2; dy++){
            for (let dx=-2; dx<=2; dx++){
              const tx = x+dx, ty = y+dy;
              if (tx>=0 && tx<gridSize && ty>=0 && ty<gridSize){
                const tSymbol = grid[ty][tx];
                if (["ğŸ”«","ğŸ­","ğŸª³","ğŸš€"].includes(tSymbol)) beaconBoosted.add(`${tx}_${ty}`);
                if (["ğŸ§±","ğŸ’"].includes(tSymbol)) beaconWallBoosted.add(`${tx}_${ty}`);
              }
            }
          }
        }
      }
    }

    // base tiles
    for (let row=0; row<viewSize; row++){
      for (let col=0; col<viewSize; col++){
        const x = startX + col;
        const y = startY + row;
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.id = `cell-${x}-${y}`;

        if (x>=0 && x<gridSize && y>=0 && y<gridSize){
          const key = `${x}_${y}`;
          const symbol = grid[y][x];

          if (beaconBoosted.has(key)) cell.style.background = "#ff8a8a";
          else if (generatorTriggers.has(key)) cell.style.background = "#fff977";
          else {
            cell.style.boxShadow = "";
            cell.style.outline = "";
            const tone = (Math.abs((x * 13) + (y * 17) + localTileSeed) % 4);
            if (tone === 0) cell.style.background = "#c8f7c5";
            else if (tone === 1) cell.style.background = "#bfeeb9";
            else if (tone === 2) cell.style.background = "#d5f9d3";
            else cell.style.background = "#b7e8b5";
          }

          cell.textContent = isCheesePickupCell(symbol) ? CHEESE_PICKUP_SYMBOL : (symbol || "");

          if (beaconWallBoosted.has(key)){
            cell.style.outline = "2px solid #22d3ee";
            cell.style.boxShadow = "inset 0 0 0 1px rgba(255,255,255,0.75), 0 0 8px rgba(34,211,238,0.8)";
          }
        } else {
          cell.style.background = "#888";
          cell.textContent = "";
        }

        viewport.appendChild(cell);
      }
    }

    // players
    for (const [pu, p] of Object.entries(players)){
      if ((p.alive ?? true) === false) continue;
      const cell = document.getElementById(`cell-${p.x}-${p.y}`);
      if (cell){
        cell.textContent = "ğŸ­";
        const nameTag = document.createElement("div");
        nameTag.className = "name";
        nameTag.textContent = (p.displayName || "mouse").toLowerCase();
        cell.appendChild(nameTag);
      }
    }

    // fleas
    for (const f of fleas){
      const cell = document.getElementById(`cell-${f.x}-${f.y}`);
      if (cell) cell.textContent = "ğŸ";
    }

    // rats
    for (const r of rats){
      if ((r.health ?? 0) <= 0) continue;
      const cell = document.getElementById(`cell-${r.x}-${r.y}`);
      if (cell){
        cell.textContent = "ğŸ€";
        const hpTag = document.createElement("div");
        hpTag.className = "name";
        hpTag.style.color = "brown";
        hpTag.textContent = `â¤ï¸${r.health}`;
        cell.appendChild(hpTag);
      }
    }

    // oxen
    for (const o of oxen){
      if ((o.health ?? 0) <= 0) continue;
      const cell = document.getElementById(`cell-${o.x}-${o.y}`);
      if (cell){
        cell.textContent = "ğŸ‚";
        const hpTag = document.createElement("div");
        hpTag.className = "name";
        hpTag.style.color = "orange";
        hpTag.textContent = `â¤ï¸${o.health}`;
        cell.appendChild(hpTag);
      }
    }

    // rat kings
    for (const k of ratKings){
      if ((k.health ?? 0) <= 0) continue;
      const cell = document.getElementById(`cell-${k.x}-${k.y}`);
      if (cell){
        cell.textContent = "ğŸ‘‘";
        const hpTag = document.createElement("div");
        hpTag.className = "name";
        hpTag.style.color = "#7c2d12";
        hpTag.textContent = `â¤ï¸${k.health}`;
        cell.appendChild(hpTag);
      }
    }

    // rabbits
    for (const r of rabbits){
      if ((r.health ?? 0) <= 0) continue;
      const cell = document.getElementById(`cell-${r.x}-${r.y}`);
      if (cell){
        cell.textContent = "ğŸ‡";
        const hpTag = document.createElement("div");
        hpTag.className = "name";
        hpTag.style.color = "#7c3aed";
        hpTag.textContent = `â¤ï¸${r.health}`;
        cell.appendChild(hpTag);
      }
    }

    // termites
    for (const t of termites){
      const cell = document.getElementById(`cell-${t.x}-${t.y}`);
      if (cell) cell.textContent = "ğŸ›";
    }

    // structure health bars
    for (const key in structureHealth){
      const [xs, ys] = key.split("_");
      const x = parseInt(xs,10), y = parseInt(ys,10);
      if (!(x>=0 && x<gridSize && y>=0 && y<gridSize)) continue;

      const symbol = grid[y][x];
      const cell = document.getElementById(`cell-${x}-${y}`);
      if (cell && ["ğŸ§±","ğŸª³","ğŸ’","ğŸš€","ğŸ­","ğŸ”«","ğŸ—¼","ğŸ¦â€ğŸ”¥","ğŸ› ï¸","ğŸ§€","ğŸ‡","âš¡","â˜„ï¸","ğŸ›¡ï¸","ğŸŸ¢","ğŸ”®","ğŸŒ°","ğŸª­"].includes(symbol)){
        const shell = document.createElement("div");
        shell.className = "structure-health-shell";

        const bar = document.createElement("div");
        bar.className = "structure-health-fill";
        const hp = structureHealth[key] ?? 0;
        const maxHp = STRUCTURE_MAX_HP[symbol] ?? Math.max(1, hp);
        const pct = Math.max(0, Math.min(100, (hp / maxHp) * 100));
        bar.style.width = `${pct}%`;
        if (pct > 66) bar.style.background = "linear-gradient(90deg,#22c55e,#16a34a)";
        else if (pct > 33) bar.style.background = "linear-gradient(90deg,#f59e0b,#f97316)";
        else bar.style.background = "linear-gradient(90deg,#ef4444,#dc2626)";
        shell.appendChild(bar);
        cell.appendChild(shell);
      }
    }

    // vultures
    for (const v of vultures){
      if ((v.health ?? 0) <= 0) continue;
      const cell = document.getElementById(`cell-${v.x}-${v.y}`);
      if (cell) cell.textContent = "ğŸ¦…";
    }

    // cat
    const catCell = document.getElementById(`cell-${catPos.x}-${catPos.y}`);
    if (catCell){
      catCell.textContent = "ğŸ±";
      const levelTag = document.createElement("div");
      levelTag.className = "name";
      levelTag.style.color = "red";
      levelTag.innerHTML = `âš¡Lv.${catPower}`;
      catCell.appendChild(levelTag);

      const bar = document.createElement("div");
      bar.className = "health-bar";
      const denom = Math.max(1, maxCatHealth);
      const barWidth = Math.max(10, Math.min(100, (catHealth/denom)*100));
      bar.style.width = `${barWidth}%`;
      bar.style.background = "red";
      bar.style.height = "3px";
      bar.style.marginTop = "-10px";
      catCell.appendChild(bar);
    }

    // rabbit laser overlays
    for (const shot of rabbitShots){
      const cell = document.getElementById(`cell-${shot.x}-${shot.y}`);
      if (!cell) continue;
      const fx = document.createElement("div");
      fx.className = "combat-vfx vfx-hit";
      fx.textContent = "ğŸ”´";
      fx.style.fontSize = "10px";
      cell.appendChild(fx);
    }

    // combat VFX overlays
    for (const v of combatVfx){
      const cell = document.getElementById(`cell-${v.x}-${v.y}`);
      if (!cell) continue;
      const fx = document.createElement("div");
      fx.className = `combat-vfx ${v.className}`;
      fx.textContent = v.icon;
      fx.style.fontSize = `${v.size}px`;
      cell.appendChild(fx);
    }

    // status list
    const statusDiv = document.getElementById("playerStatus");
    statusDiv.innerHTML = "";
    for (const p of Object.values(players)){
      const sp = document.createElement("span");
      sp.style.marginRight = "10px";
      sp.style.fontWeight = "bold";
      sp.style.color = ((p.alive ?? true) ? "green" : "red");
      sp.textContent = `${(p.displayName||"mouse").toLowerCase()}: ${((p.alive ?? true) ? "ALIVE" : "DEAD")}`;
      statusDiv.appendChild(sp);
    }
  }

  // ============================================================
  // Movement / cooldown
  // ============================================================
  function triggerMoveCooldown(){
    canMove = false;
    setTimeout(() => canMove = true, moveCooldown);
  }

  function movePlayer(dx, dy){
    if (!gameStarted || !isAlive) return;
    const newX = Math.max(0, Math.min(gridSize-1, playerPos.x + dx));
    const newY = Math.max(0, Math.min(gridSize-1, playerPos.y + dy));
    playerPos = { x: newX, y: newY };
    savePosition();
    checkCheese();
    maybeTeleportOnCrystal().catch(()=>{});
    renderGrid();
  }

  function move(dir){
    if (!canMove || !isAlive) return;
    if (dir==="up") movePlayer(0,-1);
    else if (dir==="down") movePlayer(0,1);
    else if (dir==="left") movePlayer(-1,0);
    else if (dir==="right") movePlayer(1,0);
    triggerMoveCooldown();
  }

  function triggerBuildCooldown(){
    canBuild = false;
    setTimeout(() => canBuild = true, buildCooldown);
  }

  function place(dir){
    if (!canBuild || !isAlive || selectedBuild === null) return;
    placeStructure(dir);
    triggerBuildCooldown();
  }

  function runAnalogDirection(dir, action){
    if (action === "move"){
      move(dir);
      return;
    }

    const buildDirMap = { up:"w", down:"s", left:"a", right:"d" };
    place(buildDirMap[dir]);
  }

  // ============================================================
  // Cheese
  // ============================================================
  function spawnCheese(){
    let existingPickups = 0;
    for (let y=0; y<gridSize; y++){
      for (let x=0; x<gridSize; x++){
        if (isCheesePickupCell(grid[y][x])) existingPickups++;
      }
    }

    const maxPickups = 14;
    if (existingPickups >= maxPickups) return;

    const spawnTarget = Math.min(maxPickups - existingPickups, 1 + Math.floor(Math.random() * 2));
    let spawned = 0;
    let attempts = 0;
    const maxAttempts = 120;

    while (spawned < spawnTarget && attempts < maxAttempts){
      const x = Math.floor(Math.random()*gridSize);
      const y = Math.floor(Math.random()*gridSize);
      if (tryPlaceCheesePickupAt(x, y)) spawned++;
      attempts++;
    }

    if (spawned > 0) renderGrid();
  }

  function checkCheese(){
    if (isCheesePickupCell(grid[playerPos.y][playerPos.x])){
      grid[playerPos.y][playerPos.x] = "";
      cheeseCount += 3 + cheesePickupBonus;
      document.getElementById("cheeseCount").textContent = cheeseCount;
      savePosition();
      renderGrid();
    }
  }

  // ============================================================
  // Firestore writes (UPDATED paths)
  // ============================================================
  async function savePosition(){
    const now = Date.now();
    const pRef = ccRef(ID.player(uid));
    const payload = {
      kind: "player",
      uid,
      displayName: username,
      nameKey: usernameNorm,
      x: playerPos.x,
      y: playerPos.y,
      cheese: cheeseCount,
      alive: isAlive,
      updatedAt: now
    };

    const unchanged = lastPlayerPayload &&
      lastPlayerPayload.x === payload.x &&
      lastPlayerPayload.y === payload.y &&
      lastPlayerPayload.cheese === payload.cheese &&
      lastPlayerPayload.alive === payload.alive;
    if (unchanged && (now - lastPlayerWriteAt) < 200) return;

    lastPlayerWriteAt = now;
    lastPlayerPayload = { x: payload.x, y: payload.y, cheese: payload.cheese, alive: payload.alive };
    await setDoc(pRef, payload, { merge:true });
  }

  async function upsertMyPlayerDoc(){
    const pRef = ccRef(ID.player(uid));
    await setDoc(pRef, {
      kind: "player",
      uid,
      displayName: username,
      nameKey: usernameNorm,
      x: playerPos.x,
      y: playerPos.y,
      cheese: 0,
      alive: true,
      updatedAt: Date.now()
    }, { merge:true });
  }

  // ============================================================
  // Structures
  // ============================================================
  async function placeStructure(dir){
    if (!gameStarted || !isAlive || !selectedBuild) return;

        const def = BUILD_DEFS[selectedBuild];
    if (!def) return;
    const cost = def.cost;
    if (!mobileBuildOrder.includes(selectedBuild)) return;
    if (cheeseCount < cost) return;

    let tx = playerPos.x, ty = playerPos.y;
    if (dir==="w") ty--;
    if (dir==="a") tx--;
    if (dir==="s") ty++;
    if (dir==="d") tx++;
    if (tx<0 || ty<0 || tx>=gridSize || ty>=gridSize) return;

    if (grid[ty][tx] !== "") return;

        let symbol = def.symbol;
    let health = def.hp;

    const key = `${tx}_${ty}`;
    grid[ty][tx] = symbol;
    structureHealth[key] = health;

    cheeseCount -= cost;
    document.getElementById("cheeseCount").textContent = cheeseCount;
    savePosition();

    // âœ… store under crowncouncil
    await setDoc(ccRef(ID.structure(tx,ty)), {
      kind: "structure",
      x: tx,
      y: ty,
      type: symbol,
      health,
      placedBy: uid,
      placedAt: Date.now()
    }, { merge:true });

    renderGrid();
  }


  function isWithinBeaconAura(x, y, range = 2){
    for (let by=0; by<gridSize; by++){
      for (let bx=0; bx<gridSize; bx++){
        if (grid[by][bx] !== "ğŸ—¼") continue;
        if (Math.abs(bx - x) <= range && Math.abs(by - y) <= range) return true;
      }
    }
    return false;
  }

  async function damageStructure(x, y, damageAmount = (1 + Math.floor(catPower/3))){
    const key = `${x}_${y}`;
    if (structureHealth[key] === undefined) return;

    showClawHit(x, y);

    const symbol = grid[y]?.[x] || "";
    const wallNearBeacon = ["ğŸ§±","ğŸ’"].includes(symbol) && isWithinBeaconAura(x, y, 2);
    let finalDamage = wallNearBeacon ? (damageAmount * 0.5) : damageAmount;

    const shield = structureShields[key] ?? 0;
    if (shield > 0){
      const used = Math.min(shield, finalDamage);
      structureShields[key] = shield - used;
      finalDamage -= used;
      if (structureShields[key] <= 0) delete structureShields[key];
    }

    if (finalDamage > 0) structureHealth[key] -= finalDamage;
    if (structureHealth[key] <= 0){
      grid[y][x] = "";
      delete structureHealth[key];
      delete structureShields[key];
      await deleteDoc(ccRef(ID.structure(x,y)));
    } else {
      await updateDoc(ccRef(ID.structure(x,y)), { health: structureHealth[key], shield: structureShields[key] ?? 0 });
    }
    renderGrid();
  }

  // ============================================================
  // Traps (stored under crowncouncil)
  // ============================================================
  async function placeTrap(){
    const now = Date.now();
    if (now - lastTrapTime < 20000) return;

    const {x,y} = playerPos;
    if (grid[y][x] !== "") return;

    grid[y][x] = "ğŸª¤";
    lastTrapTime = now;

    await setDoc(ccRef(ID.trap(x,y)), {
      kind: "trap",
      x, y,
      placedAt: now,
      placedBy: uid
    }, { merge:true });

    renderGrid();
  }

  // ============================================================
  // Player flea syncing (player-owned flea docs)
  // ============================================================
  async function syncMyFleas(){
    // delete old player flea docs
    const snap = await getDocs(ccCol);
    const deletions = [];
    snap.forEach(d => {
      if (d.id.startsWith(`pflea_${uid}_`)){
        deletions.push(deleteDoc(d.ref));
      }
    });
    await Promise.all(deletions);

    // write current player fleas (the â€œnear meâ€ fleas)
    // we store minimal; host moves/attacks them too
    const now = Date.now();
    let i=0;
    for (const f of fleas.filter(ff => ff.ownerUid === uid && ff.origin === "player")){
      const docId = ID.pflea(uid, i++);
      await setDoc(ccRef(docId), {
        kind: "flea",
        id: docId,
        x: f.x, y: f.y,
        lifetime: f.lifetime ?? 15,
        ownerUid: uid,
        origin: "player",
        updatedAt: now
      }, { merge:true });
    }
  }

  // ============================================================
  // Turrets / Rocket tower (host writes cat state to state doc)
  // ============================================================
  async function turretAttack(){
    for (let y=0; y<gridSize; y++){
      for (let x=0; x<gridSize; x++){
        if (grid[y][x] !== "ğŸ”«") continue;

        let attacked = false;

        // beacon bonus within 2 tiles
        let bonusDamage = 0;
        for (let dy=-2; dy<=2; dy++){
          for (let dx=-2; dx<=2; dx++){
            const nx = x+dx, ny=y+dy;
            if (nx>=0 && nx<gridSize && ny>=0 && ny<gridSize && grid[ny][nx]==="ğŸ—¼") bonusDamage++;
          }
        }
        const damage = 2 + bonusDamage;

        // cat within 5
        const dxCat = Math.abs(catPos.x - x);
        const dyCat = Math.abs(catPos.y - y);
        if (dxCat<=5 && dyCat<=5){
          addCombatVfx(x, y, "ğŸ”¥", "vfx-flame", 460, 14);
          addCombatVfx(catPos.x, catPos.y, "ğŸ’¥", "vfx-hit", 420, 15);
          catHealth -= damage;
          await updateDoc(ccRef(ID.STATE), { cat: {x:catPos.x,y:catPos.y,health:catHealth}, updatedAt: Date.now() });
          if (catHealth <= 0){
            document.getElementById("status").textContent = "ğŸ‰ Mice win!";
            document.getElementById("returnButton").style.display = "block";
          }
          attacked = true;
        }

        // else rat
        if (!attacked){
          for (const r of rats){
            if ((r.health ?? 0) <= 0) continue;
            const dxRat = Math.abs(r.x - x);
            const dyRat = Math.abs(r.y - y);
            if (dxRat<=5 && dyRat<=5){
              addCombatVfx(x, y, "ğŸ”¥", "vfx-flame", 460, 14);
              addCombatVfx(r.x, r.y, "ğŸ’¥", "vfx-hit", 420, 15);
              r.health -= damage;
              attacked = true;
              if (r.health <= 0){
                await deleteDoc(ccRef(ID.rat(r.id)));
              } else {
                await updateDoc(ccRef(ID.rat(r.id)), { health: r.health });
              }
              break;
            }
          }
        }

        // else ox
        if (!attacked){
          for (const o of oxen){
            if ((o.health ?? 0) <= 0) continue;
            const dxOx = Math.abs(o.x - x);
            const dyOx = Math.abs(o.y - y);
            if (dxOx<=5 && dyOx<=5){
              addCombatVfx(x, y, "ğŸ”¥", "vfx-flame", 460, 14);
              addCombatVfx(o.x, o.y, "ğŸ’¥", "vfx-hit", 420, 15);
              o.health -= damage;
              attacked = true;
              if (o.health <= 0){
                await deleteDoc(ccRef(ID.ox(o.id)));
              } else {
                await updateDoc(ccRef(ID.ox(o.id)), { health: o.health });
              }
              break;
            }
          }
        }
      }
    }
    renderGrid();
  }

  async function rocketTowerAttack(){
    for (let y=0; y<gridSize; y++){
      for (let x=0; x<gridSize; x++){
        if (grid[y][x] !== "ğŸš€") continue;

        // beacon boost?
        let boosted = false;
        for (let dy=-2; dy<=2; dy++){
          for (let dx=-2; dx<=2; dx++){
            const bx = x+dx, by=y+dy;
            if (bx>=0 && bx<gridSize && by>=0 && by<gridSize && grid[by][bx]==="ğŸ—¼"){
              boosted = true; break;
            }
          }
          if (boosted) break;
        }

        // farthest rat within 8
        let target = null;
        let maxDist = -1;
        for (const r of rats){
          if ((r.health ?? 0) <= 0) continue;
          const dist = Math.abs(r.x - x) + Math.abs(r.y - y);
          if (dist <= 8 && dist > maxDist){
            maxDist = dist;
            target = r;
          }
        }
        if (!target) continue;

        const mainDamage   = boosted ? 20 : 15;
        const splashDamage = boosted ? 15 : 10;

        addCombatVfx(x, y, "ğŸ”¥", "vfx-flame", 500, 14);
        addCombatVfx(target.x, target.y, "ğŸ’£", "vfx-explosion", 700, boosted ? 24 : 21);

        target.health -= mainDamage;
        if (target.health <= 0){
          await deleteDoc(ccRef(ID.rat(target.id)));
        } else {
          await updateDoc(ccRef(ID.rat(target.id)), { health: target.health });
        }

        for (let dy=-1; dy<=1; dy++){
          for (let dx=-1; dx<=1; dx++){
            const sx = target.x + dx;
            const sy = target.y + dy;
            if (sx<0 || sy<0 || sx>=gridSize || sy>=gridSize) continue;
            if (dx===0 && dy===0) continue;

            for (const r of rats){
              if (r.id !== target.id && r.x===sx && r.y===sy && (r.health ?? 0) > 0){
                r.health -= splashDamage;
                if (r.health <= 0) await deleteDoc(ccRef(ID.rat(r.id)));
                else await updateDoc(ccRef(ID.rat(r.id)), { health: r.health });
              }
            }
            for (const o of oxen){
              if (o.x===sx && o.y===sy && (o.health ?? 0) > 0){
                o.health -= splashDamage;
                if (o.health <= 0) await deleteDoc(ccRef(ID.ox(o.id)));
                else await updateDoc(ccRef(ID.ox(o.id)), { health: o.health });
              }
            }
            if (catPos.x===sx && catPos.y===sy && catHealth>0){
              addCombatVfx(catPos.x, catPos.y, "ğŸ’¥", "vfx-hit", 450, 15);
              catHealth -= splashDamage;
              await updateDoc(ccRef(ID.STATE), { cat: {x:catPos.x,y:catPos.y,health:catHealth}, updatedAt: Date.now() });
            }
          }
        }
      }
    }
    renderGrid();
  }

  // ============================================================
  // Pathfinding (kept compatible with your calls)
  // ============================================================
  function findPath(startX, startY, targetX, targetY, allowTargetWallOrPassable = false){
    const queue = [[startX, startY, []]];
    const visited = new Set([`${startX},${startY}`]);

    const directions = [[1,0],[-1,0],[0,1],[0,-1]];

    const passableFn = (typeof allowTargetWallOrPassable === "function") ? allowTargetWallOrPassable : null;
    const allowTargetWall = (typeof allowTargetWallOrPassable === "boolean") ? allowTargetWallOrPassable : false;

    while (queue.length){
      const [x,y,path] = queue.shift();
      if (x===targetX && y===targetY) return path;

      for (const [dx,dy] of directions){
        const nx = x+dx, ny=y+dy;
        const k = `${nx},${ny}`;
        if (nx<0 || nx>=gridSize || ny<0 || ny>=gridSize) continue;
        if (visited.has(k)) continue;

        const isTarget = (nx===targetX && ny===targetY);
        const cell = grid[ny][nx];
        const isWall = (cell==="ğŸ§±" || cell==="ğŸ’");

        let ok;
        if (passableFn){
          ok = !!passableFn(nx, ny);
        } else {
          ok = !isWall || (allowTargetWall && isTarget);
        }

        if (!ok) continue;
        visited.add(k);
        queue.push([nx, ny, [...path, {x:nx,y:ny}]]);
      }
    }
    return null;
  }

  function getNearestReachableStructureTarget(startX, startY, passableFn = null){
    let best = null;
    for (let y=0; y<gridSize; y++){
      for (let x=0; x<gridSize; x++){
        const symbol = grid[y][x];
        if (!["ğŸ§±","ğŸ”«","ğŸª³","ğŸ­","ğŸ’","ğŸ—¼","ğŸš€","ğŸ¦â€ğŸ”¥","ğŸ› ï¸","ğŸ§€","ğŸ‡","âš¡","â˜„ï¸","ğŸ›¡ï¸","ğŸŸ¢","ğŸ”®","ğŸŒ°","ğŸª­"].includes(symbol)) continue;

        const targetIsWall = (symbol === "ğŸ§±" || symbol === "ğŸ’");
        const passable = passableFn
          ? ((nx, ny) => (nx===x && ny===y) ? true : passableFn(nx, ny))
          : targetIsWall;

        const path = findPath(startX, startY, x, y, passable);
        if (path && (!best || path.length < best.path.length)){
          best = { x, y, path };
        }
      }
    }
    return best;
  }



  function structureTargetCells(x, y){
    const cells = [];
    for (const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
      const nx = x + dx;
      const ny = y + dy;
      if (nx<0 || ny<0 || nx>=gridSize || ny>=gridSize) continue;
      cells.push({ x:nx, y:ny });
    }
    return cells;
  }

  function getNearestStructureContactTarget(startX, startY, passableFn){
    let best = null;
    for (let y=0; y<gridSize; y++){
      for (let x=0; x<gridSize; x++){
        const symbol = grid[y][x];
        if (!["ğŸ§±","ğŸ”«","ğŸª³","ğŸ­","ğŸ’","ğŸ—¼","ğŸš€","ğŸ¦â€ğŸ”¥","ğŸ› ï¸","ğŸ§€","ğŸ‡","âš¡","â˜„ï¸","ğŸ›¡ï¸","ğŸŸ¢","ğŸ”®","ğŸŒ°","ğŸª­"].includes(symbol)) continue;

        for (const cell of structureTargetCells(x,y)){
          if (grid[cell.y][cell.x] !== "") continue;
          const path = findPath(startX, startY, cell.x, cell.y, passableFn);
          if (path && (!best || path.length < best.path.length)){
            best = { structureX:x, structureY:y, moveX:cell.x, moveY:cell.y, path };
          }
        }
      }
    }
    return best;
  }

  function getNearestMouseTarget(startX, startY, passableFn){
    let best = null;
    for (const [pu, p] of Object.entries(players)){
      if ((p.alive ?? true) === false) continue;
      const pPath = findPath(startX, startY, p.x, p.y, passableFn);
      if (pPath && (!best || pPath.length < best.path.length)){
        best = { x:p.x, y:p.y, uid:pu, path:pPath };
      }
    }
    return best;
  }
  function getNearestRabbitTarget(startX, startY, passableFn){
    let best = null;
    for (const r of rabbits){
      if ((r.health ?? 0) <= 0) continue;
      const pPath = findPath(startX, startY, r.x, r.y, passableFn);
      if (pPath && (!best || pPath.length < best.path.length)){
        best = { x:r.x, y:r.y, rabbit:r, path:pPath };
      }
    }
    return best;
  }
  // ============================================================
  // Cat AI
  // ============================================================
  function startCatBehaviorLoop(){
    if (catMoveInterval) clearInterval(catMoveInterval);
    const speed = Math.max(200, 1300 - catPower * 40);
    catMoveInterval = setInterval(() => {
      if (gameStarted) catBehavior();
    }, speed);
  }

  async function catBehavior(){
    // traps check
    for (const t of traps){
      if (t.x===catPos.x && t.y===catPos.y){
        clearInterval(catMoveInterval);
        setTimeout(() => startCatBehaviorLoop(), 5000);

        await deleteDoc(ccRef(ID.trap(catPos.x, catPos.y)));
        const cell = document.getElementById(`cell-${catPos.x}-${catPos.y}`);
        if (cell){
          cell.style.backgroundColor = "#ffaaaa";
          setTimeout(()=>cell.style.backgroundColor="#c8f7c5", 300);
        }
        renderGrid();
        return;
      }
    }

    const aliveMice = Object.values(players).filter(p => (p.alive ?? true) !== false);
    let target = null;
    let path = null;
    let mouseBlocked = true;

    // closest reachable mouse
    for (const p of aliveMice){
      const pPath = findPath(catPos.x, catPos.y, p.x, p.y, false);
      if (pPath){
        mouseBlocked = false;
        if (!path || pPath.length < path.length){
          target = {x:p.x,y:p.y,type:"mouse"};
          path = pPath;
        }
      }
    }

    // if mice are blocked/unreachable, attack nearest rabbit then structure
    if (!target && mouseBlocked){
      const rabbitTarget = getNearestRabbitTarget(catPos.x, catPos.y, false);
      if (rabbitTarget){
        target = { x: rabbitTarget.x, y: rabbitTarget.y, type: "rabbit", rabbit:rabbitTarget.rabbit };
        path = rabbitTarget.path;
      }
    }

    if (!target && mouseBlocked){
      const structureTarget = getNearestReachableStructureTarget(catPos.x, catPos.y, false);
      if (structureTarget){
        target = { x: structureTarget.x, y: structureTarget.y, type: "structure" };
        path = structureTarget.path;
      }
    }

    // move
    if (target && path && path.length > 0){
      const next = path[0];
      const symbol = grid[next.y][next.x];
      const isBlocked = (symbol==="ğŸ§±" || symbol==="ğŸ’");
      if (!isBlocked){
        catPos.x = next.x;
        catPos.y = next.y;
      }
    }

    // attack nearby
    let attacked = false;
    for (let dy=-1; dy<=1 && !attacked; dy++){
      for (let dx=-1; dx<=1 && !attacked; dx++){
        const tx = catPos.x+dx, ty=catPos.y+dy;
        if (tx<0||ty<0||tx>=gridSize||ty>=gridSize) continue;
        if (["ğŸ§±","ğŸ”«","ğŸª³","ğŸ­","ğŸ’","ğŸ—¼","ğŸš€","ğŸ¦â€ğŸ”¥","ğŸ› ï¸","ğŸ§€","ğŸ‡","âš¡","â˜„ï¸","ğŸ›¡ï¸","ğŸŸ¢","ğŸ”®","ğŸŒ°","ğŸª­"].includes(grid[ty][tx])){
          await damageStructure(tx,ty);
          attacked = true;
        }
      }
    }

    for (const rb of rabbits){
      const d = Math.abs(rb.x-catPos.x)+Math.abs(rb.y-catPos.y);
      if (d===0){
        rb.health -= ratPower * 10;
        if (rb.health <= 0) await deleteDoc(ccRef(ID.rabbit(rb.id)));
        else await updateDoc(ccRef(ID.rabbit(rb.id)), { health: rb.health, updatedAt: Date.now() });
      }
    }

    // kill players on cat tile
    for (const [pu, p] of Object.entries(players)){
      if ((p.alive ?? true) && catPos.x===p.x && catPos.y===p.y){
        await updateDoc(ccRef(ID.player(pu)), { alive:false, updatedAt: Date.now() });
        if (pu === uid){
          isAlive = false;
          document.getElementById("status").textContent = "ğŸ’€ You are dead!";
        }
      }
    }

    // write cat state
    await updateDoc(ccRef(ID.STATE), {
      cat: { x: catPos.x, y: catPos.y, health: catHealth },
      updatedAt: Date.now()
    });

    updateCatHealthBar();
    renderGrid();
  }

  // ============================================================
  // Host spawning
  // ============================================================
  async function spawnRatWave(){
    if (!isHost || catPower <= 0) return;

    const waveTag = Date.now();
    const allOffsets = [
      { x: 0, y: 0 },  { x: 1, y: 0 },  { x: -1, y: 0 },
      { x: 0, y: 1 },  { x: 0, y: -1 }, { x: 1, y: 1 },
      { x: -1, y: -1 },{ x: 1, y: -1 }, { x: -1, y: 1 },
      { x: 2, y: 0 },  { x: 0, y: 2 },  { x: -2, y: 0 }, { x: 0, y: -2 },
      { x: 2, y: 1 },  { x: 1, y: 2 },  { x: -1, y: 2 }, { x: -2, y: 1 },
      { x: -2, y: -1 },{ x: -1, y: -2 },{ x: 1, y: -2 }, { x: 2, y: -1 }
    ];

    const availableSpots = allOffsets
      .map(o => ({x:catPos.x+o.x,y:catPos.y+o.y}))
      .filter(p =>
        p.x>=0 && p.x<gridSize && p.y>=0 && p.y<gridSize &&
        grid[p.y][p.x] === "" &&
        !rats.some(r => r.x===p.x && r.y===p.y) &&
        !oxen.some(o => o.x===p.x && o.y===p.y)
      );

    const usedKeys = new Set();

    // oxen
    const oxCount = (catPower>=15) ? (Math.floor((catPower-15)/10)+1) : 0;
    let oxSpawned = 0;
    for (let i=0; i<availableSpots.length && oxSpawned<oxCount; i++){
      const spot = availableSpots[i];
      const key = `${spot.x}_${spot.y}`;
      if (usedKeys.has(key)) continue;
      usedKeys.add(key);

      const id = `ox_${crypto.randomUUID()}`;
      await setDoc(ccRef(ID.ox(id)), {
        kind: "ox",
        id,
        x: spot.x,
        y: spot.y,
        health: getOxHealthForDifficulty(),
        wave: waveTag,
        createdAt: Date.now()
      }, { merge:true });
      oxSpawned++;
    }


    // rat king: late rounds random spawn
    if (catPower >= 22 && Math.random() < 0.35){
      const livingKings = ratKings.filter(k => (k.health ?? 0) > 0).length;
      if (livingKings < 2){
        const openSpot = availableSpots.find(s => !usedKeys.has(`${s.x}_${s.y}`));
        if (openSpot){
          usedKeys.add(`${openSpot.x}_${openSpot.y}`);
          const id = `ratking_${crypto.randomUUID()}`;
          await setDoc(ccRef(ID.ratKing(id)), {
            kind: "ratking",
            id,
            x: openSpot.x,
            y: openSpot.y,
            health: Math.max(120, getRatHealthForDifficulty() * 10),
            wave: waveTag,
            createdAt: Date.now()
          }, { merge:true });
        }
      }
    }

    // rats
    const maxRats = catPower;
    let ratsSpawned = 0;
    for (let i=0; i<availableSpots.length && ratsSpawned<maxRats; i++){
      const spot = availableSpots[i];
      const key = `${spot.x}_${spot.y}`;
      if (usedKeys.has(key)) continue;
      usedKeys.add(key);

      const id = `rat_${crypto.randomUUID()}`;
      await setDoc(ccRef(ID.rat(id)), {
        kind: "rat",
        id,
        x: spot.x,
        y: spot.y,
        health: getRatHealthForDifficulty(),
        wave: waveTag,
        createdAt: Date.now()
      }, { merge:true });
      ratsSpawned++;
    }
  }

  // ============================================================
  // Host enemies movement / logic (kept from your gameplay)
  // ============================================================
  async function hostMoveRats(){
    for (const rat of rats){
      if ((rat.health ?? 0) <= 0) continue;

      if (rat.trappedUntil && Date.now() < rat.trappedUntil) continue;
      const kingNearby = ratKings.some(k => (k.health ?? 0) > 0 && (Math.abs(k.x-rat.x)+Math.abs(k.y-rat.y) <= 4));
      if (rat.slowedUntil && Date.now() < rat.slowedUntil && Math.random() < (kingNearby ? 0.35 : 0.6)) continue;

      // trap check
      for (const t of traps){
        if (t.x===rat.x && t.y===rat.y){
          rat.trappedUntil = Date.now() + 3000;
          await deleteDoc(ccRef(ID.trap(rat.x, rat.y)));
          const cell = document.getElementById(`cell-${rat.x}-${rat.y}`);
          if (cell){
            cell.style.backgroundColor = "#ffcccc";
            setTimeout(()=>cell.style.backgroundColor="#c8f7c5", 300);
          }
          renderGrid();
          continue;
        }
      }

      let closestTarget = null;
      let bestPath = null;

      const rabbitTarget = getNearestRabbitTarget(rat.x, rat.y, (x, y) => {
        const isBlocked = ["ğŸ§±","ğŸ­","ğŸ’","ğŸ—¼"].includes(grid[y][x]);
        const ratOccupied = rats.some(r => r.id !== rat.id && r.x===x && r.y===y);
        return !isBlocked && !ratOccupied;
      });

      if (rabbitTarget){
        closestTarget = { x:rabbitTarget.x, y:rabbitTarget.y, type:"rabbit", rabbit:rabbitTarget.rabbit };
        bestPath = rabbitTarget.path;
      }

      const mouseTarget = !closestTarget ? getNearestMouseTarget(rat.x, rat.y, (x, y) => {
        const isBlocked = ["ğŸ§±","ğŸ­","ğŸ’","ğŸ—¼"].includes(grid[y][x]);
        const ratOccupied = rats.some(r => r.id !== rat.id && r.x===x && r.y===y);
        return !isBlocked && !ratOccupied;
      }) : null;

      if (mouseTarget){
        closestTarget = { x:mouseTarget.x, y:mouseTarget.y, type:"mouse", uid:mouseTarget.uid };
        bestPath = mouseTarget.path;
      }

      if (!closestTarget){
        const structureTarget = getNearestStructureContactTarget(
          rat.x,
          rat.y,
          (x, y) => {
            const symbol = grid[y][x];
            const isBlocked = ["ğŸ§±","ğŸ­","ğŸ’","ğŸ—¼"].includes(symbol);
            const ratOccupied = rats.some(r => r.id !== rat.id && r.x===x && r.y===y);
            return !isBlocked && !ratOccupied;
          }
        );

        if (structureTarget){
          bestPath = structureTarget.path;
          closestTarget = { x: structureTarget.structureX, y: structureTarget.structureY, type:"structure" };
        }
      }

      if (closestTarget){
        const centerX = Math.floor(gridSize/2);
        const centerY = Math.floor(gridSize/2);

        if (!bestPath){
          bestPath = findPath(rat.x, rat.y, closestTarget.x, closestTarget.y, (x, y) => {
            const isBlocked = ["ğŸ§±","ğŸ­","ğŸ’","ğŸ—¼"].includes(grid[y][x]);
            const isReviveCenter = (x===centerX && y===centerY);
            const ratOccupied = rats.some(r => r.id !== rat.id && r.x===x && r.y===y);
            return !isBlocked && !isReviveCenter && !ratOccupied;
          });
        }

        if (bestPath && bestPath.length > 0){
          const next = bestPath[0];
          const ratInWay = rats.some(r => r.id !== rat.id && r.x===next.x && r.y===next.y);
          if (!ratInWay){
            rat.x = next.x; rat.y = next.y;
            await updateDoc(ccRef(ID.rat(rat.id)), { x: rat.x, y: rat.y });
          }
        }

        const distance = Math.abs(rat.x-closestTarget.x) + Math.abs(rat.y-closestTarget.y);
        if (closestTarget.type==="structure" && distance===1){
          await damageStructure(closestTarget.x, closestTarget.y, kingNearby ? Math.ceil(ratPower * 1.8) : ratPower);
        } else if (closestTarget.type==="rabbit" && distance===0){
          closestTarget.rabbit.health -= (kingNearby ? Math.ceil(ratPower*5) : ratPower * 3);
          if (closestTarget.rabbit.health <= 0) await deleteDoc(ccRef(ID.rabbit(closestTarget.rabbit.id)));
          else await updateDoc(ccRef(ID.rabbit(closestTarget.rabbit.id)), { health: closestTarget.rabbit.health, updatedAt: Date.now() });
        } else if (closestTarget.type==="mouse" && distance===0){
          showClawHit(closestTarget.x, closestTarget.y);
          await updateDoc(ccRef(ID.player(closestTarget.uid)), { alive:false, updatedAt: Date.now() });
          if (closestTarget.uid === uid){
            isAlive = false;
            document.getElementById("status").textContent = "ğŸ’€ You are dead!";
          }
        }
      }
    }

    // cleanup dead rats
    for (let i=rats.length-1; i>=0; i--){
      if ((rats[i].health ?? 0) <= 0){
        await deleteDoc(ccRef(ID.rat(rats[i].id)));
        rats.splice(i,1);
      }
    }
  }

  async function hostMoveOxen(){
    for (let i=oxen.length-1; i>=0; i--){
      const ox = oxen[i];
      if ((ox.health ?? 0) <= 0){
        await deleteDoc(ccRef(ID.ox(ox.id)));
        oxen.splice(i,1);
        continue;
      }

      let bestTarget = null;
      let bestPath = null;

      const rabbitTarget = getNearestRabbitTarget(ox.x, ox.y, false);
      if (rabbitTarget){
        bestTarget = { x:rabbitTarget.x, y:rabbitTarget.y, type:"rabbit", rabbit:rabbitTarget.rabbit };
        bestPath = rabbitTarget.path;
      }

      const mouseTarget = !bestTarget ? getNearestMouseTarget(ox.x, ox.y, false) : null;
      if (mouseTarget){
        bestTarget = { x:mouseTarget.x, y:mouseTarget.y, type:"mouse", uid: mouseTarget.uid };
        bestPath = mouseTarget.path;
      }

      if (!bestTarget){
        const structureTarget = getNearestStructureContactTarget(ox.x, ox.y, false);
        if (structureTarget){
          bestTarget = { x: structureTarget.structureX, y: structureTarget.structureY, type:"structure" };
          bestPath = structureTarget.path;
        }
      }

      if (bestTarget){
        if (bestPath && bestPath.length>0){
          const next = bestPath[0];
          ox.x = next.x; ox.y = next.y;
          await updateDoc(ccRef(ID.ox(ox.id)), { x: ox.x, y: ox.y });
        }

        const distance = Math.abs(ox.x - bestTarget.x) + Math.abs(ox.y - bestTarget.y);
        if (distance===1 && bestTarget.type === "structure"){
          await damageStructure(bestTarget.x, bestTarget.y, ratPower * 10);
          ox.health -= 1;
          await updateDoc(ccRef(ID.ox(ox.id)), { health: ox.health });
        } else if (distance===0 && bestTarget.type === "rabbit"){
          bestTarget.rabbit.health -= ratPower * 10;
          if (bestTarget.rabbit.health <= 0) await deleteDoc(ccRef(ID.rabbit(bestTarget.rabbit.id)));
          else await updateDoc(ccRef(ID.rabbit(bestTarget.rabbit.id)), { health: bestTarget.rabbit.health, updatedAt: Date.now() });
        } else if (distance===0 && bestTarget.type === "mouse"){
          showClawHit(bestTarget.x, bestTarget.y);
          await updateDoc(ccRef(ID.player(bestTarget.uid)), { alive:false, updatedAt: Date.now() });
        }
      }
    }
  }

  async function hostMoveRatKings(){
    for (let i=ratKings.length-1; i>=0; i--){
      const king = ratKings[i];
      if ((king.health ?? 0) <= 0){
        await deleteDoc(ccRef(ID.ratKing(king.id)));
        ratKings.splice(i,1);
        continue;
      }

      const mouseTarget = getNearestMouseTarget(king.x, king.y, false);
      const target = mouseTarget ? {x:mouseTarget.x,y:mouseTarget.y,type:"mouse",uid:mouseTarget.uid,path:mouseTarget.path} : null;
      const structureTarget = !target ? getNearestStructureContactTarget(king.x, king.y, false) : null;
      const bestPath = target?.path || structureTarget?.path || null;
      const finalTarget = target || (structureTarget ? {x:structureTarget.structureX,y:structureTarget.structureY,type:"structure"} : null);
      if (!finalTarget) continue;

      if (bestPath && bestPath.length>0){
        king.x = bestPath[0].x;
        king.y = bestPath[0].y;
        await updateDoc(ccRef(ID.ratKing(king.id)), { x: king.x, y: king.y, updatedAt: Date.now() });
      }

      const d = Math.abs(king.x-finalTarget.x)+Math.abs(king.y-finalTarget.y);
      if (finalTarget.type === "structure" && d===1){
        await damageStructure(finalTarget.x, finalTarget.y, Math.max(10, ratPower * 2));
      } else if (finalTarget.type === "mouse" && d===0){
        await updateDoc(ccRef(ID.player(finalTarget.uid)), { alive:false, updatedAt: Date.now() });
      }
    }
  }

  async function hostMoveVultures(){
    for (let i=vultures.length-1; i>=0; i--){
      const v = vultures[i];
      if ((v.health ?? 0) <= 0){
        await deleteDoc(ccRef(ID.vulture(v.id)));
        vultures.splice(i,1);
        continue;
      }

      let bestTarget = null;
      let bestPath = null;
      for (let y=0; y<gridSize; y++){
        for (let x=0; x<gridSize; x++){
          const symbol = grid[y][x];
          let priority = 99;
          if (symbol === "ğŸ­") priority = 0;
          else if (["ğŸ”«","ğŸª³","ğŸ§±","ğŸ’","ğŸ—¼","ğŸš€","ğŸ¦â€ğŸ”¥","ğŸ› ï¸"].includes(symbol)) priority = 1;
          if (priority === 99) continue;

          const contactPath = findPath(v.x, v.y, x, y, (nx, ny) => {
            if (nx===x && ny===y) return false;
            return !["ğŸ§±","ğŸ­","ğŸ’","ğŸ—¼"].includes(grid[ny][nx]);
          });
          if (!contactPath || contactPath.length===0) continue;

          const distance = Math.abs(x-v.x) + Math.abs(y-v.y);
          if (priority < (bestTarget?.priority ?? 99) || (priority === (bestTarget?.priority ?? 99) && distance < (bestTarget?.distance ?? Infinity))){
            bestTarget = { x, y, priority, distance };
            bestPath = contactPath;
          }
        }
      }
      if (!bestTarget) continue;

      if (bestPath && bestPath.length>0){
        const next = bestPath[0];
        v.x = next.x;
        v.y = next.y;
        await updateDoc(ccRef(ID.vulture(v.id)), { x: v.x, y: v.y, updatedAt: Date.now() });
      }

      const distance = Math.abs(v.x-bestTarget.x) + Math.abs(v.y-bestTarget.y);
      if (distance===1){
        await damageStructure(bestTarget.x, bestTarget.y, ratPower * 4);
      }
    }
  }

  async function hostMoveTermites(){
    for (let i=termites.length-1; i>=0; i--){
      const termite = termites[i];

      let closestWall = null;
      let minDist = Infinity;
      for (let y=0; y<gridSize; y++){
        for (let x=0; x<gridSize; x++){
          if (grid[y][x]==="ğŸ§±" || grid[y][x]==="ğŸ’"){
            const dist = Math.abs(termite.x - x) + Math.abs(termite.y - y);
            if (dist < minDist){
              minDist = dist;
              closestWall = { x, y };
            }
          }
        }
      }
      if (!closestWall) continue;

      let bestPath = null;
      for (const cell of structureTargetCells(closestWall.x, closestWall.y)){
        if (grid[cell.y][cell.x] !== "") continue;
        const path = findPath(termite.x, termite.y, cell.x, cell.y, (x,y) => {
          return !["ğŸ§±","ğŸ”«","ğŸª³","ğŸ­","ğŸ’","ğŸ—¼","ğŸš€","ğŸ¦â€ğŸ”¥","ğŸ› ï¸","ğŸ§€","ğŸ‡","âš¡","â˜„ï¸","ğŸ›¡ï¸","ğŸŸ¢","ğŸ”®","ğŸŒ°","ğŸª­"].includes(grid[y][x]);
        });
        if (path && (!bestPath || path.length < bestPath.length)){
          bestPath = path;
        }
      }

      if (bestPath && bestPath.length>0){
        const next = bestPath[0];
        termite.x = next.x; termite.y = next.y;
        await updateDoc(ccRef(ID.termite(termite.id)), { x: termite.x, y: termite.y });
      }

      const distance = Math.abs(termite.x-closestWall.x) + Math.abs(termite.y-closestWall.y);
      if (distance===1){
        await damageStructure(closestWall.x, closestWall.y, 40);
        await deleteDoc(ccRef(ID.termite(termite.id)));
        termites.splice(i,1);
      }
    }
  }

  async function hostMoveFleas(){
    // Fleas are stored as docs in crowncouncil (both nest fleas + player fleas)
    for (let i=fleas.length-1; i>=0; i--){
      const flea = fleas[i];
      let target = null;
      let minDist = Infinity;

      // target cat
      const distToCat = Math.abs(catPos.x - flea.x) + Math.abs(catPos.y - flea.y);
      if (distToCat < minDist){
        minDist = distToCat;
        target = { x: catPos.x, y: catPos.y, type:"cat" };
      }

      // target rat
      for (const r of rats){
        if ((r.health ?? 0) <= 0) continue;
        const dist = Math.abs(r.x - flea.x) + Math.abs(r.y - flea.y);
        if (dist < minDist){
          minDist = dist;
          target = { x:r.x, y:r.y, type:"rat", rat:r };
        }
      }

      // target ox
      for (const o of oxen){
        if ((o.health ?? 0) <= 0) continue;
        const dist = Math.abs(o.x - flea.x) + Math.abs(o.y - flea.y);
        if (dist < minDist){
          minDist = dist;
          target = { x:o.x, y:o.y, type:"ox", ox:o };
        }
      }

      // move flea
      if (target){
        let dx=0, dy=0;
        const xDiff = target.x - flea.x;
        const yDiff = target.y - flea.y;
        if (Math.abs(xDiff) > Math.abs(yDiff)) dx = Math.sign(xDiff);
        else dy = Math.sign(yDiff);

        const newX = flea.x + dx;
        const newY = flea.y + dy;
        if (newX>=0 && newX<gridSize && newY>=0 && newY<gridSize){
          flea.x = newX; flea.y = newY;
        }

        // attack if reached
        if (flea.x===target.x && flea.y===target.y){
          addCombatVfx(flea.x, flea.y, "ğŸ’¥", "vfx-pop", 520, 17);
          flea.lifetime = 0;

          if (target.type==="cat"){
            catHealth -= 1;
            await updateDoc(ccRef(ID.STATE), { cat: {x:catPos.x,y:catPos.y,health:catHealth}, updatedAt: Date.now() });
          } else if (target.type==="rat" && target.rat){
            target.rat.health -= 5;
            if (target.rat.health <= 0){
              await deleteDoc(ccRef(ID.rat(target.rat.id)));
            } else {
              await updateDoc(ccRef(ID.rat(target.rat.id)), { health: target.rat.health });
            }
          } else if (target.type==="ox" && target.ox){
            target.ox.health -= 5;
            if (target.ox.health <= 0){
              await deleteDoc(ccRef(ID.ox(target.ox.id)));
            } else {
              await updateDoc(ccRef(ID.ox(target.ox.id)), { health: target.ox.health });
            }
          }
        }
      }

      flea.lifetime = (flea.lifetime ?? 15) - 1;
      if (flea.lifetime <= 0){
        await deleteDoc(ccRef(flea.docId));
        fleas.splice(i,1);
      } else {
        await updateDoc(ccRef(flea.docId), { x: flea.x, y: flea.y, lifetime: flea.lifetime, updatedAt: Date.now() });
      }
    }
  }

  // ============================================================
  // Phoenix revive (host runs; removes Phoenix structure)
  // ============================================================
  async function hostPhoenixRevive(){
    // find phoenix tile in grid
    let phoenixSpot = null;
    for (let y=0; y<gridSize && !phoenixSpot; y++){
      for (let x=0; x<gridSize && !phoenixSpot; x++){
        if (grid[y][x] === "ğŸ¦â€ğŸ”¥") phoenixSpot = {x,y};
      }
    }
    if (!phoenixSpot) return;

    let revived = false;
    for (const [pu, p] of Object.entries(players)){
      if ((p.alive ?? true) === false){
        await updateDoc(ccRef(ID.player(pu)), { alive:true, x: phoenixSpot.x, y: phoenixSpot.y, updatedAt: Date.now() });
        revived = true;
        break;
      }
    }

    if (revived){
      const key = `${phoenixSpot.x}_${phoenixSpot.y}`;
      grid[phoenixSpot.y][phoenixSpot.x] = "";
      delete structureHealth[key];
      await deleteDoc(ccRef(ID.structure(phoenixSpot.x, phoenixSpot.y)));

      const cell = document.getElementById(`cell-${phoenixSpot.x}-${phoenixSpot.y}`);
      if (cell){
        cell.style.backgroundColor = "#ff4d4d";
        setTimeout(()=>cell.style.backgroundColor="#c8f7c5", 300);
      }
      renderGrid();
    }
  }

  async function repairStationTick(){
    const usedTargets = new Set();
    for (let y=0; y<gridSize; y++){
      for (let x=0; x<gridSize; x++){
        if (grid[y][x] !== "ğŸ› ï¸") continue;

        const boostedByBeacon = isWithinBeaconAura(x, y, 2);
        const repairRange = boostedByBeacon ? 8 : 6;
        const repairMultiplier = boostedByBeacon ? 0.4 : 0.25;
        const repairsPerTick = boostedByBeacon ? 2 : 1;
        const candidates = [];

        for (let ty=0; ty<gridSize; ty++){
          for (let tx=0; tx<gridSize; tx++){
            const symbol = grid[ty][tx];
            if (!["ğŸ§±","ğŸ”«","ğŸª³","ğŸ­","ğŸ’","ğŸ—¼","ğŸš€","ğŸ¦â€ğŸ”¥","ğŸ› ï¸","ğŸ§€","ğŸ‡","âš¡","â˜„ï¸","ğŸ›¡ï¸","ğŸŸ¢","ğŸ”®","ğŸŒ°","ğŸª­"].includes(symbol)) continue;
            if (tx===x && ty===y) continue;

            const key = `${tx}_${ty}`;
            const maxHp = STRUCTURE_MAX_HP[symbol] ?? 1;
            const hp = structureHealth[key] ?? maxHp;
            if (hp >= maxHp) continue;
            if (usedTargets.has(key)) continue;

            const dist = Math.abs(tx - x) + Math.abs(ty - y);
            if (dist > repairRange) continue;
            candidates.push({ tx, ty, key, symbol, hp, maxHp, dist });
          }
        }

        if (!candidates.length) continue;
        candidates.sort((a,b) => a.dist - b.dist);

        const selectedTargets = candidates.slice(0, repairsPerTick);
        const fromCell = document.getElementById(`cell-${x}-${y}`);
        if (fromCell) fromCell.style.backgroundColor = boostedByBeacon ? "#67e8f9" : "#a7f3d0";

        for (const target of selectedTargets){
          const healAmount = Math.max(1, Math.ceil(target.maxHp * repairMultiplier));
          const healedHp = Math.min(target.maxHp, target.hp + healAmount);
          structureHealth[target.key] = healedHp;
          usedTargets.add(target.key);

          const toCell = document.getElementById(`cell-${target.tx}-${target.ty}`);
          if (toCell) toCell.style.backgroundColor = boostedByBeacon ? "#22d3ee" : "#86efac";
          setTimeout(() => {
            if (toCell) toCell.style.backgroundColor = "";
          }, 220);

          await updateDoc(ccRef(ID.structure(target.tx,target.ty)), { health: healedHp, updatedAt: Date.now() });
        }

        setTimeout(() => {
          if (fromCell) fromCell.style.backgroundColor = "";
        }, 220);
      }
    }
    renderGrid();
  }

  // ============================================================
  // Generators payout (client-side for â€œmeâ€ like your original)
  // ============================================================
  async function generatorPayoutTick(){
    lastGeneratorPayoutAt = Date.now();
    for (let y=0; y<gridSize; y++){
      for (let x=0; x<gridSize; x++){
        if (grid[y][x] !== "ğŸ­") continue;

        const cell = document.getElementById(`cell-${x}-${y}`);
        if (cell){
          cell.style.backgroundColor = "#fff977";
          setTimeout(()=>cell.style.backgroundColor="#c8f7c5", 300);
        }

        let bonusCheese = 0;
        for (let dy=-2; dy<=2; dy++){
          for (let dx=-2; dx<=2; dx++){
            const nx = x+dx, ny=y+dy;
            if (nx>=0 && nx<gridSize && ny>=0 && ny<gridSize && grid[ny][nx]==="ğŸ—¼") bonusCheese++;
          }
        }

        // only pay me if I'm nearby and alive (same as your original)
        const me = players[uid];
        if (me && (me.alive ?? true) !== false){
          const dx = Math.abs(me.x - x);
          const dy = Math.abs(me.y - y);
          if (dx + dy <= 9){
            const totalCheese = 1 + bonusCheese;
            cheeseCount += totalCheese;
            document.getElementById("cheeseCount").textContent = cheeseCount;
            await updateDoc(ccRef(ID.player(uid)), { cheese: cheeseCount, updatedAt: Date.now() });
          }
        }
      }
    }
  }

  async function damageEnemyUnit(enemy, amount){
    enemy.health -= amount;
    if (enemy.health <= 0){
      if (enemy.kind === "rat") await deleteDoc(ccRef(ID.rat(enemy.id)));
      else if (enemy.kind === "ox") await deleteDoc(ccRef(ID.ox(enemy.id)));
      else if (enemy.kind === "ratking"){
        await deleteDoc(ccRef(ID.ratKing(enemy.id)));
        let dropped = 0;
        for (let dy=-2; dy<=2 && dropped<5; dy++) for (let dx=-2; dx<=2 && dropped<5; dx++){
          const nx = enemy.x + dx;
          const ny = enemy.y + dy;
          if (nx<0||ny<0||nx>=gridSize||ny>=gridSize) continue;
          if (!tryPlaceCheesePickupAt(nx, ny)) continue;
          dropped++;
        }
      }
      else if (enemy.kind === "vulture") await deleteDoc(ccRef(ID.vulture(enemy.id)));
    } else {
      if (enemy.kind === "rat") await updateDoc(ccRef(ID.rat(enemy.id)), { health: enemy.health, slowedUntil: enemy.slowedUntil || 0 });
      else if (enemy.kind === "ox") await updateDoc(ccRef(ID.ox(enemy.id)), { health: enemy.health, slowedUntil: enemy.slowedUntil || 0 });
      else if (enemy.kind === "ratking") await updateDoc(ccRef(ID.ratKing(enemy.id)), { health: enemy.health, updatedAt: Date.now() });
      else if (enemy.kind === "vulture") await updateDoc(ccRef(ID.vulture(enemy.id)), { health: enemy.health, updatedAt: Date.now() });
    }
  }

  function nearestEnemyFrom(x, y, range = 6){
    let best = null;
    for (const r of rats){
      if ((r.health ?? 0) <= 0) continue;
      const d = Math.abs(r.x - x) + Math.abs(r.y - y);
      if (d <= range && (!best || d < best.d)) best = { kind:"rat", enemy:r, d };
    }
    for (const o of oxen){
      if ((o.health ?? 0) <= 0) continue;
      const d = Math.abs(o.x - x) + Math.abs(o.y - y);
      if (d <= range && (!best || d < best.d)) best = { kind:"ox", enemy:o, d };
    }
    for (const k of ratKings){
      if ((k.health ?? 0) <= 0) continue;
      const d = Math.abs(k.x - x) + Math.abs(k.y - y);
      if (d <= range && (!best || d < best.d)) best = { kind:"ratking", enemy:k, d };
    }
    for (const v of vultures){
      if ((v.health ?? 0) <= 0) continue;
      const d = Math.abs(v.x - x) + Math.abs(v.y - y);
      if (d <= range && (!best || d < best.d)) best = { kind:"vulture", enemy:v, d };
    }
    if (catHealth > 0){
      const d = Math.abs(catPos.x - x) + Math.abs(catPos.y - y);
      if (d <= range && (!best || d < best.d)) best = { kind:"cat", d };
    }
    return best;
  }

  async function specialStructureTick(){
    rabbitShots = [];
    // cheese farm spawn: every 20s each farm can create one nearby pickup
    if (!window.__lastFarmSpawn || Date.now() - window.__lastFarmSpawn > 20000){
      window.__lastFarmSpawn = Date.now();
      const neighborOffsets = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
      for (let y=0; y<gridSize; y++) for (let x=0; x<gridSize; x++){
        if (grid[y][x] !== "ğŸ§€") continue;
        const shuffled = [...neighborOffsets].sort(() => Math.random() - 0.5);
        for (const [dx,dy] of shuffled){
          const nx = x + dx;
          const ny = y + dy;
          if (tryPlaceCheesePickupAt(nx, ny)) break;
        }
      }
    }

    for (let y=0; y<gridSize; y++){
      for (let x=0; x<gridSize; x++){
        const sym = grid[y][x];
        if (sym === "ğŸ›¡ï¸"){
          for (let ty=0; ty<gridSize; ty++) for (let tx=0; tx<gridSize; tx++){
            const k = `${tx}_${ty}`;
            if (!structureHealth[k]) continue;
            const d = Math.abs(tx-x)+Math.abs(ty-y);
            if (d<=2){
              const prev = structureShields[k]||0;
              const next = Math.min(125, prev+4);
              if (next !== prev){
                structureShields[k] = next;
                await updateDoc(ccRef(ID.structure(tx,ty)), { shield: next, updatedAt: Date.now() });
              }
            }
          }
        }
        if (sym === "â˜„ï¸"){
          const target = nearestEnemyFrom(x,y,8);
          if (target){
            let dx=0,dy=0;
            if (target.kind==="cat"){ dx=Math.sign(catPos.x-x); dy=Math.sign(catPos.y-y); }
            else { dx=Math.sign(target.enemy.x-x); dy=Math.sign(target.enemy.y-y); }
            if (dx===0&&dy===0) dx=1;
            let cx=x+dx, cy=y+dy;
            while (cx>=0&&cy>=0&&cx<gridSize&&cy<gridSize){
              rabbitShots.push({x:cx,y:cy});
              for (const r of rats){ if (r.x===cx && r.y===cy && (r.health??0)>0){ await damageEnemyUnit({...r,kind:"rat"}, 18); } }
              for (const o of oxen){ if (o.x===cx && o.y===cy && (o.health??0)>0){ await damageEnemyUnit({...o,kind:"ox"}, 18); } }
              for (const k of ratKings){ if (k.x===cx && k.y===cy && (k.health??0)>0){ await damageEnemyUnit({...k,kind:"ratking"}, 18); } }
              for (const v of vultures){ if (v.x===cx && v.y===cy && (v.health??0)>0){ await damageEnemyUnit({...v,kind:"vulture"}, 18); } }
              if (catPos.x===cx&&catPos.y===cy){ catHealth -= 18; await updateDoc(ccRef(ID.STATE), { cat:{x:catPos.x,y:catPos.y,health:catHealth}, updatedAt:Date.now() }); }
              cx += dx; cy += dy;
            }
          }
        }
        if (sym === "âš¡"){
          const first = nearestEnemyFrom(x,y,5);
          if (first){
            const hit = [];
            if (first.kind==="cat") hit.push({kind:"cat",x:catPos.x,y:catPos.y});
            else hit.push({kind:first.kind,enemy:first.enemy,x:first.enemy.x,y:first.enemy.y});
            const pool=[...rats.map(r=>({kind:"rat",enemy:r,x:r.x,y:r.y})),...oxen.map(o=>({kind:"ox",enemy:o,x:o.x,y:o.y})),...ratKings.map(k=>({kind:"ratking",enemy:k,x:k.x,y:k.y})),...vultures.map(v=>({kind:"vulture",enemy:v,x:v.x,y:v.y})),{kind:"cat",x:catPos.x,y:catPos.y}];
            for (const h of [...hit]){
              const next=pool.filter(p=>!hit.some(q=>q.x===p.x&&q.y===p.y)).sort((a,b)=>(Math.abs(a.x-h.x)+Math.abs(a.y-h.y))-(Math.abs(b.x-h.x)+Math.abs(b.y-h.y)))[0];
              if (next && (Math.abs(next.x-h.x)+Math.abs(next.y-h.y)<=3)) hit.push(next);
              if (hit.length>=4) break;
            }
            for (const h of hit){ rabbitShots.push({x:h.x,y:h.y}); if (h.kind==="cat"){ catHealth -= 4; } else { await damageEnemyUnit({...h.enemy,kind:h.kind}, 4); } }
            await updateDoc(ccRef(ID.STATE), { cat:{x:catPos.x,y:catPos.y,health:catHealth}, updatedAt:Date.now() });
          }
        }
        if (sym === "ğŸŸ¢"){
          for (const r of rats){ const d=Math.abs(r.x-x)+Math.abs(r.y-y); if (d<=6){ r.slowedUntil = Date.now()+3500; await updateDoc(ccRef(ID.rat(r.id)), { slowedUntil:r.slowedUntil, updatedAt:Date.now() }); } }
          for (const o of oxen){ const d=Math.abs(o.x-x)+Math.abs(o.y-y); if (d<=6){ o.slowedUntil = Date.now()+3500; await updateDoc(ccRef(ID.ox(o.id)), { slowedUntil:o.slowedUntil, updatedAt:Date.now() }); } }
          for (const k of ratKings){ const d=Math.abs(k.x-x)+Math.abs(k.y-y); if (d<=6){ k.slowedUntil = Date.now()+3500; await updateDoc(ccRef(ID.ratKing(k.id)), { slowedUntil:k.slowedUntil, updatedAt:Date.now() }); } }
        }
        if (sym === "ğŸŒ°" && Date.now() - lastAcornShotAt >= 10000){
          const enemies = listCombatEnemies();
          const target = enemies.sort((a,b)=>(b.enemy.health||0)-(a.enemy.health||0))[0];
          if (target){
            rabbitShots.push({x:target.enemy.x,y:target.enemy.y});
            await damageEnemyUnit({ ...target.enemy, kind: target.kind }, 55);
            lastAcornShotAt = Date.now();
          } else if (catHealth > 0){
            catHealth -= 45;
            lastAcornShotAt = Date.now();
            await updateDoc(ccRef(ID.STATE), { cat:{x:catPos.x,y:catPos.y,health:catHealth}, updatedAt:Date.now() });
          }
        }
        if (sym === "ğŸª­" && Date.now() - lastFanBurstAt >= 3000){
          const beaconBoost = isWithinBeaconAura(x, y, 2) ? 2 : 0;
          const burstCount = 2 + beaconBoost;
          const dirs = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1]];
          for (let i=0; i<burstCount; i++){
            const [dx,dy] = dirs[(i + Math.floor(Math.random()*dirs.length)) % dirs.length];
            let wx=x, wy=y;
            for (let step=0; step<5; step++){
              wx += dx + (Math.random()<0.25 ? (Math.floor(Math.random()*3)-1) : 0);
              wy += dy + (Math.random()<0.25 ? (Math.floor(Math.random()*3)-1) : 0);
              wx = Math.max(0, Math.min(gridSize-1, wx));
              wy = Math.max(0, Math.min(gridSize-1, wy));
              rabbitShots.push({x:wx,y:wy});

              for (const unit of listCombatEnemies()){
                if (unit.enemy.x===wx && unit.enemy.y===wy){
                  await damageEnemyUnit({ ...unit.enemy, kind: unit.kind }, 3);
                  const pushed = randomPushDestination(x, y, unit.enemy.x, unit.enemy.y, 1, 2);
                  const docFn = unit.kind==="rat"?ID.rat:unit.kind==="ox"?ID.ox:unit.kind==="ratking"?ID.ratKing:ID.vulture;
                  await updateDoc(ccRef(docFn(unit.enemy.id)), { x:pushed.x, y:pushed.y, updatedAt:Date.now() });
                }
              }
            }
          }
          lastFanBurstAt = Date.now();
        }
      }
    }
    renderGrid();
  }

  async function rabbitDenTick(){
    // spawn rabbits from dens
    if (!window.__lastRabbitSpawnAt) window.__lastRabbitSpawnAt = {};
    for (let y=0; y<gridSize; y++) for (let x=0; x<gridSize; x++) if (grid[y][x] === "ğŸ‡"){
      const local = rabbits.filter(r => Math.abs(r.x-x)+Math.abs(r.y-y)<=2 && (r.health??0)>0);
      if (local.length >= 3) continue;
      const denKey = `${x},${y}`;
      const lastSpawn = window.__lastRabbitSpawnAt[denKey] || 0;
      if (Date.now() - lastSpawn < 15000) continue;
      const id = `rabbit_${crypto.randomUUID()}`;
      await setDoc(ccRef(ID.rabbit(id)), { kind:"rabbit", id, x, y, health:5, createdAt:Date.now() }, { merge:true });
      window.__lastRabbitSpawnAt[denKey] = Date.now();
    }

    for (const rb of rabbits){
      if ((rb.health ?? 0) <= 0) continue;
      const target = nearestEnemyFrom(rb.x, rb.y, Number.POSITIVE_INFINITY);
      if (target){
        const tx = target.kind==="cat" ? catPos.x : target.enemy.x;
        const ty = target.kind==="cat" ? catPos.y : target.enemy.y;
        const distance = Math.abs(tx - rb.x) + Math.abs(ty - rb.y);
        if (distance <= 4){
          let cx = rb.x, cy = rb.y;
          while (cx!==tx || cy!==ty){ cx += Math.sign(tx-cx); cy += Math.sign(ty-cy); rabbitShots.push({x:cx,y:cy}); }
          if (target.kind==="cat"){
            catHealth -= 7;
            await updateDoc(ccRef(ID.STATE), { cat:{x:catPos.x,y:catPos.y,health:catHealth}, updatedAt:Date.now() });
          } else {
            await damageEnemyUnit({...target.enemy,kind:target.kind}, 7);
          }
        } else {
          const nx = rb.x + Math.sign(tx - rb.x);
          const ny = rb.y + Math.sign(ty - rb.y);
          if (nx>=0&&ny>=0&&nx<gridSize&&ny<gridSize&&grid[ny][nx]===""&&!rabbits.some(r=>r.id!==rb.id&&r.x===nx&&r.y===ny)){
            rb.x = nx;
            rb.y = ny;
            await updateDoc(ccRef(ID.rabbit(rb.id)), { x:nx, y:ny, updatedAt:Date.now() });
          }
        }
      } else {
        const opts=[[1,0],[-1,0],[0,1],[0,-1]];
        const [dx,dy] = opts[Math.floor(Math.random()*opts.length)];
        const nx=rb.x+dx, ny=rb.y+dy;
        if (nx>=0&&ny>=0&&nx<gridSize&&ny<gridSize&&grid[ny][nx]===""&&!rabbits.some(r=>r.id!==rb.id&&r.x===nx&&r.y===ny)){
          rb.x=nx; rb.y=ny;
          await updateDoc(ccRef(ID.rabbit(rb.id)), { x:nx, y:ny, updatedAt:Date.now() });
        }
      }
    }
    renderGrid();
  }

  // ============================================================
  // Wave scheduler (host updates state.nextRatWave)
  // ============================================================
  async function waveSchedulerTick(){
    if (!gameStarted) return;
    const now = Date.now();
    const next = nextRatWaveAt;

    if (isHost) await hostSyncDifficultyVote();

    if (isHost && typeof next === "number" && now >= next){
      await spawnRatWave();
      const nextTime = now + 40000;
      nextRatWaveAt = nextTime;
      await updateDoc(ccRef(ID.STATE), { nextRatWave: nextTime, updatedAt: now });
    }

    const secondsLeft = (typeof next === "number") ? Math.max(0, Math.floor((next - now)/1000)) : "?";
    document.getElementById("waveCountdown").textContent = `ğŸ€ Next wave: ${secondsLeft}s`;
  }

  // ============================================================
  // Return to lobby (unchanged paths for /users, allowed by your rules)
  // ============================================================
  async function returnToLobby(){
    const safeUsername = encodeURIComponent(username.trim());

    // award win if cat defeated
    if (catHealth <= 0){
      try{
        const usersSnap = await getDocs(collection(db, "users"));
        let matched = null;

        usersSnap.forEach(docSnap => {
          const data = docSnap.data();
          if ((data.username || "").toLowerCase() === usernameNorm){
            matched = { id: docSnap.id, wins: data.wins || 0 };
          }
        });

        if (matched){
          await updateDoc(doc(db, "users", matched.id), { wins: matched.wins + 1 });
        }
      } catch (err){
        console.error("ğŸ”¥ Error awarding win:", err);
      }
    }

    window.location.href = `/lobby/lobby.html?username=${safeUsername}`;
  }
  window.returnToLobby = returnToLobby;

  // ============================================================
  // Mobile controls
  // ============================================================
  function tryBlink(){
    const event = new KeyboardEvent('keydown', { key: 'b' });
    window.dispatchEvent(event);
  }

  function setupMobileControls(){
    const fsBtn = document.getElementById("fullscreenBtn");
    if (fsBtn){
      fsBtn.addEventListener("click", () => toggleFullscreen());
      fsBtn.addEventListener("touchstart", (e)=>{
        e.preventDefault();
        toggleFullscreen();
      });
    }

    document.querySelectorAll('#structureButtons [data-struct]').forEach(btn => {
      btn.addEventListener('click', () => selectBuild(btn.getAttribute('data-struct')));
      btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        selectBuild(btn.getAttribute('data-struct'));
      });
    });

    const prevBtn = document.getElementById("mobileBuildPrev");
    const nextBtn = document.getElementById("mobileBuildNext");
    if (prevBtn){
      const prev = (e)=>{ if (e) e.preventDefault(); cycleMobileBuild(-1); };
      prevBtn.addEventListener("click", prev);
      prevBtn.addEventListener("touchstart", prev);
    }
    if (nextBtn){
      const next = (e)=>{ if (e) e.preventDefault(); cycleMobileBuild(1); };
      nextBtn.addEventListener("click", next);
      nextBtn.addEventListener("touchstart", next);
    }

    const setupAnalogStick = (stick, thumb, action) => {
      if (!stick || !thumb) return;
      let stickPointerId = null;
      let intervalId = null;
      let lastDirection = null;
      const radius = 34;

      const resetThumb = () => {
        thumb.style.transform = "translate(-50%, -50%)";
      };

      const getDirection = (dx, dy) => {
        if (Math.abs(dx) > Math.abs(dy)) return dx > 0 ? "right" : "left";
        return dy > 0 ? "down" : "up";
      };

      const updateFromPoint = (clientX, clientY) => {
        const rect = stick.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        let dx = clientX - cx;
        let dy = clientY - cy;
        const dist = Math.hypot(dx, dy);

        if (dist > radius){
          const scale = radius / dist;
          dx *= scale;
          dy *= scale;
        }

        thumb.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        if (dist < 10){
          lastDirection = null;
          return;
        }

        const dir = getDirection(dx, dy);
        if (dir !== lastDirection){
          runAnalogDirection(dir, action);
          lastDirection = dir;
        }
      };

      const startStick = (e) => {
        e.preventDefault();
        stickPointerId = e.pointerId;
        lastDirection = null;
        stick.setPointerCapture(stickPointerId);
        updateFromPoint(e.clientX, e.clientY);
        intervalId = setInterval(() => {
          if (lastDirection) runAnalogDirection(lastDirection, action);
        }, 160);
      };

      const moveStick = (e) => {
        if (e.pointerId !== stickPointerId) return;
        e.preventDefault();
        updateFromPoint(e.clientX, e.clientY);
      };

      const endStick = (e) => {
        if (e.pointerId !== stickPointerId) return;
        e.preventDefault();
        if (intervalId) clearInterval(intervalId);
        intervalId = null;
        stickPointerId = null;
        lastDirection = null;
        resetThumb();
      };

      stick.addEventListener("pointerdown", startStick);
      stick.addEventListener("pointermove", moveStick);
      stick.addEventListener("pointerup", endStick);
      stick.addEventListener("pointercancel", endStick);
      stick.addEventListener("pointerleave", endStick);
    };

    setupAnalogStick(
      document.getElementById("moveAnalogStick"),
      document.getElementById("moveAnalogThumb"),
      "move"
    );

    setupAnalogStick(
      document.getElementById("buildAnalogStick"),
      document.getElementById("buildAnalogThumb"),
      "build"
    );

    const upgradeBtn = document.querySelector('[data-upgrade]');
    if (upgradeBtn){
      upgradeBtn.addEventListener('click', ()=> toggleUpgradeMenu());
      upgradeBtn.addEventListener('touchstart', (e)=>{
        e.preventDefault();
        toggleUpgradeMenu();
      });
    }

    const blinkBtn = document.querySelector('[data-blink]');
    if (blinkBtn){
      blinkBtn.addEventListener('click', ()=> tryBlink());
      blinkBtn.addEventListener('touchstart', (e)=>{
        e.preventDefault();
        tryBlink();
      });
    }

    const trapBtn = document.querySelector('[data-trap]');
    if (trapBtn){
      trapBtn.addEventListener('click', ()=> placeTrap());
      trapBtn.addEventListener('touchstart', (e)=>{
        e.preventDefault();
        placeTrap();
      });
    }

    updateMobileBuildDisplay();
  }


  // ============================================================
  // Listen to crowncouncil docs (this replaces all /games/... listeners)
  // ============================================================
  function listenToCrownCouncil(){
    onSnapshot(ccCol, (snap) => {
      for (const ch of snap.docChanges()){
        const id = ch.doc.id;
        const data = ch.doc.data();

        // removed
        if (ch.type === "removed"){
          if (id === ID.STATE){
            // ignore
          } else if (id.startsWith("player_")){
            delete players[data?.uid || id.replace("player_","")];
          } else if (id.startsWith("structure_")){
            const x = data?.x, y = data?.y;
            if (Number.isInteger(x) && Number.isInteger(y)){
              const key = `${x}_${y}`;
              structures.delete(key);
              delete structureHealth[key];
              delete structureShields[key];
              if (grid[y] && grid[y][x] && ["ğŸ§±","ğŸ”«","ğŸª³","ğŸ­","ğŸ’","ğŸ—¼","ğŸš€","ğŸ¦â€ğŸ”¥","ğŸ› ï¸","ğŸ§€","ğŸ‡","âš¡","â˜„ï¸","ğŸ›¡ï¸","ğŸŸ¢","ğŸ”®","ğŸŒ°","ğŸª­"].includes(grid[y][x])){
                grid[y][x] = "";
              }
            }
          } else if (id.startsWith("trap_")){
            const x = data?.x, y = data?.y;
            traps = traps.filter(t => !(t.x===x && t.y===y));
            if (Number.isInteger(x) && Number.isInteger(y) && grid[y][x] === "ğŸª¤") grid[y][x] = "";
          } else if (id.startsWith("rat_")){
            rats = rats.filter(r => r.id !== data?.id);
          } else if (id.startsWith("ox_")){
            oxen = oxen.filter(o => o.id !== data?.id);
          } else if (id.startsWith("rabbit_")){
            rabbits = rabbits.filter(r => r.id !== data?.id);
          } else if (id.startsWith("vulture_")){
            const vId = data?.id || id;
            vultures = vultures.filter(v => v.id !== vId);
          } else if (id.startsWith("termite_")){
            termites = termites.filter(t => t.id !== data?.id);
          } else if (id.startsWith("flea_") || id.startsWith("pflea_")){
            fleas = fleas.filter(f => f.docId !== id);
          } else if (id.startsWith("difficultyvote_")){
            delete difficultyVotes[data?.uid || id.replace("difficultyvote_","")];
            updateDifficultyUI();
          } else if (id.startsWith("selection_")){
            const su = data?.uid || id.replace("selection_","");
            delete selectionStates[su];
            renderSelectionOverlay();
          } else if (id.startsWith("ratking_")){
            ratKings = ratKings.filter(k => k.id !== (data?.id || id));
          }
          continue;
        }

        // added / modified
        if (id === ID.STATE){
          const hostUid = data.hostUid;
          const hostName = data.hostName;
          isHost = (hostUid === uid);

          catPower = data.catPower ?? catPower;
          ratPower = data.ratPower ?? ratPower;
          nextRatWaveAt = (typeof data.nextRatWave === "number") ? data.nextRatWave : nextRatWaveAt;
          applyDifficulty(data.difficulty || currentDifficulty || "medium");

          const cat = data.cat || {};
          catPos = { x: (cat.x ?? catPos.x), y: (cat.y ?? catPos.y) };
          if (typeof cat.health === "number") catHealth = cat.health;
          if (typeof data.selectionDeadline === "number") selectionDeadlineAt = data.selectionDeadline;
          if (data.phase === "playing" && !gameStarted){
            if (!(Array.isArray(selectedBuildSlots) && selectedBuildSlots.length===MAX_BUILD_SLOTS)){
              selectedBuildSlots = [...BASE_BUILD_ORDER];
            }
            mobileBuildOrder = selectedBuildSlots.slice(0,MAX_BUILD_SLOTS);
            if (!selectedBuild && mobileBuildOrder[0]) selectBuild(String(mobileBuildOrder[0]));
            gameStarted = true;
            startHostLoops();
          }

          updateHostDisplay(hostName);
          updateCatHealthBar();
          updateDifficultyUI();
          renderSelectionOverlay();
        }
        else if (id.startsWith("player_")){
          // keep players keyed by uid
          const pu = data.uid || id.replace("player_","");
          players[pu] = {
            uid: pu,
            displayName: data.displayName || "mouse",
            x: data.x ?? 1,
            y: data.y ?? 1,
            cheese: data.cheese ?? 0,
            alive: (data.alive !== false)
          };

          // update my local copies from firestore (so multiple tabs stay consistent)
          if (pu === uid){
            playerPos = { x: players[pu].x, y: players[pu].y };
            isAlive = players[pu].alive;
            cheeseCount = players[pu].cheese ?? 0;
            document.getElementById("cheeseCount").textContent = cheeseCount;
            document.getElementById("status").textContent = isAlive ? "" : "ğŸ’€ You are dead!";
          }
        }
        else if (id.startsWith("structure_")){
          const x = data.x, y = data.y;
          if (Number.isInteger(x) && Number.isInteger(y) && data.type){
            const key = `${x}_${y}`;
            structures.set(key, {x,y,type:data.type,health:data.health ?? 1});
            structureHealth[key] = data.health ?? 1;
            structureShields[key] = Math.max(0, data.shield ?? structureShields[key] ?? 0);
            grid[y][x] = data.type;
          }
        }
        else if (id.startsWith("trap_")){
          const x = data.x, y = data.y;
          if (Number.isInteger(x) && Number.isInteger(y)){
            traps = traps.filter(t => !(t.x===x && t.y===y));
            traps.push({x,y,placedAt:data.placedAt ?? Date.now()});
            grid[y][x] = "ğŸª¤";
          }
        }
        else if (id.startsWith("rat_")){
          const r = { ...data };
          if (!r.id) r.id = data.id || id;
          const existing = rats.find(rr => rr.id === r.id);
          if (existing) Object.assign(existing, r);
          else rats.push(r);
        }
        else if (id.startsWith("ox_")){
          const o = { ...data };
          if (!o.id) o.id = data.id || id;
          const existing = oxen.find(oo => oo.id === o.id);
          if (existing) Object.assign(existing, o);
          else oxen.push(o);
        }
        else if (id.startsWith("rabbit_")){
          const rb = { ...data };
          if (!rb.id) rb.id = data.id || id;
          const existing = rabbits.find(rr => rr.id === rb.id);
          if (existing) Object.assign(existing, rb);
          else rabbits.push(rb);
        }
        else if (id.startsWith("vulture_")){
          const v = { ...data };
          if (!v.id) v.id = data.id || id;
          const existing = vultures.find(vv => vv.id === v.id);
          if (existing) Object.assign(existing, v);
          else vultures.push(v);
        }
        else if (id.startsWith("termite_")){
          const t = { ...data };
          if (!t.id) t.id = data.id || id;
          const existing = termites.find(tt => tt.id === t.id);
          if (existing) Object.assign(existing, t);
          else termites.push(t);
        }
        else if (id.startsWith("flea_") || id.startsWith("pflea_")){
          const f = { ...data };
          f.docId = id;
          if (!f.id) f.id = id;
          const existing = fleas.find(ff => ff.docId === id);
          if (existing) Object.assign(existing, f);
          else fleas.push(f);
        }
        else if (id.startsWith("difficultyvote_")){
          const vu = data.uid || id.replace("difficultyvote_","");
          if (DIFFICULTY_SETTINGS[data.vote]){
            difficultyVotes[vu] = data.vote;
            if (vu === uid) myDifficultyVote = data.vote;
          }
          updateDifficultyUI();
        }
        else if (id.startsWith("selection_")){
          const su = data.uid || id.replace("selection_","");
          selectionStates[su] = {
            uid: su,
            done: data.done === true,
            picks: Array.isArray(data.picks) ? data.picks.slice(0,MAX_BUILD_SLOTS) : []
          };
          if (su === uid){
            mySelectionDone = data.done === true;
            if (Array.isArray(data.picks)) selectedBuildSlots = data.picks.slice(0,MAX_BUILD_SLOTS);
          }
          renderSelectionOverlay();
        }
        else if (id.startsWith("ratking_")){
          const rk = { ...data };
          if (!rk.id) rk.id = data.id || id;
          const existing = ratKings.find(rr => rr.id === rk.id);
          if (existing) Object.assign(existing, rk);
          else ratKings.push(rk);
        }
      }

      renderGrid();
    });
  }

  // ============================================================
  // Ensure lobby + state doc exist (host selection)
  // ============================================================
  async function ensureLobbyAndState(){
    // lobby doc (your rules allow it)
    await setDoc(lobbyRef, {
      gameType: "catvsmouse",
      updatedAt: Date.now()
    }, { merge:true });

    // state doc inside crowncouncil (your rules allow it)
    await runTransaction(db, async (tx) => {
      const sRef = ccRef(ID.STATE);
      const snap = await tx.get(sRef);

      if (!snap.exists()){
        // first joiner becomes host
        tx.set(sRef, {
          kind: "state",
          hostUid: uid,
          hostName: username,
          difficulty: "medium",
          cat: { x: gridSize-1, y: gridSize-1, health: DIFFICULTY_SETTINGS.medium.catStartHealth },
          catPower: 0,
          ratPower: 1,
          nextRatWave: Date.now() + 30000,
          phase: "selection",
          selectionDeadline: Date.now() + 45000,
          createdAt: Date.now(),
          updatedAt: Date.now()
        }, { merge:true });
      }
    });

    // read state once to set isHost early
    const sSnap = await getDoc(ccRef(ID.STATE));
    if (sSnap.exists()){
      const s = sSnap.data();
      isHost = (s.hostUid === uid);
      catPower = s.catPower ?? 0;
      ratPower = s.ratPower ?? 1;
      nextRatWaveAt = (typeof s.nextRatWave === "number") ? s.nextRatWave : nextRatWaveAt;
      applyDifficulty(s.difficulty || "medium");
      const cat = s.cat || {};
      catPos = { x: cat.x ?? catPos.x, y: cat.y ?? catPos.y };
      catHealth = (typeof cat.health === "number") ? cat.health : catHealth;
      selectionDeadlineAt = (typeof s.selectionDeadline === "number") ? s.selectionDeadline : (Date.now()+45000);
      gameStarted = s.phase === "playing";
      updateHostDisplay(s.hostName);
      updateCatHealthBar();
      updateDifficultyUI();
    }
  }

  function renderSelectionOverlay(){
    const slots = Array.from({length:MAX_BUILD_SLOTS}, (_,i) => `${i+1}: ${BUILD_DEFS[selectedBuildSlots[i]]?.symbol || "_"}`).join(" | ");
    const topSlots = document.getElementById("selectedBuildSlotsTop");
    if (topSlots) topSlots.textContent = `Slots â€” ${slots}`;

    const overlay = document.getElementById("selectionOverlay");
    if (!overlay) return;
    if (gameStarted){ overlay.style.display = "none"; return; }
    overlay.style.display = "flex";

    const info = document.getElementById("selectionInfo");
    const gridEl = document.getElementById("selectionGrid");
    const slotsEl = document.getElementById("selectedSlots");
    const slotListEl = document.getElementById("slotList");
    const finalizeMeta = document.getElementById("selectionFinalizeMeta");
    const now = Date.now();
    const left = selectionDeadlineAt ? Math.max(0, Math.ceil((selectionDeadlineAt - now)/1000)) : 45;
    info.textContent = `Wins: ${playerWins}. Time left: ${left}s. Difficulty: ${DIFFICULTY_SETTINGS[currentDifficulty]?.label || "Medium"}`;

    slotsEl.textContent = `Your slots: ${slots}`;

    slotListEl.innerHTML = "";
    for (let i=0; i<MAX_BUILD_SLOTS; i++){
      const buildId = selectedBuildSlots[i];
      const chip = document.createElement("button");
      chip.className = `slot-chip ${buildId ? "filled" : ""} ${mySelectionDone ? "done" : ""}`;
      chip.type = "button";
      chip.innerHTML = buildId
        ? `<div><strong>${i+1}:</strong> ${BUILD_DEFS[buildId]?.symbol || ""} ${BUILD_DEFS[buildId]?.name || ""}</div><div style="font-size:12px;opacity:0.8;">Tap to remove</div>`
        : `<div><strong>${i+1}:</strong> Empty</div><div style="font-size:12px;opacity:0.7;">Tap a building below</div>`;
      chip.disabled = mySelectionDone || !buildId;
      chip.onclick = async () => {
        if (mySelectionDone || !buildId) return;
        selectedBuildSlots.splice(i, 1);
        selectedBuildSlots = selectedBuildSlots.filter(Boolean).slice(0,MAX_BUILD_SLOTS);
        await publishMySelection(false);
        renderSelectionOverlay();
      };
      slotListEl.appendChild(chip);
    }

    const unlocked = new Set(getUnlockedBuildIds());
    gridEl.innerHTML = "";
    Object.entries(BUILD_DEFS).forEach(([id, def]) => {
      const b = document.createElement("button");
      b.className = "sel-btn";
      const winsTxt = `${Math.min(playerWins, def.minWins || 0)}/${def.minWins || 0}`;
      const locked = !unlocked.has(Number(id));
      const alreadyChosen = selectedBuildSlots.includes(Number(id));
      b.innerHTML = `<div>${def.symbol} ${def.name}</div><div>ğŸ§€${def.cost}</div>${locked ? `<div>ğŸ”’ ${winsTxt}</div>` : ""}`;
      if (locked) b.classList.add("locked");
      if (alreadyChosen) b.classList.add("chosen");
      b.disabled = locked || mySelectionDone;
      b.onclick = async () => {
        if (mySelectionDone) return;
        const buildId = Number(id);
        const alreadyIdx = selectedBuildSlots.indexOf(buildId);
        if (alreadyIdx !== -1){
          selectedBuildSlots.splice(alreadyIdx, 1);
        } else {
          const emptyIndex = selectedBuildSlots.findIndex(v => !v);
          if (emptyIndex !== -1) selectedBuildSlots[emptyIndex] = buildId;
          else if (selectedBuildSlots.length < MAX_BUILD_SLOTS) selectedBuildSlots.push(buildId);
          else return;
        }
        selectedBuildSlots = selectedBuildSlots.filter(Boolean).slice(0,MAX_BUILD_SLOTS);
        await publishMySelection(false);
        renderSelectionOverlay();
      };
      gridEl.appendChild(b);
    });

    const participantIds = getLobbyParticipants().map(([pu]) => pu);
    const doneCount = participantIds.reduce((acc, pu) => acc + (selectionStates[pu]?.done ? 1 : 0), 0);
    const stillNeeded = Math.max(0, participantIds.length - doneCount);
    if (finalizeMeta) finalizeMeta.textContent = `${stillNeeded} player(s) still need to finalize.`;
  }

  async function publishMySelection(done=false){
    selectionStates[uid] = {
      uid,
      done,
      picks: selectedBuildSlots.slice(0,MAX_BUILD_SLOTS)
    };
    await setDoc(ccRef(getSelectionDocId(uid)), {
      kind:"selection", uid, done, picks:selectedBuildSlots.slice(0,MAX_BUILD_SLOTS), updatedAt:Date.now()
    }, { merge:true });
    mySelectionDone = done;
  }

  async function tryHostFinalizeSelection(force=false){
    if (!isHost) return;
    const snap = await getDocs(ccCol);
    const participantIds = getLobbyParticipants().map(([pu]) => pu);
    const doneBy = new Set();
    snap.forEach(d => {
      if (!d.id.startsWith("selection_")) return;
      const data = d.data();
      if (data.done) doneBy.add(data.uid);
    });
    const allDone = participantIds.length>0 && participantIds.every(pu => doneBy.has(pu));
    if (allDone || force){
      const finalDifficulty = computeDifficultyFromVotes(difficultyVotes);
      await updateDoc(ccRef(ID.STATE), {
        difficulty: finalDifficulty,
        cat: { x: catPos.x, y: catPos.y, health: DIFFICULTY_SETTINGS[finalDifficulty].catStartHealth },
        phase:"playing",
        updatedAt:Date.now()
      });
    }
  }

  // ============================================================
  // Keyboard input (kept with your behavior)
  // ============================================================
  window.addEventListener("keydown", async (e) => {
    if (!isAlive) return;

    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)) e.preventDefault();

    if (e.key === " "){
      toggleUpgradeMenu();
      return;
    }

    if (upgradeMenuOpen && ["1","2","3","4","5","6"].includes(e.key) && advancementPoints > 0){
      selectUpgrade(e.key);
      return;
    }

    // movement
    if (canMove){
      switch (e.key){
        case "ArrowUp":    lastDirection={dx:0,dy:-1}; movePlayer(0,-1); triggerMoveCooldown(); break;
        case "ArrowDown":  lastDirection={dx:0,dy:1};  movePlayer(0,1);  triggerMoveCooldown(); break;
        case "ArrowLeft":  lastDirection={dx:-1,dy:0}; movePlayer(-1,0); triggerMoveCooldown(); break;
        case "ArrowRight": lastDirection={dx:1,dy:0};  movePlayer(1,0);  triggerMoveCooldown(); break;
      }
    }

    // blink
    if (blinkActive && e.key.toLowerCase() === "b"){
      const now = Date.now();
      if (now - lastBlinkTime >= 8000){
        const dx = lastDirection.dx;
        const dy = lastDirection.dy;
        const nx = playerPos.x + dx * 5;
        const ny = playerPos.y + dy * 5;

        if (nx>=0 && nx<gridSize && ny>=0 && ny<gridSize && grid[ny][nx] === ""){
          playerPos = { x:nx, y:ny };
          lastBlinkTime = now;
          await savePosition();
          renderGrid();
          const cell = document.getElementById(`cell-${nx}-${ny}`);
          if (cell){
            cell.style.backgroundColor = "#b3f0ff";
            setTimeout(()=>cell.style.backgroundColor="#c8f7c5", 300);
          }
        }
      }
    }

    if (trapmasterActive && e.key.toLowerCase() === "t"){
      await placeTrap();
    }

    if (!upgradeMenuOpen && ["1","2","3","4","5","6","7","8"].includes(e.key)){
      const idx = Number(e.key) - 1;
      const buildId = mobileBuildOrder[idx];
      if (buildId) selectBuild(String(buildId));
    }

    if (["w","a","s","d"].includes(e.key)){
      await placeStructure(e.key);
    }
  });

  // ============================================================
  // Global loops (kept gameplay)
  // ============================================================
  function startGlobalLoops(){
    // mobile setup
    const mobileLike = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || window.matchMedia("(max-width: 768px)").matches;
    if (mobileLike){
      document.getElementById("mobileControls").style.display = "block";
      document.getElementById("fullscreenBtn").style.display = "inline-block";
      renderMobileUpgradeButtons();
      setupMobileControls();
    }

    document.querySelectorAll('.difficulty-vote').forEach(btn => {
      btn.onclick = () => castDifficultyVote(btn.dataset.diff).catch(()=>{});
    });
    updateDifficultyUI();

    const finishBtn = document.getElementById("finishSelectionBtn");
    if (finishBtn){
      finishBtn.onclick = async () => {
        if (selectedBuildSlots.length < MAX_BUILD_SLOTS){
          const used = new Set(selectedBuildSlots);
          const fills = BASE_BUILD_ORDER.filter(id => !used.has(id));
          selectedBuildSlots = [...selectedBuildSlots, ...fills].slice(0,MAX_BUILD_SLOTS);
        }
        await publishMySelection(true);
        await tryHostFinalizeSelection(false);
      };
    }

    setInterval(() => {
      if (gameStarted) return;
      renderSelectionOverlay();
      if (isHost){
        hostSyncDifficultyVote().catch(()=>{});
      }
      if (isHost && selectionDeadlineAt && Date.now() >= selectionDeadlineAt){
        tryHostFinalizeSelection(true).catch(()=>{});
      }
    }, 500);

    // no pre-placed walls on match start
    renderGrid();

    // cheese spawn (local only, same as your original)
    setInterval(spawnCheese, 10000);

    // ability cooldown UI
    setInterval(updateAbilityStatus, 1000);
    setInterval(updateEconomyTimersUI, 500);
    updateEconomyTimersUI();

    // adv point every 3 mins
    setInterval(() => {
      if (!gameStarted || !isAlive) return;
      lastAdvPointAt = Date.now();
      advancementPoints++;
      document.getElementById("advPoints").textContent = advancementPoints;

      const msg = document.getElementById("advPointMessage");
      msg.textContent = "ğŸŸ¢ You gained an advancement point!";
      msg.style.display = "block";
      setTimeout(()=>msg.style.display="none", 2500);
    }, 180000);

    // player flea master spawns near player (local list; host will move if these are synced)
    setInterval(() => {
      if (!fleaMasterActive || !isAlive) return;

      // spawn up to 2 â€œplayer fleasâ€ near player
      const offsets = [{dx:0,dy:0},{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
      let spawned = 0;

      for (const o of offsets){
        const fx = playerPos.x + o.dx;
        const fy = playerPos.y + o.dy;
        if (fx<0||fy<0||fx>=gridSize||fy>=gridSize) continue;

        // prevent overlap
        if (fleas.some(f => f.x===fx && f.y===fy && f.ownerUid===uid && f.origin==="player")) continue;

        fleas.push({
          docId: ID.pflea(uid, Date.now()+spawned),
          x: fx,
          y: fy,
          lifetime: 15,
          ownerUid: uid,
          origin: "player"
        });

        spawned++;
        if (spawned >= 2) break;
      }
      renderGrid();
    }, fleaSpawnCooldown);

    // keep player fleas synced if active (like your original)
    setInterval(() => {
      if (fleaMasterActive && isAlive){
        syncMyFleas().catch(()=>{});
      }
    }, 1200);

    // generator payout
    setInterval(() => { if (gameStarted) generatorPayoutTick(); }, 15000);

    // game over check
    setInterval(() => {
      if (!gameStarted) return;

      const anyAlive = Object.values(players).some(p => (p.alive ?? true) !== false);

      let phoenixExists = false;
      for (let y=0; y<gridSize && !phoenixExists; y++){
        for (let x=0; x<gridSize && !phoenixExists; x++){
          if (grid[y][x] === "ğŸ¦â€ğŸ”¥") phoenixExists = true;
        }
      }

      if (!anyAlive && !phoenixExists){
        const st = document.getElementById("status");
        st.textContent = "ğŸ’€ All mice are dead. Game Over!";
        document.getElementById("returnButton").style.display = "block";
        st.style.color = "red";
        st.style.fontSize = "24px";
        st.style.fontWeight = "bold";
        st.style.background = "#fff0f0";
        st.style.padding = "10px";
        st.style.border = "2px solid red";
        st.style.marginTop = "10px";
        gameStarted = false;
      }
    }, 1000);

    // wave countdown + host wave scheduling
    setInterval(() => { waveSchedulerTick().catch(()=>{}); }, 1000);
  }

  // ============================================================
  // Host loops (cat AI + spawns + enemy sim)
  // ============================================================
  function startHostLoops(){
    if (!isHost || hostInitialized) return;
    hostInitialized = true;

    gameStarted = true;
    startCatBehaviorLoop();

    // power ramp
    setInterval(async () => {
      if (!gameStarted) return;

      catPower++;
      const playerCount = Object.keys(players).length;
      catHealth += 15 * playerCount;

      await updateDoc(ccRef(ID.STATE), {
        catPower,
        cat: { x: catPos.x, y: catPos.y, health: catHealth },
        updatedAt: Date.now()
      });

      startCatBehaviorLoop();
    }, 20000);

    // turret + rocket
    setInterval(() => turretAttack().catch(()=>{}), 1500);
    setInterval(() => rocketTowerAttack().catch(()=>{}), 3500);
    setInterval(() => repairStationTick().catch(()=>{}), 3000);
    setInterval(() => specialStructureTick().catch(()=>{}), 2000);
    setInterval(() => rabbitDenTick().catch(()=>{}), 2000);

    // rat power ramp
    setInterval(async () => {
      ratPower++;
      await updateDoc(ccRef(ID.STATE), { ratPower, updatedAt: Date.now() });
    }, 120000);

    // flea nests spawn fleas (now actually writes them, so everyone sees)
    setInterval(async () => {
      // count nests and spawn fleas in Firestore
      for (let y=0; y<gridSize; y++){
        for (let x=0; x<gridSize; x++){
          if (grid[y][x] !== "ğŸª³") continue;

          let beaconBonus = 0;
          for (let dy=-2; dy<=2; dy++){
            for (let dx=-2; dx<=2; dx++){
              const nx = x+dx, ny=y+dy;
              if (nx>=0&&nx<gridSize&&ny>=0&&ny<gridSize && grid[ny][nx]==="ğŸ—¼") beaconBonus++;
            }
          }
          const spawnCount = 1 + beaconBonus;

          const offsets = [
            {dx:0,dy:0},{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1},
            {dx:1,dy:1},{dx:-1,dy:-1},{dx:1,dy:-1},{dx:-1,dy:1}
          ];

          for (let i=0; i<spawnCount; i++){
            const off = offsets[Math.floor(Math.random()*offsets.length)];
            const fx = x + off.dx;
            const fy = y + off.dy;
            if (fx<0||fy<0||fx>=gridSize||fy>=gridSize) continue;

            const fid = `nest_${crypto.randomUUID()}`;
            await setDoc(ccRef(ID.flea(fid)), {
              kind: "flea",
              id: fid,
              x: fx, y: fy,
              lifetime: 15,
              origin: "nest",
              createdAt: Date.now()
            }, { merge:true });
          }
        }
      }
    }, 4000);

    // wall master heal (runs host-side; writes structure hp)
    setInterval(async () => {
      // apply to all players who have wall master? (kept close to your behavior: only local player toggles)
      // Since upgrades are local-only in your original, we keep it local-only:
      // host will not try to â€œguessâ€ who has wall master. We keep your original behavior by letting
      // each client do their own wall heal writes if they have it.
    }, 1000);

    // termites spawn center
    setInterval(async () => {
      if (!gameStarted || catPower <= 0) return;

      const centerX = Math.floor(gridSize/2);
      const centerY = Math.floor(gridSize/2);
      const numToSpawn = Math.ceil(catPower/2);

      const offsets = [
        {x:0,y:0},{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1},
        {x:1,y:1},{x:-1,y:-1},{x:1,y:-1},{x:-1,y:1}
      ];

      let spawned = 0;
      for (let i=0; i<offsets.length && spawned<numToSpawn; i++){
        const ox = centerX + offsets[i].x;
        const oy = centerY + offsets[i].y;
        if (ox<0||oy<0||ox>=gridSize||oy>=gridSize) continue;
        if (termites.some(t => t.x===ox && t.y===oy)) continue;

        const id = `termite_${Date.now()}_${i}`;
        await setDoc(ccRef(ID.termite(id)), {
          kind: "termite",
          id,
          x: ox,
          y: oy,
          createdAt: Date.now()
        }, { merge:true });
        spawned++;
      }
    }, 60000);

    // late game vultures (after oxen phase)
    setInterval(async () => {
      if (!gameStarted || catPower < 25) return;
      const desired = Math.min(6, 1 + Math.floor((catPower - 25) / 6));
      const living = vultures.filter(v => (v.health ?? 0) > 0).length;
      const toSpawn = Math.max(0, desired - living);
      if (toSpawn <= 0) return;

      for (let i=0; i<toSpawn; i++){
        const vx = Math.max(0, Math.min(gridSize-1, catPos.x + (Math.floor(Math.random()*7)-3)));
        const vy = Math.max(0, Math.min(gridSize-1, catPos.y + (Math.floor(Math.random()*7)-3)));
        const id = `vulture_${crypto.randomUUID()}`;
        await setDoc(ccRef(ID.vulture(id)), {
          kind: "vulture",
          id,
          x: vx,
          y: vy,
          health: ratPower * 20,
          createdAt: Date.now()
        }, { merge:true });
      }
    }, 8000);

    // enemy sim ticks
    const scheduleRatTick = () => {
      const ratTickMs = Math.max(550, 1050 - (catPower * 12));
      setTimeout(async () => {
        await hostMoveRats().catch(()=>{});
        scheduleRatTick();
      }, ratTickMs);
    };
    scheduleRatTick();

    setInterval(() => hostMoveOxen().catch(()=>{}), 800);
    setInterval(() => hostMoveRatKings().catch(()=>{}), 700);
    setInterval(() => hostMoveVultures().catch(()=>{}), 600);
    setInterval(() => hostMoveTermites().catch(()=>{}), 400);
    setInterval(() => hostMoveFleas().catch(()=>{}), 400);

    // phoenix revive
    setInterval(() => hostPhoenixRevive().catch(()=>{}), 2000);

    // keep cat health synced (state already updated often; this keeps it in case)
    setInterval(async () => {
      if (!gameStarted) return;
      await updateDoc(ccRef(ID.STATE), { cat: {x:catPos.x,y:catPos.y,health:catHealth}, updatedAt: Date.now() });
    }, 3000);
  }

  // ============================================================
  // Client-only wall master healing (kept from your original)
  // ============================================================
  setInterval(async () => {
    if (!wallMasterActive || !isAlive) return;

    for (let dy=-1; dy<=1; dy++){
      for (let dx=-1; dx<=1; dx++){
        const tx = playerPos.x + dx;
        const ty = playerPos.y + dy;
        if (tx<0||ty<0||tx>=gridSize||ty>=gridSize) continue;

        const key = `${tx}_${ty}`;
        if ((grid[ty][tx]==="ğŸ§±" || grid[ty][tx]==="ğŸ’") && (structureHealth[key] ?? 0) < 80){
          structureHealth[key] = (structureHealth[key] ?? 0) + 4;
          await updateDoc(ccRef(ID.structure(tx,ty)), { health: structureHealth[key] });
        }
      }
    }
  }, 1000);

  // ============================================================
  // Boot
  // ============================================================
  await ensureLobbyAndState();
  await fetchPlayerWins();
  await upsertMyPlayerDoc();
  await publishMySelection(false);
  listenToCrownCouncil();

  startGlobalLoops();
  renderSelectionOverlay();
  if (gameStarted) startHostLoops();

</script>
</body>
</html>
