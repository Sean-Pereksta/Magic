<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>ğŸ­ Cat vs Mouse</title>

  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      background: #f4f4f4;
      margin: 0;
      padding: 0;
    }
    h1 { margin: 10px 0; }

    #gridWrapper{
      width: 400px;
      height: 400px;
      border: 3px solid black;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto;
      background: #eaeaea;
    }
    #grid{
      display: grid;
      justify-content: center;
      margin: 0 auto;
      position: relative;
      z-index: 0;
    }

    .cell{
      width: 20px;
      height: 20px;
      text-align: center;
      font-size: 16px;
      position: relative;
      background: #c8f7c5;
    }
    .name{
      font-size: 10px;
      position: absolute;
      top: -12px;
      left: 0;
      right: 0;
      text-align: center;
      pointer-events:none;
      user-select:none;
    }
    .health-bar{
      position: absolute;
      top: -6px;
      left: 0;
      height: 3px;
      background-color: red;
      border-radius: 1px;
      pointer-events:none;
      user-select:none;
    }

    #catHealthContainer{ margin-top: 10px; }
    #catHealthBar{
      height: 20px;
      width: 300px;
      background: lightgray;
      position: relative;
      border-radius: 8px;
      margin: 0 auto;
    }
    #catHealthFill{
      height: 100%;
      width: 100%;
      background: red;
      border-radius: 8px;
    }
    #catHealthText{
      position: absolute;
      width: 100%;
      top: 0;
      text-align: center;
      font-weight: bold;
    }

    #mobileControls{
      display: none;
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 25;
      background: rgba(245,245,245,0.96);
      border-top: 2px solid #bbb;
      padding: 10px 8px calc(10px + env(safe-area-inset-bottom));
      box-shadow: 0 -8px 18px rgba(0,0,0,0.2);
    }

    .mobile-row{ display:flex; justify-content:center; gap:8px; flex-wrap:wrap; margin:6px 0; }
    #mobileControls .pad{ background:#fff; border:1px solid #999; border-radius:10px; }
    #mobileControls .active{ background:#d4e8ff; border-color:#5591d3; }

    #fullscreenBtn{
      position: fixed;
      top: 8px;
      right: 8px;
      z-index: 30;
      display: none;
      font-size: 14px;
      padding: 8px 10px;
      border-radius: 10px;
    }

    button, select{
      font-size: 20px;
      padding: 14px 20px;
      margin: 6px;
    }

    html, body { touch-action: manipulation; }

    @media (max-width: 768px){
      #mobileControls{ display: block; }
      #fullscreenBtn{ display: inline-block; }
      #grid{ margin-top: 10px; }
      body{ padding-bottom: 245px; }
      #gridWrapper{ width: min(96vw, 400px); height: min(96vw, 400px); }
      .cell{ width: min(20px, 96vw/30); height: min(20px, 96vw/30); font-size: 14px; }
    }

    #waveCountdown{
      margin-top: 8px;
      font-weight: 700;
      font-size: 16px;
    }

    .structure-health-shell{
      position:absolute;
      left:1px;
      right:1px;
      top:-8px;
      height:5px;
      background:rgba(20,20,20,0.32);
      border-radius:8px;
      overflow:hidden;
      border:1px solid rgba(0,0,0,0.25);
      pointer-events:none;
    }

    .structure-health-fill{
      height:100%;
      border-radius:8px;
      transition:width 0.2s ease;
      background:linear-gradient(90deg,#ef4444,#f59e0b,#22c55e);
    }
  </style>
</head>

<body>
  <button id="fullscreenBtn" aria-label="Toggle full screen">â›¶ Fullscreen</button>
  <h1 style="text-align:center;">ğŸ± Cat vs ğŸ­ Mouse</h1>

  <div style="text-align:center; margin-bottom:10px;">
    <p style="margin:5px 0; font-size:14px; color:#444;">
      ğŸ® Arrow keys to move | A/W/S/D to build | 1â€“8 to select building | Space = Upgrade Menu
    </p>
    <p style="margin:10px 0; font-size:13px; font-weight:bold; color:#333;">
      ğŸ§± Wall (1, ğŸ§€1) &nbsp; | &nbsp;
      ğŸ”« Turret (2, ğŸ§€3) &nbsp; | &nbsp;
      ğŸª³ Flea Nest (3, ğŸ§€5) &nbsp; | &nbsp;
      ğŸ­ Generator (4, ğŸ§€4) &nbsp; | &nbsp;
      ğŸ’ Super Wall (5, ğŸ§€6) &nbsp; | &nbsp;
      ğŸ—¼ Beacon (6, ğŸ§€24) &nbsp; | &nbsp;
      ğŸ¦â€ğŸ”¥ Phoenix Cheese (7, ğŸ§€40) &nbsp; | &nbsp;
      ğŸš€ Rocket Tower (8, ğŸ§€30)
    </p>
  </div>

  <div id="returnButton" style="display:none; margin-top:20px; text-align:center;">
    <button onclick="returnToLobby()" style="padding:10px 20px; font-size:16px;">ğŸ”™ Return to Lobby</button>
  </div>

  <div id="waveCountdown">ğŸ€ Next wave: ?</div>

  <div style="display:flex; justify-content:center; align-items:flex-start; gap:20px; margin-top:20px;">
    <div style="width:200px; font-size:14px;">
      <p><strong>ğŸ§€ Cheese:</strong> <span id="cheeseCount">0</span></p>
      <p><strong>âš¡ Advancement Points:</strong> <span id="advPoints">0</span></p>
      <p><strong>ğŸ”¨ Selected Build:</strong> <span id="buildType">None</span></p>

      <div id="abilityStatus" style="margin-top:10px;"></div>

      <p id="advPointMessage" style="color:green; font-weight:bold; display:none; margin:5px 0;">
        ğŸŸ¢ You gained an advancement point!
      </p>

      <p id="status"></p>

      <div id="playerStatus" style="margin-top:10px;"></div>
      <div id="hostDisplay" style="margin-top:10px; font-weight:bold; color:#333;"></div>

      <div id="upgradeMenu" style="display:none; background:#eee; border:2px solid #888; padding:10px; margin-top:10px;">
        <h3>ğŸ”§ Upgrade Menu</h3>
        <div id="mobileUpgradeButtons" style="margin:10px 0;"></div>
        <p>
          <b>1</b> â€“ ğŸƒ <strong>Speedster</strong><br>
          <b>2</b> â€“ ğŸ§€ <strong>Scavenger</strong><br>
          <b>3</b> â€“ ğŸ <strong>Flea Master</strong><br>
          <b>4</b> â€“ ğŸ§± <strong>Wall Master</strong><br>
          <b>5</b> â€“ ğŸª¤ <strong>Trapmaster</strong><br>
          <b>6</b> â€“ ğŸŒ€ <strong>Blink</strong>
        </p>
        <p>Chosen: <span id="chosenUpgrades"></span></p>
      </div>
    </div>

    <div>
      <div id="gridWrapper"><div id="grid"></div></div>

      <div id="mobileControls" style="margin-top:20px; display:none;">
        <div class="mobile-row">
          <select id="mobileBuildSelect" aria-label="Select building type">
            <option value="">ğŸ—ï¸ Select Build</option>
            <option value="1">ğŸ§± Wall (1)</option>
            <option value="2">ğŸ”« Turret (3)</option>
            <option value="3">ğŸª³ Flea Nest (5)</option>
            <option value="4">ğŸ­ Generator (4)</option>
            <option value="5">ğŸ’ Super Wall (6)</option>
            <option value="6">ğŸ—¼ Beacon (24)</option>
            <option value="7">ğŸ¦â€ğŸ”¥ Phoenix Cheese (40)</option>
            <option value="8">ğŸš€ Rocket Tower (30)</option>
          </select>
          <button data-upgrade>ğŸ› ï¸ Upgrades</button>
          <button data-blink>ğŸŒ€ Blink</button>
          <button data-trap>ğŸª¤ Trap</button>
        </div>

        <div class="mobile-row">
          <div class="pad">
            <button data-move="up" aria-label="Move Up">â¬†ï¸</button><br>
            <button data-move="left" aria-label="Move Left">â¬…ï¸</button>
            <button data-move="down" aria-label="Move Down">â¬‡ï¸</button>
            <button data-move="right" aria-label="Move Right">â¡ï¸</button>
          </div>
        </div>

        <div class="mobile-row">
          <div class="pad">
            <button data-place="w" aria-label="Build Up">â¬†ï¸ Build</button>
            <button data-place="a" aria-label="Build Left">â¬…ï¸</button>
            <button data-place="s" aria-label="Build Down">â¬‡ï¸</button>
            <button data-place="d" aria-label="Build Right">â¡ï¸</button>
          </div>
        </div>

        <div id="structureButtons" style="margin-top:10px;">
          <strong>Select Structure:</strong><br>
          <button data-struct="1">ğŸ§±</button>
          <button data-struct="2">ğŸ”«</button>
          <button data-struct="3">ğŸª³</button>
          <button data-struct="4">ğŸ­</button>
          <button data-struct="5">ğŸ’</button>
          <button data-struct="6">ğŸ—¼</button>
          <button data-struct="7">ğŸ¦â€ğŸ”¥</button>
          <button data-struct="8">ğŸš€</button>
        </div>

        <div id="upgradeButtons" style="display:none; margin-bottom:12px;">
          <strong>Upgrades:</strong><br>
          <button onclick="selectUpgrade('1')">1 â€“ Speedster</button>
          <button onclick="selectUpgrade('2')">2 â€“ Scavenger</button>
          <button onclick="selectUpgrade('3')">3 â€“ Flea Master</button>
          <button onclick="selectUpgrade('4')">4 â€“ Wall Master</button>
          <button onclick="selectUpgrade('5')">5 â€“ Trapmaster</button>
          <button onclick="selectUpgrade('6')">6 â€“ Blink</button>
        </div>

      </div>

      <div id="catHealthContainer" style="margin-top:10px;">
        <div id="catHealthBar">
          <div id="catHealthFill"></div>
          <div id="catHealthText">â¤ï¸ 1000 / 1000</div>
        </div>
      </div>
    </div>
  </div>

<script type="module">
  // ============================================================
  // Firebase (UPDATED to work with YOUR rules)
  // - Your rules allow: /lobbies/{gameId} and /lobbies/{gameId}/crowncouncil/{docId}
  // - Your rules require auth: request.auth != null
  // So we:
  //   âœ… sign in anonymously
  //   âœ… move all game docs from /games/... to /lobbies/{gameId}/crowncouncil/...
  // ============================================================

  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
  import {
    getFirestore,
    doc,
    getDoc,
    setDoc,
    updateDoc,
    deleteDoc,
    onSnapshot,
    collection,
    getDocs,
    runTransaction
  } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
    authDomain: "bible-game-246c0.firebaseapp.com",
    projectId: "bible-game-246c0"
  };

  const app = initializeApp(firebaseConfig);
  const db  = getFirestore(app);

  // âœ… Auth required by your rules
  const auth = getAuth(app);
  await signInAnonymously(auth);
  const uid = auth.currentUser.uid;

  // ============================================================
  // Routing (use lobbies + crowncouncil so rules allow it)
  // ============================================================
  const urlParams = new URLSearchParams(window.location.search);
  const gameId = urlParams.get("gameId") || "default";
  let username = (urlParams.get("username") || "guest").trim();
  const usernameNorm = username.toLowerCase();

  const lobbyRef = doc(db, `lobbies/${gameId}`);
  const ccCol    = collection(db, `lobbies/${gameId}/crowncouncil`);
  const ccRef    = (id) => doc(db, `lobbies/${gameId}/crowncouncil/${id}`);

  const ID = {
    STATE: "state",
    player: (uid) => `player_${uid}`,
    structure: (x,y) => `structure_${x}_${y}`,
    trap: (x,y) => `trap_${x}_${y}`,
    rat: (id) => `rat_${id}`,
    ox: (id) => `ox_${id}`,
    vulture: (id) => `vulture_${id}`,
    termite: (id) => `termite_${id}`,
    flea: (id) => `flea_${id}`,
    // Player-fleas (so a player can â€œownâ€ their flea docs; host moves them)
    pflea: (uid, i) => `pflea_${uid}_${i}`
  };

  // ============================================================
  // Game state
  // ============================================================
  const gridSize = 30;
  const gridElement = document.getElementById("grid");
  const grid = Array.from({length:gridSize}, () => Array.from({length:gridSize}, () => ""));

  let gameStarted = false;

  let playerPos = { x: 1, y: 1 };
  let catPos    = { x: 15, y: 15 };

  let selectedBuild = null;
  let cheeseCount = 0;
  let isAlive = true;

  let catHealth = 1000;
  let catPower  = 0;
  let ratPower  = 1;

  let canMove = true;
  let moveCooldown = 225; // âœ… was const before; upgrades change it

  let advancementPoints = 0;
  let upgradeMenuOpen = false;
  let selectedUpgrades = [];

  let fleaSpawnCooldown = 1500;
  let fleaMasterActive = false;
  let cheesePickupBonus = 0;
  let wallMasterActive = false;
  let trapmasterActive = false;
  let blinkActive = false;

  let lastTrapTime = 0;
  let lastBlinkTime = 0;
  let lastDirection = { dx: 0, dy: 0 };

  let showingUpgrades = false;

  let isHost = false;
  let hostInitialized = false;
  let catMoveInterval = null;

  // â€œRemoteâ€ objects pulled from Firestore
  let players = {}; // uid -> {x,y,cheese,alive,displayName}
  let structureHealth = {}; // key "x_y" -> hp
  let structures = new Map(); // key -> {x,y,type,health}

  let traps = [];     // {x,y,placedAt}
  let rats = [];      // {id,x,y,health,...}
  let oxen = [];      // {id,x,y,health}
  let vultures = [];  // {id,x,y,health}
  let termites = [];  // {id,x,y}
  let fleas = [];     // {id,x,y,lifetime,...}

  let lastPlayerWriteAt = 0;
  let lastPlayerPayload = null;
  let nextRatWaveAt = null;

  const STRUCTURE_MAX_HP = {
    "ğŸ§±": 15, "ğŸ”«": 5, "ğŸª³": 10, "ğŸ­": 5,
    "ğŸ’": 75, "ğŸ—¼": 25, "ğŸ¦â€ğŸ”¥": 20, "ğŸš€": 20
  };

  // ============================================================
  // UI helpers
  // ============================================================
  function updateHostDisplay(hostName){
    document.getElementById("hostDisplay").textContent = `ğŸ‘‘ Host: ${hostName || "Unknown"}`;
  }

  function updateCatHealthBar(){
    const bar  = document.getElementById("catHealthFill");
    const text = document.getElementById("catHealthText");
    const percent = Math.min(100, (catHealth / 1000) * 100);
    bar.style.width = percent + "%";
    text.textContent = `â¤ï¸ ${catHealth}`;
  }

  function toggleMobileMode(){
    showingUpgrades = !showingUpgrades;
    document.getElementById("structureButtons").style.display = showingUpgrades ? "none" : "block";
    document.getElementById("upgradeButtons").style.display   = showingUpgrades ? "block" : "none";
  }
  window.toggleMobileMode = toggleMobileMode;

  async function toggleFullscreen(){
    try {
      if (!document.fullscreenElement) await document.documentElement.requestFullscreen();
      else await document.exitFullscreen();
    } catch {}
  }

  function toggleUpgradeMenu(){
    upgradeMenuOpen = !upgradeMenuOpen;
    document.getElementById("upgradeMenu").style.display = upgradeMenuOpen ? "block" : "none";
  }

  function selectBuild(value){
    selectedBuild = parseInt(value, 10);
    const buildNames = {
      1: "Wall ğŸ§± (Cost: 1)",
      2: "Turret ğŸ”« (Cost: 3)",
      3: "Flea Nest ğŸª³ (Cost: 5)",
      4: "Cheese Generator ğŸ­ (Cost: 4)",
      5: "Super Wall ğŸ’ (Cost: 6)",
      6: "Cheese Beacon ğŸ—¼ (Cost: 24)",
      7: "Phoenix Cheese ğŸ¦â€ğŸ”¥ (Cost: 40)",
      8: "Rocket Tower ğŸš€ (Cost: 30)"
    };
    document.getElementById("buildType").textContent = buildNames[selectedBuild] || "None";
    const mobileBuildSelect = document.getElementById("mobileBuildSelect");
    if (mobileBuildSelect) mobileBuildSelect.value = String(selectedBuild || "");
  }

  function selectUpgrade(key){
    if (!upgradeMenuOpen || advancementPoints <= 0) return;

    const upgradeMap = {
      "1": "Speedster",
      "2": "Scavenger",
      "3": "Flea Master",
      "4": "Wall Master",
      "5": "Trapmaster",
      "6": "Blink"
    };

    const upgrade = upgradeMap[key];
    if (!upgrade || selectedUpgrades.includes(upgrade)) return;

    selectedUpgrades.push(upgrade);
    advancementPoints--;

    document.getElementById("advPoints").textContent = advancementPoints;
    document.getElementById("chosenUpgrades").textContent = selectedUpgrades.join(", ");

    if (upgrade === "Speedster") moveCooldown = 50;
    if (upgrade === "Scavenger") cheesePickupBonus = 7;
    if (upgrade === "Flea Master") fleaMasterActive = true;
    if (upgrade === "Wall Master") wallMasterActive = true;
    if (upgrade === "Trapmaster") trapmasterActive = true;
    if (upgrade === "Blink") blinkActive = true;
  }
  window.selectUpgrade = selectUpgrade;

  function renderMobileUpgradeButtons(){
    const container = document.getElementById("mobileUpgradeButtons");
    container.innerHTML = "";
    const upgrades = [
      { key:"1", name:"Speedster" },
      { key:"2", name:"Scavenger" },
      { key:"3", name:"Flea Master" },
      { key:"4", name:"Wall Master" },
      { key:"5", name:"Trapmaster" },
      { key:"6", name:"Blink" }
    ];
    for (const u of upgrades){
      const btn = document.createElement("button");
      btn.textContent = `${u.key} â€“ ${u.name}`;
      btn.style.margin = "4px";
      btn.onclick = () => {
        const event = new KeyboardEvent("keydown", { key: u.key });
        window.dispatchEvent(event);
      };
      container.appendChild(btn);
    }
  }

  function updateAbilityStatus(){
    const statusDiv = document.getElementById("abilityStatus");
    let content = "";
    const now = Date.now();

    if (blinkActive){
      const cooldown = 8000;
      const remaining = Math.max(0, cooldown - (now - lastBlinkTime));
      const ready = remaining === 0;
      content += `ğŸŒ€ Blink [B]: <span style="color:${ready ? 'green' : 'gray'}">${ready ? "Ready!" : (Math.ceil(remaining/1000)+"s")}</span><br>`;
    }

    if (trapmasterActive){
      const cooldown = 20000;
      const remaining = Math.max(0, cooldown - (now - lastTrapTime));
      const ready = remaining === 0;
      content += `ğŸª¤ Trap [T]: <span style="color:${ready ? 'green' : 'gray'}">${ready ? "Ready!" : (Math.ceil(remaining/1000)+"s")}</span><br>`;
    }

    statusDiv.innerHTML = content;
  }

  // ============================================================
  // Rendering
  // ============================================================
  function renderGrid(){
    const viewSize = 20;
    const halfView = Math.floor(viewSize/2);
    const viewport = document.getElementById("grid");
    viewport.innerHTML = "";

    viewport.style.gridTemplateColumns = `repeat(${viewSize}, 20px)`;
    viewport.style.gridTemplateRows    = `repeat(${viewSize}, 20px)`;
    viewport.style.width = "400px";
    viewport.style.height = "400px";

    const centerX = playerPos.x;
    const centerY = playerPos.y;
    const startX = centerX - halfView;
    const startY = centerY - halfView;

    // generator trigger highlighting
    const generatorTriggers = new Set();
    for (let y=0; y<gridSize; y++){
      for (let x=0; x<gridSize; x++){
        if (grid[y][x] === "ğŸ­"){
          for (const p of Object.values(players)){
            if ((p.alive ?? true) === false) continue;
            const dx = Math.abs((p.x ?? 0) - x);
            const dy = Math.abs((p.y ?? 0) - y);
            if (dx + dy <= 9){ generatorTriggers.add(`${x}_${y}`); break; }
          }
        }
      }
    }

    // beacon boosted tiles
    const beaconBoosted = new Set();
    for (let y=0; y<gridSize; y++){
      for (let x=0; x<gridSize; x++){
        if (grid[y][x] === "ğŸ—¼"){
          for (let dy=-2; dy<=2; dy++){
            for (let dx=-2; dx<=2; dx++){
              const tx = x+dx, ty = y+dy;
              if (tx>=0 && tx<gridSize && ty>=0 && ty<gridSize){
                const tSymbol = grid[ty][tx];
                if (["ğŸ”«","ğŸ­","ğŸª³","ğŸš€"].includes(tSymbol)){
                  beaconBoosted.add(`${tx}_${ty}`);
                }
              }
            }
          }
        }
      }
    }

    // base tiles
    for (let row=0; row<viewSize; row++){
      for (let col=0; col<viewSize; col++){
        const x = startX + col;
        const y = startY + row;
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.id = `cell-${x}-${y}`;

        if (x>=0 && x<gridSize && y>=0 && y<gridSize){
          const key = `${x}_${y}`;
          const symbol = grid[y][x];

          if (beaconBoosted.has(key)) cell.style.background = "#ff8a8a";
          else if (generatorTriggers.has(key)) cell.style.background = "#fff977";
          else cell.style.background = "#c8f7c5";

          cell.textContent = symbol || "";
        } else {
          cell.style.background = "#888";
          cell.textContent = "";
        }

        viewport.appendChild(cell);
      }
    }

    // players
    for (const [pu, p] of Object.entries(players)){
      if ((p.alive ?? true) === false) continue;
      const cell = document.getElementById(`cell-${p.x}-${p.y}`);
      if (cell){
        cell.textContent = "ğŸ­";
        const nameTag = document.createElement("div");
        nameTag.className = "name";
        nameTag.textContent = (p.displayName || "mouse").toLowerCase();
        cell.appendChild(nameTag);
      }
    }

    // fleas
    for (const f of fleas){
      const cell = document.getElementById(`cell-${f.x}-${f.y}`);
      if (cell) cell.textContent = "ğŸ";
    }

    // rats
    for (const r of rats){
      if ((r.health ?? 0) <= 0) continue;
      const cell = document.getElementById(`cell-${r.x}-${r.y}`);
      if (cell){
        cell.textContent = "ğŸ€";
        const hpTag = document.createElement("div");
        hpTag.className = "name";
        hpTag.style.color = "brown";
        hpTag.textContent = `â¤ï¸${r.health}`;
        cell.appendChild(hpTag);
      }
    }

    // oxen
    for (const o of oxen){
      if ((o.health ?? 0) <= 0) continue;
      const cell = document.getElementById(`cell-${o.x}-${o.y}`);
      if (cell){
        cell.textContent = "ğŸ‚";
        const hpTag = document.createElement("div");
        hpTag.className = "name";
        hpTag.style.color = "orange";
        hpTag.textContent = `â¤ï¸${o.health}`;
        cell.appendChild(hpTag);
      }
    }

    // termites
    for (const t of termites){
      const cell = document.getElementById(`cell-${t.x}-${t.y}`);
      if (cell) cell.textContent = "ğŸ›";
    }

    // structure health bars
    for (const key in structureHealth){
      const [xs, ys] = key.split("_");
      const x = parseInt(xs,10), y = parseInt(ys,10);
      if (!(x>=0 && x<gridSize && y>=0 && y<gridSize)) continue;

      const symbol = grid[y][x];
      const cell = document.getElementById(`cell-${x}-${y}`);
      if (cell && ["ğŸ§±","ğŸª³","ğŸ’","ğŸš€","ğŸ­","ğŸ”«","ğŸ—¼","ğŸ¦â€ğŸ”¥"].includes(symbol)){
        const shell = document.createElement("div");
        shell.className = "structure-health-shell";

        const bar = document.createElement("div");
        bar.className = "structure-health-fill";
        const hp = structureHealth[key] ?? 0;
        const maxHp = STRUCTURE_MAX_HP[symbol] ?? Math.max(1, hp);
        const pct = Math.max(0, Math.min(100, (hp / maxHp) * 100));
        bar.style.width = `${pct}%`;
        if (pct > 66) bar.style.background = "linear-gradient(90deg,#22c55e,#16a34a)";
        else if (pct > 33) bar.style.background = "linear-gradient(90deg,#f59e0b,#f97316)";
        else bar.style.background = "linear-gradient(90deg,#ef4444,#dc2626)";
        shell.appendChild(bar);
        cell.appendChild(shell);
      }
    }

    // vultures
    for (const v of vultures){
      if ((v.health ?? 0) <= 0) continue;
      const cell = document.getElementById(`cell-${v.x}-${v.y}`);
      if (cell) cell.textContent = "ğŸ¦…";
    }

    // cat
    const catCell = document.getElementById(`cell-${catPos.x}-${catPos.y}`);
    if (catCell){
      catCell.textContent = "ğŸ±";
      const levelTag = document.createElement("div");
      levelTag.className = "name";
      levelTag.style.color = "red";
      levelTag.innerHTML = `âš¡Lv.${catPower}`;
      catCell.appendChild(levelTag);

      const bar = document.createElement("div");
      bar.className = "health-bar";
      const denom = Math.max(1, (catPower * 10));
      const barWidth = Math.max(10, Math.min(100, (catHealth/denom)*100));
      bar.style.width = `${barWidth}%`;
      bar.style.background = "red";
      bar.style.height = "3px";
      bar.style.marginTop = "-10px";
      catCell.appendChild(bar);
    }

    // status list
    const statusDiv = document.getElementById("playerStatus");
    statusDiv.innerHTML = "";
    for (const p of Object.values(players)){
      const sp = document.createElement("span");
      sp.style.marginRight = "10px";
      sp.style.fontWeight = "bold";
      sp.style.color = ((p.alive ?? true) ? "green" : "red");
      sp.textContent = `${(p.displayName||"mouse").toLowerCase()}: ${((p.alive ?? true) ? "ALIVE" : "DEAD")}`;
      statusDiv.appendChild(sp);
    }
  }

  // ============================================================
  // Movement / cooldown
  // ============================================================
  function triggerMoveCooldown(){
    canMove = false;
    setTimeout(() => canMove = true, moveCooldown);
  }

  function movePlayer(dx, dy){
    if (!gameStarted || !isAlive) return;
    const newX = Math.max(0, Math.min(gridSize-1, playerPos.x + dx));
    const newY = Math.max(0, Math.min(gridSize-1, playerPos.y + dy));
    playerPos = { x: newX, y: newY };
    savePosition();
    checkCheese();
    renderGrid();
  }

  function move(dir){
    if (!canMove || !isAlive) return;
    if (dir==="up") movePlayer(0,-1);
    else if (dir==="down") movePlayer(0,1);
    else if (dir==="left") movePlayer(-1,0);
    else if (dir==="right") movePlayer(1,0);
    triggerMoveCooldown();
  }

  function place(dir){
    if (!canMove || !isAlive || selectedBuild === null) return;
    placeStructure(dir);
  }

  // ============================================================
  // Cheese
  // ============================================================
  function spawnCheese(){
    let spawned = 0;
    let attempts = 0;
    const maxAttempts = 100;

    while (spawned < 4 && attempts < maxAttempts){
      const x = Math.floor(Math.random()*gridSize);
      const y = Math.floor(Math.random()*gridSize);
      if (grid[y][x] === ""){
        grid[y][x] = "ğŸ§€";
        spawned++;
      }
      attempts++;
    }
    renderGrid();
  }

  function checkCheese(){
    if (grid[playerPos.y][playerPos.x] === "ğŸ§€"){
      grid[playerPos.y][playerPos.x] = "";
      cheeseCount += 3 + cheesePickupBonus;
      document.getElementById("cheeseCount").textContent = cheeseCount;
      savePosition();
      renderGrid();
    }
  }

  // ============================================================
  // Firestore writes (UPDATED paths)
  // ============================================================
  async function savePosition(){
    const now = Date.now();
    const pRef = ccRef(ID.player(uid));
    const payload = {
      kind: "player",
      uid,
      displayName: username,
      nameKey: usernameNorm,
      x: playerPos.x,
      y: playerPos.y,
      cheese: cheeseCount,
      alive: isAlive,
      updatedAt: now
    };

    const unchanged = lastPlayerPayload &&
      lastPlayerPayload.x === payload.x &&
      lastPlayerPayload.y === payload.y &&
      lastPlayerPayload.cheese === payload.cheese &&
      lastPlayerPayload.alive === payload.alive;
    if (unchanged && (now - lastPlayerWriteAt) < 200) return;

    lastPlayerWriteAt = now;
    lastPlayerPayload = { x: payload.x, y: payload.y, cheese: payload.cheese, alive: payload.alive };
    await setDoc(pRef, payload, { merge:true });
  }

  async function upsertMyPlayerDoc(){
    const pRef = ccRef(ID.player(uid));
    await setDoc(pRef, {
      kind: "player",
      uid,
      displayName: username,
      nameKey: usernameNorm,
      x: playerPos.x,
      y: playerPos.y,
      cheese: 0,
      alive: true,
      updatedAt: Date.now()
    }, { merge:true });
  }

  // ============================================================
  // Structures
  // ============================================================
  async function placeStructure(dir){
    if (!gameStarted || !isAlive || !selectedBuild) return;

    let cost = 0;
    if (selectedBuild===1) cost=1;
    else if (selectedBuild===2) cost=3;
    else if (selectedBuild===3) cost=5;
    else if (selectedBuild===4) cost=4;
    else if (selectedBuild===5) cost=6;
    else if (selectedBuild===6) cost=24;
    else if (selectedBuild===7) cost=40;
    else if (selectedBuild===8) cost=30;

    if (cheeseCount < cost) return;

    let tx = playerPos.x, ty = playerPos.y;
    if (dir==="w") ty--;
    if (dir==="a") tx--;
    if (dir==="s") ty++;
    if (dir==="d") tx++;
    if (tx<0 || ty<0 || tx>=gridSize || ty>=gridSize) return;

    if (grid[ty][tx] !== "") return;

    let symbol = "";
    let health = 1;

    if (selectedBuild===1){ symbol="ğŸ§±"; health=15; }
    else if (selectedBuild===2){ symbol="ğŸ”«"; health=5; }
    else if (selectedBuild===3){ symbol="ğŸª³"; health=10; }
    else if (selectedBuild===4){ symbol="ğŸ­"; health=5; }
    else if (selectedBuild===5){ symbol="ğŸ’"; health=75; }
    else if (selectedBuild===6){ symbol="ğŸ—¼"; health=25; }
    else if (selectedBuild===7){ symbol="ğŸ¦â€ğŸ”¥"; health=20; }
    else if (selectedBuild===8){ symbol="ğŸš€"; health=20; }

    const key = `${tx}_${ty}`;
    grid[ty][tx] = symbol;
    structureHealth[key] = health;

    cheeseCount -= cost;
    document.getElementById("cheeseCount").textContent = cheeseCount;
    savePosition();

    // âœ… store under crowncouncil
    await setDoc(ccRef(ID.structure(tx,ty)), {
      kind: "structure",
      x: tx,
      y: ty,
      type: symbol,
      health,
      placedBy: uid,
      placedAt: Date.now()
    }, { merge:true });

    renderGrid();
  }

  async function damageStructure(x, y, damageAmount = (1 + Math.floor(catPower/3))){
    const key = `${x}_${y}`;
    if (structureHealth[key] === undefined) return;

    structureHealth[key] -= damageAmount;
    if (structureHealth[key] <= 0){
      grid[y][x] = "";
      delete structureHealth[key];
      await deleteDoc(ccRef(ID.structure(x,y)));
    } else {
      await updateDoc(ccRef(ID.structure(x,y)), { health: structureHealth[key] });
    }
    renderGrid();
  }

  // ============================================================
  // Traps (stored under crowncouncil)
  // ============================================================
  async function placeTrap(){
    const now = Date.now();
    if (now - lastTrapTime < 20000) return;

    const {x,y} = playerPos;
    if (grid[y][x] !== "") return;

    grid[y][x] = "ğŸª¤";
    lastTrapTime = now;

    await setDoc(ccRef(ID.trap(x,y)), {
      kind: "trap",
      x, y,
      placedAt: now,
      placedBy: uid
    }, { merge:true });

    renderGrid();
  }

  // ============================================================
  // Player flea syncing (player-owned flea docs)
  // ============================================================
  async function syncMyFleas(){
    // delete old player flea docs
    const snap = await getDocs(ccCol);
    const deletions = [];
    snap.forEach(d => {
      if (d.id.startsWith(`pflea_${uid}_`)){
        deletions.push(deleteDoc(d.ref));
      }
    });
    await Promise.all(deletions);

    // write current player fleas (the â€œnear meâ€ fleas)
    // we store minimal; host moves/attacks them too
    const now = Date.now();
    let i=0;
    for (const f of fleas.filter(ff => ff.ownerUid === uid && ff.origin === "player")){
      const docId = ID.pflea(uid, i++);
      await setDoc(ccRef(docId), {
        kind: "flea",
        id: docId,
        x: f.x, y: f.y,
        lifetime: f.lifetime ?? 15,
        ownerUid: uid,
        origin: "player",
        updatedAt: now
      }, { merge:true });
    }
  }

  // ============================================================
  // Turrets / Rocket tower (host writes cat state to state doc)
  // ============================================================
  async function turretAttack(){
    for (let y=0; y<gridSize; y++){
      for (let x=0; x<gridSize; x++){
        if (grid[y][x] !== "ğŸ”«") continue;

        let attacked = false;

        // beacon bonus within 2 tiles
        let bonusDamage = 0;
        for (let dy=-2; dy<=2; dy++){
          for (let dx=-2; dx<=2; dx++){
            const nx = x+dx, ny=y+dy;
            if (nx>=0 && nx<gridSize && ny>=0 && ny<gridSize && grid[ny][nx]==="ğŸ—¼") bonusDamage++;
          }
        }
        const damage = 2 + bonusDamage;

        // cat within 5
        const dxCat = Math.abs(catPos.x - x);
        const dyCat = Math.abs(catPos.y - y);
        if (dxCat<=5 && dyCat<=5){
          catHealth -= damage;
          await updateDoc(ccRef(ID.STATE), { cat: {x:catPos.x,y:catPos.y,health:catHealth}, updatedAt: Date.now() });
          if (catHealth <= 0){
            document.getElementById("status").textContent = "ğŸ‰ Mice win!";
            document.getElementById("returnButton").style.display = "block";
          }
          attacked = true;
        }

        // else rat
        if (!attacked){
          for (const r of rats){
            if ((r.health ?? 0) <= 0) continue;
            const dxRat = Math.abs(r.x - x);
            const dyRat = Math.abs(r.y - y);
            if (dxRat<=5 && dyRat<=5){
              r.health -= damage;
              attacked = true;
              if (r.health <= 0){
                await deleteDoc(ccRef(ID.rat(r.id)));
              } else {
                await updateDoc(ccRef(ID.rat(r.id)), { health: r.health });
              }
              break;
            }
          }
        }

        // else ox
        if (!attacked){
          for (const o of oxen){
            if ((o.health ?? 0) <= 0) continue;
            const dxOx = Math.abs(o.x - x);
            const dyOx = Math.abs(o.y - y);
            if (dxOx<=5 && dyOx<=5){
              o.health -= damage;
              attacked = true;
              if (o.health <= 0){
                await deleteDoc(ccRef(ID.ox(o.id)));
              } else {
                await updateDoc(ccRef(ID.ox(o.id)), { health: o.health });
              }
              break;
            }
          }
        }
      }
    }
    renderGrid();
  }

  async function rocketTowerAttack(){
    for (let y=0; y<gridSize; y++){
      for (let x=0; x<gridSize; x++){
        if (grid[y][x] !== "ğŸš€") continue;

        // beacon boost?
        let boosted = false;
        for (let dy=-2; dy<=2; dy++){
          for (let dx=-2; dx<=2; dx++){
            const bx = x+dx, by=y+dy;
            if (bx>=0 && bx<gridSize && by>=0 && by<gridSize && grid[by][bx]==="ğŸ—¼"){
              boosted = true; break;
            }
          }
          if (boosted) break;
        }

        // farthest rat within 8
        let target = null;
        let maxDist = -1;
        for (const r of rats){
          if ((r.health ?? 0) <= 0) continue;
          const dist = Math.abs(r.x - x) + Math.abs(r.y - y);
          if (dist <= 8 && dist > maxDist){
            maxDist = dist;
            target = r;
          }
        }
        if (!target) continue;

        const mainDamage   = boosted ? 20 : 15;
        const splashDamage = boosted ? 15 : 10;

        target.health -= mainDamage;
        if (target.health <= 0){
          await deleteDoc(ccRef(ID.rat(target.id)));
        } else {
          await updateDoc(ccRef(ID.rat(target.id)), { health: target.health });
        }

        for (let dy=-1; dy<=1; dy++){
          for (let dx=-1; dx<=1; dx++){
            const sx = target.x + dx;
            const sy = target.y + dy;
            if (sx<0 || sy<0 || sx>=gridSize || sy>=gridSize) continue;
            if (dx===0 && dy===0) continue;

            for (const r of rats){
              if (r.id !== target.id && r.x===sx && r.y===sy && (r.health ?? 0) > 0){
                r.health -= splashDamage;
                if (r.health <= 0) await deleteDoc(ccRef(ID.rat(r.id)));
                else await updateDoc(ccRef(ID.rat(r.id)), { health: r.health });
              }
            }
            for (const o of oxen){
              if (o.x===sx && o.y===sy && (o.health ?? 0) > 0){
                o.health -= splashDamage;
                if (o.health <= 0) await deleteDoc(ccRef(ID.ox(o.id)));
                else await updateDoc(ccRef(ID.ox(o.id)), { health: o.health });
              }
            }
            if (catPos.x===sx && catPos.y===sy && catHealth>0){
              catHealth -= splashDamage;
              await updateDoc(ccRef(ID.STATE), { cat: {x:catPos.x,y:catPos.y,health:catHealth}, updatedAt: Date.now() });
            }
          }
        }
      }
    }
    renderGrid();
  }

  // ============================================================
  // Pathfinding (kept compatible with your calls)
  // ============================================================
  function findPath(startX, startY, targetX, targetY, allowTargetWallOrPassable = false){
    const queue = [[startX, startY, []]];
    const visited = new Set([`${startX},${startY}`]);

    const directions = [[1,0],[-1,0],[0,1],[0,-1]];

    const passableFn = (typeof allowTargetWallOrPassable === "function") ? allowTargetWallOrPassable : null;
    const allowTargetWall = (typeof allowTargetWallOrPassable === "boolean") ? allowTargetWallOrPassable : false;

    while (queue.length){
      const [x,y,path] = queue.shift();
      if (x===targetX && y===targetY) return path;

      for (const [dx,dy] of directions){
        const nx = x+dx, ny=y+dy;
        const k = `${nx},${ny}`;
        if (nx<0 || nx>=gridSize || ny<0 || ny>=gridSize) continue;
        if (visited.has(k)) continue;

        const isTarget = (nx===targetX && ny===targetY);
        const cell = grid[ny][nx];
        const isWall = (cell==="ğŸ§±" || cell==="ğŸ’");

        let ok;
        if (passableFn){
          ok = !!passableFn(nx, ny);
        } else {
          ok = !isWall || (allowTargetWall && isTarget);
        }

        if (!ok) continue;
        visited.add(k);
        queue.push([nx, ny, [...path, {x:nx,y:ny}]]);
      }
    }
    return null;
  }

  function getNearestReachableStructureTarget(startX, startY, passableFn = null){
    let best = null;
    for (let y=0; y<gridSize; y++){
      for (let x=0; x<gridSize; x++){
        const symbol = grid[y][x];
        if (!["ğŸ§±","ğŸ”«","ğŸª³","ğŸ­","ğŸ’","ğŸ—¼","ğŸš€","ğŸ¦â€ğŸ”¥"].includes(symbol)) continue;

        const targetIsWall = (symbol === "ğŸ§±" || symbol === "ğŸ’");
        const passable = passableFn
          ? ((nx, ny) => (nx===x && ny===y) ? true : passableFn(nx, ny))
          : targetIsWall;

        const path = findPath(startX, startY, x, y, passable);
        if (path && (!best || path.length < best.path.length)){
          best = { x, y, path };
        }
      }
    }
    return best;
  }

  // ============================================================
  // Cat AI
  // ============================================================
  function startCatBehaviorLoop(){
    if (catMoveInterval) clearInterval(catMoveInterval);
    const speed = Math.max(200, 1300 - catPower * 40);
    catMoveInterval = setInterval(() => {
      if (gameStarted) catBehavior();
    }, speed);
  }

  async function catBehavior(){
    // traps check
    for (const t of traps){
      if (t.x===catPos.x && t.y===catPos.y){
        clearInterval(catMoveInterval);
        setTimeout(() => startCatBehaviorLoop(), 5000);

        await deleteDoc(ccRef(ID.trap(catPos.x, catPos.y)));
        const cell = document.getElementById(`cell-${catPos.x}-${catPos.y}`);
        if (cell){
          cell.style.backgroundColor = "#ffaaaa";
          setTimeout(()=>cell.style.backgroundColor="#c8f7c5", 300);
        }
        renderGrid();
        return;
      }
    }

    const aliveMice = Object.values(players).filter(p => (p.alive ?? true) !== false);
    let target = null;
    let path = null;
    let mouseBlocked = true;

    // closest reachable mouse
    for (const p of aliveMice){
      const pPath = findPath(catPos.x, catPos.y, p.x, p.y, false);
      if (pPath){
        mouseBlocked = false;
        if (!path || pPath.length < path.length){
          target = {x:p.x,y:p.y,type:"mouse"};
          path = pPath;
        }
      }
    }

    // if mice are blocked/unreachable, attack nearest reachable structure
    if (!target && mouseBlocked){
      const structureTarget = getNearestReachableStructureTarget(catPos.x, catPos.y, false);
      if (structureTarget){
        target = { x: structureTarget.x, y: structureTarget.y, type: "structure" };
        path = structureTarget.path;
      }
    }

    // move
    if (target && path && path.length > 0){
      const next = path[0];
      const symbol = grid[next.y][next.x];
      const isBlocked = (symbol==="ğŸ§±" || symbol==="ğŸ’");
      if (!isBlocked){
        catPos.x = next.x;
        catPos.y = next.y;
      }
    }

    // attack nearby
    let attacked = false;
    for (let dy=-1; dy<=1 && !attacked; dy++){
      for (let dx=-1; dx<=1 && !attacked; dx++){
        const tx = catPos.x+dx, ty=catPos.y+dy;
        if (tx<0||ty<0||tx>=gridSize||ty>=gridSize) continue;
        if (["ğŸ§±","ğŸ”«","ğŸª³","ğŸ­","ğŸ’","ğŸ—¼","ğŸš€","ğŸ¦â€ğŸ”¥"].includes(grid[ty][tx])){
          await damageStructure(tx,ty);
          attacked = true;
        }
      }
    }

    // kill players on cat tile
    for (const [pu, p] of Object.entries(players)){
      if ((p.alive ?? true) && catPos.x===p.x && catPos.y===p.y){
        await updateDoc(ccRef(ID.player(pu)), { alive:false, updatedAt: Date.now() });
        if (pu === uid){
          isAlive = false;
          document.getElementById("status").textContent = "ğŸ’€ You are dead!";
        }
      }
    }

    // write cat state
    await updateDoc(ccRef(ID.STATE), {
      cat: { x: catPos.x, y: catPos.y, health: catHealth },
      updatedAt: Date.now()
    });

    updateCatHealthBar();
    renderGrid();
  }

  // ============================================================
  // Host spawning
  // ============================================================
  async function spawnRatWave(){
    if (!isHost || catPower <= 0) return;

    const waveTag = Date.now();
    const allOffsets = [
      { x: 0, y: 0 },  { x: 1, y: 0 },  { x: -1, y: 0 },
      { x: 0, y: 1 },  { x: 0, y: -1 }, { x: 1, y: 1 },
      { x: -1, y: -1 },{ x: 1, y: -1 }, { x: -1, y: 1 },
      { x: 2, y: 0 },  { x: 0, y: 2 },  { x: -2, y: 0 }, { x: 0, y: -2 },
      { x: 2, y: 1 },  { x: 1, y: 2 },  { x: -1, y: 2 }, { x: -2, y: 1 },
      { x: -2, y: -1 },{ x: -1, y: -2 },{ x: 1, y: -2 }, { x: 2, y: -1 }
    ];

    const availableSpots = allOffsets
      .map(o => ({x:catPos.x+o.x,y:catPos.y+o.y}))
      .filter(p =>
        p.x>=0 && p.x<gridSize && p.y>=0 && p.y<gridSize &&
        grid[p.y][p.x] === "" &&
        !rats.some(r => r.x===p.x && r.y===p.y) &&
        !oxen.some(o => o.x===p.x && o.y===p.y)
      );

    const usedKeys = new Set();

    // oxen
    const oxCount = (catPower>=15) ? (Math.floor((catPower-15)/10)+1) : 0;
    let oxSpawned = 0;
    for (let i=0; i<availableSpots.length && oxSpawned<oxCount; i++){
      const spot = availableSpots[i];
      const key = `${spot.x}_${spot.y}`;
      if (usedKeys.has(key)) continue;
      usedKeys.add(key);

      const id = `ox_${crypto.randomUUID()}`;
      await setDoc(ccRef(ID.ox(id)), {
        kind: "ox",
        id,
        x: spot.x,
        y: spot.y,
        health: ratPower * 30,
        wave: waveTag,
        createdAt: Date.now()
      }, { merge:true });
      oxSpawned++;
    }

    // rats
    const maxRats = catPower;
    let ratsSpawned = 0;
    for (let i=0; i<availableSpots.length && ratsSpawned<maxRats; i++){
      const spot = availableSpots[i];
      const key = `${spot.x}_${spot.y}`;
      if (usedKeys.has(key)) continue;
      usedKeys.add(key);

      const id = `rat_${crypto.randomUUID()}`;
      await setDoc(ccRef(ID.rat(id)), {
        kind: "rat",
        id,
        x: spot.x,
        y: spot.y,
        health: ratPower * 5,
        wave: waveTag,
        createdAt: Date.now()
      }, { merge:true });
      ratsSpawned++;
    }
  }

  // ============================================================
  // Host enemies movement / logic (kept from your gameplay)
  // ============================================================
  async function hostMoveRats(){
    for (const rat of rats){
      if ((rat.health ?? 0) <= 0) continue;

      if (rat.trappedUntil && Date.now() < rat.trappedUntil) continue;

      // trap check
      for (const t of traps){
        if (t.x===rat.x && t.y===rat.y){
          rat.trappedUntil = Date.now() + 3000;
          await deleteDoc(ccRef(ID.trap(rat.x, rat.y)));
          const cell = document.getElementById(`cell-${rat.x}-${rat.y}`);
          if (cell){
            cell.style.backgroundColor = "#ffcccc";
            setTimeout(()=>cell.style.backgroundColor="#c8f7c5", 300);
          }
          renderGrid();
          continue;
        }
      }

      let closestTarget = null;
      let minDist = Infinity;

      // reachable nearby player first
      for (const [pu, p] of Object.entries(players)){
        if ((p.alive ?? true) === false) continue;
        const manhattan = Math.abs(p.x - rat.x) + Math.abs(p.y - rat.y);
        if (manhattan > 7) continue;

        const pPath = findPath(rat.x, rat.y, p.x, p.y, (x, y) => {
          const isBlocked = ["ğŸ§±","ğŸ­","ğŸ’","ğŸ—¼"].includes(grid[y][x]);
          const ratOccupied = rats.some(r => r.id !== rat.id && r.x===x && r.y===y);
          return !isBlocked && !ratOccupied;
        });

        if (pPath && pPath.length > 0){
          minDist = pPath.length;
          closestTarget = { x:p.x, y:p.y, type:"mouse", uid: pu, priority: 0 };
          break;
        }
      }

      // closest player
      for (const [pu, p] of Object.entries(players)){
        if ((p.alive ?? true) !== false){
          const dist = Math.abs(p.x - rat.x) + Math.abs(p.y - rat.y);
          if (dist < minDist){
            minDist = dist;
            closestTarget = { x:p.x, y:p.y, type:"mouse", uid: pu, priority: 1 };
          }
        }
      }

      // closest structure
      for (let y=0; y<gridSize; y++){
        for (let x=0; x<gridSize; x++){
          if (["ğŸ§±","ğŸ”«","ğŸª³","ğŸ­","ğŸ’","ğŸ—¼","ğŸš€","ğŸ¦â€ğŸ”¥"].includes(grid[y][x])){
            const dist = Math.abs(x - rat.x) + Math.abs(y - rat.y);
            if (dist < minDist || (dist===minDist && (closestTarget?.priority ?? 99) > 2)){
              minDist = dist;
              closestTarget = { x, y, type:"structure", priority: 2 };
            }
          }
        }
      }

      if (closestTarget){
        const centerX = Math.floor(gridSize/2);
        const centerY = Math.floor(gridSize/2);

        const path = findPath(rat.x, rat.y, closestTarget.x, closestTarget.y, (x, y) => {
          const isBlocked = ["ğŸ§±","ğŸ­","ğŸ’","ğŸ—¼"].includes(grid[y][x]);
          const isReviveCenter = (x===centerX && y===centerY);
          const ratOccupied = rats.some(r => r.id !== rat.id && r.x===x && r.y===y);
          return !isBlocked && !isReviveCenter && !ratOccupied;
        });

        if (path && path.length > 0){
          const next = path[0];
          const ratInWay = rats.some(r => r.id !== rat.id && r.x===next.x && r.y===next.y);
          if (!ratInWay){
            rat.x = next.x; rat.y = next.y;
            await updateDoc(ccRef(ID.rat(rat.id)), { x: rat.x, y: rat.y });
          }
        }

        if (rat.x===closestTarget.x && rat.y===closestTarget.y){
          if (closestTarget.type==="structure"){
            await damageStructure(rat.x, rat.y, ratPower);
          } else if (closestTarget.type==="mouse"){
            await updateDoc(ccRef(ID.player(closestTarget.uid)), { alive:false, updatedAt: Date.now() });
            if (closestTarget.uid === uid){
              isAlive = false;
              document.getElementById("status").textContent = "ğŸ’€ You are dead!";
            }
          }
        }
      }
    }

    // cleanup dead rats
    for (let i=rats.length-1; i>=0; i--){
      if ((rats[i].health ?? 0) <= 0){
        await deleteDoc(ccRef(ID.rat(rats[i].id)));
        rats.splice(i,1);
      }
    }
  }

  async function hostMoveOxen(){
    for (let i=oxen.length-1; i>=0; i--){
      const ox = oxen[i];
      if ((ox.health ?? 0) <= 0){
        await deleteDoc(ccRef(ID.ox(ox.id)));
        oxen.splice(i,1);
        continue;
      }

      let bestTarget = null;
      let bestPath = null;

      // prioritize nearest reachable mouse first
      for (const [pu, p] of Object.entries(players)){
        if ((p.alive ?? true) === false) continue;
        const pPath = findPath(ox.x, ox.y, p.x, p.y, false);
        if (pPath && (!bestPath || pPath.length < bestPath.length)){
          bestTarget = { x:p.x, y:p.y, type:"mouse", uid: pu };
          bestPath = pPath;
        }
      }

      // if no mouse path, attack nearest reachable structure (walls included)
      if (!bestTarget){
        const structureTarget = getNearestReachableStructureTarget(ox.x, ox.y, false);
        if (structureTarget){
          bestTarget = { x: structureTarget.x, y: structureTarget.y, type:"structure" };
          bestPath = structureTarget.path;
        }
      }

      if (bestTarget){
        if (bestPath && bestPath.length>0){
          const next = bestPath[0];
          ox.x = next.x; ox.y = next.y;
          await updateDoc(ccRef(ID.ox(ox.id)), { x: ox.x, y: ox.y });
        }

        const dx = Math.abs(ox.x - bestTarget.x);
        const dy = Math.abs(ox.y - bestTarget.y);
        const touching = (dx + dy <= 1);
        if (touching && bestTarget.type === "structure"){
          await damageStructure(bestTarget.x, bestTarget.y, ratPower * 10);
          ox.health -= 1;
          await updateDoc(ccRef(ID.ox(ox.id)), { health: ox.health });
        } else if (touching && bestTarget.type === "mouse"){
          await updateDoc(ccRef(ID.player(bestTarget.uid)), { alive:false, updatedAt: Date.now() });
        }
      }
    }
  }

  async function hostMoveVultures(){
    for (let i=vultures.length-1; i>=0; i--){
      const v = vultures[i];
      if ((v.health ?? 0) <= 0){
        await deleteDoc(ccRef(ID.vulture(v.id)));
        vultures.splice(i,1);
        continue;
      }

      let bestTarget = null;
      let minDist = Infinity;
      for (let y=0; y<gridSize; y++){
        for (let x=0; x<gridSize; x++){
          const symbol = grid[y][x];
          let priority = 99;
          if (symbol === "ğŸ­") priority = 0;
          else if (["ğŸ”«","ğŸª³","ğŸ§±","ğŸ’","ğŸ—¼","ğŸš€","ğŸ¦â€ğŸ”¥"].includes(symbol)) priority = 1;
          if (priority === 99) continue;

          const dist = Math.abs(x-v.x) + Math.abs(y-v.y);
          if (priority < (bestTarget?.priority ?? 99) || (priority === (bestTarget?.priority ?? 99) && dist < minDist)){
            minDist = dist;
            bestTarget = { x, y, priority };
          }
        }
      }
      if (!bestTarget) continue;

      let nx = v.x;
      let ny = v.y;
      if (Math.abs(bestTarget.x - v.x) >= Math.abs(bestTarget.y - v.y)) nx += Math.sign(bestTarget.x - v.x);
      else ny += Math.sign(bestTarget.y - v.y);

      if (nx>=0 && nx<gridSize && ny>=0 && ny<gridSize){
        v.x = nx;
        v.y = ny;
        await updateDoc(ccRef(ID.vulture(v.id)), { x: v.x, y: v.y, updatedAt: Date.now() });
      }

      if (v.x===bestTarget.x && v.y===bestTarget.y){
        await damageStructure(v.x, v.y, ratPower * 4);
      }
    }
  }

  async function hostMoveTermites(){
    for (let i=termites.length-1; i>=0; i--){
      const termite = termites[i];

      let closestWall = null;
      let minDist = Infinity;
      for (let y=0; y<gridSize; y++){
        for (let x=0; x<gridSize; x++){
          if (grid[y][x]==="ğŸ§±" || grid[y][x]==="ğŸ’"){
            const dist = Math.abs(termite.x - x) + Math.abs(termite.y - y);
            if (dist < minDist){
              minDist = dist;
              closestWall = { x, y };
            }
          }
        }
      }
      if (!closestWall) continue;

      const path = findPath(termite.x, termite.y, closestWall.x, closestWall.y, (x,y) => {
        const isTargetWall = (x===closestWall.x && y===closestWall.y);
        if (isTargetWall) return true;
        return !["ğŸ§±","ğŸ”«","ğŸª³","ğŸ­","ğŸ’","ğŸ—¼","ğŸš€"].includes(grid[y][x]);
      });

      if (path && path.length>0){
        const next = path[0];
        termite.x = next.x; termite.y = next.y;
        await updateDoc(ccRef(ID.termite(termite.id)), { x: termite.x, y: termite.y });
      }

      if (termite.x===closestWall.x && termite.y===closestWall.y){
        await damageStructure(termite.x, termite.y, 40);
        await deleteDoc(ccRef(ID.termite(termite.id)));
        termites.splice(i,1);
      }
    }
  }

  async function hostMoveFleas(){
    // Fleas are stored as docs in crowncouncil (both nest fleas + player fleas)
    for (let i=fleas.length-1; i>=0; i--){
      const flea = fleas[i];
      let target = null;
      let minDist = Infinity;

      // target cat
      const distToCat = Math.abs(catPos.x - flea.x) + Math.abs(catPos.y - flea.y);
      if (distToCat < minDist){
        minDist = distToCat;
        target = { x: catPos.x, y: catPos.y, type:"cat" };
      }

      // target rat
      for (const r of rats){
        if ((r.health ?? 0) <= 0) continue;
        const dist = Math.abs(r.x - flea.x) + Math.abs(r.y - flea.y);
        if (dist < minDist){
          minDist = dist;
          target = { x:r.x, y:r.y, type:"rat", rat:r };
        }
      }

      // target ox
      for (const o of oxen){
        if ((o.health ?? 0) <= 0) continue;
        const dist = Math.abs(o.x - flea.x) + Math.abs(o.y - flea.y);
        if (dist < minDist){
          minDist = dist;
          target = { x:o.x, y:o.y, type:"ox", ox:o };
        }
      }

      // move flea
      if (target){
        let dx=0, dy=0;
        const xDiff = target.x - flea.x;
        const yDiff = target.y - flea.y;
        if (Math.abs(xDiff) > Math.abs(yDiff)) dx = Math.sign(xDiff);
        else dy = Math.sign(yDiff);

        const newX = flea.x + dx;
        const newY = flea.y + dy;
        if (newX>=0 && newX<gridSize && newY>=0 && newY<gridSize){
          flea.x = newX; flea.y = newY;
        }

        // attack if reached
        if (flea.x===target.x && flea.y===target.y){
          flea.lifetime = 0;

          if (target.type==="cat"){
            catHealth -= 1;
            await updateDoc(ccRef(ID.STATE), { cat: {x:catPos.x,y:catPos.y,health:catHealth}, updatedAt: Date.now() });
          } else if (target.type==="rat" && target.rat){
            target.rat.health -= 5;
            if (target.rat.health <= 0){
              await deleteDoc(ccRef(ID.rat(target.rat.id)));
            } else {
              await updateDoc(ccRef(ID.rat(target.rat.id)), { health: target.rat.health });
            }
          } else if (target.type==="ox" && target.ox){
            target.ox.health -= 5;
            if (target.ox.health <= 0){
              await deleteDoc(ccRef(ID.ox(target.ox.id)));
            } else {
              await updateDoc(ccRef(ID.ox(target.ox.id)), { health: target.ox.health });
            }
          }
        }
      }

      flea.lifetime = (flea.lifetime ?? 15) - 1;
      if (flea.lifetime <= 0){
        await deleteDoc(ccRef(flea.docId));
        fleas.splice(i,1);
      } else {
        await updateDoc(ccRef(flea.docId), { x: flea.x, y: flea.y, lifetime: flea.lifetime, updatedAt: Date.now() });
      }
    }
  }

  // ============================================================
  // Phoenix revive (host runs; removes Phoenix structure)
  // ============================================================
  async function hostPhoenixRevive(){
    // find phoenix tile in grid
    let phoenixSpot = null;
    for (let y=0; y<gridSize && !phoenixSpot; y++){
      for (let x=0; x<gridSize && !phoenixSpot; x++){
        if (grid[y][x] === "ğŸ¦â€ğŸ”¥") phoenixSpot = {x,y};
      }
    }
    if (!phoenixSpot) return;

    let revived = false;
    for (const [pu, p] of Object.entries(players)){
      if ((p.alive ?? true) === false){
        await updateDoc(ccRef(ID.player(pu)), { alive:true, x: phoenixSpot.x, y: phoenixSpot.y, updatedAt: Date.now() });
        revived = true;
        break;
      }
    }

    if (revived){
      const key = `${phoenixSpot.x}_${phoenixSpot.y}`;
      grid[phoenixSpot.y][phoenixSpot.x] = "";
      delete structureHealth[key];
      await deleteDoc(ccRef(ID.structure(phoenixSpot.x, phoenixSpot.y)));

      const cell = document.getElementById(`cell-${phoenixSpot.x}-${phoenixSpot.y}`);
      if (cell){
        cell.style.backgroundColor = "#ff4d4d";
        setTimeout(()=>cell.style.backgroundColor="#c8f7c5", 300);
      }
      renderGrid();
    }
  }

  // ============================================================
  // Generators payout (client-side for â€œmeâ€ like your original)
  // ============================================================
  async function generatorPayoutTick(){
    for (let y=0; y<gridSize; y++){
      for (let x=0; x<gridSize; x++){
        if (grid[y][x] !== "ğŸ­") continue;

        const cell = document.getElementById(`cell-${x}-${y}`);
        if (cell){
          cell.style.backgroundColor = "#fff977";
          setTimeout(()=>cell.style.backgroundColor="#c8f7c5", 300);
        }

        let bonusCheese = 0;
        for (let dy=-2; dy<=2; dy++){
          for (let dx=-2; dx<=2; dx++){
            const nx = x+dx, ny=y+dy;
            if (nx>=0 && nx<gridSize && ny>=0 && ny<gridSize && grid[ny][nx]==="ğŸ—¼") bonusCheese++;
          }
        }

        // only pay me if I'm nearby and alive (same as your original)
        const me = players[uid];
        if (me && (me.alive ?? true) !== false){
          const dx = Math.abs(me.x - x);
          const dy = Math.abs(me.y - y);
          if (dx + dy <= 9){
            const totalCheese = 1 + bonusCheese;
            cheeseCount += totalCheese;
            document.getElementById("cheeseCount").textContent = cheeseCount;
            await updateDoc(ccRef(ID.player(uid)), { cheese: cheeseCount, updatedAt: Date.now() });
          }
        }
      }
    }
  }

  // ============================================================
  // Wave scheduler (host updates state.nextRatWave)
  // ============================================================
  async function waveSchedulerTick(){
    if (!gameStarted) return;
    const now = Date.now();
    const next = nextRatWaveAt;

    if (isHost && typeof next === "number" && now >= next){
      await spawnRatWave();
      const nextTime = now + 40000;
      nextRatWaveAt = nextTime;
      await updateDoc(ccRef(ID.STATE), { nextRatWave: nextTime, updatedAt: now });
    }

    const secondsLeft = (typeof next === "number") ? Math.max(0, Math.floor((next - now)/1000)) : "?";
    document.getElementById("waveCountdown").textContent = `ğŸ€ Next wave: ${secondsLeft}s`;
  }

  // ============================================================
  // Return to lobby (unchanged paths for /users, allowed by your rules)
  // ============================================================
  async function returnToLobby(){
    const safeUsername = encodeURIComponent(username.trim());

    // award win if cat defeated
    if (catHealth <= 0){
      try{
        const usersSnap = await getDocs(collection(db, "users"));
        let matched = null;

        usersSnap.forEach(docSnap => {
          const data = docSnap.data();
          if ((data.username || "").toLowerCase() === usernameNorm){
            matched = { id: docSnap.id, wins: data.wins || 0 };
          }
        });

        if (matched){
          await updateDoc(doc(db, "users", matched.id), { wins: matched.wins + 1 });
        }
      } catch (err){
        console.error("ğŸ”¥ Error awarding win:", err);
      }
    }

    window.location.href = `/lobby/lobby.html?username=${safeUsername}`;
  }
  window.returnToLobby = returnToLobby;

  // ============================================================
  // Mobile controls
  // ============================================================
  function tryBlink(){
    const event = new KeyboardEvent('keydown', { key: 'b' });
    window.dispatchEvent(event);
  }

  function setupMobileControls(){
    const mobileBuildSelect = document.getElementById("mobileBuildSelect");
    if (mobileBuildSelect){
      const handleBuildSelect = () => {
        if (mobileBuildSelect.value) selectBuild(mobileBuildSelect.value);
      };
      mobileBuildSelect.addEventListener("change", handleBuildSelect);
      mobileBuildSelect.addEventListener("touchend", handleBuildSelect);
    }

    const fsBtn = document.getElementById("fullscreenBtn");
    if (fsBtn){
      fsBtn.addEventListener("click", () => toggleFullscreen());
      fsBtn.addEventListener("touchstart", (e)=>{
        e.preventDefault();
        toggleFullscreen();
      });
    }

    document.querySelectorAll('[data-move]').forEach(btn => {
      btn.addEventListener('click', () => move(btn.getAttribute('data-move')));
      btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        move(btn.getAttribute('data-move'));
      });
    });

    document.querySelectorAll('[data-place]').forEach(btn => {
      btn.addEventListener('click', () => place(btn.getAttribute('data-place')));
      btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        place(btn.getAttribute('data-place'));
      });
    });

    document.querySelectorAll('#structureButtons [data-struct]').forEach(btn => {
      btn.addEventListener('click', () => selectBuild(btn.getAttribute('data-struct')));
      btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        selectBuild(btn.getAttribute('data-struct'));
      });
    });

    const upgradeBtn = document.querySelector('[data-upgrade]');
    if (upgradeBtn){
      upgradeBtn.addEventListener('click', ()=> toggleUpgradeMenu());
      upgradeBtn.addEventListener('touchstart', (e)=>{
        e.preventDefault();
        toggleUpgradeMenu();
      });
    }

    const blinkBtn = document.querySelector('[data-blink]');
    if (blinkBtn){
      blinkBtn.addEventListener('click', ()=> tryBlink());
      blinkBtn.addEventListener('touchstart', (e)=>{
        e.preventDefault();
        tryBlink();
      });
    }

    const trapBtn = document.querySelector('[data-trap]');
    if (trapBtn){
      trapBtn.addEventListener('click', ()=> placeTrap());
      trapBtn.addEventListener('touchstart', (e)=>{
        e.preventDefault();
        placeTrap();
      });
    }
  }

  // ============================================================
  // Listen to crowncouncil docs (this replaces all /games/... listeners)
  // ============================================================
  function listenToCrownCouncil(){
    onSnapshot(ccCol, (snap) => {
      for (const ch of snap.docChanges()){
        const id = ch.doc.id;
        const data = ch.doc.data();

        // removed
        if (ch.type === "removed"){
          if (id === ID.STATE){
            // ignore
          } else if (id.startsWith("player_")){
            delete players[data?.uid || id.replace("player_","")];
          } else if (id.startsWith("structure_")){
            const x = data?.x, y = data?.y;
            if (Number.isInteger(x) && Number.isInteger(y)){
              const key = `${x}_${y}`;
              structures.delete(key);
              delete structureHealth[key];
              if (grid[y] && grid[y][x] && ["ğŸ§±","ğŸ”«","ğŸª³","ğŸ­","ğŸ’","ğŸ—¼","ğŸ¦â€ğŸ”¥","ğŸš€"].includes(grid[y][x])){
                grid[y][x] = "";
              }
            }
          } else if (id.startsWith("trap_")){
            const x = data?.x, y = data?.y;
            traps = traps.filter(t => !(t.x===x && t.y===y));
            if (Number.isInteger(x) && Number.isInteger(y) && grid[y][x] === "ğŸª¤") grid[y][x] = "";
          } else if (id.startsWith("rat_")){
            rats = rats.filter(r => r.id !== data?.id);
          } else if (id.startsWith("ox_")){
            oxen = oxen.filter(o => o.id !== data?.id);
          } else if (id.startsWith("vulture_")){
            const vId = data?.id || id;
            vultures = vultures.filter(v => v.id !== vId);
          } else if (id.startsWith("termite_")){
            termites = termites.filter(t => t.id !== data?.id);
          } else if (id.startsWith("flea_") || id.startsWith("pflea_")){
            fleas = fleas.filter(f => f.docId !== id);
          }
          continue;
        }

        // added / modified
        if (id === ID.STATE){
          const hostUid = data.hostUid;
          const hostName = data.hostName;
          isHost = (hostUid === uid);

          catPower = data.catPower ?? catPower;
          ratPower = data.ratPower ?? ratPower;
          nextRatWaveAt = (typeof data.nextRatWave === "number") ? data.nextRatWave : nextRatWaveAt;

          const cat = data.cat || {};
          catPos = { x: (cat.x ?? catPos.x), y: (cat.y ?? catPos.y) };
          if (typeof cat.health === "number") catHealth = cat.health;

          updateHostDisplay(hostName);
          updateCatHealthBar();
        }
        else if (id.startsWith("player_")){
          // keep players keyed by uid
          const pu = data.uid || id.replace("player_","");
          players[pu] = {
            uid: pu,
            displayName: data.displayName || "mouse",
            x: data.x ?? 1,
            y: data.y ?? 1,
            cheese: data.cheese ?? 0,
            alive: (data.alive !== false)
          };

          // update my local copies from firestore (so multiple tabs stay consistent)
          if (pu === uid){
            playerPos = { x: players[pu].x, y: players[pu].y };
            isAlive = players[pu].alive;
            cheeseCount = players[pu].cheese ?? 0;
            document.getElementById("cheeseCount").textContent = cheeseCount;
            document.getElementById("status").textContent = isAlive ? "" : "ğŸ’€ You are dead!";
          }
        }
        else if (id.startsWith("structure_")){
          const x = data.x, y = data.y;
          if (Number.isInteger(x) && Number.isInteger(y) && data.type){
            const key = `${x}_${y}`;
            structures.set(key, {x,y,type:data.type,health:data.health ?? 1});
            structureHealth[key] = data.health ?? 1;
            grid[y][x] = data.type;
          }
        }
        else if (id.startsWith("trap_")){
          const x = data.x, y = data.y;
          if (Number.isInteger(x) && Number.isInteger(y)){
            traps = traps.filter(t => !(t.x===x && t.y===y));
            traps.push({x,y,placedAt:data.placedAt ?? Date.now()});
            grid[y][x] = "ğŸª¤";
          }
        }
        else if (id.startsWith("rat_")){
          const r = { ...data };
          if (!r.id) r.id = data.id || id;
          const existing = rats.find(rr => rr.id === r.id);
          if (existing) Object.assign(existing, r);
          else rats.push(r);
        }
        else if (id.startsWith("ox_")){
          const o = { ...data };
          if (!o.id) o.id = data.id || id;
          const existing = oxen.find(oo => oo.id === o.id);
          if (existing) Object.assign(existing, o);
          else oxen.push(o);
        }
        else if (id.startsWith("vulture_")){
          const v = { ...data };
          if (!v.id) v.id = data.id || id;
          const existing = vultures.find(vv => vv.id === v.id);
          if (existing) Object.assign(existing, v);
          else vultures.push(v);
        }
        else if (id.startsWith("termite_")){
          const t = { ...data };
          if (!t.id) t.id = data.id || id;
          const existing = termites.find(tt => tt.id === t.id);
          if (existing) Object.assign(existing, t);
          else termites.push(t);
        }
        else if (id.startsWith("flea_") || id.startsWith("pflea_")){
          const f = { ...data };
          f.docId = id;
          if (!f.id) f.id = id;
          const existing = fleas.find(ff => ff.docId === id);
          if (existing) Object.assign(existing, f);
          else fleas.push(f);
        }
      }

      renderGrid();
    });
  }

  // ============================================================
  // Ensure lobby + state doc exist (host selection)
  // ============================================================
  async function ensureLobbyAndState(){
    // lobby doc (your rules allow it)
    await setDoc(lobbyRef, {
      gameType: "catvsmouse",
      updatedAt: Date.now()
    }, { merge:true });

    // state doc inside crowncouncil (your rules allow it)
    await runTransaction(db, async (tx) => {
      const sRef = ccRef(ID.STATE);
      const snap = await tx.get(sRef);

      if (!snap.exists()){
        // first joiner becomes host
        tx.set(sRef, {
          kind: "state",
          hostUid: uid,
          hostName: username,
          cat: { x: gridSize-1, y: gridSize-1, health: 1000 },
          catPower: 0,
          ratPower: 1,
          nextRatWave: Date.now() + 30000,
          createdAt: Date.now(),
          updatedAt: Date.now()
        }, { merge:true });
      }
    });

    // read state once to set isHost early
    const sSnap = await getDoc(ccRef(ID.STATE));
    if (sSnap.exists()){
      const s = sSnap.data();
      isHost = (s.hostUid === uid);
      catPower = s.catPower ?? 0;
      ratPower = s.ratPower ?? 1;
      nextRatWaveAt = (typeof s.nextRatWave === "number") ? s.nextRatWave : nextRatWaveAt;
      const cat = s.cat || {};
      catPos = { x: cat.x ?? catPos.x, y: cat.y ?? catPos.y };
      catHealth = (typeof cat.health === "number") ? cat.health : catHealth;
      updateHostDisplay(s.hostName);
      updateCatHealthBar();
    }
  }

  // ============================================================
  // Keyboard input (kept with your behavior)
  // ============================================================
  window.addEventListener("keydown", async (e) => {
    if (!isAlive) return;

    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)) e.preventDefault();

    if (e.key === " "){
      toggleUpgradeMenu();
      return;
    }

    if (upgradeMenuOpen && ["1","2","3","4","5","6"].includes(e.key) && advancementPoints > 0){
      selectUpgrade(e.key);
      return;
    }

    // movement
    if (canMove){
      switch (e.key){
        case "ArrowUp":    lastDirection={dx:0,dy:-1}; movePlayer(0,-1); triggerMoveCooldown(); break;
        case "ArrowDown":  lastDirection={dx:0,dy:1};  movePlayer(0,1);  triggerMoveCooldown(); break;
        case "ArrowLeft":  lastDirection={dx:-1,dy:0}; movePlayer(-1,0); triggerMoveCooldown(); break;
        case "ArrowRight": lastDirection={dx:1,dy:0};  movePlayer(1,0);  triggerMoveCooldown(); break;
      }
    }

    // blink
    if (blinkActive && e.key.toLowerCase() === "b"){
      const now = Date.now();
      if (now - lastBlinkTime >= 8000){
        const dx = lastDirection.dx;
        const dy = lastDirection.dy;
        const nx = playerPos.x + dx * 5;
        const ny = playerPos.y + dy * 5;

        if (nx>=0 && nx<gridSize && ny>=0 && ny<gridSize && grid[ny][nx] === ""){
          playerPos = { x:nx, y:ny };
          lastBlinkTime = now;
          await savePosition();
          renderGrid();
          const cell = document.getElementById(`cell-${nx}-${ny}`);
          if (cell){
            cell.style.backgroundColor = "#b3f0ff";
            setTimeout(()=>cell.style.backgroundColor="#c8f7c5", 300);
          }
        }
      }
    }

    if (trapmasterActive && e.key.toLowerCase() === "t"){
      await placeTrap();
    }

    if (!upgradeMenuOpen && ["1","2","3","4","5","6","7","8"].includes(e.key)){
      selectBuild(e.key);
    }

    if (["w","a","s","d"].includes(e.key)){
      await placeStructure(e.key);
    }
  });

  // ============================================================
  // Global loops (kept gameplay)
  // ============================================================
  function startGlobalLoops(){
    // mobile setup
    const mobileLike = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || window.matchMedia("(max-width: 768px)").matches;
    if (mobileLike){
      document.getElementById("mobileControls").style.display = "block";
      document.getElementById("fullscreenBtn").style.display = "inline-block";
      renderMobileUpgradeButtons();
      setupMobileControls();
    }

    // initial placements (local only, same as your original)
    grid[24][15] = "ğŸ§±";
    grid[25][14] = "ğŸ§±";
    grid[25][16] = "ğŸ§±";
    renderGrid();

    // cheese spawn (local only, same as your original)
    setInterval(spawnCheese, 10000);

    // ability cooldown UI
    setInterval(updateAbilityStatus, 1000);

    // adv point every 3 mins
    setInterval(() => {
      if (!gameStarted || !isAlive) return;
      advancementPoints++;
      document.getElementById("advPoints").textContent = advancementPoints;

      const msg = document.getElementById("advPointMessage");
      msg.textContent = "ğŸŸ¢ You gained an advancement point!";
      msg.style.display = "block";
      setTimeout(()=>msg.style.display="none", 2500);
    }, 180000);

    // player flea master spawns near player (local list; host will move if these are synced)
    setInterval(() => {
      if (!fleaMasterActive || !isAlive) return;

      // spawn up to 2 â€œplayer fleasâ€ near player
      const offsets = [{dx:0,dy:0},{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
      let spawned = 0;

      for (const o of offsets){
        const fx = playerPos.x + o.dx;
        const fy = playerPos.y + o.dy;
        if (fx<0||fy<0||fx>=gridSize||fy>=gridSize) continue;

        // prevent overlap
        if (fleas.some(f => f.x===fx && f.y===fy && f.ownerUid===uid && f.origin==="player")) continue;

        fleas.push({
          docId: ID.pflea(uid, Date.now()+spawned),
          x: fx,
          y: fy,
          lifetime: 15,
          ownerUid: uid,
          origin: "player"
        });

        spawned++;
        if (spawned >= 2) break;
      }
      renderGrid();
    }, fleaSpawnCooldown);

    // keep player fleas synced if active (like your original)
    setInterval(() => {
      if (fleaMasterActive && isAlive){
        syncMyFleas().catch(()=>{});
      }
    }, 1200);

    // generator payout
    setInterval(() => { if (gameStarted) generatorPayoutTick(); }, 15000);

    // game over check
    setInterval(() => {
      if (!gameStarted) return;

      const anyAlive = Object.values(players).some(p => (p.alive ?? true) !== false);

      let phoenixExists = false;
      for (let y=0; y<gridSize && !phoenixExists; y++){
        for (let x=0; x<gridSize && !phoenixExists; x++){
          if (grid[y][x] === "ğŸ¦â€ğŸ”¥") phoenixExists = true;
        }
      }

      if (!anyAlive && !phoenixExists){
        const st = document.getElementById("status");
        st.textContent = "ğŸ’€ All mice are dead. Game Over!";
        document.getElementById("returnButton").style.display = "block";
        st.style.color = "red";
        st.style.fontSize = "24px";
        st.style.fontWeight = "bold";
        st.style.background = "#fff0f0";
        st.style.padding = "10px";
        st.style.border = "2px solid red";
        st.style.marginTop = "10px";
        gameStarted = false;
      }
    }, 1000);

    // wave countdown + host wave scheduling
    setInterval(() => { waveSchedulerTick().catch(()=>{}); }, 1000);
  }

  // ============================================================
  // Host loops (cat AI + spawns + enemy sim)
  // ============================================================
  function startHostLoops(){
    if (!isHost || hostInitialized) return;
    hostInitialized = true;

    gameStarted = true;
    startCatBehaviorLoop();

    // power ramp
    setInterval(async () => {
      if (!gameStarted) return;

      catPower++;
      const playerCount = Object.keys(players).length;
      catHealth += 15 * playerCount;

      await updateDoc(ccRef(ID.STATE), {
        catPower,
        cat: { x: catPos.x, y: catPos.y, health: catHealth },
        updatedAt: Date.now()
      });

      startCatBehaviorLoop();
    }, 20000);

    // turret + rocket
    setInterval(() => turretAttack().catch(()=>{}), 1500);
    setInterval(() => rocketTowerAttack().catch(()=>{}), 3500);

    // rat power ramp
    setInterval(async () => {
      ratPower++;
      await updateDoc(ccRef(ID.STATE), { ratPower, updatedAt: Date.now() });
    }, 120000);

    // flea nests spawn fleas (now actually writes them, so everyone sees)
    setInterval(async () => {
      // count nests and spawn fleas in Firestore
      for (let y=0; y<gridSize; y++){
        for (let x=0; x<gridSize; x++){
          if (grid[y][x] !== "ğŸª³") continue;

          let beaconBonus = 0;
          for (let dy=-2; dy<=2; dy++){
            for (let dx=-2; dx<=2; dx++){
              const nx = x+dx, ny=y+dy;
              if (nx>=0&&nx<gridSize&&ny>=0&&ny<gridSize && grid[ny][nx]==="ğŸ—¼") beaconBonus++;
            }
          }
          const spawnCount = 1 + beaconBonus;

          const offsets = [
            {dx:0,dy:0},{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1},
            {dx:1,dy:1},{dx:-1,dy:-1},{dx:1,dy:-1},{dx:-1,dy:1}
          ];

          for (let i=0; i<spawnCount; i++){
            const off = offsets[Math.floor(Math.random()*offsets.length)];
            const fx = x + off.dx;
            const fy = y + off.dy;
            if (fx<0||fy<0||fx>=gridSize||fy>=gridSize) continue;

            const fid = `nest_${crypto.randomUUID()}`;
            await setDoc(ccRef(ID.flea(fid)), {
              kind: "flea",
              id: fid,
              x: fx, y: fy,
              lifetime: 15,
              origin: "nest",
              createdAt: Date.now()
            }, { merge:true });
          }
        }
      }
    }, 4000);

    // wall master heal (runs host-side; writes structure hp)
    setInterval(async () => {
      // apply to all players who have wall master? (kept close to your behavior: only local player toggles)
      // Since upgrades are local-only in your original, we keep it local-only:
      // host will not try to â€œguessâ€ who has wall master. We keep your original behavior by letting
      // each client do their own wall heal writes if they have it.
    }, 1000);

    // termites spawn center
    setInterval(async () => {
      if (!gameStarted || catPower <= 0) return;

      const centerX = Math.floor(gridSize/2);
      const centerY = Math.floor(gridSize/2);
      const numToSpawn = Math.ceil(catPower/2);

      const offsets = [
        {x:0,y:0},{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1},
        {x:1,y:1},{x:-1,y:-1},{x:1,y:-1},{x:-1,y:1}
      ];

      let spawned = 0;
      for (let i=0; i<offsets.length && spawned<numToSpawn; i++){
        const ox = centerX + offsets[i].x;
        const oy = centerY + offsets[i].y;
        if (ox<0||oy<0||ox>=gridSize||oy>=gridSize) continue;
        if (termites.some(t => t.x===ox && t.y===oy)) continue;

        const id = `termite_${Date.now()}_${i}`;
        await setDoc(ccRef(ID.termite(id)), {
          kind: "termite",
          id,
          x: ox,
          y: oy,
          createdAt: Date.now()
        }, { merge:true });
        spawned++;
      }
    }, 60000);

    // late game vultures (after oxen phase)
    setInterval(async () => {
      if (!gameStarted || catPower < 25) return;
      const desired = Math.min(6, 1 + Math.floor((catPower - 25) / 6));
      const living = vultures.filter(v => (v.health ?? 0) > 0).length;
      const toSpawn = Math.max(0, desired - living);
      if (toSpawn <= 0) return;

      for (let i=0; i<toSpawn; i++){
        const vx = Math.max(0, Math.min(gridSize-1, catPos.x + (Math.floor(Math.random()*7)-3)));
        const vy = Math.max(0, Math.min(gridSize-1, catPos.y + (Math.floor(Math.random()*7)-3)));
        const id = `vulture_${crypto.randomUUID()}`;
        await setDoc(ccRef(ID.vulture(id)), {
          kind: "vulture",
          id,
          x: vx,
          y: vy,
          health: ratPower * 20,
          createdAt: Date.now()
        }, { merge:true });
      }
    }, 8000);

    // enemy sim ticks
    setInterval(() => hostMoveRats().catch(()=>{}), 400);
    setInterval(() => hostMoveOxen().catch(()=>{}), 800);
    setInterval(() => hostMoveVultures().catch(()=>{}), 600);
    setInterval(() => hostMoveTermites().catch(()=>{}), 400);
    setInterval(() => hostMoveFleas().catch(()=>{}), 400);

    // phoenix revive
    setInterval(() => hostPhoenixRevive().catch(()=>{}), 2000);

    // keep cat health synced (state already updated often; this keeps it in case)
    setInterval(async () => {
      if (!gameStarted) return;
      await updateDoc(ccRef(ID.STATE), { cat: {x:catPos.x,y:catPos.y,health:catHealth}, updatedAt: Date.now() });
    }, 3000);
  }

  // ============================================================
  // Client-only wall master healing (kept from your original)
  // ============================================================
  setInterval(async () => {
    if (!wallMasterActive || !isAlive) return;

    for (let dy=-1; dy<=1; dy++){
      for (let dx=-1; dx<=1; dx++){
        const tx = playerPos.x + dx;
        const ty = playerPos.y + dy;
        if (tx<0||ty<0||tx>=gridSize||ty>=gridSize) continue;

        const key = `${tx}_${ty}`;
        if ((grid[ty][tx]==="ğŸ§±" || grid[ty][tx]==="ğŸ’") && (structureHealth[key] ?? 0) < 80){
          structureHealth[key] = (structureHealth[key] ?? 0) + 4;
          await updateDoc(ccRef(ID.structure(tx,ty)), { health: structureHealth[key] });
        }
      }
    }
  }, 1000);

  // ============================================================
  // Boot
  // ============================================================
  await ensureLobbyAndState();
  await upsertMyPlayerDoc();
  listenToCrownCouncil();

  // start game
  gameStarted = true;
  startGlobalLoops();

  // start host loops if host
  startHostLoops();

</script>
</body>
</html>

