<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>‚öîÔ∏è Rock Duel</title>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<style>
  :root{
    --ink:#0f172a; --muted:#6b7280; --br:#e5e7eb; --card:#fff; --shadow:0 10px 30px rgba(15,23,42,.08);
    --good:#16a34a; --bad:#ef4444; --accent:#111827;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Arial;color:var(--ink);background:#fafafa;}
  button{font-family:inherit; cursor:pointer}

  .wrap{min-height:100vh;display:grid;grid-template-rows:auto 1fr auto}
  .top{
    position:sticky; top:0; z-index:5; background:#fff; border-bottom:1px solid var(--br);
    display:flex; align-items:center; justify-content:space-between; gap:10px; padding:8px 10px;
  }
  .hp{display:flex;align-items:center;gap:8px;border:1px solid var(--br);background:#fff;padding:8px 12px;border-radius:12px}
  .hpbar{position:relative;width:140px;height:10px;background:#f3f4f6;border-radius:999px;overflow:hidden;border:1px solid var(--br)}
  .hpbar>i{display:block;height:100%;width:100%;background:linear-gradient(90deg,#22c55e,#84cc16)}
  .tag{font-weight:900}
  .timer{font-weight:900}
  .statusPanel{display:flex;gap:8px;flex-wrap:wrap}
  .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border:1px solid var(--br);border-radius:999px;background:#fff;font-size:12px}

  /* Arena with raised, above-sprites center text */
  .arena{ position:relative; display:grid; place-items:center; padding:12px; overflow:hidden; min-height:260px; }
  .row{display:flex; gap:8px; align-items:center; justify-content:center; flex-wrap:wrap}
  .centerText{
    position:absolute; left:50%; top:32%; transform:translate(-50%,-50%);
    font-weight:900; font-size:20px; text-align:center; min-height:40px;
    z-index:5; pointer-events:none;
  }

  .hand{
    position:sticky; bottom:0; background:#fff;border-top:1px solid var(--br);
    padding:8px; display:flex; align-items:center; justify-content:center; gap:8px; flex-wrap:wrap
  }
  .card{
    width:110px; height:150px; border:2px solid var(--br); border-radius:14px; background:#fff; box-shadow:var(--shadow);
    display:flex; flex-direction:column; align-items:center; justify-content:center; gap:8px; padding:10px;
  }
  .card.small{ width:88px; height:120px; }
  .card b{ font-size:14px; text-align:center }
  .card small{ color:var(--muted); text-align:center }
  .choose{ border-color:#111827 }
  .disabled{ opacity:.5; pointer-events:none }

  .sprite{
    width:120px;height:120px;border-radius:16px;border:2px solid var(--br);display:grid;place-items:center;background:#fff;box-shadow:var(--shadow);
    position:absolute;top:50%;transform:translateY(-50%);
    z-index:1; /* keep sprites under the center text */
  }
  .spriteL{ left:-140px }
  .spriteR{ right:-140px }
  .runL{ animation:runL .9s forwards }
  .runR{ animation:runR .9s forwards }
  .fade{ animation:fade .7s forwards }

  @keyframes runL{ to{ left:calc(50% - 130px) } }
  @keyframes runR{ to{ right:calc(50% - 130px) } }
  @keyframes fade{ to{ opacity:0 } }

  @media (max-width:680px){
    .hpbar{ width:110px }
    .card{ width:92px; height:124px }
    .card.small{ width:80px; height:110px }
    .sprite{ width:96px;height:96px }
    .centerText{ font-size:18px; top:28%; }
  }
</style>
</head>
<body>
<div class="wrap">
  <!-- TOP -->
  <div class="top">
    <div class="hp">
      <span class="tag" id="oppTag">Opponent</span>
      <div class="hpbar"><i id="ohpFill" style="width:100%"></i></div>
      <span id="ohpLbl">0/0</span>
    </div>
    <div class="statusPanel">
      <span class="pill">‚è±Ô∏è <span id="timer">15</span>s</span>
      <span class="pill" id="blkRock" style="display:none">üö´ Rock (2)</span>
      <span class="pill" id="blkPaper" style="display:none">üö´ Paper (2)</span>
      <span class="pill" id="blkScissors" style="display:none">üö´ Scissors (2)</span>
      <span class="pill" id="handBoostSelf" style="display:none">üÉè Your Hand +1 (2)</span>
      <span class="pill" id="handBoostOpp" style="display:none">üÉè Their Hand +1 (2)</span>
    </div>
    <div class="hp">
      <span class="tag">You</span>
      <div class="hpbar"><i id="phpFill" style="width:100%"></i></div>
      <span id="phpLbl">0/0</span>
    </div>
  </div>

  <!-- ARENA -->
  <div class="arena" id="arena">
    <div id="center" class="centerText">Waiting for duel‚Ä¶</div>
  </div>

  <!-- HAND -->
  <div class="hand">
    <div class="row" id="handRow"></div>
  </div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import {
    getFirestore, doc, getDoc, setDoc, updateDoc, runTransaction, onSnapshot, serverTimestamp
  } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

  // ---------- Firebase ----------
  const firebaseConfig = {
    apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
    authDomain: "bible-game-246c0.firebaseapp.com",
    projectId: "bible-game-246c0",
    storageBucket: "bible-game-246c0.appspot.com",
    messagingSenderId: "959619818996",
    appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // ---------- Params ----------
  const qs = new URLSearchParams(location.search);
  const duelId = qs.get("duel") || "";
  const username = qs.get("username") || localStorage.getItem("gh.username") || "";
  if (!duelId || !username){
    alert("Missing duel or username.");
    location.href = "/game/rock.html" + (username?`?username=${encodeURIComponent(username)}`:"");
  }
  const duelRef = doc(db,"duels",duelId);

  // ---------- UI refs ----------
  const center = document.getElementById("center");
  const ohpLbl = document.getElementById("ohpLbl");
  const ohpFill = document.getElementById("ohpFill");
  const phpLbl = document.getElementById("phpLbl");
  const phpFill = document.getElementById("phpFill");
  const timerEl = document.getElementById("timer");
  const handRow = document.getElementById("handRow");
  const arena = document.getElementById("arena");
  const oppTag = document.getElementById("oppTag");
  const blkRock = document.getElementById("blkRock");
  const blkPaper = document.getElementById("blkPaper");
  const blkScissors = document.getElementById("blkScissors");
  const handBoostSelf = document.getElementById("handBoostSelf");
  const handBoostOpp = document.getElementById("handBoostOpp");

  // ---------- Rules ----------
  const NON_ATTACK = new Set(["effect-reveal","effect-draw","block-rock","block-paper","block-scissors"]);
  const EMOJI = {
    rock:"ü™®", paper:"üìÑ", scissors:"‚úÇÔ∏è",
    crystal:"üíé", diamond:"üî∑", match:"üß®", water:"üíß", slime:"üü¢", dark:"üåë",
    "effect-reveal":"üëÅÔ∏è", "effect-draw":"üÉè",
    "block-rock":"‚õîü™®", "block-paper":"‚õîüìÑ", "block-scissors":"‚õî‚úÇÔ∏è"
  };
  const NAME = {
    rock:"Rock", paper:"Paper", scissors:"Scissors",
    crystal:"Crystal", diamond:"Diamond", match:"Match", water:"Water", slime:"Slime", dark:"Dark Matter",
    "effect-reveal":"Reveal", "effect-draw":"Draw",
    "block-rock":"Block Rock", "block-paper":"Block Paper", "block-scissors":"Block Scissors"
  };
  function compareTypes(a,b){
    if (a===b) return 0;
    const base = { rock:{scissors:1,paper:-1}, paper:{rock:1,scissors:-1}, scissors:{paper:1,rock:-1} };
    if (base[a]?.[b]!==undefined) return base[a][b];
    if (base[b]?.[a]!==undefined) return -base[b][a];
    if (a==="crystal"){ if (b==="rock"||b==="scissors") return 1; if (b==="paper") return -1; }
    if (b==="crystal"){ if (a==="rock"||a==="scissors") return -1; if (a==="paper") return 1; }
    if (a==="diamond"){ if (["crystal","rock","scissors"].includes(b)) return 1; if (b==="paper") return -1; }
    if (b==="diamond"){ if (["crystal","rock","scissors"].includes(a)) return -1; if (a==="paper") return 1; }
    if (a==="match"){ if (["paper","scissors"].includes(b)) return 1; if (["crystal","diamond","rock"].includes(b)) return -1; }
    if (b==="match"){ if (["paper","scissors"].includes(a)) return -1; if (["crystal","diamond","rock"].includes(a)) return 1; }
    if (a==="water"){ if (["rock","paper","match"].includes(b)) return 1; if (["crystal","diamond","scissors"].includes(b)) return -1; }
    if (b==="water"){ if (["rock","paper","match"].includes(a)) return -1; if (["crystal","diamond","scissors"].includes(a)) return 1; }
    if (a==="slime"){ if (["rock","crystal","diamond","match","paper"].includes(b)) return 1; if (["scissors","water"].includes(b)) return -1; }
    if (b==="slime"){ if (["rock","crystal","diamond","match","paper"].includes(a)) return -1; if (["scissors","water"].includes(a)) return 1; }
    if (a==="dark"){ if (b==="rock") return -1; return 1; }
    if (b==="dark"){ if (a==="rock") return 1; return -1; }
    return 0;
  }

  // ---------- Helpers ----------
  function normalizeNameToType(n){
    const m = String(n||"").toLowerCase();
    if (m.includes("block") && m.includes("rock")) return "block-rock";
    if (m.includes("block") && m.includes("paper")) return "block-paper";
    if (m.includes("block") && m.includes("scissors")) return "block-scissors";
    if (m.includes("reveal")) return "effect-reveal";
    if (m.includes("draw")) return "effect-draw";
    if (m.includes("crystal")) return "crystal";
    if (m.includes("diamond")) return "diamond";
    if (m.includes("match")) return "match";
    if (m.includes("water")) return "water";
    if (m.includes("slime")) return "slime";
    if (m.includes("dark")) return "dark";
    if (m.includes("rock")) return "rock";
    if (m.includes("paper")) return "paper";
    if (m.includes("scissors")) return "scissors";
    return "rock";
  }
  function shuffle(a){ for(let i=a.length-1;i>0;i++){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function drawToHand(hand, deck, discard, n){
    for(let i=0;i<n;i++){
      if (deck.length===0) reshuffle(deck, discard);
      if (deck.length===0) break;
      hand.push(deck.pop());
    }
  }
  function reshuffle(deck, discard){
    if (!discard) return;
    while(discard.length) deck.push(discard.pop());
    shuffle(deck);
  }
  function baseInventory(){
    return [
      {name:"Rock"},{name:"Rock"},{name:"Rock"},
      {name:"Paper"},{name:"Paper"},{name:"Paper"},
      {name:"Scissors"},{name:"Scissors"},{name:"Scissors"}
    ];
  }
  function wait(ms){ return new Promise(r=> setTimeout(r, ms)); }

  // defeat helpers (same as PvE additions)
  function removeRandomCards(inv, count){
    const res = Array.isArray(inv) ? [...inv] : [];
    if (res.length <= 2 || count <= 0) return res;
    const n = Math.min(count, res.length);
    for (let i = 0; i < n; i++){
      const idx = Math.floor(Math.random() * res.length);
      res.splice(idx, 1);
    }
    return res;
  }

  // ---------- Local state ----------
  let meSide = "a"; // or "b"
  let meName = username;
  let oppName = "";
  let unsub = null;
  let lastShownTurn = -1; // prevent spamming center on repeats

  function setCenter(msg){ center.innerHTML = msg; }
  function cardHTML(card, i, disabled=false){
    const type = card.type;
    const e = EMOJI[type] || "‚ùî";
    const n = NAME[type] || type;
    return `<button class="card ${window.innerWidth<680?"small":""} ${disabled?"disabled":""}" data-idx="${i}">
      <div style="font-size:26px">${e}</div>
      <b>${n}</b>
      <small>${NON_ATTACK.has(type)?"Utility":"Attack"}</small>
    </button>`;
  }

  // ---------- Subscribe + bootstrap ----------
  const duelSnap = await getDoc(duelRef);
  if (!duelSnap.exists()){
    alert("Duel not found.");
    backToWorld();
  }
  let duel = duelSnap.data();

  // decide side
  if (duel.a === username) { meSide = "a"; oppName = duel.b; }
  else if (duel.b === username) { meSide = "b"; oppName = duel.a; }
  else {
    alert("You are not a participant in this duel.");
    backToWorld();
  }
  oppTag.textContent = oppName || "Opponent";

  // Initialize duel if needed (only side A initializes)
  if (!duel.state){
    if (meSide==="a"){
      await initDuelAsA();
    }
  }

  // Live updates
  unsub = onSnapshot(duelRef, (snap)=>{
    if (!snap.exists()) return;
    duel = snap.data();
    renderAll();
  });

  // ---------- Initialization (side A) ----------
  async function initDuelAsA(){
    await runTransaction(db, async (tx)=>{
      const snap = await tx.get(duelRef);
      const d = snap.data() || {};
      if (d.state) return; // already initialized

      const aDoc = await tx.get(doc(db,"players", d.a));
      const bDoc = await tx.get(doc(db,"players", d.b));
      if (!aDoc.exists() || !bDoc.exists()) throw new Error("Players missing");

      const a = aDoc.data(), b = bDoc.data();
      const aMax = 3 + (a.level||1);
      const bMax = 3 + (b.level||1);

      const aDeck = shuffle((a.inventory || baseInventory()).map(c=> ({type: c.type || normalizeNameToType(c.name)})));
      const bDeck = shuffle((b.inventory || baseInventory()).map(c=> ({type: c.type || normalizeNameToType(c.name)})));

      const aHand=[], bHand=[], aDiscard=[], bDiscard=[];
      drawToHand(aHand,aDeck,aDiscard,3);
      drawToHand(bHand,bDeck,bDiscard,3);

      const init = {
        state: "active",
        turn: 1,
        aHP: aMax, aMax: aMax,
        bHP: bMax, bMax: bMax,
        aDeck, bDeck, aHand, bHand, aDiscard, bDiscard,
        blocks: {rock:0,paper:0,scissors:0},
        aHandBoost: 0, bHandBoost: 0,
        aPick: null, bPick: null,
        timerStart: serverTimestamp(),
        lastClash: null,
        revealFor: "", revealTurn: 0,
        winner: "",
        a: d.a, b: d.b
      };
      tx.set(duelRef, {...d, ...init});
    });
  }

  // ---------- Render ----------
  function renderAll(){
    if (!duel || !duel.state) return;

    const meHP = meSide==="a" ? duel.aHP : duel.bHP;
    const meMax = meSide==="a" ? duel.aMax : duel.bMax;
    const opHP = meSide==="a" ? duel.bHP : duel.aHP;
    const opMax = meSide==="a" ? duel.bMax : duel.aMax;

    phpLbl.textContent = `${meHP}/${meMax}`;
    phpFill.style.width = Math.max(0, Math.round((meHP/meMax)*100))+"%";
    ohpLbl.textContent = `${opHP}/${opMax}`;
    ohpFill.style.width = Math.max(0, Math.round((opHP/opMax)*100))+"%";

    // timer
    const startMs = duel.timerStart?.toMillis ? duel.timerStart.toMillis() : Date.now();
    const remain = Math.max(0, 15 - Math.floor((Date.now() - startMs)/1000));
    timerEl.textContent = ""+remain;

    // status
    blkRock.style.display = duel.blocks?.rock>0 ? "inline-flex":"none";
    blkPaper.style.display = duel.blocks?.paper>0 ? "inline-flex":"none";
    blkScissors.style.display = duel.blocks?.scissors>0 ? "inline-flex":"none";
    if (duel.blocks?.rock>0) blkRock.textContent = `üö´ Rock (${duel.blocks.rock})`;
    if (duel.blocks?.paper>0) blkPaper.textContent = `üö´ Paper (${duel.blocks.paper})`;
    if (duel.blocks?.scissors>0) blkScissors.textContent = `üö´ Scissors (${duel.blocks.scissors})`;

    handBoostSelf.style.display = (meSide==="a" ? duel.aHandBoost : duel.bHandBoost)>0 ? "inline-flex":"none";
    handBoostOpp.style.display = (meSide==="a" ? duel.bHandBoost : duel.aHandBoost)>0 ? "inline-flex":"none";
    if (meSide==="a"){
      if (duel.aHandBoost>0) handBoostSelf.textContent = `üÉè Your Hand +1 (${duel.aHandBoost})`;
      if (duel.bHandBoost>0) handBoostOpp.textContent = `üÉè Their Hand +1 (${duel.bHandBoost})`;
    } else {
      if (duel.bHandBoost>0) handBoostSelf.textContent = `üÉè Your Hand +1 (${duel.bHandBoost})`;
      if (duel.aHandBoost>0) handBoostOpp.textContent = `üÉè Their Hand +1 (${duel.aHandBoost})`;
    }

    // hand
    const myHand = meSide==="a" ? duel.aHand : duel.bHand;
    renderHand(myHand, remain===0);

    // reveal message (same-turn only; purely cosmetic)
    if (duel.revealTurn === duel.turn && duel.revealFor && lastShownTurn !== duel.turn){
      const showOpp = meSide==="a" ? (duel.revealFor==="a") : (duel.revealFor==="b");
      const list = showOpp ? (meSide==="a" ? duel.bHand : duel.aHand) : (meSide==="a" ? duel.aHand : duel.bHand);
      if (Array.isArray(list)){
        const txt = list.map(c=> (EMOJI[c.type]||"‚ùî")+" "+(NAME[c.type]||c.type)).join(" ¬∑ ");
        setCenter(`üëÅÔ∏è Reveal ‚Äî ${showOpp ? "Enemy hand" : "Your hand"}: ${txt}`);
        lastShownTurn = duel.turn;
      }
    }

    // end state checks
    if (duel.state==="over"){
      if (duel.winner === username){
        setCenter("üèÜ You won!");
        setTimeout(()=> backToWorld(), 1000);
      } else if (!duel.winner){
        setCenter("ü§ù Draw.");
        setTimeout(()=> backToWorld(), 1000);
      }
      // If you lost, we don't redirect here; onPlayerDefeat() below handles the message + redirect.
      return;
    }

    const myPick = meSide==="a" ? duel.aPick : duel.bPick;
    const opPick = meSide==="a" ? duel.bPick : duel.aPick;

    if (remain===0 && (!myPick || !opPick)){
      resolveTurnTxn();
    }
    if (myPick && opPick){
      resolveTurnTxn();
    }
  }

  function renderHand(hand, disable){
    handRow.innerHTML = hand.map((c,i)=> cardHTML(c,i, disable)).join("");
    handRow.querySelectorAll(".card").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const idx = +btn.getAttribute("data-idx");
        submitPick(idx);
      });
    });
  }

  async function submitPick(idx){
    try{
      await runTransaction(db, async (tx)=>{
        const snap = await tx.get(duelRef);
        const d = snap.data();
        if (!d || d.state!=="active") return;
        const myHand = meSide==="a" ? d.aHand : d.bHand;
        if (!myHand || !myHand[idx]) return;
        if (meSide==="a"){
          if (d.aPick) return;
          tx.update(duelRef, { aPick: { idx, type: myHand[idx].type } });
        } else {
          if (d.bPick) return;
          tx.update(duelRef, { bPick: { idx, type: myHand[idx].type } });
        }
      });
    }catch(e){ console.error(e); }
  }

  // ---------- Resolve turn ----------
  async function resolveTurnTxn(){
    try{
      await runTransaction(db, async (tx)=>{
        const snap = await tx.get(duelRef);
        const d = snap.data();
        if (!d || d.state!=="active") return;

        const started = d.timerStart?.toMillis ? d.timerStart.toMillis() : Date.now();
        const expired = (Date.now() - started) >= 15000;

        let aPick = d.aPick, bPick = d.bPick;
        if (!aPick && expired && d.aHand?.length){
          const idx = Math.floor(Math.random()*d.aHand.length);
          aPick = { idx, type: d.aHand[idx].type };
        }
        if (!bPick && expired && d.bHand?.length){
          const idx = Math.floor(Math.random()*d.bHand.length);
          bPick = { idx, type: d.bHand[idx].type };
        }
        if (!aPick || !bPick) return;

        const state = JSON.parse(JSON.stringify(d));

        // pull cards
        const aCard = state.aHand.splice(aPick.idx,1)[0];
        const bCard = state.bHand.splice(bPick.idx,1)[0];
        if (!aCard || !bCard) return;

        state.lastClash = { a: aCard.type, b: bCard.type, turn: state.turn, ts: Date.now() };

        applyUtility(state, "a", aCard);
        applyUtility(state, "b", bCard);

        // blocked?
        const isBlocked = (t, blocks)=> (t==="rock" && blocks.rock>0) || (t==="paper" && blocks.paper>0) || (t==="scissors" && blocks.scissors>0);
        const aAtk = !NON_ATTACK.has(aCard.type) && !isBlocked(aCard.type, state.blocks);
        const bAtk = !NON_ATTACK.has(bCard.type) && !isBlocked(bCard.type, state.blocks);

        // damage resolution
        if (!aAtk && bAtk){
          state.aHP = Math.max(0, state.aHP - 1);
        } else if (!bAtk && aAtk){
          state.bHP = Math.max(0, state.bHP - 1);
        } else if (aAtk && bAtk){
          const cmp = compareTypes(aCard.type, bCard.type);
          if (cmp>0) state.bHP = Math.max(0, state.bHP - 1);
          else if (cmp<0) state.aHP = Math.max(0, state.aHP - 1);
        }

        state.aDiscard.push(aCard);
        state.bDiscard.push(bCard);

        const aMaxHand = (state.aHandBoost>0) ? 4 : 3;
        const bMaxHand = (state.bHandBoost>0) ? 4 : 3;
        drawToHand(state.aHand, state.aDeck, state.aDiscard, aMaxHand - state.aHand.length);
        drawToHand(state.bHand, state.bDeck, state.bDiscard, bMaxHand - state.bHand.length);

        ["rock","paper","scissors"].forEach(k=>{ if (state.blocks[k]>0) state.blocks[k]--; });
        if (state.aHandBoost>0) state.aHandBoost--;
        if (state.bHandBoost>0) state.bHandBoost--;

        if (state.aHP<=0 || state.bHP<=0){
          state.state = "over";
          state.winner = state.aHP>0 ? state.a : (state.bHP>0 ? state.b : "");
        } else {
          state.turn = (state.turn||1) + 1;
          state.aPick = null; state.bPick = null;
          state.timerStart = serverTimestamp();
          // clear reveal for older turns
          state.revealFor = state.revealFor || "";
          state.revealTurn = state.revealTurn || 0;
        }

        tx.update(duelRef, state);
      });

      // post-apply animation and possible defeat penalty
      const post = await getDoc(duelRef);
      const st = post.data();
      if (!st) return;

      // Clash text + sprites
      showClash(st.lastClash?.a, st.lastClash?.b);

      if (st.state==="over"){
        if (st.winner && st.winner !== username){
          const res = await onPlayerDefeat(username); // apply PvE-style defeat penalty
          setCenter(`üíÄ Defeat ‚Äî Level set to ${res.newLevel}${res.lost ? ` ¬∑ lost ${res.lost} card${res.lost>1?'s':''}` : ''}. Returning‚Ä¶`);
          setTimeout(()=> backToWorld(), 1200);
        }
        // if winner==you or draw, renderAll() already handles redirect
      }
    }catch(e){ console.error(e); }
  }

  function applyUtility(state, side, card){
    const t = card.type;
    if (t==="effect-reveal"){
      state.revealFor = side;
      state.revealTurn = state.turn || 1;
    } else if (t==="effect-draw"){
      if (side==="a"){
        drawToHand(state.aHand, state.aDeck, state.aDiscard, 2);
        state.aHandBoost = Math.max(state.aHandBoost||0, 2);
      } else {
        drawToHand(state.bHand, state.bDeck, state.bDiscard, 2);
        state.bHandBoost = Math.max(state.bHandBoost||0, 2);
      }
    } else if (t==="block-rock" || t==="block-paper" || t==="block-scissors"){
      const typ = t.split("-")[1];
      // keep PVP block at 2 turns (PvE uses 3 ‚Äî can be tuned)
      state.blocks[typ] = Math.max(state.blocks[typ]||0, 2);
    }
  }

  // ---------- Clash animation ----------
  async function showClash(aType, bType){
    if (!aType || !bType) return;
    arena.querySelectorAll(".sprite").forEach(n=>n.remove());
    let leftType = (meSide==="a")? aType : bType;
    let rightType = (meSide==="a")? bType : aType;

    const left = document.createElement("div");
    const right = document.createElement("div");
    left.className="sprite spriteL runL";
    right.className="sprite spriteR runR";
    left.innerHTML = `<div style="font-size:28px">${EMOJI[leftType]||"‚ùî"}</div><small>${NAME[leftType]||leftType}</small>`;
    right.innerHTML= `<div style="font-size:28px">${EMOJI[rightType]||"‚ùî"}</div><small>${NAME[rightType]||rightType}</small>`;
    arena.appendChild(left); arena.appendChild(right);
    setCenter(`${EMOJI[leftType]||"‚ùî"} ${NAME[leftType]||leftType}  vs  ${EMOJI[rightType]||"‚ùî"} ${NAME[rightType]||rightType}`);
    await wait(900);
  }

  // ---------- Defeat penalty (level -1 min 1, lose 2 cards unless ‚â§2) ----------
  async function onPlayerDefeat(name){
    let lost = 0, newLevel = 1;
    try{
      const pRef = doc(db,"players",name);
      const pSnap = await getDoc(pRef);
      if (pSnap.exists()){
        const cur = pSnap.data();
        newLevel = Math.max(1, (cur.level || 1) - 1);

        const currentInv = Array.isArray(cur.inventory) ? cur.inventory : [];
        const removeCount = currentInv.length > 2 ? 2 : 0;
        const newInv = removeRandomCards(currentInv, removeCount);
        lost = removeCount;

        await updateDoc(pRef, {
          level: newLevel,
          inventory: newInv,
          x: 8, y: 8 // send back to town
          // xp, gold, guild, etc. are preserved
        });
      }
    }catch(e){
      console.warn("Defeat update failed:", e);
    }
    return {lost, newLevel};
  }

  function backToWorld(){
    location.href = `/game/rock.html?username=${encodeURIComponent(username)}`;
  }
</script>
</body>
</html>

