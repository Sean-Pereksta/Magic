<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Base Push ‚Äî Frontline War (3 Lanes)</title>
  <meta name="viewport"
        content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <style>
    :root{
      --bg:#020617;
      --panel:#020617;
      --ink:#e5e7eb;
      --muted:#9ca3af;
      --accent:#22c55e;
      --danger:#ef4444;
      --warn:#eab308;
      --line:#1f2933;
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color:transparent;}
    html,body{
      margin:0;padding:0;height:100%;
      background:var(--bg);color:var(--ink);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
    }
    body{display:flex;justify-content:center;align-items:stretch;}

    #gameRoot{
      display:flex;
      flex-direction:column;
      width:100%;
      max-width:1100px;
      height:100vh;
      background:radial-gradient(circle at top,#0f172a,#020617 60%);
      overflow:hidden;
      position:relative;
    }

    #topBar{
      flex:0 0 auto;
      padding:6px 8px;
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      gap:4px;
      border-bottom:1px solid var(--line);
      background:rgba(0,0,0,0.65);
      backdrop-filter:blur(8px);
      font-size:12px;
    }

    #hudStats{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
    }

    .pill{
      padding:2px 8px;
      border-radius:999px;
      background:#020617;
      border:1px solid #1f2937;
      white-space:nowrap;
    }

    #btnFullscreen{
      margin-left:auto;
      padding:4px 10px;
      border-radius:999px;
      border:1px solid #1f2937;
      background:#020617;
      color:var(--ink);
      font-size:12px;
    }
    #btnFullscreen:active{
      transform:scale(.97);
      background:#111827;
    }

    #upgradeBar{
      flex:0 0 auto;
      padding:4px 6px 6px;
      display:flex;
      gap:6px;
      min-height:40px;
      align-items:center;
      overflow-x:auto;
      border-bottom:1px solid var(--line);
      background:rgba(15,23,42,.9);
    }
    #upgradeBar::-webkit-scrollbar{height:4px;}
    #upgradeBar::-webkit-scrollbar-thumb{background:#1f2937;border-radius:999px;}

    .upgradeHint{
      font-size:11px;
      color:var(--muted);
      white-space:nowrap;
    }

    .upgradeCard{
      min-width:110px;
      max-width:150px;
      padding:6px 8px;
      border-radius:10px;
      border:1px solid #374151;
      background:#020617;
      cursor:pointer;
      display:flex;
      flex-direction:column;
      gap:4px;
      font-size:11px;
      flex:0 0 auto;
    }
    .upgradeCard h4{
      margin:0;
      font-size:12px;
    }
    .upgradeCard small{
      color:var(--muted);
    }
    .upgradeCard:active{
      transform:scale(.97);
      border-color:var(--accent);
    }

    #canvasWrap{
      position:relative;
      flex:1 1 auto;
      background:#020617;
      overflow:hidden;
    }
    #gameCanvas{
      width:100%;
      height:100%;
      touch-action:none;
      display:block;
    }

    #overlay{
      position:absolute;
      inset:0;
      display:flex;
      justify-content:center;
      align-items:center;
      pointer-events:none;
      font-size:20px;
      font-weight:600;
      text-shadow:0 0 8px #000;
    }
    #overlay span{
      background:rgba(15,23,42,.8);
      padding:10px 16px;
      border-radius:12px;
      border:1px solid #1f2937;
    }

    #toast{
      position:absolute;
      left:50%;
      top:54px;
      transform:translateX(-50%);
      padding:6px 12px;
      border-radius:999px;
      background:rgba(8,47,73,.9);
      color:#e0f2fe;
      font-size:12px;
      border:1px solid #0ea5e9;
      opacity:0;
      pointer-events:none;
      transition:opacity .2s, transform .2s;
      z-index:10;
      white-space:nowrap;
    }
    #toast.show{
      opacity:1;
      transform:translateX(-50%) translateY(-4px);
    }

    /* Base shop */
    #shopPanel{
      position:absolute;
      left:8px;
      top:54px;
      background:rgba(15,23,42,.92);
      border-radius:10px;
      padding:8px;
      border:1px solid #1f2937;
      box-shadow:0 12px 24px rgba(0,0,0,.4);
      font-size:11px;
      min-width:180px;
      pointer-events:auto;
      display:none;
      z-index:12;
    }
    .shopTitle{
      font-weight:600;
      margin-bottom:4px;
    }
    .shopItems{
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .shopItem{
      width:100%;
      text-align:left;
      padding:4px 6px;
      border-radius:8px;
      border:1px solid #1f2937;
      background:#020617;
      color:var(--ink);
      font-size:11px;
      cursor:pointer;
    }
    .shopItem small{color:var(--muted);}
    .shopItem:disabled{
      opacity:.4;
      border-style:dashed;
      cursor:default;
    }
    .shopItem:active{
      transform:scale(.97);
      background:#030712;
    }

    @media (max-width:600px){
      #topBar{font-size:11px;}
      .pill{padding:1px 6px;}
      #btnFullscreen{padding:3px 8px;font-size:11px;}
      .upgradeCard{min-width:100px;}
      #shopPanel{font-size:10px;}
    }
  </style>
</head>
<body>
<div id="gameRoot">
  <div id="topBar">
    <div id="hudStats">
      <div class="pill" id="hudLevel">Lv 1</div>
      <div class="pill" id="hudHP">HP 100 / 100</div>
      <div class="pill" id="hudBase">Base 1000 / 1000</div>
      <div class="pill" id="hudXP">XP 0 / 20</div>
      <div class="pill" id="hudCredits">‚òÖ 0</div>
      <div class="pill" id="hudTip">Tap / click to move ‚Ä¢ Auto-fire</div>
    </div>
    <button id="btnFullscreen">‚õ∂ Fullscreen</button>
  </div>
  <div id="upgradeBar">
    <span class="upgradeHint" id="upgradeHint">Level up to choose upgrades.</span>
  </div>
  <div id="canvasWrap">
    <canvas id="gameCanvas"></canvas>

    <!-- Base shop (shows when you stand near base) -->
    <div id="shopPanel">
      <div class="shopTitle">üè™ Base Shop</div>
      <div class="shopItems">
        <button class="shopItem" data-item="burn">
          üî• Burn Rounds<br>
          <small>Shots apply burning DoT (20‚òÖ)</small>
        </button>
        <button class="shopItem" data-item="freeze">
          ‚ùÑÔ∏è Frost Rounds<br>
          <small>Shots slow enemies (20‚òÖ)</small>
        </button>
        <button class="shopItem" data-item="power">
          ‚ö° Power Core<br>
          <small>+20% hero damage (25‚òÖ)</small>
        </button>
      </div>
    </div>

    <div id="overlay"><span></span></div>
    <div id="toast"></div>
  </div>
</div>

<script>
(function(){
  // ---------- Canvas & layout ----------
  var canvas = document.getElementById('gameCanvas');
  var ctx = canvas.getContext('2d');
  var overlayEl = document.getElementById('overlay');
  var overlaySpan = overlayEl.querySelector('span');
  var toastEl = document.getElementById('toast');

  var hudLevel = document.getElementById('hudLevel');
  var hudHP = document.getElementById('hudHP');
  var hudBase = document.getElementById('hudBase');
  var hudXP = document.getElementById('hudXP');
  var hudCredits = document.getElementById('hudCredits');

  var upgradeBar = document.getElementById('upgradeBar');
  var upgradeHint = document.getElementById('upgradeHint');

  var btnFullscreen = document.getElementById('btnFullscreen');
  var gameRoot = document.getElementById('gameRoot');

  var shopPanel = document.getElementById('shopPanel');

  function resizeCanvas(){
    var rect = canvas.parentElement.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * window.devicePixelRatio);
    canvas.height = Math.floor(rect.height * window.devicePixelRatio);
    ctx.setTransform(window.devicePixelRatio,0,0,window.devicePixelRatio,0,0);
  }
  window.addEventListener('resize',resizeCanvas);
  resizeCanvas();

  // ---------- Helpers ----------
  function clamp(v,min,max){ return v<min?min:(v>max?max:v); }
  function randRange(a,b){ return a + Math.random()*(b-a); }
  function distanceSq(ax,ay,bx,by){
    var dx=ax-bx, dy=ay-by;
    return dx*dx+dy*dy;
  }
  function angleDiff(a,b){
    var d=a-b;
    while(d>Math.PI) d-=2*Math.PI;
    while(d<-Math.PI) d+=2*Math.PI;
    return d;
  }

  function showToast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    setTimeout(function(){
      toastEl.classList.remove('show');
    },1800);
  }

  function drawBar(x,y,w,h,ratio,colorBg,colorFg){
    ratio = ratio<0?0:(ratio>1?1:ratio);
    ctx.fillStyle=colorBg;
    ctx.fillRect(x,y,w,h);
    ctx.fillStyle=colorFg;
    ctx.fillRect(x,y,w*ratio,h);
  }

  // Floating damage numbers
  var damageTexts = [];
  function spawnDamageText(x,y,amount,color){
    damageTexts.push({
      x:x,
      y:y,
      text:Math.round(amount),
      life:0.7,
      vy:-22,
      color:color || '#f97316'
    });
  }

  // Hitscan beams & lightning arcs
  var beams = [];
  function spawnBeam(x1,y1,x2,y2,color){
    beams.push({
      x1:x1, y1:y1,
      x2:x2, y2:y2,
      life:0.08,
      color:color || '#e5e7eb'
    });
  }

  // ---------- World & camera ----------
  var world = {
    width: 5200,
    height: 1500   // taller map
  };

  // Three lanes (top / mid / bottom) marching toward the right / boss
  var LANES = [
    {name:'top', y: world.height*0.25},
    {name:'mid', y: world.height*0.5},
    {name:'bot', y: world.height*0.75}
  ];

  var cameraX = 0;
  var cameraY = 0;

  // Push line
  var pushLineX = 0;
  var pushProgress = 0;

  // ---------- Entities ----------
  var player = {
    x: 260,
    y: world.height/2,
    size: 22,
    baseSpeed: 220,
    maxHP: 100,
    hp: 100,
    regen: 2,
    dmg: 16,
    range: 280,
    fireCooldown: 0.35,
    fireTimer: 0,
    alive: true,
    respawnTimer:0,
    level: 1,
    xp: 0,
    xpNext: 20,
    targetX: null,
    targetY: null,
    unlocked:{
      shotgun:false,
      sniper:false,
      missile:false,
      shockwave:false,
      chain:false
    },
    atkTimers:{
      shotgun:0,
      sniper:0,
      missile:0,
      shockwave:0,
      chain:0
    },
    mods:{
      burn:false,
      freeze:false
    }
  };

  var base = {
    x: 80,
    y: world.height/2 - 80,
    w: 160,
    h: 160,
    maxHP: 1000,
    hp: 1000,
    alive:true
  };

  var friendlyTurrets = [];
  var enemyTurrets = [];
  var enemies = [];
  var alliedTroops = [];
  var bullets = [];
  var boss = null;
  var missiles = []; // boss / heavy missiles
  var explosions = [];

  var troopConfig = {
    spawnInterval: 5,
    spawnTimer: 2.5,
    count: 1,        // per lane
    maxHP: 80,
    hp: 80,
    dmg: 10,
    range: 220,
    speed: 110,
    fireCooldown: 1.0
  };

  var timeElapsed = 0;
  var enemySpawnTimer = 0;
  var gameOver = false;
  var gameWin = false;

  var upgradeOpen = false;
  var pauseForUpgrade = false;
  var upgradeChoices = [];
  var currentUpgradeMode = 'stats'; // 'stats' or 'weapon'
  var pendingSpecial = false;

  // Shop / currency
  var credits = 0;
  var SHOP_ITEMS = {
    burn:{
      cost:20,
      apply:function(){
        player.mods.burn = true;
        showToast('Burn Rounds acquired!');
      }
    },
    freeze:{
      cost:20,
      apply:function(){
        player.mods.freeze = true;
        showToast('Frost Rounds acquired!');
      }
    },
    power:{
      cost:25,
      apply:function(){
        player.dmg = Math.round(player.dmg*1.2);
        showToast('Power Core acquired!');
      }
    }
  };
  var ownedShop = {burn:false,freeze:false,power:false};

  function addCredits(amount){
    credits += (amount||0);
    if(credits<0) credits=0;
  }

  function hitEntity(ent, dmg, color){
    if(!ent || !ent.alive) return;
    ent.hp -= dmg;
    var cx = ent.x, cy = ent.y;
    if(ent===base){
      cx = base.x+base.w/2;
      cy = base.y+base.h/2;
    }else if(typeof ent.w==='number' && typeof ent.h==='number'){
      cx = ent.x+ent.w/2;
      cy = ent.y+ent.h/2;
    }
    spawnDamageText(cx, cy-10, dmg, color || '#f97316');
    if(ent.hp <= 0){
      ent.hp = 0;
      ent.alive=false;
      if(ent===base){
        base.alive=false;
      }
    }
  }

  function onEnemyDeath(e){
    if(e.deadHandled) return;
    e.deadHandled = true;
    if(e.xp) gainXP(e.xp);
    addCredits(1);
  }

  // ---------- Init map ----------
  function makeTurret(x,y,isForward){
    var tier = isForward?1:0;
    return {
      x:x,
      y:y,
      size:20,
      maxHP:isForward?200:170,
      hp:isForward?200:170,
      fireCooldown:isForward?0.9:1.1,
      fireTimer:0,
      dmg:isForward?18:14,
      range:isForward?360:310,
      alive:true,
      side:'friendly',
      tier:tier
    };
  }

  function initTurrets(){
    friendlyTurrets.length = 0;
    var bx = base.x+base.w/2;
    var by = base.y+base.h/2;
    var r = 110;
    var spots = [
      {dx:0,dy:-r},
      {dx:0,dy:r},
      {dx:-r,dy:0},
      {dx:r,dy:0},
      {dx:-r*0.7,dy:-r*0.7},
      {dx:-r*0.7,dy:r*0.7}
    ];
    for(var i=0;i<spots.length;i++){
      friendlyTurrets.push(makeTurret(bx+spots[i].dx,by+spots[i].dy,false));
    }
    var rowX1 = 800;
    friendlyTurrets.push(makeTurret(rowX1, world.height*0.35, true));
    friendlyTurrets.push(makeTurret(rowX1, world.height*0.65, true));
  }

  function makeEnemyTurrets(){
    enemyTurrets.length = 0;
    // More rows, stronger + more complex patterns as you go right
    var rows = [
      {x:2600,tier:1,pattern:'single'},
      {x:3000,tier:2,pattern:'single'},
      {x:3400,tier:3,pattern:'burst'},
      {x:3800,tier:4,pattern:'burst'},
      {x:4200,tier:5,pattern:'scatter'},
      {x:4600,tier:6,pattern:'scatter'}
    ];
    for(var i=0;i<rows.length;i++){
      var r = rows[i];
      var baseHP = 220 + r.tier*90;
      var baseDmg = 22 + r.tier*12;
      var baseRange = 360 + r.tier*60;
      var cd = 1.0 - r.tier*0.12;
      if(cd<0.4) cd=0.4;

      // place per row on mid and slightly offset lanes so all lanes eventually hit them
      enemyTurrets.push({
        x:r.x,
        y:LANES[0].y,
        size:22,
        maxHP:baseHP,
        hp:baseHP,
        fireCooldown:cd,
        fireTimer:0,
        dmg:baseDmg,
        range:baseRange,
        alive:true,
        side:'enemy',
        tier:r.tier,
        pattern:r.pattern,
        burstShotsRemaining:0,
        burstGap:0,
        lastTargetX:0,
        lastTargetY:0
      });
      enemyTurrets.push({
        x:r.x,
        y:LANES[1].y,
        size:22,
        maxHP:baseHP,
        hp:baseHP,
        fireCooldown:cd,
        fireTimer:0,
        dmg:baseDmg,
        range:baseRange,
        alive:true,
        side:'enemy',
        tier:r.tier,
        pattern:r.pattern,
        burstShotsRemaining:0,
        burstGap:0,
        lastTargetX:0,
        lastTargetY:0
      });
      enemyTurrets.push({
        x:r.x,
        y:LANES[2].y,
        size:22,
        maxHP:baseHP,
        hp:baseHP,
        fireCooldown:cd,
        fireTimer:0,
        dmg:baseDmg,
        range:baseRange,
        alive:true,
        side:'enemy',
        tier:r.tier,
        pattern:r.pattern,
        burstShotsRemaining:0,
        burstGap:0,
        lastTargetX:0,
        lastTargetY:0
      });
    }
  }

  function makeBoss(){
    boss = {
      x: world.width-220,
      y: world.height/2,
      size: 50,
      maxHP: 2200,
      hp: 2200,
      alive:true,
      missileCooldown:3.5,
      missileTimer:0,
      aggroRange: 750
    };
  }

  function resetGame(){
    player.x = base.x+base.w/2;
    player.y = base.y+base.h/2;
    player.size=22;
    player.baseSpeed=220;
    player.maxHP=100;
    player.hp=100;
    player.regen=2;
    player.dmg=16;
    player.range=280;
    player.fireCooldown=0.35;
    player.fireTimer=0;
    player.alive=true;
    player.respawnTimer=0;
    player.level=1;
    player.xp=0;
    player.xpNext=20;
    player.targetX=null;
    player.targetY=null;
    player.unlocked.shotgun=false;
    player.unlocked.sniper=false;
    player.unlocked.missile=false;
    player.unlocked.shockwave=false;
    player.unlocked.chain=false;
    player.atkTimers.shotgun=0;
    player.atkTimers.sniper=0;
    player.atkTimers.missile=0;
    player.atkTimers.shockwave=0;
    player.atkTimers.chain=0;
    player.mods.burn=false;
    player.mods.freeze=false;

    base.maxHP=1000;
    base.hp=1000;
    base.alive=true;

    enemies.length=0;
    enemyTurrets.length=0;
    friendlyTurrets.length=0;
    alliedTroops.length=0;
    bullets.length=0;
    missiles.length=0;
    explosions.length=0;
    beams.length=0;
    damageTexts.length=0;

    troopConfig.spawnInterval=5;
    troopConfig.spawnTimer=2.5;
    troopConfig.count=1;
    troopConfig.maxHP=80;
    troopConfig.dmg=10;
    troopConfig.range=220;
    troopConfig.speed=110;
    troopConfig.fireCooldown=1.0;

    initTurrets();
    makeEnemyTurrets();
    makeBoss();

    timeElapsed=0;
    enemySpawnTimer=0;
    gameOver=false;
    gameWin=false;
    upgradeOpen=false;
    pauseForUpgrade=false;
    upgradeChoices=[];
    currentUpgradeMode='stats';
    pendingSpecial=false;
    clearUpgradesUI();
    setOverlay('');
    credits=0;
    ownedShop={burn:false,freeze:false,power:false};
  }

  resetGame();

  // ---------- Upgrades ----------
  var ALL_UPGRADES = [
    {
      id:'range',
      title:'+15% Range',
      desc:'Hit enemies from further away.',
      apply:function(){ player.range = Math.round(player.range*1.15); }
    },
    {
      id:'speed',
      title:'+15% Move Speed',
      desc:'Kite and dodge more easily.',
      apply:function(){ player.baseSpeed = Math.round(player.baseSpeed*1.15); }
    },
    {
      id:'hp',
      title:'+25% Max HP',
      desc:'Max HP +25% and fully heal.',
      apply:function(){
        player.maxHP = Math.round(player.maxHP*1.25);
        player.hp = player.maxHP;
      }
    },
    {
      id:'regen',
      title:'+40% Regen',
      desc:'Recover HP faster over time.',
      apply:function(){ player.regen = player.regen*1.4; }
    },
    {
      id:'damage',
      title:'+20% Damage',
      desc:'Your shots hurt more.',
      apply:function(){ player.dmg = Math.round(player.dmg*1.2); }
    },
    {
      id:'firerate',
      title:'+15% Fire Rate',
      desc:'Shoot more often.',
      apply:function(){ player.fireCooldown = player.fireCooldown*0.85; }
    },
    {
      id:'troop_hp',
      title:'Troops: +25% HP',
      desc:'Base troops get tankier.',
      apply:function(){ troopConfig.maxHP = Math.round(troopConfig.maxHP*1.25); }
    },
    {
      id:'troop_dmg',
      title:'Troops: +25% Damage',
      desc:'Troops hit harder.',
      apply:function(){ troopConfig.dmg = Math.round(troopConfig.dmg*1.25); }
    },
    {
      id:'troop_rate',
      title:'Troops: +20% Spawn Rate',
      desc:'Troops spawn more often.',
      apply:function(){ troopConfig.spawnInterval = Math.max(2.0, troopConfig.spawnInterval*0.8); }
    },
    {
      id:'troop_count',
      title:'Troops: +1 per lane',
      desc:'One extra trooper in each lane.',
      apply:function(){ troopConfig.count = Math.min(3, troopConfig.count+1); }
    }
  ];

  var SPECIAL_WEAPONS = [
    {
      id:'shotgun',
      title:'Shotgun Blast',
      desc:'Periodic cone of pellets.'
    },
    {
      id:'sniper',
      title:'Sniper Beam',
      desc:'Periodically snipes a far enemy.'
    },
    {
      id:'missile',
      title:'Mini Missiles',
      desc:'Homing mini-missiles on random foes.'
    },
    {
      id:'shockwave',
      title:'Shockwave',
      desc:'Periodic radial burst around you.'
    },
    {
      id:'chain',
      title:'Chain Lightning',
      desc:'Lightning jumps between enemies.'
    }
  ];

  function clearUpgradesUI(){
    upgradeChoices = [];
    while(upgradeBar.firstChild){
      upgradeBar.removeChild(upgradeBar.firstChild);
    }
    upgradeBar.appendChild(upgradeHint);
    upgradeHint.textContent = 'Level up to choose upgrades.';
  }

  function openUpgradeChoices(mode){
    upgradeOpen = true;
    pauseForUpgrade = true;
    currentUpgradeMode = mode || 'stats';

    while(upgradeBar.firstChild){
      upgradeBar.removeChild(upgradeBar.firstChild);
    }
    upgradeBar.appendChild(upgradeHint);

    var pool;
    if(currentUpgradeMode==='stats'){
      upgradeHint.textContent = 'Choose an upgrade:';
      pool = ALL_UPGRADES.slice();
    }else{
      upgradeHint.textContent = 'Choose a new weapon:';
      pool = SPECIAL_WEAPONS.filter(function(w){ return !player.unlocked[w.id]; });
    }

    var count = Math.min(3, pool.length);
    upgradeChoices=[];
    if(count===0){
      upgradeOpen=false;
      pauseForUpgrade=false;
      clearUpgradesUI();
      return;
    }
    for(var i=0;i<count;i++){
      var idx = Math.floor(Math.random()*pool.length);
      upgradeChoices.push(pool[idx]);
      pool.splice(idx,1);
    }

    upgradeChoices.forEach(function(up){
      var card = document.createElement('div');
      card.className='upgradeCard';
      var h4 = document.createElement('h4');
      h4.textContent = up.title;
      var p = document.createElement('small');
      p.textContent = up.desc || '';
      card.appendChild(h4);
      card.appendChild(p);
      card.addEventListener('click',function(){
        if(currentUpgradeMode==='stats'){
          up.apply();
          var anyWeaponLeft = SPECIAL_WEAPONS.some(function(w){return !player.unlocked[w.id];});
          if(pendingSpecial && anyWeaponLeft){
            pendingSpecial=false;
            openUpgradeChoices('weapon');
          }else{
            upgradeOpen=false;
            pauseForUpgrade=false;
            clearUpgradesUI();
          }
        }else{
          player.unlocked[up.id]=true;
          if(player.atkTimers[up.id]===undefined){
            player.atkTimers[up.id]=0;
          }
          showToast('Unlocked: '+up.title);
          upgradeOpen=false;
          pauseForUpgrade=false;
          clearUpgradesUI();
        }
      });
      upgradeBar.appendChild(card);
    });
  }

  function gainXP(amount){
    if(gameOver) return;
    player.xp += amount;
    while(player.xp >= player.xpNext){
      player.xp -= player.xpNext;
      levelUp();
    }
  }

  function levelUp(){
    player.level += 1;
    player.maxHP = Math.round(player.maxHP + 18);
    player.hp = player.maxHP;
    player.xpNext = Math.round(player.xpNext * 1.35);

    var anyWeaponLeft = SPECIAL_WEAPONS.some(function(w){return !player.unlocked[w.id];});
    pendingSpecial = (player.level % 5 === 0) && anyWeaponLeft;

    openUpgradeChoices('stats');
  }

  // ---------- Shop events ----------
  Array.prototype.forEach.call(shopPanel.querySelectorAll('.shopItem'), function(btn){
    btn.addEventListener('click', function(){
      var key = btn.getAttribute('data-item');
      var item = SHOP_ITEMS[key];
      if(!item) return;
      if(ownedShop[key]){
        showToast('Already purchased.');
        return;
      }
      if(credits < item.cost){
        showToast('Need '+(item.cost-credits)+' more credits.');
        return;
      }
      addCredits(-item.cost);
      item.apply();
      ownedShop[key]=true;
      btn.disabled=true;
    });
  });

  // ---------- Spawning & allies ----------
  function addBullet(x,y,tx,ty,speed,dmg,side,type,fromHero){
    var dx = tx-x;
    var dy = ty-y;
    var len = Math.sqrt(dx*dx+dy*dy) || 1;
    var vx = dx/len*speed;
    var vy = dy/len*speed;
    var b = {
      x:x,y:y,
      vx:vx,vy:vy,
      dmg:dmg,
      side:side,
      life:3,
      radius:6,
      type:type || 'normal',
      fromHero:!!fromHero,
      tx:tx,
      ty:ty,
      target:null
    };
    bullets.push(b);
    return b;
  }

  function getEntityCenter(ent){
    if(ent===base){
      return {x:base.x+base.w/2, y:base.y+base.h/2};
    }
    if(typeof ent.w==='number' && typeof ent.h==='number'){
      return {x:ent.x+ent.w/2, y:ent.y+ent.h/2};
    }
    return {x:ent.x, y:ent.y};
  }

  function spawnTroopsFromBase(){
    if(!base.alive) return;
    // spawn troops in each lane marching toward right
    for(var l=0;l<LANES.length;l++){
      for(var i=0;i<troopConfig.count;i++){
        var tx = base.x+base.w+10+Math.random()*25;
        var laneY = LANES[l].y + randRange(-40,40);
        var ty = clamp(laneY,80,world.height-80);
        alliedTroops.push({
          x:tx,
          y:ty,
          size:18,
          maxHP:troopConfig.maxHP,
          hp:troopConfig.maxHP,
          speed:troopConfig.speed,
          dmg:troopConfig.dmg,
          range:troopConfig.range,
          fireCooldown:troopConfig.fireCooldown,
          fireTimer:Math.random()*troopConfig.fireCooldown,
          alive:true,
          laneIndex:l,
          laneY:LANES[l].y
        });
      }
    }
  }

  function fireBossMissile(targetX,targetY, dmg, radius){
    missiles.push({
      x:boss?boss.x:targetX,
      y:boss?boss.y:targetY,
      tx:targetX,
      ty:targetY,
      speed:120,
      radius:radius||10,
      arrived:false,
      explodeRadius:90,
      dmg:dmg||120
    });
  }

  // ---------- Specials ----------
  function getClosestEnemy(){
    var best=null;
    var bestD=Infinity;
    for(var i=0;i<enemies.length;i++){
      var e=enemies[i];
      if(!e.alive) continue;
      var d=distanceSq(player.x,player.y,e.x,e.y);
      if(d<bestD){
        bestD=d;
        best=e;
      }
    }
    return best;
  }

  function spawnShotgun(){
    var target = getClosestEnemy();
    if(!target) return;
    var dx = target.x-player.x;
    var dy = target.y-player.y;
    var baseAng = Math.atan2(dy,dx);
    var spread = Math.PI/6;
    var count = 5;
    for(var i=0;i<count;i++){
      var a = baseAng + spread*(i-(count-1)/2);
      var tx = player.x + Math.cos(a)*player.range;
      var ty = player.y + Math.sin(a)*player.range;
      var b = addBullet(player.x,player.y,tx,ty,260,Math.round(player.dmg*0.7),'friendly','shotgun',true);
      b.life = 1.6;
    }
  }

  function spawnSniper(){
    var far=null;
    var farD=0;
    for(var i=0;i<enemies.length;i++){
      var e=enemies[i];
      if(!e.alive) continue;
      var d=distanceSq(player.x,player.y,e.x,e.y);
      if(d>farD){
        farD=d;
        far=e;
      }
    }
    if(!far) return;
    var b = addBullet(player.x,player.y,far.x,far.y,420,Math.round(player.dmg*3),'friendly','sniper',true);
    b.life = 2.5;
  }

  function spawnMiniMissiles(){
    var list=[];
    for(var i=0;i<enemies.length;i++){
      if(enemies[i].alive) list.push(enemies[i]);
    }
    if(list.length===0) return;
    var shots = Math.min(4,list.length);
    for(var s=0;s<shots;s++){
      var idx = Math.floor(Math.random()*list.length);
      var e=list[idx];
      var b = addBullet(player.x,player.y,e.x,e.y,180,Math.round(player.dmg*1.6),'friendly','missile',true);
      b.target = e;
      b.life = 4;
      b.radius = 7;
    }
  }

  function spawnShockwave(){
    var radius = 160;
    var dmg = Math.round(player.dmg*1.4);
    explosions.push({
      x:player.x,
      y:player.y,
      radius:radius,
      maxRadius:radius,
      life:0.45
    });
    for(var i=0;i<enemies.length;i++){
      var e=enemies[i];
      if(!e.alive) continue;
      var d = Math.sqrt(distanceSq(player.x,player.y,e.x,e.y));
      if(d<=radius){
        hitEntity(e,dmg,'#e5e7eb');
        if(!e.alive){
          onEnemyDeath(e);
        }
      }
    }
  }

  // Hero on-hit elemental effects
  function applyHeroOnHitEffects(target, baseDamage){
    if(!target || !target.alive) return;
    if(player.mods.burn){
      target.burnTimer = 3;
      target.burnDps = (target.burnDps || 0) + (8 + player.level*0.6);
    }
    if(player.mods.freeze){
      target.freezeTimer = 2;
    }
  }

  function updateStatusOnUnit(ent, dt, isEnemyArray){
    if(!ent) return;
    if(ent.burnTimer && ent.burnTimer>0){
      ent.burnTimer -= dt;
      if(ent.burnTimer<0) ent.burnTimer=0;
      var dps = ent.burnDps || 0;
      if(dps>0 && ent.alive){
        hitEntity(ent,dps*dt,'#fb923c');
        if(isEnemyArray && !ent.alive){
          onEnemyDeath(ent);
        }
      }
    }
    if(ent.freezeTimer && ent.freezeTimer>0){
      ent.freezeTimer -= dt;
      if(ent.freezeTimer<0) ent.freezeTimer=0;
    }
  }

  // Chain Lightning: zaps enemies and jumps between them
  function castChainLightning(){
    var cands = [];
    for(var i=0;i<enemies.length;i++){
      if(enemies[i].alive) cands.push(enemies[i]);
    }
    if(boss && boss.alive) cands.push(boss);
    if(!cands.length) return;

    // start on nearest to player
    var start=null, best=Infinity;
    for(var j=0;j<cands.length;j++){
      var c=cands[j];
      var d=distanceSq(player.x,player.y,c.x,c.y);
      if(d<best){
        best=d; start=c;
      }
    }
    if(!start) return;

    var used=[];
    var prevX = player.x;
    var prevY = player.y;
    var current = start;
    var dmg = player.dmg*2.2;
    var jumps = 4;
    var jumpRadiusSq = 260*260;

    for(var step=0; step<jumps && current; step++){
      spawnBeam(prevX,prevY,current.x,current.y,'#a855f7');
      hitEntity(current,dmg,'#a855f7');
      if(current.kind && current.hp<=0){
        onEnemyDeath(current);
      }
      applyHeroOnHitEffects(current,dmg);

      used.push(current);
      prevX = current.x;
      prevY = current.y;

      var next=null, best2=Infinity;
      for(var k=0;k<cands.length;k++){
        var cand=cands[k];
        if(!cand.alive) continue;
        if(used.indexOf(cand)>=0) continue;
        var dd=distanceSq(current.x,current.y,cand.x,cand.y);
        if(dd<jumpRadiusSq && dd<best2){
          best2=dd;
          next=cand;
        }
      }
      dmg *= 0.6;
      current = next;
    }
  }

  // ---------- Input ----------
  function handlePointer(evt){
    if(!player.alive || gameOver) return;
    var rect = canvas.getBoundingClientRect();
    var scaleX = canvas.width / window.devicePixelRatio / rect.width;
    var scaleY = canvas.height / window.devicePixelRatio / rect.height;
    var cx = (evt.clientX - rect.left) * scaleX;
    var cy = (evt.clientY - rect.top) * scaleY;
    var worldX = cameraX - canvas.width/window.devicePixelRatio/2 + cx;
    var worldY = cameraY - canvas.height/window.devicePixelRatio/2 + cy;
    player.targetX = clamp(worldX,0,world.width);
    player.targetY = clamp(worldY,0,world.height);
  }

  canvas.addEventListener('pointerdown',function(e){
    e.preventDefault();
    handlePointer(e);
  });
  canvas.addEventListener('pointermove',function(e){
    if(e.buttons&1){
      e.preventDefault();
      handlePointer(e);
    }
  });
  canvas.addEventListener('contextmenu',function(e){e.preventDefault();});

  // ---------- Fullscreen ----------
  btnFullscreen.addEventListener('click',function(){
    if(!document.fullscreenElement){
      if(gameRoot.requestFullscreen){
        gameRoot.requestFullscreen();
      }
    }else{
      if(document.exitFullscreen){
        document.exitFullscreen();
      }
    }
  });

  // ---------- Overlay ----------
  function setOverlay(text){
    if(text){
      overlayEl.style.display='flex';
      overlaySpan.textContent=text;
    }else{
      overlayEl.style.display='none';
      overlaySpan.textContent='';
    }
  }

  // ---------- Target helper ----------
  function nearestFriendlyTarget(x,y){
    var target=null;
    var bestD=Infinity;

    // player
    if(player.alive){
      var dpl=distanceSq(x,y,player.x,player.y);
      if(dpl<bestD){
        bestD=dpl;
        target={type:'player',ref:player,x:player.x,y:player.y};
      }
    }
    // base
    if(base.alive){
      var bcx=base.x+base.w/2;
      var bcy=base.y+base.h/2;
      var db=distanceSq(x,y,bcx,bcy);
      if(db<bestD){
        bestD=db;
        target={type:'base',ref:base,x:bcx,y:bcy};
      }
    }
    // friendly turrets
    for(var i=0;i<friendlyTurrets.length;i++){
      var ft=friendlyTurrets[i];
      if(!ft.alive) continue;
      var dt2=distanceSq(x,y,ft.x,ft.y);
      if(dt2<bestD){
        bestD=dt2;
        target={type:'turret',ref:ft,x:ft.x,y:ft.y};
      }
    }
    // allied troops
    for(var j=0;j<alliedTroops.length;j++){
      var tr=alliedTroops[j];
      if(!tr.alive) continue;
      var da=distanceSq(x,y,tr.x,tr.y);
      if(da<bestD){
        bestD=da;
        target={type:'ally',ref:tr,x:tr.x,y:tr.y};
      }
    }
    return target;
  }

  function applyLaserArcDamage(en,dt){
    var r = en.arcRange;
    var w = en.arcWidth;
    var dps = 40;
    function tryHit(obj,x,y){
      if(!obj.alive) return;
      var dx=x-en.x, dy=y-en.y;
      var dist = Math.sqrt(dx*dx+dy*dy);
      if(dist>r) return;
      var ang = Math.atan2(dy,dx);
      if(Math.abs(angleDiff(ang,en.arcAngle)) <= w/2){
        hitEntity(obj,dps*dt,'#fb7185');
      }
    }
    if(player.alive) tryHit(player,player.x,player.y);
    if(base.alive) tryHit(base,base.x+base.w/2,base.y+base.h/2);
    for(var i=0;i<friendlyTurrets.length;i++){
      var ft=friendlyTurrets[i];
      if(!ft.alive) continue;
      tryHit(ft,ft.x,ft.y);
    }
    for(var j=0;j<alliedTroops.length;j++){
      var tr=alliedTroops[j];
      if(!tr.alive) continue;
      tryHit(tr,tr.x,tr.y);
    }
  }

  function updateLaserEnemy(en,target,dt){
    var slowFactor = (en.freezeTimer && en.freezeTimer>0)?0.45:1;
    // movement
    if(target){
      var dx = target.x-en.x;
      var dy = target.y-en.y;
      var dist = Math.sqrt(dx*dx+dy*dy);
      var desired = 190;
      if(dist>desired+25){
        en.x += dx/dist * en.speed*slowFactor*dt;
        en.y += dy/dist * en.speed*slowFactor*dt;
      }else if(dist<desired-25){
        en.x -= dx/dist * en.speed*slowFactor*dt*0.6;
        en.y -= dy/dist * en.speed*slowFactor*dt*0.6;
      }
    }else{
      en.x -= en.speed*slowFactor*dt*0.4;
    }

    // sweeping wiper-style arc
    if(en.arcActiveTime>0){
      en.arcActiveTime -= dt;
      en.arcAngle += en.sweepDir * en.sweepSpeed * dt;
      if(en.arcAngle > en.maxAngle){
        en.arcAngle = en.maxAngle;
        en.sweepDir = -1;
      }else if(en.arcAngle < en.minAngle){
        en.arcAngle = en.minAngle;
        en.sweepDir = 1;
      }
      applyLaserArcDamage(en,dt);
    }else{
      en.arcTimer -= dt;
      if(en.arcTimer<=0){
        en.arcActiveTime = en.arcDuration;
        en.arcTimer = en.arcCooldown;
        en.arcAngle = en.minAngle;
        en.sweepDir = 1;
      }
    }
  }

  function applyDashDamage(en){
    var dmg = en.dashDamage;
    function tryHit(obj,x,y){
      if(!obj.alive) return;
      var d=distanceSq(en.x,en.y,x,y);
      var rad=(en.size+22);
      if(d<=rad*rad){
        hitEntity(obj,dmg,'#fb7185');
      }
    }
    if(player.alive) tryHit(player,player.x,player.y);
    if(base.alive) tryHit(base,base.x+base.w/2,base.y+base.h/2);
    for(var i=0;i<friendlyTurrets.length;i++){
      var ft=friendlyTurrets[i];
      if(!ft.alive) continue;
      tryHit(ft,ft.x,ft.y);
    }
    for(var j=0;j<alliedTroops.length;j++){
      var tr=alliedTroops[j];
      if(!tr.alive) continue;
      tryHit(tr,tr.x,tr.y);
    }
  }

  function updateDashEnemy(en,target,dt){
    var slowFactor = (en.freezeTimer && en.freezeTimer>0)?0.45:1;
    if(en.state==='normal'){
      if(target){
        var dx = target.x-en.x;
        var dy = target.y-en.y;
        var dist = Math.sqrt(dx*dx+dy*dy);
        if(dist>2){
          en.x += dx/dist*en.speed*slowFactor*dt;
          en.y += dy/dist*en.speed*slowFactor*dt;
        }
        if(dist < en.size + 24){
          hitEntity(target.ref,en.dmg*dt*0.6);
        }
        en.dashCooldown -= dt;
        if(dist < en.dashRange && en.dashCooldown<=0){
          en.state='windup';
          en.dashStateTimer=0.5;
          en.dashTargetX=target.x;
          en.dashTargetY=target.y;
        }
      }else{
        en.x -= en.speed*slowFactor*dt*0.6;
      }
    }else if(en.state==='windup'){
      en.dashStateTimer-=dt;
      if(en.dashStateTimer<=0){
        en.state='dash';
        en.dashStateTimer=0.25;
        var dx2 = en.dashTargetX-en.x;
        var dy2 = en.dashTargetY-en.y;
        var dist2 = Math.sqrt(dx2*dx2+dy2*dy2) || 1;
        en.dashVx = dx2/dist2*en.dashSpeed;
        en.dashVy = dy2/dist2*en.dashSpeed;
      }
    }else if(en.state==='dash'){
      en.dashStateTimer-=dt;
      en.x += en.dashVx*dt;
      en.y += en.dashVy*dt;
      applyDashDamage(en);
      if(en.dashStateTimer<=0){
        en.state='normal';
        en.dashCooldown=en.dashCooldownMax;
      }
    }
  }

  function updateScatterEnemy(en,target,dt){
    var slowFactor = (en.freezeTimer && en.freezeTimer>0)?0.45:1;
    if(target){
      var dx = target.x-en.x;
      var dy = target.y-en.y;
      var dist = Math.sqrt(dx*dx+dy*dy);
      var desired = 220;
      if(dist>desired+15){
        en.x += dx/dist * en.speed*slowFactor*dt;
        en.y += dy/dist * en.speed*slowFactor*dt;
      }else if(dist<desired-15){
        en.x -= dx/dist * en.speed*slowFactor*dt*0.7;
        en.y -= dy/dist * en.speed*slowFactor*dt*0.7;
      }
      en.fireTimer -= dt;
      if(en.fireTimer<=0 && dist<en.range){
        var baseAng = Math.atan2(target.y-en.y,target.x-en.x);
        var count = 5;
        var spread = Math.PI/5;
        for(var i=0;i<count;i++){
          var a = baseAng + spread*(i-(count-1)/2);
          var tx = en.x + Math.cos(a)*en.range;
          var ty = en.y + Math.sin(a)*en.range;
          addBullet(en.x,en.y,tx,ty,260,en.dmg,'enemy','scatter',false);
        }
        en.fireTimer = en.fireCooldown;
      }
    }else{
      en.x -= en.speed*slowFactor*dt*0.5;
    }
  }

  // ---------- Main update ----------
  var lastTime = performance.now();

  function update(dt){
    if(gameOver) return;
    if(pauseForUpgrade) return;

    timeElapsed += dt;
    enemySpawnTimer += dt;

    // spawn enemies (three lanes)
    var spawnInterval = Math.max(0.9, 2.4 - timeElapsed*0.01);
    while(enemySpawnTimer >= spawnInterval){
      enemySpawnTimer -= spawnInterval;
      spawnEnemy();
    }

    // Friendly troop spawns
    if(base.alive){
      troopConfig.spawnTimer -= dt;
      if(troopConfig.spawnTimer<=0){
        troopConfig.spawnTimer += troopConfig.spawnInterval;
        spawnTroopsFromBase();
      }
    }

    // player
    if(player.alive){
      if(player.targetX!==null){
        var dx = player.targetX-player.x;
        var dy = player.targetY-player.y;
        var dist = Math.sqrt(dx*dx+dy*dy);
        if(dist>2){
          var vx = dx/dist * player.baseSpeed;
          var vy = dy/dist * player.baseSpeed;
          player.x += vx*dt;
          player.y += vy*dt;
          player.x = clamp(player.x,0,world.width);
          player.y = clamp(player.y,0,world.height);
        }
      }

      // regen
      if(player.hp<player.maxHP){
        player.hp = Math.min(player.maxHP, player.hp + player.regen*dt);
      }

      // base shop visibility (stand near base)
      var bcx = base.x+base.w/2;
      var bcy = base.y+base.h/2;
      var nearBase = base.alive && Math.sqrt(distanceSq(player.x,player.y,bcx,bcy)) < 200 && !gameOver;
      shopPanel.style.display = nearBase ? 'block' : 'none';

      // auto-fire using hitscan beam (hero basic)
      player.fireTimer -= dt;
      if(player.fireTimer <= 0){
        var target = null;
        var bestD = player.range * player.range;

        function considerTarget(obj){
          if(!obj || !obj.alive) return;
          var d = distanceSq(player.x,player.y,obj.x,obj.y);
          if(d<bestD){
            bestD = d;
            target = obj;
          }
        }

        for(var i0=0;i0<enemies.length;i0++) considerTarget(enemies[i0]);
        for(var j0=0;j0<enemyTurrets.length;j0++) considerTarget(enemyTurrets[j0]);
        if(boss) considerTarget(boss);

        if(target){
          spawnBeam(player.x,player.y,target.x,target.y,'#e5e7eb');
          var dmg = player.dmg;
          hitEntity(target,dmg,'#e5e7eb');
          if(target.kind || target===boss){
            applyHeroOnHitEffects(target,dmg);
          }
          player.fireTimer = player.fireCooldown;
        }else{
          player.fireTimer = 0.12;
        }
      }

      // specials
      if(player.unlocked.shotgun){
        player.atkTimers.shotgun += dt;
        if(player.atkTimers.shotgun>=3){
          spawnShotgun();
          player.atkTimers.shotgun=0;
        }
      }
      if(player.unlocked.sniper){
        player.atkTimers.sniper += dt;
        if(player.atkTimers.sniper>=4.5){
          spawnSniper();
          player.atkTimers.sniper=0;
        }
      }
      if(player.unlocked.missile){
        player.atkTimers.missile += dt;
        if(player.atkTimers.missile>=5.0){
          spawnMiniMissiles();
          player.atkTimers.missile=0;
        }
      }
      if(player.unlocked.shockwave){
        player.atkTimers.shockwave += dt;
        if(player.atkTimers.shockwave>=7.5){
          spawnShockwave();
          player.atkTimers.shockwave=0;
        }
      }
      if(player.unlocked.chain){
        player.atkTimers.chain += dt;
        if(player.atkTimers.chain>=8){
          castChainLightning();
          player.atkTimers.chain=0;
        }
      }
    }else{
      player.respawnTimer -= dt;
      if(player.respawnTimer<=0){
        player.alive=true;
        player.hp = player.maxHP;
        player.x = base.x+base.w/2;
        player.y = base.y+base.h/2;
        player.targetX = player.x;
        player.targetY = player.y;
      }
    }

    // friendly turrets
    for(var i=0;i<friendlyTurrets.length;i++){
      var t=friendlyTurrets[i];
      if(!t.alive) continue;
      if(t.hp<t.maxHP){
        t.hp = Math.min(t.maxHP, t.hp + 3*dt);
      }
      t.fireTimer -= dt;
      if(t.fireTimer<=0){
        var target=null;
        var bestD=t.range*t.range;
        for(var j=0;j<enemies.length;j++){
          var e=enemies[j];
          if(!e.alive) continue;
          var d=distanceSq(t.x,t.y,e.x,e.y);
          if(d<bestD){
            bestD=d;
            target=e;
          }
        }
        if(target){
          addBullet(t.x,t.y,target.x,target.y,320,t.dmg,'friendly','turret',false);
          t.fireTimer = t.fireCooldown;
        }else{
          t.fireTimer=0.15;
        }
      }
    }

    // allied troops (3-lane marching)
    for(var a=0;a<alliedTroops.length;a++){
      var tr = alliedTroops[a];
      if(!tr.alive) continue;
      var target=null;
      var bestD=Infinity;

      // find nearest enemy / turret / boss
      for(var eIdx=0;eIdx<enemies.length;eIdx++){
        var e=enemies[eIdx];
        if(!e.alive) continue;
        var d=distanceSq(tr.x,tr.y,e.x,e.y);
        if(d<bestD){
          bestD=d;
          target=e;
        }
      }
      for(var etIdx=0;etIdx<enemyTurrets.length;etIdx++){
        var et=enemyTurrets[etIdx];
        if(!et.alive) continue;
        var d2=distanceSq(tr.x,tr.y,et.x,et.y);
        if(d2<bestD){
          bestD=d2;
          target=et;
        }
      }
      if(boss && boss.alive){
        var db=distanceSq(tr.x,tr.y,boss.x,boss.y);
        if(db<bestD){
          bestD=db;
          target=boss;
        }
      }

      var engageRadius = tr.range*tr.range*1.1;

      if(target && bestD <= engageRadius){
        // engage & move toward target
        var dx3=target.x-tr.x;
        var dy3=target.y-tr.y;
        var dist3=Math.sqrt(dx3*dx3+dy3*dy3) || 1;
        if(dist3>40){
          tr.x += dx3/dist3 * tr.speed*dt;
          tr.y += dy3/dist3 * tr.speed*dt;
        }
        tr.fireTimer -= dt;
        if(tr.fireTimer<=0 && dist3<=tr.range){
          addBullet(tr.x,tr.y,target.x,target.y,300,tr.dmg,'friendly','troop',false);
          tr.fireTimer = tr.fireCooldown;
        }
      }else{
        // lane march towards boss along assigned lane
        var targetLaneY = (typeof tr.laneY === 'number') ? tr.laneY : world.height/2;
        tr.x += tr.speed*dt;
        var dyLane = targetLaneY - tr.y;
        if(Math.abs(dyLane) > 2){
          var dir = dyLane>0 ? 1 : -1;
          tr.y += dir * tr.speed*0.4*dt;
        }
        tr.y = clamp(tr.y,40,world.height-40);
      }
    }

    // enemy turrets
    for(var i2=0;i2<enemyTurrets.length;i2++){
      var et2=enemyTurrets[i2];
      if(!et2.alive) continue;

      // handle ongoing burst sequences
      if(et2.pattern==='burst' && et2.burstShotsRemaining>0){
        et2.burstGap -= dt;
        if(et2.burstGap<=0){
          et2.burstGap = 0.16;
          et2.burstShotsRemaining--;
          addBullet(et2.x,et2.y,et2.lastTargetX,et2.lastTargetY,260+et2.tier*20,et2.dmg,'enemy','normal',false);
        }
      }

      et2.fireTimer -= dt;
      if(et2.fireTimer<=0){
        var best = nearestFriendlyTarget(et2.x,et2.y);
        if(best && distanceSq(et2.x,et2.y,best.x,best.y)<=et2.range*et2.range){
          if(et2.pattern==='single'){
            addBullet(et2.x,et2.y,best.x,best.y,260+et2.tier*20,et2.dmg,'enemy','normal',false);
          }else if(et2.pattern==='burst'){
            et2.lastTargetX = best.x;
            et2.lastTargetY = best.y;
            addBullet(et2.x,et2.y,best.x,best.y,260+et2.tier*20,et2.dmg,'enemy','normal',false);
            et2.burstShotsRemaining = 2;
            et2.burstGap = 0.16;
          }else if(et2.pattern==='scatter'){
            var baseAngT = Math.atan2(best.y-et2.y,best.x-et2.x);
            var countS = 5;
            var spreadS = Math.PI/10;
            for(var k=-2;k<=2;k++){
              var aa = baseAngT + k*spreadS;
              var tx = et2.x + Math.cos(aa)*et2.range;
              var ty = et2.y + Math.sin(aa)*et2.range;
              addBullet(et2.x,et2.y,tx,ty,260+et2.tier*20,et2.dmg,'enemy','scatter',false);
            }
          }
          et2.fireTimer = et2.fireCooldown;
        }else{
          et2.fireTimer=0.3;
        }
      }
    }

    // Enemies (movement + attacking)
    for(var eIdx=0;eIdx<enemies.length;eIdx++){
      var en=enemies[eIdx];
      if(!en.alive) continue;

      var target = nearestFriendlyTarget(en.x,en.y);

      if(en.kind==='laser'){
        updateLaserEnemy(en,target?{x:target.x,y:target.y}:null,dt);
        updateStatusOnUnit(en,dt,true);
        continue;
      }
      if(en.kind==='dash'){
        updateDashEnemy(en,target,dt);
        updateStatusOnUnit(en,dt,true);
        continue;
      }
      if(en.kind==='scatter'){
        updateScatterEnemy(en,target?{x:target.x,y:target.y}:null,dt);
        updateStatusOnUnit(en,dt,true);
        continue;
      }

      var slowFactor = (en.freezeTimer && en.freezeTimer>0)?0.45:1;

      if(target){
        var dx2 = target.x-en.x;
        var dy2 = target.y-en.y;
        var dist2 = Math.sqrt(dx2*dx2+dy2*dy2);

        if(en.kind!=='alien' || dist2>en.range*0.6){
          if(dist2>1){
            en.x += dx2/dist2 * en.speed*slowFactor*dt;
            en.y += dy2/dist2 * en.speed*slowFactor*dt;
          }
        }

        if(en.dps>0 && dist2 < en.size + (target.ref.size||24) + 4){
          var dmgSec = en.dps*dt;
          hitEntity(target.ref,dmgSec);
          if(target.ref===base && !base.alive){
            gameOver=true;
            gameWin=false;
            setOverlay('Defeat ‚Äî your base fell.');
          }
        }

        if(en.kind==='alien'){
          en.fireTimer -= dt;
          if(en.fireTimer<=0 && dist2<en.range*en.range){
            addBullet(en.x,en.y,target.x,target.y,260,en.dmg,'enemy','normal',false);
            en.fireTimer = en.fireCooldown || 1.5;
          }
        }
      }else{
        en.x -= en.speed*slowFactor*dt*0.5;
      }

      updateStatusOnUnit(en,dt,true);
    }

    // Boss
    if(boss && boss.alive){
      boss.missileTimer -= dt;
      var inAggro=false;
      if(player.alive){
        var dBoss = Math.sqrt(distanceSq(player.x,player.y,boss.x,boss.y));
        inAggro = (dBoss <= boss.aggroRange);
      }
      if(inAggro && boss.missileTimer<=0){
        var txB = player.x;
        var tyB = player.y;
        fireBossMissile(txB,tyB,120,10);
        boss.missileTimer = boss.missileCooldown;
      }
      updateStatusOnUnit(boss,dt,false);
    }

    // Missiles (boss)
    for(var m=0;m<missiles.length;m++){
      var ms=missiles[m];
      if(ms.arrived) continue;
      var dxm=ms.tx-ms.x;
      var dym=ms.ty-ms.y;
      var distm=Math.sqrt(dxm*dxm+dym*dym);
      if(distm<10){
        ms.arrived=true;
        explosions.push({
          x:ms.tx,
          y:ms.ty,
          radius:ms.explodeRadius,
          maxRadius:ms.explodeRadius,
          life:0.45
        });
        var reSq=ms.explodeRadius*ms.explodeRadius;

        if(player.alive && distanceSq(player.x,player.y,ms.tx,ms.ty)<=reSq){
          player.hp -= ms.dmg;
          if(player.hp<=0){
            player.hp=0;
            player.alive=false;
            player.respawnTimer=10;
            player.targetX=null;
            player.targetY=null;
          }
        }
        if(base.alive && distanceSq(base.x+base.w/2,base.y+base.h/2,ms.tx,ms.ty)<=reSq){
          hitEntity(base,ms.dmg*1.2);
          if(!base.alive){
            gameOver=true;
            gameWin=false;
            setOverlay('Defeat ‚Äî your base fell.');
          }
        }
        for(var ftIdx=0;ftIdx<friendlyTurrets.length;ftIdx++){
          var ft=friendlyTurrets[ftIdx];
          if(!ft.alive) continue;
          if(distanceSq(ft.x,ft.y,ms.tx,ms.ty)<=reSq){
            hitEntity(ft,ms.dmg);
          }
        }
        for(var atIdx=0;atIdx<alliedTroops.length;atIdx++){
          var tr2=alliedTroops[atIdx];
          if(!tr2.alive) continue;
          if(distanceSq(tr2.x,tr2.y,ms.tx,ms.ty)<=reSq){
            hitEntity(tr2,ms.dmg);
          }
        }
      }else{
        ms.x += dxm/distm*ms.speed*dt;
        ms.y += dym/distm*ms.speed*dt;
      }
    }

    // bullets
    for(var bIdx=0;bIdx<bullets.length;bIdx++){
      var bl=bullets[bIdx];
      if(!bl) continue;
      bl.life -= dt;
      if(bl.life<=0){
        bullets[bIdx]=null;
        continue;
      }

      // missile homing
      if(bl.type==='missile' && bl.target && bl.target.alive){
        var dxh = bl.target.x-bl.x;
        var dyh = bl.target.y-bl.y;
        var dh = Math.sqrt(dxh*dxh+dyh*dyh) || 1;
        var speedH = 220;
        var dvx = dxh/dh*speedH;
        var dvy = dyh/dh*speedH;
        var steer = 6*dt;
        bl.vx = bl.vx + (dvx-bl.vx)*steer;
        bl.vy = bl.vy + (dvy-bl.vy)*steer;
      }

      bl.x += bl.vx*dt;
      bl.y += bl.vy*dt;
      if(bl.x< -50 || bl.x>world.width+50 || bl.y<-50 || bl.y>world.height+50){
        bullets[bIdx]=null;
        continue;
      }

      if(bl.side==='friendly'){
        var hit=false;
        // enemies
        for(var e2Idx=0;e2Idx<enemies.length;e2Idx++){
          var e2=enemies[e2Idx];
          if(!e2.alive) continue;
          var de=distanceSq(bl.x,bl.y,e2.x,e2.y);
          var rad = bl.radius + e2.size*0.7;
          if(de<=rad*rad){
            hitEntity(e2,bl.dmg,'#e5e7eb');
            if(!e2.alive){
              onEnemyDeath(e2);
            }else if(bl.fromHero){
              applyHeroOnHitEffects(e2,bl.dmg);
            }
            hit=true;
            break;
          }
        }
        if(!hit && boss && boss.alive){
          var dboss=distanceSq(bl.x,bl.y,boss.x,boss.y);
          var radB = bl.radius + boss.size;
          if(dboss<=radB*radB){
            hitEntity(boss,bl.dmg,'#e5e7eb');
            if(bl.fromHero){
              applyHeroOnHitEffects(boss,bl.dmg);
            }
            hit=true;
          }
        }
        if(!hit){
          for(var et3Idx=0;et3Idx<enemyTurrets.length;et3Idx++){
            var et3=enemyTurrets[et3Idx];
            if(!et3.alive) continue;
            var det=distanceSq(bl.x,bl.y,et3.x,et3.y);
            var radet=bl.radius + et3.size;
            if(det<=radet*radet){
              hitEntity(et3,bl.dmg,'#e5e7eb');
              if(!et3.alive && !et3.deadHandled){
                et3.deadHandled=true;
                addCredits(5);
              }
              hit=true;
              break;
            }
          }
        }
        if(hit) bullets[bIdx]=null;
      }else{
        // enemy bullet
        var hit2=false;
        if(player.alive){
          var dp2=distanceSq(bl.x,bl.y,player.x,player.y);
          var rp=bl.radius + player.size;
          if(dp2<=rp*rp){
            hitEntity(player,bl.dmg,'#fb7185');
            if(player.hp<=0){
              player.hp=0;
              player.alive=false;
              player.respawnTimer=10;
              player.targetX=null;
              player.targetY=null;
            }
            hit2=true;
          }
        }
        if(!hit2 && base.alive){
          var db2=distanceSq(bl.x,bl.y,base.x+base.w/2,base.y+base.h/2);
          var rb=bl.radius + Math.max(base.w,base.h)/2;
          if(db2<=rb*rb){
            hitEntity(base,bl.dmg);
            if(!base.alive){
              gameOver=true;
              gameWin=false;
              setOverlay('Defeat ‚Äî your base fell.');
            }
            hit2=true;
          }
        }
        if(!hit2){
          for(var ft4Idx=0;ft4Idx<friendlyTurrets.length;ft4Idx++){
            var ft4=friendlyTurrets[ft4Idx];
            if(!ft4.alive) continue;
            var dft=distanceSq(bl.x,bl.y,ft4.x,ft4.y);
            var rft=bl.radius + ft4.size;
            if(dft<=rft*rft){
              hitEntity(ft4,bl.dmg);
              hit2=true;
              break;
            }
          }
        }
        if(!hit2){
          for(var at2=0;at2<alliedTroops.length;at2++){
            var tro=alliedTroops[at2];
            if(!tro.alive) continue;
            var dat=distanceSq(bl.x,bl.y,tro.x,tro.y);
            var rat=bl.radius + tro.size;
            if(dat<=rat*rat){
              hitEntity(tro,bl.dmg);
              hit2=true;
              break;
            }
          }
        }
        if(hit2) bullets[bIdx]=null;
      }
    }

    // explosions fade
    for(var ex=0;ex<explosions.length;ex++){
      var exo=explosions[ex];
      exo.life -= dt;
      if(exo.life<0){
        explosions.splice(ex,1);
        ex--;
      }
    }

    // update beams
    for(var bi=0;bi<beams.length;bi++){
      beams[bi].life -= dt;
      if(beams[bi].life<=0){
        beams.splice(bi,1);
        bi--;
      }
    }

    // update damage texts
    for(var di=0;di<damageTexts.length;di++){
      var dtxt = damageTexts[di];
      dtxt.life -= dt;
      dtxt.y += dtxt.vy*dt;
      if(dtxt.life<=0){
        damageTexts.splice(di,1);
        di--;
      }
    }

    // cleanup bullets
    var newBullets=[];
    for(var nb=0;nb<bullets.length;nb++){
      if(bullets[nb]) newBullets.push(bullets[nb]);
    }
    bullets=newBullets;

    // player death check
    if(player.alive && player.hp<=0){
      player.alive=false;
      player.respawnTimer=10;
      player.targetX=null;
      player.targetY=null;
    }

    // base defeat
    if(!base.alive && !gameOver){
      gameOver=true;
      gameWin=false;
      setOverlay('Defeat ‚Äî your base fell.');
    }

    // win condition
    if(boss && !boss.alive && !gameOver){
      var anyTurret=false;
      for(var qt=0;qt<enemyTurrets.length;qt++){
        if(enemyTurrets[qt].alive){ anyTurret=true; break; }
      }
      var anyEnemy=false;
      for(var qe=0;qe<enemies.length;qe++){
        if(enemies[qe].alive){ anyEnemy=true; break; }
      }
      if(!anyTurret && !anyEnemy){
        gameOver=true;
        gameWin=true;
        setOverlay('Victory ‚Äî boss defeated!');
      }
    }

    // push line (frontline)
    var front = base.x+base.w;
    if(player.alive) front = Math.max(front,player.x);
    for(var f=0;f<friendlyTurrets.length;f++){
      var ftf=friendlyTurrets[f];
      if(ftf.alive) front=Math.max(front,ftf.x);
    }
    for(var at=0;at<alliedTroops.length;at++){
      var atr=alliedTroops[at];
      if(atr.alive) front=Math.max(front,atr.x);
    }
    pushLineX = front;
    var baseCenterX = base.x+base.w/2;
    var maxPushX = boss? boss.x : world.width;
    pushProgress = (front-baseCenterX)/(maxPushX-baseCenterX);
    pushProgress = pushProgress<0?0:(pushProgress>1?1:pushProgress);

    // camera follow player
    var camTargetX = player.x;
    var camTargetY = player.y;
    cameraX = clamp(camTargetX, canvas.width/window.devicePixelRatio/2, world.width - canvas.width/window.devicePixelRatio/2);
    cameraY = clamp(camTargetY, canvas.height/window.devicePixelRatio/2, world.height - canvas.height/window.devicePixelRatio/2);
  }

  // ---------- Enemy spawning ----------
  function spawnEnemy(){
    var aliveCount=0;
    for(var i=0;i<enemies.length;i++){
      if(enemies[i].alive) aliveCount++;
    }
    if(aliveCount>55) return;

    // pick a lane: 0=top,1=mid,2=bot
    var laneIndex = Math.floor(Math.random()*LANES.length);
    var lane = LANES[laneIndex];

    var x = randRange(world.width-400, world.width-120);
    var y = clamp(lane.y + randRange(-80,80), 80, world.height-80);

    var t;
    if(timeElapsed<45){
      var r1 = Math.random();
      if(r1<0.65) t='bug';
      else if(r1<0.9) t='alien';
      else t='fast';
    }else if(timeElapsed<110){
      var r2=Math.random();
      if(r2<0.30) t='bug';
      else if(r2<0.55) t='fast';
      else if(r2<0.75) t='alien';
      else if(r2<0.9) t='tank';
      else t='laser';
    }else{
      var r3=Math.random();
      if(r3<0.16) t='bug';
      else if(r3<0.30) t='fast';
      else if(r3<0.46) t='alien';
      else if(r3<0.62) t='tank';
      else if(r3<0.78) t='laser';
      else if(r3<0.9) t='dash';
      else t='scatter';
    }

    var enemy;
    if(t==='bug'){
      enemy = {
        kind:'bug',
        emoji:'üêú',
        x:x,y:y,
        size:18,
        maxHP:40,
        hp:40,
        speed:70,
        dmg:6,
        dps:10,
        xp:5,
        range:18,
        alive:true
      };
    }else if(t==='fast'){
      enemy = {
        kind:'fast',
        emoji:'üêù',
        x:x,y:y,
        size:16,
        maxHP:32,
        hp:32,
        speed:140,
        dmg:5,
        dps:9,
        xp:7,
        range:18,
        alive:true
      };
    }else if(t==='tank'){
      enemy = {
        kind:'tank',
        emoji:'ü™≤',
        x:x,y:y,
        size:26,
        maxHP:130,
        hp:130,
        speed:45,
        dmg:14,
        dps:18,
        xp:12,
        range:24,
        alive:true
      };
    }else if(t==='alien'){
      enemy = {
        kind:'alien',
        emoji:'üëæ',
        x:x,y:y,
        size:22,
        maxHP:75,
        hp:75,
        speed:60,
        dmg:10,
        dps:0,
        xp:10,
        range:230,
        fireCooldown:1.5,
        fireTimer:0,
        alive:true
      };
    }else if(t==='laser'){
      enemy = {
        kind:'laser',
        emoji:'üï∑',
        x:x,y:y,
        size:22,
        maxHP:85,
        hp:85,
        speed:55,
        dmg:0,
        dps:0,
        xp:14,
        range:0,
        alive:true,
        arcRange:230,
        arcWidth:Math.PI/2.8,
        arcCooldown:5.0,
        arcTimer:2.5,
        arcDuration:1.4,
        arcActiveTime:0,
        arcAngle:0,
        sweepDir:1,
        minAngle:-Math.PI/3,
        maxAngle:Math.PI/3,
        sweepSpeed:1.8
      };
    }else if(t==='scatter'){
      enemy = {
        kind:'scatter',
        emoji:'ü¶Ä',
        x:x,y:y,
        size:22,
        maxHP:95,
        hp:95,
        speed:60,
        dmg:8,
        dps:0,
        xp:15,
        range:260,
        fireCooldown:2.8,
        fireTimer:0,
        alive:true
      };
    }else{
      // dash
      enemy = {
        kind:'dash',
        emoji:'ü¶Ç',
        x:x,y:y,
        size:20,
        maxHP:65,
        hp:65,
        speed:90,
        dmg:20,
        dps:0,
        xp:13,
        range:18,
        alive:true,
        state:'normal',
        dashCooldownMax:5,
        dashCooldown:2+Math.random()*2,
        dashStateTimer:0,
        dashTargetX:x,
        dashTargetY:y,
        dashSpeed:320,
        dashDamage:45,
        dashRange:260,
        dashVx:0,
        dashVy:0
      };
    }
    enemies.push(enemy);
  }

  // ---------- Drawing ----------
  function worldToScreen(wx,wy){
    var sx = wx - cameraX + canvas.width/window.devicePixelRatio/2;
    var sy = wy - cameraY + canvas.height/window.devicePixelRatio/2;
    return {x:sx,y:sy};
  }

  function render(){
    var w = canvas.width/window.devicePixelRatio;
    var h = canvas.height/window.devicePixelRatio;
    ctx.clearRect(0,0,w,h);

    // background grid
    ctx.save();
    ctx.fillStyle='#020617';
    ctx.fillRect(0,0,w,h);
    ctx.strokeStyle='#0b1220';
    ctx.lineWidth=1;
    var gridSize=60;
    var camOffsetX = cameraX%gridSize;
    var camOffsetY = cameraY%gridSize;
    for(var gx=-camOffsetX;gx<w;gx+=gridSize){
      ctx.beginPath();ctx.moveTo(gx,0);ctx.lineTo(gx,h);ctx.stroke();
    }
    for(var gy=-camOffsetY;gy<h;gy+=gridSize){
      ctx.beginPath();ctx.moveTo(0,gy);ctx.lineTo(w,gy);ctx.stroke();
    }
    ctx.restore();

    // base
    if(base){
      var bc = worldToScreen(base.x+base.w/2,base.y+base.h/2);
      ctx.fillStyle='#111827';
      ctx.fillRect(bc.x-base.w/2,bc.y-base.h/2,base.w,base.h);
      ctx.strokeStyle=base.alive?'#22c55e':'#991b1b';
      ctx.lineWidth=3;
      ctx.strokeRect(bc.x-base.w/2,bc.y-base.h/2,base.w,base.h);
      drawBar(bc.x-50,bc.y-base.h/2-10,100,5, base.hp/base.maxHP,'#1f2937','#22c55e');
    }

    // friendly turrets
    for(var i=0;i<friendlyTurrets.length;i++){
      var t=friendlyTurrets[i];
      var ts=worldToScreen(t.x,t.y);
      if(!t.alive) ctx.globalAlpha=0.3;
      ctx.beginPath();
      ctx.moveTo(ts.x,ts.y-t.size);
      ctx.lineTo(ts.x-t.size*0.9,ts.y+t.size*0.8);
      ctx.lineTo(ts.x+t.size*0.9,ts.y+t.size*0.8);
      ctx.closePath();
      ctx.fillStyle='#0f766e';
      ctx.fill();
      ctx.strokeStyle='#99f6e4';
      ctx.lineWidth=2;
      ctx.stroke();
      drawBar(ts.x-18,ts.y+t.size+2,36,4,t.hp/t.maxHP,'#1f2937','#22c55e');
      ctx.globalAlpha=1;
    }

    // enemy turrets
    for(var j=0;j<enemyTurrets.length;j++){
      var et=enemyTurrets[j];
      var es=worldToScreen(et.x,et.y);
      if(!et.alive) ctx.globalAlpha=0.35;
      ctx.beginPath();
      ctx.moveTo(es.x,es.y-et.size);
      ctx.lineTo(es.x-et.size*0.9,es.y+et.size*0.8);
      ctx.lineTo(es.x+et.size*0.9,es.y+et.size*0.8);
      ctx.closePath();
      ctx.fillStyle='#7f1d1d';
      ctx.fill();
      ctx.strokeStyle='#fecaca';
      ctx.lineWidth=2;
      ctx.stroke();
      drawBar(es.x-20,es.y+et.size+3,40,4,et.hp/et.maxHP,'#1f2937','#ef4444');
      ctx.globalAlpha=1;
    }

    // boss
    if(boss){
      var bs = worldToScreen(boss.x,boss.y);
      ctx.beginPath();
      ctx.arc(bs.x,bs.y,boss.size,0,Math.PI*2);
      ctx.fillStyle=boss.alive?'#7c2d12':'#1f2937';
      ctx.fill();
      ctx.strokeStyle='#f97316';
      ctx.lineWidth=3;
      ctx.stroke();
      drawBar(bs.x-60,bs.y-boss.size-10,120,6,boss.hp/boss.maxHP,'#1f2937','#ef4444');
      ctx.fillStyle='#fed7aa';
      ctx.font='16px system-ui';
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.fillText('üëπ',bs.x,bs.y+6);
    }

    // hero
    var ps = worldToScreen(player.x,player.y);
    ctx.fillStyle=player.alive?'#38bdf8':'#64748b';
    ctx.fillRect(ps.x-player.size/2,ps.y-player.size/2,player.size,player.size);
    ctx.strokeStyle='#f9fafb';
    ctx.lineWidth=2;
    ctx.strokeRect(ps.x-player.size/2,ps.y-player.size/2,player.size,player.size);
    drawBar(ps.x-24,ps.y-player.size/2-8,48,4,player.hp/player.maxHP,'#1f2937','#22c55e');

    // allied troops
    for(var a=0;a<alliedTroops.length;a++){
      var tr=alliedTroops[a];
      if(!tr.alive) continue;
      var ts=worldToScreen(tr.x,tr.y);
      ctx.fillStyle='#16a34a';
      ctx.fillRect(ts.x-tr.size/2,ts.y-tr.size/2,tr.size,tr.size);
      ctx.strokeStyle='#bbf7d0';
      ctx.lineWidth=1.5;
      ctx.strokeRect(ts.x-tr.size/2,ts.y-tr.size/2,tr.size,tr.size);
      drawBar(ts.x-14,ts.y-tr.size/2-6,28,3,tr.hp/tr.maxHP,'#1f2937','#22c55e');
    }

    // enemies
    ctx.font='20px system-ui';
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    for(var eIdx=0;eIdx<enemies.length;eIdx++){
      var en=enemies[eIdx];
      if(!en.alive) continue;
      var es2=worldToScreen(en.x,en.y);
      ctx.fillStyle='#0f172a';
      ctx.beginPath();
      ctx.arc(es2.x,es2.y,en.size,0,Math.PI*2);
      ctx.fill();
      ctx.fillStyle='#fef9c3';
      ctx.fillText(en.emoji,es2.x,es2.y+1);
      drawBar(es2.x-en.size,es2.y-en.size-7,en.size*2,4,en.hp/en.maxHP,'#1f2937','#f97316');

      // laser arc visual
      if(en.kind==='laser' && en.arcActiveTime>0){
        var frac=en.arcActiveTime/en.arcDuration;
        ctx.beginPath();
        ctx.arc(es2.x,es2.y,en.arcRange,
                en.arcAngle - en.arcWidth/2,
                en.arcAngle + en.arcWidth/2);
        ctx.strokeStyle='rgba(251,113,133,'+(0.2+0.4*frac)+')';
        ctx.lineWidth=5;
        ctx.stroke();
      }
      // dash telegraph
      if(en.kind==='dash' && en.state==='windup'){
        var tx = worldToScreen(en.dashTargetX,en.dashTargetY);
        ctx.save();
        ctx.strokeStyle='rgba(248,113,113,0.9)';
        ctx.setLineDash([4,5]);
        ctx.beginPath();
        ctx.moveTo(es2.x,es2.y);
        ctx.lineTo(tx.x,tx.y);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
      }
      // freeze ring
      if(en.freezeTimer && en.freezeTimer>0){
        ctx.beginPath();
        ctx.arc(es2.x,es2.y,en.size+4,0,Math.PI*2);
        ctx.strokeStyle='rgba(56,189,248,0.85)';
        ctx.lineWidth=2;
        ctx.stroke();
      }
    }

    // hitscan beams & chain arcs
    for(var bi=0;bi<beams.length;bi++){
      var bm=beams[bi];
      var s1 = worldToScreen(bm.x1,bm.y1);
      var s2 = worldToScreen(bm.x2,bm.y2);
      var alpha = bm.life/0.08;
      ctx.save();
      var col = bm.color || '#e5e7eb';
      // parse rgb from color string if needed? keep simple: treat as full alpha
      if(col.indexOf('#')===0){
        ctx.strokeStyle = col;
        ctx.globalAlpha = alpha;
      }else{
        ctx.strokeStyle = col;
      }
      ctx.lineWidth = (bm.color==='#a855f7'?3:2);
      ctx.beginPath();
      ctx.moveTo(s1.x,s1.y);
      ctx.lineTo(s2.x,s2.y);
      ctx.stroke();
      ctx.restore();
    }

    // bullets
    for(var bIdx=0;bIdx<bullets.length;bIdx++){
      var bl=bullets[bIdx];
      if(!bl) continue;
      var bs2=worldToScreen(bl.x,bl.y);

      if(bl.type==='missile'){
        ctx.save();
        var ang = Math.atan2(bl.vy,bl.vx);
        ctx.translate(bs2.x,bs2.y);
        ctx.rotate(ang);
        ctx.beginPath();
        ctx.moveTo(7,0);
        ctx.lineTo(-4,3);
        ctx.lineTo(-4,-3);
        ctx.closePath();
        ctx.fillStyle = bl.side==='friendly' ? '#e5e7eb' : '#fb7185';
        ctx.fill();
        ctx.restore();
      }else{
        ctx.beginPath();
        var r = (bl.side==='friendly'?3:4);
        ctx.arc(bs2.x,bs2.y,r,0,Math.PI*2);
        ctx.fillStyle = bl.side==='friendly' ? '#e5e7eb' : '#fb7185';
        ctx.fill();
      }
    }

    // missiles (boss)
    for(var m=0;m<missiles.length;m++){
      var ms=missiles[m];
      var msS=worldToScreen(ms.x,ms.y);
      ctx.beginPath();
      ctx.arc(msS.x,msS.y,ms.radius,0,Math.PI*2);
      ctx.fillStyle='#f97316';
      ctx.fill();
      ctx.strokeStyle='#fed7aa';
      ctx.lineWidth=2;
      ctx.stroke();
    }

    // explosions
    for(var ex=0;ex<explosions.length;ex++){
      var exo=explosions[ex];
      var t = exo.life/0.45;
      var rNow = exo.maxRadius * (1-t);
      var exs=worldToScreen(exo.x,exo.y);
      ctx.beginPath();
      ctx.arc(exs.x,exs.y,rNow,0,Math.PI*2);
      ctx.strokeStyle='rgba(248,250,252,'+t+')';
      ctx.lineWidth=4;
      ctx.stroke();
    }

    // floating damage numbers
    ctx.font='11px system-ui';
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    for(var di=0;di<damageTexts.length;di++){
      var dtxt = damageTexts[di];
      var s = worldToScreen(dtxt.x,dtxt.y);
      var alpha = dtxt.life/0.7;
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = dtxt.color;
      ctx.fillText(dtxt.text,s.x,s.y);
      ctx.restore();
    }

    // push line (frontline)
    var pls = worldToScreen(pushLineX,0);
    if(pls.x>=-10 && pls.x<=w+10){
      ctx.save();
      ctx.strokeStyle='rgba(56,189,248,0.7)';
      ctx.setLineDash([6,6]);
      ctx.beginPath();
      ctx.moveTo(pls.x,0);
      ctx.lineTo(pls.x,h);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }

    // push progress bar bottom
    var barW = w*0.6;
    var barX = w*0.2;
    var barY = h-14;
    drawBar(barX,barY,barW,6,pushProgress,'#020617','#38bdf8');

    // HUD text values
    hudLevel.textContent='Lv '+player.level;
    hudHP.textContent='HP '+Math.round(player.hp)+' / '+player.maxHP;
    hudBase.textContent='Base '+Math.round(base.hp)+' / '+base.maxHP;
    hudXP.textContent='XP '+Math.round(player.xp)+' / '+player.xpNext;
    hudCredits.textContent='‚òÖ '+credits;

    if(!player.alive && !gameOver){
      setOverlay('You died ‚Äî respawn in '+Math.ceil(player.respawnTimer)+'s');
    }else if(!gameOver){
      setOverlay('');
    }
  }

  // ---------- Game loop ----------
  function loop(now){
    var dt = (now-lastTime)/1000;
    if(dt>0.05) dt=0.05;
    lastTime=now;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // restart on overlay after game over
  overlayEl.addEventListener('click',function(){
    if(gameOver){
      resetGame();
    }
  });
})();
</script>
</body>
</html>





