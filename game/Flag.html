<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Chess Lite â€” Factions & Cooldowns</title>
<style>
  :root{
    --bg:#020617; --panel:#020617; --line:#1e293b; --muted:#9ca3af; --text:#e5e7eb;
    --order:#60a5fa; --chaos:#f97373; --void:#a855f7;
    --sel:#eab308;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--text);
    font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;
    background:radial-gradient(900px 500px at 20% 0%, #0f172a 0%, #020617 55%, #000 100%);
  }
  .wrap{
    display:grid;
    grid-template-columns: minmax(0,380px) minmax(0,360px);
    gap:16px;
    padding:12px;
  }
  @media (max-width: 800px){
    .wrap{
      grid-template-columns: minmax(0,1fr);
    }
  }

  .board-wrap{
    background:var(--panel);
    border-radius:14px;
    border:1px solid var(--line);
    padding:10px;
    box-shadow:0 12px 36px rgba(0,0,0,.4);
  }
  .board-header{
    display:flex; flex-wrap:wrap;
    gap:8px; margin-bottom:8px;
    align-items:center;
  }
  .pill{
    padding:5px 9px; border-radius:999px;
    font-size:12px;
    border:1px solid var(--line);
    background:#020617;
    color:var(--muted);
    display:inline-flex;
    align-items:center;
    gap:4px;
  }

  .board{
    --tile: min(14vw, 58px);
    display:grid;
    grid-template-columns:repeat(6, var(--tile));
    grid-template-rows:repeat(6, var(--tile));
    gap:2px;
    justify-content:center;
    margin:auto;
  }
  @media (max-width: 600px){
    .board{
      --tile: min(18vw, 54px);
    }
  }

  .tile{
    width:var(--tile);
    height:var(--tile);
    border-radius:10px;
    position:relative;
    display:flex;
    align-items:center;
    justify-content:center;
    cursor:pointer;
    user-select:none;
    background:radial-gradient(circle at 30% 20%, #111827 0, #020617 55%);
    border:1px solid rgba(15,23,42,.9);
    box-shadow:inset 0 0 0 1px rgba(15,23,42,.7);
  }
  .tile:hover{filter:brightness(1.1);}
  .tile.sel{
    outline:2px solid var(--sel);
    outline-offset:-2px;
  }
  .tile.move-ok{
    box-shadow:0 0 0 2px rgba(56,189,248,.6), inset 0 0 0 1px rgba(15,23,42,.9);
  }
  .tile.attack-ok{
    box-shadow:0 0 0 2px rgba(248,113,113,.7), inset 0 0 0 1px rgba(15,23,42,.9);
  }
  .tile.trap{
    background:radial-gradient(circle at 50% 30%, #4c1d95 0,#020617 60%);
  }

  .piece{
    position:relative;
    font-size:28px;
    filter:drop-shadow(0 1px 0 rgba(0,0,0,.75));
    z-index:2;
  }

  @keyframes movePulse {
    0%{transform:scale(1);}
    50%{transform:scale(1.12);}
    100%{transform:scale(1);}
  }
  @keyframes hitShake {
    0%,100%{transform:translateX(0);}
    25%{transform:translateX(-2px);}
    50%{transform:translateX(2px);}
    75%{transform:translateX(-1px);}
  }

  .cd-container{
    position:absolute;
    left:50%; transform:translateX(-50%);
    bottom:100%; margin-bottom:4px;
    width:80%;
    display:flex;
    flex-direction:column;
    gap:2px;
    z-index:3;
  }
  .cd-bar{
    width:100%; height:5px;
    background:rgba(15,23,42,.9);
    border-radius:999px;
    overflow:hidden;
    border:1px solid rgba(148,163,184,.7);
  }
  .cd-inner{
    height:100%; width:100%;
    transform-origin:left center;
  }
  .cd-move .cd-inner{background:#22d3ee;}
  .cd-ability .cd-inner{background:#facc15;}

  .hp-chip{
    position:absolute;
    right:4px; bottom:4px;
    padding:1px 5px;
    font-size:11px;
    border-radius:999px;
    background:rgba(15,23,42,.9);
    border:1px solid rgba(148,163,184,.8);
    z-index:3;
  }
  .king-badge{
    position:absolute;
    left:4px; bottom:4px;
    font-size:13px;
    text-shadow:0 1px 2px rgba(0,0,0,.8);
  }
  .king-icon{
    position:absolute;
    left:50%;
    bottom:-4px;
    transform:translateX(-50%);
    font-size:14px;
    text-shadow:0 1px 2px rgba(0,0,0,.9);
  }

  .side{
    background:var(--panel);
    border-radius:14px;
    border:1px solid var(--line);
    padding:10px;
    box-shadow:0 10px 28px rgba(0,0,0,.4);
  }
  h1{
    margin:0 0 8px;
    font-size:19px;
    color:#e5e7eb;
  }

  .row{display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin:4px 0;}

  button{
    background:#020617;
    color:var(--text);
    border-radius:999px;
    border:1px solid var(--line);
    padding:7px 11px;
    cursor:pointer;
    font-size:13px;
  }
  button:hover{background:#020617ee;}
  button:disabled{opacity:.4; cursor:not-allowed;}
  .faction-btn.active{
    border-color:#facc15;
    box-shadow:0 0 0 1px rgba(250,204,21,.3);
  }

  select{
    background:#020617;
    color:var(--text);
    border-radius:999px;
    border:1px solid var(--line);
    padding:5px 9px;
    font-size:13px;
  }

  .unit-panel{
    margin-top:6px;
    border-radius:12px;
    border:1px solid var(--line);
    padding:8px;
    background:#020617;
  }
  .unit-title{
    display:flex; gap:8px; align-items:center;
    margin-bottom:4px;
  }
  .unit-title span.emoji{font-size:24px;}
  .unit-name{font-weight:600;}
  .unit-stats{font-size:12px; color:#d1d5db;}

  .action-btns{display:flex; flex-wrap:wrap; gap:8px; margin-top:6px;}

  .help-box{
    margin-top:8px;
    border-radius:12px;
    border:1px solid var(--line);
    padding:7px 9px;
    background:#020617;
    font-size:12px;
    color:#e5e7eb;
  }
  .log-box{
    margin-top:8px;
    border-radius:12px;
    border:1px solid var(--line);
    padding:7px 9px;
    background:#020617;
  }
  .log-title{font-size:13px; margin-bottom:3px;}
  .log{max-height:200px; overflow:auto; font-size:12px; color:#d1d5db;}
  .log p{margin:1px 0;}

  .toast{
    position:fixed;
    left:50%; bottom:12px;
    transform:translateX(-50%);
    background:#020617;
    border-radius:999px;
    border:1px solid var(--line);
    padding:7px 13px;
    font-size:13px;
    color:#e5e7eb;
    box-shadow:0 8px 24px rgba(0,0,0,.6);
    display:none;
    z-index:20;
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="board-wrap">
    <div class="board-header">
      <span class="pill">Faction:
        <button id="btnOrder" class="faction-btn">Order</button>
        <button id="btnChaos" class="faction-btn">Chaos</button>
        <button id="btnVoid"  class="faction-btn">Void</button>
      </span>
      <span class="pill">AI Difficulty:
        <select id="difficulty">
          <option value="slow">Slow</option>
          <option value="normal" selected>Normal</option>
          <option value="fast">Fast</option>
          <option value="insane">Insane</option>
        </select>
      </span>
      <button id="btnStart">Start / Restart</button>
    </div>
    <div class="board-header">
      <span class="pill">Status: <b id="statusText">Pick a faction & difficulty, then Start.</b></span>
    </div>
    <div id="board" class="board"></div>
  </div>

  <div class="side">
    <h1>Unit Detail & Commands</h1>
    <div class="row">
      <span class="pill">Time: <b id="timeDisp">0.0s</b></span>
      <span class="pill">Pieces â€” You: <b id="countP">0</b> â€¢ AI: <b id="countAI">0</b></span>
      <span class="pill" id="checkInfo">Check: â€”</span>
    </div>

    <div class="unit-panel">
      <div class="unit-title">
        <span class="emoji" id="unitEmoji">â¬š</span>
        <span class="unit-name" id="unitName">No unit selected</span>
      </div>
      <div class="unit-stats" id="unitStats">â€”</div>
      <div class="action-btns">
        <button id="btnMove">Move</button>
        <button id="btnAttack">Attack</button>
        <button id="btnAbility">Ability</button>
      </div>
    </div>

    <div class="help-box">
      <div><b>How it works</b></div>
      <ul style="margin:4px 0 0; padding-left:18px;">
        <li>Pick your <b>Faction</b> and <b>AI Difficulty</b>, then press Start.</li>
        <li>Each side has a <b>King</b> (â™” / â™š / â™› + icon). If your king dies, you lose.</li>
        <li>Pieces move in straight <b>orthogonal directions only</b> (no diagonals).</li>
        <li><b>Normal attacks are contact-only:</b> you must move onto an enemyâ€™s tile to hit it.</li>
        <li>If the enemy survives (HP &gt; 0), it gets <b>knocked</b> to a nearby open tile instead.</li>
        <li>Only <b>abilities</b> can hit at range or affect areas.</li>
        <li>Bars above pieces: <span style="color:#22d3ee">teal</span> = move/attack cooldown, <span style="color:#facc15">gold</span> = ability cooldown.</li>
      </ul>
    </div>

    <div class="log-box">
      <div class="log-title"><b>Battle Log</b></div>
      <div id="log" class="log"></div>
    </div>
  </div>
</div>

<div id="toast" class="toast"></div>

<script>
(function(){
  const BOARD_W = 6, BOARD_H = 6;

  const PIECES = {
    // ORDER
    order_king: {
      name:'Order King', emoji:'â™”', hp:3, dmg:1, move:1,
      moveCool:2.2, abilityCool:8.0,
      abilityKey:'order_aura', faction:'order', isKing:true,
      desc:'Order: adjacent allies share rhythm. Normal attack = step onto an enemy; survivors get knocked away. Ability: pulse that speeds nearby allies.'
    },
    order_guard: {
      name:'Sentinel', emoji:'ðŸ›¡ï¸', hp:3, dmg:1, move:1,
      moveCool:2.0, abilityCool:9.0,
      abilityKey:'order_shield', faction:'order', isKing:false,
      desc:'Sturdy defender. Ability: shield a neighboring ally (+1 HP).'
    },
    order_archer: {
      name:'Sky Archer', emoji:'ðŸ¹', hp:1, dmg:1, move:1,
      moveCool:2.4, abilityCool:9.5,
      abilityKey:'order_volley', faction:'order', isKing:false,
      desc:'Contact hit by stepping on enemies. Ability: ranged volley hitting up to two enemies in a line.'
    },
    order_mage: {
      name:'Circle Mage', emoji:'ðŸ”®', hp:2, dmg:1, move:1,
      moveCool:2.6, abilityCool:10.0,
      abilityKey:'order_swap', faction:'order', isKing:false,
      desc:'Coordinator. Ability: swap positions with a friendly unit within 2 tiles.'
    },

    // CHAOS
    chaos_king: {
      name:'Chaos King', emoji:'â™š', hp:3, dmg:1, move:1,
      moveCool:2.1, abilityCool:8.5,
      abilityKey:'chaos_quake', faction:'chaos', isKing:true,
      desc:'Ruler of mayhem. Ability: scramble nearby enemy cooldowns.'
    },
    chaos_imp: {
      name:'Warp Imp', emoji:'ðŸ˜ˆ', hp:1, dmg:1, move:2,
      moveCool:1.7, abilityCool:8.0,
      abilityKey:'chaos_blink', faction:'chaos', isKing:false,
      desc:'Fast harasser. Contact hit by stepping on enemies. Ability: blink behind an enemy and strike.'
    },
    chaos_reaver: {
      name:'Reaver', emoji:'ðŸ—¡ï¸', hp:2, dmg:2, move:1,
      moveCool:2.4, abilityCool:9.5,
      abilityKey:'chaos_backstab', faction:'chaos', isKing:false,
      desc:'Assassin. Ability: big bonus when striking from behind the enemy line.'
    },
    chaos_witch: {
      name:'Witch', emoji:'â˜ ï¸', hp:2, dmg:1, move:1,
      moveCool:2.5, abilityCool:10.0,
      abilityKey:'chaos_curse', faction:'chaos', isKing:false,
      desc:'Debuffer. Ability: curse a target so the next two hits deal +1.'
    },

    // VOID
    void_king: {
      name:'Void King', emoji:'â™›', hp:3, dmg:1, move:1,
      moveCool:2.3, abilityCool:8.5,
      abilityKey:'void_trapfield', faction:'void', isKing:true,
      desc:'Master of snares. Ability: lay trap tiles that root and wound whoever steps on them.'
    },
    void_warden: {
      name:'Warden', emoji:'â›“ï¸', hp:3, dmg:1, move:1,
      moveCool:2.2, abilityCool:9.0,
      abilityKey:'void_root', faction:'void', isKing:false,
      desc:'Controller. Ability: root an enemy in place for several seconds.'
    },
    void_shade: {
      name:'Shade', emoji:'ðŸ‘ï¸', hp:2, dmg:1, move:2,
      moveCool:2.0, abilityCool:9.5,
      abilityKey:'void_pull', faction:'void', isKing:false,
      desc:'Ambusher. Ability: pull an enemy one tile closer (into dangerâ€¦ or a trap).'
    },
    void_orb: {
      name:'Null Orb', emoji:'âš«', hp:1, dmg:1, move:1,
      moveCool:2.4, abilityCool:10.0,
      abilityKey:'void_blast', faction:'void', isKing:false,
      desc:'Mine-like. Ability: void blast damaging a small area.'
    }
  };

  const FACTION_ROWS = {
    order: ['order_guard','order_archer','order_mage','order_guard','order_archer','order_king'],
    chaos: ['chaos_imp','chaos_reaver','chaos_witch','chaos_imp','chaos_reaver','chaos_king'],
    void:  ['void_warden','void_shade','void_orb','void_warden','void_shade','void_king']
  };

  const DIFFICULTY_INTERVAL = {
    slow:   1.2,
    normal: 0.8,
    fast:   0.5,
    insane: 0.25
  };

  const boardEl     = document.getElementById('board');
  const logEl       = document.getElementById('log');
  const statusText  = document.getElementById('statusText');
  const timeDisp    = document.getElementById('timeDisp');
  const countP      = document.getElementById('countP');
  const countAI     = document.getElementById('countAI');
  const checkInfo   = document.getElementById('checkInfo');

  const unitEmoji   = document.getElementById('unitEmoji');
  const unitName    = document.getElementById('unitName');
  const unitStats   = document.getElementById('unitStats');
  const btnMove     = document.getElementById('btnMove');
  const btnAttack   = document.getElementById('btnAttack');
  const btnAbility  = document.getElementById('btnAbility');

  const btnOrder = document.getElementById('btnOrder');
  const btnChaos = document.getElementById('btnChaos');
  const btnVoid  = document.getElementById('btnVoid');
  const btnStart = document.getElementById('btnStart');
  const diffSel  = document.getElementById('difficulty');

  let state = {
    units: [],
    traps: [],
    now:0,
    running:false,
    winner:null,
    factionP:null,
    factionAI:null,
    difficulty:'normal',
    aiInterval:0.8,
    lastAiAct:0,
    selectedId:null,
    hintMode:null,
    hints:new Set(),
    animMove:new Set(),
    animHit:new Set(),
    checkOnP:false,
    checkOnAI:false
  };

  function id(){ return Math.random().toString(36).slice(2,9); }
  function key(x,y){ return x+','+y; }
  function isInside(x,y){ return x>=0 && y>=0 && x<BOARD_W && y<BOARD_H; }
  function pieceDef(u){ return PIECES[u.tKey]; }
  function getUnitAt(x,y){ return state.units.find(u=>u.hp>0 && u.x===x && u.y===y); }

  // ===== Faction selection =====
  function setFaction(f){
    state.factionP = f;
    const all = ['order','chaos','void'];
    const remaining = all.filter(x=>x!==f);
    state.factionAI = remaining[Math.floor(Math.random()*remaining.length)];
    btnOrder.classList.toggle('active', f==='order');
    btnChaos.classList.toggle('active', f==='chaos');
    btnVoid.classList.toggle('active',  f==='void');
    pushStatus();
  }

  btnOrder.onclick = ()=> setFaction('order');
  btnChaos.onclick = ()=> setFaction('chaos');
  btnVoid.onclick  = ()=> setFaction('void');

  diffSel.onchange = ()=>{
    state.difficulty = diffSel.value;
    state.aiInterval = DIFFICULTY_INTERVAL[state.difficulty] || 0.8;
    pushStatus();
  };

  function pushStatus(){
    if(!state.factionP){
      statusText.textContent = 'Pick a faction & difficulty, then Start.';
      return;
    }
    statusText.textContent = `You: ${state.factionP.toUpperCase()} Â· AI: ${state.factionAI.toUpperCase()} Â· Difficulty: ${state.difficulty}`;
  }

  // ===== Game start =====
  btnStart.onclick = ()=> startGame();

  function spawnUnit(side,tKey,x,y){
    const def = PIECES[tKey];
    state.units.push({
      id:id(),
      side,
      tKey,
      x,y,
      hp:def.hp,
      maxHp:def.hp,
      dmg:def.dmg,
      bonusDmg:0,
      moveCool:def.moveCool,
      abilityCool:def.abilityCool,
      nextMoveAt:0,
      nextAbilityAt:def.abilityCool*0.5,
      curseStacks:0,
      rootUntil:0
    });
  }

  function startGame(){
    if(!state.factionP){
      toast('Pick a faction first.');
      return;
    }
    state.units = [];
    state.traps = [];
    state.now = 0;
    state.running = true;
    state.winner = null;
    state.selectedId = null;
    state.hintMode = null;
    state.hints.clear();
    state.animMove.clear();
    state.animHit.clear();
    state.checkOnP = false;
    state.checkOnAI = false;
    state.difficulty = diffSel.value;
    state.aiInterval = DIFFICULTY_INTERVAL[state.difficulty] || 0.8;
    state.lastAiAct = 0;

    const rowP = FACTION_ROWS[state.factionP];
    for(let x=0;x<BOARD_W;x++){
      const tKey = rowP[x % rowP.length];
      spawnUnit('P', tKey, x, BOARD_H-1);
    }
    const rowAI = FACTION_ROWS[state.factionAI];
    for(let x=0;x<BOARD_W;x++){
      const tKey = rowAI[x % rowAI.length];
      spawnUnit('AI', tKey, x, 0);
    }

    logEl.innerHTML='';
    pushLog(`Game started. You = ${state.factionP.toUpperCase()}, AI = ${state.factionAI.toUpperCase()}, difficulty = ${state.difficulty}.`);
    pushStatus();
    render();
  }

  // ===== Rendering =====
  function cooldownRatio(now, nextAt, cool){
    if(cool<=0) return 1;
    if(now>=nextAt) return 1;
    const remaining = nextAt - now;
    const r = 1 - remaining / cool;
    return Math.max(0, Math.min(1,r));
  }

  function render(){
    boardEl.innerHTML='';
    const now = state.now;

    for(let y=0;y<BOARD_H;y++){
      for(let x=0;x<BOARD_W;x++){
        const tile = document.createElement('div');
        tile.className='tile';
        tile.dataset.x=x;
        tile.dataset.y=y;

        if(state.traps.some(t=>t.x===x && t.y===y)){
          tile.classList.add('trap');
        }

        const u = getUnitAt(x,y);

        const k = key(x,y);
        if(state.hintMode==='move' && state.hints.has(k)){
          tile.classList.add('move-ok');
        }
        if(state.hintMode==='attack' && u && state.hints.has('id:'+u.id)){
          tile.classList.add('attack-ok');
        }
        if(state.hintMode==='ability' && (state.hints.has(k) || (u && state.hints.has('id:'+u.id)))){
          tile.classList.add(u ? 'attack-ok' : 'move-ok');
        }

        if(u && state.selectedId===u.id){
          tile.classList.add('sel');
        }

        if(u){
          const def = pieceDef(u);
          const cdMoveRatio = cooldownRatio(now, u.nextMoveAt, u.moveCool);
          const cdAbRatio   = cooldownRatio(now, u.nextAbilityAt, u.abilityCool);

          const cdWrap = document.createElement('div');
          cdWrap.className='cd-container';
          const barM = document.createElement('div');
          barM.className='cd-bar cd-move';
          const inM = document.createElement('div');
          inM.className='cd-inner';
          inM.style.transform = 'scaleX('+cdMoveRatio.toFixed(3)+')';
          barM.appendChild(inM);
          const barA = document.createElement('div');
          barA.className='cd-bar cd-ability';
          const inA = document.createElement('div');
          inA.className='cd-inner';
          inA.style.transform = 'scaleX('+cdAbRatio.toFixed(3)+')';
          barA.appendChild(inA);
          cdWrap.appendChild(barM); cdWrap.appendChild(barA);
          tile.appendChild(cdWrap);

          const piece = document.createElement('div');
          piece.className='piece';
          piece.textContent = def.emoji;
          if(def.faction==='order') piece.style.color = 'var(--order)';
          else if(def.faction==='chaos') piece.style.color = 'var(--chaos)';
          else piece.style.color = 'var(--void)';

          if(state.animMove.has(u.id)){
            piece.style.animation='movePulse 0.25s ease-out';
          } else if(state.animHit.has(u.id)){
            piece.style.animation='hitShake 0.25s ease-out';
          }
          tile.appendChild(piece);

          const hp = document.createElement('div');
          hp.className='hp-chip';
          hp.textContent = `${u.hp}/${u.maxHp}`;
          tile.appendChild(hp);

          if(def.isKing){
            const kb=document.createElement('div');
            kb.className='king-badge';
            kb.textContent='â™›';
            tile.appendChild(kb);

            const ki=document.createElement('div');
            ki.className='king-icon';
            ki.textContent = def.faction==='order' ? 'âš–ï¸' : def.faction==='chaos' ? 'ðŸ”¥' : 'ðŸ•³ï¸';
            tile.appendChild(ki);
          }
        }

        tile.onclick = onTileClick;
        boardEl.appendChild(tile);
      }
    }

    state.animMove.clear();
    state.animHit.clear();

    timeDisp.textContent = state.now.toFixed(1)+'s';
    const pAlive = state.units.filter(u=>u.side==='P' && u.hp>0).length;
    const aAlive = state.units.filter(u=>u.side==='AI' && u.hp>0).length;
    countP.textContent = pAlive;
    countAI.textContent = aAlive;

    updateUnitPanel();
    updateCheckStatus();
    const chkP = state.checkOnP ? 'You' : null;
    const chkAI = state.checkOnAI ? 'AI' : null;
    if(!chkP && !chkAI) checkInfo.textContent = 'Check: â€”';
    else if(chkP && !chkAI) checkInfo.textContent = 'Check: on You';
    else if(!chkP && chkAI) checkInfo.textContent = 'Check: on AI';
    else checkInfo.textContent = 'Check: mutual chaos?!';
  }

  // ===== UI / panel =====
  function updateUnitPanel(){
    const u = state.units.find(x=>x.id===state.selectedId && x.hp>0);
    if(!u){
      unitEmoji.textContent='â¬š';
      unitName.textContent='No unit selected';
      unitStats.textContent='â€”';
      btnMove.disabled=true;
      btnAttack.disabled=true;
      btnAbility.disabled=true;
      return;
    }
    const def = pieceDef(u);
    const moveReady = (state.now>=u.nextMoveAt && !isRooted(u));
    const abReady   = (state.now>=u.nextAbilityAt);
    unitEmoji.textContent = def.emoji;
    unitName.textContent =
      `${def.name} â€” ${u.side==='P'?'You':'AI'}${def.isKing?' (King)':''}`;
    unitStats.textContent =
      `HP ${u.hp}/${u.maxHp} â€¢ Dmg ${u.dmg + u.bonusDmg} â€¢ Stride ${def.move} Â· ${def.desc}`;

    btnMove.disabled   = !(u.side==='P' && moveReady && state.running && !state.winner);
    btnAttack.disabled = !(u.side==='P' && moveReady && state.running && !state.winner);
    btnAbility.disabled= !(u.side==='P' && abReady   && state.running && !state.winner);

    btnMove.textContent   = moveReady ? 'Move' : 'Move (cooling / rooted)';
    btnAttack.textContent = moveReady ? 'Attack (contact)' : 'Attack (cooling / rooted)';
    btnAbility.textContent= abReady ? 'Ability' : 'Ability (cooling)';
  }

  btnMove.onclick = ()=> setHintMode('move');
  btnAttack.onclick = ()=> setHintMode('attack');
  btnAbility.onclick = ()=> setHintMode('ability');

  // ===== Movement / targeting helpers =====
  function manhattan(a,b){ return Math.abs(a.x-b.x)+Math.abs(a.y-b.y); }
  function isRooted(u){ return state.now < (u.rootUntil || 0); }

  function reachableTiles(u, steps){
    if(isRooted(u)) return new Set();
    const visited = new Set([key(u.x,u.y)]);
    const q=[{x:u.x,y:u.y,d:0}];
    const res=new Set();
    while(q.length){
      const cur=q.shift();
      const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of dirs){
        const nx=cur.x+dx, ny=cur.y+dy;
        if(!isInside(nx,ny)) continue;
        const k=key(nx,ny);
        if(visited.has(k)) continue;
        if(getUnitAt(nx,ny)) continue;
        const nd=cur.d+1;
        if(nd>steps) continue;
        visited.add(k);
        res.add(k);
        q.push({x:nx,y:ny,d:nd});
      }
    }
    return res;
  }

  function canReachEnemyContact(u, target, steps){
    if(u.side===target.side) return false;
    if(isRooted(u)) return false;
    const visited = new Set([key(u.x,u.y)]);
    const q=[{x:u.x,y:u.y,d:0}];
    while(q.length){
      const cur=q.shift();
      const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of dirs){
        const nx=cur.x+dx, ny=cur.y+dy;
        if(!isInside(nx,ny)) continue;
        const k=key(nx,ny);
        if(visited.has(k)) continue;
        const occ = getUnitAt(nx,ny);
        const nd = cur.d+1;
        if(nd>steps) continue;
        if(occ && occ.id!==target.id) continue; // cannot move through others
        if(occ && occ.id===target.id){
          return true;
        }
        visited.add(k);
        q.push({x:nx,y:ny,d:nd});
      }
    }
    return false;
  }

  function contactTargets(u){
    const def = pieceDef(u);
    const res=[];
    for(const v of state.units){
      if(v.hp<=0 || v.side===u.side) continue;
      if(canReachEnemyContact(u,v,def.move)) res.push(v);
    }
    return res;
  }

  function enemiesInRange(u, range){
    return state.units.filter(v=>v.hp>0 && v.side!==u.side && manhattan(u,v)<=range);
  }

  // traps & knockback
  function triggerTrapAt(u){
    const idx = state.traps.findIndex(t=>t.x===u.x && t.y===u.y);
    if(idx===-1) return;
    state.traps.splice(idx,1);
    u.hp -= 1;
    u.rootUntil = state.now + 3.5;
    state.animHit.add(u.id);
    pushLog(`${pieceDef(u).name} stepped on a Void trap! -1 HP and rooted.`);
    if(u.hp<=0){
      pushLog(`${pieceDef(u).name} was destroyed by a trap.`);
      checkKingsAlive();
    }
  }

  function knockbackTarget(attacker,target){
    if(target.hp<=0) return;
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    let best=null;
    for(const [dx,dy] of dirs){
      const nx=target.x+dx, ny=target.y+dy;
      if(!isInside(nx,ny)) continue;
      if(getUnitAt(nx,ny)) continue;
      const dist = manhattan({x:nx,y:ny}, attacker);
      if(!best || dist>best.dist) best={x:nx,y:ny,dist};
    }
    if(best){
      target.x=best.x; target.y=best.y;
      state.animHit.add(target.id);
      triggerTrapAt(target);
      pushLog(`${pieceDef(target).name} was knocked back.`);
    } else {
      // nowhere to go: crushed
      target.hp=0;
      state.animHit.add(target.id);
      pushLog(`${pieceDef(target).name} had nowhere to go and was crushed.`);
      checkKingsAlive();
    }
  }

  // ===== Hinting & clicks =====
  function setHintMode(mode){
    const u = state.units.find(x=>x.id===state.selectedId && x.hp>0);
    if(!u || u.side!=='P'){
      toast('Select one of your pieces first.');
      return;
    }
    if(!state.running || state.winner) return;
    if((mode==='move' || mode==='attack') && (state.now<u.nextMoveAt || isRooted(u))){
      toast('Move/attack still cooling or rooted.');
      return;
    }
    if(mode==='ability' && state.now<u.nextAbilityAt){
      toast('Ability still cooling.');
      return;
    }

    state.hintMode=mode;
    state.hints.clear();
    const def = pieceDef(u);

    if(mode==='move'){
      const reach = reachableTiles(u, def.move);
      for(const k of reach) state.hints.add(k);
    } else if(mode==='attack'){
      const targets = contactTargets(u);
      for(const t of targets) state.hints.add('id:'+t.id);
    } else if(mode==='ability'){
      abilityHints(u);
    }
    render();
  }

  function abilityHints(u){
    const def = pieceDef(u);
    const keyAb = def.abilityKey;
    const r = 3;

    if(keyAb==='order_aura' || keyAb==='chaos_quake'){
      state.hints.add('id:'+u.id);
    } else if(keyAb==='order_shield'){
      const allies = state.units.filter(v=>v.hp>0 && v.side===u.side && v.id!==u.id && manhattan(u,v)===1);
      for(const a of allies) state.hints.add('id:'+a.id);
    } else if(keyAb==='order_volley'){
      const foes = state.units.filter(v=>v.hp>0 && v.side!==u.side && (v.x===u.x || v.y===u.y) && manhattan(u,v)<=3);
      for(const f of foes) state.hints.add('id:'+f.id);
    } else if(keyAb==='order_swap'){
      const allies = state.units.filter(v=>v.hp>0 && v.side===u.side && v.id!==u.id && manhattan(u,v)<=2);
      for(const a of allies) state.hints.add('id:'+a.id);
    } else if(keyAb==='chaos_blink' || keyAb==='chaos_backstab'){
      const foes = enemiesInRange(u,2);
      for(const f of foes) state.hints.add('id:'+f.id);
    } else if(keyAb==='chaos_curse'){
      const foes = enemiesInRange(u,2);
      for(const f of foes) state.hints.add('id:'+f.id);
    } else if(keyAb==='void_trapfield' || keyAb==='void_blast'){
      for(let y=0;y<BOARD_H;y++){
        for(let x=0;x<BOARD_W;x++){
          if(manhattan(u,{x,y})<=r) state.hints.add(key(x,y));
        }
      }
    } else if(keyAb==='void_root' || keyAb==='void_pull'){
      const foes = enemiesInRange(u,3);
      for(const f of foes) state.hints.add('id:'+f.id);
    }
  }

  function onTileClick(e){
    const x = +e.currentTarget.dataset.x;
    const y = +e.currentTarget.dataset.y;
    const u = getUnitAt(x,y);

    const sel = state.units.find(w=>w.id===state.selectedId && w.hp>0);

    if(sel && sel.side==='P' && state.running && !state.winner){
      if(state.hintMode==='move' && state.hints.has(key(x,y))){
        doMove(sel,x,y);
        return;
      }
      if(state.hintMode==='attack' && u && state.hints.has('id:'+u.id)){
        doAttack(sel,u);
        return;
      }
      if(state.hintMode==='ability'){
        resolveAbilityClick(sel,u,x,y);
        return;
      }
    }

    if(u){
      state.selectedId = u.id;
      state.hintMode = null;
      state.hints.clear();
      render();
    }
  }

  // ===== Actions =====
  function setMoveCooldown(u){
    let duration = u.moveCool;
    const def = pieceDef(u);
    if(def.faction==='order'){
      const alliesAdj = state.units.filter(v=>v.hp>0 && v.side===u.side && v.id!==u.id && manhattan(u,v)===1).length;
      const mult = Math.max(0.6, 1 - alliesAdj*0.15);
      duration *= mult;
    }
    u.nextMoveAt = state.now + duration;
  }

  function doMove(u,tx,ty){
    if(state.now<u.nextMoveAt || isRooted(u)){
      toast('Move still cooling or rooted.');
      return;
    }
    if(getUnitAt(tx,ty)){
      toast('Cannot move onto another piece (use Attack to land on them).');
      return;
    }
    if(!reachableTiles(u, pieceDef(u).move).has(key(tx,ty))){
      toast('Not reachable.');
      return;
    }
    u.x=tx; u.y=ty;
    triggerTrapAt(u);
    state.animMove.add(u.id);
    setMoveCooldown(u);
    pushLog(`${sideName(u.side)} ${pieceDef(u).name} moved.`);
    postAction();
  }

  function doAttack(attacker,target){
    if(state.now<attacker.nextMoveAt || isRooted(attacker)){
      toast('Attack still cooling or rooted.');
      return;
    }
    const defA = pieceDef(attacker);
    if(!canReachEnemyContact(attacker,target,defA.move)){
      toast('Target not reachable by contact.');
      return;
    }

    // Step onto target's tile
    attacker.x = target.x;
    attacker.y = target.y;

    let dmg = defA.dmg + attacker.bonusDmg;
    if(target.curseStacks>0) dmg += 1;
    target.hp -= dmg;
    attacker.bonusDmg = 0;
    state.animMove.add(attacker.id);
    state.animHit.add(target.id);
    pushLog(`${sideName(attacker.side)} ${defA.name} slammed into ${pieceDef(target).name} for ${dmg}.`);
    setMoveCooldown(attacker);

    if(target.hp<=0){
      pushLog(`${pieceDef(target).name} was destroyed.`);
      checkKingsAlive();
    } else {
      knockbackTarget(attacker,target);
    }

    triggerTrapAt(attacker);
    postAction();
  }

  function postAction(){
    state.hintMode=null;
    state.hints.clear();
    render();
  }

  // ===== Abilities =====
  function eachEnemyAround(u, radius, cb){
    for(const v of state.units){
      if(v.hp<=0 || v.side===u.side) continue;
      if(manhattan(u,v)<=radius) cb(v);
    }
  }

  function resolveAbilityClick(u,target,x,y){
    const def = pieceDef(u);
    const ak = def.abilityKey;
    const now = state.now;
    if(now<u.nextAbilityAt){
      toast('Ability still cooling.');
      return;
    }

    const tileK = key(x,y);

    if(ak==='order_aura' && state.hints.has('id:'+u.id)){
      abilityOrderAura(u);
    } else if(ak==='order_shield' && target && state.hints.has('id:'+target.id)){
      abilityOrderShield(u,target);
    } else if(ak==='order_volley' && target && state.hints.has('id:'+target.id)){
      abilityOrderVolley(u,target);
    } else if(ak==='order_swap' && target && state.hints.has('id:'+target.id)){
      abilityOrderSwap(u,target);
    } else if(ak==='chaos_quake' && state.hints.has('id:'+u.id)){
      abilityChaosQuake(u);
    } else if(ak==='chaos_blink' && target && state.hints.has('id:'+target.id)){
      abilityChaosBlink(u,target);
    } else if(ak==='chaos_backstab' && target && state.hints.has('id:'+target.id)){
      abilityChaosBackstab(u,target);
    } else if(ak==='chaos_curse' && target && state.hints.has('id:'+target.id)){
      abilityChaosCurse(u,target);
    } else if(ak==='void_trapfield' && state.hints.has(tileK)){
      abilityVoidTrapfield(u,{x,y});
    } else if(ak==='void_root' && target && state.hints.has('id:'+target.id)){
      abilityVoidRoot(u,target);
    } else if(ak==='void_pull' && target && state.hints.has('id:'+target.id)){
      abilityVoidPull(u,target);
    } else if(ak==='void_blast' && state.hints.has(tileK)){
      abilityVoidBlast(u,{x,y});
    } else {
      toast('Invalid ability target.');
      return;
    }
    u.nextAbilityAt = now + u.abilityCool;
    state.hintMode=null;
    state.hints.clear();
    render();
  }

  // ORDER
  function abilityOrderAura(u){
    const affected = state.units.filter(v=>v.hp>0 && v.side===u.side && manhattan(u,v)<=1);
    for(const a of affected){
      if(a===u) continue;
      a.nextMoveAt = Math.max(state.now, a.nextMoveAt - 1.0);
      state.animMove.add(a.id);
    }
    pushLog(`${sideName(u.side)} Order King pulsed an aura, speeding allies.`);
  }

  function abilityOrderShield(u,ally){
    ally.hp = Math.min(ally.maxHp, ally.hp+1);
    state.animMove.add(u.id);
    pushLog(`${sideName(u.side)} Sentinel shielded ${pieceDef(ally).name} (+1 HP).`);
  }

  function abilityOrderVolley(u,primary){
    const isCol = (primary.x===u.x);
    const hits=[];
    for(const v of state.units){
      if(v.hp<=0 || v.side===u.side) continue;
      if(isCol && v.x===u.x && Math.sign(v.y-u.y)===Math.sign(primary.y-u.y) && manhattan(u,v)<=3){
        hits.push(v);
      } else if(!isCol && v.y===u.y && Math.sign(v.x-u.x)===Math.sign(primary.x-u.x) && manhattan(u,v)<=3){
        hits.push(v);
      }
    }
    hits.sort((a,b)=>a.hp-b.hp);
    const toHit=hits.slice(0,2);
    for(const v of toHit){
      let dmg = 1;
      if(v.curseStacks>0) dmg +=1;
      v.hp-=dmg;
      state.animHit.add(v.id);
      pushLog(`${sideName(u.side)} Sky Archer volley hit ${pieceDef(v).name} for ${dmg}.`);
      if(v.hp<=0){
        pushLog(`${pieceDef(v).name} was destroyed.`);
      }
    }
    checkKingsAlive();
  }

  function abilityOrderSwap(u,ally){
    const oldX=u.x, oldY=u.y;
    u.x=ally.x; u.y=ally.y;
    ally.x=oldX; ally.y=oldY;
    state.animMove.add(u.id);
    state.animMove.add(ally.id);
    pushLog(`${sideName(u.side)} Circle Mage swapped with ${pieceDef(ally).name}.`);
  }

  // CHAOS
  function abilityChaosQuake(u){
    eachEnemyAround(u,2, v=>{
      const rnd = 0.5 + Math.random()*1.5;
      const newCd = v.moveCool * rnd;
      v.nextMoveAt = state.now + newCd;
      state.animHit.add(v.id);
    });
    pushLog(`${sideName(u.side)} Chaos King scrambled enemy rhythms.`);
  }

  function abilityChaosBlink(u,target){
    const dy = (u.side==='P' ? -1 : 1);
    const bx = target.x;
    const by = target.y + dy;
    if(isInside(bx,by) && !getUnitAt(bx,by)){
      u.x=bx; u.y=by;
    }
    let dmg = pieceDef(u).dmg + 1;
    if(target.curseStacks>0) dmg +=1;
    target.hp-=dmg;
    state.animMove.add(u.id);
    state.animHit.add(target.id);
    pushLog(`${sideName(u.side)} Warp Imp blinked and struck ${pieceDef(target).name} for ${dmg}.`);
    if(target.hp<=0){
      pushLog(`${pieceDef(target).name} was destroyed.`);
      checkKingsAlive();
    }
  }

  function abilityChaosBackstab(u,target){
    let dmg = pieceDef(u).dmg + 1;
    if(target.curseStacks>0) dmg +=1;
    if((u.side==='P' && u.y<target.y) || (u.side==='AI' && u.y>target.y)){
      dmg +=1;
    }
    target.hp-=dmg;
    state.animHit.add(target.id);
    pushLog(`${sideName(u.side)} Reaver backstabbed ${pieceDef(target).name} for ${dmg}.`);
    if(target.hp<=0){
      pushLog(`${pieceDef(target).name} was destroyed.`);
      checkKingsAlive();
    }
  }

  function abilityChaosCurse(u,target){
    target.curseStacks +=2;
    state.animHit.add(target.id);
    pushLog(`${sideName(u.side)} Witch cursed ${pieceDef(target).name}; next 2 hits deal +1 damage.`);
  }

  // VOID
  function abilityVoidTrapfield(u,tile){
    state.traps.push({x:tile.x,y:tile.y});
    pushLog(`${sideName(u.side)} Void King laid a trap at (${tile.x+1},${BOARD_H-tile.y}).`);
  }

  function abilityVoidRoot(u,target){
    target.rootUntil = Math.max(target.rootUntil || 0, state.now + 4.0);
    state.animHit.add(target.id);
    pushLog(`${sideName(u.side)} Warden rooted ${pieceDef(target).name}.`);
  }

  function abilityVoidPull(u,target){
    const dx = Math.sign(u.x - target.x);
    const dy = Math.sign(u.y - target.y);
    const nx = target.x + dx;
    const ny = target.y + dy;
    if(isInside(nx,ny) && !getUnitAt(nx,ny)){
      target.x=nx; target.y=ny;
      state.animHit.add(target.id);
      pushLog(`${sideName(u.side)} Shade pulled ${pieceDef(target).name} closer.`);
      triggerTrapAt(target);
    }else{
      pushLog(`${sideName(u.side)} Shade tried to pull ${pieceDef(target).name} but there was no space.`);
    }
  }

  function abilityVoidBlast(u,tile){
    const radius=1;
    for(const v of state.units){
      if(v.hp<=0 || v.side===u.side) continue;
      if(Math.abs(v.x-tile.x)<=radius && Math.abs(v.y-tile.y)<=radius){
        let dmg=1;
        if(v.curseStacks>0) dmg +=1;
        v.hp-=dmg;
        state.animHit.add(v.id);
        pushLog(`${sideName(u.side)} Null Orb blasted ${pieceDef(v).name} for ${dmg}.`);
        if(v.hp<=0){
          pushLog(`${pieceDef(v).name} was destroyed.`);
        }
      }
    }
    checkKingsAlive();
  }

  // ===== Check / kings =====
  function sideName(side){ return side==='P'?'You':'AI'; }

  function kingOf(side){
    return state.units.find(u=>u.hp>0 && u.side===side && pieceDef(u).isKing);
  }

  function canPieceContactAttack(attacker,target){
    const def = pieceDef(attacker);
    return canReachEnemyContact(attacker,target,def.move);
  }

  function isKingInCheck(side){
    const king = kingOf(side);
    if(!king) return false;
    const enemySide = (side==='P'?'AI':'P');
    for(const u of state.units){
      if(u.hp<=0 || u.side!==enemySide) continue;
      if(canPieceContactAttack(u,king)) return true;
    }
    return false;
  }

  function updateCheckStatus(){
    state.checkOnP = isKingInCheck('P');
    state.checkOnAI= isKingInCheck('AI');
  }

  function checkKingsAlive(){
    const kP = kingOf('P');
    const kA = kingOf('AI');
    if(!kP || kP.hp<=0){
      endGame('AI','Your king was destroyed (checkmate-ish).');
    }else if(!kA || kA.hp<=0){
      endGame('P','AI king was destroyed (checkmate-ish).');
    }
  }

  function endGame(winnerSide,msg){
    if(state.winner) return;
    state.running=false;
    state.winner = winnerSide;
    statusText.textContent = msg + ' Press Start for a new battle.';
    pushLog(msg);
    toast(msg);
  }

  // ===== AI =====
  function shouldAiUseAbility(u){
    const def = pieceDef(u);
    const ak = def.abilityKey;
    const foes2 = enemiesInRange(u,2);
    const foes3 = enemiesInRange(u,3);

    if(ak==='chaos_quake' || ak==='order_aura'){
      return state.units.some(v=>v.hp>0 && manhattan(u,v)<=2 && v.side!==u.side);
    }
    if(ak==='chaos_backstab' || ak==='chaos_blink'){
      return foes2.length>0;
    }
    if(ak==='chaos_curse' || ak==='void_root' || ak==='void_pull'){
      return foes2.length>0;
    }
    if(ak==='order_shield'){
      return state.units.some(v=>v.hp>0 && v.side===u.side && v.id!==u.id && v.hp<v.maxHp && manhattan(u,v)===1);
    }
    if(ak==='order_volley'){
      return state.units.some(v=>v.hp>0 && v.side!==u.side && (v.x===u.x||v.y===u.y) && manhattan(u,v)<=3);
    }
    if(ak==='order_swap'){
      return state.units.some(v=>v.hp>0 && v.side===u.side && v.id!==u.id && pieceDef(v).isKing);
    }
    if(ak==='void_trapfield' || ak==='void_blast'){
      return true;
    }
    return false;
  }

  function aiUseAbility(u){
    const def = pieceDef(u);
    const ak = def.abilityKey;
    const now = state.now;
    if(now<u.nextAbilityAt) return;

    const foes2 = enemiesInRange(u,2);
    const foes3 = enemiesInRange(u,3);

    if(ak==='order_aura'){
      abilityOrderAura(u);
    } else if(ak==='order_shield'){
      const allies = state.units.filter(v=>v.hp>0 && v.side===u.side && v.id!==u.id && v.hp<v.maxHp && manhattan(u,v)===1);
      if(!allies.length) return;
      abilityOrderShield(u,allies[0]);
    } else if(ak==='order_volley'){
      const cands = state.units.filter(v=>v.hp>0 && v.side!==u.side && (v.x===u.x||v.y===u.y) && manhattan(u,v)<=3);
      if(!cands.length) return;
      cands.sort((a,b)=>a.hp-b.hp);
      abilityOrderVolley(u,cands[0]);
    } else if(ak==='order_swap'){
      const allies = state.units.filter(v=>v.hp>0 && v.side===u.side && v.id!==u.id);
      if(!allies.length) return;
      allies.sort((a,b)=>(pieceDef(b).isKing?1:0)-(pieceDef(a).isKing?1:0));
      abilityOrderSwap(u,allies[0]);
    } else if(ak==='chaos_quake'){
      abilityChaosQuake(u);
    } else if(ak==='chaos_blink'){
      if(!foes2.length) return;
      foes2.sort((a,b)=>a.hp-b.hp);
      abilityChaosBlink(u,foes2[0]);
    } else if(ak==='chaos_backstab'){
      const adj = enemiesInRange(u,1);
      if(!adj.length) return;
      adj.sort((a,b)=>a.hp-b.hp);
      abilityChaosBackstab(u,adj[0]);
    } else if(ak==='chaos_curse'){
      if(!foes2.length) return;
      foes2.sort((a,b)=>a.hp-b.hp);
      abilityChaosCurse(u,foes2[0]);
    } else if(ak==='void_trapfield'){
      const kp = kingOf('P');
      if(!kp) return;
      let bestTile=null, bestScore=-1;
      for(let y=0;y<BOARD_H;y++){
        for(let x=0;x<BOARD_W;x++){
          if(!getUnitAt(x,y) && manhattan(u,{x,y})<=3){
            const d = manhattan({x,y},kp);
            const score = 10 - d;
            if(score>bestScore){ bestScore=score; bestTile={x,y}; }
          }
        }
      }
      if(bestTile) abilityVoidTrapfield(u,bestTile); else return;
    } else if(ak==='void_root'){
      if(!foes2.length) return;
      foes2.sort((a,b)=>(pieceDef(b).isKing?1:0)-(pieceDef(a).isKing?1:0) || a.hp-b.hp);
      abilityVoidRoot(u,foes2[0]);
    } else if(ak==='void_pull'){
      if(!foes3.length) return;
      foes3.sort((a,b)=>a.hp-b.hp);
      abilityVoidPull(u,foes3[0]);
    } else if(ak==='void_blast'){
      const kp = kingOf('P');
      if(!kp) return;
      abilityVoidBlast(u,{x:kp.x,y:kp.y});
    } else return;

    u.nextAbilityAt = now + u.abilityCool;
  }

  function aiStep(){
    if(!state.running || state.winner) return;
    const candidates = state.units.filter(u=>u.hp>0 && u.side==='AI' && state.now>=u.nextMoveAt && !isRooted(u));
    if(!candidates.length) return;

    const abUser = candidates.find(u=> state.now>=u.nextAbilityAt && shouldAiUseAbility(u));
    if(abUser){
      aiUseAbility(abUser);
      return;
    }

    const attackChoices=[];
    for(const u of candidates){
      const targets = contactTargets(u);
      for(const v of targets){
        const score = (pieceDef(v).isKing?200:0) + (v.hp<=pieceDef(u).dmg+u.bonusDmg?50:0) + (3-v.hp);
        attackChoices.push({u,v,score});
      }
    }
    if(attackChoices.length){
      attackChoices.sort((a,b)=>b.score-a.score);
      const best=attackChoices[0];
      doAttack(best.u,best.v);
      return;
    }

    const kingP = kingOf('P');
    if(!kingP) return;
    let bestMove = null;
    for(const u of candidates){
      const def=pieceDef(u);
      const tiles = reachableTiles(u, def.move);
      for(const k of tiles){
        const [tx,ty] = k.split(',').map(Number);
        const distNow = manhattan(u,kingP);
        const distNew = manhattan({x:tx,y:ty},kingP);
        const gain = distNow - distNew;
        const score = gain*10 + (pieceDef(u).isKing? -3:0);
        if(!bestMove || score>bestMove.score){
          bestMove = {u,tx,ty,score};
        }
      }
    }
    if(bestMove){
      doMove(bestMove.u,bestMove.tx,bestMove.ty);
    }
  }

  // ===== Logging & toast =====
  function pushLog(msg){
    const p=document.createElement('p');
    p.textContent='â€¢ '+msg;
    logEl.insertBefore(p,logEl.firstChild);
    const max=60;
    while(logEl.children.length>max) logEl.removeChild(logEl.lastChild);
  }

  function toast(msg){
    const t=document.getElementById('toast');
    t.textContent=msg;
    t.style.display='block';
    clearTimeout(t._h);
    t._h=setTimeout(()=>{t.style.display='none';},1600);
  }

  // ===== Loop =====
  let lastTime = performance.now();
  function loop(nowMs){
    const dt = (nowMs - lastTime)/1000;
    lastTime = nowMs;
    state.now += dt;

    if(state.running && !state.winner){
      if(state.now - state.lastAiAct >= state.aiInterval){
        state.lastAiAct = state.now;
        aiStep();
      }
    }
    render();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  render();
})();
</script>
</body>
</html>




