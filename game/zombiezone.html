<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>üßü‚Äç‚ôÇÔ∏è Zombie Zone ‚Äî 4P</title>
<style>
  :root{
    --bg:#0b1014; --panel:#0e1726; --ink:#e6edf3; --muted:#93a4b7;
    --good:#22c55e; --warn:#f59e0b; --bad:#ef4444; --accent:#7c3aed;
    --line:#16243d;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--ink);
    background:radial-gradient(1200px 600px at 50% -200px,#0f172a 0%,#0b1014 55%,#070b0f 100%);
    font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Arial;
    overscroll-behavior: none;
  }

  .hud{
    position:sticky; top:0; z-index:50; display:flex; align-items:center; gap:10px; padding:10px;
    background:rgba(8,13,20,.75); backdrop-filter: blur(8px); border-bottom:1px solid #101a2c;
  }
  .hud .title{font-weight:900}
  .spacer{flex:1}
  .btn{
    appearance:none; border:1px solid #263147; background:#111a2b; color:#e6edf3; padding:10px 12px; border-radius:12px; cursor:pointer; font-weight:800;
    touch-action: manipulation; user-select:none;
  }
  .btn:hover{background:#162238}
  .btn[disabled]{opacity:.6; cursor:not-allowed}
  .btn-accent{background:linear-gradient(180deg,#7c3aed,#6d28d9); border-color:#5b21b6}
  .btn-red{background:#991b1b; border-color:#7f1d1d}
  .pill{padding:6px 10px; border-radius:999px; border:1px solid #263147; background:#0e1726; font-weight:800}

  #playArea{ padding:12px; }
  .shell{ display:grid; grid-template-columns: minmax(260px,1fr) 360px; gap:12px; align-items:start; }
  @media (max-width:900px){ .shell{ grid-template-columns:1fr } }

  :fullscreen #playArea, #playArea:fullscreen{ padding:8px; }
  :fullscreen .shell, .shell:fullscreen{ grid-template-columns:1fr; grid-auto-rows:auto; }

  .map-wrap{
    background:#0a111c; border:1px solid #12213a; border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,.25);
    position:relative; user-select:none; overflow:hidden;
    height: min(52vh, 560px);
    overscroll-behavior: none;
    touch-action: none; /* critical for responsive mobile pan/zoom */
  }
  @media (min-width:901px){ .map-wrap{ height: min(70vh, 820px); } }
  :fullscreen .map-wrap, .map-wrap:fullscreen{ height: 52vh; }
  @media (min-width:901px){ :fullscreen .map-wrap, .map-wrap:fullscreen{ height: 70vh; } }
  canvas{ display:block; width:100%; height:100%; touch-action: none; }

  .right-col{ display:grid; gap:10px; }
  .card{ background:#0e1726; border:1px solid var(--line); border-radius:16px; padding:12px }
  .card h3{ margin:0 0 8px; font-size:16px }
  .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center }
  .col{ display:grid; gap:8px }

  .actions{ display:flex; gap:8px; flex-wrap:wrap }
  .actions .btn{ flex:1 1 auto; min-width:120px }

  .res{ display:flex; gap:6px; flex-wrap:wrap }
  .chip{ display:inline-flex; align-items:center; gap:6px; padding:8px 10px; background:#0b1322; border:1px solid #1b2b48; border-radius:999px; font-weight:800 }
  .dot{ width:10px; height:10px; border-radius:50% }

  /* Build modal (inside #playArea so it appears over fullscreen) */
  .modal{ position:fixed; inset:0; display:none; place-items:center; z-index:2147483000; }
  .modal.show{ display:grid; }
  .modal::before{ content:""; position:absolute; inset:0; background:rgba(0,0,0,.5); }
  .modal .box{
    position:relative; background:#0e1726; border:1px solid #233454; border-radius:16px; padding:14px;
    width:min(720px,92vw);
  }
  .grid3{ display:grid; grid-template-columns: repeat(3, 1fr); gap:10px }
  @media (max-width:560px){ .grid3{ grid-template-columns: repeat(2, 1fr); } }
  .tool{
    display:flex; flex-direction:column; gap:4px; align-items:center; justify-content:center;
    min-height:74px; border:1px dashed #253656; border-radius:12px; background:#0b1322; cursor:pointer; font-weight:800; text-align:center
  }
  .tool small{ color:#9fb3cb; font-weight:600; font-size:12px }

  /* Dice banners */
  .dice-banner{
    position:absolute; inset:auto 0 28% 0; margin:auto; width:100%; display:grid; place-items:center; pointer-events:none;
    font-weight:900; font-size: clamp(40px, 10vw, 96px); color:#fff; text-shadow:0 8px 24px rgba(0,0,0,.5);
    opacity:0; transform: translateY(10px); transition: opacity .6s, transform .6s;
  }
  .dice-banner.show{ opacity:1; transform: translateY(0) }

  .care-banner{
    position:absolute; inset:auto 0 44% 0; margin:auto; width:100%; display:grid; place-items:center; pointer-events:none;
    opacity:0; transform: translateY(10px); transition: opacity .6s, transform .6s;
  }
  .care-banner.show{ opacity:1; transform: translateY(0) }
  .care-box{
    display:inline-flex; gap:8px; align-items:center; padding:10px 14px;
    background:rgba(20,30,48,.85); border:1px solid #263147; border-radius:14px; backdrop-filter: blur(6px);
    font-weight:900; color:#e6edf3;
  }
  .care-pill{
    display:inline-flex; gap:6px; align-items:center; padding:6px 10px; border-radius:999px;
    background:#0b1322; border:1px solid #1b2b48; font-weight:800; font-size:14px;
  }

  .dead{
    position:fixed; inset:0; background:rgba(0,0,0,.7); display:none; z-index:2147483000; place-items:center; text-align:center; padding:20px;
  }
  .dead .box{ background:#0e1726; border:1px solid #223456; border-radius:16px; padding:20px; max-width:520px }
  .dead .box h2{ margin:0 0 8px }

  /* Toast (also inside fullscreen root) */
  .toast{
    position:fixed; bottom:18px; left:50%; transform:translateX(-50%) translateY(10px);
    background:#17263e; color:#e6edf3; border:1px solid #2a3f66;
    padding:10px 14px; border-radius:12px; opacity:0; transition:.25s; z-index:2147483500; pointer-events:none; font-weight:800
  }
  .toast.show{ opacity:1; transform:translateX(-50%) translateY(0) }
</style>
</head>
<body>
  <div class="hud">
    <div class="title">üßü‚Äç‚ôÇÔ∏è Zombie Zone</div>
    <span id="turnInfo" class="pill">Waiting‚Ä¶</span>
    <span id="timer" class="pill">60s</span>
    <div class="spacer"></div>
    <button id="btnZoomOut" class="btn">‚àí</button>
    <button id="btnZoomIn" class="btn">+</button>
    <button id="btnFullscreen" class="btn">‚§¢ Fullscreen</button>
  </div>

  <!-- Fullscreen target -->
  <div id="playArea">
    <div class="shell">
      <div class="map-wrap" id="mapWrap">
        <canvas id="map"></canvas>
        <div id="diceBanner" class="dice-banner"></div>
        <div id="careBanner" class="care-banner"></div>
      </div>

      <div class="right-col">
        <div class="card">
          <div class="actions">
            <button id="btnBuild" class="btn btn-accent">Build</button>
            <button id="btnEndTurn" class="btn btn-accent" disabled>End Turn</button>
          </div>
          <div class="row" style="margin-top:8px">
            <span class="pill">üé≤ Last Roll: <b id="lastRollUi">‚Äî</b></span>
          </div>
        </div>

        <div class="card">
          <h3>Resources</h3>
          <div id="resRow" class="res"></div>
        </div>

        <div class="card">
          <h3>Trade</h3>
          <div class="row">
            <select id="tradeGive" class="btn">
              <option value="brick">Brick</option><option value="ore">Ore</option>
              <option value="sheep">Sheep</option><option value="wheat">Wheat</option><option value="wood">Wood</option>
            </select>
            <input id="tradeGiveAmt" class="btn" type="number" min="1" value="1" style="width:90px"/>
          </div>
          <div class="row" style="margin-top:6px">
            <select id="tradeWant" class="btn">
              <option value="brick">Brick</option><option value="ore">Ore</option>
              <option value="sheep">Sheep</option><option value="wheat">Wheat</option><option value="wood">Wood</option>
            </select>
            <input id="tradeWantAmt" class="btn" type="number" min="1" value="1" style="width:90px"/>
            <button id="btnPostTrade" class="btn">Post Trade</button>
          </div>
          <div id="trades" class="col" style="margin-top:10px"></div>
        </div>

        <div class="card" style="font-size:13px; line-height:1.45; color:#9fb3cb">
          <h3>Build Costs</h3>
          <div><b>Wire</b> 1 ore (or Free Wire token) ‚Ä¢ <b>Wall</b> <u>2 wood</u> ‚Ä¢ <b>Ultra Wall</b> <u>3 brick</u> ‚Ä¢ <b>Command Ctr</b> 2 ore,2 brick,2 sheep ‚Ä¢ <b>Central Base</b> 2 ore,2 brick,2 sheep</div>
          <div><b>Turret</b> 1 wood,1 sheep ‚Ä¢ <b>Catapult</b> 3 wood,2 sheep ‚Ä¢ <b>Fire Beacon</b> 1 wood,2 wheat ‚Ä¢ <b>Tesla</b> 2 ore,2 wheat,2 sheep,2 wood ‚Ä¢ <b>Tri-Bolt</b> 2 wood,2 ore,1 brick ‚Ä¢ <b>Mortar</b> <u>1 ore,3 brick</u> ‚Ä¢ <b>Drill</b> 2 ore ‚Ä¢ <b>Upgrade</b> (towers) 2 wheat,1 ore</div>
          <div>Everything except walls must connect to your <b>wires</b>. If zombies cut/destroy a wire, disconnected stuff gets destroyed.</div>
        </div>
      </div>
    </div>

    <!-- Overlays inside fullscreen root -->
    <div id="buildModal" class="modal" aria-hidden="true">
      <div class="box">
        <div class="row" style="justify-content:space-between; align-items:center; margin-bottom:8px">
          <h3 style="margin:0">Select a Building</h3>
          <button id="btnCloseBuild" class="btn">Close</button>
        </div>
        <div id="buildGrid" class="grid3"></div>
        <div style="margin-top:8px; font-size:12px; color:#9fb3cb">Tap a building, then tap a tile. Tap empty space to cancel.</div>
      </div>
    </div>

    <div id="toast" class="toast"></div>
  </div>

  <div id="deadOverlay" class="dead">
    <div class="box">
      <h2>üíÄ You‚Äôve been eliminated</h2>
      <p>You no longer control any Command Centers. You‚Äôll spectate until the game ends.</p>
      <div class="row" style="justify-content:center">
        <button id="btnReturnLobby" class="btn btn-red">Return to Lobby</button>
      </div>
    </div>
  </div>

<script type="module">
/* ---------------- Firebase ---------------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, runTransaction,
  collection, addDoc, serverTimestamp, deleteDoc
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

/* ---------------- URL Params ---------------- */
const params = new URLSearchParams(location.search);
const gameId = params.get("gameId") || "local";
const username = params.get("username") || ("Player" + Math.floor(Math.random()*999));

/* ---------------- Constants ---------------- */
const W = 64, H = 64;
const TILE_COLORS = { red:"#7f1d1d", gray:"#374151", white:"#cbd5e1", yellow:"#f59e0b", green:"#197141" };
const RESOURCE_BY_COLOR = { red:'brick', gray:'ore', white:'sheep', yellow:'wheat', green:'wood' };
const R_KEYS = ['brick','ore','sheep','wheat','wood'];
const TURN_SECONDS = 60;

/* ---------------- State ---------------- */
let state = null;
let myIndex = -1;
let localCareSeenRound = 0;
let lastRollSeenTurnId = -1;
let endingTurn = false; // ‚Üê mobile ‚Äúfreeze‚Äù guard

/* ---------------- DOM ---------------- */
const playArea = document.getElementById('playArea');
const wrap = document.getElementById('mapWrap');
const canvas = document.getElementById('map');
const ctx = canvas.getContext('2d');
const diceBanner = document.getElementById('diceBanner');
const careBanner = document.getElementById('careBanner');
const resRow = document.getElementById('resRow');
const tradesEl = document.getElementById('trades');
const btnEndTurn = document.getElementById('btnEndTurn');
const btnBuild = document.getElementById('btnBuild');
const buildModal = document.getElementById('buildModal');
const buildGrid = document.getElementById('buildGrid');
const btnCloseBuild = document.getElementById('btnCloseBuild');
const btnFullscreen = document.getElementById('btnFullscreen');
const btnReturnLobby = document.getElementById('btnReturnLobby');
const timerEl = document.getElementById('timer');
const turnInfo = document.getElementById('turnInfo');
const tradeGive = document.getElementById('tradeGive');
const tradeGiveAmt = document.getElementById('tradeGiveAmt');
const tradeWant = document.getElementById('tradeWant');
const tradeWantAmt = document.getElementById('tradeWantAmt');
const btnZoomIn = document.getElementById('btnZoomIn');
const btnZoomOut = document.getElementById('btnZoomOut');
const lastRollUi = document.getElementById('lastRollUi');
const toastEl = document.getElementById('toast');
const deadOverlay = document.getElementById('deadOverlay');

/* ---------------- Camera / Interaction ---------------- */
let local = {
  scale:36, camX:0, camY:0,
  dragging:false, dragStart:[0,0], camStart:[0,0],
  build:null, hover:[-1,-1]
};
const clampScale = ()=> { local.scale = Math.max(18, Math.min(64, local.scale)); };

function resize(){
  const dpr = devicePixelRatio||1;
  canvas.width  = wrap.clientWidth * dpr;
  canvas.height = wrap.clientHeight * dpr;
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resize);

function worldToScreen(x,y){ return [(x - local.camX)*local.scale, (y - local.camY)*local.scale]; }
function screenToWorld(px,py){ return [px/local.scale + local.camX, py/local.scale + local.camY]; }
function ptToTile(px,py){ const [wx,wy] = screenToWorld(px,py); return [Math.floor(wx), Math.floor(wy)]; }

resize();
clampScale();
local.camX = 32 - (wrap.clientWidth/local.scale)/2;
local.camY = 32 - (wrap.clientHeight/local.scale)/2;

/* Drag pan */
wrap.addEventListener('pointerdown', (e)=>{
  wrap.setPointerCapture(e.pointerId);
  local.dragging=true; local.dragStart=[e.clientX,e.clientY]; local.camStart=[local.camX,local.camY];
  e.preventDefault();
}, {passive:false});

wrap.addEventListener('pointermove', (e)=>{
  const rect = wrap.getBoundingClientRect();
  const px=e.clientX-rect.left, py=e.clientY-rect.top;
  local.hover = ptToTile(px,py);
  if(local.dragging){
    const dx=(e.clientX-local.dragStart[0])/local.scale;
    const dy=(e.clientY-local.dragStart[1])/local.scale;
    local.camX = local.camStart[0]-dx;
    local.camY = local.camStart[1]-dy;
    e.preventDefault();
  }else if(e.pointerType==='mouse'){
    const edge=18;
    if(px<edge) local.camX -= 0.15;
    if(px>rect.width-edge) local.camX += 0.15;
    if(py<edge) local.camY -= 0.15;
    if(py>rect.height-edge) local.camY += 0.15;
  }
}, {passive:false});
wrap.addEventListener('pointerup',(e)=>{
  wrap.releasePointerCapture(e.pointerId);
  const moved = Math.hypot(e.clientX-local.dragStart[0], e.clientY-local.dragStart[1]);
  if(local.dragging && moved<6){ handleTap(e); }
  local.dragging=false;
  e.preventDefault();
}, {passive:false});
wrap.addEventListener('pointercancel',()=> local.dragging=false);

/* Pinch zoom via touch */
let pinchDist=0;
wrap.addEventListener('touchstart',(e)=>{ if(e.touches.length===2){ pinchDist = dist(e.touches[0], e.touches[1]); } }, {passive:true});
wrap.addEventListener('touchmove',(e)=>{
  if(e.touches.length===2){
    e.preventDefault();
    const nd = dist(e.touches[0], e.touches[1]);
    if(pinchDist>0){
      const rect = wrap.getBoundingClientRect();
      const cx = (e.touches[0].clientX + e.touches[1].clientX)/2 - rect.left;
      const cy = (e.touches[0].clientY + e.touches[1].clientY)/2 - rect.top;
      const factor = Math.pow(1.015, (nd - pinchDist)/2);
      zoomAt(cx, cy, factor);
    }
    pinchDist = nd;
  }
},{passive:false});
wrap.addEventListener('touchend',()=>{ pinchDist=0; }, {passive:true});
function dist(a,b){ const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY; return Math.hypot(dx,dy); }

/* Zoom helpers */
function zoomAt(pointX, pointY, factor){
  const [wx, wy] = screenToWorld(pointX, pointY);
  local.scale *= factor; clampScale();
  const [sx, sy] = worldToScreen(wx, wy);
  const dx = (pointX - sx)/local.scale;
  const dy = (pointY - sy)/local.scale;
  local.camX -= dx; local.camY -= dy;
}
btnZoomIn.onclick  = ()=> zoomAt(wrap.clientWidth/2, wrap.clientHeight/2, 1.15);
btnZoomOut.onclick = ()=> zoomAt(wrap.clientWidth/2, wrap.clientHeight/2, 1/1.15);

/* ---------------- Helpers ---------------- */
function indexOf(x, y){ return y*W + x; }
function inBounds(x,y){ return x>=0 && y>=0 && x<W && y<H; }
function getTile(g, x, y){ return g.tiles[indexOf(x,y)]; }
function tileAt(x,y){ return state ? state.tiles[indexOf(x,y)] : null; }
function playerColor(i){ return ['#60a5fa','#22c55e','#f59e0b','#f472b6'][i%4]; }
function alive(){ return myIndex>=0 && state.players[myIndex]?.alive; }
function isMyTurn(){ return state && myIndex>=0 && state.playerOrder[state.currentTurn]===myIndex; }

/* HP helpers */
function hpFor(kind){
  if(kind==='wall') return 6;
  if(kind==='uwall') return 14;
  if(kind==='turret' || kind==='cata' || kind==='beacon') return 8;
  if(kind==='tesla') return 10;
  if(kind==='tribolt') return 9;
  if(kind==='mortar') return 8;
  if(kind==='cc'||kind==='base') return 20;
  if(kind==='drill') return 6;
  if(kind==='wire') return 1;
  return 1;
}
function drawHpBar(x, y, cur, max){
  const w = Math.max(24, local.scale - 6);
  const h = 5;
  const px = x + (local.scale - w)/2;
  const py = y + 3;
  const r = Math.max(0, Math.min(1, cur/max));
  ctx.fillStyle = "#000";
  ctx.fillRect(px, py, w, h);
  ctx.fillStyle = r>0.5 ? "#22c55e" : (r>0.25 ? "#f59e0b" : "#ef4444");
  ctx.fillRect(px, py, w*r, h);
  if(local.scale >= 28){
    ctx.font = "bold 10px ui-sans-serif";
    ctx.fillStyle = "#e6edf3";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillText(`${Math.ceil(cur)}/${max}`, x + local.scale/2, py + h + 1);
  }
}

/* ---------------- RNG + Map ---------------- */
function seededRng(seed){ let s = seed>>>0; return ()=> (s = (s*1664525 + 1013904223) >>> 0)/2**32; }
function genMap(seed){
  const rnd = seededRng(seed);
  const colors = Object.keys(TILE_COLORS);
  const nums = [2,3,4,5,6,8,9,10,11,12]; // no 7
  const tiles = new Array(W*H);
  for(let y=0;y<H;y++){
    for(let x=0;x<W;x++){
      tiles[indexOf(x,y)] = {
        color: colors[Math.floor(rnd()*colors.length)],
        num:   nums[Math.floor(rnd()*nums.length)]
      };
    }
  }
  return tiles;
}

/* ---------------- UI bits ---------------- */
function toast(msg){
  toastEl.textContent = msg;
  toastEl.classList.add('show');
  setTimeout(()=> toastEl.classList.remove('show'), 1300);
}
function moneyChip(label, color, amt){
  const div = document.createElement('div'); div.className='chip';
  const dot = document.createElement('span'); dot.className='dot'; dot.style.background=color;
  const text = document.createElement('span'); text.textContent=`${label}: ${amt|0}`;
  div.append(dot,text); return div;
}
function renderResources(){
  resRow.innerHTML=''; if(!state||myIndex<0) return;
  const r = state.players[myIndex].res;
  resRow.append(
    moneyChip('Brick','#b91c1c', r.brick),
    moneyChip('Ore','#64748b', r.ore),
    moneyChip('Sheep','#e2e8f0', r.sheep),
    moneyChip('Wheat','#fbbf24', r.wheat),
    moneyChip('Wood','#22c55e', r.wood),
    moneyChip('Free Wire','#93c5fd', state.players[myIndex].freeWire||0),
  );
}
function showDice(n){
  lastRollUi.textContent = n;
  diceBanner.textContent = `üé≤ ${n}`;
  diceBanner.classList.add('show');
  setTimeout(()=>diceBanner.classList.remove('show'), 1600);
}
function showCare(items){
  careBanner.innerHTML = '';
  const box = document.createElement('div');
  box.className = 'care-box';
  const label = document.createElement('div');
  label.textContent = 'üéÅ Care Package';
  box.appendChild(label);
  for(const it of items){
    const pill = document.createElement('div');
    pill.className='care-pill';
    const pretty = it.k==='wire' ? 'Wire' : (it.k[0].toUpperCase()+it.k.slice(1));
    pill.textContent = `+${it.n} ${pretty}`;
    box.appendChild(pill);
  }
  careBanner.appendChild(box);
  careBanner.classList.add('show');
  setTimeout(()=> careBanner.classList.remove('show'), 1800);
}

/* ---------------- Costs & Build ---------------- */
const COST = {
  wire: {ore:1}, wall:{wood:2}, uwall:{brick:3},
  cc:{ore:2,brick:2,sheep:2}, base:{ore:2,brick:2,sheep:2},
  turret:{wood:1,sheep:1}, cata:{wood:3,sheep:2},
  beacon:{wood:1,wheat:2}, tesla:{ore:2,wheat:2,sheep:2,wood:2},
  tribolt:{wood:2,ore:2,brick:1}, mortar:{ore:1,brick:3}, drill:{ore:2}
};
const BUILD_TOOLS = [
  {id:'wire',label:'Wire',icon:'üîå'},
  {id:'wall',label:'Wall',icon:'üß±'},
  {id:'uwall',label:'Ultra Wall',icon:'üß±‚òÖ'},
  {id:'cc',label:'Command',icon:'üèöÔ∏è'},
  {id:'base',label:'Central Base',icon:'üèõÔ∏è'},
  {id:'turret',label:'Turret',icon:'üèπ'},
  {id:'cata',label:'Catapult',icon:'ü™µ'},
  {id:'beacon',label:'Fire Beacon',icon:'üî•'},
  {id:'tesla',label:'Tesla',icon:'‚ö°'},
  {id:'tribolt',label:'Tri-Bolt',icon:'üî±'},
  {id:'mortar',label:'Mortar',icon:'üí£'},
  {id:'drill',label:'Drill',icon:'‚õèÔ∏è'}
];
function needsWire(kind){ return !['wall','uwall'].includes(kind); }
function hasRes(cost){
  const r = state.players[myIndex].res;
  for(const k of Object.keys(cost)){ if((r[k]||0) < cost[k]) return false; }
  return true;
}
function canAfford(kind){
  if(kind==='wire'){
    const token = (state.players[myIndex].freeWire||0)>0;
    return token || hasRes(COST.wire);
  }
  return COST[kind] ? hasRes(COST[kind]) : true;
}
function upgradable(b){ return ['turret','cata','beacon','tesla','tribolt','mortar'].includes(b.kind); }
function costText(obj){ return Object.entries(obj).map(([k,v])=>`${v} ${k}`).join(', '); }
function renderBuildModal(){
  buildGrid.innerHTML='';
  for(const t of BUILD_TOOLS){
    const div = document.createElement('button');
    div.className='tool';
    const c = COST[t.id] ? costText(COST[t.id]) : '‚Äî';
    div.innerHTML = `<div style="font-size:18px">${t.icon} ${t.label}</div><small>${c}</small>`;
    div.onclick = ()=>{
      if(!alive()) return;
      if(!canAfford(t.id)){
        toast(`Not enough resources for ${t.label}`);
        return;
      }
      local.build = {kind:t.id};
      buildModal.classList.remove('show');
    };
    buildGrid.appendChild(div);
  }
}
renderBuildModal();
btnBuild.onclick = ()=> buildModal.classList.add('show');
btnCloseBuild.onclick = ()=> buildModal.classList.remove('show');
buildModal.addEventListener('click',(e)=>{ if(e.target===buildModal) buildModal.classList.remove('show'); });

function placeable(x,y,sel,g=state){
  if(g.zombies.some(z=>z.x===x&&z.y===y)) return false;
  if(g.buildings.some(b=>b.x===x&&b.y===y)) return false;

  if(sel.kind==='cc'){
    for(const p of g.players){
      for(const bb of (p.bases||[])){
        const d = Math.abs(bb.x-x)+Math.abs(bb.y-y);
        if(d<3) return false;
      }
    }
  }
  if(sel.kind==='base'){
    const there = g.buildings.find(b=>b.x===x&&b.y===y && b.kind==='cc' && b.owner===myIndex);
    if(!there) return false;
  }
  if(needsWire(sel.kind)){
    const adj = [[1,0],[-1,0],[0,1],[0,-1]].some(([dx,dy])=>{
      return g.buildings.some(b=>b.x===x+dx&&b.y===y+dy&&b.kind==='wire'&&b.owner===myIndex);
    });
    if(!adj) return false;
  }
  return true;
}

async function doPlace(x,y,sel){
  if(sel.kind==='wire'){
    const hasToken = (state.players[myIndex].freeWire||0)>0;
    const payOre = hasRes(COST.wire);
    if(!hasToken && !payOre){ toast('Not enough ore (or Free Wire)'); return; }
    await runTransaction(db, async (tx)=>{
      const snap = await tx.get(gameRef); if(!snap.exists()) return;
      const g = snap.data();
      if(!placeable(x,y,sel,g)) return;

      g.buildings.push({kind:'wire', owner:myIndex, x,y, hp:hpFor('wire'), level:1});
      if(hasToken){
        g.players[myIndex].freeWire = (g.players[myIndex].freeWire||0) - 1;
      }else{
        g.players[myIndex].res.ore = (g.players[myIndex].res.ore||0) - 1;
      }
      await tx.update(gameRef,g);
    });
    return;
  }

  if(COST[sel.kind] && !hasRes(COST[sel.kind])){ toast('Not enough resources'); return; }
  await runTransaction(db, async (tx)=>{
    const snap = await tx.get(gameRef); if(!snap.exists()) return;
    const g = snap.data();
    if(!placeable(x,y,sel,g)) return;

    if(sel.kind==='base'){
      const i = g.buildings.findIndex(b=>b.x===x&&b.y===y&&b.kind==='cc'&&b.owner===myIndex);
      if(i>=0){ g.buildings[i].kind='base'; g.buildings[i].level=1; g.buildings[i].hp = Math.max(g.buildings[i].hp, hpFor('base')); }
      const pb = g.players[myIndex].bases.find(b=>b.x===x&&b.y===y);
      if(pb) pb.type='base';
    }else{
      g.buildings.push({kind:sel.kind, owner:myIndex, x,y, hp:hpFor(sel.kind), level:1});
      if(sel.kind==='cc'){ g.players[myIndex].bases.push({x,y,type:'cc'}); }
    }
    if(COST[sel.kind]){
      for(const k of Object.keys(COST[sel.kind])){
        g.players[myIndex].res[k] = (g.players[myIndex].res[k]||0) - COST[sel.kind][k];
      }
    }
    pruneDisconnected(g,myIndex);
    await tx.update(gameRef,g);
  });
}

async function tryUpgrade(b){
  const cost = {wheat:2, ore:1};
  if(!hasRes(cost)){ toast('Not enough for upgrade'); return; }
  await runTransaction(db, async (tx)=>{
    const snap = await tx.get(gameRef); if(!snap.exists()) return;
    const g = snap.data();
    const i = g.buildings.findIndex(x=>x.x===b.x && x.y===b.y && x.owner===myIndex && x.kind===b.kind);
    if(i<0) return;
    g.buildings[i].level = (g.buildings[i].level||1)+1;
    for(const k of Object.keys(cost)){ g.players[myIndex].res[k]-=cost[k]; }
    await tx.update(gameRef,g);
  });
}

/* ---------------- Game Doc ---------------- */
const gameRef = doc(db, "zombiezone", gameId);

async function initialPlayers(){
  try{
    const lob = await getDoc(doc(db,"lobbies",gameId));
    if(lob.exists()){
      const arr = lob.data().players||[];
      if(arr.length) return arr.slice(0,4);
    }
  }catch(e){}
  return [username];
}

async function ensureGame(){
  await runTransaction(db, async (tx)=>{
    const snap = await tx.get(gameRef);
    if(!snap.exists()){
      const seed = Math.floor(Math.random()*2**31);
      const tiles = genMap(seed);
      const players = await initialPlayers();
      const pls = players.map(n=>({
        name:n, alive:true,
        res:{brick:0,ore:0,sheep:0,wheat:0,wood:0},
        bases:[],
        needsFirstCC:true,
        lastCareRound: 0,
        careShow: [],
        freeWire: 0
      }));
      await tx.set(gameRef,{
        seed, tiles,
        buildings: [],
        zombies: [],
        players: pls,
        playerOrder: pls.map((_,i)=>i),
        currentTurn: 0,
        round: 1,
        turnEndsAt: Date.now()+TURN_SECONDS*1000,
        zombiesPerEdge: 1,
        zombieBaseHP: 3,
        fogDone:false,
        turnId: 0,
        lastRoll: null,
        lastRollTurnId: -1,
        createdAt: serverTimestamp()
      });
    }
  });
}

/* ---------------- Subscriptions ---------------- */
onSnapshot(gameRef, (snap)=>{
  if(!snap.exists()) return;
  state = snap.data();
  myIndex = (state.players||[]).findIndex(p=>p.name===username);
  renderResources(); renderTrades(); updateHud();

  // Care package banner
  if(myIndex>=0){
    const me = state.players[myIndex];
    if(me.lastCareRound && me.lastCareRound > localCareSeenRound){
      localCareSeenRound = me.lastCareRound;
      if(Array.isArray(me.careShow) && me.careShow.length){
        showCare(me.careShow);
      }
    }
  }

  // Dice banner/UI
  if(state.lastRollTurnId != null && state.lastRollTurnId !== lastRollSeenTurnId && state.lastRoll != null){
    lastRollSeenTurnId = state.lastRollTurnId;
    showDice(state.lastRoll);
  }else if(state.lastRoll != null){
    lastRollUi.textContent = state.lastRoll;
  }else{
    lastRollUi.textContent = '‚Äî';
  }

  if(myIndex>=0 && !state.players[myIndex].alive){
    deadOverlay.style.display='grid';
    btnEndTurn.disabled=true;
  }else{
    deadOverlay.style.display='none';
  }
});

function updateHud(){
  if(!state) return;
  const currentPI = state.playerOrder[state.currentTurn] ?? 0;
  const curName = state.players[currentPI]?.name || '?';
  const meTurn = (myIndex===currentPI);
  btnEndTurn.disabled = !meTurn || !alive() || endingTurn;
  turnInfo.textContent = meTurn ? `Your turn` : `Waiting on ${curName}`;
}

/* ---------------- Timer ---------------- */
let timerHandle=null;
function startTimer(){
  if(timerHandle) clearInterval(timerHandle);
  timerHandle = setInterval(()=>{
    if(!state) return;
    const ms = Math.max(0, state.turnEndsAt - Date.now());
    const s = Math.ceil(ms/1000);
    timerEl.textContent = s + 's';
    if(ms<=0) forceEndTurn();
  }, 250);
}
startTimer();

/* ---------------- Input / Tap ---------------- */
function handleTap(e){
  const rect = wrap.getBoundingClientRect();
  const [tx,ty]=ptToTile(e.clientX-rect.left,e.clientY-rect.top);
  if(!inBounds(tx,ty)){ local.build=null; return; }
  if(!alive()) return;

  // FIRST-TURN FREE CC PLACEMENT
  if(isMyTurn() && state.players[myIndex]?.needsFirstCC){
    placeFirstCC(tx,ty);
    return;
  }

  if(local.build){
    if(!canAfford(local.build.kind)){ toast('Not enough resources'); local.build=null; return; }
    if(placeable(tx,ty,local.build)) doPlace(tx,ty,local.build);
    local.build=null; return;
  }
  // try upgrade click
  const b = state.buildings.find(b=>b.x===tx&&b.y===ty&&b.owner===myIndex&&upgradable(b));
  if(b) tryUpgrade(b);
}
document.body.addEventListener('click',(e)=>{
  if(!wrap.contains(e.target) && !buildModal.contains(e.target)) local.build=null;
}, true);

/* ---------------- First turn CC placement ---------------- */
async function placeFirstCC(x,y){
  await runTransaction(db, async (tx)=>{
    const snap = await tx.get(gameRef); if(!snap.exists()) return;
    const g = snap.data();
    const me = g.players[myIndex];
    if(!me || !me.needsFirstCC) return;
    if(g.zombies.some(z=>z.x===x&&z.y===y)) return;
    if(g.buildings.some(b=>b.x===x&&b.y===y)) return;
    for(const p of g.players){
      for(const bb of (p.bases||[])){
        const d = Math.abs(bb.x-x)+Math.abs(bb.y-y);
        if(d<3) return; // spacing
      }
    }
    g.buildings.push({kind:'cc', owner:myIndex, x,y, hp:hpFor('cc'), level:1});
    g.buildings.push({kind:'wire', owner:myIndex, x,y, hp:hpFor('wire'), level:1}); // power seed
    me.bases.push({x,y,type:'cc'});
    me.needsFirstCC=false;
    g.turnEndsAt = Date.now()+TURN_SECONDS*1000;
    await tx.update(gameRef,g);
  });
}

/* ---------------- Drawing ---------------- */
function draw(){
  if(!state) return requestAnimationFrame(draw);
  const {buildings,zombies} = state;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const vw = wrap.clientWidth / local.scale, vh = wrap.clientHeight / local.scale;
  const x0 = Math.max(0, Math.floor(local.camX));
  const y0 = Math.max(0, Math.floor(local.camY));
  const x1 = Math.min(W-1, Math.ceil(local.camX + vw));
  const y1 = Math.min(H-1, Math.ceil(local.camY + vh));

  // base tiles
  for(let y=y0;y<=y1;y++){
    for(let x=x0;x<=x1;x++){
      const t = tileAt(x,y); if(!t) continue;
      const [sx,sy] = worldToScreen(x,y);
      ctx.fillStyle = TILE_COLORS[t.color];
      ctx.fillRect(sx,sy,1*local.scale,1*local.scale);
    }
  }

  // wires
  for(const b of buildings){
    if(b.kind!=='wire') continue;
    const [sx,sy] = worldToScreen(b.x,b.y);
    ctx.fillStyle="#93c5fd";
    ctx.fillRect(sx+local.scale*0.35, sy+local.scale*0.35, local.scale*0.3, local.scale*0.3);
  }

  // buildings + HP
  for(const b of buildings){
    if(b.kind==='wire') continue;
    const [sx,sy] = worldToScreen(b.x,b.y);
    ctx.strokeStyle = playerColor(b.owner);
    ctx.lineWidth=2; ctx.strokeRect(sx+1,sy+1, local.scale-2, local.scale-2);
    ctx.fillStyle="#0b1322aa"; ctx.fillRect(sx,sy,local.scale,local.scale);
    const icon = (
      b.kind==='wall'?'üß±': b.kind==='uwall'?'üß±':
      b.kind==='cc'?'üèöÔ∏è': b.kind==='base'?'üèõÔ∏è':
      b.kind==='turret'?'üèπ': b.kind==='cata'?'ü™µ':
      b.kind==='beacon'?'üî•': b.kind==='tesla'?'‚ö°':
      b.kind==='tribolt'?'üî±': b.kind==='mortar'?'üí£':
      b.kind==='drill'?'‚õèÔ∏è':'‚ñ°'
    );
    ctx.fillStyle="#fff"; ctx.font="bold 18px system-ui"; ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText(icon, sx+local.scale/2, sy+local.scale/2+1);
    if(b.level && b.level>1){ ctx.fillText("‚òÖ", sx+local.scale-10, sy+10); }

    // HP BAR (always for non-wire)
    const maxhp = Math.max(hpFor(b.kind), b.hp||1);
    drawHpBar(sx, sy, b.hp ?? maxhp, maxhp);
  }

  // zombies + HP bar
  for(const z of zombies){
    const [sx,sy] = worldToScreen(z.x,z.y);
    ctx.font = "bold 20px system-ui";
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText("üßü", sx+local.scale/2, sy+local.scale/2);
    drawHpBar(sx, sy, z.hp, z.maxhp);
  }

  // numbers
  ctx.fillStyle = "rgba(255,255,255,.98)";
  ctx.font = "bold 12px ui-sans-serif";
  ctx.textAlign="center"; ctx.textBaseline="bottom";
  for(let y=y0;y<=y1;y++){
    for(let x=x0;x<=x1;x++){
      const t = tileAt(x,y); if(!t) continue;
      const [sx,sy] = worldToScreen(x,y);
      ctx.fillText(String(t.num), sx + 0.5*local.scale, sy + local.scale - 2);
    }
  }

  // build hint
  if(local.build){
    const [hx,hy]=local.hover;
    if(inBounds(hx,hy)){
      const [sx,sy]=worldToScreen(hx,hy);
      ctx.save(); ctx.lineWidth=3;
      ctx.strokeStyle = placeable(hx,hy,local.build) ? "#22c55e" : "#ef4444";
      ctx.strokeRect(sx+1,sy+1,local.scale-2,local.scale-2);
      ctx.restore();
    }
  }
  requestAnimationFrame(draw);
}
requestAnimationFrame(draw);

/* ---------------- Turn Flow (ROLL AT END) ---------------- */
function setEndingUI(on){
  endingTurn = on;
  btnEndTurn.textContent = on ? 'Ending‚Ä¶' : 'End Turn';
  updateHud();
}
async function endTurnSafely(){
  if(!alive()){ toast('You are eliminated.'); return; }
  if(!isMyTurn()){ toast('Not your turn'); return; }
  if(endingTurn) return;
  setEndingUI(true);
  try{
    await applyEndTurn();
  }catch(err){
    console.error(err);
    toast('End turn failed');
  }finally{
    // Button state will also update via snapshot; keep responsive here:
    setEndingUI(false);
  }
}
btnEndTurn.addEventListener('click', ()=> endTurnSafely(), {passive:true});
btnEndTurn.addEventListener('touchend', (e)=>{ e.preventDefault(); endTurnSafely(); }, {passive:false});

btnFullscreen.onclick = ()=> {
  if(!document.fullscreenElement){ playArea.requestFullscreen?.(); }
  else{ document.exitFullscreen?.(); }
};
btnReturnLobby.onclick = ()=>{ window.location.href='/?username='+encodeURIComponent(username); };

// The actual turn logic (kept separate)
async function applyEndTurn(){
  await runTransaction(db, async (tx)=>{
    const snap = await tx.get(gameRef); if(!snap.exists()) return;
    const g = snap.data();
    if(g.playerOrder[g.currentTurn]!==myIndex) return;

    // 1) Roll dice now (END of turn)
    const roll = 2 + Math.floor(Math.random()*6) + Math.floor(Math.random()*6);
    g.lastRoll = roll;
    g.lastRollTurnId = g.turnId;

    // 2) Payout to ALL players based on the roll
    const adj4 = [[0,0],[1,0],[-1,0],[0,1],[0,-1]];
    for(let pi=0; pi<g.players.length; pi++){
      const pl = g.players[pi];
      if(!pl.alive) continue;
      const addRes = {brick:0,ore:0,sheep:0,wheat:0,wood:0};
      for(const b of (pl.bases||[])){
        for(const [dx,dy] of adj4){
          const x=b.x+dx,y=b.y+dy; if(!inBounds(x,y)) continue;
          const t = getTile(g, x,y); if(!t) continue;
          if(t.num===roll){
            const mult = (g.buildings.some(bb=>bb.kind==='drill'&&bb.x===x&&bb.y===y)?3:1) * (b.type==='base'?2:1);
            const rkey = RESOURCE_BY_COLOR[t.color];
            addRes[rkey] += mult;
          }
        }
      }
      for(const k of R_KEYS){ pl.res[k]=(pl.res[k]||0)+(addRes[k]||0); }
    }

    // 3) Current player's defenses fire
    fireDefenses(g,myIndex);

    // 4) If 7, zombies take an extra step now
    if(roll===7){ zombiesAdvance(g); }

    // 5) End-of-turn zombies move 1 and spawn 1
    zombiesAdvance(g);
    spawnEdgeZombies(g, 1);

    // 6) Next turn logic & round wrap
    const cur=g.currentTurn;
    let nt=(cur+1)%g.playerOrder.length;
    for(let guard=0; guard<8; guard++){
      const pi=g.playerOrder[nt]; if(g.players[pi]?.alive) break;
      nt=(nt+1)%g.playerOrder.length;
    }
    const wrapped = (nt<=cur);
    if(wrapped){
      g.round++;
      g.zombiesPerEdge = Math.min(6, g.zombiesPerEdge+1);
      if(g.round%5===0) g.zombieBaseHP+=1;
      spawnEdgeZombies(g, g.zombiesPerEdge);

      // CARE PACKAGES at start of every even round
      if(g.round % 2 === 0){
        for(let i=0;i<g.players.length;i++){
          const p = g.players[i];
          if(!p.alive) continue;
          const picks = [pickRes(), pickRes(), pickRes()];
          const counts = {brick:0,ore:0,sheep:0,wheat:0,wood:0};
          for(const k of picks){ counts[k]++; }
          for(const k of R_KEYS){ p.res[k] = (p.res[k]||0) + counts[k]; }
          p.freeWire = (p.freeWire||0) + 1; // free wire token
          p.lastCareRound = g.round;
          p.careShow = [
            ...R_KEYS.filter(k=>counts[k]>0).map(k=>({k, n:counts[k]})),
            {k:'wire', n:1}
          ];
        }
      }
    }

    // alive flags
    for(let i=0;i<g.players.length;i++){
      const still = g.buildings.some(b=>b.owner===i&&(b.kind==='cc'||b.kind==='base'));
      g.players[i].alive = !!still;
      if(!still) g.players[i].bases=[];
    }

    // next turn timing + new turn id
    g.currentTurn = nt;
    g.turnEndsAt = Date.now()+TURN_SECONDS*1000;
    g.turnId = (g.turnId||0) + 1;

    await tx.update(gameRef,g);
  });
}
function pickRes(){ return R_KEYS[Math.floor(Math.random()*R_KEYS.length)]; }
async function forceEndTurn(){ if(endingTurn) return; if(state && state.playerOrder[state.currentTurn]===myIndex) await endTurnSafely(); }

/* ---------------- Zombies / Pathing & Attacks ---------------- */
function zombiesAdvance(g){
  const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
  const walkable = (x,y)=>{
    const occ = g.buildings.find(b=>b.x===x&&b.y===y && b.kind!=='wire');
    return !occ;
  };

  for(const z of g.zombies){
    // 0) Damage any building on the current tile
    const onIdx = g.buildings.findIndex(b=>b.x===z.x && b.y===z.y);
    if(onIdx>=0){
      g.buildings[onIdx].hp -= 1;
      if(g.buildings[onIdx].hp<=0){
        const owner = g.buildings[onIdx].owner;
        g.buildings.splice(onIdx,1);
        pruneDisconnected(g,owner);
      }
    }

    // 1) Determine target (nearest alive base)
    const targets=[];
    g.players.forEach((p)=>{ if(!p.alive) return; for(const bb of p.bases||[]) targets.push({x:bb.x,y:bb.y}); });
    if(!targets.length) continue;
    const goal = nearest(targets, z.x,z.y);

    // 2) Try step toward goal
    const step = bfsStep(z.x,z.y, goal.x,goal.y, walkable);

    if(step){
      z.x=step.x; z.y=step.y;
      // After moving, if it moved onto a building tile, it will damage it next tick via step 0
    }else{
      // 3) If blocked: attack adjacent ANY building (prefer walls if present)
      const adjIdxWall = dirs
        .map(([dx,dy])=> g.buildings.findIndex(b=>b.x===z.x+dx&&b.y===z.y+dy&&(b.kind==='wall'||b.kind==='uwall')))
        .find(ix=>ix>=0);
      let targetIdx = adjIdxWall;
      if(targetIdx<0){
        targetIdx = dirs
          .map(([dx,dy])=> g.buildings.findIndex(b=>b.x===z.x+dx&&b.y===z.y+dy))
          .find(ix=>ix>=0);
      }
      if(targetIdx>=0){
        g.buildings[targetIdx].hp -= 1;
        if(g.buildings[targetIdx].hp<=0){
          const owner = g.buildings[targetIdx].owner;
          g.buildings.splice(targetIdx,1);
          pruneDisconnected(g,owner);
        }
      }
    }
  }
  // Cleanup
  g.buildings = g.buildings.filter(b=> b.hp==null || b.hp>0 );
}
function nearest(arr,x,y){
  let best=arr[0], bd=1e9;
  for(const t of arr){ const d=Math.abs(t.x-x)+Math.abs(t.y-y); if(d<bd){ bd=d; best=t; } }
  return best;
}
function bfsStep(sx,sy,tx,ty,pass){
  if(sx===tx && sy===ty) return null;
  const Q=[[sx,sy]], seen=new Set([sx+','+sy]), from=new Map();
  const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
  while(Q.length){
    const [x,y]=Q.shift();
    for(const [dx,dy] of dirs){
      const nx=x+dx, ny=y+dy; const key=nx+','+ny;
      if(!inBounds(nx,ny) || seen.has(key)) continue;
      if(!pass(nx,ny) && !(nx===tx&&ny===ty)) continue;
      seen.add(key); from.set(key,[x,y]);
      if(nx===tx && ny===ty){
        let cur=[nx,ny], prev=[x,y];
        while(prev[0]!==sx || prev[1]!==sy){
          cur=prev; const pkey=prev[0]+','+prev[1];
          prev=from.get(pkey)||[sx,sy];
          if(prev[0]===sx && prev[1]===sy) break;
        }
        return {x:cur[0],y:cur[1]};
      }
      Q.push([nx,ny]);
    }
  }
  return null;
}
function spawnEdgeZombies(g,count){
  for(let i=0;i<count;i++){
    const edge=Math.floor(Math.random()*4);
    let x=0,y=0;
    if(edge===0){ x=Math.floor(Math.random()*W); y=0; }
    if(edge===1){ x=Math.floor(Math.random()*W); y=H-1; }
    if(edge===2){ x=0; y=Math.floor(Math.random()*H); }
    if(edge===3){ x=W-1; y=Math.floor(Math.random()*H); }
    if(g.zombies.some(z=>z.x===x&&z.y===y)){ i--; continue; }
    g.zombies.push({x,y,hp:g.zombieBaseHP,maxhp:g.zombieBaseHP});
  }
}

/* ---------------- Connectivity Prune ---------------- */
function pruneDisconnected(g, owner){
  const needs = (b)=> !['wall','uwall'].includes(b.kind);
  const sources = [
    ...(g.players[owner].bases||[]).map(b=>({x:b.x,y:b.y})),
    ...g.buildings.filter(b=>b.owner===owner && b.kind==='wire').map(w=>({x:w.x,y:w.y}))
  ];
  const seen=new Set(sources.map(s=>s.x+','+s.y));
  const Q=[...sources.map(s=>[s.x,s.y])];
  const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
  while(Q.length){
    const [x,y]=Q.shift();
    for(const [dx,dy] of dirs){
      const nx=x+dx, ny=y+dy; if(!inBounds(nx,ny)) continue;
      const key=nx+','+ny; if(seen.has(key)) continue;
      const isWire = g.buildings.some(b=>b.x===nx&&b.y===ny&&b.kind==='wire'&&b.owner===owner);
      const isBase = (g.players[owner].bases||[]).some(b=>b.x===nx&&b.y===ny);
      const isPow  = g.buildings.some(b=>b.x===nx&&b.y===ny&&needs(b)&&b.owner===owner);
      if(isWire||isBase||isPow){ seen.add(key); Q.push([nx,ny]); }
    }
  }
  g.buildings = g.buildings.filter(b=>{
    if(b.owner!==owner) return true;
    if(!needs(b)) return true;
    return seen.has(b.x+','+b.y);
  });
}

/* ---------------- Defenses (incl. Mortar) ---------------- */
function fireDefenses(g, owner){
  const towers = g.buildings.filter(b=>b.owner===owner && ['turret','cata','beacon','tesla','tribolt','mortar'].includes(b.kind));
  for(const t of towers){
    if(g.zombies.length===0) continue;
    const rangeOf = (k)=>{
      let r=(k==='turret')?5:(k==='cata')?6:(k==='beacon')?4:(k==='tesla')?5:(k==='tribolt')?6:(k==='mortar')?8:4;
      if(t.level>1) r++;
      return r;
    };
    const dmgOf   = (k)=>{
      let d=(k==='turret')?2:(k==='cata')?1:(k==='beacon')?1:(k==='tesla')?2:(k==='tribolt')?1:(k==='mortar')?2:1;
      if(t.level>1) d++;
      return d;
    };
    const inR = (z)=> Math.abs(z.x-t.x)+Math.abs(z.y-t.y) <= rangeOf(t.kind);
    const targets = g.zombies.filter(inR);
    if(targets.length===0) continue;

    if(t.kind==='turret'){
      hitNearest(targets,1,dmgOf('turret'));
    }else if(t.kind==='cata'){
      const z = nearest(targets,t.x,t.y);
      for(const zz of g.zombies){ if(Math.abs(zz.x-z.x)<=1 && Math.abs(zz.y-z.y)<=1) zz.hp -= dmgOf('cata'); }
    }else if(t.kind==='beacon'){
      for(const zz of g.zombies){ if(Math.abs(zz.x-t.x)<=2 && Math.abs(zz.y-t.y)<=2) zz.hp -= dmgOf('beacon'); }
    }else if(t.kind==='tesla'){
      let chain=[]; let cur=nearest(targets,t.x,t.y); chain.push(cur);
      for(let hops=0;hops<5;hops++){
        const nxt = g.zombies.find(z=>!chain.includes(z) && (Math.abs(z.x-cur.x)+Math.abs(z.y-cur.y)===1));
        if(!nxt) break; chain.push(nxt); cur=nxt;
      }
      for(const zz of chain){ zz.hp -= dmgOf('tesla'); }
    }else if(t.kind==='tribolt'){
      hitNearest(targets, Math.min(3,targets.length), dmgOf('tribolt'));
    }else if(t.kind==='mortar'){
      const z = nearest(targets,t.x,t.y); // explode 3x3
      for(const zz of g.zombies){ if(Math.abs(zz.x-z.x)<=1 && Math.abs(zz.y-z.y)<=1) zz.hp -= dmgOf('mortar'); }
    }
  }
  g.zombies = g.zombies.filter(z=>z.hp>0);
  function hitNearest(arr,n,d){
    arr.sort((a,b)=> (Math.abs(a.x-t.x)+Math.abs(a.y-t.y)) - (Math.abs(b.x-t.x)+Math.abs(b.y-t.y)));
    for(let i=0;i<n;i++) if(arr[i]) arr[i].hp -= d;
  }
}

/* ---------------- Trades ---------------- */
const tradesRef = collection(db, "zombiezone", gameId, "trades");
document.getElementById('btnPostTrade').onclick = async ()=>{
  if(!alive()) return;
  const giveK=tradeGive.value, wantK=tradeWant.value;
  const giveN=Math.max(1,parseInt(tradeGiveAmt.value||'1'));
  const wantN=Math.max(1,parseInt(tradeWantAmt.value||'1'));
  if(state.players[myIndex].res[giveK] < giveN) return;
  await addDoc(tradesRef,{from:username,give:{[giveK]:giveN},want:{[wantK]:wantN},createdAt:serverTimestamp()});
};
onSnapshot(tradesRef,(snap)=>{
  const items=[]; snap.forEach(d=>items.push({id:d.id,...d.data()}));
  renderTrades(items);
});
function renderTrades(items=[]){
  tradesEl.innerHTML='';
  items.forEach(t=>{
    const row=document.createElement('div');
    row.className='trade-item';
    row.style.display='flex';
    row.style.alignItems='center';
    row.style.justifyContent='space-between';
    row.style.gap='8px';
    row.style.padding='8px';
    row.style.border='1px solid #192e50';
    row.style.borderRadius='12px';
    row.style.background='#0b1322';

    const left=document.createElement('div');
    left.textContent=`${t.from} offers ${fmtRes(t.give)} for ${fmtRes(t.want)}`;

    const right=document.createElement('div');
    if(t.from!==username && alive()){
      const b=document.createElement('button'); b.className='btn'; b.textContent='Accept'; b.onclick=()=>acceptTrade(t); right.appendChild(b);
    }else{
      const b=document.createElement('button'); b.className='btn'; b.textContent='Cancel'; b.onclick=()=>deleteDoc(doc(db,"zombiezone",gameId,"trades",t.id)); right.appendChild(b);
    }
    row.append(left,right);
    tradesEl.appendChild(row);
  });
}
function fmtRes(o){ const k=Object.keys(o||{})[0]; return `${o[k]} ${k}`; }
async function acceptTrade(t){
  await runTransaction(db, async (tx)=>{
    const gs=await tx.get(gameRef); if(!gs.exists()) return;
    const g=gs.data();
    const fromIdx=g.players.findIndex(p=>p.name===t.from);
    const toIdx=myIndex;
    const gk=Object.keys(t.give||{})[0], gv=t.give[gk];
    const wk=Object.keys(t.want||{})[0], wv=t.want[wk];
    if((g.players[fromIdx].res[gk]||0)<gv) return;
    if((g.players[toIdx].res[wk]||0)<wv) return;
    g.players[fromIdx].res[gk]-=gv;
    g.players[toIdx].res[gk]=(g.players[toIdx].res[gk]||0)+gv;
    g.players[toIdx].res[wk]-=wv;
    g.players[fromIdx].res[wk]=(g.players[fromIdx].res[wk]||0)+wv;
    await tx.update(gameRef,g);
  });
  try{ await deleteDoc(doc(db,"zombiezone",gameId,"trades",t.id)); }catch(e){}
}

/* ---------------- Timer hooks ---------------- */
let lastTurnSeen=-1;
onSnapshot(gameRef,(snap)=>{
  if(!snap.exists()) return;
  const g=snap.data();
  if(g.currentTurn!==lastTurnSeen){
    lastTurnSeen=g.currentTurn;
    startTimer();
  }
});

/* ---------------- Init ---------------- */
await ensureGame();
requestAnimationFrame(draw);

</script>
</body>
</html>







