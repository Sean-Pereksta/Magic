<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Wild Matches — Multiplayer</title>
<style>
  :root{
    --ink:#0a1b12; --muted:#54705f; --bg:#08120c; --pane:#0e1b14; --edge:#1a3a2a;
    --accent:#0ea35a; --accent-2:#0a7a44;
    --h:48px; --scoresH:38px; --oppsH:46px; --handH:102px;
    --riverW:min(96vw,720px);
    --cardW: clamp(48px, 9vw, 66px); --cardH: calc(var(--cardW) * 1.33);
    --handBottomOffset: 10vh;
    --sbW: 240px; --sbGap: 8px;
    --padR: 0px;
  }
  @media (min-width: 901px){ :root{ --handBottomOffset: 8vh; } }
  @media (max-width: 540px){ :root{ --sbW: 200px; } }

  body.sb-open{ --padR: calc(var(--sbW) + var(--sbGap)); }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    background:
      radial-gradient(900px 600px at 60% -10%, #173626 0%, #0c1a12 50%, #08120c 100%),
      linear-gradient(180deg, #0b1711, #08120c);
    color:var(--ink);font:600 12px/1.25 system-ui,Segoe UI,Inter,Roboto,Arial,sans-serif;overflow:hidden;
    -webkit-tap-highlight-color:transparent
  }
  button{appearance:none;border:1px solid #24563e;background:#133022;color:#e6fff2;border-radius:10px;padding:6px 10px;font-weight:800;font-size:12px;cursor:pointer}
  button:active{transform:translateY(1px)}
  .top{position:fixed;inset:0 0 auto 0;height:var(--h);display:flex;align-items:center;justify-content:space-between;padding:6px 8px}
  .brand{display:flex;align-items:center;gap:8px}
  .logo{width:28px;height:28px;border-radius:8px;display:grid;place-items:center;background:#ffffff0f;border:1px solid #ffffff1e;font-size:16px}
  .title{font-weight:900;letter-spacing:.2px}
  .controls{display:flex;align-items:center;gap:6px}
  .badge{padding:3px 8px;border-radius:999px;background:#112a1e;border:1px solid #205238;color:#d6ffe8;font-size:11px}
  .host{background:#163a29;border-color:#246a4a}
  .leave{background:#2b0f17;border-color:#541a27}
  .ghost{background:#12261c;border-color:#234c37}

  .scoresBar{position:fixed;left:0;right:0;top:var(--h);height:var(--scoresH);display:flex;align-items:center;justify-content:center;padding:0 6px}
  .scores-inner{width:calc(var(--riverW) + var(--padR));display:flex;gap:6px;justify-content:center;overflow:auto;-webkit-overflow-scrolling:touch}
  .sc{display:flex;align-items:center;gap:6px;padding:3px 8px;border-radius:999px;border:1px solid #214e38;background:#0f2419;white-space:nowrap;font-size:11px;color:#e2ffe8}
  .sc .dot{width:10px;height:10px;border-radius:50%}
  .m1{border-color:#e6c200;background:linear-gradient(180deg,#2b2500,#0f1200);color:#ffe680}
  .m1 .dot{background:#ffd700}
  .m2{border-color:#b6bcc6;background:linear-gradient(180deg,#1d2127,#0e1216);color:#e5e9f0}
  .m2 .dot{background:#c0c0c0}
  .m3{border-color:#b2732a;background:linear-gradient(180deg,#23160a,#0f0b07);color:#ffd9b3}
  .m3 .dot{background:#cd7f32}

  .opps{position:fixed;left:0;right:0;top:calc(var(--h) + var(--scoresH));height:var(--oppsH);display:flex;align-items:center;justify-content:center;padding:0 6px}
  .opps-inner{width:calc(var(--riverW) + var(--padR));display:flex;gap:6px;justify-content:center;overflow:hidden}
  .opp{flex:1 1 0;min-width:0;border:1px solid var(--edge);background:#0f2419;border-radius:8px;padding:4px 6px;display:flex;align-items:center;gap:6px;color:#e6fff2}
  .opp .name{font-weight:900;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .mini{display:flex;gap:3px;margin-left:auto}
  .mini i{width:14px;height:20px;border-radius:4px;background:#0f2c20;border:1px solid #1b513b;display:block}
  .revealMini{display:flex;gap:6px;margin-left:auto;font-size:11px;color:#d6ffe8;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .flag{font-size:12px;opacity:.9}
  .flag.sil{color:#fbbf24}
  .flag.shd{color:#60a5fa}

  .main{
    position:absolute;
    inset:calc(var(--h) + var(--scoresH) + var(--oppsH)) 0 calc(env(safe-area-inset-bottom) + var(--handH) + var(--handBottomOffset) + 60px) 0;
    display:grid;place-items:center;
    padding-right: var(--padR);
  }
  .riverWrap{width:var(--riverW);margin:0 auto}
  .river{display:grid;grid-template-columns:repeat(5,var(--cardW));grid-auto-rows:var(--cardH);gap:6px}
  .slot{width:var(--cardW);height:var(--cardH);border-radius:8px;border:1px solid var(--edge);background:#0f2419;display:grid;place-items:center;position:relative}
  .slot.empty{border-style:dashed;opacity:.6}
  .card{width:calc(100% - 6px);height:calc(100% - 6px);border-radius:8px;border:1px solid #1f4a37;background:#113624;position:relative;overflow:hidden;color:#eafff2}
  .front,.back{position:absolute;inset:0;display:grid;place-items:start;padding:5px}
  .front .t{font-weight:900;font-size:11px}
  .front .f{font-size:10px;color:#d3ffe0cc}
  .sel{outline:3px solid var(--accent);outline-offset:2px}
  .frozen .slot{filter:grayscale(.2) contrast(.92);opacity:.88}
  .flipGlow .slot{box-shadow:0 0 0 2px #0ea35a99 inset}
  .back{
    background:
      linear-gradient(45deg, #163a29 25%, transparent 25%, transparent 75%, #163a29 75%),
      linear-gradient(45deg, #163a29 25%, transparent 25%, transparent 75%, #163a29 75%);
    background-size: 12px 12px; background-position: 0 0, 6px 6px; background-color:#0b2418;
  }

  .timer{position:absolute;top:4px;right:4px;width:22px;height:22px;display:grid;place-items:center;pointer-events:none;opacity:.92;filter:drop-shadow(0 1px 2px rgba(0,0,0,.65))}
  .timer svg{width:22px;height:22px}
  .timer .track{fill:none;stroke:#1f4a37;stroke-width:3}
  .timer .prog{fill:none;stroke:#0ea35a;stroke-width:3;stroke-linecap:round}
  .timer .txt{position:absolute;font-size:9px;font-weight:900;color:#d5ffe7}

  .suggest{position:fixed;left:0;right:0;bottom:calc(var(--handH) + var(--handBottomOffset) + env(safe-area-inset-bottom) + 6px);display:grid;place-items:center;pointer-events:none}
  .suggest-inner{width:calc(var(--riverW) + var(--padR));display:grid;grid-template-rows:auto auto;gap:6px;pointer-events:all}
  .ready{display:flex;gap:6px;flex-wrap:wrap;justify-content:center}
  .pill{display:flex;flex-direction:column;gap:4px;border:1px solid #214e38;background:#0f2419;border-radius:12px;padding:6px 8px;font-size:11px;color:#d6ffe8;min-width:240px;max-width:calc(var(--riverW) - 12px)}
  .pill .row{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
  .pill .label{font-weight:900}
  .pill .cards{opacity:.9}
  .pill .desc{font-size:10px;opacity:.95}
  .playBtn{background:var(--accent);border-color:#0a7a44;color:#fff;padding:4px 10px;border-radius:999px;font-size:11px;font-weight:900;letter-spacing:.3px}
  .playBtn:hover{filter:brightness(1.05)}
  .playBtn:active{background:var(--accent-2)}

  .handWrap{position:fixed;left:0;right:0;bottom:var(--handBottomOffset);height:calc(var(--handH) + env(safe-area-inset-bottom));padding:6px 8px env(safe-area-inset-bottom)}
  .hand{height:100%;margin:0 auto;width:calc(var(--riverW) + var(--padR));border:1px solid var(--edge);background:#0f2419;border-radius:10px;padding:6px;display:flex;gap:6px;align-items:center;justify-content:center}
  .hslot{width:calc(var(--cardW) * 1.02);height:calc(var(--cardH) * 1.02);border:1px solid var(--edge);background:#0e2218;border-radius:8px;display:grid;place-items:center}
  .hslot.empty{opacity:.5;border-style:dashed}

  .overlay{position:fixed;inset:0;background:rgba(5,10,18,.86);display:none;align-items:center;justify-content:center;z-index:40}
  .overlay.show{display:flex}
  .modal{background:#0f2419;border:1px solid #1b2c48;border-radius:12px;width:min(92vw,420px);padding:12px;box-shadow:0 24px 60px rgba(0,0,0,.45);color:#eafff2}
  .modal h2{margin:0 0 6px 0}
  .modal p{margin:0 0 6px 0;color:#d6ffe8}
  .table{width:100%;border-collapse:collapse;font-size:12px}
  .table td,.table th{border-bottom:1px solid #214e38;padding:6px;text-align:left}
  .table tr:last-child td{border-bottom:none}

  .pick{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(8,12,20,.84);z-index:45}
  .pick.show{display:flex}
  .pickBox{background:#0f2419;border:1px solid #1b2c48;border-radius:12px;width:min(94vw,520px);max-height:min(72vh,520px);overflow:auto;padding:10px;color:#eafff2}
  .pickBox h3{margin:0 0 8px 0;font-size:14px}
  .prow{border:1px solid #214e38;background:#0e2218;border-radius:10px;padding:8px;margin:6px 0}
  .prow h4{margin:0 0 6px 0;font-size:12px;color:#d6ffe8}
  .pcards{display:flex;flex-wrap:wrap;gap:6px}
  .pbtn{font-size:11px;padding:5px 8px;border-radius:9px;border:1px solid #2a6a4d;background:#133022;color:#dbeaff;cursor:pointer}

  .toasts{position:fixed;left:50%;transform:translateX(-50%);top:calc(var(--h) + 4px);display:flex;flex-direction:column;gap:6px;z-index:60;pointer-events:none}
  .toast{background:#0f2419;border:1px solid #214e38;color:#e6efff;padding:6px 8px;border-radius:9px;box-shadow:0 8px 20px rgba(0,0,0,.35);opacity:0;transform:translateY(-6px);animation:tIn .22s ease-out forwards}
  @keyframes tIn{to{opacity:1;transform:translateY(0)}}
  .toast.out{animation:tOut .22s ease-in forwards}
  @keyframes tOut{to{opacity:0;transform:translateY(-6px)}}

  .sidepanel{
    position:fixed; right:6px;
    top:calc(var(--h) + var(--scoresH) + 6px);
    bottom:calc(var(--handH) + var(--handBottomOffset) + env(safe-area-inset-bottom) + 6px);
    width:var(--sbW); background:#0f2419; border:1px solid var(--edge); border-radius:10px;
    display:flex; flex-direction:column; overflow:hidden; z-index:31; color:#eafff2
  }
  .sp-head{display:flex; align-items:center; justify-content:space-between; gap:6px; padding:6px; border-bottom:1px solid #1b2b48}
  .sp-title{font-weight:900}
  .sp-btn{padding:4px 8px; border-radius:999px; font-size:11px}
  .sp-body{overflow:auto; padding:6px}
  .comboRow{border:1px solid #214e38; background:#0f2419; color:#d6ffe8; border-radius:10px; padding:6px; margin-bottom:6px; display:grid; gap:2px}
  .comboRow .r1{display:flex; align-items:center; justify-content:space-between; gap:8px}
  .comboRow .cName{font-weight:900; font-size:11px}
  .comboRow .cPts{opacity:.9; font-size:11px}
  .comboRow .req{font-size:12px; opacity:.95}
  .comboRow .eff{font-size:10px; opacity:.9}
  .sidepanel.min{ width:40px; }
  .sidepanel.min .sp-body{ display:none; }
  .sidepanel.min .sp-title{ display:none; }
  .sidepanel.min .sp-head{ justify-content:center; }
  @media (max-width: 480px){
    body:not(.persist-open) .sidepanel{ width:40px; }
    body:not(.persist-open) .sidepanel .sp-body{ display:none; }
    body:not(.persist-open) .sidepanel .sp-title{ display:none; }
    body:not(.persist-open){ --padR: 48px; }
  }
</style>
</head>
<body class="sb-open">
  <div class="top">
    <div class="brand">
      <div class="logo">🌿</div>
      <div class="title">Wild Matches</div>
      <span class="badge" id="hostBadge" hidden>Host</span>
      <span class="badge" id="gameIdBadge"></span>
      <span class="badge" id="banBadge" hidden></span>
    </div>
    <div class="controls">
      <span class="badge" id="deckBadge">Deck: 0</span>
      <span class="badge" id="discardBadge">Discard: 0</span>
      <button class="host" id="startBtn" hidden>Deal & Start</button>
      <button class="ghost" id="fsBtn" title="Fullscreen">⛶</button>
      <button class="leave" id="leaveBtn">Lobby</button>
    </div>
  </div>

  <div class="scoresBar"><div class="scores-inner" id="scores"></div></div>
  <div class="opps"><div class="opps-inner" id="opps"></div></div>

  <main class="main">
    <div class="riverWrap">
      <div class="river" id="river"></div>
    </div>
  </main>

  <div class="suggest">
    <div class="suggest-inner">
      <div class="ready" id="ready"></div>
      <div class="ready" id="near"></div>
    </div>
  </div>

  <div class="handWrap"><div class="hand" id="hand"></div></div>

  <aside id="comboPanel" class="sidepanel">
    <div class="sp-head">
      <span class="sp-title">Combos (Pairs & Sets)</span>
      <button id="spToggle" class="sp-btn">«</button>
    </div>
    <div class="sp-body" id="comboList"></div>
  </aside>

  <div class="overlay" id="over">
    <div class="modal">
      <h2 id="overTitle">Game Over</h2>
      <p id="overWhy"></p>
      <table class="table" id="overTable"></table>
      <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:8px">
        <button id="toLobbyBtn">Back to Lobby</button>
      </div>
    </div>
  </div>

  <div class="pick" id="pick">
    <div class="pickBox">
      <h3 id="pickTitle">Pick a target</h3>
      <div id="pickBody"></div>
      <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:8px">
        <button id="pickCancel">Cancel</button>
      </div>
    </div>
  </div>

  <div class="toasts" id="toasts"></div>

<script type="module">
/* ======= Firebase ======= */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc, runTransaction, onSnapshot,
  serverTimestamp
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

/* ======= URL / Lobby ======= */
const qp = new URLSearchParams(location.search);
const gameId = qp.get('gameId') || '';
const username = (qp.get('username') || '').trim();
const LOBBY_URL = "/";

if (!gameId || !username) alert("Missing gameId or username in URL.");

const gref = doc(db, "games", gameId);
const uref = doc(db, "users", username);

/* ======= Cards & combos (Nature Theme) ======= */

/* Families */
const F = {
  Plant:  'Plant',
  Animal: 'Animal',
  Weather:'Weather',
  Water:  'Water',
  Habitat:'Habitat',

  /* Back-compat keys used in a couple effect helpers */
  Beast:  'Animal',   // used by discardNonBeastEach handler
  Relic:  'Habitat'   // (we don't use destroyRelicEach in nature set)
};

/* Card list */
const CARDS = [
  // Plants
  {id:'Seed',     name:'Seed',      fam:F.Plant,   emoji:'🌱', tier:1},
  {id:'Flower',   name:'Flower',    fam:F.Plant,   emoji:'🌼', tier:2},
  {id:'Tree',     name:'Tree',      fam:F.Plant,   emoji:'🌳', tier:3},
  {id:'Vine',     name:'Vine',      fam:F.Plant,   emoji:'🌿', tier:2},
  {id:'Mushroom', name:'Mushroom',  fam:F.Plant,   emoji:'🍄', tier:2},

  // Animals
  {id:'Bee',      name:'Bee',       fam:F.Animal,  emoji:'🐝', tier:2},
  {id:'Bird',     name:'Bird',      fam:F.Animal,  emoji:'🐦', tier:2},
  {id:'Wolf',     name:'Wolf',      fam:F.Animal,  emoji:'🐺', tier:2},
  {id:'Bear',     name:'Bear',      fam:F.Animal,  emoji:'🐻', tier:3},
  {id:'Fish',     name:'Fish',      fam:F.Animal,  emoji:'🐟', tier:1},

  // Weather
  {id:'Sun',      name:'Sun',       fam:F.Weather, emoji:'☀️', tier:1},
  {id:'Rain',     name:'Rain',      fam:F.Weather, emoji:'🌧️', tier:1},
  {id:'Storm',    name:'Storm',     fam:F.Weather, emoji:'⛈️', tier:2},
  {id:'Snow',     name:'Snow',      fam:F.Weather, emoji:'❄️', tier:2},
  {id:'Wind',     name:'Wind',      fam:F.Weather, emoji:'🌬️', tier:1},
  {id:'Rainbow',  name:'Rainbow',   fam:F.Weather, emoji:'🌈', tier:3},

  // Water
  {id:'River',    name:'River',     fam:F.Water,   emoji:'🏞️', tier:2},
  {id:'Lake',     name:'Lake',      fam:F.Water,   emoji:'🫧',  tier:1},
  {id:'Falls',    name:'Waterfall', fam:F.Water,   emoji:'💦',  tier:2},
  {id:'Glacier',  name:'Glacier',   fam:F.Water,   emoji:'🧊',  tier:3},

  // Habitats
  {id:'Hive',     name:'Hive',      fam:F.Habitat, emoji:'🏠🐝', tier:2},
  {id:'Nest',     name:'Nest',      fam:F.Habitat, emoji:'🪺',   tier:2},
  {id:'Den',      name:'Den',       fam:F.Habitat, emoji:'🕳️',   tier:2},
  {id:'Dam',      name:'Dam',       fam:F.Habitat, emoji:'🪵🌊',  tier:3},
];

/* Family icon used in side panel */
function famIcon(fam){
  if (fam === 'Plant')   return '🌿';
  if (fam === 'Animal')  return '🐾';
  if (fam === 'Weather') return '⛅';
  if (fam === 'Water')   return '💧';
  if (fam === 'Habitat') return '🏡';
  return '❓';
}

const byId = Object.fromEntries(CARDS.map(c=>[c.id,c]));
const NEED = {
  id:(id)=>({id,label:byId[id].name, test:c=>c.id===id}),
  fam:(fam)=>({fam,label:fam, test:c=>c.fam===fam}),
};

/* Effect legend + descriptions (unchanged structure) */
const ICON = {
  steal:'🫴', destroy:'💥', freeze:'🧊', flip:'🔁', reveal:'👁️',
  draw:'➕', duplicate:'🪞', shield:'🛡️', scry:'🔮', refresh:'♻️',
  swap:'🔀', ban:'🚫', trade:'🔁', silence:'🤐', cull:'🪓', discard:'🗑️', points:'⭐'
};
function effectDescription(combo){
  const e = combo.effect || '';
  if (!e) return `${ICON.points} +${combo.pts}`;
  if (e.startsWith('stealEach'))       return `${ICON.steal} Steal 1 from all`;
  if (e.startsWith('stealTarget:'))    return `${ICON.steal} Steal a ${e.split(':')[1]}`;
  if (e.startsWith('duplicateTarget')) return `${ICON.duplicate} Duplicate any card`;
  if (e.startsWith('destroyTarget'))   return `${ICON.destroy} Destroy any card`;
  if (e.startsWith('freeze:'))         return `${ICON.freeze} Freeze river ${Math.round((+e.split(':')[1]||0)/1000)}s`;
  if (e.startsWith('flip:'))           return `${ICON.flip} Reveal center ${Math.round((+e.split(':')[1]||0)/1000)}s`;
  if (e.startsWith('revealOpp:'))      return `${ICON.reveal} Reveal opponents ${Math.round((+e.split(':')[1]||0)/1000)}s`;
  if (e.startsWith('draw:'))           return `${ICON.draw} Draw ${e.split(':')[1]}`;
  if (e==='refreshColumn')             return `${ICON.refresh} Refresh a column`;
  if (e==='swapRiver')                 return `${ICON.swap} Swap two center cards`;
  if (e.startsWith('refreshRow:'))     return `${ICON.refresh} Refresh ${e.endsWith('top')?'top':'bottom'} row`;
  if (e.startsWith('shieldSelf:'))     return `${ICON.shield} Shield ${Math.round((+e.split(':')[1]||0)/1000)}s`;
  if (e.startsWith('scry:'))           return `${ICON.scry} Scry top ${e.split(':')[1]}`;
  if (e.startsWith('banFam:'))         return `${ICON.ban} Ban ${e.split(':')[1]} ${Math.round((+e.split(':')[2]||0)/1000)}s`;
  if (e.startsWith('discardEach:'))    return `${ICON.discard} All foes discard ${e.split(':')[1]}`;
  if (e==='discardNonBeastEach:1')     return `${ICON.cull} Foes discard non-Animals`;
  if (e.startsWith('tradeRandom'))     return `${ICON.trade} Trade a random card`;
  if (e.startsWith('silenceTarget:'))  return `${ICON.silence} Silence ${Math.round((+e.split(':')[1]||0)/1000)}s`;
  if (e.startsWith('legend:'))         return `🌟 Legend combo`;
  return `${ICON.points} +${combo.pts}`;
}

/* Nature combos — intuitive reads */
const COMBOS = [
  {key:'Germination',     label:'Germination',      pts:12, need:[NEED.id('Seed'),NEED.id('Rain'),NEED.id('Sun')], effect:'draw:1'},
  {key:'Photosynthesis',  label:'Photosynthesis',   pts:14, need:[NEED.id('Tree'),NEED.id('Sun'),NEED.id('Rain')], effect:'shieldSelf:4000'},
  {key:'Pollination',     label:'Pollination',      pts:13, need:[NEED.id('Flower'),NEED.id('Bee'),NEED.id('Sun')], effect:'scry:3'},
  {key:'HoneyHarvest',    label:'Honey Harvest',    pts:15, need:[NEED.id('Bee'),NEED.id('Flower'),NEED.id('Hive')], effect:'stealEach:1'},
  {key:'NestBuilding',    label:'Nest Building',    pts:10, need:[NEED.id('Bird'),NEED.id('Vine'),NEED.id('Nest')], effect:'draw:1'},
  {key:'SalmonRun',       label:'Salmon Run',       pts:12, need:[NEED.id('River'),NEED.id('Fish'),NEED.id('Bear')], effect:'stealTarget:Animal'},
  {key:'BeaverWorks',     label:'Beaver Works',     pts:14, need:[NEED.id('Dam'),NEED.id('River'),NEED.id('Tree')], effect:'refreshColumn'},
  {key:'WinterShelter',   label:'Winter Shelter',   pts:11, need:[NEED.id('Bear'),NEED.id('Den'),NEED.id('Snow')], effect:'shieldSelf:5000'},
  {key:'Migration',       label:'Migration',        pts:9,  need:[NEED.id('Bird'),NEED.id('Wind'),NEED.id('Sun')], effect:'revealOpp:3000'},
  {key:'Bloom',           label:'Bloom',            pts:8,  need:[NEED.id('Flower'),NEED.id('Rain'),NEED.id('Sun')], effect:'flip:3000'},
  {key:'Icestorm',        label:'Icestorm',         pts:12, need:[NEED.id('Snow'),NEED.id('Storm'),NEED.id('Wind')], effect:'freeze:4000'},
  {key:'RainbowAfterRain',label:'Rainbow After Rain',pts:10,need:[NEED.id('Rain'),NEED.id('Sun'),NEED.id('Rainbow')], effect:'scry:2'},
  {key:'Floodwaters',     label:'Floodwaters',      pts:16, need:[NEED.id('Storm'),NEED.id('Rain'),NEED.id('River')], effect:'refreshRow:bottom'},

  {key:'AnimalTrio',      label:'Animal Trio',      pts:12, need:[NEED.fam(F.Animal), NEED.fam(F.Animal), NEED.fam(F.Animal)], effect:'banFam:Weather:4000'},
  {key:'PlantTrio',       label:'Plant Trio',       pts:12, need:[NEED.fam(F.Plant),  NEED.fam(F.Plant),  NEED.fam(F.Plant)],  effect:'scry:3'},
  {key:'WeatherParade',   label:'Weather Parade',   pts:10, need:[NEED.fam(F.Weather),NEED.fam(F.Weather),NEED.fam(F.Weather)], effect:'refreshColumn'},
  {key:'HabitatSet',      label:'Habitat Set',      pts:14, need:[NEED.fam(F.Habitat),NEED.fam(F.Habitat),NEED.fam(F.Habitat)], effect:'draw:1'},
  {key:'WaterCycle',      label:'Water Cycle',      pts:18, need:[NEED.id('Lake'),NEED.id('River'),NEED.id('Falls'),NEED.id('Sun')], effect:'swapRiver'},
    {key:'MyceliumNetwork',  label:'Mycelium Network',   pts:11, need:[NEED.id('Mushroom'),NEED.id('Tree'),NEED.id('Rain')], effect:'scry:2'},
  {key:'HiveDefense',      label:'Hive Defense',       pts:10, need:[NEED.id('Hive'),NEED.id('Bee'),NEED.id('Wind')], effect:'shieldSelf:4000'},
  {key:'SpawningGrounds',  label:'Spawning Grounds',   pts:9,  need:[NEED.id('Lake'),NEED.id('Fish'),NEED.id('Sun')], effect:'draw:1'},
  {key:'ForestCanopy',     label:'Forest Canopy',      pts:10, need:[NEED.id('Tree'),NEED.id('Bird'),NEED.id('Nest')], effect:'revealOpp:2500'},
  {key:'PredatorsDomain',  label:'Predator’s Domain',  pts:12, need:[NEED.id('Wolf'),NEED.id('Den'),NEED.id('Snow')],  effect:'banFam:Plant:4000'},
  {key:'LightningStrike',  label:'Lightning Strike',   pts:13, need:[NEED.id('Storm'),NEED.id('Tree'),NEED.id('Wind')], effect:'destroyTarget:any'},
  {key:'Thaw',             label:'Thaw',               pts:10, need:[NEED.id('Sun'),NEED.id('Glacier'),NEED.id('River')], effect:'refreshRow:bottom'},
  {key:'Rainmaker',        label:'Rainmaker',          pts:9,  need:[NEED.id('Lake'),NEED.id('Sun'),NEED.id('Wind')], effect:'refreshColumn'},
  {key:'BloomingMeadow',   label:'Blooming Meadow',    pts:11, need:[NEED.id('Flower'),NEED.id('Tree'),NEED.id('Bee')], effect:'scry:2'},
  {key:'Waterwheel',       label:'Waterwheel',         pts:10, need:[NEED.id('Dam'),NEED.id('River'),NEED.id('Wind')], effect:'draw:1'},
  {key:'AuroraChill',      label:'Aurora Chill',       pts:12, need:[NEED.id('Rainbow'),NEED.id('Glacier'),NEED.id('Wind')], effect:'freeze:4000'},
  {key:'FertileDelta',     label:'Fertile Delta',      pts:9,  need:[NEED.id('River'),NEED.id('Sun'),NEED.id('Seed')], effect:'draw:1'},
  {key:'FoggyMorning',     label:'Foggy Morning',      pts:8,  need:[NEED.id('Lake'),NEED.id('Wind'),NEED.id('Tree')], effect:'flip:2500'},
  {key:'Monsoon',          label:'Monsoon',            pts:14, need:[NEED.id('Storm'),NEED.id('Rain'),NEED.id('Wind')], effect:'refreshRow:top'},
  {key:'PollinatorSwarm',  label:'Pollinator Swarm',   pts:12, need:[NEED.id('Bee'),NEED.id('Bee'),NEED.id('Flower')], effect:'scry:3'},
  {key:'PackHunt',         label:'Pack Hunt',          pts:13, need:[NEED.id('Wolf'),NEED.id('Wolf'),NEED.id('Bird')], effect:'stealTarget:Animal'},
  {key:'DeepHibernate',    label:'Deep Hibernate',     pts:12, need:[NEED.id('Bear'),NEED.id('Glacier'),NEED.id('Den')], effect:'shieldSelf:6000'},
  {key:'RiverTrade',       label:'River Trade',        pts:9,  need:[NEED.id('River'),NEED.id('Nest'),NEED.id('Fish')], effect:'tradeRandom'},
  {key:'CleanSweep',       label:'Clean Sweep',        pts:11, need:[NEED.id('Wind'),NEED.id('Wind'),NEED.id('Flower')], effect:'discardEach:1'},
  {key:'TidalSurge',       label:'Tidal Surge',        pts:15, need:[NEED.id('Falls'),NEED.id('River'),NEED.id('Storm')], effect:'swapRiver'},

  {key:'HowlOfNight',     label:'Howl of Night',    pts:7,  need:[NEED.id('Wolf'),NEED.id('Wind'),NEED.id('Snow')], effect:'discardEach:1'},
  {key:'PredatorCulling', label:'Predator Culling', pts:10, need:[NEED.id('Wolf'),NEED.id('Bear'),NEED.id('Bird')], effect:'discardNonBeastEach:1'},
  {key:'GlacialShift',    label:'Glacial Shift',    pts:8,  need:[NEED.id('Glacier'),NEED.id('Wind'),NEED.id('Tree')], effect:'flip:2500'},
  {key:'TroutTrade',      label:'Trout Trade',      pts:8,  need:[NEED.id('Fish'),NEED.id('River'),NEED.id('Lake')],  effect:'tradeRandom'},

  {key:'Ecosystem',       label:'ECOSYSTEM',        pts:34, need:[NEED.id('Tree'),NEED.id('River'),NEED.id('Sun'),NEED.id('Rain'),NEED.id('Bee')], effect:'legend:ecosystem'},
  {key:'GreatMigration',  label:'GREAT MIGRATION',  pts:28, need:[NEED.id('Bird'),NEED.id('Wind'),NEED.id('Sun'),NEED.id('Nest')], effect:'legend:migration'},
];

const COMBO_BY_KEY = Object.fromEntries(COMBOS.map(c=>[c.key,c]));

/* ======= DOM refs ======= */
const el = {
  river: document.getElementById('river'),
  hand: document.getElementById('hand'),
  opps: document.getElementById('opps'),
  scores: document.getElementById('scores'),
  ready: document.getElementById('ready'),
  near: document.getElementById('near'),
  deckBadge: document.getElementById('deckBadge'),
  discardBadge: document.getElementById('discardBadge'),
  startBtn: document.getElementById('startBtn'),
  hostBadge: document.getElementById('hostBadge'),
  gameIdBadge: document.getElementById('gameIdBadge'),
  banBadge: document.getElementById('banBadge'),
  fsBtn: document.getElementById('fsBtn'),
  leaveBtn: document.getElementById('leaveBtn'),
  toLobbyBtn: document.getElementById('toLobbyBtn'),
  over: document.getElementById('over'),
  overTitle: document.getElementById('overTitle'),
  overWhy: document.getElementById('overWhy'),
  overTable: document.getElementById('overTable'),
  pick: document.getElementById('pick'),
  pickTitle: document.getElementById('pickTitle'),
  pickBody: document.getElementById('pickBody'),
  pickCancel: document.getElementById('pickCancel'),
  toasts: document.getElementById('toasts'),
  sp: document.getElementById('comboPanel'),
  spToggle: document.getElementById('spToggle'),
  spList: document.getElementById('comboList')
};
el.gameIdBadge.textContent = `ID: ${gameId.slice(0,6)}`;

const BASE_REVEAL_MS = 10000; // 10s
const now = ()=> Date.now();

/* ======= Side panel (open/minimize) ======= */
const SB_KEY = 'splinters.panel.open';
function setPanel(open, persist=true){
  document.body.classList.toggle('sb-open', open);
  el.sp.classList.toggle('min', !open);
  el.spToggle.textContent = open ? '«' : '»';
  if (persist) localStorage.setItem(SB_KEY, open ? '1' : '0');
  document.body.classList.toggle('persist-open', open && window.innerWidth <= 480);
}
el.spToggle.addEventListener('click', ()=> setPanel(el.sp.classList.contains('min')));
setPanel(localStorage.getItem(SB_KEY)!=='0', false);

/* Render the panel */
function renderComboPanel(){
  const rows = COMBOS.slice().sort((a,b)=> (b.pts + (b.effect?2:0)) - (a.pts + (a.effect?2:0)));
  el.spList.innerHTML = '';
  for(const c of rows){
    const r = document.createElement('div'); r.className='comboRow';
    const reqEmo = c.need.map(n=> n.id ? byId[n.id].emoji : famIcon(n.fam)).join(' ');
    const row1 = document.createElement('div'); row1.className='r1';
    const nm = document.createElement('div'); nm.className='cName'; nm.textContent = c.label;
    const pts = document.createElement('div'); pts.className='cPts'; pts.textContent = `+${c.pts}`;
    row1.append(nm, pts);
    const req = document.createElement('div'); req.className='req'; req.textContent = `Need: ${reqEmo}`;
    const eff = document.createElement('div'); eff.className='eff'; eff.textContent = `Effect: ${effectDescription(c)}`;
    r.append(row1, req, eff);
    el.spList.appendChild(r);
  }
}
renderComboPanel();

/* ======= Helpers ======= */
function miniHand(count){ return `<div class="mini">${Array.from({length:Math.min(5,count)},()=>'<i></i>').join('')}</div>`; }
function buildDeck(){
  const freq = { Plant:4, Animal:3, Weather:4, Water:3, Habitat:3 };
  const deck=[];
  for(const c of CARDS){ const n=freq[c.fam]??2; for(let i=0;i<n;i++) deck.push(c.id); }
  for(let i=0;i<8;i++){ deck.push(CARDS[(Math.random()*CARDS.length)|0].id); }
  for(let i=deck.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [deck[i],deck[j]]=[deck[j],deck[i]]; }
  return deck;
}
const localRevealUntil = Array(10).fill(0);
const localRevealStart = Array(10).fill(0);
const localRevealDur   = Array(10).fill(0);
let   localFlipHighlightUntil = 0;
const prevRiverUids = Array(10).fill(null);
const makeUID = ()=> Math.random().toString(36).slice(2);

/* ======= Game bootstrap ======= */
async function ensureGameAndSeat(){
  await runTransaction(db, async(tx)=>{
    const snap = await tx.get(gref);
    if (!snap.exists()){
      const deck = buildDeck();
      const base = {
        createdAt: serverTimestamp(),
        host: username,
        status: "lobby",
        players: [username],
        deck, discard: [],
        river: Array.from({length:10}, ()=>({uid:null, id:null})),
        hands: {[username]: []},
        points: {[username]: 0},
        combos: {[username]: 0},
        winners: [],
        freezeUntil: 0,
        revealOppUntil: 0,
        shields: {}, silenced: {}, ban: null,
        events: [],
        lastMoveAt: now()
      };
      tx.set(gref, base);
      return;
    }
    const g = snap.data();
    const players = Array.isArray(g.players) ? g.players.slice() : [];
    if (!players.includes(username)) players.push(username);
    const hands = Object.assign({}, g.hands);
    if (!hands[username]) hands[username] = [];
    const points = Object.assign({}, g.points); if(points[username]===undefined) points[username]=0;
    const combos = Object.assign({}, g.combos); if(combos[username]===undefined) combos[username]=0;
    tx.update(gref, { players, hands, points, combos, host: g.host || username,
      shields: g.shields || {}, silenced: g.silenced || {}, ban: g.ban || null });
  });
}
await ensureGameAndSeat();

/* ======= Host: deal & start ======= */
async function hostDealAndStart(){
  await runTransaction(db, async(tx)=>{
    const snap = await tx.get(gref);
    if (!snap.exists()) throw new Error("Missing game");
    const g = snap.data();
    if (g.host !== username) return;
    const deck = buildDeck();
    const river = Array.from({length:10}, ()=>({uid: makeUID(), id: deck.pop() || null}));
    const hands = {};
    for(const p of g.players){
      hands[p] = [];
      for(let i=0;i<5;i++){ const id = deck.pop(); if(id) hands[p].push({uid:makeUID(), id}); }
    }
    const points={}, combos={}; g.players.forEach(p=>{ points[p]=0; combos[p]=0; });
    tx.update(gref, {
      status:"active", deck, river, hands, points, combos,
      discard: [], winners: [],
      freezeUntil: 0, revealOppUntil: 0, shields:{}, silenced:{}, ban:null,
      events: (g.events||[]).concat([{ts:now(), text:`${username} started the game.`},{ts:now(), type:'revealCenter', ms:BASE_REVEAL_MS, text:'Cards revealed.'}]).slice(-20),
      lastMoveAt: now()
    });
  });
}

/* ======= Interactions ======= */
let sel = {zone:null, idx:null};
let tapLock = 0;
const lockShort = ()=> (tapLock = now() + 220);
const canTap = ()=> now() > tapLock;

function youAreSilenced(g){ const s = g.silenced||{}; const until = s[username]||0; return now() < until; }
function famBanned(g, cardId){ const ban = g.ban; if (!ban) return false; if (now() >= (ban.until||0)) return false; return byId[cardId].fam === ban.fam; }

async function pickFromRiver(rIdx){
  if (!canTap()) return; lockShort();
  await runTransaction(db, async(tx)=>{
    const snap = await tx.get(gref); if(!snap.exists()) return;
    const g = snap.data(); if(g.status!=='active') return;
    if (now() < (g.freezeUntil||0)) return;
    if (youAreSilenced(g)) { pushEvent(g, {ts:now(), text:`${username} is silenced.`}); tx.update(gref, g); return; }

    const r = (g.river||[])[rIdx]; if(!r || !r.id) return;
    if (famBanned(g, r.id)) { pushEvent(g, {ts:now(), text:`Ban active — cannot take ${byId[r.id].fam}.`}); tx.update(gref, g); return; }

    const my = (g.hands?.[username]||[]).slice(); if(my.length>=5) return;

    const deck = (g.deck||[]).slice(); const discard = (g.discard||[]).slice();

    my.push({uid:makeUID(), id:r.id});
    const nextId = deck.pop() || null;
    g.river[rIdx] = {uid: nextId ? makeUID() : null, id: nextId};

    const hands = Object.assign({}, g.hands, {[username]: my});
    const events = (g.events||[]).concat([{ts:now(), text:`${username} drew from center.`}]).slice(-20);
    tx.update(gref, {hands, river:g.river, deck, discard, events, lastMoveAt: now()});
  });
}

async function swapHandRiver(hIdx, rIdx){
  if (!canTap()) return; lockShort();
  await runTransaction(db, async(tx)=>{
    const snap = await tx.get(gref); if(!snap.exists()) return;
    const g = snap.data(); if(g.status!=='active') return;
    if (now() < (g.freezeUntil||0)) return;
    if (youAreSilenced(g)) { pushEvent(g, {ts:now(), text:`${username} is silenced.`}); tx.update(gref, g); return; }

    const my = (g.hands?.[username]||[]).slice(); if(!my[hIdx]) return;
    const r = (g.river||[])[rIdx]; if(!r || !r.id) return;
    if (famBanned(g, r.id)) { pushEvent(g, {ts:now(), text:`Ban active — cannot take ${byId[r.id].fam}.`}); tx.update(gref, g); return; }

    const myCard = my[hIdx], riverCard = r;
    my[hIdx] = {uid: makeUID(), id: riverCard.id};
    g.river[rIdx] = {uid: makeUID(), id: myCard.id};

    const hands = Object.assign({}, g.hands, {[username]: my});
    const events = (g.events||[]).concat([{ts:now(), text:`${username} swapped with center.`}]).slice(-20);
    tx.update(gref, {hands, river:g.river, events, lastMoveAt: now()});
  });
}

/* ======= Effects ======= */
function pushEvent(g, e){ g.events = (g.events||[]).concat([e]).slice(-20); }
function oppList(g, exclude){ return (g.players||[]).filter(p=>p!==exclude); }
function pushToHandOrDiscard(g, player, cardId){
  const hand = (g.hands[player]||[]);
  if (hand.length < 5) hand.push({uid:makeUID(), id:cardId});
  else (g.discard||=(g.discard||[])).push(cardId);
}
function removeRandomFromHand(g, player){
  const h = (g.hands[player]||[]);
  if(!h.length) return null;
  const i = Math.floor(Math.random()*h.length);
  return h.splice(i,1)[0];
}
function removeFirstFam(g, player, fam){
  const h = (g.hands[player]||[]);
  const idx = h.findIndex(x=>byId[x.id].fam===fam);
  if (idx>=0) return h.splice(idx,1)[0];
  return null;
}
function refreshIndex(g, idx){
  const deck = g.deck||[];
  if (g.river[idx]?.id) (g.discard||=(g.discard||[])).push(g.river[idx].id);
  const next = deck.pop() || null;
  g.river[idx] = {uid: next ? makeUID() : null, id: next};
}
function refreshColumn(g, col){
  const a = col, b = col+5;
  if (a>=0 && a<5) refreshIndex(g, a);
  if (b>=5 && b<10) refreshIndex(g, b);
}
function refreshRow(g, row){ if (row==='top'){ for(let i=0;i<5;i++) refreshIndex(g,i); } else { for(let i=5;i<10;i++) refreshIndex(g,i); } }
function swapTwoRiver(g){
  const filled = (g.river||[]).map((s,i)=>s?.id?i:null).filter(i=>i!==null);
  if (filled.length<2) return;
  const a = filled[(Math.random()*filled.length)|0], b = filled[(Math.random()*filled.length)|0];
  if (a===b) return;
  const ra = g.river[a], rb = g.river[b];
  g.river[a] = {uid: makeUID(), id: rb.id};
  g.river[b] = {uid: makeUID(), id: ra.id};
}

function effectNeedsTarget(effect){
  if (!effect) return null;
  if (effect.startsWith('stealTarget:'))     return {kind:'steal', fam:effect.split(':')[1]};
  if (effect.startsWith('duplicateTarget:')) return {kind:'duplicate', fam:effect.split(':')[1]};
  if (effect.startsWith('destroyTarget:'))   return {kind:'destroy', fam:effect.split(':')[1]};
  if (effect.startsWith('silenceTarget:'))   return {kind:'silence', ms: Number(effect.split(':')[1]||'4000') };
  if (effect==='tradeRandom')                return {kind:'trade'};
  return null;
}
function famMatch(fam, id){ return fam==='any' ? true : byId[id].fam===fam; }
function targetShielded(g, player){ const t=(g.shields||{})[player]||0; return now()<t; }

/* Legends + general non-target effects */
function applyNonTargetEffect(g, who, comboKey){
  const combo = COMBO_BY_KEY[comboKey] || {effect:''};
  const e = combo.effect || '';

  if (e.startsWith('legend:')){
    const which = e.split(':')[1];
    if (which==='ecosystem'){
      // reveal opps briefly, draw a card, and force one discard from each opponent (feels powerful)
      g.revealOppUntil = now()+4000;
      for(const opp of oppList(g, who)){
        const d = removeRandomFromHand(g, opp); if (d) (g.discard||=(g.discard||[])).push(d.id);
      }
      const deck = g.deck||[]; if (deck.length) pushToHandOrDiscard(g, who, deck.pop());
      pushEvent(g, {ts:now(), text:`${who} completed ECOSYSTEM!`});
    } else if (which==='migration'){
      // give who a shield and refresh top row (winds of change)
      g.shields = Object.assign({}, g.shields, {[who]: now()+4000});
      refreshRow(g,'top');
      pushEvent(g, {ts:now(), text:`${who} launched GREAT MIGRATION!`});
    }
    return;
  }

  if (e.startsWith('flip:')){
    const ms = Number(e.split(':')[1]||'2500');
    pushEvent(g, {ts:now(), type:'revealCenter', ms, text:`${who} flashed the center.`});
    return;
  }
  if (e.startsWith('revealOpp:')){
    const ms = Number(e.split(':')[1]||'3000');
    g.revealOppUntil = Math.max(now()+ms, g.revealOppUntil||0);
    pushEvent(g, {ts:now(), text:`${who} revealed opponents (${Math.round(ms/1000)}s).`});
    return;
  }
  if (e.startsWith('freeze:')){
    const ms = Number(e.split(':')[1]||'3000');
    g.freezeUntil = Math.max(now()+ms, g.freezeUntil||0);
    pushEvent(g, {ts:now(), text:`${who} froze the river (${Math.round(ms/1000)}s).`});
    return;
  }
  if (e.startsWith('draw:')){
    let n = Number(e.split(':')[1]||'1');
    const deck = g.deck||[];
    while(n-->0 && deck.length) pushToHandOrDiscard(g, who, deck.pop());
    pushEvent(g, {ts:now(), text:`${who} drew bonus card(s).`});
    return;
  }
  if (e==='refreshColumn'){ const col = (Math.random()*5)|0; refreshColumn(g, col); pushEvent(g, {ts:now(), text:`${who} refreshed a column.`}); return; }
  if (e.startsWith('refreshRow:')){ const row = e.split(':')[1]; refreshRow(g, row==='top'?'top':'bottom'); pushEvent(g, {ts:now(), text:`${who} refreshed the ${row} row.`}); return; }
  if (e==='swapRiver'){ swapTwoRiver(g); pushEvent(g, {ts:now(), text:`${who} twisted the river.`}); return; }
  if (e.startsWith('shieldSelf:')){ const ms=Number(e.split(':')[1]||'4000'); g.shields = Object.assign({}, g.shields, {[who]: now()+ms}); pushEvent(g,{ts:now(), text:`${who} gained a Shield (${Math.round(ms/1000)}s).`}); return; }
  if (e.startsWith('scry:')){
    let n = Number(e.split(':')[1]||'3'); if (n<1) n=1;
    const deck = g.deck||[];
    const pull=[]; while(n-- > 0 && deck.length) pull.push(deck.pop());
    if (pull.length){
      pull.sort((a,b)=> byId[b].tier - byId[a].tier);
      const keep = pull.shift();
      pushToHandOrDiscard(g, who, keep);
      while(pull.length) deck.push(pull.pop());
      pushEvent(g, {ts:now(), text:`${who} scried the deck.`});
      pushEvent(g, {ts:now(), type:'revealCenter', ms:1500, text:`Scry shimmer`});
    }
    return;
  }
  if (e.startsWith('banFam:')){
    const [,fam,msStr] = e.split(':');
    const ms = Number(msStr||'4000');
    g.ban = {fam, until: now()+ms};
    pushEvent(g, {ts:now(), text:`${who} banned ${fam} for ${Math.round(ms/1000)}s.`});
    return;
  }
  if (e.startsWith('discardEach:')){
    let n = Number(e.split(':')[1]||'1'); if (n<1) n=1;
    for(const opp of oppList(g, who)){
      for(let k=0;k<n;k++){ const d = removeRandomFromHand(g, opp); if (d) (g.discard||=(g.discard||[])).push(d.id); }
    }
    pushEvent(g, {ts:now(), text:`${who} forced discards from all foes.`});
    return;
  }
  if (e==='discardNonBeastEach:1'){
    for(const opp of oppList(g, who)){
      const h = (g.hands[opp]||[]);
      let idx = h.findIndex(x=>byId[x.id].fam!==F.Animal);
      if (idx<0 && h.length) idx = (Math.random()*h.length)|0;
      if (idx>=0){ const [c]=h.splice(idx,1); (g.discard||=(g.discard||[])).push(c.id); }
    }
    pushEvent(g, {ts:now(), text:`${who} culled non-animals from foes.`});
    return;
  }
  if (e.startsWith('stealEach:')){
    let n = Number(e.split(':')[1]||'1'); if (n<1) n=1;
    for(const opp of oppList(g, who)){
      for(let k=0;k<n;k++){ const got = removeRandomFromHand(g, opp); if (got) pushToHandOrDiscard(g, who, got.id); }
    }
    pushEvent(g, {ts:now(), text:`${who} plucked from each opponent.`});
    return;
  }

  pushEvent(g, {ts:now(), text:`${who} played ${combo.label} (+${combo.pts||0}).`});
}

/* ======= Play combo ======= */
async function playCombo(comboKey, useUids, targetInfo){
  await runTransaction(db, async(tx)=>{
    const snap = await tx.get(gref); if(!snap.exists()) return;
    const g = snap.data(); if(g.status!=='active') return;

    const my = (g.hands?.[username]||[]).slice();
    const haveAll = useUids.every(uid => my.some(x=>x.uid===uid));
    if (!haveAll) return;

    for(const uid of useUids){ const idx = my.findIndex(x=>x.uid===uid); if (idx>=0) my.splice(idx,1); }

    const combo = COMBO_BY_KEY[comboKey];
    const points = Object.assign({}, g.points);
    const combos = Object.assign({}, g.combos);
    points[username] = (points[username]||0) + (combo.pts||0);
    combos[username] = (combos[username]||0) + 1;

    const needs = effectNeedsTarget(combo.effect);
    if (needs){
      if (needs.kind==='trade'){
        const target = targetInfo && targetInfo.opp; if (!target) return;
        if (targetShielded(g, target)){ pushEvent(g,{ts:now(), text:`${target} blocked trade (Shield).`}); }
        else{
          const a = removeRandomFromHand(g, username);
          const b = removeRandomFromHand(g, target);
          if (a) (g.hands[target]||[]).push({uid:makeUID(), id:a.id});
          if (b) (g.hands[username]||[]).push({uid:makeUID(), id:b.id});
          pushEvent(g, {ts:now(), text:`${username} traded a random card with ${target}.`});
        }
      } else if (needs.kind==='silence'){
        const target = targetInfo && targetInfo.opp; if (!target) return;
        g.silenced = Object.assign({}, g.silenced, {[target]: now() + (needs.ms||4000)});
        pushEvent(g, {ts:now(), text:`${username} silenced ${target} (${Math.round((needs.ms||4000)/1000)}s).`});
      } else {
        const target = targetInfo && targetInfo.opp;
        const oppH = (g.hands?.[target]||[]);
        const tIdx = oppH.findIndex(x=>x.uid===targetInfo.cardUid);
        if (tIdx<0) return;
        if (targetShielded(g, target)){ pushEvent(g,{ts:now(), text:`${target} blocked the effect (Shield).`}); }
        else{
          const picked = oppH.splice(tIdx,1)[0];
          if (needs.kind==='steal'){
            pushToHandOrDiscard(g, username, picked.id);
            pushEvent(g, {ts:now(), text:`${username} stole ${byId[picked.id].emoji} ${byId[picked.id].name} from ${target}.`});
          } else if (needs.kind==='duplicate'){
            oppH.splice(tIdx,0,picked);
            pushToHandOrDiscard(g, username, picked.id);
            pushEvent(g, {ts:now(), text:`${username} duplicated ${byId[picked.id].emoji} ${byId[picked.id].name} from ${target}.`});
          } else if (needs.kind==='destroy'){
            (g.discard||=(g.discard||[])).push(picked.id);
            pushEvent(g, {ts:now(), text:`${username} destroyed ${byId[picked.id].emoji} ${byId[picked.id].name} from ${target}.`});
          }
        }
      }
    } else {
      applyNonTargetEffect(g, username, comboKey);
      pushEvent(g, {ts:now(), text:`${username} played ${combo.label} (+${combo.pts||0}).`});
    }

    const hands = Object.assign({}, g.hands, {[username]: my});
    tx.update(gref, {
      hands, points, combos,
      river: g.river, deck: g.deck, discard: g.discard,
      freezeUntil: g.freezeUntil||0, revealOppUntil: g.revealOppUntil||0,
      shields: g.shields||{}, silenced: g.silenced||{}, ban: g.ban||null,
      events: g.events, lastMoveAt: now()
    });
  });
  await endIfDeckDone();
}

/* ======= Suggestions ======= */
function findReadyCombos(handIds){
  const hand = handIds.map(id=>byId[id]);
  const out=[];
  for(const combo of COMBOS){
    const used = new Array(hand.length).fill(false);
    const take = [];
    for(const req of combo.need){
      let idx=-1;
      for(let i=0;i<hand.length;i++){
        if(used[i]) continue;
        if(req.test(hand[i])){ idx=i; break; }
      }
      if(idx<0){ take.length=0; break; }
      used[idx]=true; take.push(idx);
    }
    if(take.length){ out.push({combo,indexes:take}); }
  }
  out.sort((a,b)=> (b.combo.pts + (b.combo.effect?3:0)) - (a.combo.pts + (a.combo.effect?3:0)));
  return out.slice(0,3);
}
function findNearCombosDetailed(handIds, limitMissing=2){
  const hand = handIds.map(id=>byId[id]);
  const res=[];
  for(const combo of COMBOS){
    const used = new Array(hand.length).fill(false);
    const missing=[];
    for(const req of combo.need){
      let ok=-1;
      for(let i=0;i<hand.length;i++){
        if(used[i]) continue;
        if(req.test(hand[i])){ ok=i; break; }
      }
      if(ok>=0) used[ok]=true; else missing.push(req);
    }
    if(missing.length>0 && missing.length<=limitMissing){
      res.push({combo, missing});
    }
  }
  res.sort((a,b)=> (a.missing.length - b.missing.length) || ((b.combo.pts||0) - (a.combo.pts||0)));
  return res.slice(0,3);
}

/* ======= Target pickers ======= */
function openTargetCardPicker(game, combo, useUids, needs){
  const picker = el.pick, title = el.pickTitle, body = el.pickBody;
  title.textContent = `Choose a target — ${combo.label}`;
  body.innerHTML = '';
  const players = (game.players||[]).filter(p=>p!==username);
  for (const p of players){
    const row = document.createElement('div'); row.className='prow';
    row.innerHTML = `<h4>${p} ${targetShielded(game,p)?' <span class="flag shd">🛡️</span>':''}</h4>`;
    const cardsDiv = document.createElement('div'); cardsDiv.className='pcards';
    const hand = (game.hands?.[p]||[]); let any=false;
    for(const c of hand){
      if (needs.fam!=='any' && !famMatch(needs.fam, c.id)) continue;
      any=true;
      const btn = document.createElement('button'); btn.className='pbtn';
      btn.textContent = `${byId[c.id].emoji} ${byId[c.id].name}`;
      btn.addEventListener('click', async ()=>{
        picker.classList.remove('show');
        await playCombo(combo.key, useUids, {opp:p, cardUid:c.uid});
      });
      cardsDiv.appendChild(btn);
    }
    if(!any){ const none=document.createElement('div'); none.style.opacity='.75'; none.style.fontSize='12px'; none.textContent='No valid cards.'; cardsDiv.appendChild(none); }
    row.appendChild(cardsDiv); body.appendChild(row);
  }
  picker.classList.add('show');
}
function openTargetPlayerPicker(game, combo, useUids, titleText){
  const picker = el.pick, title = el.pickTitle, body = el.pickBody;
  title.textContent = titleText || `Choose a player`;
  body.innerHTML = '';
  const players = (game.players||[]).filter(p=>p!==username);
  const row = document.createElement('div'); row.className='prow';
  const cardsDiv = document.createElement('div'); cardsDiv.className='pcards';
  players.forEach(p=>{
    const btn = document.createElement('button'); btn.className='pbtn';
    const flags = `${(game.silenced?.[p]&&now()<game.silenced[p])?'🤐 ':''}${targetShielded(game,p)?'🛡️ ':''}`;
    btn.textContent = `${flags}${p}`;
    btn.addEventListener('click', async ()=>{
      picker.classList.remove('show');
      await playCombo(combo.key, useUids, {opp:p});
    });
    cardsDiv.appendChild(btn);
  });
  row.appendChild(cardsDiv); body.appendChild(row);
  picker.classList.add('show');
}
el.pickCancel.addEventListener('click', ()=> el.pick.classList.remove('show'));

/* ======= Rendering ======= */
function cardFrontHTML(id){
  const c = byId[id];
  return `<div class="front"><div class="t">${c.emoji} ${c.name}</div><div class="f">${c.fam} • Tier ${c.tier}</div></div>`;
}
function cardBackHTML(){ return `<div class="back"></div>`; }
function timerHTML(){ return `
  <div class="timer" aria-hidden="true">
    <svg viewBox="0 0 36 36" focusable="false">
      <circle class="track" cx="18" cy="18" r="15"></circle>
      <circle class="prog" cx="18" cy="18" r="15"></circle>
    </svg>
    <span class="txt">10</span>
  </div>`; }

function renderOpps(game){
  const reveal = now() < (game.revealOppUntil||0);
  const players = (game.players||[]).filter(p=>p!==username);
  const hands = game.hands||{};
  const points = game.points||{};
  el.opps.innerHTML = '';
  for (const p of players){
    const div = document.createElement('div'); div.className='opp';
    const hand = (hands[p]||[]);
    const isSil = now() < (game.silenced?.[p]||0);
    const isShd = now() < (game.shields?.[p]||0);
    div.innerHTML = `<span class="name">${p}</span>
                     ${isSil?'<span class="flag sil">🤐</span>':''}
                     ${isShd?'<span class="flag shd">🛡️</span>':''}
                     <span class="badge">Pts: ${points[p]||0}</span>`;
    if (reveal){
      const rev = document.createElement('div'); rev.className='revealMini';
      rev.innerHTML = hand.slice(0,6).map(x=>`${byId[x.id].emoji} ${byId[x.id].name}`).join(' · ');
      div.appendChild(rev);
    } else {
      div.insertAdjacentHTML('beforeend', miniHand(hand.length));
    }
    el.opps.appendChild(div);
  }
}
function renderScores(game){
  const pts = Object.assign({}, game.points||{});
  const players = (game.players||[]).slice();
  players.forEach(p=>{ if(pts[p]===undefined) pts[p]=0; });
  const rows = players.map(p=>({name:p, pts:pts[p]})).sort((a,b)=>b.pts-a.pts);
  el.scores.innerHTML = '';
  rows.forEach((r,i)=>{
    const div = document.createElement('div');
    let cls = ''; if (i===0) cls='m1'; else if (i===1) cls='m2'; else if (i===2) cls='m3';
    div.className = `sc ${cls}`;
    div.innerHTML = `<span class="dot"></span><span>${r.name===username?'You':r.name}</span><span>•</span><strong>${r.pts}</strong>`;
    el.scores.appendChild(div);
  });
}
function renderRiver(game){
  const frozen = now() < (game.freezeUntil||0);
  const wrap = document.querySelector('.riverWrap');
  wrap.classList.toggle('frozen', frozen);
  wrap.classList.toggle('flipGlow', now() < localFlipHighlightUntil);

  el.river.innerHTML='';
  const R = game.river||[];
  for(let i=0;i<10;i++){
    const s = R[i] || {id:null};
    const slot = document.createElement('div');
    slot.className = 'slot' + (s.id? '':' empty');
    slot.dataset.idx = String(i);
    if (sel.zone==='river' && sel.idx===i) slot.classList.add('sel');
    if (s.id){
      const card = document.createElement('div'); card.className='card';
      card.innerHTML = cardFrontHTML(s.id) + cardBackHTML() + timerHTML();
      slot.appendChild(card);
    }
    el.river.appendChild(slot);
  }

  const ban = game.ban;
  if (ban && now() < (ban.until||0)){
    el.banBadge.hidden = false;
    el.banBadge.textContent = `Ban: ${ban.fam}`;
  } else el.banBadge.hidden = true;
}
function renderHand(game){
  el.hand.innerHTML='';
  const my = (game.hands?.[username]||[]);
  for(let i=0;i<5;i++){
    const slot = document.createElement('div');
    slot.className = 'hslot'+(my[i]?'':' empty');
    slot.dataset.idx = String(i);
    if (sel.zone==='hand' && sel.idx===i) slot.classList.add('sel');
    if (my[i]){
      const c = my[i].id;
      const card = document.createElement('div'); card.className='card';
      card.innerHTML = cardFrontHTML(c);
      slot.appendChild(card);
    }
    el.hand.appendChild(slot);
  }
}
function renderReady(game){
  const my = (game.hands?.[username]||[]);
  const ready = findReadyCombos(my.map(x=>x.id));
  el.ready.innerHTML = '';
  if (!ready.length){
    const pill=document.createElement('div'); pill.className='pill'; pill.textContent='No ready combos';
    el.ready.appendChild(pill);
    return;
  }
  for(const r of ready){
    const combo = r.combo;
    const emo = r.indexes.map(i => byId[my[i].id].emoji).join(' ');
    const desc = effectDescription(combo);

    const pill=document.createElement('div'); pill.className='pill';
    const top=document.createElement('div'); top.className='row';
    const label=document.createElement('span'); label.className='label'; label.textContent = combo.label;
    const cards=document.createElement('span'); cards.className='cards'; cards.textContent = `• ${emo}`;
    const btn=document.createElement('button'); btn.className='playBtn'; btn.textContent = `PLAY — ${desc} (+${combo.pts})`;
    btn.setAttribute('aria-label', `Play ${combo.label}. ${desc}. Adds ${combo.pts} points.`);
    btn.addEventListener('click', async ()=>{
      const useUids = r.indexes.map(i=>my[i].uid);
      const needs = effectNeedsTarget(combo.effect);
      if (needs){
        if (needs.kind==='trade' || needs.kind==='silence'){
          openTargetPlayerPicker(game, combo, useUids, needs.kind==='trade'?'Choose player to trade with':'Choose a player to silence');
        } else {
          openTargetCardPicker(game, combo, useUids, needs);
        }
      } else {
        await playCombo(combo.key, useUids, null);
      }
    });
    top.append(label, cards, btn);
    const sub=document.createElement('div'); sub.className='desc'; sub.textContent = `Effect: ${desc}`;
    pill.append(top, sub);
    el.ready.appendChild(pill);
  }
}
function renderNear(game){
  const my = (game.hands?.[username]||[]);
  const near = findNearCombosDetailed(my.map(x=>x.id), 2);
  el.near.innerHTML='';
  if (!near.length){
    const pill=document.createElement('div'); pill.className='pill'; pill.textContent='No combo suggestions';
    el.near.appendChild(pill); return;
  }
  for(const n of near){
    const needsEmo = n.missing.map(m=> (m.id? byId[m.id].emoji : famIcon(m.fam))).join(' ');
    const pill=document.createElement('div'); pill.className='pill';
    pill.innerHTML = `<div class="row"><span class="label">${n.combo.label}</span><span class="cards">• need ${needsEmo}</span></div>`;
    el.near.appendChild(pill);
  }
}
function updateHUD(game){
  el.deckBadge.textContent = `Deck: ${game.deck?.length||0}`;
  el.discardBadge.textContent = `Discard: ${game.discard?.length||0}`;
  el.startBtn.hidden = !(game.host===username && game.status==='lobby');
  el.hostBadge.hidden = !(game.host===username);
}

/* ======= Face/back + timer updater ======= */
function rafFaces(){
  const slots = el.river.querySelectorAll('.slot');
  const t = now();
  slots.forEach((slot)=>{
    const idx = Number(slot.dataset.idx);
    const front = slot.querySelector('.front');
    const back  = slot.querySelector('.back');
    const timer = slot.querySelector('.timer');
    const prog  = slot.querySelector('.prog');
    const txt   = slot.querySelector('.txt');
    if (!front || !back) return;
    const up = t < (localRevealUntil[idx]||0);
    front.style.display = up ? '' : 'none';
    back.style.display  = up ? 'none' : '';
    if (timer && prog && txt){
      if (up){
        timer.style.display = '';
        const elapsed = Math.max(0, t - (localRevealStart[idx]||t));
        const dur = Math.max(1, localRevealDur[idx]||1);
        const remain = Math.max(0, (localRevealUntil[idx]||t)-t);
        const ratio = Math.max(0, Math.min(1, 1 - (elapsed/dur)));
        const circ = 2*Math.PI*15;
        prog.setAttribute('stroke-dasharray', `${circ}`);
        prog.setAttribute('stroke-dashoffset', `${(1-ratio)*circ}`);
        txt.textContent = String(Math.ceil(remain/1000));
      } else {
        timer.style.display = 'none';
      }
    }
  });
  requestAnimationFrame(rafFaces);
}
requestAnimationFrame(rafFaces);

/* ======= Click bindings ======= */
el.river.addEventListener('click', async (e)=>{
  const slot = e.target.closest('.slot'); if(!slot) return;
  const rIdx = Number(slot.dataset.idx);
  const snap = await getDoc(gref); if(!snap.exists()) return;
  const g = snap.data(); if (g.status!=='active') return;

  const my = (g.hands?.[username]||[]);
  if (now() < (g.freezeUntil||0)) return;

  if (my.length<5){ await pickFromRiver(rIdx); sel={zone:null,idx:null}; }
  else{
    if (sel.zone==='hand'){ await swapHandRiver(sel.idx, rIdx); sel={zone:null,idx:null}; }
    else { sel={zone:'river', idx:rIdx}; renderRiver(g); }
  }
});
el.hand.addEventListener('click', async (e)=>{
  const slot = e.target.closest('.hslot'); if(!slot) return;
  const hIdx = Number(slot.dataset.idx);
  const snap = await getDoc(gref); if(!snap.exists()) return;
  const g = snap.data(); if (g.status!=='active') return;
  const my = (g.hands?.[username]||[]);
  if (!my[hIdx]) return;

  if (sel.zone==='river'){ await swapHandRiver(hIdx, sel.idx); sel={zone:null,idx:null}; }
  else if (sel.zone==='hand' && sel.idx===hIdx){ sel={zone:null,idx:null}; }
  else { sel={zone:'hand', idx:hIdx}; renderHand(g); }
});

/* ======= Fullscreen / leave / start ======= */
el.fsBtn.addEventListener('click', async ()=>{
  const root = document.documentElement;
  try{
    if (!document.fullscreenElement) await (root.requestFullscreen?.() || root.webkitRequestFullscreen?.());
    else await (document.exitFullscreen?.() || document.webkitExitFullscreen?.());
  }catch(e){}
});
el.leaveBtn.addEventListener('click', ()=>{ location.href = `${LOBBY_URL}?username=${encodeURIComponent(username)}`; });
el.toLobbyBtn.addEventListener('click', ()=>{ location.href = `${LOBBY_URL}?username=${encodeURIComponent(username)}`; });
el.startBtn.addEventListener('click', hostDealAndStart);

/* ======= Game over & win bump ======= */
async function endIfDeckDone(){
  await runTransaction(db, async(tx)=>{
    const snap = await tx.get(gref);
    if (!snap.exists()) return;
    const g = snap.data();
    if (g.status !== 'active') return;

    const anyRiver = (g.river||[]).some(s=>s && s.id);
    const deckEmpty = !g.deck || g.deck.length===0;
    if (!deckEmpty || anyRiver) return;

    const pts = g.points||{};
    const entries = Object.entries(pts);
    if (!entries.length) return;
    entries.sort((a,b)=> (b[1])-(a[1]));
    const top = entries[0][1];
    const winners = entries.filter(e=>e[1]===top).map(e=>e[0]);

    tx.update(gref, {status:'over', winners, overReason:'Deck exhausted', lastMoveAt: now(),
      events: (g.events||[]).concat([{ts:now(), text:`Game over — winner: ${winners.join(', ')}`}]).slice(-20)
    });
  });
}
async function bumpMyWinsIfWinner(winners){
  if (!winners.includes(username)) return;
  await runTransaction(db, async(tx)=>{
    const usnap = await tx.get(uref);
    if (!usnap.exists()){ tx.set(uref, {wins:1}, {merge:true}); }
    else { const cur = usnap.data(); tx.update(uref, {wins: (cur.wins||0)+1}); }
  });
}

/* ======= Live sync + toasts + local reveal handling ======= */
let lastEventTs = 0;
onSnapshot(gref, async (snap)=>{
  if (!snap.exists()) return;
  const g = snap.data();

  // Local 10s flip when a new UID appears in a river slot
  const R = g.river||[];
  for(let i=0;i<10;i++){
    const u = R[i]?.uid || null;
    if (u && u !== prevRiverUids[i]){
      const t = now();
      localRevealStart[i] = t;
      localRevealDur[i]   = BASE_REVEAL_MS;
      localRevealUntil[i] = t + BASE_REVEAL_MS;
      prevRiverUids[i]    = u;
    } else if (!u) {
      prevRiverUids[i] = null;
      localRevealStart[i] = 0;
      localRevealDur[i]   = 0;
      localRevealUntil[i] = 0;
    }
  }

  renderScores(g);
  renderOpps(g);
  renderRiver(g);
  renderHand(g);
  renderReady(g);
  renderNear(g);
  updateHUD(g);

  for (const ev of (g.events||[])){
    if (ev.ts > lastEventTs){
      if (ev.type === 'revealCenter'){
        const dur = ev.ms || 2500;
        const t = now();
        for(let i=0;i<10;i++){
          localRevealStart[i] = t;
          localRevealDur[i]   = dur;
          localRevealUntil[i] = t + dur;
        }
        localFlipHighlightUntil = t + dur;
      }
      if (ev.text) showToast(ev.text);
      lastEventTs = Math.max(lastEventTs, ev.ts);
    }
  }

  if (g.status==='over'){
    showOver(g);
    if (!localStorage.getItem(`splinters.bumped.${gameId}.${username}`)){
      await bumpMyWinsIfWinner(g.winners||[]);  // harmless if not winner
      localStorage.setItem(`splinters.bumped.${gameId}.${username}`,'1');
      setTimeout(()=>{ location.href = `${LOBBY_URL}?username=${encodeURIComponent(username)}`; }, 1500);
    }
  }
});

/* ======= UI helpers ======= */
function showToast(text){
  const t=document.createElement('div'); t.className='toast'; t.textContent=text;
  el.toasts.appendChild(t);
  const life = 1300 + Math.random()*500;
  setTimeout(()=>{ t.classList.add('out'); setTimeout(()=>t.remove(),220); }, life);
}
function showOver(game){
  const winners = game.winners||[];
  el.overTitle.textContent = winners.includes(username) && winners.length===1 ? 'You win!' : `Winner: ${winners.join(', ')}`;
  el.overWhy.textContent = game.overReason || 'Game finished';
  const pts = game.points||{};
  const rows = Object.entries(pts).sort((a,b)=>b[1]-a[1]);
  el.overTable.innerHTML = `<tr><th>Player</th><th>Points</th></tr>` + rows.map(r=>`<tr><td>${r[0]===username?'You':r[0]}</td><td>${r[1]}</td></tr>`).join('');
  el.over.classList.add('show');
}

/* ======= Header state ======= */
onSnapshot(gref, (snap)=>{
  if(!snap.exists()) return;
  const g = snap.data();
  el.startBtn.hidden = !(g.host===username && g.status==='lobby');
  el.hostBadge.hidden = !(g.host===username);
});

/* ======= Periodic end-condition check ======= */
setInterval(endIfDeckDone, 1200);

/* ======= Responsive: auto-open padding when panel open ======= */
window.addEventListener('resize', ()=>{
  const persistedOpen = (localStorage.getItem(SB_KEY) !== '0');
  setPanel(persistedOpen, false);
});
</script>
</body>
</html>










