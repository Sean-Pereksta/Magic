<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Splinters ‚Äî Multiplayer (Clear Play, Flip Timers, Set Combos)</title>
<style>
  :root{
    --ink:#eaf2ff; --muted:#a7bfdc; --bg:#0a0e14; --pane:#0f1726; --edge:#1a2b46; --accent:#b91c1c; --accent-2:#7f1d1d;
    --h:48px; --oppsH:44px; --handH:100px; --riverW:min(96vw,720px);
    --cardW: clamp(48px, 9vw, 66px); --cardH: calc(var(--cardW) * 1.33);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:radial-gradient(1000px 700px at 60% -10%,#151f31 0%,#0a0e14 45%,#070a10 100%);color:var(--ink);font:600 12px/1.25 system-ui,Segoe UI,Inter,Roboto,Arial,sans-serif;overflow:hidden;-webkit-tap-highlight-color:transparent}
  button{appearance:none;border:1px solid #2b3f64;background:#132139;color:#eaf3ff;border-radius:10px;padding:6px 10px;font-weight:800;font-size:12px;cursor:pointer}
  button:active{transform:translateY(1px)}
  .top{position:fixed;inset:0 0 auto 0;height:var(--h);display:flex;align-items:center;justify-content:space-between;padding:6px 8px}
  .brand{display:flex;align-items:center;gap:8px}
  .logo{width:28px;height:28px;border-radius:8px;display:grid;place-items:center;background:#ffffff14;border:1px solid #ffffff22;font-size:16px}
  .title{font-weight:900;letter-spacing:.2px}
  .controls{display:flex;align-items:center;gap:6px}
  .badge{padding:3px 8px;border-radius:999px;background:#0f1a2b;border:1px solid #21365b;color:#cfe4ff;font-size:11px}
  .host{background:#192940;border-color:#2f4e7d}
  .leave{background:#260c0c;border-color:#4b1a1a}
  .ghost{background:#0d1728;border-color:#1b2b48}

  /* Opponents bar */
  .opps{position:fixed;left:0;right:0;top:var(--h);height:var(--oppsH);display:flex;align-items:center;justify-content:center;padding:0 6px}
  .opps-inner{width:var(--riverW);display:flex;gap:6px;justify-content:center;overflow:hidden}
  .opp{flex:1 1 0;min-width:0;border:1px solid var(--edge);background:#0e1626;border-radius:8px;padding:4px 6px;display:flex;align-items:center;gap:6px}
  .opp .name{font-weight:900;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .mini{display:flex;gap:3px;margin-left:auto}
  .mini i{width:14px;height:20px;border-radius:4px;background:#112036;border:1px solid #213a62;display:block}
  .revealMini{display:flex;gap:6px;margin-left:auto;font-size:11px;color:#dbe8ff;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}

  /* River */
  .main{position:absolute;inset:calc(var(--h) + var(--oppsH)) 0 calc(env(safe-area-inset-bottom) + var(--handH) + 60px) 0;display:grid;place-items:center}
  .riverWrap{width:var(--riverW)}
  .river{display:grid;grid-template-columns:repeat(5,var(--cardW));grid-auto-rows:var(--cardH);gap:6px}
  .slot{width:var(--cardW);height:var(--cardH);border-radius:8px;border:1px solid var(--edge);background:#0f1a2a;display:grid;place-items:center;position:relative}
  .slot.empty{border-style:dashed;opacity:.6}
  .card{width:calc(100% - 6px);height:calc(100% - 6px);border-radius:8px;border:1px solid #1e2f52;background:#14243c;position:relative;overflow:hidden}
  .front,.back{position:absolute;inset:0;display:grid;place-items:start;padding:5px}
  .front .t{font-weight:900;font-size:11px}
  .front .f{font-size:10px;color:#cfe1ffcc}
  .back{
    background:
      linear-gradient(45deg, #1b2a45 25%, transparent 25%, transparent 75%, #1b2a45 75%),
      linear-gradient(45deg, #1b2a45 25%, transparent 25%, transparent 75%, #1b2a45 75%);
    background-size: 12px 12px; background-position: 0 0, 6px 6px; background-color:#0a1422;
  }
  .sel{outline:3px solid var(--accent);outline-offset:2px}
  .frozen .slot{filter:grayscale(.2) contrast(.92);opacity:.88}
  .flipGlow .slot{box-shadow:0 0 0 2px #b91c1c99 inset}

  /* Flip timer on each river card */
  .timer{position:absolute;top:4px;right:4px;width:22px;height:22px;display:grid;place-items:center;pointer-events:none;opacity:.92;filter:drop-shadow(0 1px 2px rgba(0,0,0,.65))}
  .timer svg{width:22px;height:22px}
  .timer .track{fill:none;stroke:#243a5f;stroke-width:3}
  .timer .prog{fill:none;stroke:#ef4444;stroke-width:3;stroke-linecap:round}
  .timer .txt{position:absolute;font-size:9px;font-weight:900;color:#ffd7d7}

  /* Ready + Near combos */
  .suggest{position:fixed;left:0;right:0;bottom:calc(var(--handH) + env(safe-area-inset-bottom) + 6px);display:grid;place-items:center}
  .suggest-inner{width:var(--riverW);display:grid;grid-template-rows:auto auto;gap:6px}
  .ready{display:flex;gap:6px;flex-wrap:wrap;justify-content:center}
  .pill{display:flex;align-items:center;gap:6px;border:1px solid #223a5f;background:#111e33;border-radius:999px;padding:4px 8px;font-size:11px;color:#dbe7ff}
  .need{opacity:.9}
  .playBtn{background:var(--accent);border-color:#5e1111;color:#fff;padding:4px 8px;border-radius:999px;font-size:11px;font-weight:900}
  .playBtn:hover{filter:brightness(1.05)}
  .playBtn:active{background:var(--accent-2)}

  /* Hand */
  .handWrap{position:fixed;left:0;right:0;bottom:0;height:calc(var(--handH) + env(safe-area-inset-bottom));padding:6px 8px env(safe-area-inset-bottom)}
  .hand{height:100%;margin:0 auto;width:var(--riverW);border:1px solid var(--edge);background:#0f1a2a;border-radius:10px;padding:6px;display:flex;gap:6px;align-items:center;justify-content:center}
  .hslot{width:calc(var(--cardW) * 1.02);height:calc(var(--cardH) * 1.02);border:1px solid var(--edge);background:#0d1728;border-radius:8px;display:grid;place-items:center}
  .hslot.empty{opacity:.5;border-style:dashed}

  /* Winner */
  .overlay{position:fixed;inset:0;background:rgba(5,10,18,.86);display:none;align-items:center;justify-content:center;z-index:40}
  .overlay.show{display:flex}
  .modal{background:#0f1a2a;border:1px solid #1b2c48;border-radius:12px;width:min(92vw,420px);padding:12px;box-shadow:0 24px 60px rgba(0,0,0,.45)}
  .modal h2{margin:0 0 6px 0}
  .modal p{margin:0 0 6px 0;color:#cfe1ff}
  .table{width:100%;border-collapse:collapse;font-size:12px}
  .table td,.table th{border-bottom:1px solid #22385d;padding:6px;text-align:left}
  .table tr:last-child td{border-bottom:none}

  /* Target picker */
  .pick{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(8,12,20,.84);z-index:45}
  .pick.show{display:flex}
  .pickBox{background:#0f1b2e;border:1px solid #1b2c48;border-radius:12px;width:min(94vw,520px);max-height:min(72vh,520px);overflow:auto;padding:10px}
  .pickBox h3{margin:0 0 8px 0;font-size:14px}
  .prow{border:1px solid #223a5f;background:#0d1727;border-radius:10px;padding:8px;margin:6px 0}
  .prow h4{margin:0 0 6px 0;font-size:12px;color:#cfe4ff}
  .pcards{display:flex;flex-wrap:wrap;gap:6px}
  .pbtn{font-size:11px;padding:5px 8px;border-radius:9px;border:1px solid #2a426d;background:#132242;color:#dbeaff;cursor:pointer}

  /* Toasts */
  .toasts{position:fixed;left:50%;transform:translateX(-50%);top:calc(var(--h) + 4px);display:flex;flex-direction:column;gap:6px;z-index:60;pointer-events:none}
  .toast{background:#0f1b2e;border:1px solid #203656;color:#e6efff;padding:6px 8px;border-radius:9px;box-shadow:0 8px 20px rgba(0,0,0,.35);opacity:0;transform:translateY(-6px);animation:tin .22s ease-out forwards}
  @keyframes tin{to{opacity:1;transform:translateY(0)}}
  .toast.out{animation:tout .22s ease-in forwards}
  @keyframes tout{to{opacity:0;transform:translateY(-6px)}}
</style>
</head>
<body>
  <div class="top">
    <div class="brand">
      <div class="logo">ü™Ñ</div>
      <div class="title">Splinters</div>
      <span class="badge" id="hostBadge" hidden>Host</span>
      <span class="badge" id="gameIdBadge"></span>
    </div>
    <div class="controls">
      <span class="badge" id="deckBadge">Deck: 0</span>
      <span class="badge" id="discardBadge">Discard: 0</span>
      <button class="host" id="startBtn" hidden>Deal & Start</button>
      <button class="ghost" id="fsBtn" title="Fullscreen">‚õ∂</button>
      <button class="leave" id="leaveBtn">Lobby</button>
    </div>
  </div>

  <!-- Opponents -->
  <div class="opps"><div class="opps-inner" id="opps"></div></div>

  <!-- Board -->
  <main class="main">
    <div class="riverWrap">
      <div class="river" id="river"></div>
    </div>
  </main>

  <!-- Ready + Near suggestions -->
  <div class="suggest">
    <div class="suggest-inner">
      <div class="ready" id="ready"></div>
      <div class="ready" id="near"></div>
    </div>
  </div>

  <!-- Hand -->
  <div class="handWrap"><div class="hand" id="hand"></div></div>

  <!-- Winner -->
  <div class="overlay" id="over">
    <div class="modal">
      <h2 id="overTitle">Game Over</h2>
      <p id="overWhy"></p>
      <table class="table" id="overTable"></table>
      <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:8px">
        <button id="toLobbyBtn">Back to Lobby</button>
      </div>
    </div>
  </div>

  <!-- Target picker -->
  <div class="pick" id="pick">
    <div class="pickBox">
      <h3 id="pickTitle">Pick a target</h3>
      <div id="pickBody"></div>
      <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:8px">
        <button id="pickCancel">Cancel</button>
      </div>
    </div>
  </div>

  <div class="toasts" id="toasts"></div>

<script type="module">
/* ======= Firebase ======= */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc, runTransaction, onSnapshot,
  serverTimestamp
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

/* ======= URL / Lobby ======= */
const qp = new URLSearchParams(location.search);
const gameId = qp.get('gameId') || '';
const username = (qp.get('username') || '').trim();
const LOBBY_URL = "/";

if (!gameId || !username) alert("Missing gameId or username in URL.");

const gref = doc(db, "games", gameId);
const uref = doc(db, "users", username);

/* ======= Cards & Combos ======= */
const F = { Scholar:'Scholar', Weather:'Weather', Beast:'Beast', Tamer:'Tamer', Relic:'Relic' };
const CARDS = [
  {id:'SchLight',name:'Scholar of Light',fam:F.Scholar,emoji:'‚ú®',tier:2},
  {id:'SchStorm',name:'Scholar of Storms',fam:F.Scholar,emoji:'üå©Ô∏è',tier:2},
  {id:'SchBeast',name:'Scholar of Beasts',fam:F.Scholar,emoji:'üêæ',tier:2},
  {id:'SchStars',name:'Scholar of Stars',fam:F.Scholar,emoji:'üåå',tier:3},
  {id:'SchTime', name:'Scholar of Time', fam:F.Scholar,emoji:'‚è≥',tier:3},
  {id:'SchDark', name:'Scholar of Darkness', fam:F.Scholar,emoji:'üåë',tier:2},

  {id:'StormCloud',name:'Storm Cloud',fam:F.Weather,emoji:'‚òÅÔ∏è',tier:1},
  {id:'Lightning',name:'Lightning',fam:F.Weather,emoji:'‚ö°',tier:2},
  {id:'Sun', name:'Sun', fam:F.Weather,emoji:'‚òÄÔ∏è',tier:1},
  {id:'Rain',name:'Rain',fam:F.Weather,emoji:'üåßÔ∏è',tier:1},
  {id:'Blizzard',name:'Blizzard',fam:F.Weather,emoji:'‚ùÑÔ∏è',tier:2},
  {id:'Eclipse',name:'Eclipse',fam:F.Weather,emoji:'üåò',tier:3},

  {id:'SkySerpent',name:'Sky Serpent',fam:F.Beast,emoji:'üêç',tier:2},
  {id:'RockRhino',name:'Rock Rhino',fam:F.Beast,emoji:'ü¶è',tier:2},
  {id:'FireDrake',name:'Fire Drake',fam:F.Beast,emoji:'üêâ',tier:3},
  {id:'ShadowWolf',name:'Shadow Wolf',fam:F.Beast,emoji:'üê∫',tier:2},

  {id:'BeastMaster',name:'Beast Master',fam:F.Tamer,emoji:'üêæ‚öîÔ∏è',tier:2},
  {id:'DragonKnight',name:'Dragon Knight',fam:F.Tamer,emoji:'üêâ‚öîÔ∏è',tier:3},
  {id:'WolfTamer',name:'Wolf Tamer',fam:F.Tamer,emoji:'üê∫‚öîÔ∏è',tier:2},
  {id:'StormRider',name:'Storm Rider',fam:F.Tamer,emoji:'üå©Ô∏è‚öîÔ∏è',tier:2},

  {id:'SanctumOrb',name:'Sanctum Orb',fam:F.Relic,emoji:'üîÆ',tier:3},
  {id:'StormLance',name:'Storm Lance',fam:F.Relic,emoji:'‚öîÔ∏èüå©Ô∏è',tier:2},
  {id:'SunCrown',name:'Sun Crown',fam:F.Relic,emoji:'üëë‚òÄÔ∏è',tier:2},
  {id:'ShadowDagger',name:'Shadow Dagger',fam:F.Relic,emoji:'üó°Ô∏èüåë',tier:2},
  {id:'MirrorStars',name:'Mirror of Stars',fam:F.Relic,emoji:'ü™ûüåå',tier:3},
];
const byId = Object.fromEntries(CARDS.map(c=>[c.id,c]));
const makeUID = ()=> Math.random().toString(36).slice(2);

const NEED = {
  id:(id)=>({id,label:byId[id].name, test:c=>c.id===id}),
  fam:(fam)=>({fam,label:fam, test:c=>c.fam===fam}),
};

const COMBOS = [
  /* EFFECT COMBOS */
  {key:'ThunderHeist', label:'Thunder Heist', pts:6, need:[NEED.id('Lightning'),NEED.id('StormCloud'),NEED.id('StormRider')], effect:'stealEach:1'},
  {key:'MidnightAssassination', label:'Midnight Assassination', pts:7, need:[NEED.id('ShadowDagger'),NEED.id('SchDark'),NEED.id('StormCloud')], effect:'destroyTarget:any'},
  {key:'StormShatter', label:'Storm Shatter', pts:6, need:[NEED.id('StormLance'),NEED.id('Lightning'),NEED.id('SchStorm')], effect:'destroyRelicEach'},
  {key:'Weatherlift', label:'Weatherlift', pts:6, need:[NEED.id('Rain'),NEED.id('StormCloud'),NEED.id('SchTime')], effect:'stealTarget:Weather'},
  {key:'SerpentsSpoils', label:'Serpent‚Äôs Spoils', pts:6, need:[NEED.id('SkySerpent'),NEED.id('SchBeast'),NEED.id('ShadowDagger')], effect:'stealTarget:Relic'},
  {key:'FrozenOracle', label:'Frozen Oracle', pts:6, need:[NEED.id('SanctumOrb'),NEED.id('Blizzard'),NEED.id('SchTime')], effect:'freeze:4000'},
  {key:'CrownCommand', label:'Crown Command', pts:5, need:[NEED.id('SunCrown'),NEED.id('Sun'),NEED.id('BeastMaster')], effect:'draw:1'},
  {key:'PackRaid', label:'Pack Raid', pts:6, need:[NEED.id('ShadowWolf'),NEED.id('BeastMaster'),NEED.id('WolfTamer')], effect:'stealTarget:Beast'},
  {key:'StarlitCopy', label:'Starlit Copy', pts:6, need:[NEED.id('SchStars'),NEED.id('MirrorStars'),NEED.id('SchTime')], effect:'duplicateTarget:any'},
  {key:'ScholarsGlint', label:'Scholars‚Äô Glint', pts:5, need:[NEED.id('SchLight'),NEED.id('SchStorm')], effect:'flip:2500'}, // LOCAL center reveal
  {key:'TwilightEdict', label:'Twilight Edict', pts:5, need:[NEED.id('Eclipse'),NEED.id('SchDark')], effect:'revealOpp:3000'},

  /* LEGENDARY */
  {key:'AscendantTempest', label:'ASCENDANT TEMPEST', pts:42, need:[NEED.id('SchStorm'),NEED.id('Lightning'),NEED.id('StormCloud'),NEED.id('StormRider'),NEED.id('Eclipse')], effect:'legend:tempest'},
  {key:'RelicsUnleashed', label:'RELICS UNLEASHED', pts:34, need:[NEED.id('SanctumOrb'),NEED.id('MirrorStars'),NEED.id('StormLance'),NEED.id('SunCrown')], effect:'legend:relics'},
  {key:'ScholarsCouncil', label:'SCHOLARS COUNCIL', pts:28, need:[NEED.id('SchLight'),NEED.id('SchDark'),NEED.id('SchStars'),NEED.id('SchTime')], effect:'legend:council'},
  {key:'BeastDominion', label:'BEAST DOMINION', pts:30, need:[NEED.id('BeastMaster'),NEED.id('WolfTamer'),NEED.id('SkySerpent'),NEED.id('ShadowWolf')], effect:'legend:beast'},

  /* POINTS-ONLY (existing) */
  {key:'Cloudburst', label:'Cloudburst', pts:7, need:[NEED.id('StormCloud'),NEED.id('Rain'),NEED.id('Lightning')]},
  {key:'SolarCoronation', label:'Solar Coronation', pts:12, need:[NEED.id('SunCrown'),NEED.id('Sun'),NEED.id('SchLight')]},
  {key:'RhinoStudy', label:'Rhino Study', pts:9, need:[NEED.id('RockRhino'),NEED.id('SchBeast'),NEED.id('BeastMaster')]},
  {key:'TimeAndStars', label:'Time & Stars', pts:16, need:[NEED.id('SchTime'),NEED.id('SchStars'),NEED.id('SanctumOrb')]},
  {key:'WeatherSet', label:'Weather Set', pts:20, need:[NEED.id('Rain'),NEED.id('Sun'),NEED.id('Blizzard'),NEED.id('Lightning')]},
  {key:'Skychain', label:'Skychain', pts:17, need:[NEED.id('SkySerpent'),NEED.id('BeastMaster'),NEED.id('Lightning')]},
  {key:'ScholarTriad', label:'Scholar Triad', pts:18, need:[NEED.id('SchLight'),NEED.id('SchStorm'),NEED.id('SchBeast')]},

  /* NEW ‚ÄúSET‚Äù COMBOS */
  {key:'BeastTrio', label:'Beast Trio', pts:12, need:[NEED.fam(F.Beast), NEED.fam(F.Beast), NEED.fam(F.Beast)]},
  {key:'BeastHorde', label:'Beast Horde', pts:18, need:[NEED.fam(F.Beast), NEED.fam(F.Beast), NEED.fam(F.Beast), NEED.fam(F.Beast)]},
  {key:'ScholarAssembly', label:'Scholar Assembly', pts:16, need:[NEED.fam(F.Scholar), NEED.fam(F.Scholar), NEED.fam(F.Scholar)]},      /* any 3 Scholars */
  {key:'ScholarConclave', label:'Scholar Conclave', pts:22, need:[NEED.fam(F.Scholar), NEED.fam(F.Scholar), NEED.fam(F.Scholar), NEED.fam(F.Scholar)]}, /* any 4 Scholars */
  {key:'RelicSet', label:'Relic Set', pts:14, need:[NEED.fam(F.Relic), NEED.fam(F.Relic), NEED.fam(F.Relic)]},
  {key:'TamerLine', label:'Tamer Line', pts:13, need:[NEED.fam(F.Tamer), NEED.fam(F.Tamer), NEED.fam(F.Tamer)]},
  {key:'WeatherParade', label:'Weather Parade', pts:10, need:[NEED.fam(F.Weather), NEED.fam(F.Weather), NEED.fam(F.Weather)]},
];

const COMBO_BY_KEY = Object.fromEntries(COMBOS.map(c=>[c.key,c]));

/* ======= DOM ======= */
const el = {
  river: document.getElementById('river'),
  hand: document.getElementById('hand'),
  opps: document.getElementById('opps'),
  ready: document.getElementById('ready'),
  near: document.getElementById('near'),
  deckBadge: document.getElementById('deckBadge'),
  discardBadge: document.getElementById('discardBadge'),
  startBtn: document.getElementById('startBtn'),
  hostBadge: document.getElementById('hostBadge'),
  gameIdBadge: document.getElementById('gameIdBadge'),
  fsBtn: document.getElementById('fsBtn'),
  leaveBtn: document.getElementById('leaveBtn'),
  toLobbyBtn: document.getElementById('toLobbyBtn'),
  over: document.getElementById('over'),
  overTitle: document.getElementById('overTitle'),
  overWhy: document.getElementById('overWhy'),
  overTable: document.getElementById('overTable'),
  pick: document.getElementById('pick'),
  pickTitle: document.getElementById('pickTitle'),
  pickBody: document.getElementById('pickBody'),
  pickCancel: document.getElementById('pickCancel'),
  toasts: document.getElementById('toasts'),
};
el.gameIdBadge.textContent = `ID: ${gameId.slice(0,6)}`;

/* ======= Helpers ======= */
function cardFrontHTML(id){
  const c = byId[id];
  return `<div class="front"><div class="t">${c.emoji} ${c.name}</div><div class="f">${c.fam} ‚Ä¢ Tier ${c.tier}</div></div>`;
}
function cardBackHTML(){ return `<div class="back"></div>`; }
function timerHTML(){ return `
  <div class="timer" aria-hidden="true">
    <svg viewBox="0 0 36 36" focusable="false">
      <circle class="track" cx="18" cy="18" r="15"></circle>
      <circle class="prog" cx="18" cy="18" r="15"></circle>
    </svg>
    <span class="txt">5</span>
  </div>`; }
function miniHand(count){ return `<div class="mini">${Array.from({length:Math.min(5,count)},()=>'<i></i>').join('')}</div>`; }
function buildDeck(){
  const freq = { Scholar:3, Weather:4, Beast:3, Tamer:3, Relic:3 };
  const deck=[];
  for(const c of CARDS){ const n=freq[c.fam]??2; for(let i=0;i<n;i++) deck.push(c.id); }
  for(let i=0;i<8;i++){ deck.push(CARDS[(Math.random()*CARDS.length)|0].id); }
  for(let i=deck.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [deck[i],deck[j]]=[deck[j],deck[i]]; }
  return deck;
}
function now(){ return Date.now(); }

/* ======= Local reveal timers (per river slot) ======= */
const localRevealUntil = Array(10).fill(0);    // when front hides
const localRevealStart = Array(10).fill(0);    // when started showing
const localRevealDur   = Array(10).fill(0);    // ms shown total for this cycle
let   localFlipHighlightUntil = 0;             // brief glow on flip-all
const prevRiverUids = Array(10).fill(null);

/* ======= Ready / Near combos ======= */
function findReadyCombos(handIds){
  const hand = handIds.map(id=>byId[id]);
  const out=[];
  for(const combo of COMBOS){
    const used = new Array(hand.length).fill(false);
    const take = [];
    for(const req of combo.need){
      let idx=-1;
      for(let i=0;i<hand.length;i++){
        if(used[i]) continue;
        if(req.test(hand[i])){ idx=i; break; }
      }
      if(idx<0){ take.length=0; break; }
      used[idx]=true; take.push(idx);
    }
    if(take.length){ out.push({combo,indexes:take}); }
  }
  out.sort((a,b)=> (b.combo.pts + (b.combo.effect?2:0)) - (a.combo.pts + (a.combo.effect?2:0)));
  return out.slice(0,3);
}
function findNearCombosDetailed(handIds, limitMissing=2){
  const hand = handIds.map(id=>byId[id]);
  const res=[];
  for(const combo of COMBOS){
    const used = new Array(hand.length).fill(false);
    const missing=[];
    for(const req of combo.need){
      let ok=-1;
      for(let i=0;i<hand.length;i++){
        if(used[i]) continue;
        if(req.test(hand[i])){ ok=i; break; }
      }
      if(ok>=0) used[ok]=true; else missing.push(req);
    }
    if(missing.length>0 && missing.length<=limitMissing){
      res.push({combo, missing});
    }
  }
  res.sort((a,b)=> (a.missing.length - b.missing.length) || ((b.combo.pts||0) - (a.combo.pts||0)));
  return res.slice(0,3);
}

/* ======= Bootstrap / seat ======= */
async function ensureGameAndSeat(){
  await runTransaction(db, async(tx)=>{
    const snap = await tx.get(gref);
    if (!snap.exists()){
      const deck = buildDeck();
      const base = {
        createdAt: serverTimestamp(),
        host: username,
        status: "lobby",
        players: [username],
        deck, discard: [],
        river: Array.from({length:10}, ()=>({uid:null, id:null})),
        hands: {[username]: []},
        points: {[username]: 0},
        combos: {[username]: 0},
        winners: [],
        freezeUntil: 0,
        revealOppUntil: 0,
        events: [],
        lastMoveAt: now()
      };
      tx.set(gref, base);
      return;
    }
    const g = snap.data();
    const players = Array.isArray(g.players) ? g.players.slice() : [];
    if (!players.includes(username)) players.push(username);
    const hands = Object.assign({}, g.hands);
    if (!hands[username]) hands[username] = [];
    const points = Object.assign({}, g.points); if(points[username]===undefined) points[username]=0;
    const combos = Object.assign({}, g.combos); if(combos[username]===undefined) combos[username]=0;
    tx.update(gref, { players, hands, points, combos, host: g.host || username });
  });
}
await ensureGameAndSeat();

/* ======= Host: deal & start ======= */
async function hostDealAndStart(){
  await runTransaction(db, async(tx)=>{
    const snap = await tx.get(gref);
    if (!snap.exists()) throw new Error("Missing game");
    const g = snap.data();
    if (g.host !== username) return;
    const deck = buildDeck();
    const river = Array.from({length:10}, ()=>({uid: makeUID(), id: deck.pop() || null}));
    const hands = {};
    for(const p of g.players){
      hands[p] = [];
      for(let i=0;i<5;i++){ const id = deck.pop(); if(id) hands[p].push({uid:makeUID(), id}); }
    }
    const points={}, combos={}; g.players.forEach(p=>{ points[p]=0; combos[p]=0; });
    tx.update(gref, {
      status:"active", deck, river, hands, points, combos,
      discard: [], winners: [],
      freezeUntil: 0, revealOppUntil: 0,
      events: (g.events||[]).concat([{ts:now(), text:`${username} started the game.`},{ts:now(), type:'revealCenter', ms:5000, text:'Cards revealed.'}]).slice(-20),
      lastMoveAt: now()
    });
  });
}

/* ======= Interactions ======= */
let sel = {zone:null, idx:null};
let tapLock = 0;
function lockShort(){ tapLock = now() + 220; }
function canTap(){ return now() > tapLock; }

async function pickFromRiver(rIdx){
  if (!canTap()) return; lockShort();
  await runTransaction(db, async(tx)=>{
    const snap = await tx.get(gref); if(!snap.exists()) return;
    const g = snap.data(); if(g.status!=='active') return;
    if (now() < (g.freezeUntil||0)) return;

    const r = (g.river||[])[rIdx]; if(!r || !r.id) return;
    const my = (g.hands?.[username]||[]).slice(); if(my.length>=5) return;

    const deck = (g.deck||[]).slice(); const discard = (g.discard||[]).slice();

    my.push({uid:makeUID(), id:r.id});
    const nextId = deck.pop() || null;
    g.river[rIdx] = {uid: nextId ? makeUID() : null, id: nextId};

    const hands = Object.assign({}, g.hands, {[username]: my});
    const events = (g.events||[]).concat([{ts:now(), text:`${username} drew from center.`}]).slice(-20);
    tx.update(gref, {hands, river:g.river, deck, discard, events, lastMoveAt: now()});
  });
}

async function swapHandRiver(hIdx, rIdx){
  if (!canTap()) return; lockShort();
  await runTransaction(db, async(tx)=>{
    const snap = await tx.get(gref); if(!snap.exists()) return;
    const g = snap.data(); if(g.status!=='active') return;
    if (now() < (g.freezeUntil||0)) return;

    const my = (g.hands?.[username]||[]).slice(); if(!my[hIdx]) return;
    const r = (g.river||[])[rIdx]; if(!r || !r.id) return;

    const myCard = my[hIdx], riverCard = r;
    my[hIdx] = {uid: makeUID(), id: riverCard.id};
    g.river[rIdx] = {uid: makeUID(), id: myCard.id};

    const hands = Object.assign({}, g.hands, {[username]: my});
    const events = (g.events||[]).concat([{ts:now(), text:`${username} swapped with center.`}]).slice(-20);
    tx.update(gref, {hands, river:g.river, events, lastMoveAt: now()});
  });
}

/* ======= Effects ======= */
function pushEvent(g, e){ g.events = (g.events||[]).concat([e]).slice(-20); }
function pushToHandOrDiscard(g, player, cardId){
  const hand = (g.hands[player]||[]);
  if (hand.length < 5) hand.push({uid:makeUID(), id:cardId});
  else (g.discard||=(g.discard||[])).push(cardId);
}
function oppList(g, exclude){ return (g.players||[]).filter(p=>p!==exclude); }
function removeRandomFromHand(g, player){
  const h = (g.hands[player]||[]);
  if(!h.length) return null;
  const i = Math.floor(Math.random()*h.length);
  return h.splice(i,1)[0];
}
function removeFirstFam(g, player, fam){
  const h = (g.hands[player]||[]);
  const idx = h.findIndex(x=>byId[x.id].fam===fam);
  if (idx>=0) return h.splice(idx,1)[0];
  return null;
}

function effectNeedsTarget(effect){
  if (!effect) return null;
  if (effect.startsWith('stealTarget:')) return {kind:'steal', fam:effect.split(':')[1]};
  if (effect.startsWith('duplicateTarget:')) return {kind:'duplicate', fam:effect.split(':')[1]};
  if (effect.startsWith('destroyTarget:')) return {kind:'destroy', fam:effect.split(':')[1]};
  return null;
}
function famMatch(fam, id){
  if (fam==='any') return true;
  return byId[id].fam===fam;
}

function applyNonTargetEffect(g, who, comboKey){
  switch(comboKey){
    case 'ThunderHeist': {
      for(const opp of oppList(g, who)){
        const got = removeRandomFromHand(g, opp);
        if (got) pushToHandOrDiscard(g, who, got.id);
      }
      pushEvent(g, {ts:now(), text:`${who} plucked 1 from each opponent.`});
    } break;
    case 'StormShatter': {
      for(const opp of oppList(g, who)){
        const d = removeFirstFam(g, opp, F.Relic);
        if (d) (g.discard||=(g.discard||[])).push(d.id);
      }
      pushEvent(g, {ts:now(), text:`${who} shattered opponents‚Äô relics.`});
    } break;
    case 'FrozenOracle': {
      g.freezeUntil = now() + 4000;
      pushEvent(g, {ts:now(), text:`${who} froze the river (4s).`});
    } break;
    case 'CrownCommand': {
      const deck = g.deck||[];
      if (deck.length){
        const id = deck.pop();
        pushToHandOrDiscard(g, who, id);
        pushEvent(g, {ts:now(), text:`${who} drew a bonus card.`});
      }
    } break;
    case 'ScholarsGlint': {
      pushEvent(g, {ts:now(), type:'revealCenter', ms:2500, text:`${who} flashed the center.`}); // LOCAL flip
    } break;
    case 'TwilightEdict': {
      g.revealOppUntil = now() + 3000;
      pushEvent(g, {ts:now(), text:`${who} revealed opponents‚Äô hands (3s).`});
    } break;
    /* LEGENDARY */
    case 'AscendantTempest': {
      g.revealOppUntil = now()+4000;
      for(const opp of oppList(g, who)){
        for(let k=0;k<2;k++){
          const got = removeRandomFromHand(g, opp);
          if (got) pushToHandOrDiscard(g, who, got.id);
        }
        const d = removeRandomFromHand(g, opp);
        if (d) (g.discard||=(g.discard||[])).push(d.id);
      }
      pushEvent(g, {ts:now(), text:`${who} unleashed ASCENDANT TEMPEST!`});
    } break;
    case 'RelicsUnleashed': {
      for(const opp of oppList(g, who)){
        const d = removeFirstFam(g, opp, F.Relic);
        if (d) (g.discard||=(g.discard||[])).push(d.id);
      }
      const deck = g.deck||[];
      if (deck.length){ pushToHandOrDiscard(g, who, deck.pop()); }
      pushEvent(g, {ts:now(), text:`${who} unleashed RELICS!`});
    } break;
    case 'ScholarsCouncil': {
      g.freezeUntil = now()+3000;
      pushEvent(g, {ts:now(), text:`${who} convened COUNCIL (river frozen 3s).`});
    } break;
    case 'BeastDominion': {
      const deck = g.deck||[];
      if (deck.length) pushToHandOrDiscard(g, who, deck.pop());
      if (deck.length) pushToHandOrDiscard(g, who, deck.pop());
      for(const opp of oppList(g, who)){
        const d = removeRandomFromHand(g, opp);
        if (d) (g.discard||=(g.discard||[])).push(d.id);
      }
      pushEvent(g, {ts:now(), text:`${who} proclaimed BEAST DOMINION!`});
    } break;
  }
}

/* ======= Play combo ======= */
async function playCombo(comboKey, useUids, targetInfo){
  await runTransaction(db, async(tx)=>{
    const snap = await tx.get(gref); if(!snap.exists()) return;
    const g = snap.data(); if(g.status!=='active') return;

    const my = (g.hands?.[username]||[]).slice();
    const haveAll = useUids.every(uid => my.some(x=>x.uid===uid));
    if (!haveAll) return;

    // remove those cards from my hand
    for(const uid of useUids){ const idx = my.findIndex(x=>x.uid===uid); if (idx>=0) my.splice(idx,1); }

    const combo = COMBO_BY_KEY[comboKey];
    const points = Object.assign({}, g.points);
    const combos = Object.assign({}, g.combos);
    points[username] = (points[username]||0) + (combo.pts||0);
    combos[username] = (combos[username]||0) + 1;

    const needs = effectNeedsTarget(combo.effect);
    if (needs){
      const oppH = (g.hands?.[targetInfo.opp]||[]);
      const tIdx = oppH.findIndex(x=>x.uid===targetInfo.cardUid);
      if (tIdx<0 || !famMatch(needs.fam==='any'?'any':needs.fam, oppH[tIdx].id)) return;
      const picked = oppH.splice(tIdx,1)[0];

      if (needs.kind==='steal'){
        pushToHandOrDiscard(g, username, picked.id);
        pushEvent(g, {ts:now(), text:`${username} stole ${byId[picked.id].emoji} ${byId[picked.id].name} from ${targetInfo.opp}.`});
      } else if (needs.kind==='duplicate'){
        pushToHandOrDiscard(g, username, picked.id);
        (g.hands[targetInfo.opp] = oppH); // opponent keeps theirs; we copy
        pushEvent(g, {ts:now(), text:`${username} duplicated ${byId[picked.id].emoji} ${byId[picked.id].name} from ${targetInfo.opp}.`});
      } else if (needs.kind==='destroy'){
        (g.discard||=(g.discard||[])).push(picked.id);
        pushEvent(g, {ts:now(), text:`${username} destroyed ${byId[picked.id].emoji} ${byId[picked.id].name} from ${targetInfo.opp}.`});
      }
    } else {
      applyNonTargetEffect(g, username, comboKey);
      pushEvent(g, {ts:now(), text:`${username} played ${combo.label} (+${combo.pts||0}).`});
    }

    const hands = Object.assign({}, g.hands, {[username]: my});
    tx.update(gref, {
      hands, points, combos,
      river: g.river, deck: g.deck, discard: g.discard,
      freezeUntil: g.freezeUntil||0, revealOppUntil: g.revealOppUntil||0,
      events: g.events, lastMoveAt: now()
    });
  });
  await endIfDeckDone();
}

/* ======= Target picker ======= */
function openTargetPicker(game, combo, useUids, needs){
  const picker = el.pick, title = el.pickTitle, body = el.pickBody;
  title.textContent = `Choose a target ‚Äî ${combo.label}`;
  body.innerHTML = '';
  const players = (game.players||[]).filter(p=>p!==username);
  for (const p of players){
    const row = document.createElement('div'); row.className='prow';
    row.innerHTML = `<h4>${p}</h4>`;
    const cardsDiv = document.createElement('div'); cardsDiv.className='pcards';
    const hand = (game.hands?.[p]||[]);
    let any=false;
    for(const c of hand){
      if (needs.fam!=='any' && !famMatch(needs.fam, c.id)) continue;
      any=true;
      const btn = document.createElement('button'); btn.className='pbtn';
      btn.textContent = `${byId[c.id].emoji} ${byId[c.id].name}`;
      btn.addEventListener('click', async ()=>{
        picker.classList.remove('show');
        await playCombo(combo.key, useUids, {opp:p, cardUid:c.uid});
      });
      cardsDiv.appendChild(btn);
    }
    if(!any){ const none=document.createElement('div'); none.style.opacity='.75'; none.style.fontSize='12px'; none.textContent='No valid cards.'; cardsDiv.appendChild(none); }
    row.appendChild(cardsDiv); body.appendChild(row);
  }
  picker.classList.add('show');
}
el.pickCancel.addEventListener('click', ()=> el.pick.classList.remove('show'));

/* ======= Rendering ======= */
function renderOpps(game){
  const reveal = now() < (game.revealOppUntil||0);
  const players = (game.players||[]).filter(p=>p!==username);
  const hands = game.hands||{};
  const points = game.points||{};
  el.opps.innerHTML = '';
  for (const p of players){
    const div = document.createElement('div'); div.className='opp';
    const hand = (hands[p]||[]);
    div.innerHTML = `<span class="name">${p}</span>
                     <span class="badge">Pts: ${points[p]||0}</span>`;
    if (reveal){
      const rev = document.createElement('div'); rev.className='revealMini';
      rev.innerHTML = hand.slice(0,6).map(x=>`${byId[x.id].emoji} ${byId[x.id].name}`).join(' ¬∑ ');
      div.appendChild(rev);
    } else {
      div.insertAdjacentHTML('beforeend', miniHand(hand.length));
    }
    el.opps.appendChild(div);
  }
}
function renderRiver(game){
  const frozen = now() < (game.freezeUntil||0);
  const wrap = document.querySelector('.riverWrap');
  wrap.classList.toggle('frozen', frozen);
  wrap.classList.toggle('flipGlow', now() < localFlipHighlightUntil);

  el.river.innerHTML='';
  const R = game.river||[];
  for(let i=0;i<10;i++){
    const s = R[i] || {id:null};
    const slot = document.createElement('div');
    slot.className = 'slot' + (s.id? '':' empty');
    slot.dataset.idx = String(i);
    if (sel.zone==='river' && sel.idx===i) slot.classList.add('sel');
    if (s.id){
      const card = document.createElement('div'); card.className='card';
      card.innerHTML = cardFrontHTML(s.id) + cardBackHTML() + timerHTML();
      el.river.appendChild(Object.assign(slot,{appendChild:slot.appendChild.bind(slot)}));
      slot.appendChild(card);
    } else {
      el.river.appendChild(slot);
    }
  }
}
function renderHand(game){
  el.hand.innerHTML='';
  const my = (game.hands?.[username]||[]);
  for(let i=0;i<5;i++){
    const slot = document.createElement('div');
    slot.className = 'hslot'+(my[i]?'':' empty');
    slot.dataset.idx = String(i);
    if (sel.zone==='hand' && sel.idx===i) slot.classList.add('sel');
    if (my[i]){
      const c = my[i].id;
      const card = document.createElement('div'); card.className='card';
      card.innerHTML = cardFrontHTML(c); // hand is always face-up
      slot.appendChild(card);
    }
    el.hand.appendChild(slot);
  }
}
function renderReady(game){
  const my = (game.hands?.[username]||[]);
  const ready = findReadyCombos(my.map(x=>x.id));
  el.ready.innerHTML = '';
  if (!ready.length){
    const pill=document.createElement('div'); pill.className='pill'; pill.textContent='No ready combos';
    el.ready.appendChild(pill);
    return;
  }
  for(const r of ready){
    const combo = r.combo;
    const emo = r.indexes.map(i => byId[my[i].id].emoji).join(' ');
    const p = document.createElement('div'); p.className='pill';
    const label = document.createElement('span'); label.textContent = `${combo.label} (+${combo.pts})`;
    const cards = document.createElement('span'); cards.textContent = `‚Ä¢ ${emo}`;
    const btn = document.createElement('button'); btn.className='playBtn'; btn.textContent='PLAY';
    btn.addEventListener('click', async ()=>{
      const useUids = r.indexes.map(i=>my[i].uid);
      const needs = effectNeedsTarget(combo.effect);
      if (needs){ openTargetPicker(game, combo, useUids, needs); }
      else { await playCombo(combo.key, useUids, null); }
    });
    p.append(label, cards, btn);
    el.ready.appendChild(p);
  }
}
function renderNear(game){
  const my = (game.hands?.[username]||[]);
  const near = findNearCombosDetailed(my.map(x=>x.id), 2);
  el.near.innerHTML='';
  if (!near.length){
    const pill=document.createElement('div'); pill.className='pill'; pill.textContent='No combo suggestions';
    el.near.appendChild(pill); return;
  }
  for(const n of near){
    const pill=document.createElement('div'); pill.className='pill';
    const needsEmo = n.missing.map(m=> (m.id? byId[m.id].emoji : m.fam==='Scholar'?'üìò':m.fam==='Beast'?'üêæ':m.fam==='Relic'?'üóùÔ∏è':m.fam==='Tamer'?'‚öîÔ∏è':m.fam==='Weather'?'‚õÖ':'‚ùì')).join(' ');
    pill.innerHTML = `<span>${n.combo.label}</span> <span class="need">‚Ä¢ need ${needsEmo}</span>`;
    el.near.appendChild(pill);
  }
}
function updateHUD(game){
  el.deckBadge.textContent = `Deck: ${game.deck?.length||0}`;
  el.discardBadge.textContent = `Discard: ${game.discard?.length||0}`;
  el.startBtn.hidden = !(game.host===username && game.status==='lobby');
  el.hostBadge.hidden = !(game.host===username);
}

/* Face/back + timer updater (local) */
function rafFaces(){
  const slots = el.river.querySelectorAll('.slot');
  const t = now();
  slots.forEach((slot)=>{
    const idx = Number(slot.dataset.idx);
    const front = slot.querySelector('.front');
    const back  = slot.querySelector('.back');
    const timer = slot.querySelector('.timer');
    const prog  = slot.querySelector('.prog');
    const txt   = slot.querySelector('.txt');
    if (!front || !back) return;
    const up = t < (localRevealUntil[idx]||0);
    front.style.display = up ? '' : 'none';
    back.style.display  = up ? 'none' : '';
    if (timer && prog && txt){
      if (up){
        timer.style.display = '';
        const elapsed = Math.max(0, t - (localRevealStart[idx]||t));
        const dur = Math.max(1, localRevealDur[idx]||1);
        const remain = Math.max(0, (localRevealUntil[idx]||t)-t);
        const ratio = Math.max(0, Math.min(1, 1 - (elapsed/dur)));
        const circ = 2*Math.PI*15;
        prog.setAttribute('stroke-dasharray', `${circ}`);
        prog.setAttribute('stroke-dashoffset', `${(1-ratio)*circ}`);
        txt.textContent = String(Math.ceil(remain/1000));
      } else {
        timer.style.display = 'none';
      }
    }
  });
  requestAnimationFrame(rafFaces);
}
requestAnimationFrame(rafFaces);

/* ======= Click bindings ======= */
el.river.addEventListener('click', async (e)=>{
  const slot = e.target.closest('.slot'); if(!slot) return;
  const rIdx = Number(slot.dataset.idx);
  const snap = await getDoc(gref); if(!snap.exists()) return;
  const g = snap.data(); if (g.status!=='active') return;

  const my = (g.hands?.[username]||[]);
  if (now() < (g.freezeUntil||0)) return;

  if (my.length<5){ await pickFromRiver(rIdx); sel={zone:null,idx:null}; }
  else{
    if (sel.zone==='hand'){ await swapHandRiver(sel.idx, rIdx); sel={zone:null,idx:null}; }
    else { sel={zone:'river', idx:rIdx}; renderRiver(g); }
  }
});
el.hand.addEventListener('click', async (e)=>{
  const slot = e.target.closest('.hslot'); if(!slot) return;
  const hIdx = Number(slot.dataset.idx);
  const snap = await getDoc(gref); if(!snap.exists()) return;
  const g = snap.data(); if (g.status!=='active') return;
  const my = (g.hands?.[username]||[]);
  if (!my[hIdx]) return;

  if (sel.zone==='river'){ await swapHandRiver(hIdx, sel.idx); sel={zone:null,idx:null}; }
  else if (sel.zone==='hand' && sel.idx===hIdx){ sel={zone:null,idx:null}; }
  else { sel={zone:'hand', idx:hIdx}; renderHand(g); }
});

/* ======= Fullscreen / leave / start ======= */
el.fsBtn.addEventListener('click', async ()=>{
  const root = document.documentElement;
  try{
    if (!document.fullscreenElement) await (root.requestFullscreen?.() || root.webkitRequestFullscreen?.());
    else await (document.exitFullscreen?.() || document.webkitExitFullscreen?.());
  }catch(e){}
});
el.leaveBtn.addEventListener('click', ()=>{ location.href = `${LOBBY_URL}?username=${encodeURIComponent(username)}`; });
el.toLobbyBtn.addEventListener('click', ()=>{ location.href = `${LOBBY_URL}?username=${encodeURIComponent(username)}`; });
el.startBtn.addEventListener('click', hostDealAndStart);

/* ======= Game over & win bump ======= */
async function endIfDeckDone(){
  await runTransaction(db, async(tx)=>{
    const snap = await tx.get(gref);
    if (!snap.exists()) return;
    const g = snap.data();
    if (g.status !== 'active') return;

    const anyRiver = (g.river||[]).some(s=>s && s.id);
    const deckEmpty = !g.deck || g.deck.length===0;
    if (!deckEmpty || anyRiver) return;

    const pts = g.points||{};
    const entries = Object.entries(pts);
    if (!entries.length) return;
    entries.sort((a,b)=> (b[1])-(a[1]));
    const top = entries[0][1];
    const winners = entries.filter(e=>e[1]===top).map(e=>e[0]);

    tx.update(gref, {status:'over', winners, overReason:'Deck exhausted', lastMoveAt: now(),
      events: (g.events||[]).concat([{ts:now(), text:`Game over ‚Äî winner: ${winners.join(', ')}`}]).slice(-20)
    });
  });
}
async function bumpMyWinsIfWinner(winners){
  if (!winners.includes(username)) return;
  await runTransaction(db, async(tx)=>{
    const usnap = await tx.get(uref);
    if (!usnap.exists()){ tx.set(uref, {wins:1}, {merge:true}); }
    else { const cur = usnap.data(); tx.update(uref, {wins: (cur.wins||0)+1}); }
  });
}

/* ======= Live sync + toasts + local reveal handling ======= */
let lastEventTs = 0;
onSnapshot(gref, async (snap)=>{
  if (!snap.exists()) return;
  const g = snap.data();

  /* Local flip-timer bootstrapping:
     - New/changed river card: 5s face-up (local)
     - revealCenter event: extend/refresh timers to given ms for all slots */
  const R = g.river||[];
  for(let i=0;i<10;i++){
    const u = R[i]?.uid || null;
    if (u && u !== prevRiverUids[i]){
      const t = now();
      localRevealStart[i] = t;
      localRevealDur[i]   = 5000;
      localRevealUntil[i] = t + 5000;
      prevRiverUids[i]    = u;
    } else if (!u) {
      prevRiverUids[i] = null;
      localRevealStart[i] = 0;
      localRevealDur[i]   = 0;
      localRevealUntil[i] = 0;
    }
  }

  renderOpps(g);
  renderRiver(g);
  renderHand(g);
  renderReady(g);
  renderNear(g);
  updateHUD(g);

  // toasts + handle structured events
  for (const ev of (g.events||[])){
    if (ev.ts > lastEventTs){
      if (ev.type === 'revealCenter'){
        const dur = ev.ms || 2500;
        const t = now();
        for(let i=0;i<10;i++){
          localRevealStart[i] = t;
          localRevealDur[i]   = dur;
          localRevealUntil[i] = t + dur;
        }
        localFlipHighlightUntil = t + dur;
      }
      if (ev.text) showToast(ev.text);
      lastEventTs = Math.max(lastEventTs, ev.ts);
    }
  }

  if (g.status==='over'){
    showOver(g);
    if (!localStorage.getItem(`splinters.bumped.${gameId}.${username}`)){
      await bumpMyWinsIfWinner(g.winners||[]);
      localStorage.setItem(`splinters.bumped.${gameId}.${username}`,'1');
      setTimeout(()=>{ location.href = `${LOBBY_URL}?username=${encodeURIComponent(username)}`; }, 1500);
    }
  }
});

/* ======= UI helpers ======= */
function showToast(text){
  const t=document.createElement('div'); t.className='toast'; t.textContent=text;
  el.toasts.appendChild(t);
  const life = 1300 + Math.random()*500;
  setTimeout(()=>{ t.classList.add('out'); setTimeout(()=>t.remove(),220); }, life);
}
function showOver(game){
  const winners = game.winners||[];
  el.overTitle.textContent = winners.includes(username) && winners.length===1 ? 'You win!' : `Winner: ${winners.join(', ')}`;
  el.overWhy.textContent = game.overReason || 'Game finished';
  const pts = game.points||{};
  const rows = Object.entries(pts).sort((a,b)=>b[1]-a[1]);
  el.overTable.innerHTML = `<tr><th>Player</th><th>Points</th></tr>` + rows.map(r=>`<tr><td>${r[0]}</td><td>${r[1]}</td></tr>`).join('');
  el.over.classList.add('show');
}

/* ======= End-condition poll (safety) ======= */
setInterval(endIfDeckDone, 1200);

/* ======= Header state ======= */
onSnapshot(gref, (snap)=>{
  if(!snap.exists()) return;
  const g = snap.data();
  el.startBtn.hidden = !(g.host===username && g.status==='lobby');
  el.hostBadge.hidden = !(g.host===username);
});
</script>
</body>
</html>


