<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Splinters ‚Äî Multiplayer (Mobile-Elevated Hand, Medals, Flip Timers, Effect Hints)</title>
<style>
  :root{
    --ink:#eaf2ff; --muted:#a7bfdc; --bg:#0a0e14; --pane:#0f1726; --edge:#1a2b46; --accent:#b91c1c; --accent-2:#7f1d1d;
    --h:48px; --scoresH:38px; --oppsH:46px; --handH:102px; --riverW:min(96vw,720px);
    --cardW: clamp(48px, 9vw, 66px); --cardH: calc(var(--cardW) * 1.33);
    --handBottomOffset: 0px;
  }
  @media (max-width: 760px){
    :root{ --handBottomOffset: 10vh; }
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:radial-gradient(1000px 700px at 60% -10%,#151f31 0%,#0a0e14 45%,#070a10 100%);color:var(--ink);font:600 12px/1.25 system-ui,Segoe UI,Inter,Roboto,Arial,sans-serif;overflow:hidden;-webkit-tap-highlight-color:transparent}
  button{appearance:none;border:1px solid #2b3f64;background:#132139;color:#eaf3ff;border-radius:10px;padding:6px 10px;font-weight:800;font-size:12px;cursor:pointer}
  button:active{transform:translateY(1px)}
  .top{position:fixed;inset:0 0 auto 0;height:var(--h);display:flex;align-items:center;justify-content:space-between;padding:6px 8px}
  .brand{display:flex;align-items:center;gap:8px}
  .logo{width:28px;height:28px;border-radius:8px;display:grid;place-items:center;background:#ffffff14;border:1px solid #ffffff22;font-size:16px}
  .title{font-weight:900;letter-spacing:.2px}
  .controls{display:flex;align-items:center;gap:6px}
  .badge{padding:3px 8px;border-radius:999px;background:#0f1a2b;border:1px solid #21365b;color:#cfe4ff;font-size:11px}
  .host{background:#192940;border-color:#2f4e7d}
  .leave{background:#260c0c;border-color:#4b1a1a}
  .ghost{background:#0d1728;border-color:#1b2b48}

  /* Scoreboard medals */
  .scoresBar{position:fixed;left:0;right:0;top:var(--h);height:var(--scoresH);display:flex;align-items:center;justify-content:center;padding:0 6px}
  .scores-inner{width:var(--riverW);display:flex;gap:6px;justify-content:center;overflow:auto;-webkit-overflow-scrolling:touch}
  .sc{display:flex;align-items:center;gap:6px;padding:3px 8px;border-radius:999px;border:1px solid #223a5f;background:#0f1a2b;white-space:nowrap;font-size:11px}
  .sc .dot{width:10px;height:10px;border-radius:50%}
  .m1{border-color:#e6c200;background:linear-gradient(180deg,#2b2500,#0f1200);color:#ffe680}
  .m1 .dot{background:#ffd700}
  .m2{border-color:#b6bcc6;background:linear-gradient(180deg,#1d2127,#0e1216);color:#e5e9f0}
  .m2 .dot{background:#c0c0c0}
  .m3{border-color:#b2732a;background:linear-gradient(180deg,#23160a,#0f0b07);color:#ffd9b3}
  .m3 .dot{background:#cd7f32}

  /* Opponents strip */
  .opps{position:fixed;left:0;right:0;top:calc(var(--h) + var(--scoresH));height:var(--oppsH);display:flex;align-items:center;justify-content:center;padding:0 6px}
  .opps-inner{width:var(--riverW);display:flex;gap:6px;justify-content:center;overflow:hidden}
  .opp{flex:1 1 0;min-width:0;border:1px solid var(--edge);background:#0e1626;border-radius:8px;padding:4px 6px;display:flex;align-items:center;gap:6px}
  .opp .name{font-weight:900;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .mini{display:flex;gap:3px;margin-left:auto}
  .mini i{width:14px;height:20px;border-radius:4px;background:#112036;border:1px solid #213a62;display:block}
  .revealMini{display:flex;gap:6px;margin-left:auto;font-size:11px;color:#dbe8ff;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .flag{font-size:12px;opacity:.9}
  .flag.sil{color:#fbbf24}
  .flag.shd{color:#60a5fa}

  /* Board / river */
  .main{position:absolute;inset:calc(var(--h) + var(--scoresH) + var(--oppsH)) 0 calc(env(safe-area-inset-bottom) + var(--handH) + var(--handBottomOffset) + 60px) 0;display:grid;place-items:center}
  .riverWrap{width:var(--riverW)}
  .river{display:grid;grid-template-columns:repeat(5,var(--cardW));grid-auto-rows:var(--cardH);gap:6px}
  .slot{width:var(--cardW);height:var(--cardH);border-radius:8px;border:1px solid var(--edge);background:#0f1a2a;display:grid;place-items:center;position:relative}
  .slot.empty{border-style:dashed;opacity:.6}
  .card{width:calc(100% - 6px);height:calc(100% - 6px);border-radius:8px;border:1px solid #1e2f52;background:#14243c;position:relative;overflow:hidden}
  .front,.back{position:absolute;inset:0;display:grid;place-items:start;padding:5px}
  .front .t{font-weight:900;font-size:11px}
  .front .f{font-size:10px;color:#cfe1ffcc}
  .sel{outline:3px solid var(--accent);outline-offset:2px}
  .frozen .slot{filter:grayscale(.2) contrast(.92);opacity:.88}
  .flipGlow .slot{box-shadow:0 0 0 2px #b91c1c99 inset}

  /* flip-back pattern */
  .back{
    background:
      linear-gradient(45deg, #1b2a45 25%, transparent 25%, transparent 75%, #1b2a45 75%),
      linear-gradient(45deg, #1b2a45 25%, transparent 25%, transparent 75%, #1b2a45 75%);
    background-size: 12px 12px; background-position: 0 0, 6px 6px; background-color:#0a1422;
  }

  /* Flip timer per river card */
  .timer{position:absolute;top:4px;right:4px;width:22px;height:22px;display:grid;place-items:center;pointer-events:none;opacity:.92;filter:drop-shadow(0 1px 2px rgba(0,0,0,.65))}
  .timer svg{width:22px;height:22px}
  .timer .track{fill:none;stroke:#243a5f;stroke-width:3}
  .timer .prog{fill:none;stroke:#ef4444;stroke-width:3;stroke-linecap:round}
  .timer .txt{position:absolute;font-size:9px;font-weight:900;color:#ffd7d7}

  /* Effect hint chips on card faces */
  .front .hints{margin-top:4px;display:flex;gap:4px;flex-wrap:wrap}
  .chipHint{
    display:inline-flex;align-items:center;gap:4px;padding:2px 6px;border-radius:999px;
    border:1px solid #2a426d;background:#12223d;color:#dbe7ff;font-size:10px;line-height:1;white-space:nowrap;
    max-width:100%;overflow:hidden;text-overflow:ellipsis
  }

  /* Suggestions / buttons above hand */
  .suggest{position:fixed;left:0;right:0;bottom:calc(var(--handH) + var(--handBottomOffset) + env(safe-area-inset-bottom) + 6px);display:grid;place-items:center}
  .suggest-inner{width:var(--riverW);display:grid;grid-template-rows:auto auto;gap:6px}
  .ready{display:flex;gap:6px;flex-wrap:wrap;justify-content:center}
  .pill{display:flex;align-items:center;gap:6px;border:1px solid #223a5f;background:#111e33;border-radius:999px;padding:4px 8px;font-size:11px;color:#dbe7ff}
  .need{opacity:.9}
  .playBtn{background:var(--accent);border-color:#5e1111;color:#fff;padding:4px 10px;border-radius:999px;font-size:11px;font-weight:900;letter-spacing:.3px}
  .playBtn:hover{filter:brightness(1.05)}
  .playBtn:active{background:var(--accent-2)}

  /* Hand (elevated on mobile) */
  .handWrap{position:fixed;left:0;right:0;bottom:var(--handBottomOffset);height:calc(var(--handH) + env(safe-area-inset-bottom));padding:6px 8px env(safe-area-inset-bottom)}
  .hand{height:100%;margin:0 auto;width:var(--riverW);border:1px solid var(--edge);background:#0f1a2a;border-radius:10px;padding:6px;display:flex;gap:6px;align-items:center;justify-content:center}
  .hslot{width:calc(var(--cardW) * 1.02);height:calc(var(--cardH) * 1.02);border:1px solid var(--edge);background:#0d1728;border-radius:8px;display:grid;place-items:center}
  .hslot.empty{opacity:.5;border-style:dashed}

  /* Winner modal */
  .overlay{position:fixed;inset:0;background:rgba(5,10,18,.86);display:none;align-items:center;justify-content:center;z-index:40}
  .overlay.show{display:flex}
  .modal{background:#0f1a2a;border:1px solid #1b2c48;border-radius:12px;width:min(92vw,420px);padding:12px;box-shadow:0 24px 60px rgba(0,0,0,.45)}
  .modal h2{margin:0 0 6px 0}
  .modal p{margin:0 0 6px 0;color:#cfe1ff}
  .table{width:100%;border-collapse:collapse;font-size:12px}
  .table td,.table th{border-bottom:1px solid #22385d;padding:6px;text-align:left}
  .table tr:last-child td{border-bottom:none}

  /* Target pickers */
  .pick{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(8,12,20,.84);z-index:45}
  .pick.show{display:flex}
  .pickBox{background:#0f1b2e;border:1px solid #1b2c48;border-radius:12px;width:min(94vw,520px);max-height:min(72vh,520px);overflow:auto;padding:10px}
  .pickBox h3{margin:0 0 8px 0;font-size:14px}
  .prow{border:1px solid #223a5f;background:#0d1727;border-radius:10px;padding:8px;margin:6px 0}
  .prow h4{margin:0 0 6px 0;font-size:12px;color:#cfe4ff}
  .pcards{display:flex;flex-wrap:wrap;gap:6px}
  .pbtn{font-size:11px;padding:5px 8px;border-radius:9px;border:1px solid #2a426d;background:#132242;color:#dbeaff;cursor:pointer}

  /* Toasts */
  .toasts{position:fixed;left:50%;transform:translateX(-50%);top:calc(var(--h) + 4px);display:flex;flex-direction:column;gap:6px;z-index:60;pointer-events:none}
  .toast{background:#0f1b2e;border:1px solid #203656;color:#e6efff;padding:6px 8px;border-radius:9px;box-shadow:0 8px 20px rgba(0,0,0,.35);opacity:0;transform:translateY(-6px);animation:tIn .22s ease-out forwards}
  @keyframes tIn{to{opacity:1;transform:translateY(0)}}
  .toast.out{animation:tOut .22s ease-in forwards}
  @keyframes tOut{to{opacity:0;transform:translateY(-6px)}}
</style>
</head>
<body>
  <div class="top">
    <div class="brand">
      <div class="logo">ü™Ñ</div>
      <div class="title">Splinters</div>
      <span class="badge" id="hostBadge" hidden>Host</span>
      <span class="badge" id="gameIdBadge"></span>
      <span class="badge" id="banBadge" hidden></span>
    </div>
    <div class="controls">
      <span class="badge" id="deckBadge">Deck: 0</span>
      <span class="badge" id="discardBadge">Discard: 0</span>
      <button class="host" id="startBtn" hidden>Deal & Start</button>
      <button class="ghost" id="fsBtn" title="Fullscreen">‚õ∂</button>
      <button class="leave" id="leaveBtn">Lobby</button>
    </div>
  </div>

  <!-- Scoreboard medals -->
  <div class="scoresBar"><div class="scores-inner" id="scores"></div></div>

  <!-- Opponents -->
  <div class="opps"><div class="opps-inner" id="opps"></div></div>

  <!-- Board -->
  <main class="main">
    <div class="riverWrap">
      <div class="river" id="river"></div>
    </div>
  </main>

  <!-- Suggestions -->
  <div class="suggest">
    <div class="suggest-inner">
      <div class="ready" id="ready"></div>
      <div class="ready" id="near"></div>
    </div>
  </div>

  <!-- Hand -->
  <div class="handWrap"><div class="hand" id="hand"></div></div>

  <!-- Winner -->
  <div class="overlay" id="over">
    <div class="modal">
      <h2 id="overTitle">Game Over</h2>
      <p id="overWhy"></p>
      <table class="table" id="overTable"></table>
      <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:8px">
        <button id="toLobbyBtn">Back to Lobby</button>
      </div>
    </div>
  </div>

  <!-- Target pickers -->
  <div class="pick" id="pick">
    <div class="pickBox">
      <h3 id="pickTitle">Pick a target</h3>
      <div id="pickBody"></div>
      <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:8px">
        <button id="pickCancel">Cancel</button>
      </div>
    </div>
  </div>

  <div class="toasts" id="toasts"></div>

<script type="module">
/* ======= Firebase ======= */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc, runTransaction, onSnapshot,
  serverTimestamp
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

/* ======= URL / Lobby ======= */
const qp = new URLSearchParams(location.search);
const gameId = qp.get('gameId') || '';
const username = (qp.get('username') || '').trim();
const LOBBY_URL = "/";

if (!gameId || !username) alert("Missing gameId or username in URL.");

const gref = doc(db, "games", gameId);
const uref = doc(db, "users", username);

/* ======= Cards & combos ======= */
const F = { Scholar:'Scholar', Weather:'Weather', Beast:'Beast', Tamer:'Tamer', Relic:'Relic' };
const CARDS = [
  {id:'SchLight',name:'Scholar of Light',fam:F.Scholar,emoji:'‚ú®',tier:2},
  {id:'SchStorm',name:'Scholar of Storms',fam:F.Scholar,emoji:'üå©Ô∏è',tier:2},
  {id:'SchBeast',name:'Scholar of Beasts',fam:F.Scholar,emoji:'üêæ',tier:2},
  {id:'SchStars',name:'Scholar of Stars',fam:F.Scholar,emoji:'üåå',tier:3},
  {id:'SchTime', name:'Scholar of Time', fam:F.Scholar,emoji:'‚è≥',tier:3},
  {id:'SchDark', name:'Scholar of Darkness', fam:F.Scholar,emoji:'üåë',tier:2},

  {id:'StormCloud',name:'Storm Cloud',fam:F.Weather,emoji:'‚òÅÔ∏è',tier:1},
  {id:'Lightning',name:'Lightning',fam:F.Weather,emoji:'‚ö°',tier:2},
  {id:'Sun', name:'Sun', fam:F.Weather,emoji:'‚òÄÔ∏è',tier:1},
  {id:'Rain',name:'Rain',fam:F.Weather,emoji:'üåßÔ∏è',tier:1},
  {id:'Blizzard',name:'Blizzard',fam:F.Weather,emoji:'‚ùÑÔ∏è',tier:2},
  {id:'Eclipse',name:'Eclipse',fam:F.Weather,emoji:'üåò',tier:3},

  {id:'SkySerpent',name:'Sky Serpent',fam:F.Beast,emoji:'üêç',tier:2},
  {id:'RockRhino',name:'Rock Rhino',fam:F.Beast,emoji:'ü¶è',tier:2},
  {id:'FireDrake',name:'Fire Drake',fam:F.Beast,emoji:'üêâ',tier:3},
  {id:'ShadowWolf',name:'Shadow Wolf',fam:F.Beast,emoji:'üê∫',tier:2},

  {id:'BeastMaster',name:'Beast Master',fam:F.Tamer,emoji:'üêæ‚öîÔ∏è',tier:2},
  {id:'DragonKnight',name:'Dragon Knight',fam:F.Tamer,emoji:'üêâ‚öîÔ∏è',tier:3},
  {id:'WolfTamer',name:'Wolf Tamer',fam:F.Tamer,emoji:'üê∫‚öîÔ∏è',tier:2},
  {id:'StormRider',name:'Storm Rider',fam:F.Tamer,emoji:'üå©Ô∏è‚öîÔ∏è',tier:2},

  {id:'SanctumOrb',name:'Sanctum Orb',fam:F.Relic,emoji:'üîÆ',tier:3},
  {id:'StormLance',name:'Storm Lance',fam:F.Relic,emoji:'‚öîÔ∏èüå©Ô∏è',tier:2},
  {id:'SunCrown',name:'Sun Crown',fam:F.Relic,emoji:'üëë‚òÄÔ∏è',tier:2},
  {id:'ShadowDagger',name:'Shadow Dagger',fam:F.Relic,emoji:'üó°Ô∏èüåë',tier:2},
  {id:'MirrorStars',name:'Mirror of Stars',fam:F.Relic,emoji:'ü™ûüåå',tier:3},
];
const byId = Object.fromEntries(CARDS.map(c=>[c.id,c]));
const NEED = {
  id:(id)=>({id,label:byId[id].name, test:c=>c.id===id}),
  fam:(fam)=>({fam,label:fam, test:c=>c.fam===fam}),
};
const COMBOS = [
  {key:'ThunderHeist', label:'Thunder Heist', pts:6, need:[NEED.id('Lightning'),NEED.id('StormCloud'),NEED.id('StormRider')], effect:'stealEach:1'},
  {key:'MidnightAssassination', label:'Midnight Assassination', pts:7, need:[NEED.id('ShadowDagger'),NEED.id('SchDark'),NEED.id('StormCloud')], effect:'destroyTarget:any'},
  {key:'StormShatter', label:'Storm Shatter', pts:6, need:[NEED.id('StormLance'),NEED.id('Lightning'),NEED.id('SchStorm')], effect:'destroyRelicEach'},
  {key:'Weatherlift', label:'Weatherlift', pts:6, need:[NEED.id('Rain'),NEED.id('StormCloud'),NEED.id('SchTime')], effect:'stealTarget:Weather'},
  {key:'SerpentsSpoils', label:'Serpent‚Äôs Spoils', pts:6, need:[NEED.id('SkySerpent'),NEED.id('SchBeast'),NEED.id('ShadowDagger')], effect:'stealTarget:Relic'},
  {key:'FrozenOracle', label:'Frozen Oracle', pts:6, need:[NEED.id('SanctumOrb'),NEED.id('Blizzard'),NEED.id('SchTime')], effect:'freeze:4000'},
  {key:'CrownCommand', label:'Crown Command', pts:5, need:[NEED.id('SunCrown'),NEED.id('Sun'),NEED.id('BeastMaster')], effect:'draw:1'},
  {key:'PackRaid', label:'Pack Raid', pts:6, need:[NEED.id('ShadowWolf'),NEED.id('BeastMaster'),NEED.id('WolfTamer')], effect:'stealTarget:Beast'},
  {key:'StarlitCopy', label:'Starlit Copy', pts:6, need:[NEED.id('SchStars'),NEED.id('MirrorStars'),NEED.id('SchTime')], effect:'duplicateTarget:any'},
  {key:'ScholarsGlint', label:'Scholars‚Äô Glint', pts:5, need:[NEED.id('SchLight'),NEED.id('SchStorm')], effect:'flip:2500'},
  {key:'TwilightEdict', label:'Twilight Edict', pts:5, need:[NEED.id('Eclipse'),NEED.id('SchDark')], effect:'revealOpp:3000'},

  {key:'AscendantTempest', label:'ASCENDANT TEMPEST', pts:42, need:[NEED.id('SchStorm'),NEED.id('Lightning'),NEED.id('StormCloud'),NEED.id('StormRider'),NEED.id('Eclipse')], effect:'legend:tempest'},
  {key:'RelicsUnleashed', label:'RELICS UNLEASHED', pts:34, need:[NEED.id('SanctumOrb'),NEED.id('MirrorStars'),NEED.id('StormLance'),NEED.id('SunCrown')], effect:'legend:relics'},
  {key:'ScholarsCouncil', label:'SCHOLARS COUNCIL', pts:28, need:[NEED.id('SchLight'),NEED.id('SchDark'),NEED.id('SchStars'),NEED.id('SchTime')], effect:'legend:council'},
  {key:'BeastDominion', label:'BEAST DOMINION', pts:30, need:[NEED.id('BeastMaster'),NEED.id('WolfTamer'),NEED.id('SkySerpent'),NEED.id('ShadowWolf')], effect:'legend:beast'},

  {key:'Cloudburst', label:'Cloudburst', pts:7, need:[NEED.id('StormCloud'),NEED.id('Rain'),NEED.id('Lightning')], effect:'refreshColumn'},
  {key:'SolarCoronation', label:'Solar Coronation', pts:12, need:[NEED.id('SunCrown'),NEED.id('Sun'),NEED.id('SchLight')], effect:'shieldSelf:4000'},
  {key:'RhinoStudy', label:'Rhino Study', pts:9, need:[NEED.id('RockRhino'),NEED.id('SchBeast'),NEED.id('BeastMaster')], effect:'draw:1'},
  {key:'TimeAndStars', label:'Time & Stars', pts:16, need:[NEED.id('SchTime'),NEED.id('SchStars'),NEED.id('SanctumOrb')], effect:'scry3'},
  {key:'WeatherSet', label:'Weather Set', pts:20, need:[NEED.id('Rain'),NEED.id('Sun'),NEED.id('Blizzard'),NEED.id('Lightning')], effect:'refreshRow:top'},
  {key:'Skychain', label:'Skychain', pts:17, need:[NEED.id('SkySerpent'),NEED.id('BeastMaster'),NEED.id('Lightning')], effect:'swapRiver'},
  {key:'ScholarTriad', label:'Scholar Triad', pts:18, need:[NEED.id('SchLight'),NEED.id('SchStorm'),NEED.id('SchBeast')], effect:'revealOpp:2000'},

  {key:'BeastTrio', label:'Beast Trio', pts:12, need:[NEED.fam(F.Beast), NEED.fam(F.Beast), NEED.fam(F.Beast)], effect:'banFam:Weather:4000'},
  {key:'BeastHorde', label:'Beast Horde', pts:18, need:[NEED.fam(F.Beast), NEED.fam(F.Beast), NEED.fam(F.Beast), NEED.fam(F.Beast)], effect:'refreshRow:bottom'},
  {key:'ScholarAssembly', label:'Scholar Assembly', pts:16, need:[NEED.fam(F.Scholar), NEED.fam(F.Scholar), NEED.fam(F.Scholar)], effect:'pullRelics:1'},
  {key:'ScholarConclave', label:'Scholar Conclave', pts:22, need:[NEED.fam(F.Scholar), NEED.fam(F.Scholar), NEED.fam(F.Scholar), NEED.fam(F.Scholar)], effect:'shieldSelf:5000'},
  {key:'RelicSet', label:'Relic Set', pts:14, need:[NEED.fam(F.Relic), NEED.fam(F.Relic), NEED.fam(F.Relic)], effect:'pullRelics:2'},
  {key:'TamerLine', label:'Tamer Line', pts:13, need:[NEED.fam(F.Tamer), NEED.fam(F.Tamer), NEED.fam(F.Tamer)], effect:'tradeRandom'},
  {key:'WeatherParade', label:'Weather Parade', pts:10, need:[NEED.fam(F.Weather), NEED.fam(F.Weather), NEED.fam(F.Weather)], effect:'refreshColumn'},
  {key:'NightSilence', label:'Night Silence', pts:9, need:[NEED.id('ShadowDagger'),NEED.id('SchDark'),NEED.id('Eclipse')], effect:'silenceTarget:5000'},
  {key:'BeastCulling', label:'Beast Culling', pts:10, need:[NEED.id('ShadowWolf'),NEED.id('SkySerpent'),NEED.id('WolfTamer')], effect:'discardNonBeastEach:1'}
];
const COMBO_BY_KEY = Object.fromEntries(COMBOS.map(c=>[c.key,c]));
const byIdMap = byId;
const makeUID = ()=> Math.random().toString(36).slice(2);

/* ======= DOM refs ======= */
const el = {
  river: document.getElementById('river'),
  hand: document.getElementById('hand'),
  opps: document.getElementById('opps'),
  scores: document.getElementById('scores'),
  ready: document.getElementById('ready'),
  near: document.getElementById('near'),
  deckBadge: document.getElementById('deckBadge'),
  discardBadge: document.getElementById('discardBadge'),
  startBtn: document.getElementById('startBtn'),
  hostBadge: document.getElementById('hostBadge'),
  gameIdBadge: document.getElementById('gameIdBadge'),
  banBadge: document.getElementById('banBadge'),
  fsBtn: document.getElementById('fsBtn'),
  leaveBtn: document.getElementById('leaveBtn'),
  toLobbyBtn: document.getElementById('toLobbyBtn'),
  over: document.getElementById('over'),
  overTitle: document.getElementById('overTitle'),
  overWhy: document.getElementById('overWhy'),
  overTable: document.getElementById('overTable'),
  pick: document.getElementById('pick'),
  pickTitle: document.getElementById('pickTitle'),
  pickBody: document.getElementById('pickBody'),
  pickCancel: document.getElementById('pickCancel'),
  toasts: document.getElementById('toasts'),
};
el.gameIdBadge.textContent = `ID: ${gameId.slice(0,6)}`;

/* ======= Effect hints on cards ======= */
const EFFECT_ICONS = {
  steal: 'ü´¥', destroy: 'üí•', freeze: 'üßä', flip:'üîÅ', reveal:'üëÅÔ∏è',
  draw:'‚ûï', duplicate:'ü™û', shield:'üõ°Ô∏è', scry:'üîÆ', refresh:'‚ôªÔ∏è',
  swap:'üîÄ', ban:'üö´', trade:'üîÅ', silence:'ü§ê', cull:'ü™ì', points:'‚≠ê'
};
function shortEffectForCombo(combo){
  const e = combo.effect || '';
  if (!e) return `${EFFECT_ICONS.points} +${combo.pts}`;
  if (e.startsWith('stealEach'))       return `${EFFECT_ICONS.steal} Steal 1 each`;
  if (e.startsWith('stealTarget:'))    return `${EFFECT_ICONS.steal} Steal ${e.split(':')[1]}`;
  if (e.startsWith('duplicateTarget')) return `${EFFECT_ICONS.duplicate} Duplicate any`;
  if (e.startsWith('destroyTarget'))   return `${EFFECT_ICONS.destroy} Destroy any`;
  if (e.startsWith('freeze:'))         return `${EFFECT_ICONS.freeze} Freeze ${Math.round((+e.split(':')[1]||0)/1000)}s`;
  if (e.startsWith('flip:'))           return `${EFFECT_ICONS.flip} Flip ${Math.round((+e.split(':')[1]||0)/1000)}s`;
  if (e.startsWith('revealOpp:'))      return `${EFFECT_ICONS.reveal} Reveal ${Math.round((+e.split(':')[1]||0)/1000)}s`;
  if (e.startsWith('draw:'))           return `${EFFECT_ICONS.draw} Draw ${e.split(':')[1]}`;
  if (e==='refreshColumn')             return `${EFFECT_ICONS.refresh} Refresh column`;
  if (e==='swapRiver')                 return `${EFFECT_ICONS.swap} Swap two center`;
  if (e.startsWith('refreshRow:'))     return `${EFFECT_ICONS.refresh} Refresh ${e.endsWith('top')?'top':'bottom'} row`;
  if (e.startsWith('shieldSelf:'))     return `${EFFECT_ICONS.shield} Shield ${Math.round((+e.split(':')[1]||0)/1000)}s`;
  if (e==='scry3')                     return `${EFFECT_ICONS.scry} Scry 3`;
  if (e.startsWith('banFam:'))         return `${EFFECT_ICONS.ban} Ban ${e.split(':')[1]} ${Math.round((+e.split(':')[2]||0)/1000)}s`;
  if (e.startsWith('tradeRandom'))     return `${EFFECT_ICONS.trade} Trade random`;
  if (e.startsWith('silenceTarget:'))  return `${EFFECT_ICONS.silence} Silence ${Math.round((+e.split(':')[1]||0)/1000)}s`;
  if (e==='discardNonBeastEach:1')     return `${EFFECT_ICONS.cull} Foes discard non-Beast`;
  if (e.startsWith('legend:'))         return `üåü Legend`;
  return `${EFFECT_ICONS.points} +${combo.pts}`;
}
/* Build per-card hint list (top 2 chips) */
const CARD_HINTS = new Map();
function hintScore(cmb, isIdExact){
  const effectful = cmb.effect ? 1 : 0;
  return (isIdExact? 200 : 0) + (effectful? 100 : 0) + (cmb.pts||0);
}
for (const c of CARDS){
  const hints = [];
  for (const cmb of COMBOS){
    for (const need of cmb.need){
      const exact = !!need.id && need.id===c.id;
      const famOk = !!need.fam && need.fam===c.fam;
      if (!exact && !famOk) continue;
      hints.push({combo:cmb, exact, score:hintScore(cmb, exact)});
      break;
    }
  }
  hints.sort((a,b)=> b.score - a.score);
  const out = [];
  const seen = new Set();
  for (const h of hints){
    const blurb = shortEffectForCombo(h.combo);
    if (seen.has(blurb)) continue;
    seen.add(blurb);
    out.push({label: blurb, title: `${h.combo.label} (+${h.combo.pts})`});
    if (out.length>=2) break;
  }
  CARD_HINTS.set(c.id, out);
}

/* ======= Helpers ======= */
function miniHand(count){ return `<div class="mini">${Array.from({length:Math.min(5,count)},()=>'<i></i>').join('')}</div>`; }
function buildDeck(){
  const freq = { Scholar:3, Weather:4, Beast:3, Tamer:3, Relic:3 };
  const deck=[];
  for(const c of CARDS){ const n=freq[c.fam]??2; for(let i=0;i<n;i++) deck.push(c.id); }
  for(let i=0;i<8;i++){ deck.push(CARDS[(Math.random()*CARDS.length)|0].id); }
  for(let i=deck.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [deck[i],deck[j]]=[deck[j],deck[i]]; }
  return deck;
}
const now = ()=> Date.now();

/* ======= Local reveal timers (per river slot) ======= */
const localRevealUntil = Array(10).fill(0);
const localRevealStart = Array(10).fill(0);
const localRevealDur   = Array(10).fill(0);
let   localFlipHighlightUntil = 0;
const prevRiverUids = Array(10).fill(null);

/* ======= Suggestions ======= */
function findReadyCombos(handIds){
  const hand = handIds.map(id=>byIdMap[id]);
  const out=[];
  for(const combo of COMBOS){
    const used = new Array(hand.length).fill(false);
    const take = [];
    for(const req of combo.need){
      let idx=-1;
      for(let i=0;i<hand.length;i++){
        if(used[i]) continue;
        if(req.test(hand[i])){ idx=i; break; }
      }
      if(idx<0){ take.length=0; break; }
      used[idx]=true; take.push(idx);
    }
    if(take.length){ out.push({combo,indexes:take}); }
  }
  out.sort((a,b)=> (b.combo.pts + (b.combo.effect?2:0)) - (a.combo.pts + (a.combo.effect?2:0)));
  return out.slice(0,3);
}
function famIcon(fam){
  return fam==='Scholar'?'üìò':fam==='Beast'?'üêæ':fam==='Relic'?'üóùÔ∏è':fam==='Tamer'?'‚öîÔ∏è':fam==='Weather'?'‚õÖ':'‚ùì';
}
function findNearCombosDetailed(handIds, limitMissing=2){
  const hand = handIds.map(id=>byIdMap[id]);
  const res=[];
  for(const combo of COMBOS){
    const used = new Array(hand.length).fill(false);
    const missing=[];
    for(const req of combo.need){
      let ok=-1;
      for(let i=0;i<hand.length;i++){
        if(used[i]) continue;
        if(req.test(hand[i])){ ok=i; break; }
      }
      if(ok>=0) used[ok]=true; else missing.push(req);
    }
    if(missing.length>0 && missing.length<=limitMissing){
      res.push({combo, missing});
    }
  }
  res.sort((a,b)=> (a.missing.length - b.missing.length) || ((b.combo.pts||0) - (a.combo.pts||0)));
  return res.slice(0,3);
}

/* ======= Game bootstrap ======= */
async function ensureGameAndSeat(){
  await runTransaction(db, async(tx)=>{
    const snap = await tx.get(gref);
    if (!snap.exists()){
      const deck = buildDeck();
      const base = {
        createdAt: serverTimestamp(),
        host: username,
        status: "lobby",
        players: [username],
        deck, discard: [],
        river: Array.from({length:10}, ()=>({uid:null, id:null})),
        hands: {[username]: []},
        points: {[username]: 0},
        combos: {[username]: 0},
        winners: [],
        freezeUntil: 0,
        revealOppUntil: 0,
        shields: {}, silenced: {}, ban: null,
        events: [],
        lastMoveAt: now()
      };
      tx.set(gref, base);
      return;
    }
    const g = snap.data();
    const players = Array.isArray(g.players) ? g.players.slice() : [];
    if (!players.includes(username)) players.push(username);
    const hands = Object.assign({}, g.hands);
    if (!hands[username]) hands[username] = [];
    const points = Object.assign({}, g.points); if(points[username]===undefined) points[username]=0;
    const combos = Object.assign({}, g.combos); if(combos[username]===undefined) combos[username]=0;
    tx.update(gref, { players, hands, points, combos, host: g.host || username,
      shields: g.shields || {}, silenced: g.silenced || {}, ban: g.ban || null });
  });
}
await ensureGameAndSeat();

/* ======= Host: deal & start ======= */
async function hostDealAndStart(){
  await runTransaction(db, async(tx)=>{
    const snap = await tx.get(gref);
    if (!snap.exists()) throw new Error("Missing game");
    const g = snap.data();
    if (g.host !== username) return;
    const deck = buildDeck();
    const river = Array.from({length:10}, ()=>({uid: makeUID(), id: deck.pop() || null}));
    const hands = {};
    for(const p of g.players){
      hands[p] = [];
      for(let i=0;i<5;i++){ const id = deck.pop(); if(id) hands[p].push({uid:makeUID(), id}); }
    }
    const points={}, combos={}; g.players.forEach(p=>{ points[p]=0; combos[p]=0; });
    tx.update(gref, {
      status:"active", deck, river, hands, points, combos,
      discard: [], winners: [],
      freezeUntil: 0, revealOppUntil: 0, shields:{}, silenced:{}, ban:null,
      events: (g.events||[]).concat([{ts:now(), text:`${username} started the game.`},{ts:now(), type:'revealCenter', ms:5000, text:'Cards revealed.'}]).slice(-20),
      lastMoveAt: now()
    });
  });
}

/* ======= Interactions ======= */
let sel = {zone:null, idx:null};
let tapLock = 0;
const lockShort = ()=> (tapLock = now() + 220);
const canTap = ()=> now() > tapLock;

function youAreSilenced(g){ const s = g.silenced||{}; const until = s[username]||0; return now() < until; }
function famBanned(g, cardId){ const ban = g.ban; if (!ban) return false; if (now() >= (ban.until||0)) return false; return byIdMap[cardId].fam === ban.fam; }

async function pickFromRiver(rIdx){
  if (!canTap()) return; lockShort();
  await runTransaction(db, async(tx)=>{
    const snap = await tx.get(gref); if(!snap.exists()) return;
    const g = snap.data(); if(g.status!=='active') return;
    if (now() < (g.freezeUntil||0)) return;
    if (youAreSilenced(g)) { pushEvent(g, {ts:now(), text:`${username} is silenced.`}); tx.update(gref, g); return; }

    const r = (g.river||[])[rIdx]; if(!r || !r.id) return;
    if (famBanned(g, r.id)) { pushEvent(g, {ts:now(), text:`Ban active ‚Äî cannot take ${byIdMap[r.id].fam}.`}); tx.update(gref, g); return; }

    const my = (g.hands?.[username]||[]).slice(); if(my.length>=5) return;

    const deck = (g.deck||[]).slice(); const discard = (g.discard||[]).slice();

    my.push({uid:makeUID(), id:r.id});
    const nextId = deck.pop() || null;
    g.river[rIdx] = {uid: nextId ? makeUID() : null, id: nextId};

    const hands = Object.assign({}, g.hands, {[username]: my});
    const events = (g.events||[]).concat([{ts:now(), text:`${username} drew from center.`}]).slice(-20);
    tx.update(gref, {hands, river:g.river, deck, discard, events, lastMoveAt: now()});
  });
}

async function swapHandRiver(hIdx, rIdx){
  if (!canTap()) return; lockShort();
  await runTransaction(db, async(tx)=>{
    const snap = await tx.get(gref); if(!snap.exists()) return;
    const g = snap.data(); if(g.status!=='active') return;
    if (now() < (g.freezeUntil||0)) return;
    if (youAreSilenced(g)) { pushEvent(g, {ts:now(), text:`${username} is silenced.`}); tx.update(gref, g); return; }

    const my = (g.hands?.[username]||[]).slice(); if(!my[hIdx]) return;
    const r = (g.river||[])[rIdx]; if(!r || !r.id) return;
    if (famBanned(g, r.id)) { pushEvent(g, {ts:now(), text:`Ban active ‚Äî cannot take ${byIdMap[r.id].fam}.`}); tx.update(gref, g); return; }

    const myCard = my[hIdx], riverCard = r;
    my[hIdx] = {uid: makeUID(), id: riverCard.id};
    g.river[rIdx] = {uid: makeUID(), id: myCard.id};

    const hands = Object.assign({}, g.hands, {[username]: my});
    const events = (g.events||[]).concat([{ts:now(), text:`${username} swapped with center.`}]).slice(-20);
    tx.update(gref, {hands, river:g.river, events, lastMoveAt: now()});
  });
}

/* ======= Effects (helpers) ======= */
function pushEvent(g, e){ g.events = (g.events||[]).concat([e]).slice(-20); }
function oppList(g, exclude){ return (g.players||[]).filter(p=>p!==exclude); }
function pushToHandOrDiscard(g, player, cardId){
  const hand = (g.hands[player]||[]);
  if (hand.length < 5) hand.push({uid:makeUID(), id:cardId});
  else (g.discard||=(g.discard||[])).push(cardId);
}
function removeRandomFromHand(g, player){
  const h = (g.hands[player]||[]);
  if(!h.length) return null;
  const i = Math.floor(Math.random()*h.length);
  return h.splice(i,1)[0];
}
function removeFirstFam(g, player, fam){
  const h = (g.hands[player]||[]);
  const idx = h.findIndex(x=>byIdMap[x.id].fam===fam);
  if (idx>=0) return h.splice(idx,1)[0];
  return null;
}
function refreshIndex(g, idx){
  const deck = g.deck||[];
  if (g.river[idx]?.id) (g.discard||=(g.discard||[])).push(g.river[idx].id);
  const next = deck.pop() || null;
  g.river[idx] = {uid: next ? makeUID() : null, id: next};
}
function refreshColumn(g, col){
  const a = col, b = col+5;
  if (a>=0 && a<5) refreshIndex(g, a);
  if (b>=5 && b<10) refreshIndex(g, b);
}
function refreshRow(g, row){ if (row==='top'){ for(let i=0;i<5;i++) refreshIndex(g,i); } else { for(let i=5;i<10;i++) refreshIndex(g,i); } }
function swapTwoRiver(g){
  const filled = (g.river||[]).map((s,i)=>s?.id?i:null).filter(i=>i!==null);
  if (filled.length<2) return;
  const a = filled[(Math.random()*filled.length)|0], b = filled[(Math.random()*filled.length)|0];
  if (a===b) return;
  const ra = g.river[a], rb = g.river[b];
  g.river[a] = {uid: makeUID(), id: rb.id};
  g.river[b] = {uid: makeUID(), id: ra.id};
}

function effectNeedsTarget(effect){
  if (!effect) return null;
  if (effect.startsWith('stealTarget:'))     return {kind:'steal', fam:effect.split(':')[1]};
  if (effect.startsWith('duplicateTarget:')) return {kind:'duplicate', fam:effect.split(':')[1]};
  if (effect.startsWith('destroyTarget:'))   return {kind:'destroy', fam:effect.split(':')[1]};
  if (effect.startsWith('silenceTarget:'))   return {kind:'silence', ms: Number(effect.split(':')[1]||'4000') };
  if (effect==='tradeRandom')                return {kind:'trade'};
  return null;
}
function famMatch(fam, id){ return fam==='any' ? true : byIdMap[id].fam===fam; }
function targetShielded(g, player){ const t=(g.shields||{})[player]||0; return now()<t; }

function applyNonTargetEffect(g, who, comboKey){
  switch(comboKey){
    case 'ThunderHeist': { for(const opp of oppList(g, who)){ const got = removeRandomFromHand(g, opp); if (got) pushToHandOrDiscard(g, who, got.id); } pushEvent(g, {ts:now(), text:`${who} plucked 1 from each opponent.`}); } break;
    case 'StormShatter': { for(const opp of oppList(g, who)){ const d = removeFirstFam(g, opp, F.Relic); if (d) (g.discard||=(g.discard||[])).push(d.id); } pushEvent(g, {ts:now(), text:`${who} shattered opponents‚Äô relics.`}); } break;
    case 'FrozenOracle': { g.freezeUntil = now() + 4000; pushEvent(g, {ts:now(), text:`${who} froze the river (4s).`}); } break;
    case 'CrownCommand': { const deck = g.deck||[]; if (deck.length){ const id = deck.pop(); pushToHandOrDiscard(g, who, id); pushEvent(g, {ts:now(), text:`${who} drew a bonus card.`}); } } break;
    case 'ScholarsGlint': { pushEvent(g, {ts:now(), type:'revealCenter', ms:2500, text:`${who} flashed the center.`}); } break;
    case 'TwilightEdict': { g.revealOppUntil = now() + 3000; pushEvent(g, {ts:now(), text:`${who} revealed opponents‚Äô hands (3s).`}); } break;

    case 'AscendantTempest': {
      g.revealOppUntil = now()+4000;
      for(const opp of oppList(g, who)){
        for(let k=0;k<2;k++){ const got = removeRandomFromHand(g, opp); if (got) pushToHandOrDiscard(g, who, got.id); }
        const d = removeRandomFromHand(g, opp); if (d) (g.discard||=(g.discard||[])).push(d.id);
      }
      pushEvent(g, {ts:now(), text:`${who} unleashed ASCENDANT TEMPEST!`});
    } break;
    case 'RelicsUnleashed': {
      for(const opp of oppList(g, who)){ const d = removeFirstFam(g, opp, F.Relic); if (d) (g.discard||=(g.discard||[])).push(d.id); }
      const deck = g.deck||[]; if (deck.length){ pushToHandOrDiscard(g, who, deck.pop()); }
      pushEvent(g, {ts:now(), text:`${who} unleashed RELICS!`});
    } break;
    case 'ScholarsCouncil': { g.freezeUntil = now()+3000; pushEvent(g, {ts:now(), text:`${who} convened COUNCIL (river frozen 3s).`}); } break;
    case 'BeastDominion': {
      const deck = g.deck||[]; if (deck.length) pushToHandOrDiscard(g, who, deck.pop()); if (deck.length) pushToHandOrDiscard(g, who, deck.pop());
      for(const opp of oppList(g, who)){ const d = removeRandomFromHand(g, opp); if (d) (g.discard||=(g.discard||[])).push(d.id); }
      pushEvent(g, {ts:now(), text:`${who} proclaimed BEAST DOMINION!`});
    } break;

    case 'Cloudburst': { const col = (Math.random()*5)|0; refreshColumn(g, col); pushEvent(g, {ts:now(), text:`${who} refreshed a column.`}); } break;
    case 'SolarCoronation': { g.shields = Object.assign({}, g.shields, {[who]: now()+4000}); pushEvent(g, {ts:now(), text:`${who} gained a Shield (4s).`}); } break;
    case 'RhinoStudy': { const deck = g.deck||[]; if (deck.length){ pushToHandOrDiscard(g, who, deck.pop()); pushEvent(g,{ts:now(), text:`${who} drew 1.`}); } } break;
    case 'TimeAndStars': {
      const deck = g.deck||[]; if (deck.length){
        const tri = [deck.pop(), deck.pop(), deck.pop()].filter(Boolean);
        if (tri.length){ tri.sort((a,b)=> byIdMap[b].tier - byIdMap[a].tier); const keep = tri.shift(); pushToHandOrDiscard(g, who, keep); while(tri.length) deck.push(tri.pop()); pushEvent(g, {ts:now(), text:`${who} scried the deck (kept best).`}); pushEvent(g, {ts:now(), type:'revealCenter', ms:1500, text:`Scry shimmer`}); }
      }
    } break;
    case 'WeatherSet': { refreshRow(g, 'top'); pushEvent(g, {ts:now(), text:`${who} refreshed the top row.`}); } break;
    case 'Skychain': { swapTwoRiver(g); pushEvent(g, {ts:now(), text:`${who} twisted the river.`}); } break;
    case 'ScholarTriad': { g.revealOppUntil = Math.max(now()+2000, g.revealOppUntil||0); pushEvent(g, {ts:now(), text:`${who} gleaned insights (reveal 2s).`}); } break;

    case 'BeastTrio': { g.ban = {fam:F.Weather, until: now()+4000}; pushEvent(g, {ts:now(), text:`${who} howled ‚Äî Weather banned 4s.`}); } break;
    case 'BeastHorde': { refreshRow(g, 'bottom'); pushEvent(g, {ts:now(), text:`${who} surged beasts ‚Äî bottom row refreshed.`}); } break;
    case 'ScholarAssembly': { let need=1; const disc=g.discard||[]; const keep=[]; for(let i=disc.length-1;i>=0 && need>0;i--){ if(byIdMap[disc[i]].fam===F.Relic){ keep.push(disc.splice(i,1)[0]); need--; } } keep.forEach(id=>pushToHandOrDiscard(g, who, id)); pushEvent(g, {ts:now(), text:`${who} reclaimed a relic from discard.`}); } break;
    case 'ScholarConclave': { g.shields = Object.assign({}, g.shields, {[who]: now()+5000}); pushEvent(g, {ts:now(), text:`${who} conjured a Shield (5s).`}); } break;
    case 'RelicSet': { let need=2; const disc=g.discard||[]; const keep=[]; for(let i=disc.length-1;i>=0 && need>0;i--){ if(byIdMap[disc[i]].fam===F.Relic){ keep.push(disc.splice(i,1)[0]); need--; } } keep.forEach(id=>pushToHandOrDiscard(g, who, id)); pushEvent(g, {ts:now(), text:`${who} reclaimed relics.`}); } break;
    case 'WeatherParade': { const col = (Math.random()*5)|0; refreshColumn(g,col); pushEvent(g, {ts:now(), text:`${who} stirred the skies ‚Äî column refreshed.`}); } break;
    case 'BeastCulling': { for(const opp of oppList(g, who)){ const h = (g.hands[opp]||[]); let idx = h.findIndex(x=>byIdMap[x.id].fam!==F.Beast); if (idx<0 && h.length) idx = (Math.random()*h.length)|0; if (idx>=0){ const [c]=h.splice(idx,1); (g.discard||=(g.discard||[])).push(c.id); } } pushEvent(g, {ts:now(), text:`${who} culled non-beasts from foes.`}); } break;
  }
}

/* ======= Play combo ======= */
async function playCombo(comboKey, useUids, targetInfo){
  await runTransaction(db, async(tx)=>{
    const snap = await tx.get(gref); if(!snap.exists()) return;
    const g = snap.data(); if(g.status!=='active') return;

    const my = (g.hands?.[username]||[]).slice();
    const haveAll = useUids.every(uid => my.some(x=>x.uid===uid));
    if (!haveAll) return;

    for(const uid of useUids){ const idx = my.findIndex(x=>x.uid===uid); if (idx>=0) my.splice(idx,1); }

    const combo = COMBO_BY_KEY[comboKey];
    const points = Object.assign({}, g.points);
    const combos = Object.assign({}, g.combos);
    points[username] = (points[username]||0) + (combo.pts||0);
    combos[username] = (combos[username]||0) + 1;

    const needs = effectNeedsTarget(combo.effect);
    if (needs){
      if (needs.kind==='trade'){
        const target = targetInfo && targetInfo.opp; if (!target) return;
        if (targetShielded(g, target)){ pushEvent(g,{ts:now(), text:`${target} blocked trade (Shield).`}); }
        else{
          const a = removeRandomFromHand(g, username);
          const b = removeRandomFromHand(g, target);
          if (a) (g.hands[target]||[]).push({uid:makeUID(), id:a.id});
          if (b) (g.hands[username]||[]).push({uid:makeUID(), id:b.id});
          pushEvent(g, {ts:now(), text:`${username} traded a random card with ${target}.`});
        }
      } else if (needs.kind==='silence'){
        const target = targetInfo && targetInfo.opp; if (!target) return;
        g.silenced = Object.assign({}, g.silenced, {[target]: now() + (needs.ms||4000)});
        pushEvent(g, {ts:now(), text:`${username} silenced ${target} (${Math.round((needs.ms||4000)/1000)}s).`});
      } else {
        const target = targetInfo && targetInfo.opp;
        const oppH = (g.hands?.[target]||[]);
        const tIdx = oppH.findIndex(x=>x.uid===targetInfo.cardUid);
        if (tIdx<0) return;
        if (targetShielded(g, target)){ pushEvent(g,{ts:now(), text:`${target} blocked the effect (Shield).`}); }
        else{
          const picked = oppH.splice(tIdx,1)[0];
          if (needs.kind==='steal'){
            pushToHandOrDiscard(g, username, picked.id);
            pushEvent(g, {ts:now(), text:`${username} stole ${byIdMap[picked.id].emoji} ${byIdMap[picked.id].name} from ${target}.`});
          } else if (needs.kind==='duplicate'){
            oppH.splice(tIdx,0,picked);
            pushToHandOrDiscard(g, username, picked.id);
            pushEvent(g, {ts:now(), text:`${username} duplicated ${byIdMap[picked.id].emoji} ${byIdMap[picked.id].name} from ${target}.`});
          } else if (needs.kind==='destroy'){
            (g.discard||=(g.discard||[])).push(picked.id);
            pushEvent(g, {ts:now(), text:`${username} destroyed ${byIdMap[picked.id].emoji} ${byIdMap[picked.id].name} from ${target}.`});
          }
        }
      }
    } else {
      applyNonTargetEffect(g, username, comboKey);
      pushEvent(g, {ts:now(), text:`${username} played ${combo.label} (+${combo.pts||0}).`});
    }

    const hands = Object.assign({}, g.hands, {[username]: my});
    tx.update(gref, {
      hands, points, combos,
      river: g.river, deck: g.deck, discard: g.discard,
      freezeUntil: g.freezeUntil||0, revealOppUntil: g.revealOppUntil||0,
      shields: g.shields||{}, silenced: g.silenced||{}, ban: g.ban||null,
      events: g.events, lastMoveAt: now()
    });
  });
  await endIfDeckDone();
}

/* ======= Target pickers ======= */
function openTargetCardPicker(game, combo, useUids, needs){
  const picker = el.pick, title = el.pickTitle, body = el.pickBody;
  title.textContent = `Choose a target ‚Äî ${combo.label}`;
  body.innerHTML = '';
  const players = (game.players||[]).filter(p=>p!==username);
  for (const p of players){
    const row = document.createElement('div'); row.className='prow';
    row.innerHTML = `<h4>${p} ${targetShielded(game,p)?' <span class="flag shd">üõ°Ô∏è</span>':''}</h4>`;
    const cardsDiv = document.createElement('div'); cardsDiv.className='pcards';
    const hand = (game.hands?.[p]||[]);
    let any=false;
    for(const c of hand){
      if (needs.fam!=='any' && !famMatch(needs.fam, c.id)) continue;
      any=true;
      const btn = document.createElement('button'); btn.className='pbtn';
      btn.textContent = `${byIdMap[c.id].emoji} ${byIdMap[c.id].name}`;
      btn.addEventListener('click', async ()=>{
        picker.classList.remove('show');
        await playCombo(combo.key, useUids, {opp:p, cardUid:c.uid});
      });
      cardsDiv.appendChild(btn);
    }
    if(!any){ const none=document.createElement('div'); none.style.opacity='.75'; none.style.fontSize='12px'; none.textContent='No valid cards.'; cardsDiv.appendChild(none); }
    row.appendChild(cardsDiv); body.appendChild(row);
  }
  picker.classList.add('show');
}
function openTargetPlayerPicker(game, combo, useUids, titleText){
  const picker = el.pick, title = el.pickTitle, body = el.pickBody;
  title.textContent = titleText || `Choose a player`;
  body.innerHTML = '';
  const players = (game.players||[]).filter(p=>p!==username);
  const row = document.createElement('div'); row.className='prow';
  const cardsDiv = document.createElement('div'); cardsDiv.className='pcards';
  players.forEach(p=>{
    const btn = document.createElement('button'); btn.className='pbtn';
    const flags = `${(game.silenced?.[p]&&now()<game.silenced[p])?'ü§ê ':''}${targetShielded(game,p)?'üõ°Ô∏è ':''}`;
    btn.textContent = `${flags}${p}`;
    btn.addEventListener('click', async ()=>{
      picker.classList.remove('show');
      await playCombo(combo.key, useUids, {opp:p});
    });
    cardsDiv.appendChild(btn);
  });
  row.appendChild(cardsDiv); body.appendChild(row);
  picker.classList.add('show');
}
el.pickCancel.addEventListener('click', ()=> el.pick.classList.remove('show'));

/* ======= Rendering ======= */
function cardFrontHTML(id){
  const c = byIdMap[id];
  const hints = CARD_HINTS.get(id) || [];
  const chips = hints.map(h=>`<span class="chipHint" title="${h.title}">${h.label}</span>`).join('');
  return `
    <div class="front">
      <div class="t">${c.emoji} ${c.name}</div>
      <div class="f">${c.fam} ‚Ä¢ Tier ${c.tier}</div>
      ${chips ? `<div class="hints">${chips}</div>` : ''}
    </div>
  `;
}
function cardBackHTML(){ return `<div class="back"></div>`; }
function timerHTML(){ return `
  <div class="timer" aria-hidden="true">
    <svg viewBox="0 0 36 36" focusable="false">
      <circle class="track" cx="18" cy="18" r="15"></circle>
      <circle class="prog" cx="18" cy="18" r="15"></circle>
    </svg>
    <span class="txt">5</span>
  </div>`; }

function renderOpps(game){
  const reveal = now() < (game.revealOppUntil||0);
  const players = (game.players||[]).filter(p=>p!==username);
  const hands = game.hands||{};
  const points = game.points||{};
  el.opps.innerHTML = '';
  for (const p of players){
    const div = document.createElement('div'); div.className='opp';
    const hand = (hands[p]||[]);
    const isSil = now() < (game.silenced?.[p]||0);
    const isShd = now() < (game.shields?.[p]||0);
    div.innerHTML = `<span class="name">${p}</span>
                     ${isSil?'<span class="flag sil">ü§ê</span>':''}
                     ${isShd?'<span class="flag shd">üõ°Ô∏è</span>':''}
                     <span class="badge">Pts: ${points[p]||0}</span>`;
    if (reveal){
      const rev = document.createElement('div'); rev.className='revealMini';
      rev.innerHTML = hand.slice(0,6).map(x=>`${byIdMap[x.id].emoji} ${byIdMap[x.id].name}`).join(' ¬∑ ');
      div.appendChild(rev);
    } else {
      div.insertAdjacentHTML('beforeend', miniHand(hand.length));
    }
    el.opps.appendChild(div);
  }
}
function renderScores(game){
  const pts = Object.assign({}, game.points||{});
  const players = (game.players||[]).slice();
  players.forEach(p=>{ if(pts[p]===undefined) pts[p]=0; });
  const rows = players.map(p=>({name:p, pts:pts[p]})).sort((a,b)=>b.pts-a.pts);
  el.scores.innerHTML = '';
  rows.forEach((r,i)=>{
    const div = document.createElement('div');
    let cls = ''; if (i===0) cls='m1'; else if (i===1) cls='m2'; else if (i===2) cls='m3';
    div.className = `sc ${cls}`;
    div.innerHTML = `<span class="dot"></span><span>${r.name===username?'You':r.name}</span><span>‚Ä¢</span><strong>${r.pts}</strong>`;
    el.scores.appendChild(div);
  });
}
function renderRiver(game){
  const frozen = now() < (game.freezeUntil||0);
  const wrap = document.querySelector('.riverWrap');
  wrap.classList.toggle('frozen', frozen);
  wrap.classList.toggle('flipGlow', now() < localFlipHighlightUntil);

  el.river.innerHTML='';
  const R = game.river||[];
  for(let i=0;i<10;i++){
    const s = R[i] || {id:null};
    const slot = document.createElement('div');
    slot.className = 'slot' + (s.id? '':' empty');
    slot.dataset.idx = String(i);
    if (sel.zone==='river' && sel.idx===i) slot.classList.add('sel');
    if (s.id){
      const card = document.createElement('div'); card.className='card';
      card.innerHTML = cardFrontHTML(s.id) + cardBackHTML() + timerHTML();
      slot.appendChild(card);
    }
    el.river.appendChild(slot);
  }

  const ban = game.ban;
  if (ban && now() < (ban.until||0)){
    el.banBadge.hidden = false;
    el.banBadge.textContent = `Ban: ${ban.fam}`;
  } else el.banBadge.hidden = true;
}
function renderHand(game){
  el.hand.innerHTML='';
  const my = (game.hands?.[username]||[]);
  for(let i=0;i<5;i++){
    const slot = document.createElement('div');
    slot.className = 'hslot'+(my[i]?'':' empty');
    slot.dataset.idx = String(i);
    if (sel.zone==='hand' && sel.idx===i) slot.classList.add('sel');
    if (my[i]){
      const c = my[i].id;
      const card = document.createElement('div'); card.className='card';
      card.innerHTML = cardFrontHTML(c);
      slot.appendChild(card);
    }
    el.hand.appendChild(slot);
  }
}
function renderReady(game){
  const my = (game.hands?.[username]||[]);
  const ready = findReadyCombos(my.map(x=>x.id));
  el.ready.innerHTML = '';
  if (!ready.length){
    const pill=document.createElement('div'); pill.className='pill'; pill.textContent='No ready combos';
    el.ready.appendChild(pill);
    return;
  }
  for(const r of ready){
    const combo = r.combo;
    const emo = r.indexes.map(i => byIdMap[my[i].id].emoji).join(' ');
    const p = document.createElement('div'); p.className='pill';
    const label = document.createElement('span'); label.textContent = `${combo.label} (+${combo.pts})`;
    const cards = document.createElement('span'); cards.textContent = `‚Ä¢ ${emo}`;
    const btn = document.createElement('button'); btn.className='playBtn'; btn.textContent='PLAY';
    btn.addEventListener('click', async ()=>{
      const useUids = r.indexes.map(i=>my[i].uid);
      const needs = effectNeedsTarget(combo.effect);
      if (needs){
        if (needs.kind==='trade' || needs.kind==='silence'){ openTargetPlayerPicker(game, combo, useUids, needs.kind==='trade'?'Choose player to trade with':'Choose a player to silence'); }
        else { openTargetCardPicker(game, combo, useUids, needs); }
      } else { await playCombo(combo.key, useUids, null); }
    });
    p.append(label, cards, btn);
    el.ready.appendChild(p);
  }
}
function renderNear(game){
  const my = (game.hands?.[username]||[]);
  const near = findNearCombosDetailed(my.map(x=>x.id), 2);
  el.near.innerHTML='';
  if (!near.length){
    const pill=document.createElement('div'); pill.className='pill'; pill.textContent='No combo suggestions';
    el.near.appendChild(pill); return;
  }
  for(const n of near){
    const pill=document.createElement('div'); pill.className='pill';
    const needsEmo = n.missing.map(m=> (m.id? byIdMap[m.id].emoji : famIcon(m.fam))).join(' ');
    pill.innerHTML = `<span>${n.combo.label}</span> <span class="need">‚Ä¢ need ${needsEmo}</span>`;
    el.near.appendChild(pill);
  }
}
function updateHUD(game){
  el.deckBadge.textContent = `Deck: ${game.deck?.length||0}`;
  el.discardBadge.textContent = `Discard: ${game.discard?.length||0}`;
  el.startBtn.hidden = !(game.host===username && game.status==='lobby');
  el.hostBadge.hidden = !(game.host===username);
}

/* Face/back + timer updater (local) */
function rafFaces(){
  const slots = el.river.querySelectorAll('.slot');
  const t = now();
  slots.forEach((slot)=>{
    const idx = Number(slot.dataset.idx);
    const front = slot.querySelector('.front');
    const back  = slot.querySelector('.back');
    const timer = slot.querySelector('.timer');
    const prog  = slot.querySelector('.prog');
    const txt   = slot.querySelector('.txt');
    if (!front || !back) return;
    const up = t < (localRevealUntil[idx]||0);
    front.style.display = up ? '' : 'none';
    back.style.display  = up ? 'none' : '';
    if (timer && prog && txt){
      if (up){
        timer.style.display = '';
        const elapsed = Math.max(0, t - (localRevealStart[idx]||t));
        const dur = Math.max(1, localRevealDur[idx]||1);
        const remain = Math.max(0, (localRevealUntil[idx]||t)-t);
        const ratio = Math.max(0, Math.min(1, 1 - (elapsed/dur)));
        const circ = 2*Math.PI*15;
        prog.setAttribute('stroke-dasharray', `${circ}`);
        prog.setAttribute('stroke-dashoffset', `${(1-ratio)*circ}`);
        txt.textContent = String(Math.ceil(remain/1000));
      } else {
        timer.style.display = 'none';
      }
    }
  });
  requestAnimationFrame(rafFaces);
}
requestAnimationFrame(rafFaces);

/* ======= Click bindings ======= */
el.river.addEventListener('click', async (e)=>{
  const slot = e.target.closest('.slot'); if(!slot) return;
  const rIdx = Number(slot.dataset.idx);
  const snap = await getDoc(gref); if(!snap.exists()) return;
  const g = snap.data(); if (g.status!=='active') return;

  const my = (g.hands?.[username]||[]);
  if (now() < (g.freezeUntil||0)) return;

  if (my.length<5){ await pickFromRiver(rIdx); sel={zone:null,idx:null}; }
  else{
    if (sel.zone==='hand'){ await swapHandRiver(sel.idx, rIdx); sel={zone:null,idx:null}; }
    else { sel={zone:'river', idx:rIdx}; renderRiver(g); }
  }
});
el.hand.addEventListener('click', async (e)=>{
  const slot = e.target.closest('.hslot'); if(!slot) return;
  const hIdx = Number(slot.dataset.idx);
  const snap = await getDoc(gref); if(!snap.exists()) return;
  const g = snap.data(); if (g.status!=='active') return;
  const my = (g.hands?.[username]||[]);
  if (!my[hIdx]) return;

  if (sel.zone==='river'){ await swapHandRiver(hIdx, sel.idx); sel={zone:null,idx:null}; }
  else if (sel.zone==='hand' && sel.idx===hIdx){ sel={zone:null,idx:null}; }
  else { sel={zone:'hand', idx:hIdx}; renderHand(g); }
});

/* ======= Fullscreen / leave / start ======= */
el.fsBtn.addEventListener('click', async ()=>{
  const root = document.documentElement;
  try{
    if (!document.fullscreenElement) await (root.requestFullscreen?.() || root.webkitRequestFullscreen?.());
    else await (document.exitFullscreen?.() || document.webkitExitFullscreen?.());
  }catch(e){}
});
el.leaveBtn.addEventListener('click', ()=>{ location.href = `${LOBBY_URL}?username=${encodeURIComponent(username)}`; });
el.toLobbyBtn.addEventListener('click', ()=>{ location.href = `${LOBBY_URL}?username=${encodeURIComponent(username)}`; });
el.startBtn.addEventListener('click', hostDealAndStart);

/* ======= Game over & win bump ======= */
async function endIfDeckDone(){
  await runTransaction(db, async(tx)=>{
    const snap = await tx.get(gref);
    if (!snap.exists()) return;
    const g = snap.data();
    if (g.status !== 'active') return;

    const anyRiver = (g.river||[]).some(s=>s && s.id);
    const deckEmpty = !g.deck || g.deck.length===0;
    if (!deckEmpty || anyRiver) return;

    const pts = g.points||{};
    const entries = Object.entries(pts);
    if (!entries.length) return;
    entries.sort((a,b)=> (b[1])-(a[1]));
    const top = entries[0][1];
    const winners = entries.filter(e=>e[1]===top).map(e=>e[0]);

    tx.update(gref, {status:'over', winners, overReason:'Deck exhausted', lastMoveAt: now(),
      events: (g.events||[]).concat([{ts:now(), text:`Game over ‚Äî winner: ${winners.join(', ')}`}]).slice(-20)
    });
  });
}
async function bumpMyWinsIfWinner(winners){
  if (!winners.includes(username)) return;
  await runTransaction(db, async(tx)=>{
    const usnap = await tx.get(uref);
    if (!usnap.exists()){ tx.set(uref, {wins:1}, {merge:true}); }
    else { const cur = usnap.data(); tx.update(uref, {wins: (cur.wins||0)+1}); }
  });
}

/* ======= Live sync + toasts + local reveal handling ======= */
let lastEventTs = 0;
onSnapshot(gref, async (snap)=>{
  if (!snap.exists()) return;
  const g = snap.data();

  /* Local flip-timer bootstrapping: reveal each newly spawned card for 5s */
  const R = g.river||[];
  for(let i=0;i<10;i++){
    const u = R[i]?.uid || null;
    if (u && u !== prevRiverUids[i]){
      const t = now();
      localRevealStart[i] = t;
      localRevealDur[i]   = 5000;
      localRevealUntil[i] = t + 5000;
      prevRiverUids[i]    = u;
    } else if (!u) {
      prevRiverUids[i] = null;
      localRevealStart[i] = 0;
      localRevealDur[i]   = 0;
      localRevealUntil[i] = 0;
    }
  }

  renderScores(g);
  renderOpps(g);
  renderRiver(g);
  renderHand(g);
  renderReady(g);
  renderNear(g);
  updateHUD(g);

  for (const ev of (g.events||[])){
    if (ev.ts > lastEventTs){
      if (ev.type === 'revealCenter'){
        const dur = ev.ms || 2500;
        const t = now();
        for(let i=0;i<10;i++){
          localRevealStart[i] = t;
          localRevealDur[i]   = dur;
          localRevealUntil[i] = t + dur;
        }
        localFlipHighlightUntil = t + dur;
      }
      if (ev.text) showToast(ev.text);
      lastEventTs = Math.max(lastEventTs, ev.ts);
    }
  }

  if (g.status==='over'){
    showOver(g);
    if (!localStorage.getItem(`splinters.bumped.${gameId}.${username}`)){
      await bumpMyWinsIfWinner(g.winners||[]);
      localStorage.setItem(`splinters.bumped.${gameId}.${username}`,'1');
      setTimeout(()=>{ location.href = `${LOBBY_URL}?username=${encodeURIComponent(username)}`; }, 1500);
    }
  }
});

/* ======= UI helpers ======= */
function showToast(text){
  const t=document.createElement('div'); t.className='toast'; t.textContent=text;
  el.toasts.appendChild(t);
  const life = 1300 + Math.random()*500;
  setTimeout(()=>{ t.classList.add('out'); setTimeout(()=>t.remove(),220); }, life);
}
function showOver(game){
  const winners = game.winners||[];
  el.overTitle.textContent = winners.includes(username) && winners.length===1 ? 'You win!' : `Winner: ${winners.join(', ')}`;
  el.overWhy.textContent = game.overReason || 'Game finished';
  const pts = game.points||{};
  const rows = Object.entries(pts).sort((a,b)=>b[1]-a[1]);
  el.overTable.innerHTML = `<tr><th>Player</th><th>Points</th></tr>` + rows.map(r=>`<tr><td>${r[0]===username?'You':r[0]}</td><td>${r[1]}</td></tr>`).join('');
  el.over.classList.add('show');
}

/* ======= Header state ======= */
onSnapshot(gref, (snap)=>{
  if(!snap.exists()) return;
  const g = snap.data();
  el.startBtn.hidden = !(g.host===username && g.status==='lobby');
  el.hostBadge.hidden = !(g.host===username);
});

/* ======= Periodic end-condition check ======= */
setInterval(endIfDeckDone, 1200);
</script>
</body>
</html>



