<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>JESUS RUN — Endless Regions + Heaven Trial</title>
<style>
  :root{
    --bgTop:#eaf3ff; --bgMid:#f7fbff; --bgBot:#ffffff;
    --ink:#0f172a; --muted:#475569;
    --panel:rgba(255,255,255,.78); --line:rgba(15,23,42,.14);
    --shadow:0 18px 40px rgba(15,23,42,.12);
    --gold:#caa24a; --red:#d33636; --blue:#2b86ff; --green:#2aa84a;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bgTop),var(--bgBot));color:var(--ink);
    font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}
  #wrap{height:100%;display:grid;place-items:center;padding:10px}
  #shell{
    width:min(1120px,96vw);
    aspect-ratio:16/9;
    background:rgba(255,255,255,.35);
    border:1px solid var(--line);
    border-radius:18px;
    box-shadow:var(--shadow);
    overflow:hidden;
    position:relative;
  }
  canvas{width:100%;height:100%;display:block}
  #hud{
    position:absolute;inset:10px 10px auto 10px;
    display:flex;gap:10px;align-items:flex-start;pointer-events:none;
  }
  .panel{
    background:var(--panel);
    border:1px solid var(--line);
    border-radius:14px;
    padding:10px 12px;
    box-shadow:0 10px 26px rgba(15,23,42,.10);
    backdrop-filter: blur(8px);
  }
  #leftHUD{display:flex;flex-direction:column;gap:8px;min-width:340px}
  #rowTop{display:flex;gap:10px;align-items:center;justify-content:space-between}
  #title{font-weight:900;letter-spacing:.4px}
  #sub{font-size:12px;color:var(--muted);margin-top:2px}
  #stats{display:flex;gap:10px;align-items:center;flex-wrap:wrap;font-size:13px;color:var(--muted)}
  .pill{
    display:inline-flex;align-items:center;gap:8px;
    padding:6px 10px;border-radius:999px;border:1px solid var(--line);
    background:rgba(255,255,255,.70);
    color:var(--ink);
  }
  .dot{width:9px;height:9px;border-radius:999px;background:var(--blue)}
  .heart{width:10px;height:10px;border-radius:3px;background:var(--red);transform:rotate(45deg);position:relative}
  .heart:before,.heart:after{content:"";position:absolute;width:10px;height:10px;border-radius:50%;background:var(--red)}
  .heart:before{left:-5px;top:0}
  .heart:after{left:0;top:-5px}
  #power{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
  .pow{
    display:inline-flex;align-items:center;gap:8px;
    padding:6px 10px;border-radius:12px;border:1px solid var(--line);
    background:rgba(255,255,255,.75);
    color:var(--ink);font-size:12px;
  }
  .icon{
    width:20px;height:20px;border-radius:7px;border:1px solid rgba(15,23,42,.16);
    display:grid;place-items:center;font-weight:900;overflow:hidden;
  }
  .ic-blue{background:rgba(43,134,255,.14)}
  .ic-gold{background:rgba(202,162,74,.16)}
  .ic-green{background:rgba(42,168,74,.14)}
  .ic-heaven{background:rgba(255,255,255,.55)}
  #banner{
    position:absolute;left:50%;top:14px;transform:translateX(-50%);
    padding:10px 14px;border-radius:14px;border:1px solid var(--line);
    background:rgba(255,255,255,.86);
    box-shadow:0 12px 30px rgba(15,23,42,.14);
    font-weight:950;letter-spacing:.6px;
    opacity:0;pointer-events:none;
    transition:opacity .2s ease;
  }
  #banner small{display:block;font-weight:800;color:var(--muted);letter-spacing:.2px;margin-top:2px}
  #mobileRotateHint{
    position:absolute;inset:0;display:none;align-items:center;justify-content:center;z-index:14;
    background:rgba(15,23,42,.58);padding:20px;
  }
  #mobileRotateHint .panel{font-size:14px;color:var(--ink);max-width:360px;text-align:center;line-height:1.4}
  #topButtons{position:absolute;top:10px;right:10px;display:flex;gap:8px;z-index:12}
  .uiBtn{pointer-events:auto;border:1px solid var(--line);background:rgba(255,255,255,.86);border-radius:10px;padding:8px 10px;font-weight:700;cursor:pointer}
  #mobileControls{
    position:absolute;left:0;right:0;bottom:0;display:none;justify-content:space-between;align-items:end;
    padding:14px;z-index:8;pointer-events:none;
  }
  #joystick,#jumpBtn{pointer-events:auto}
  #joystick{width:124px;height:124px;border-radius:999px;background:rgba(15,23,42,.20);border:1px solid rgba(255,255,255,.4);position:relative;touch-action:none}
  #stick{position:absolute;left:50%;top:50%;width:58px;height:58px;margin:-29px 0 0 -29px;border-radius:999px;background:rgba(255,255,255,.85);border:1px solid var(--line)}
  #jumpBtn{width:96px;height:96px;border-radius:999px;border:1px solid rgba(255,255,255,.48);background:rgba(43,134,255,.75);color:#fff;font-size:18px;font-weight:800;touch-action:none}
  #gameOverModal{position:absolute;inset:0;background:rgba(15,23,42,.76);z-index:15;display:none;align-items:center;justify-content:center;padding:18px}
  #gameOverCard{width:min(520px,92vw);background:rgba(255,255,255,.95);border-radius:16px;padding:18px;border:1px solid var(--line)}
  #scoreList{margin:8px 0 14px;padding-left:20px;max-height:200px;overflow:auto}
  #nameRow{display:flex;gap:8px;margin-bottom:10px}
  #nameInput{flex:1;padding:8px 10px;border-radius:10px;border:1px solid var(--line)}
  @media (hover:none) and (pointer:coarse){
    #mobileControls{display:flex}
  }
  kbd{font:inherit;background:rgba(255,255,255,.8);border:1px solid var(--line);border-bottom-color:rgba(15,23,42,.22);
    padding:1px 6px;border-radius:7px;color:var(--ink)}
</style>
</head>
<body>
<div id="wrap">
  <div id="shell">
    <canvas id="c" width="960" height="540"></canvas>

    <div id="hud">
      <div id="leftHUD" class="panel">
        <div id="rowTop">
          <div>
            <div id="title">JESUS RUN</div>
            <div id="sub">Rome → Jerusalem → Hell · Jump above the top to enter Heaven (hard)</div>
          </div>
          <div class="pill"><span class="dot"></span><span id="regionText">Rome</span></div>
        </div>

        <div id="stats">
          <span class="pill"><b id="levelText">1-1</b></span>
          <span class="pill">Distance: <b id="distText">0</b></span>
          <span class="pill">Hearts: <b id="heartsText">3</b> <span id="heartsIcons"></span></span>
        </div>

        <div id="power"></div>
      </div>
    </div>

    <div id="banner"><div id="bannerMain">WORLD 1-1</div><small id="bannerSub">ROME</small></div>

    <div id="topButtons">
      <button id="startBtn" class="uiBtn">Start Game</button>
      <button id="fullscreenBtn" class="uiBtn">Fullscreen</button>
    </div>

    <div id="mobileControls">
      <div id="joystick"><div id="stick"></div></div>
      <button id="jumpBtn">JUMP</button>
    </div>

    <div id="mobileRotateHint">
      <div class="panel">
        <div style="font-weight:900;font-size:18px;margin-bottom:8px">Best in Landscape</div>
        Turn your phone sideways before starting for better controls and visibility.
      </div>
    </div>

    <div id="gameOverModal">
      <div id="gameOverCard">
        <h2 style="margin:0 0 8px">Game Over</h2>
        <div id="finalScoreText"></div>
        <ol id="scoreList"></ol>
        <div id="nameWrap" style="display:none">
          <div style="font-weight:700;margin-bottom:6px">Top 10! Enter your name:</div>
          <div id="nameRow">
            <input id="nameInput" maxlength="20" placeholder="Disciple name" />
            <button id="saveScoreBtn" class="uiBtn">Save</button>
          </div>
          <div id="saveStatus" style="font-size:12px;color:var(--muted)"></div>
        </div>
        <button id="restartBtn" class="uiBtn">Restart</button>
      </div>
    </div>
  </div>
</div>

<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>

<script>
(() => {
  // =========================
  // Canvas + basics
  // =========================
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const uiRegion = document.getElementById('regionText');
  const uiLevel  = document.getElementById('levelText');
  const uiDist   = document.getElementById('distText');
  const uiHearts = document.getElementById('heartsText');
  const uiHeartsIcons = document.getElementById('heartsIcons');
  const uiPower  = document.getElementById('power');
  const banner = document.getElementById('banner');
  const bannerMain = document.getElementById('bannerMain');
  const bannerSub  = document.getElementById('bannerSub');
  const startBtn = document.getElementById('startBtn');
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  const joystick = document.getElementById('joystick');
  const stick = document.getElementById('stick');
  const jumpBtn = document.getElementById('jumpBtn');
  const mobileRotateHint = document.getElementById('mobileRotateHint');
  const gameOverModal = document.getElementById('gameOverModal');
  const scoreList = document.getElementById('scoreList');
  const finalScoreText = document.getElementById('finalScoreText');
  const nameWrap = document.getElementById('nameWrap');
  const nameInput = document.getElementById('nameInput');
  const saveScoreBtn = document.getElementById('saveScoreBtn');
  const saveStatus = document.getElementById('saveStatus');
  const restartBtn = document.getElementById('restartBtn');

  const W = canvas.width, H = canvas.height;

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand  = (a,b)=>a+Math.random()*(b-a);
  const rndi  = (a,b)=>Math.floor(rand(a,b+1));
  const lerp  = (a,b,t)=>a+(b-a)*t;
  const sign  = (v)=>v<0?-1:1;

  function aabb(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x &&
           a.y < b.y + b.h && a.y + a.h > b.y;
  }
  function overlapX(a,b){
    const lo = Math.max(a.x, b.x);
    const hi = Math.min(a.x+a.w, b.x+b.w);
    return hi - lo;
  }

  // =========================
  // Fixed timestep physics
  // =========================
  let last = performance.now()/1000;
  let acc = 0;
  const FIXED_DT = 1/120;
  const MAX_STEPS = 7;

  // =========================
  // Input
  // =========================
  const keys = new Set();
  const pressed = new Set();
  const mobileInput = {xAxis:0, down:false, jumpHeld:false, jumpQueued:false};
  const isMobileDevice = matchMedia('(hover:none) and (pointer:coarse)').matches;
  let gameStarted = false;
  let gameScore = 0;
  let highScores = [];
  let topTenEligible = false;
  const LOCAL_SCORES_KEY = 'jesusRunHighscores';

  function setGameStarted(started){
    gameStarted = started;
    if(startBtn) startBtn.style.display = started ? 'none' : 'inline-flex';
    updateMobileRotateHint();
  }

  function startGame(){
    if(GAME_OVER) return;
    setGameStarted(true);
  }

  startBtn.addEventListener('click', startGame);

  addEventListener('keydown', e => {
    if(["ArrowLeft","ArrowRight","ArrowUp","ArrowDown"," "].includes(e.key)) e.preventDefault();
    const k = e.key.toLowerCase();
    keys.add(k);
    if(!e.repeat) pressed.add(k);
    startGame();
  });
  addEventListener('keyup', e => keys.delete(e.key.toLowerCase()));
  fullscreenBtn.addEventListener('click', async () => {
    try{
      if(!document.fullscreenElement) await document.documentElement.requestFullscreen();
      else await document.exitFullscreen();
    }catch(_e){}
  });

  function resetStick(){
    mobileInput.xAxis = 0; mobileInput.down = false;
    stick.style.transform = 'translate(0px,0px)';
  }
  function setJoystickFromEvent(e){
    const t = (e.touches && e.touches[0]) || e;
    const rect = joystick.getBoundingClientRect();
    const cx = rect.left + rect.width/2;
    const cy = rect.top + rect.height/2;
    const dx = t.clientX - cx;
    const dy = t.clientY - cy;
    const maxR = rect.width*0.34;
    const len = Math.hypot(dx,dy) || 1;
    const nx = (dx/len) * Math.min(maxR,len);
    const ny = (dy/len) * Math.min(maxR,len);
    stick.style.transform = `translate(${nx}px,${ny}px)`;
    mobileInput.xAxis = clamp(nx/maxR,-1,1);
    mobileInput.down = ny > maxR*0.40;
  }
  joystick.addEventListener('pointerdown', e=>{ startGame(); joystick.setPointerCapture(e.pointerId); setJoystickFromEvent(e); });
  joystick.addEventListener('pointermove', e=>{ if(e.pressure>0) setJoystickFromEvent(e); });
  joystick.addEventListener('pointerup', resetStick);
  joystick.addEventListener('pointercancel', resetStick);

  jumpBtn.addEventListener('pointerdown', e=>{ e.preventDefault(); startGame(); mobileInput.jumpHeld = true; mobileInput.jumpQueued = true; });
  jumpBtn.addEventListener('pointerup', ()=> mobileInput.jumpHeld = false);
  jumpBtn.addEventListener('pointercancel', ()=> mobileInput.jumpHeld = false);

  const kDown = (k)=>keys.has(k);
  const consume = (k)=>{ if(pressed.has(k)){ pressed.delete(k); return true; } return false; };
  const jumpJustPressed = () => {
    if(mobileInput.jumpQueued){
      mobileInput.jumpQueued = false;
      return true;
    }
    return consume('w') || consume('arrowup') || consume(' ');
  };
  const jumpHeld = () => mobileInput.jumpHeld || kDown('w') || kDown('arrowup') || kDown(' ');
  const downHeld = () => mobileInput.down || kDown('s') || kDown('arrowdown');

  function updateMobileRotateHint(){
    if(!isMobileDevice || !mobileRotateHint) return;
    const portrait = window.innerHeight > window.innerWidth;
    mobileRotateHint.style.display = (!gameStarted && portrait) ? 'flex' : 'none';
  }
  addEventListener('resize', updateMobileRotateHint);
  addEventListener('orientationchange', updateMobileRotateHint);

  // =========================
  // World/region progression
  // =========================
  const REGIONS = ["Rome","Jerusalem","Hell"];
  const SECTION_W = 2400;
  const FLOOR_Y = 468;

  // Heaven trial
  const HEAVEN = "Heaven";
  const HEAVEN_REWARD = 5;                 // +5 levels forward
  const HEAVEN_LEN_BASE = SECTION_W * 1.25;

  function getWorldStage(si){
    const world = Math.floor(si/3)+1;
    const stage = (si%3)+1;
    const region = REGIONS[stage-1];
    return {world, stage, region};
  }

  // Stronger scaling than before (deeper levels get nastier)
  function difficultyScalar(world, stage){
    const base = 1 + (world-1)*0.36;            // was ~0.18 per world
    const stageAdd = (stage===2?0.16:stage===3?0.34:0.00);
    return base + stageAdd;
  }
  function heavenDifficulty(world){
    // Starts hard and ramps hard
    return 2.0 + (world-1)*0.55;
  }

  // =========================
  // Player
  // =========================
  const player = {
    x: 140, y: FLOOR_Y-64,
    w: 34, h: 64,
    vx: 0, vy: 0,
    facing: 1,
    onGround: false,
    onMoverId: null,
    groundSolid: null,
    coyote: 0,
    jumpBuf: 0,
    jumpsLeft: 0,
    invT: 0,
    dropT: 0,
    hearts: 3,
    hasSandals: false,
    hasAngelWings: false,
    hasShield: false,
    hasBread: false,
    holyLightT: 0,
    fireRainShots: 0,
    fireRainCd: 0,
    armT: 0,
  };

  // Feel tuning
  const GRAV = 2800;
  const RUN  = 560;
  const AIR_MAX = 0.92;
  const JUMP_V = 960;
  const ACC_GROUND = 5200;
  const ACC_AIR = 3400;
  const FRICTION_GROUND = 9.0;
  const FRICTION_AIR = 2.2;

  function maxJumpDist(){
    const tFlight = (2*JUMP_V)/GRAV;
    return RUN * tFlight;
  }
  const SAFE_GAP = Math.min(220, Math.max(170, maxJumpDist()*0.72));

  // =========================
  // Two-world system (earth + heaven)
  // =========================
  const earthWorld = {
    solids:[], movers:[], hazards:[], enemies:[], pickups:[],
    sectionIndex:0, generatedUntilX:0
  };
  const heavenWorld = {
    solids:[], movers:[], hazards:[], enemies:[], pickups:[],
    generatedUntilX:0
  };

  let realm = "earth";
  let worldObj = earthWorld;

  // active references (so existing functions keep working)
  let solids = worldObj.solids;
  let movers = worldObj.movers;
  let hazards = worldObj.hazards;
  let enemies = worldObj.enemies;
  let pickups = worldObj.pickups;

  function setWorld(obj){
    worldObj = obj;
    solids = obj.solids;
    movers = obj.movers;
    hazards = obj.hazards;
    enemies = obj.enemies;
    pickups = obj.pickups;
  }

  // Heaven run state
  let heavenEntrySI = 0;
  let heavenEntryX = 0;
  let heavenGoalX = 0;
  let heavenDiff = 2.0;
let GAME_OVER = false;

  const firebaseConfig = {
    apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
    authDomain: "bible-game-246c0.firebaseapp.com",
    databaseURL: "https://bible-game-246c0-default-rtdb.firebaseio.com",
    projectId: "bible-game-246c0",
    storageBucket: "bible-game-246c0.firebasestorage.app",
    messagingSenderId: "959619818996",
    appId: "1:959619818996:web:5a9fbf492e23c765e445a1",
    measurementId: "G-8PR6LVKSH3"
  };
  let db = null;
  try{
    if(window.firebase){
      firebase.initializeApp(firebaseConfig);
      db = firebase.firestore();
    }
  }catch(_e){ db = null; }

  // =========================
  // Objects + helpers
  // =========================
  let fx = [];
  let nextMoverId = 1;
  let perfT = 0;
  let camX = 0;
  let bannerT = 0;

  const isGround = (s)=>s.kind === 'ground';
  const isOneWay = (s)=>s.kind === 'platform' || s.kind === 'crumble' || s.kind === 'cloud' || s.kind==='slippery' || s.kind==='blessed';

  function moverSweepBox(m, pad=30){
    const ax = Math.abs(m.ax||0), ay = Math.abs(m.ay||0);
    return {
      x: (m.baseX - ax) - pad,
      y: (m.baseY - ay) - pad,
      w: (m.w + ax*2) + pad*2,
      h: (m.h + ay*2) + pad*2
    };
  }
  function hitsAnyMoverSweep(r){
    for(const m of movers){
      if(!m.sweep) continue;
      if(aabb(r, m.sweep)) return true;
    }
    return false;
  }
  function canPlaceRect(r, pad=12){
    for(const s of solids){
      if(s.dead) continue;
      const p = (s.kind==='ground'||r.kind==='ground') ? 6 : pad;
      if(aabb({x:r.x-p,y:r.y-p,w:r.w+p*2,h:r.h+p*2}, s)) return false;
    }
    if(hitsAnyMoverSweep(r)) return false;
    return true;
  }

  function placeSolid(r){ solids.push(r); }
  function placeMover(m){
    m.id = nextMoverId++;
    m.t = rand(0,Math.PI*2);
    m.dx = 0; m.dy = 0; m.vx = 0; m.vy = 0;
    m.sweep = moverSweepBox(m, 34);
    movers.push(m);
  }
  function placeHazard(h){ hazards.push(h); }
  function placeEnemy(e){ enemies.push(e); }
  function placePickup(p){ pickups.push(p); }

  function showBanner(main, sub, dur=1.6){
    bannerMain.textContent = main;
    bannerSub.textContent = sub;
    bannerT = dur;
    banner.style.opacity = "1";
  }
  function showBannerForSection(si){
    const {world, stage, region} = getWorldStage(si);
    showBanner(`WORLD ${world}-${stage}`, region.toUpperCase(), 1.6);
  }

  function findSurfaceY(x){
    let best = null;
    for(const s of solids){
      if(s.dead) continue;
      if(s.x <= x && x <= s.x + s.w){
        if(best === null || s.y < best) best = s.y;
      }
    }
    for(const m of movers){
      if(m.x <= x && x <= m.x + m.w){
        if(best === null || m.y < best) best = m.y;
      }
    }
    return best;
  }
function triggerGameOver(){
  if (GAME_OVER) return;
  GAME_OVER = true;
  showGameOverUI();
}

function restartGame(){
  GAME_OVER = false;
  gameOverModal.style.display = 'none';
  setGameStarted(false);
  resetWorld();
}

function loadLocalScores(){
  try{
    const raw = localStorage.getItem(LOCAL_SCORES_KEY);
    if(!raw) return [];
    const parsed = JSON.parse(raw);
    if(!Array.isArray(parsed)) return [];
    return parsed.filter(r=>r && typeof r.score === 'number').slice(0, 20);
  }catch(_e){ return []; }
}

function writeLocalScores(rows){
  try{
    localStorage.setItem(LOCAL_SCORES_KEY, JSON.stringify(rows));
    return true;
  }catch(_e){ return false; }
}

function mergeTopScores(rows){
  return rows
    .map(r=>({name: (r.name || 'Anonymous').toString().slice(0,20), score: Math.max(0, Math.floor(r.score||0)), createdAt: r.createdAt || Date.now()}))
    .sort((a,b)=> (b.score-a.score) || (a.createdAt-b.createdAt))
    .slice(0,10);
}

async function fetchHighScores(){
  const local = loadLocalScores();
  if(!db) return mergeTopScores(local);
  try{
    const snap = await db.collection('highscores').orderBy('score','desc').limit(10).get();
    const remote = snap.docs.map(d=>d.data());
    return mergeTopScores([...local, ...remote]);
  }catch(_e){
    return mergeTopScores(local);
  }
}

async function saveHighScore(name, score){
  const row = {name, score: Math.max(0, Math.floor(score||0)), createdAt: Date.now()};
  const combined = mergeTopScores([row, ...loadLocalScores()]);
  const localOk = writeLocalScores(combined);

  if(!db) return {ok: localOk, source: localOk ? 'local' : 'none'};
  try{
    await db.collection('highscores').add(row);
    return {ok: true, source: 'cloud'};
  }catch(_e){
    return {ok: localOk, source: localOk ? 'local' : 'none'};
  }
}

function renderHighScoreList(){
  scoreList.innerHTML = '';
  highScores.forEach((row)=>{
    const li = document.createElement('li');
    li.textContent = `${row.name || 'Anonymous'} — ${row.score || 0}`;
    scoreList.appendChild(li);
  });
  if(!highScores.length){
    const li = document.createElement('li');
    li.textContent = 'No scores yet';
    scoreList.appendChild(li);
  }
}

async function showGameOverUI(){
  gameOverModal.style.display = 'flex';
  finalScoreText.textContent = `Distance score: ${gameScore}`;
  highScores = await fetchHighScores();
  const cutoff = highScores.length < 10 ? 0 : (highScores[highScores.length-1]?.score || 0);
  topTenEligible = gameScore >= cutoff || highScores.length < 10;
  nameWrap.style.display = topTenEligible ? 'block' : 'none';
  nameInput.value = '';
  if(saveStatus) saveStatus.textContent = '';
  renderHighScoreList();
}

saveScoreBtn.addEventListener('click', async ()=>{
  const raw = nameInput.value.trim();
  const safeName = raw.replace(/[^\w\s.-]/g,'').slice(0,20) || 'Anonymous';
  const result = await saveHighScore(safeName, gameScore);
  if(result.ok){
    highScores = await fetchHighScores();
    renderHighScoreList();
    nameWrap.style.display = 'none';
    if(saveStatus){
      saveStatus.style.color = 'var(--green)';
      saveStatus.textContent = result.source === 'cloud' ? 'Saved to global highscores.' : 'Saved on this device (offline mode).';
    }
  } else if(saveStatus){
    saveStatus.style.color = 'var(--red)';
    saveStatus.textContent = 'Could not save score. Please try again.';
  }
});
restartBtn.addEventListener('click', restartGame);

  // =========================
  // Collision & movement (same rules)
  // =========================
  function moveAndCollide(ent, dt){
    ent.onGround = false;
    ent.onMoverId = null;
    ent.groundSolid = null;

    const prevX = ent.x, prevY = ent.y;
    const prevBottom = prevY + ent.h;
    const prevTop = prevY;
    const ignoreOneWay = (ent.dropT && ent.dropT > 0);

    // ---- X (collide ONLY with ground)
    ent.x += ent.vx * dt;
    for(const s of solids){
      if(s.dead) continue;
      if(!isGround(s)) continue;
      if(aabb(ent, s)){
        if(ent.vx > 0) ent.x = s.x - ent.w;
        else if(ent.vx < 0) ent.x = s.x + s.w;
        ent.vx = 0;
      }
    }

    // ---- Y
    ent.y += ent.vy * dt;

    // full solids (ground)
    for(const s of solids){
      if(s.dead) continue;
      if(!isGround(s)) continue;
      if(!aabb(ent, s)) continue;

      if(ent.vy > 0 && prevBottom <= s.y + 2){
        ent.y = s.y - ent.h;
        ent.vy = 0;
        ent.onGround = true;
        ent.groundSolid = s;
      } else if(ent.vy < 0 && prevTop >= s.y + s.h - 2){
        ent.y = s.y + s.h;
        ent.vy = 0;
      }
    }

    // ONE-WAY solids
    if(!ignoreOneWay && ent.vy >= 0){
  const MIN_OVER = 10; // keep a little overlap so tiny corner touches don't "stick"
  for(const s of solids){
    if(s.dead) continue;
    if(!isOneWay(s)) continue;
    if(!aabb(ent, s)) continue;

    const over = overlapX(ent, s);
    if(over < MIN_OVER) continue;

    // only land when coming from above
    if(prevBottom <= s.y + 2){
      // NOTE: no edge clamping -> you can walk off naturally
      ent.y = s.y - ent.h;
      ent.vy = 0;
      ent.onGround = true;
      ent.groundSolid = s;
    }
  }
}

   // ✅ REPLACE this entire Movers: one-way top only block inside moveAndCollide(ent, dt):
// (the block that starts with:  // Movers: one-way top only)

if(!ignoreOneWay && ent.vy >= 0){
  const MIN_OVER = 12;
  for(const m of movers){
    const r = {x:m.x,y:m.y,w:m.w,h:m.h};
    if(!aabb(ent, r)) continue;

    const over = overlapX(ent, r);
    if(over < MIN_OVER) continue;

    if(prevBottom <= r.y + 2){
      // NOTE: no edge clamping -> you can walk off movers too
      ent.y = r.y - ent.h;
      ent.vy = 0;
      ent.onGround = true;
      ent.onMoverId = m.id;
      ent.groundSolid = null;
    }
  }
}


    // Sticky rider snap
    if(!ignoreOneWay && ent.vy >= 0){
      const EPS_TOP = 10;
      for(const m of movers){
        const over = overlapX(ent, m);
        if(over < 12) continue;
        const feet = ent.y + ent.h;
        if(feet >= m.y - 2 && feet <= m.y + EPS_TOP){
          ent.y = m.y - ent.h;
          ent.vy = 0;
          ent.onGround = true;
          ent.onMoverId = m.id;
          ent.groundSolid = null;
        }
      }
    }
  }

  // =========================
  // FX / Damage
  // =========================
  function popFX(text,x,y,color){
    fx.push({kind:"text", text, x, y, vy:-40, t:0.9, color});
  }
  function spawnDust(x,y){
    for(let i=0;i<5;i++){
      fx.push({kind:"dust", x:x+rand(-6,6), y:y+rand(-4,2), vx:rand(-120,120), vy:rand(-220,-120), t:0.4});
    }
  }
  function spawnSparkle(x,y){
    for(let i=0;i<10;i++){
      fx.push({kind:"chip", x:x+rand(-6,6), y:y+rand(-8,8), vx:rand(-160,160), vy:rand(-320,-160), t:0.45, theme:"spark"});
    }
  }

  function triggerHolyPlatformBlast(platform){
    if(!platform || platform.kind !== 'blessed' || platform.holySpent) return;
    platform.holySpent = true;
    platform.dead = true;

    const cx = platform.x + platform.w*0.5;
    const cy = platform.y + platform.h*0.5;
    const blastR = 320;

    let vaporized = 0;
    for(const e of enemies){
      if(e.hp <= 0) continue;
      const ex = e.x + e.w*0.5;
      const ey = e.y + e.h*0.5;
      if(Math.hypot(ex-cx, ey-cy) <= blastR){
        e.hp = 0;
        vaporized++;
        spawnSparkle(ex, ey);
      }
    }

    for(let i=0;i<20;i++){
      fx.push({kind:"chip", x:cx+rand(-24,24), y:cy+rand(-14,14), vx:rand(-260,260), vy:rand(-420,-120), t:0.7, theme:"spark"});
    }
    popFX(vaporized>0 ? `HOLY BLAST! x${vaporized}` : "HOLY BLAST!", cx, platform.y-10, "#d4b43d");
    player.vy = Math.min(player.vy, -700);
    player.onGround = false;
    player.groundSolid = null;
  }

  function exitHeaven(success){
    // leave heaven -> return to earth
    realm = "earth";
    setWorld(earthWorld);

    // clear heaven arrays
    heavenWorld.solids.length = 0;
    heavenWorld.movers.length = 0;
    heavenWorld.hazards.length = 0;
    heavenWorld.enemies.length = 0;
    heavenWorld.pickups.length = 0;
    heavenWorld.generatedUntilX = 0;

    if(success){
      const targetSI = heavenEntrySI + HEAVEN_REWARD;
      const targetX = targetSI * SECTION_W + 160;
      ensureGeneratedEarth(targetX + SECTION_W*2.6);

      player.x = targetX;
      const surf = findSurfaceY(player.x) ?? FLOOR_Y;
      player.y = surf - player.h;
      player.vx = 0; player.vy = 0;
      player.invT = 1.15;
      camX = Math.max(camX, player.x - 360);

      const ws = getWorldStage(targetSI);
      if(player.hasAngelWings){
        player.hasAngelWings = false;
        player.hasSandals = true;
        popFX("Wings faded to Sandals", player.x+player.w/2, player.y-12, "#1d56c9");
      }
      showBanner("ASCENSION COMPLETE", `+${HEAVEN_REWARD} Levels → ${ws.world}-${ws.stage} (${ws.region})`, 2.0);
    } else {
      const backX = Math.max(heavenEntryX, camX + 140);
      ensureGeneratedEarth(backX + SECTION_W*1.2);
      player.x = backX;
      const surf = findSurfaceY(player.x) ?? FLOOR_Y;
      player.y = surf - player.h;
      player.vx = 0; player.vy = 0;
      player.invT = 1.05;

      showBanner("HEAVEN FAILED", "Back to Earth", 1.6);
    }
  }

  function enterHeaven(){
    // snapshot where we came from
    const curSI = Math.max(0, Math.floor(player.x / SECTION_W));
    heavenEntrySI = curSI;
    heavenEntryX = player.x;

    const ws = getWorldStage(curSI);
    heavenDiff = heavenDifficulty(ws.world);
    heavenGoalX = player.x + (HEAVEN_LEN_BASE * (0.95 + ws.world*0.06));

    // switch world
    realm = "heaven";
    setWorld(heavenWorld);

    // reset heaven storage
    solids.length = 0; movers.length = 0; hazards.length = 0; enemies.length = 0; pickups.length = 0;
    heavenWorld.generatedUntilX = player.x;

    // place player into the heaven lane (coming up from below feels nice)
    player.y = H - 120;
    player.vy = Math.max(player.vy, 120);
    player.onGround = false;
    player.onMoverId = null;
    player.groundSolid = null;
    player.coyote = 0;
    player.jumpBuf = 0;
    player.dropT = 0;

    showBanner("HEAVEN TRIAL", `Clear to skip +${HEAVEN_REWARD} levels (scales with depth)`, 2.1);
  }

  function takeHit(){
    if(player.invT > 0) return;

    if(player.hasShield){
      player.hasShield = false;
      player.invT = 0.85;
      popFX("Shield broken!", player.x+player.w/2, player.y-10, "#8d6a18");
      return;
    }
    if(player.hasAngelWings){
      player.hasAngelWings = false;
      player.invT = 0.85;
      popFX("Wings torn!", player.x+player.w/2, player.y-10, "#7d5ad6");
      return;
    }
    if(player.hasSandals){
      player.hasSandals = false;
      player.invT = 0.85;
      popFX("Sandals lost!", player.x+player.w/2, player.y-10, "#1d56c9");
      return;
    }
    if(player.hasBread){
      player.hasBread = false;
      player.invT = 0.85;
      popFX("Extra heart gone!", player.x+player.w/2, player.y-10, "#1f7a37");
      return;
    }

    player.hearts -= 1;
    player.invT = 1.05;
    popFX("Ouch!", player.x+player.w/2, player.y-10, "#d33636");

    if(player.hearts <= 0){
      if(realm === "heaven"){
        player.hearts = 3;
        player.hasSandals = player.hasShield = player.hasBread = false;
        exitHeaven(false);
      } else {
        triggerGameOver();
      }
    }
  }

  function respawn(){
    const backX = Math.max(camX + 120, Math.floor(player.x/SECTION_W)*SECTION_W + 140);
    const y = findSurfaceY(backX) ?? FLOOR_Y;
    player.x = backX;
    player.y = y - player.h;
    player.vx = 0; player.vy = 0;
    player.hearts = 3;
    player.hasSandals = false;
    player.hasShield = false;
    player.hasBread = false;
    player.holyLightT = 0;
    player.fireRainShots = 0;
    player.fireRainCd = 0;
    player.invT = 1.2;
    player.dropT = 0;
    popFX("Respawn", player.x+player.w/2, player.y-14, "#0f172a");
  }

  // =========================
  // Pickups
  // =========================
  function applyPickup(kind){
    if(kind==="angelWings"){
      player.hasAngelWings = true;
      player.hasSandals = false;
      popFX("Angel Wings! Quad Jump", player.x+player.w/2, player.y-10, "#7d5ad6");
    } else if(kind==="sandals"){
      player.hasAngelWings = false;
      player.hasSandals = true;
      popFX("Double Jump!", player.x+player.w/2, player.y-10, "#1d56c9");
    } else if(kind==="shield"){
      player.hasShield = true;
      popFX("Shield!", player.x+player.w/2, player.y-10, "#8d6a18");
    } else if(kind==="bread"){
      if(player.hearts < 4){
        player.hearts += 1;
        player.hasBread = true;
        popFX("+1 Heart!", player.x+player.w/2, player.y-10, "#1f7a37");
      } else {
        player.hasBread = true;
        popFX("Strength renewed!", player.x+player.w/2, player.y-10, "#1f7a37");
      }
    } else if(kind==="fireRain"){
      player.fireRainShots = Math.max(player.fireRainShots, 5);
      player.fireRainCd = 0;
      popFX("Raining Fire! 5 enemies burn", player.x+player.w/2, player.y-10, "#d33636");
    } else if(kind==="holyLight"){
      player.holyLightT = Math.max(player.holyLightT, 5);
      popFX("Holy Light! Enemies retreat", player.x+player.w/2, player.y-10, "#d4b43d");
    }
    spawnSparkle(player.x+player.w/2, player.y+player.h/2);
  }

  // =========================
  // Hazards
  // =========================
  function handleHazards(dt){
    for(const h of hazards){
      if(h.kind==="spearTrap"){
        h.t = (h.t||0) + dt;
        const phase = (h.t % h.period)/h.period;
        h.ext = phase < 0.35 ? lerp(0, 1, phase/0.35) : phase < 0.55 ? 1 : lerp(1, 0, (phase-0.55)/0.45);
        const hit = {x:h.x, y:h.y-26, w:h.w, h:26*h.ext};
        if(h.ext > 0.65 && aabb(player, hit)) takeHit();
      }
      if(h.kind==="fireJet"){
        h.t = (h.t||0) + dt;
        const phase = (h.t % h.period)/h.period;
        h.ext = phase < 0.30 ? lerp(0,1,phase/0.30) : phase < 0.55 ? 1 : lerp(1,0,(phase-0.55)/0.45);
        const hit = {x:h.x, y:h.y-40, w:h.w, h:40*h.ext};
        if(h.ext > 0.55 && aabb(player, hit)) takeHit();
      }
      if(h.kind==="spikes" || h.kind==="spikesTop" || h.kind==="lava"){
        const hit = {x:h.x, y:h.y, w:h.w, h:h.h};
        if(aabb(player, hit)) takeHit();
      }
      if(h.kind==="saw"){
        h.t = (h.t||0) + dt*(h.sp||1.7);
        h.x += Math.sin(h.t)*((h.amp||26)*dt);
        const hit = {x:h.x-10, y:h.y-10, w:20, h:20};
        if(aabb(player, hit)) takeHit();
      }
      if(h.kind==="radiant"){
        // Heaven beam: pulses
        h.t = (h.t||0) + dt;
        const phase = (h.t % h.period)/h.period;
        h.on = phase < 0.55;
        if(h.on){
          const hit = {x:h.x, y:h.y, w:h.w, h:h.h};
          if(aabb(player, hit)) takeHit();
        }
      }
    }
  }

  // =========================
  // Enemies
  // =========================
  function makeEnemy(type, x, y, region, diff){
    const base = {x,y, vx:0, vy:0, w:40, h:52, onGround:false, onMoverId:null, groundSolid:null, hp:1, t:rand(0,10), region, type, hurtT:0, patrol:1};
    if(type==="legionary") return Object.assign(base, {w:50,h:62, speed: clamp(130+diff*24,130,240), hp: 1, name:"Legionary"});
    if(type==="centurion") return Object.assign(base, {w:54,h:66, speed: clamp(138+diff*22,138,260), hp: 2, name:"Centurion"});
    if(type==="javelin") return Object.assign(base, {w:52,h:64, speed: clamp(124+diff*18,124,230), hp: 1, ranged:true, cd:rand(0,1.0), name:"Javelin"});
    if(type==="hound") return Object.assign(base, {w:40,h:42, speed: clamp(190+diff*28,190,320), hp: 1, name:"Hound"});
    if(type==="templeGuard") return Object.assign(base, {w:46,h:62, speed: clamp(150+diff*22,150,265), hp: 1, name:"Temple Guard"});
    if(type==="slinger") return Object.assign(base, {w:44,h:60, speed: clamp(132+diff*18,132,240), hp: 1, ranged:true, cd:rand(0,1.1), name:"Slinger"});
    if(type==="zealot") return Object.assign(base, {w:50,h:64, speed: clamp(168+diff*22,168,300), hp: 2, name:"Zealot"});
    if(type==="stoneGolem") return Object.assign(base, {w:64,h:72, speed: clamp(96+diff*14,96,160), hp: 4, heavy:true, name:"Stone Golem"});
    if(type==="imp") return Object.assign(base, {w:44,h:50, speed: clamp(190+diff*26,190,340), hp: 1, name:"Imp"});
    if(type==="fireSkull") return Object.assign(base, {w:42,h:46, speed: clamp(158+diff*22,158,290), hp: 1, hover:true, name:"Fire Skull"});
    if(type==="brimHound") return Object.assign(base, {w:48,h:46, speed: clamp(220+diff*30,220,380), hp: 1, name:"Brim Hound"});
    if(type==="wraith") return Object.assign(base, {w:48,h:62, speed: clamp(170+diff*26,170,320), hp: 2, name:"Wraith"});
    if(type==="warlord") return Object.assign(base, {w:62,h:72, speed: clamp(118+diff*16,118,220), hp: 4, heavy:true, name:"Warlord"});
    if(type==="fallenKnight") return Object.assign(base, {w:58,h:68, speed: clamp(148+diff*24,148,280), hp: 3, ranged:true, cd:rand(0,1.0), name:"Fallen Knight"});

    // Heaven angels
    if(type==="angelV"){
      return Object.assign(base, {
        w:48,h:62, hp: Math.round(2 + diff*0.6),
        angel:true, pattern:"v",
        baseX:x, baseY:y,
        ampY: rndi(60, 120) + diff*18,
        sp: 1.2 + diff*0.25,
        chase: 34 + diff*10,
        name:"Angel"
      });
    }
    if(type==="angelH"){
      return Object.assign(base, {
        w:48,h:62, hp: Math.round(2 + diff*0.6),
        angel:true, pattern:"h",
        baseX:x, baseY:y,
        ampX: rndi(90, 170) + diff*22,
        sp: 1.0 + diff*0.22,
        chase: 30 + diff*10,
        name:"Angel"
      });
    }

    return base;
  }

  function updateEnemies(dt){
    // Earth + Heaven enemies share array, but heaven angels have their own motion.
    for(const e of enemies){
      if(e.hp<=0) continue;
      e.t += dt;
      e.hurtT = Math.max(0, e.hurtT - dt);

      if(e.angel){
        // Float patterns: vertical or horizontal, with mild "pressure" towards player
        const px = player.x + player.w/2;
        const py = player.y + player.h/2;

        if(e.pattern === "v"){
          // y oscillates, x drifts gently toward player
          e.baseX += clamp(px - (e.baseX + e.w/2), -1, 1) * e.chase * dt;
          e.y = e.baseY + Math.sin(e.t * e.sp) * e.ampY;
          e.x = e.baseX;
        } else {
          // x oscillates, y drifts gently toward player
          e.baseY += clamp(py - (e.baseY + e.h/2), -1, 1) * (e.chase*0.55) * dt;
          e.x = e.baseX + Math.sin(e.t * e.sp) * e.ampX;
          e.y = e.baseY;
          // keep angels within screen-ish band so it's fair-ish
          e.y = clamp(e.y, 80, FLOOR_Y-120);
        }

        // Tiny forward drift so angels don't get left behind at high speed
        e.baseX += (0.10 + heavenDiff*0.02) * RUN * dt;

        continue;
      }

      if(e.hover) e.y += Math.sin(e.t*3)*0.10;

      const px = player.x + player.w/2;
      const ex = e.x + e.w/2;
      const d = px - ex;

      let dir = e.patrol || 1;
      if(player.holyLightT > 0 && Math.abs(d) < 460 && Math.abs(player.y - e.y) < 180){
        dir = -sign(d || dir);
      } else if(Math.abs(d) < 280 && Math.abs(player.y - e.y) < 140){
        dir = sign(d);
      }
      if(e.onGround){
        const footX = e.x + (dir>0 ? e.w+4 : -4);
        const surf = findSurfaceY(footX);
        const mySurf = findSurfaceY(e.x + e.w/2);
        if(surf === null || mySurf === null || Math.abs(surf - mySurf) > 44) dir *= -1;
      }
      e.patrol = dir;

      e.vx = dir * e.speed;
      e.vy += GRAV * dt;
      e.vy = Math.min(e.vy, 1500);

      if(e.onMoverId){
        const m = movers.find(mm => mm.id===e.onMoverId);
        if(m){ e.x += m.dx; e.y += m.dy; } else e.onMoverId = null;
      }

      e.dropT = 0;
      moveAndCollide(e, dt);

      if(e.ranged){
        e.cd -= dt;
        if(e.cd <= 0 && Math.abs(d) < 460 && Math.abs(player.y - e.y) < 160){
          e.cd = rand(1.1, 1.9);
          if(e.type==="javelin"){
            hazards.push({x:e.x + (e.patrol>0?e.w: -12), y:e.y+24, w:18, h:6, kind:"proj", vx:e.patrol*560, t:0.9, theme:e.region});
          } else {
            hazards.push({x:e.x + e.w/2, y:e.y+18, w:10, h:10, kind:"orb", vx:e.patrol*460, vy:-200, t:1.1, theme:e.region});
          }
        }
      }

      if(e.hellShooter){
        e.fireCd -= dt;
        if(e.fireCd <= 0){
          const dx = (player.x + player.w*0.5) - (e.x + e.w*0.5);
          const dy = (player.y + player.h*0.45) - (e.y + e.h*0.38);
          const len = Math.hypot(dx, dy) || 1;
          const sp = 440;
          hazards.push({
            x:e.x + e.w*0.5,
            y:e.y + e.h*0.38,
            w:12,
            h:12,
            kind:"fireball",
            vx:(dx/len)*sp,
            vy:(dy/len)*sp,
            t:1.8,
            theme:"Hell"
          });
          e.fireCd = rand(1.3, 2.2);
        }
      }
    }

    // projectiles (earth)
    for(let i=hazards.length-1;i>=0;i--){
      const h = hazards[i];
      if(h.kind==="proj"){
        h.x += h.vx * dt;
        h.t -= dt;
        const hit = {x:h.x, y:h.y-6, w:h.w, h:h.h+12};
        if(aabb(player, hit)) takeHit();
        if(h.t<=0) hazards.splice(i,1);
      }
      if(h.kind==="orb"){
        h.vy += 950*dt;
        h.x += h.vx * dt;
        h.y += h.vy * dt;
        h.t -= dt;
        const hit = {x:h.x-4, y:h.y-4, w:h.w+8, h:h.h+8};
        if(aabb(player, hit)) takeHit();
        if(h.y > FLOOR_Y+240 || h.t<=0) hazards.splice(i,1);
      }
      if(h.kind==="fireball"){
        h.x += h.vx * dt;
        h.y += h.vy * dt;
        h.t -= dt;
        const hit = {x:h.x-6, y:h.y-6, w:h.w+12, h:h.h+12};
        if(aabb(player, hit)){
          takeHit();
          hazards.splice(i,1);
          continue;
        }
        if(h.t<=0) hazards.splice(i,1);
      }
    }

    // stomp / contact (works for angels too)
    for(const e of enemies){
      if(e.hp<=0) continue;

      if(!e.angel){
        const topHit = { x:e.x+6, y:e.y-7, w:e.w-12, h:12 };
        const pFeet  = { x:player.x+7, y:player.y+player.h-7, w:player.w-14, h:12 };

        if(aabb(pFeet, topHit) && player.vy > 120){
          e.hp -= 1;
          e.hurtT = 0.25;
          player.vy = -Math.max(560, JUMP_V*0.55);
          spawnSparkle(e.x+e.w/2, e.y+12);
          popFX("Stomp!", e.x+e.w/2, e.y-10, "#0f172a");
          continue;
        }
      }

      if(aabb(player, e) && player.invT<=0){
        takeHit();
        player.vx = -sign((player.x+player.w/2)-(e.x+e.w/2)) * 420;
        player.vy = -560;
      }
    }
  }

  // =========================
  // Generation — Earth (harder deeper + chasms with movers past level 3)
  // =========================
  function ensureGeneratedEarth(targetX){
    setWorld(earthWorld);
    while(earthWorld.generatedUntilX < targetX){
      genEarthSection(earthWorld.generatedUntilX);
    }
  }

  function spawnEnemiesForEarthSection(startX, endX, world, stage, region, diff){
    const depthBoost = (world-1)*0.9;
    const baseCount = rndi(7, 11) + Math.floor(diff*1.5) + Math.floor(depthBoost);

    for(let i=0;i<baseCount;i++){
      const ex = rand(startX+260, endX-240);
      const ySurf = findSurfaceY(ex);
      if(ySurf === null) continue;

      let type = "legionary";
      if(region==="Rome"){
        const pool = [
          {t:"legionary", w:1.00},
          {t:"hound", w:0.58},
          ...(world>=3 ? [{t:"centurion", w:0.38}] : []),
          ...(world>=4 ? [{t:"javelin", w:0.28}] : []),
        ];
        type = weightedPick(pool);
      } else if(region==="Jerusalem"){
        const pool = [
          {t:"templeGuard", w:0.90},
          {t:"slinger", w:0.50},
          ...(world>=3 ? [{t:"zealot", w:0.36}] : []),
          ...(world>=4 ? [{t:"stoneGolem", w:0.22}] : []),
        ];
        type = weightedPick(pool);
      } else {
        const pool = [
          {t:"imp", w:0.90},
          {t:"fireSkull", w:0.60},
          ...(world>=3 ? [{t:"brimHound", w:0.34}] : []),
          ...(world>=4 ? [{t:"wraith", w:0.26}] : []),
          ...(world>=5 ? [{t:"fallenKnight", w:0.22}] : []),
          ...(world>=6 ? [{t:"warlord", w:0.18}] : []),
        ];
        type = weightedPick(pool);
      }

      const enemy = makeEnemy(type, ex, ySurf-44, region, diff);
      if(region === "Hell" && world >= 5 && !enemy.angel){
        enemy.hellShooter = true;
        enemy.fireCd = rand(0.45, 1.55);
      }
      placeEnemy(enemy);

      // more traps deeper
      if(world>=2 && region==="Rome" && Math.random()<0.12*diff){
        placeHazard({x:ex+rand(-150,150), y:ySurf-14, w:36, h:14, kind:"spearTrap", theme:region, t:rand(0,10), period:rand(1.25,1.95)});
      }
      if(region==="Hell" && world>=3 && Math.random()<0.14*diff){
        placeHazard({x:ex+rand(-160,160), y:ySurf-12, w:30, h:12, kind:"fireJet", theme:region, t:rand(0,10), period:rand(0.95,1.55)});
      }
    }
  }

  function genEarthSection(startX){
    setWorld(earthWorld);

    const si = earthWorld.sectionIndex;
    const {world, stage, region} = getWorldStage(si);
    const diff = difficultyScalar(world, stage);
    const endX = startX + SECTION_W;

    // --- ground with pits + “chasms with moving platforms” past level 3
    const groundH = 80;
    let x = startX;

    // More chasms and bigger pits deeper
    const deep = (si >= 3); // “past level 3”
    const pitChanceBase = (region==="Hell"?0.26:region==="Jerusalem"?0.18:0.14);
    const pitChance = clamp(pitChanceBase * (0.95 + diff*0.35) * (deep?1.20:1.0), 0.10, 0.62);

    while(x < endX){
      const segW = rndi(deep ? 260 : 320, deep ? 520 : 560);
      let gapW = 0;
      let chasm = false;

      if(Math.random() < pitChance){
        // deeper = longer gaps; some become “chasm bridges” that REQUIRE movers
        if(deep && Math.random() < (0.55 + diff*0.05)){
          chasm = true;
          gapW = rndi(Math.floor(SAFE_GAP*1.05), Math.floor(SAFE_GAP*1.85)); // too far to clear cleanly
          gapW = clamp(gapW, 240, 520);
        } else {
          gapW = rndi(80, Math.floor(SAFE_GAP*0.85));
        }
      }

      const g = { x, y: FLOOR_Y, w: Math.min(segW, endX-x), h: groundH, kind:'ground', theme: region };
      placeSolid(g);

      if(gapW > 0){
        const pitX = x + g.w;
        const pitW = gapW;

        if(region==="Hell"){
          placeHazard({x:pitX, y:FLOOR_Y+18, w:pitW, h:groundH-18, kind:'lava', theme:region});
        } else if(world>=2 && Math.random()<0.40*diff){
          placeHazard({x:pitX+12, y:FLOOR_Y+18, w:Math.max(24, pitW-24), h:22, kind:'spikes', theme:region});
        }

        if(chasm){
          // Build moving-platform bridge inside the pit
          const n = clamp(3 + Math.floor(diff*0.7), 3, 5);
          for(let j=0;j<n;j++){
            const mw = rndi(140, 210) - Math.floor(diff*6);
            const mh = 18;
            const frac = (j+1)/(n+1);
            const mx = pitX + frac*pitW - mw/2;
            const my = rndi(250, 365) - Math.floor(diff*6);

            const kindRoll = Math.random();
            const kind = (kindRoll<0.40) ? "horiz" : (kindRoll<0.70) ? "loop" : "elevator";
            const ax = (kind==="elevator") ? rndi(18, 70) : rndi(70, 150);
            const ay = (kind==="horiz") ? rndi(12, 44) : rndi(50, 140);
            const sp = clamp(0.95 + diff*0.25 + rand(-0.10,0.10), 0.95, 1.75);

            const m = { x:mx, y:my, w:mw, h:mh, baseX:mx, baseY:my, ax, ay, sp, kind, theme: region };
            const sweep = moverSweepBox(m, 34);
            if(canPlaceRect(sweep, 0)) placeMover(m);
          }

          // occasional “ascension elevator” to make Heaven reachable
          if(deep && Math.random() < 0.14){
            const mw = 200, mh = 18;
            const mx = pitX + pitW*0.5 - mw/2;
            const topY = 86;
            const baseY = rndi(290, 360);
            const ay = Math.max(90, baseY - topY);
            const m = { x:mx, y:baseY, w:mw, h:mh, baseX:mx, baseY:baseY, ax:20, ay:ay, sp: clamp(0.90+diff*0.18,0.9,1.4), kind:"elevator", theme: region };
            const sweep = moverSweepBox(m, 34);
            if(canPlaceRect(sweep, 0)) placeMover(m);
          }
        }
      }

      x += g.w + gapW;
    }

    // --- raised platforms (harder deeper = slightly smaller + more traps)
    const platCount = rndi(deep?7:6, deep?10:9) + Math.floor(diff*0.9);
    for(let i=0;i<platCount;i++){
      const pw = rndi(deep?140:160, deep?320:340);
      const ph = 20;
      const px = rand(startX+260, endX-260-pw);
      const py = rand(deep?230:250, deep?390:395);
      const r = {x:px, y:py, w:pw, h:ph, kind:'platform', theme:region, style:(region==="Rome"?"marble":region==="Jerusalem"?"stone":"obsidian")};
      if(!canPlaceRect(r, 18)) continue;
      placeSolid(r);

      const trapChance = (region==="Hell"?0.34:region==="Jerusalem"?0.24:0.18) * clamp(0.8 + diff*0.35, 0.8, 1.7);
      if(Math.random() < trapChance){
        const safeZone = 82;
        if(pw > safeZone+90){
          const spikesW = rndi(54, 110);
          const sx = (Math.random()<0.5) ? (px+12) : (px+pw-12-spikesW);
          placeHazard({x:sx, y:py-16, w:spikesW, h:16, kind:'spikesTop', theme:region});
        }
      }
      if(world>=2 && Math.random() < 0.16*diff){
        placeHazard({x:px+pw*0.5, y:py-14, kind:'saw', amp:rndi(10,30), sp:rand(1.0,2.1), t:rand(0,10), theme:region});
      }

      if(world>=2 && Math.random() < 0.18){
        const kind = Math.random()<0.5 ? 'slippery' : 'blessed';
        const sw = rndi(120, 220);
        const sx = px + rand(0, Math.max(8,pw-sw));
        const sr = {x:sx, y: py - rndi(68,118), w: sw, h: 18, kind, theme:region, baseX:sx, slideT:rand(0,Math.PI*2), holyCharge:0, holySpent:false};
        if(canPlaceRect(sr, 16)) placeSolid(sr);
      }
    }

    // --- movers (more + faster deeper)
    const moverCount = rndi(deep?5:4, deep?8:6) + Math.floor(diff*1.0);
    for(let i=0;i<moverCount;i++){
      const mw = rndi(150, 250);
      const mh = 18;
      const mx = rand(startX+380, endX-380-mw);
      const my = rand(deep?220:250, deep?390:390);

      const kindRoll = Math.random();
      const kind = (kindRoll<0.30) ? "horiz" : (kindRoll<0.55) ? "elevator" : (kindRoll<0.82) ? "loop" : "drift";
      const ax = (kind==="elevator") ? rndi(20, 80) : rndi(90, 200);
      const ay = (kind==="horiz") ? rndi(10, 55) : rndi(80, 170);
      const sp = clamp(0.95 + diff*0.25 + rand(-0.10,0.10), 0.95, 1.85);

      const m = { x:mx, y:my, w:mw, h:mh, baseX:mx, baseY:my, ax, ay, sp, kind, theme:region };
      const sweep = moverSweepBox(m, 34);
      if(!canPlaceRect(sweep, 0)) continue;
      placeMover(m);

      if(world>=2 && Math.random()<0.30){
        placePickup({x: mx + mw*0.45, y: my - 54, w: 22, h: 22, kind: (Math.random()<0.5?"sandals":"shield"), theme:region, bobT: rand(0,10)});
      }
    }

    // --- crumble platforms (more likely deeper)
    if(region==="Jerusalem" || (region==="Hell" && world>=2) || (world>=3 && Math.random()<0.25)){
      const crumbleCount = rndi(3, 6) + Math.floor(diff*0.8);
      for(let i=0;i<crumbleCount;i++){
        const pw = rndi(140, 240);
        const ph = 20;
        const px = rand(startX+340, endX-340-pw);
        const py = rand(235, 380);
        if(py > FLOOR_Y-110) continue;

        const r = {x:px, y:py, w:pw, h:ph, kind:'crumble', theme:region, cr:1.0, crDelay:0.28, crTime:1.15, crActive:false, crShake:0, dead:false};
        if(!canPlaceRect(r, 18)) continue;
        placeSolid(r);
      }
    }

    // --- enemies
    spawnEnemiesForEarthSection(startX, endX, world, stage, region, diff);

    // --- powerup
    if(Math.random()<0.70){
      const weightedKinds = [
        {kind:"bread", w:1.0},
        {kind:"sandals", w:0.82},
        {kind:"shield", w:0.78},
        ...(world>=2?[{kind:"holyLight", w:0.62}]:[]),
        ...(world>=3?[{kind:"fireRain", w:0.48}]:[]),
        ...(world>=2?[{kind:"angelWings", w:0.18}]:[]),
      ];
      const total = weightedKinds.reduce((sum, it)=>sum+it.w, 0);
      let roll = Math.random()*total;
      let kind = weightedKinds[0].kind;
      for(const it of weightedKinds){
        roll -= it.w;
        if(roll<=0){ kind = it.kind; break; }
      }
      placePickup({x: rand(startX+450, endX-450), y: rand(210, 320), w: 24, h: 24, kind, theme:region, bobT: rand(0,10)});
    }

    solids = solids.filter(s => (s.kind==='ground') || !hitsAnyMoverSweep(s));

    showBannerForSection(earthWorld.sectionIndex);
    earthWorld.sectionIndex++;
    earthWorld.generatedUntilX = endX;
  }

  function weightedPick(items){
    let sum = 0;
    for(const it of items) sum += it.w;
    let r = Math.random()*sum;
    for(const it of items){
      r -= it.w;
      if(r<=0) return it.t;
    }
    return items[0].t;
  }

  // =========================
  // Generation — Heaven (hard, scales, clears -> +5 levels)
  // =========================
  function ensureGeneratedHeaven(targetX){
    setWorld(heavenWorld);
    while(heavenWorld.generatedUntilX < targetX){
      genHeavenChunk(heavenWorld.generatedUntilX);
    }
  }

  function genHeavenChunk(startX){
    setWorld(heavenWorld);
    const endX = startX + 1600;

    // clouds are one-way platforms; no permanent ground
    const baseCount = 12 + Math.floor(heavenDiff*4.2);
    for(let i=0;i<baseCount;i++){
      const pw = rndi(120, 240) - Math.floor(heavenDiff*6);
      const ph = 20;
      const px = rand(startX+140, endX-140-pw);
      const py = rand(120, 410);

      const r = {x:px, y:py, w:pw, h:ph, kind:'cloud', theme:HEAVEN, dead:false};
      if(!canPlaceRect(r, 14)) continue;
      placeSolid(r);
    }

    // moving clouds (mandatory later)
    const moverCount = 4 + Math.floor(heavenDiff*2.0);
    for(let i=0;i<moverCount;i++){
      const mw = rndi(130, 220) - Math.floor(heavenDiff*5);
      const mh = 18;
      const mx = rand(startX+180, endX-180-mw);
      const my = rand(120, 400);

      const kindRoll = Math.random();
      const kind = (kindRoll<0.34) ? "horiz" : (kindRoll<0.62) ? "loop" : "elevator";
      const ax = (kind==="elevator") ? rndi(18, 85) : rndi(90, 210);
      const ay = (kind==="horiz") ? rndi(14, 60) : rndi(80, 170);
      const sp = clamp(1.05 + heavenDiff*0.22 + rand(-0.08,0.08), 1.05, 2.25);

      const m = { x:mx, y:my, w:mw, h:mh, baseX:mx, baseY:my, ax, ay, sp, kind, theme:HEAVEN };
      const sweep = moverSweepBox(m, 34);
      if(!canPlaceRect(sweep, 0)) continue;
      placeMover(m);
    }

    // radiant beams (heaven hazards) scale up
    const beamChance = clamp(0.10 + heavenDiff*0.06, 0.10, 0.42);
    if(Math.random() < beamChance){
      const bx = rand(startX+220, endX-220);
      const bw = rndi(18, 34);
      placeHazard({
        kind:"radiant",
        x:bx, y:0, w:bw, h:FLOOR_Y-40,
        t:rand(0,10),
        period: clamp(1.25 - heavenDiff*0.08, 0.70, 1.25),
        theme:HEAVEN
      });
    }

    // angels (very difficult)
    const angelCount = 6 + Math.floor(heavenDiff*4.0);
    for(let i=0;i<angelCount;i++){
      const ex = rand(startX+220, endX-220);
      const ey = rand(90, 390);
      const type = (Math.random()<0.5) ? "angelV" : "angelH";
      const e = makeEnemy(type, ex, ey, HEAVEN, heavenDiff);
      placeEnemy(e);
    }

    // sparse powerups to tempt risk
    if(Math.random() < 0.24){
      const heavens = [
        {kind:"shield", w:0.8},
        {kind:"sandals", w:0.7},
        {kind:"holyLight", w:0.55},
        {kind:"fireRain", w:0.5},
        {kind:"angelWings", w:0.12},
      ];
      const total = heavens.reduce((sum, it)=>sum+it.w, 0);
      let roll = Math.random()*total;
      let kind = heavens[0].kind;
      for(const it of heavens){
        roll -= it.w;
        if(roll<=0){ kind = it.kind; break; }
      }
      placePickup({x: rand(startX+240, endX-240), y: rand(120, 260), w: 24, h: 24, kind, theme:HEAVEN, bobT: rand(0,10)});
    }

    solids = solids.filter(s => !hitsAnyMoverSweep(s));
    heavenWorld.generatedUntilX = endX;
  }

  // =========================
  // HUD
  // =========================
  function renderHUD(){
    const si = Math.max(0, Math.floor(player.x / SECTION_W));
    const ws = getWorldStage(si);

    if(realm === "heaven"){
      uiRegion.textContent = "Heaven";
      uiLevel.textContent = `HEAVEN`;
    } else {
      uiRegion.textContent = ws.region;
      uiLevel.textContent  = `${ws.world}-${ws.stage}`;
    }

    uiDist.textContent = Math.floor(player.x/10).toString();
    uiHearts.textContent = player.hearts.toString();

    uiHeartsIcons.innerHTML = "";
    for(let i=0;i<player.hearts;i++){
      const span = document.createElement('span');
      span.className = "heart";
      span.style.marginLeft = "6px";
      uiHeartsIcons.appendChild(span);
    }

    uiPower.innerHTML = "";
    const addPow = (label, cls, kind) => {
      const d = document.createElement('div');
      d.className = "pow";
      d.innerHTML = `<span class="icon ${cls}" data-kind="${kind}"></span><b>${label}</b>`;
      uiPower.appendChild(d);
      const icon = d.querySelector('.icon');
      const c = document.createElement('canvas');
      c.width = c.height = 20;
      icon.appendChild(c);
      drawPowerIcon(c.getContext('2d'), kind);
    };
    if(player.hasAngelWings) addPow("Angel Wings (Quad Jump)", "ic-blue", "angelWings");
    if(player.hasSandals) addPow("Holy Sandals (Double Jump)", "ic-blue", "sandals");
    if(player.hasShield)  addPow("Shield (1 hit)", "ic-gold", "shield");
    if(player.hasBread)   addPow("Loaves & Fish (+1 heart)", "ic-green", "bread");
    if(player.holyLightT > 0) addPow(`Holy Light (${player.holyLightT.toFixed(1)}s)`, "ic-gold", "holyLight");
    if(player.fireRainShots > 0) addPow(`Raining Fire (${player.fireRainShots} left)`, "ic-gold", "fireRain");

    if(realm==="heaven"){
      const d = document.createElement('div');
      d.className = "pow";
      d.innerHTML = `<span class="icon ic-heaven"></span><b>Goal:</b> <span style="color:var(--muted)">reach the end → +${HEAVEN_REWARD} levels</span>`;
      uiPower.appendChild(d);
    }
  }

  // =========================
  // Update loop
  // =========================
  function update(dt){
	if (GAME_OVER) return;
    // generate ahead in current realm
    if(realm === "heaven"){
      ensureGeneratedHeaven(player.x + 1600);
    } else {
      ensureGeneratedEarth(player.x + SECTION_W*2.6);
    }

    // camera forward-only-ish
    const targetCam = player.x - 360;
    camX = Math.max(camX, targetCam);
    camX = Math.max(0, camX);

    // never go too far back
    const leftBound = camX + 90;
    if(player.x < leftBound){
      player.x = leftBound;
      if(player.vx < 0) player.vx = 0;
    }

    // movers
    for(const m of movers){
      const prevX = m.x, prevY = m.y;
      m.t += dt * m.sp;

      let nx=m.x, ny=m.y;
      if(m.kind==='horiz'){
        nx = m.baseX + Math.sin(m.t) * (m.ax||0);
        ny = m.baseY + Math.cos(m.t*0.9) * (m.ay||0);
      } else if(m.kind==='elevator'){
        nx = m.baseX + Math.sin(m.t*0.7) * (m.ax||0);
        ny = m.baseY + Math.sin(m.t) * (m.ay||0);
      } else if(m.kind==='loop'){
        nx = m.baseX + Math.cos(m.t) * (m.ax||0);
        ny = m.baseY + Math.sin(m.t) * (m.ay||0);
      } else {
        nx = m.baseX + Math.sin(m.t) * (m.ax||0);
        ny = m.baseY + Math.sin(m.t*0.8 + 1.2) * (m.ay||0);
      }

      const test = {x:nx,y:ny,w:m.w,h:m.h};
      let bad = false;
      for(const s of solids){
        if(s.dead) continue;
        if(aabb(test, s)){ bad = true; break; }
      }
      if(!bad){
        m.x = nx; m.y = ny;
      } else {
        m.x = prevX; m.y = prevY;
        m.t += 0.35;
      }

      m.dx = (m.x - prevX);
      m.dy = (m.y - prevY);
      m.vx = m.dx/dt;
      m.vy = m.dy/dt;
    }

    // special one-way platforms
    for(const s of solids){
      if(s.dead) continue;
      if(s.kind==='slippery'){
        const wasX = s.x;
        const active = player.onGround && player.groundSolid===s;
        s.slideT = (s.slideT || 0);
        if(active) s.slideT += dt * 1.8;
        if(active){
          const swing = 66;
          s.x = (s.baseX ?? s.x) + Math.sin(s.slideT) * swing;
        }
        s.dx = s.x - wasX;
        if(active && Math.abs(s.dx) > 0.0001){
          player.x += s.dx;
        }
      } else if(s.kind==='blessed'){
        const active = player.onGround && player.groundSolid===s;
        if(active){
          s.holyCharge = (s.holyCharge || 0) + dt;
          if(s.holyCharge > 1.45){
            triggerHolyPlatformBlast(s);
          }
        } else {
          s.holyCharge = Math.max(0, (s.holyCharge || 0) - dt*0.55);
        }
      }
    }

    // carry player if riding mover
    if(player.onMoverId){
      const m = movers.find(mm => mm.id === player.onMoverId);
      if(m){
        player.x += m.dx;
        player.y += m.dy;
      } else {
        player.onMoverId = null;
      }
    }

    // drop timer
    player.dropT = Math.max(0, player.dropT - dt);

    // input
    const wantL = mobileInput.xAxis < -0.25 || kDown('a') || kDown('arrowleft');
    const wantR = mobileInput.xAxis > 0.25 || kDown('d') || kDown('arrowright');
    const wantDown = downHeld();

    let ax = 0;
    if(wantL) ax -= 1;
    if(wantR) ax += 1;
    if(ax !== 0) player.facing = sign(ax);

    // accel / friction
    const onSlippery = player.onGround && player.groundSolid && player.groundSolid.kind==='slippery';
    const onBlessed = player.onGround && player.groundSolid && player.groundSolid.kind==='blessed';
    const accel = player.onGround ? (onSlippery ? ACC_GROUND*0.82 : ACC_GROUND) : ACC_AIR;
    const maxSp = player.onGround ? (onBlessed ? RUN*1.10 : RUN) : RUN*AIR_MAX;

    if(ax !== 0 && Math.sign(player.vx) !== 0 && Math.sign(player.vx) !== ax){
      player.vx *= 0.90;
      player.vx += ax * accel * dt * 0.35;
    }

    player.vx += ax * accel * dt;
    player.vx = clamp(player.vx, -maxSp, maxSp);

    const fric = player.onGround ? (onSlippery ? FRICTION_GROUND*0.35 : FRICTION_GROUND) : FRICTION_AIR;
    player.vx *= Math.exp(-fric*dt);

    // jump buffer + coyote
    if(jumpJustPressed()) player.jumpBuf = 0.16;
    else player.jumpBuf = Math.max(0, player.jumpBuf - dt);

    if(player.onGround) player.coyote = 0.12;
    else player.coyote = Math.max(0, player.coyote - dt);

    if(player.onGround){
      player.jumpsLeft = player.hasAngelWings ? 3 : (player.hasSandals ? 1 : 0);
    }

    // drop through one-way
    if(player.onGround && wantDown){
      const onOneWay = (player.groundSolid && isOneWay(player.groundSolid)) || (player.onMoverId != null);
      if(onOneWay){
        player.dropT = 0.22;
        player.onGround = false;
        player.onMoverId = null;
        player.groundSolid = null;
        player.y += 2;
        player.vy = Math.max(player.vy, 160);
        spawnDust(player.x+player.w/2, player.y+player.h);
      }
    }

    // jump if buffered
    if(player.jumpBuf > 0){
      const canGroundJump = (player.coyote > 0);
      const canAirJump = (!canGroundJump && player.jumpsLeft > 0);

      if(canGroundJump || canAirJump){
        player.jumpBuf = 0;
        if(canGroundJump) player.coyote = 0;
        else {
          player.jumpsLeft = Math.max(0, player.jumpsLeft - 1);
          popFX("Hop!", player.x+player.w/2, player.y-10, "#1d56c9");
        }

        player.vy = -(onBlessed ? JUMP_V*1.08 : JUMP_V);
        player.vx += player.facing * 55;
        spawnDust(player.x+player.w/2, player.y+player.h);
      }
    }

    // gravity + variable jump
    player.vy += GRAV * dt;
    if(player.vy < 0 && !jumpHeld()){
      player.vy += GRAV * 0.95 * dt;
    }
    player.vy = Math.min(player.vy, 1600);

    // collide
    moveAndCollide(player, dt);

    // crumble logic
    if(player.onGround && player.groundSolid && player.groundSolid.kind === 'crumble'){
      const s = player.groundSolid;
      if(!s.dead){
        s.crDelay = Math.max(0, (s.crDelay ?? 0.28) - dt);
        s.crShake = Math.min(1, (s.crShake||0) + dt*2.4);
        if(s.crDelay === 0){
          s.crActive = true;
          s.cr = (s.cr ?? 1.0) - dt*(1.0/(s.crTime ?? 1.15));
          if(s.cr <= 0){
            s.dead = true;
            popFX("CRUMBLE!", s.x+s.w/2, s.y-8, "#7c2d12");
            for(let i=0;i<8;i++){
              fx.push({kind:"chip", x:s.x+rand(8,s.w-8), y:s.y+rand(2,12), vx:rand(-90,90), vy:rand(-240,-90), t:0.6, theme:s.theme});
            }
          }
        }
      }
    } else {
      for(const s of solids){
        if(s.kind==='crumble' && !s.dead && !s.crActive){
          s.crDelay = Math.min(0.28, (s.crDelay ?? 0.28) + dt*0.35);
          s.crShake = Math.max(0, (s.crShake||0) - dt*1.6);
        }
      }
    }

    // invuln
    player.invT = Math.max(0, player.invT - dt);

    // arms
    const moving = Math.abs(player.vx) > 60;
    player.armT += dt * (moving ? 12 : 3);

    // hazards
    handleHazards(dt);

    // pickups
    for(let i=pickups.length-1;i>=0;i--){
      const p = pickups[i];
      p.bobT = (p.bobT||0) + dt*3;
      const r = {x:p.x, y:p.y + Math.sin(p.bobT)*5, w:p.w, h:p.h};
      if(aabb(player, r)){
        applyPickup(p.kind);
        pickups.splice(i,1);
      }
    }

    // enemies
    updateEnemies(dt);

    if(player.holyLightT > 0) player.holyLightT = Math.max(0, player.holyLightT - dt);
    if(player.fireRainShots > 0){
      player.fireRainCd -= dt;
      if(player.fireRainCd <= 0){
        const target = enemies
          .filter(e=>e.hp>0)
          .sort((a,b)=>Math.abs((a.x+a.w*0.5)-(player.x+player.w*0.5)) - Math.abs((b.x+b.w*0.5)-(player.x+player.w*0.5)))[0];
        if(target){
          target.hp = 0;
          spawnSparkle(target.x+target.w/2, target.y+target.h/2);
          popFX("Holy fire!", target.x+target.w/2, target.y-8, "#d33636");
          player.fireRainShots -= 1;
          player.fireRainCd = 0.32;
        } else {
          player.fireRainCd = 0.12;
        }
      }
    }

    // Heaven entry: jump above ceiling in earth
    if(realm === "earth" && player.y < -34){
      enterHeaven();
    }

    // Heaven win condition
    if(realm === "heaven" && player.x > heavenGoalX){
      exitHeaven(true);
    }

    gameScore = Math.max(gameScore, Math.floor(player.x/10));

    // fall out
    if(player.y > H + 240){
      if(realm === "heaven"){
        exitHeaven(false);
      } else {
        takeHit();
        player.y = FLOOR_Y - player.h;
        player.vy = 0;
      }
    }

    // prune behind (per-realm)
    const killX = camX - 600;
    solids = solids.filter(s => (s.x + s.w > killX) && !s.dead);
    hazards = hazards.filter(h => h.x + h.w > killX);
    enemies = enemies.filter(e => e.x + e.w > killX && e.hp > 0);
    pickups = pickups.filter(p => p.x + p.w > killX);

    // fx
    for(let i=fx.length-1;i>=0;i--){
      const f = fx[i];
      f.t -= dt;
      if(f.kind==="text"){
        f.y += f.vy * dt;
        f.vy += 80*dt;
      } else if(f.kind==="chip"){
        f.x += f.vx*dt;
        f.y += f.vy*dt;
        f.vy += 1400*dt;
      } else if(f.kind==="dust"){
        f.x += f.vx*dt;
        f.y += f.vy*dt;
        f.vy += 420*dt;
      }
      if(f.t <= 0) fx.splice(i,1);
    }

    // banner fade
    if(bannerT > 0){
      bannerT -= dt;
      banner.style.opacity = bannerT > 0.9 ? "1" : String(clamp(bannerT/0.9, 0, 1));
    } else banner.style.opacity = "0";

    renderHUD();
  }

  // =========================
  // Draw
  // =========================
  function draw(){
    const si = Math.max(0, Math.floor(player.x / SECTION_W));
    const {world, stage, region} = getWorldStage(si);

    if(realm === "heaven"){
      drawBackdrop(HEAVEN, world, stage);
    } else {
      drawBackdrop(region, world, stage);
    }

    ctx.save();
    ctx.translate(-camX, 0);

    drawHazards();

    for(const s of solids){
      if(s.dead) continue;
      drawPlatform(s);
    }
    for(const m of movers) drawMover(m);
    for(const p of pickups) drawPickup(p);
    for(const e of enemies){
      if(e.hp<=0) continue;
      drawEnemy(e);
    }

    drawJesus(player);

    for(const f of fx){
      if(f.kind==="text"){
        ctx.globalAlpha = clamp(f.t/0.9,0,1);
        ctx.font = "900 14px ui-sans-serif, system-ui";
        ctx.fillStyle = f.color || "#0f172a";
        ctx.textAlign = "center";
        ctx.fillText(f.text, f.x, f.y);
        ctx.globalAlpha = 1;
      } else if(f.kind==="chip"){
        ctx.globalAlpha = clamp(f.t/0.65,0,1);
        ctx.fillStyle = f.theme==="spark" ? "rgba(255,215,120,.95)" :
                        f.theme==="Hell" ? "rgba(255,120,80,.9)" :
                        f.theme===HEAVEN ? "rgba(255,255,255,.92)" :
                        "rgba(120,85,55,.9)";
        ctx.fillRect(f.x, f.y, 4, 4);
        ctx.globalAlpha = 1;
      } else if(f.kind==="dust"){
        ctx.globalAlpha = clamp(f.t/0.4,0,1);
        ctx.fillStyle = "rgba(120,120,120,.35)";
        ctx.beginPath(); ctx.arc(f.x,f.y,3,0,Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
      }
    }
    ctx.restore();
  }

  // =========================
  // Backdrops
  // =========================
  function drawBackdrop(region, world, stage){
    let top="#eaf3ff", mid="#f7fbff", bot="#ffffff";

    if(region==="Jerusalem"){ top="#f5f8ff"; mid="#fffdf8"; bot="#ffffff"; }
    if(region==="Hell"){ top="#3b0b0f"; mid="#18070a"; bot="#0b0607"; }
    if(region===HEAVEN){ top="#cfe8ff"; mid="#f4fbff"; bot="#ffffff"; }

    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, top);
    g.addColorStop(0.55, mid);
    g.addColorStop(1, bot);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    const p1 = camX*0.18;
    const p2 = camX*0.32;

    if(region==="Rome"){
      drawRomeCity(p2, 0.22);
      drawRomePillars(p1, 0.42);
      drawRomeArches(p1*1.08, 0.20);
    } else if(region==="Jerusalem"){
      drawJerusalemHills(p2, 0.20);
      drawJerusalemWalls(p1, 0.44);
    } else if(region==="Hell"){
      drawHellRidges(p2, 0.22);
      drawHellGlow(p1, 0.50);
    } else {
      drawHeavenClouds(p2, 0.26);
      drawHeavenRays(p1, 0.20);
    }

    const vg = ctx.createRadialGradient(W/2,H/2,40,W/2,H/2,Math.max(W,H));
    vg.addColorStop(0, "rgba(0,0,0,0)");
    vg.addColorStop(1, region==="Hell" ? "rgba(0,0,0,.25)" : "rgba(0,0,0,.07)");
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,W,H);
  }

  function drawHeavenClouds(px, alpha){
    ctx.save();
    ctx.globalAlpha = alpha;
    const yBase = 170;
    for(let i=0;i<16;i++){
      const x = (i*170 - (px%170)) - 80;
      const y = yBase + (i%4)*44;
      ctx.fillStyle = "rgba(255,255,255,.95)";
      ctx.beginPath();
      ctx.ellipse(x+70,y,60,22,0,0,Math.PI*2);
      ctx.ellipse(x+110,y-10,52,18,0,0,Math.PI*2);
      ctx.ellipse(x+30,y-8,42,16,0,0,Math.PI*2);
      ctx.fill();
      ctx.fillStyle = "rgba(15,23,42,.07)";
      ctx.beginPath();
      ctx.ellipse(x+80,y+10,70,20,0,0,Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }
  function drawHeavenRays(px, alpha){
    ctx.save();
    ctx.globalAlpha = alpha;
    const cx = W*0.72, cy = 40;
    for(let i=0;i<10;i++){
      const ang = (i/10)*Math.PI*2 + (px*0.0006);
      const x1 = cx + Math.cos(ang)*20, y1 = cy + Math.sin(ang)*20;
      const x2 = cx + Math.cos(ang)*520, y2 = cy + Math.sin(ang)*520;
      ctx.strokeStyle = "rgba(255,215,120,.15)";
      ctx.lineWidth = 18;
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    }
    ctx.restore();
  }

  function drawRomeCity(px, alpha){
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = "rgba(120,140,170,.34)";
    const yBase = 340;
    for(let i=0;i<18;i++){
      const x = (i*140 - (px%140)) - 80;
      const w = 112;
      const h = 62 + (i%3)*22;
      ctx.fillRect(x, yBase-h, w, h);
      ctx.beginPath(); ctx.arc(x+w*0.5, yBase-h, 26, Math.PI, 0); ctx.fill();
      ctx.globalAlpha = alpha*0.55;
      ctx.fillStyle = "rgba(255,255,255,.55)";
      for(let k=0;k<5;k++) ctx.fillRect(x+12+k*20, yBase-h+18, 8, 10);
      ctx.globalAlpha = alpha;
      ctx.fillStyle = "rgba(120,140,170,.34)";
    }
    ctx.restore();
  }
  function drawRomePillars(px, alpha){
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = "rgba(245,248,255,.95)";
    ctx.strokeStyle = "rgba(120,130,150,.24)";
    ctx.lineWidth = 2;
    const yBase = 418;
    for(let i=0;i<10;i++){
      const x = (i*220 - (px%220)) - 60;
      const h = 130 + (i%2)*20;
      roundRect(ctx, x, yBase-h, 34, h, 12); ctx.fill(); ctx.stroke();
      ctx.fillStyle = "rgba(255,255,255,.98)";
      roundRect(ctx, x-7, yBase-h-18, 48, 18, 8); ctx.fill();
      ctx.fillStyle = "rgba(245,248,255,.95)";
    }
    ctx.restore();
  }
  function drawRomeArches(px, alpha){
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = "rgba(235,240,248,.75)";
    ctx.strokeStyle = "rgba(120,130,150,.20)";
    ctx.lineWidth = 2;
    const y = 420;
    for(let i=0;i<7;i++){
      const x = (i*280 - (px%280)) - 80;
      roundRect(ctx, x, y-72, 220, 72, 14); ctx.fill(); ctx.stroke();
      ctx.globalCompositeOperation = "destination-out";
      ctx.beginPath(); ctx.arc(x+110, y-10, 52, Math.PI, 0); ctx.fill();
      ctx.globalCompositeOperation = "source-over";
      ctx.strokeStyle = "rgba(120,130,150,.18)";
      ctx.beginPath(); ctx.arc(x+110, y-10, 52, Math.PI, 0); ctx.stroke();
    }
    ctx.restore();
  }
  function drawJerusalemHills(px, alpha){
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = "rgba(220,200,170,.30)";
    const y = 360;
    for(let i=0;i<12;i++){
      const x = (i*180 - (px%180)) - 80;
      ctx.beginPath(); ctx.ellipse(x+90, y+30, 120, 55, 0, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }
  function drawJerusalemWalls(px, alpha){
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = "rgba(210,185,150,.45)";
    ctx.strokeStyle = "rgba(110,80,50,.18)";
    ctx.lineWidth = 2;
    const yBase = 420;
    for(let i=0;i<10;i++){
      const x = (i*200 - (px%200)) - 60;
      const w = 160, h=70;
      ctx.fillRect(x, yBase-h, w, h);
      ctx.strokeRect(x, yBase-h, w, h);
      for(let k=0;k<6;k++) ctx.fillRect(x+10+k*24, yBase-h-12, 16, 12);
    }
    ctx.restore();
  }
  function drawHellRidges(px, alpha){
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = "rgba(0,0,0,.35)";
    const y = 370;
    for(let i=0;i<12;i++){
      const x = (i*200 - (px%200)) - 80;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x+80, y-70);
      ctx.lineTo(x+160, y);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  }
  function drawHellGlow(px, alpha){
    ctx.save();
    ctx.globalAlpha = alpha;
    for(let i=0;i<10;i++){
      const x = (i*220 - (px%220)) - 90;
      const y = 430;
      const g = ctx.createRadialGradient(x+120,y,20,x+120,y,160);
      g.addColorStop(0,"rgba(255,120,80,.25)");
      g.addColorStop(1,"rgba(0,0,0,0)");
      ctx.fillStyle = g;
      ctx.fillRect(x, y-160, 240, 220);
    }
    ctx.restore();
  }

  // =========================
  // Platform drawing
  // =========================
  function drawPlatform(s){
    const theme = s.theme || "Rome";
    const x=s.x, y=s.y, w=s.w, h=s.h;

    const shake = (s.kind==="crumble" && (s.crShake||0)>0) ? (Math.sin(perfT*60)*2*(s.crShake||0)) : 0;
    ctx.save();
    ctx.translate(shake,0);

    if(s.kind==='slippery'){
      drawIceBlock(x,y,w,h);
    } else if(s.kind==='blessed'){
      drawBlessedBlock(x,y,w,h);
      const t = clamp((s.holyCharge||0)/1.45, 0, 1);
      if(t>0){
        ctx.globalAlpha = 0.16 + t*0.28;
        ctx.fillStyle = "rgba(255,215,120,.95)";
        roundRect(ctx, x-4, y-4, w+8, h+8, 12);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    } else if(theme === HEAVEN){
      drawCloudBlock(x,y,w,h);
    } else if(s.kind==="ground"){
      if(theme==="Rome") drawMarbleBlock(x,y,w,h, true);
      else if(theme==="Jerusalem") drawStoneBlock(x,y,w,h, true);
      else drawObsidianBlock(x,y,w,h, true);
    } else {
      if(theme==="Rome") drawMarbleBlock(x,y,w,h, false);
      else if(theme==="Jerusalem") drawStoneBlock(x,y,w,h, false);
      else drawObsidianBlock(x,y,w,h, false);

      // crumble visual
      if(s.kind==="crumble"){
        const cr = clamp(s.cr ?? 1, 0, 1);
        ctx.globalAlpha = 0.65;
        ctx.strokeStyle = "rgba(60,30,15,.55)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x + w*0.16, y + 6);
        ctx.lineTo(x + w*0.35, y + 14);
        ctx.lineTo(x + w*0.62, y + 7 + (1-cr)*9);
        ctx.lineTo(x + w*0.86, y + 12);
        ctx.stroke();
        ctx.globalAlpha = 1;

        if((s.crDelay??0.28) < 0.10 || s.crActive){
          ctx.globalAlpha = 0.18;
          ctx.fillStyle = "rgba(255,120,80,.95)";
          ctx.fillRect(x,y,w,h);
          ctx.globalAlpha = 1;
        }
      }
    }

    ctx.restore();
  }

  function drawMover(m){
    const x=m.x, y=m.y, w=m.w, h=m.h;
    const theme = m.theme || "Rome";

    ctx.save();
    ctx.globalAlpha = (theme===HEAVEN) ? 0.20 : 0.22;
    ctx.fillStyle = theme==="Hell" ? "rgba(255,120,80,.40)" : theme===HEAVEN ? "rgba(255,255,255,.55)" : "rgba(43,134,255,.22)";
    roundRect(ctx, x-10, y-12, w+20, h+24, 12); ctx.fill();
    ctx.globalAlpha = 1;

    drawPlatform({x,y,w,h,kind:"platform",theme});

    ctx.strokeStyle = "rgba(15,23,42,.20)";
    ctx.lineWidth = 2;
    const topY = theme==="Hell" ? 70 : 44;
    ctx.beginPath();
    ctx.moveTo(x+16, y); ctx.lineTo(x+12, topY);
    ctx.moveTo(x+w-16, y); ctx.lineTo(x+w-12, topY);
    ctx.stroke();

    ctx.fillStyle = "rgba(15,23,42,.18)";
    ctx.beginPath(); ctx.arc(x+12, topY, 4, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+w-12, topY, 4, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // =========================
  // Hazards drawing
  // =========================
  function drawHazards(){
    for(const h of hazards){
      if(h.kind==="spikes" || h.kind==="spikesTop") drawSpikes(h.x,h.y,h.w,h.h,h.theme);
      else if(h.kind==="lava") drawLava(h.x,h.y,h.w,h.h);
      else if(h.kind==="spearTrap") drawSpearTrap(h);
      else if(h.kind==="fireJet") drawFireJet(h);
      else if(h.kind==="saw") drawSawTrap(h);
      else if(h.kind==="radiant") drawRadiant(h);
      else if(h.kind==="proj") drawJavelin(h);
      else if(h.kind==="orb") drawOrb(h);
      else if(h.kind==="fireball") drawFireball(h);
    }
  }

  function drawIceBlock(x,y,w,h){
    const g = ctx.createLinearGradient(x,y,x,y+h);
    g.addColorStop(0,"rgba(225,245,255,.95)");
    g.addColorStop(1,"rgba(165,220,255,.95)");
    ctx.fillStyle = g;
    roundRect(ctx,x,y,w,h,10); ctx.fill();
    ctx.strokeStyle = "rgba(120,170,220,.45)"; ctx.lineWidth = 2; roundRect(ctx,x,y,w,h,10); ctx.stroke();
  }
  function drawBlessedBlock(x,y,w,h){
    const g = ctx.createLinearGradient(x,y,x,y+h);
    g.addColorStop(0,"rgba(255,250,220,.98)");
    g.addColorStop(1,"rgba(245,215,135,.96)");
    ctx.fillStyle = g;
    roundRect(ctx,x,y,w,h,10); ctx.fill();
    ctx.strokeStyle = "rgba(175,130,50,.48)"; ctx.lineWidth = 2; roundRect(ctx,x,y,w,h,10); ctx.stroke();
  }

  function drawRadiant(h){
    ctx.save();
    // faint column always
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "rgba(255,215,120,.65)";
    ctx.fillRect(h.x, h.y, h.w, h.h);

    // bright when on
    const phase = ((h.t||0) % h.period)/h.period;
    const on = phase < 0.55;
    if(on){
      ctx.globalAlpha = 0.45;
      const g = ctx.createLinearGradient(0,h.y,0,h.y+h.h);
      g.addColorStop(0,"rgba(255,255,255,.10)");
      g.addColorStop(0.5,"rgba(255,215,120,.65)");
      g.addColorStop(1,"rgba(255,255,255,.08)");
      ctx.fillStyle = g;
      ctx.fillRect(h.x-6, h.y, h.w+12, h.h);
    }
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  // =========================
  // Pickups drawing
  // =========================
  function drawPickup(p){
    const y = p.y + Math.sin(p.bobT||0)*5;
    const x = p.x;

    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = (p.theme===HEAVEN) ? "rgba(255,255,255,.95)" : "rgba(255,255,255,.95)";
    ctx.beginPath(); ctx.arc(x+p.w/2, y+p.h/2, 20, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;

    ctx.fillStyle = "rgba(255,255,255,.85)";
    roundRect(ctx, x-2, y-2, p.w+4, p.h+4, 10); ctx.fill();
    ctx.strokeStyle = "rgba(15,23,42,.12)";
    ctx.stroke();

    if(p.kind==="angelWings") drawAngelWingsIcon(ctx, x+2, y+2, p.w-4, p.h-4);
    else if(p.kind==="sandals") drawSandalsIcon(ctx, x+2, y+2, p.w-4, p.h-4);
    else if(p.kind==="shield") drawShieldIcon(ctx, x+2, y+2, p.w-4, p.h-4);
    else if(p.kind==="holyLight") drawHolyLightIcon(ctx, x+2, y+2, p.w-4, p.h-4);
    else if(p.kind==="fireRain") drawFireRainIcon(ctx, x+2, y+2, p.w-4, p.h-4);
    else drawBreadFishIcon(ctx, x+2, y+2, p.w-4, p.h-4);

    ctx.restore();
  }

  // =========================
  // Enemy drawing
  // =========================
  function drawEnemy(e){
    ctx.save();
    if(e.hurtT > 0) ctx.globalAlpha = 0.78;

    if(e.angel) drawAngel(e);
    else if(e.type==="legionary" || e.type==="centurion" || e.type==="javelin") drawLegionary(e);
    else if(e.type==="hound" || e.type==="brimHound") drawHound(e);
    else if(e.type==="templeGuard" || e.type==="slinger" || e.type==="zealot") drawGuard(e);
    else if(e.type==="stoneGolem") drawGolem(e);
    else if(e.type==="imp") drawImp(e);
    else if(e.type==="fireSkull") drawFireSkull(e);
    else if(e.type==="wraith") drawWraith(e);
    else {
      ctx.fillStyle = "rgba(0,0,0,.25)";
      roundRect(ctx, e.x, e.y, e.w, e.h, 10); ctx.fill();
    }
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawAngel(e){
    const x=e.x, y=e.y, w=e.w, h=e.h;
    const glow = 0.18 + Math.min(0.18, heavenDiff*0.03);

    // aura
    ctx.save();
    ctx.globalAlpha = glow;
    const g = ctx.createRadialGradient(x+w/2,y+h/2,10,x+w/2,y+h/2,60);
    g.addColorStop(0,"rgba(255,255,255,.85)");
    g.addColorStop(0.55,"rgba(255,215,120,.45)");
    g.addColorStop(1,"rgba(255,255,255,0)");
    ctx.fillStyle = g;
    ctx.fillRect(x-40,y-40,w+80,h+80);
    ctx.restore();

    const OUT="rgba(15,23,42,.30)";

    // wings
    ctx.fillStyle = "rgba(255,255,255,.95)";
    ctx.strokeStyle = OUT; ctx.lineWidth = 2;
    roundRect(ctx, x-12, y+18, 22, 28, 12); ctx.fill(); roundRect(ctx, x-12, y+18, 22, 28, 12); ctx.stroke();
    roundRect(ctx, x+w-10, y+18, 22, 28, 12); ctx.fill(); roundRect(ctx, x+w-10, y+18, 22, 28, 12); ctx.stroke();

    // body robe
    ctx.fillStyle = "rgba(255,255,255,.98)";
    roundRect(ctx, x+10, y+16, w-20, h-18, 14); ctx.fill();
    ctx.strokeStyle = OUT; ctx.lineWidth = 2;
    roundRect(ctx, x+10, y+16, w-20, h-18, 14); ctx.stroke();

    // head + halo
    ctx.fillStyle = "rgba(255,235,210,.96)";
    ctx.beginPath(); ctx.arc(x+w/2, y+16, 10, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = OUT; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(x+w/2, y+16, 10, 0, Math.PI*2); ctx.stroke();

    ctx.strokeStyle = "rgba(255,215,120,.85)";
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.ellipse(x+w/2, y+6, 14, 6, 0, 0, Math.PI*2); ctx.stroke();
  }

  // =========================
  // Player drawing (Jesus)
  // =========================
function drawJesus(p){
  const x = p.x, y = p.y, w = p.w, h = p.h;

  // Facing: keep consistent
  const dir = (p.facing >= 0 ? 1 : -1);

  // Velocity + speed
  const vx = p.vx || 0, vy = p.vy || 0;
  const speed = Math.hypot(vx, vy);

  // Only animate when truly moving
  const MOVE_THRESH = 60;
  const moving = speed > MOVE_THRESH;

  // Time base (don’t require p.armT to exist)
  const t = (p.armT ?? 0);

  // "run" amount is defined BEFORE we use it (fixes your error)
  const run = moving ? Math.max(0, Math.min(1, (speed - MOVE_THRESH) / 180)) : 0;

  // Bob is very subtle when idle
  const bob = Math.sin(t * 0.55) * (moving ? 1.9 : 0.35);

  // Run cycle (only matters when run>0)
  const stepT = t * 1.95;
  const legA = Math.sin(stepT) * run;
  const legB = Math.sin(stepT + Math.PI) * run;
  const armA = Math.sin(stepT + Math.PI/2) * run;
  const armB = Math.sin(stepT + Math.PI/2 + Math.PI) * run;

  // Styling
  const s = Math.min(w, h);
  const OUT = "rgba(15,23,42,.45)";
  const SKIN = "rgba(160,116,92,.98)";
  const HAIR = "rgba(70,45,28,.98)";
  const BEARD = "rgba(60,38,22,.98)";
  const ROBE = "rgba(255,255,255,.98)";
  const ROBE_SHADE = "rgba(15,23,42,.07)";
  const SASH = "rgba(201,52,52,.95)";
  const SASH_D = "rgba(15,23,42,.22)";

  // Anchors
  const cx = x + w * 0.5;
  const footBaseY = y + h - 4 + bob;
  const hipY = y + h * 0.62 + bob;

  // Lean forward when running (nice “motion” feel)
  const lean = dir * (0.8 + run * 2.2);

  ctx.save();
  ctx.lineJoin = "round";
  ctx.lineCap = "round";

  // invincibility flicker
  if (p.invT > 0 && Math.floor(p.invT * 18) % 2 === 0) ctx.globalAlpha = 0.55;

  // aura glow for power-ups
  if (p.hasShield || p.hasSandals || p.hasAngelWings){
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = p.hasShield ? "rgba(202,162,74,.60)" : p.hasAngelWings ? "rgba(125,90,214,.55)" : "rgba(43,134,255,.55)";
    ctx.beginPath();
    ctx.ellipse(cx, y + h * 0.56, 34, 48, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  // ground shadow
  ctx.fillStyle = "rgba(0,0,0,.16)";
  ctx.beginPath();
  ctx.ellipse(cx, y + h, w * 0.36, 7, 0, 0, Math.PI * 2);
  ctx.fill();

  // -----------------
  // LEGS (clear run)
  // -----------------
  function drawLeg(phase, backLeg){
    // Big clear stride when moving, almost none when idle
    const stepAmp = (w * 0.06) + run * (w * 0.22);
    const liftAmp = (h * 0.01) + run * (h * 0.10);

    // small split so feet don’t overlap when idle
    const stance = (backLeg ? -1 : 1) * (w * 0.05);

    // foot forward/back
    const fx = cx + lean + stance + (phase * stepAmp);

    // lift only when foot is “forward”
    const lift = Math.max(0, phase) * liftAmp;
    const fy = footBaseY - lift;

    const kneeX = cx + lean + (phase * stepAmp * 0.55);
    const kneeY = hipY + h * 0.17 - lift * 0.35;

    // leg stroke
    ctx.strokeStyle = backLeg ? "rgba(120,85,55,.55)" : "rgba(120,85,55,.82)";
    ctx.lineWidth = backLeg ? (s * 0.10) : (s * 0.115);

    ctx.beginPath();
    ctx.moveTo(cx + lean + (backLeg ? -dir * 2 : dir * 2), hipY);
    ctx.quadraticCurveTo(kneeX, kneeY, fx, fy);
    ctx.stroke();

    // outline
    ctx.strokeStyle = OUT;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx + lean + (backLeg ? -dir * 2 : dir * 2), hipY);
    ctx.quadraticCurveTo(kneeX, kneeY, fx, fy);
    ctx.stroke();

    // FOOT / SANDAL (very visible)
    const footW = w * (moving ? 0.26 : 0.22);
    const footH = h * (moving ? 0.085 : 0.07);

    ctx.fillStyle = p.hasSandals ? "rgba(43,134,255,.88)" : "rgba(140,102,82,.85)";
    ctx.strokeStyle = OUT;
    ctx.lineWidth = 2;
    roundRect(ctx, fx - footW * 0.5, fy - footH * 0.5, footW, footH, 4);
    ctx.fill();
    roundRect(ctx, fx - footW * 0.5, fy - footH * 0.5, footW, footH, 4);
    ctx.stroke();

    // toe hint
    ctx.strokeStyle = "rgba(15,23,42,.22)";
    ctx.lineWidth = 1.6;
    ctx.beginPath();
    ctx.moveTo(fx, fy);
    ctx.lineTo(fx + dir * (footW * 0.24), fy - footH * 0.05);
    ctx.stroke();
  }

  // Back then front
  drawLeg(legB, true);
  drawLeg(legA, false);

  if(p.hasAngelWings){
    ctx.fillStyle = "rgba(250,250,255,.92)";
    ctx.strokeStyle = "rgba(120,120,145,.25)";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.ellipse(cx-w*0.34, y+h*0.48, w*0.24, h*0.22, -0.35, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.ellipse(cx+w*0.34, y+h*0.48, w*0.24, h*0.22, 0.35, 0, Math.PI*2); ctx.fill(); ctx.stroke();
  }

  // -----------------
  // ROBE / TUNIC
  // -----------------
  const bodyX = x + w * 0.18;
  const bodyY = y + h * 0.26 + bob;
  const bodyW = w * 0.64;
  const bodyH = h * 0.62;

  ctx.fillStyle = ROBE;
  ctx.strokeStyle = OUT;
  ctx.lineWidth = 2;

  ctx.beginPath();
  ctx.moveTo(bodyX + 10, bodyY);
  ctx.quadraticCurveTo(cx, bodyY - 6, bodyX + bodyW - 10, bodyY);
  ctx.lineTo(bodyX + bodyW + 6, bodyY + bodyH * 0.72);
  ctx.quadraticCurveTo(cx, bodyY + bodyH + 12, bodyX - 6, bodyY + bodyH * 0.72);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // inner shade fold
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = ROBE_SHADE;
  ctx.beginPath();
  ctx.moveTo(cx + dir * (w * 0.05), bodyY + 10);
  ctx.quadraticCurveTo(cx + dir * (w * 0.12), bodyY + bodyH * 0.45, cx + dir * (w * 0.03), bodyY + bodyH * 0.95);
  ctx.lineTo(cx + dir * (w * 0.11), bodyY + bodyH * 0.92);
  ctx.quadraticCurveTo(cx + dir * (w * 0.16), bodyY + bodyH * 0.42, cx + dir * (w * 0.07), bodyY + 12);
  ctx.closePath();
  ctx.fill();
  ctx.globalAlpha = 1;

  // sash (diagonal)
  ctx.strokeStyle = SASH;
  ctx.lineWidth = Math.max(5, s * 0.10);
  ctx.beginPath();
  ctx.moveTo(x + (dir > 0 ? w * 0.22 : w * 0.78), y + h * 0.36 + bob);
  ctx.lineTo(x + (dir > 0 ? w * 0.78 : w * 0.22), y + h * 0.86 + bob);
  ctx.stroke();

  ctx.strokeStyle = SASH_D;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x + (dir > 0 ? w * 0.22 : w * 0.78), y + h * 0.36 + bob);
  ctx.lineTo(x + (dir > 0 ? w * 0.78 : w * 0.22), y + h * 0.86 + bob);
  ctx.stroke();

  // -----------------
  // ARMS (swing only when moving)
  // -----------------
  function drawArm(phase, leftSide){
    const shoulderX = cx + (leftSide ? -w * 0.20 : w * 0.20) + lean * 0.22;
    const shoulderY = y + h * 0.42 + bob;

    const swingAmpX = w * 0.05 + run * w * 0.16;
    const swingAmpY = h * 0.02 + run * h * 0.10;

    const handX = shoulderX + phase * swingAmpX;
    const handY = shoulderY + Math.abs(phase) * swingAmpY;

    ctx.strokeStyle = SKIN;
    ctx.lineWidth = s * 0.11;
    ctx.beginPath();
    ctx.moveTo(shoulderX, shoulderY);
    ctx.quadraticCurveTo((shoulderX + handX) * 0.5, (shoulderY + handY) * 0.5, handX, handY);
    ctx.stroke();

    ctx.strokeStyle = OUT;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(shoulderX, shoulderY);
    ctx.quadraticCurveTo((shoulderX + handX) * 0.5, (shoulderY + handY) * 0.5, handX, handY);
    ctx.stroke();

    ctx.fillStyle = SKIN;
    ctx.strokeStyle = OUT;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(handX, handY, s * 0.055, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
  }

  drawArm(armB, true);
  drawArm(armA, false);

  // optional shield
  if (p.hasShield){
    const shX = cx + dir * (w * 0.34);
    const shY = y + h * 0.55 + bob;
    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "rgba(202,162,74,.85)";
    ctx.strokeStyle = OUT;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(shX, shY, w * 0.14, h * 0.15, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.strokeStyle = "rgba(15,23,42,.22)";
    ctx.beginPath();
    ctx.moveTo(shX, shY - h * 0.10);
    ctx.lineTo(shX, shY + h * 0.10);
    ctx.stroke();
    ctx.restore();
  }

  // -----------------
  // HEAD + FACE (eyes follow movement)
  // -----------------
  const headR = s * 0.22;
  const headCx = cx + lean * 0.35;
  const headCy = y + h * 0.18 + bob;

  // hair back
  ctx.fillStyle = HAIR;
  ctx.beginPath();
  ctx.arc(headCx, headCy, headR * 1.06, Math.PI * 0.08, Math.PI * 1.92);
  ctx.closePath();
  ctx.fill();

  // head
  ctx.fillStyle = SKIN;
  ctx.beginPath();
  ctx.arc(headCx, headCy, headR, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = OUT;
  ctx.lineWidth = 2;
  ctx.stroke();

  // beard
  ctx.fillStyle = BEARD;
  ctx.beginPath();
  ctx.arc(headCx, headCy + headR * 0.20, headR * 1.02, Math.PI * 0.05, Math.PI * 0.95, false);
  ctx.quadraticCurveTo(headCx, headCy + headR * 1.35, headCx - headR * 0.95, headCy + headR * 0.20);
  ctx.closePath();
  ctx.fill();

  // hair sides
  ctx.fillStyle = HAIR;
  roundRect(ctx, headCx - headR * 1.10, headCy - headR * 0.35, headR * 0.55, headR * 1.25, headR * 0.35); ctx.fill();
  roundRect(ctx, headCx + headR * 0.55, headCy - headR * 0.35, headR * 0.55, headR * 1.25, headR * 0.35); ctx.fill();

  // eye placement + "look" amount
  const eyeY = headCy - headR * 0.10;
  const eyeSep = headR * 0.45;

  // Look shift: direction + a little from vx (clamped)
  const vxLook = Math.max(-1, Math.min(1, vx / 260));
  const faceShift = dir * (headR * 0.16);
  const pupilShift = (dir * 0.10 + vxLook * 0.06) * headR;

  // whites
  ctx.fillStyle = "rgba(255,255,255,.92)";
  ctx.beginPath();
  ctx.ellipse(headCx - eyeSep + faceShift, eyeY, headR * 0.18, headR * 0.13, 0, 0, Math.PI * 2);
  ctx.ellipse(headCx + eyeSep + faceShift, eyeY, headR * 0.18, headR * 0.13, 0, 0, Math.PI * 2);
  ctx.fill();

  // pupils
  ctx.fillStyle = "rgba(15,23,42,.75)";
  ctx.beginPath();
  ctx.arc(headCx - eyeSep + faceShift + pupilShift, eyeY, headR * 0.07, 0, Math.PI * 2);
  ctx.arc(headCx + eyeSep + faceShift + pupilShift, eyeY, headR * 0.07, 0, Math.PI * 2);
  ctx.fill();

  // eyebrows
  ctx.strokeStyle = "rgba(15,23,42,.45)";
  ctx.lineWidth = 1.7;
  ctx.beginPath();
  ctx.moveTo(headCx - eyeSep - headR * 0.12 + faceShift, eyeY - headR * 0.22);
  ctx.lineTo(headCx - eyeSep + headR * 0.18 + faceShift, eyeY - headR * 0.26);
  ctx.moveTo(headCx + eyeSep - headR * 0.18 + faceShift, eyeY - headR * 0.26);
  ctx.lineTo(headCx + eyeSep + headR * 0.12 + faceShift, eyeY - headR * 0.22);
  ctx.stroke();

  // nose
  ctx.strokeStyle = "rgba(15,23,42,.22)";
  ctx.lineWidth = 1.6;
  ctx.beginPath();
  ctx.moveTo(headCx + faceShift * 0.90, headCy - headR * 0.02);
  ctx.lineTo(headCx + faceShift * 1.10, headCy + headR * 0.18);
  ctx.stroke();

  // mouth
  ctx.strokeStyle = "rgba(15,23,42,.35)";
  ctx.lineWidth = 1.6;
  ctx.beginPath();
  ctx.moveTo(headCx - headR * 0.28 + faceShift * 0.50, headCy + headR * 0.48);
  ctx.quadraticCurveTo(headCx + faceShift * 0.60, headCy + headR * 0.62, headCx + headR * 0.30 + faceShift * 0.50, headCy + headR * 0.48);
  ctx.stroke();

  ctx.restore();
}


  // =========================
  // Power icons
  // =========================
  function drawPowerIcon(g, kind){
    g.clearRect(0,0,20,20);
    if(kind==="angelWings") drawAngelWingsIcon(g, 2,2,16,16);
    else if(kind==="sandals") drawSandalsIcon(g, 2,2,16,16);
    else if(kind==="shield") drawShieldIcon(g, 2,2,16,16);
    else if(kind==="holyLight") drawHolyLightIcon(g, 2,2,16,16);
    else if(kind==="fireRain") drawFireRainIcon(g, 2,2,16,16);
    else drawBreadFishIcon(g, 2,2,16,16);
  }

  function drawAngelWingsIcon(g, x,y,w,h){
    g.fillStyle = "rgba(250,250,255,.96)";
    g.beginPath(); g.ellipse(x+w*0.3,y+h*0.55,w*0.26,h*0.38,0,0,Math.PI*2); g.fill();
    g.beginPath(); g.ellipse(x+w*0.7,y+h*0.55,w*0.26,h*0.38,0,0,Math.PI*2); g.fill();
    g.fillStyle = "rgba(125,90,214,.9)";
    g.beginPath(); g.arc(x+w*0.5,y+h*0.55,w*0.12,0,Math.PI*2); g.fill();
  }
  function drawSandalsIcon(g, x,y,w,h){
    g.save();
    g.fillStyle = "rgba(43,134,255,.18)";
    g.strokeStyle = "rgba(29,86,201,.55)";
    g.lineWidth = 1.6;
    roundRect(g, x+2, y+5, w*0.42, h*0.55, 6); g.fill(); g.stroke();
    roundRect(g, x+w*0.56, y+5, w*0.42, h*0.55, 6); g.fill(); g.stroke();
    g.strokeStyle = "rgba(29,86,201,.70)";
    g.lineWidth = 2;
    g.beginPath();
    g.moveTo(x+4, y+10); g.lineTo(x+w*0.38, y+8);
    g.moveTo(x+w*0.60, y+8); g.lineTo(x+w*0.96, y+10);
    g.stroke();
    g.restore();
  }

  function drawHolyLightIcon(g, x,y,w,h){
    g.save();
    const cx = x + w/2, cy = y + h/2;
    g.strokeStyle = "rgba(212,180,61,.85)";
    g.lineWidth = 1.8;
    for(let i=0;i<8;i++){
      const a = (Math.PI*2*i)/8;
      g.beginPath();
      g.moveTo(cx + Math.cos(a)*2, cy + Math.sin(a)*2);
      g.lineTo(cx + Math.cos(a)*(w*0.46), cy + Math.sin(a)*(h*0.46));
      g.stroke();
    }
    g.fillStyle = "rgba(255,240,140,.95)";
    g.beginPath(); g.arc(cx, cy, w*0.22, 0, Math.PI*2); g.fill();
    g.restore();
  }

  function drawFireRainIcon(g, x,y,w,h){
    g.save();
    g.fillStyle = "rgba(211,54,54,.92)";
    for(let i=0;i<3;i++){
      const fx = x + w*(0.2 + i*0.3);
      g.beginPath();
      g.moveTo(fx, y+1);
      g.lineTo(fx+w*0.10, y+h*0.52);
      g.lineTo(fx-w*0.10, y+h*0.52);
      g.closePath();
      g.fill();
    }
    g.fillStyle = "rgba(255,170,70,.95)";
    g.beginPath(); g.arc(x+w*0.5, y+h*0.72, w*0.22, 0, Math.PI*2); g.fill();
    g.restore();
  }
  function drawShieldIcon(g, x,y,w,h){
    g.save();
    const cx = x + w/2;
    const top = y+2;
    const bot = y+h-2;
    g.fillStyle = "rgba(202,162,74,.22)";
    g.strokeStyle = "rgba(141,106,24,.65)";
    g.lineWidth = 1.8;
    g.beginPath();
    g.moveTo(cx, top);
    g.quadraticCurveTo(x+w-1, y+5, x+w-3, y+10);
    g.lineTo(cx, bot);
    g.lineTo(x+3, y+10);
    g.quadraticCurveTo(x+1, y+5, cx, top);
    g.closePath();
    g.fill(); g.stroke();
    g.strokeStyle = "rgba(141,106,24,.85)";
    g.lineWidth = 2.2;
    g.beginPath();
    g.moveTo(cx, y+5); g.lineTo(cx, y+h-5);
    g.moveTo(cx-4, y+10); g.lineTo(cx+4, y+10);
    g.stroke();
    g.restore();
  }
  function drawBreadFishIcon(g, x,y,w,h){
    g.save();
    g.fillStyle = "rgba(42,168,74,.14)";
    g.fillRect(x,y,w,h);
    g.fillStyle = "rgba(205,150,80,.95)";
    g.strokeStyle = "rgba(140,95,45,.55)";
    g.lineWidth = 1.4;
    roundRect(g, x+2, y+6, w*0.62, h*0.45, 7); g.fill(); g.stroke();
    g.strokeStyle = "rgba(140,95,45,.45)";
    g.lineWidth = 1.2;
    for(let i=0;i<3;i++){
      const sx = x+6+i*4;
      g.beginPath();
      g.moveTo(sx, y+9); g.lineTo(sx+2, y+13);
      g.stroke();
    }
    g.fillStyle = "rgba(120,170,220,.92)";
    g.strokeStyle = "rgba(40,90,140,.40)";
    g.lineWidth = 1.2;
    const fx = x+w*0.72, fy = y+11;
    g.beginPath();
    g.ellipse(fx, fy, 4.5, 3.2, 0, 0, Math.PI*2); g.fill(); g.stroke();
    g.beginPath();
    g.moveTo(fx+4.5, fy);
    g.lineTo(fx+8, fy-2.5);
    g.lineTo(fx+8, fy+2.5);
    g.closePath(); g.fill(); g.stroke();
    g.restore();
  }

  // =========================
  // Platform styles
  // =========================
  function drawCloudBlock(x,y,w,h){
    ctx.save();
    // soft body
    ctx.fillStyle = "rgba(255,255,255,.97)";
    roundRect(ctx, x, y, w, h, 12); ctx.fill();
    // fluffy bumps
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "rgba(255,255,255,.98)";
    for(let i=0;i<Math.floor(w/46)+1;i++){
      const bx = x + i*46 + rand(-8,8);
      ctx.beginPath();
      ctx.ellipse(bx, y+6, 22, 10, 0, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
    // subtle outline
    ctx.strokeStyle = "rgba(15,23,42,.16)";
    ctx.lineWidth = 2;
    roundRect(ctx, x, y, w, h, 12); ctx.stroke();
    // gentle gold highlight
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "rgba(255,215,120,.85)";
    ctx.fillRect(x+2, y+2, w-4, 3);
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawMarbleBlock(x,y,w,h,isGround){
    ctx.save();
    ctx.fillStyle = "rgba(245,248,255,.96)";
    roundRect(ctx, x, y, w, h, isGround?14:12); ctx.fill();
    ctx.strokeStyle = "rgba(120,130,150,.28)";
    ctx.lineWidth = 2; ctx.stroke();
    ctx.globalAlpha = 0.16;
    ctx.strokeStyle = "rgba(120,140,170,.55)";
    ctx.lineWidth = 1.2;
    for(let i=0;i<4;i++){
      const vx = x + rand(10,w-10);
      ctx.beginPath();
      ctx.moveTo(vx, y+10);
      ctx.lineTo(vx+rand(-30,30), y+h-10);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
    ctx.fillStyle = "rgba(255,255,255,.95)";
    ctx.fillRect(x+2, y+2, w-4, 4);
    ctx.globalAlpha = 0.55;
    ctx.fillStyle = "rgba(202,162,74,.85)";
    ctx.fillRect(x+2, y+6, w-4, 2);
    ctx.globalAlpha = 1;
    ctx.restore();
  }
  function drawStoneBlock(x,y,w,h,isGround){
    ctx.save();
    ctx.fillStyle = "rgba(222,202,172,.93)";
    roundRect(ctx, x, y, w, h, isGround?14:12); ctx.fill();
    ctx.strokeStyle = "rgba(110,80,50,.20)";
    ctx.lineWidth = 2; ctx.stroke();
    ctx.globalAlpha = 0.24;
    ctx.strokeStyle = "rgba(110,80,50,.35)";
    ctx.lineWidth = 1;
    for(let yy=y+12; yy<y+h; yy+=16){
      ctx.beginPath(); ctx.moveTo(x+6, yy); ctx.lineTo(x+w-6, yy); ctx.stroke();
    }
    ctx.globalAlpha = 1;
    ctx.fillStyle = "rgba(255,255,255,.35)";
    ctx.fillRect(x+2, y+2, w-4, 4);
    ctx.restore();
  }
  function drawObsidianBlock(x,y,w,h,isGround){
    ctx.save();
    ctx.fillStyle = "rgba(25,25,30,.96)";
    roundRect(ctx, x, y, w, h, isGround?14:12); ctx.fill();
    ctx.strokeStyle = "rgba(255,120,80,.22)";
    ctx.lineWidth = 2; ctx.stroke();
    ctx.globalAlpha = 0.34;
    ctx.strokeStyle = "rgba(255,120,80,.85)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x+w*0.15, y+h*0.30);
    ctx.lineTo(x+w*0.42, y+h*0.55);
    ctx.lineTo(x+w*0.74, y+h*0.34);
    ctx.stroke();
    ctx.globalAlpha = 1;
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "rgba(255,120,80,.85)";
    ctx.fillRect(x+2, y+2, w-4, 3);
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  // =========================
  // Enemy art (earth)
  // =========================
  function drawLegionary(e){
    const x=e.x, y=e.y, w=e.w, h=e.h;
    const dir = e.patrol || 1;
    const step = Math.sin(e.t*8)*4;
    const OUT = "rgba(15,23,42,.45)";

    ctx.fillStyle = "rgba(0,0,0,.14)";
    ctx.beginPath(); ctx.ellipse(x+w*0.5, y+h, w*0.36, 7, 0, 0, Math.PI*2); ctx.fill();

    const spear = (e.type==="javelin");
    ctx.strokeStyle = "rgba(70,50,25,.88)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    const sx = x + (dir>0 ? w-10 : 10);
    ctx.moveTo(sx, y+22);
    ctx.lineTo(sx + dir*(spear?44:36), y+14);
    ctx.stroke();
    ctx.fillStyle = "rgba(220,220,235,.92)";
    ctx.beginPath();
    ctx.moveTo(sx + dir*(spear?44:36), y+14);
    ctx.lineTo(sx + dir*(spear?54:44), y+17);
    ctx.lineTo(sx + dir*(spear?44:36), y+20);
    ctx.closePath(); ctx.fill();
    ctx.strokeStyle = OUT; ctx.lineWidth = 1.5; ctx.stroke();

    ctx.fillStyle = (e.type==="centurion") ? "rgba(155,22,22,.96)" : "rgba(190,30,30,.96)";
    roundRect(ctx, x+12, y+22, w-24, h-26, 12); ctx.fill();
    ctx.strokeStyle = OUT; ctx.lineWidth = 2;
    roundRect(ctx, x+12, y+22, w-24, h-26, 12); ctx.stroke();

    ctx.fillStyle = "rgba(92,92,102,.92)";
    roundRect(ctx, x+16, y+26, w-32, 16, 10); ctx.fill();
    ctx.strokeStyle = "rgba(15,23,42,.30)"; ctx.lineWidth = 1.8;
    roundRect(ctx, x+16, y+26, w-32, 16, 10); ctx.stroke();

    ctx.strokeStyle = "rgba(20,20,25,.25)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x+14, y+46); ctx.lineTo(x+w-14, y+46);
    ctx.stroke();

    ctx.fillStyle = "rgba(85,85,92,.95)";
    ctx.beginPath(); ctx.arc(x+w*0.5, y+18, 15, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = OUT; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(x+w*0.5, y+18, 15, 0, Math.PI*2); ctx.stroke();

    ctx.fillStyle = "rgba(60,60,66,.95)";
    roundRect(ctx, x+w*0.5-18, y+8, 36, 14, 9); ctx.fill();
    ctx.strokeStyle = OUT; ctx.lineWidth = 2;
    roundRect(ctx, x+w*0.5-18, y+8, 36, 14, 9); ctx.stroke();

    ctx.fillStyle = "rgba(220,70,70,.95)";
    roundRect(ctx, x+w*0.5-7, y+2, 14, 10, 6); ctx.fill();

    const shX = dir>0 ? x+2 : x+w-24;
    ctx.fillStyle = "rgba(170,98,40,.97)";
    roundRect(ctx, shX, y+28, 22, 30, 10); ctx.fill();
    ctx.strokeStyle = OUT; ctx.lineWidth = 2;
    roundRect(ctx, shX, y+28, 22, 30, 10); ctx.stroke();

    ctx.strokeStyle = "rgba(255,215,120,.60)";
    ctx.lineWidth = 2;
    ctx.strokeRect(shX+3, y+31, 16, 24);

    ctx.fillStyle = "rgba(255,215,120,.88)";
    ctx.beginPath(); ctx.arc(shX+11, y+43, 3, 0, Math.PI*2); ctx.fill();

    ctx.strokeStyle = "rgba(45,32,20,.82)";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(x+w*0.46, y+h-6); ctx.lineTo(x+w*0.46 + step, y+h-20);
    ctx.moveTo(x+w*0.54, y+h-6); ctx.lineTo(x+w*0.54 - step, y+h-20);
    ctx.stroke();
  }

  function drawGuard(e){
    const x=e.x, y=e.y, w=e.w, h=e.h;
    const step = Math.sin(e.t*7)*3;
    const OUT = "rgba(15,23,42,.42)";

    ctx.fillStyle = "rgba(0,0,0,.13)";
    ctx.beginPath(); ctx.ellipse(x+w*0.5, y+h, w*0.35, 7, 0, 0, Math.PI*2); ctx.fill();

    const tone = (e.type==="zealot") ? "rgba(145,98,58,.96)" : "rgba(168,128,88,.96)";
    ctx.fillStyle = tone;
    roundRect(ctx, x+12, y+22, w-24, h-26, 12); ctx.fill();
    ctx.strokeStyle = OUT; ctx.lineWidth = 2;
    roundRect(ctx, x+12, y+22, w-24, h-26, 12); ctx.stroke();

    ctx.fillStyle = "rgba(245,245,250,.90)";
    roundRect(ctx, x+16, y+30, w-32, 12, 10); ctx.fill();
    ctx.strokeStyle = "rgba(15,23,42,.25)"; ctx.lineWidth = 1.8;
    roundRect(ctx, x+16, y+30, w-32, 12, 10); ctx.stroke();

    ctx.fillStyle = "rgba(110,82,64,.96)";
    ctx.beginPath(); ctx.arc(x+w*0.5, y+18, 13, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = OUT; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(x+w*0.5, y+18, 13, 0, Math.PI*2); ctx.stroke();

    ctx.fillStyle = "rgba(235,235,240,.88)";
    roundRect(ctx, x+w*0.5-16, y+8, 32, 12, 9); ctx.fill();
    ctx.strokeStyle = OUT; ctx.lineWidth = 2;
    roundRect(ctx, x+w*0.5-16, y+8, 32, 12, 9); ctx.stroke();

    ctx.strokeStyle = "rgba(55,38,24,.75)";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(x+w*0.46, y+h-6); ctx.lineTo(x+w*0.46 + step, y+h-18);
    ctx.moveTo(x+w*0.54, y+h-6); ctx.lineTo(x+w*0.54 - step, y+h-18);
    ctx.stroke();
  }

  function drawHound(e){
    const x=e.x, y=e.y, w=e.w, h=e.h;
    const hell = e.type==="brimHound";
    const step = Math.sin(e.t*10)*2.5;
    const OUT = "rgba(15,23,42,.45)";

    ctx.fillStyle = "rgba(0,0,0,.14)";
    ctx.beginPath(); ctx.ellipse(x+w*0.5, y+h, w*0.36, 7, 0, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = hell ? "rgba(130,34,22,.97)" : "rgba(75,75,82,.97)";
    roundRect(ctx, x+6, y+18, w-12, h-18, 14); ctx.fill();
    ctx.strokeStyle = OUT; ctx.lineWidth = 2;
    roundRect(ctx, x+6, y+18, w-12, h-18, 14); ctx.stroke();

    ctx.fillStyle = "rgba(0,0,0,.22)";
    roundRect(ctx, x+w*0.62, y+26, w*0.24, 10, 8); ctx.fill();

    ctx.fillStyle = hell ? "rgba(255,190,120,.92)" : "rgba(245,245,250,.92)";
    ctx.beginPath(); ctx.arc(x+w*0.72, y+28, 3.4, 0, Math.PI*2); ctx.fill();

    ctx.strokeStyle = "rgba(35,28,20,.82)";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(x+w*0.35, y+h-5); ctx.lineTo(x+w*0.35 + step, y+h-16);
    ctx.moveTo(x+w*0.65, y+h-5); ctx.lineTo(x+w*0.65 - step, y+h-16);
    ctx.stroke();

    if(hell){
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = "rgba(255,120,80,.75)";
      ctx.beginPath(); ctx.arc(x+w*0.5, y+h*0.55, w*0.65, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  function drawGolem(e){
    const x=e.x, y=e.y, w=e.w, h=e.h;
    const OUT = "rgba(15,23,42,.40)";
    ctx.fillStyle = "rgba(0,0,0,.15)";
    ctx.beginPath(); ctx.ellipse(x+w*0.5, y+h, w*0.40, 8, 0, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = "rgba(155,134,108,.97)";
    roundRect(ctx, x+6, y+10, w-12, h-10, 14); ctx.fill();
    ctx.strokeStyle = OUT; ctx.lineWidth = 2;
    roundRect(ctx, x+6, y+10, w-12, h-10, 14); ctx.stroke();

    ctx.strokeStyle = "rgba(60,45,30,.35)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x+w*0.25, y+h*0.35);
    ctx.lineTo(x+w*0.40, y+h*0.55);
    ctx.lineTo(x+w*0.70, y+h*0.42);
    ctx.stroke();
  }

  function drawImp(e){
    const x=e.x, y=e.y, w=e.w, h=e.h;
    const OUT = "rgba(15,23,42,.45)";
    ctx.fillStyle = "rgba(0,0,0,.14)";
    ctx.beginPath(); ctx.ellipse(x+w*0.5, y+h, w*0.36, 7, 0, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = "rgba(155,32,26,.97)";
    roundRect(ctx, x+8, y+16, w-16, h-16, 14); ctx.fill();
    ctx.strokeStyle = OUT; ctx.lineWidth = 2;
    roundRect(ctx, x+8, y+16, w-16, h-16, 14); ctx.stroke();

    ctx.fillStyle = "rgba(255,210,170,.92)";
    ctx.beginPath();
    ctx.moveTo(x+w*0.35, y+16); ctx.lineTo(x+w*0.28, y+6); ctx.lineTo(x+w*0.42, y+12); ctx.closePath(); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x+w*0.65, y+16); ctx.lineTo(x+w*0.72, y+6); ctx.lineTo(x+w*0.58, y+12); ctx.closePath(); ctx.fill();

    ctx.fillStyle = "rgba(15,23,42,.55)";
    ctx.beginPath(); ctx.arc(x+w*0.44, y+24, 2.0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+w*0.56, y+24, 2.0, 0, Math.PI*2); ctx.fill();
  }

  function drawFireSkull(e){
    const x=e.x, y=e.y, w=e.w, h=e.h;
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "rgba(255,120,80,.65)";
    ctx.beginPath(); ctx.arc(x+w*0.5, y+h*0.5, w*0.72, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;

    ctx.fillStyle = "rgba(245,245,250,.96)";
    ctx.beginPath(); ctx.arc(x+w*0.5, y+h*0.56, w*0.38, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = "rgba(15,23,42,.35)";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(x+w*0.5, y+h*0.56, w*0.38, 0, Math.PI*2); ctx.stroke();

    ctx.fillStyle = "rgba(0,0,0,.55)";
    ctx.beginPath(); ctx.arc(x+w*0.42, y+h*0.56, 3, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+w*0.58, y+h*0.56, 3, 0, Math.PI*2); ctx.fill();
  }

  function drawWraith(e){
    const x=e.x, y=e.y, w=e.w, h=e.h;
    ctx.globalAlpha = 0.78;
    ctx.fillStyle = "rgba(80,140,255,.24)";
    ctx.beginPath();
    ctx.moveTo(x+w*0.2, y+h*0.95);
    ctx.quadraticCurveTo(x+w*0.5, y+h*0.18, x+w*0.8, y+h*0.95);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = "rgba(15,23,42,.25)";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  // =========================
  // Hazard art (existing)
  // =========================
  function drawSpikes(x,y,w,h,theme){
    ctx.save();
    ctx.fillStyle = theme==="Hell" ? "rgba(255,120,80,.65)" : "rgba(80,80,90,.55)";
    const n = Math.max(3, Math.floor(w/18));
    for(let i=0;i<n;i++){
      const sx = x + i*(w/n);
      ctx.beginPath();
      ctx.moveTo(sx, y+h);
      ctx.lineTo(sx+(w/n)*0.5, y);
      ctx.lineTo(sx+(w/n), y+h);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  }
  function drawSawTrap(h){
    ctx.save();
    ctx.translate(h.x, h.y);
    ctx.rotate((h.t||0)*5.2);
    ctx.fillStyle = "rgba(190,195,210,.95)";
    for(let i=0;i<8;i++){
      const a = (Math.PI*2/8)*i;
      ctx.beginPath();
      ctx.moveTo(Math.cos(a)*3, Math.sin(a)*3);
      ctx.lineTo(Math.cos(a+0.16)*12, Math.sin(a+0.16)*12);
      ctx.lineTo(Math.cos(a-0.16)*12, Math.sin(a-0.16)*12);
      ctx.closePath();
      ctx.fill();
    }
    ctx.beginPath(); ctx.arc(0,0,8,0,Math.PI*2); ctx.fillStyle = "rgba(120,125,150,.98)"; ctx.fill();
    ctx.restore();
  }
  function drawLava(x,y,w,h){
    ctx.save();
    const g = ctx.createLinearGradient(0,y,0,y+h);
    g.addColorStop(0,"rgba(255,120,80,.86)");
    g.addColorStop(1,"rgba(140,20,20,.92)");
    ctx.fillStyle = g;
    roundRect(ctx, x, y, w, h, 10); ctx.fill();
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "rgba(255,220,160,.95)";
    for(let i=0;i<8;i++){
      const bx = x + (i*80 - (camX*0.7%80));
      ctx.beginPath(); ctx.arc(bx, y+rand(6,h-6), rand(3,7), 0, Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha = 1;
    ctx.restore();
  }
  function drawSpearTrap(h){
    const ext = h.ext || 0;
    ctx.save();
    ctx.fillStyle = "rgba(140,120,95,.75)";
    roundRect(ctx, h.x, h.y, h.w, h.h, 8); ctx.fill();
    ctx.strokeStyle = "rgba(60,40,20,.9)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(h.x + h.w/2, h.y);
    ctx.lineTo(h.x + h.w/2, h.y - 28*ext);
    ctx.stroke();
    if(ext>0.2){
      ctx.fillStyle = "rgba(220,220,235,.95)";
      ctx.beginPath();
      ctx.moveTo(h.x + h.w/2, h.y - 28*ext);
      ctx.lineTo(h.x + h.w/2 - 6, h.y - 22*ext);
      ctx.lineTo(h.x + h.w/2 + 6, h.y - 22*ext);
      ctx.closePath(); ctx.fill();
    }
    ctx.restore();
  }
  function drawFireJet(h){
    const ext = h.ext || 0;
    ctx.save();
    ctx.fillStyle = "rgba(80,40,30,.55)";
    roundRect(ctx, h.x, h.y, h.w, h.h, 8); ctx.fill();
    if(ext>0.05){
      const g = ctx.createLinearGradient(0,h.y-40*ext,0,h.y);
      g.addColorStop(0,"rgba(255,220,160,.0)");
      g.addColorStop(0.4,"rgba(255,160,80,.55)");
      g.addColorStop(1,"rgba(255,80,60,.85)");
      ctx.fillStyle = g;
      roundRect(ctx, h.x+2, h.y-42*ext, h.w-4, 42*ext, 10);
      ctx.fill();
    }
    ctx.restore();
  }
  function drawJavelin(h){
    ctx.save();
    ctx.strokeStyle = "rgba(70,50,25,.9)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(h.x, h.y);
    ctx.lineTo(h.x + (h.vx>0?18:-18), h.y);
    ctx.stroke();
    ctx.restore();
  }
  function drawOrb(h){
    ctx.save();
    ctx.fillStyle = h.theme==="Hell" ? "rgba(255,120,80,.92)" : "rgba(120,120,140,.9)";
    ctx.beginPath(); ctx.arc(h.x, h.y, 7, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 0.25;
    ctx.beginPath(); ctx.arc(h.x, h.y, 18, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
    ctx.restore();
  }
  function drawFireball(h){
    ctx.save();
    const r = 7;
    const g = ctx.createRadialGradient(h.x, h.y, 1, h.x, h.y, r*2.3);
    g.addColorStop(0,"rgba(255,240,180,.95)");
    g.addColorStop(0.45,"rgba(255,140,60,.92)");
    g.addColorStop(1,"rgba(140,20,10,0)");
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(h.x, h.y, r*2.4, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "rgba(255,120,40,.95)";
    ctx.beginPath(); ctx.arc(h.x, h.y, r, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // =========================
  // Utils
  // =========================
  function roundRect(g,x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    g.beginPath();
    g.moveTo(x+rr,y);
    g.arcTo(x+w,y,x+w,y+h,rr);
    g.arcTo(x+w,y+h,x,y+h,rr);
    g.arcTo(x,y+h,x,y,rr);
    g.arcTo(x,y,x+w,y,rr);
    g.closePath();
  }

  // =========================
  // Reset/start
  // =========================
  function resetWorld(){
    earthWorld.solids.length=0; earthWorld.movers.length=0; earthWorld.hazards.length=0; earthWorld.enemies.length=0; earthWorld.pickups.length=0;
    earthWorld.sectionIndex=0; earthWorld.generatedUntilX=0;

    heavenWorld.solids.length=0; heavenWorld.movers.length=0; heavenWorld.hazards.length=0; heavenWorld.enemies.length=0; heavenWorld.pickups.length=0;
    heavenWorld.generatedUntilX=0;

    realm = "earth";
    setWorld(earthWorld);

    fx.length = 0;
    nextMoverId = 1;
    camX = 0;

    player.x = 140; player.y = FLOOR_Y - player.h;
    player.vx = 0; player.vy = 0;
    player.hearts = 3;
    player.hasSandals = player.hasShield = player.hasBread = false;
    player.hasAngelWings = false;
    player.holyLightT = 0;
    player.fireRainShots = 0;
    player.fireRainCd = 0;
    player.invT = 0; player.dropT = 0;

    showBannerForSection(0);
    ensureGeneratedEarth(player.x + SECTION_W*2);
    renderHUD();
  }

  // =========================
  // Main loop
  // =========================
  function loop(){
    const now = performance.now()/1000;
    let dt = now - last;
    last = now;

    dt = Math.min(0.06, Math.max(0, dt));
    acc += dt;

    let steps = 0;
    while(gameStarted && acc >= FIXED_DT && steps < MAX_STEPS){
      perfT += FIXED_DT;
      update(FIXED_DT);
      acc -= FIXED_DT;
      steps++;
    }
    draw();
    requestAnimationFrame(loop);
  }

  resetWorld();
  setGameStarted(false);
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
