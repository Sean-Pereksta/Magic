<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>üè∞ Royale Grid ‚Äî Firebase Clash</title>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<style>
  :root{
    --bg:#07090c;
    --panel: rgba(12,14,18,.78);
    --stroke: rgba(255,255,255,.12);
    --txt:#e7eef7;
    --muted: rgba(231,238,247,.70);
    --accent:#38bdf8;

    --p0:#60a5fa; /* blue side */
    --p1:#f87171; /* red side */

    --cell:56px;
    --gap:4px;

    --topH:64px;
    --hudH:122px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    background:
      radial-gradient(circle at 15% 10%, rgba(99,102,241,.25), transparent 40%),
      radial-gradient(circle at 85% 20%, rgba(236,72,153,.22), transparent 40%),
      radial-gradient(circle at 50% 100%, #090b14 0, #05060a 60%, #02030a 100%);
    color:var(--txt);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    overflow:hidden;
    touch-action:none;
  }

  .topbar{
    height:var(--topH);
    display:grid;
    grid-template-columns: 1fr auto 1fr;
    align-items:center;
    padding:8px 12px;
    background: linear-gradient(90deg,#020617,#070a12,#0b1020);
    border-bottom:1px solid rgba(148,163,184,.25);
    box-shadow:0 16px 40px rgba(0,0,0,.55);
    gap:10px;
    position:relative;
    z-index:50;
  }
  .leftTools{justify-self:start; display:flex; align-items:center; gap:8px;}
  .centerHud{
    justify-self:center;
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:6px;
  }
  .playerMeta{justify-self:end; display:flex; align-items:center; gap:8px;}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .badge{
    display:inline-flex; align-items:center; gap:8px;
    padding:7px 12px;
    border-radius:999px;
    background:rgba(2,6,23,.85);
    border:1px solid rgba(148,163,184,.28);
    font-weight:900;
    font-size:.85rem;
    color:#e5e7eb;
    backdrop-filter: blur(10px);
    white-space:nowrap;
  }
  .badge.blue{ border-color: rgba(96,165,250,.5); box-shadow:0 0 0 1px rgba(96,165,250,.2) inset; }
  .badge.red{ border-color: rgba(248,113,113,.5); box-shadow:0 0 0 1px rgba(248,113,113,.2) inset; }
  .badge small{opacity:.8; font-weight:800}
  .btn{
    appearance:none;
    border-radius:999px;
    padding:8px 12px;
    font-weight:900;
    cursor:pointer;
    border:1px solid rgba(148,163,184,.35);
    background:rgba(2,6,23,.72);
    color:#e5e7eb;
    font-size:.85rem;
  }
  .btn:hover{border-color:var(--accent)}
  .btn:active{transform:translateY(1px)}
  .btn.fullscreenBtn{
    border-color: rgba(56,189,248,.65);
    box-shadow: 0 0 0 1px rgba(56,189,248,.25) inset;
  }

  .wrap{
    height: calc(100dvh - var(--topH) - var(--hudH));
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
    overflow:hidden;
  }

  .viewport{
    width:100%;
    height:100%;
    position:relative;
    overflow:hidden;
    display:grid;
    place-items:center;
    user-select:none;
  }

  .canvas{
    transform-origin: 0 0;
    will-change: transform;
  }

  .grid{
    display:grid;
    grid-template-columns: repeat(var(--w), var(--cell));
    grid-auto-rows: var(--cell);
    gap:var(--gap);
    padding:12px;
    border-radius:22px;
    background:
      linear-gradient(180deg, rgba(22,163,74,.28), rgba(101,67,33,.25) 38%, rgba(22,163,74,.22) 100%),
      linear-gradient(160deg, rgba(15,23,42,.85), rgba(2,6,23,.92));
    box-shadow: 0 25px 60px rgba(0,0,0,.55), 0 0 0 1px rgba(148,163,184,.25) inset;
  }
  .cell{
    width:var(--cell); height:var(--cell);
    border-radius:12px;
    border:1px solid rgba(255,255,255,.10);
    background:
      radial-gradient(circle at 28% 26%, rgba(34,197,94,.18), transparent 45%),
      radial-gradient(circle at 70% 60%, rgba(59,130,246,.16), transparent 55%),
      linear-gradient(145deg, rgba(15,23,42,.35), rgba(2,6,23,.55));
    box-shadow: 0 1px 0 rgba(255,255,255,.10) inset, 0 10px 25px rgba(0,0,0,.25);
    position:relative;
    overflow:hidden;
    cursor:pointer;
  }
  .cell.side0{
    background:
      radial-gradient(circle at 30% 26%, rgba(59,130,246,.20), transparent 45%),
      radial-gradient(circle at 72% 60%, rgba(14,116,144,.18), transparent 55%),
      linear-gradient(145deg, rgba(15,23,42,.35), rgba(2,6,23,.55));
  }
  .cell.side1{
    background:
      radial-gradient(circle at 30% 26%, rgba(239,68,68,.18), transparent 45%),
      radial-gradient(circle at 72% 60%, rgba(244,114,182,.14), transparent 55%),
      linear-gradient(145deg, rgba(15,23,42,.35), rgba(2,6,23,.55));
  }
  .cell.river{
    background:
      radial-gradient(circle at 30% 30%, rgba(125,211,252,.28), transparent 55%),
      radial-gradient(circle at 75% 65%, rgba(59,130,246,.22), transparent 60%),
      linear-gradient(145deg, rgba(2,6,23,.72), rgba(15,23,42,.82));
    border-color: rgba(56,189,248,.25);
  }
  .cell.bridge{
    background:
      radial-gradient(circle at 30% 30%, rgba(245,158,11,.22), transparent 55%),
      linear-gradient(145deg, rgba(2,6,23,.72), rgba(15,23,42,.82));
    border-color: rgba(245,158,11,.35);
  }
  .cell.blocked::after{
    content:"";
    position:absolute; inset:0;
    background: linear-gradient(135deg, rgba(148,163,184,.08), rgba(0,0,0,.0));
    opacity:.55;
    pointer-events:none;
  }
  .cell.placeHint::before{
    content:"";
    position:absolute; inset:3px;
    border-radius:10px;
    border:2px dashed rgba(110,231,183,.9);
    background: rgba(16,185,129,.16);
    box-shadow:0 0 18px rgba(16,185,129,.35);
    pointer-events:none;
    z-index:2;
  }
  .cell.placeBlocked::before{
    content:"";
    position:absolute; inset:3px;
    border-radius:10px;
    border:2px dashed rgba(248,113,113,.7);
    background: rgba(239,68,68,.12);
    pointer-events:none;
    z-index:2;
  }

  .under{
    position:absolute; inset:0;
    opacity:.95;
  }

  /* --- SPRITES (SVG) --- */
  .piece{
    position:absolute; inset:0;
    display:grid; place-items:center;
    z-index:3;
    pointer-events:none;
    filter: drop-shadow(0 0 10px rgba(0,0,0,.65));
  }
  .sprite{
    width:44px; height:44px;
    display:grid; place-items:center;
  }
  .sprite svg{width:44px; height:44px}
  .team0{ --team: var(--p0); }
  .team1{ --team: var(--p1); }
  .sprite .teamFill{ fill: var(--team); }
  .sprite .teamStroke{ stroke: var(--team); }
  .sprite .ink{ fill: rgba(2,6,23,.92); }
  .sprite .shine{ fill: rgba(255,255,255,.22); }
  .sprite .steel{ fill: #cbd5e1; }
  .sprite .steel2{ fill:#94a3b8; }
  .sprite .stone{ fill:#94a3b8; }
  .sprite .stone2{ fill:#64748b; }
  .sprite .wood{ fill:#a16207; }
  .sprite .cloth{ fill:#a855f7; }
  .sprite .skin{ fill:#fde68a; }
  .sprite .gob{ fill:#22c55e; }
  .sprite .gob2{ fill:#16a34a; }
  .sprite .giant{ fill:#c084fc; }
  .sprite .giant2{ fill:#a855f7; }

  .piece .stack{
    position:absolute;
    right:6px; top:6px;
    font-size:11px;
    font-weight:1000;
    padding:2px 6px;
    border-radius:999px;
    background:rgba(2,6,23,.85);
    border:1px solid rgba(148,163,184,.25);
    color:#e5e7eb;
  }

  .hp{
    position:absolute; left:6px; right:6px; bottom:6px; height:7px;
    background:rgba(2,6,23,.85);
    border:1px solid rgba(148,163,184,.20);
    border-radius:999px;
    overflow:hidden;
    z-index:4;
  }
  .hp > i{display:block; height:100%; width:0%;}
  .hp .p0{background:linear-gradient(90deg, var(--p0), #2563eb); box-shadow:0 0 16px rgba(96,165,250,.55)}
  .hp .p1{background:linear-gradient(90deg, var(--p1), #dc2626); box-shadow:0 0 16px rgba(248,113,113,.55)}
  .hp .neutral{background:linear-gradient(90deg, #a3e635, #22c55e)}

  .hint{
    position:absolute;
    left:50%; top:10px; transform:translateX(-50%);
    padding:8px 12px;
    border-radius:999px;
    background:rgba(2,6,23,.78);
    border:1px solid rgba(148,163,184,.25);
    font-weight:900;
    font-size:.85rem;
    color:#e5e7eb;
    z-index:20;
    display:none;
    max-width:92vw;
    text-align:center;
  }

  /* HUD */
  .hud{
    height:var(--hudH);
    background: linear-gradient(180deg, rgba(2,6,23,.55), rgba(2,6,23,.92));
    border-top:1px solid rgba(148,163,184,.20);
    box-shadow: 0 -18px 40px rgba(0,0,0,.55);
    padding:10px 12px;
    display:grid;
    grid-template-columns: 1fr;
    gap:10px;
  }
  .hudTop{display:flex; align-items:center; justify-content:space-between; gap:10px;}
  .elixirWrap{
    display:flex; align-items:center; gap:10px; width:100%;
    max-width: 820px;
  }
  .elixirLabel{
    font-weight:1000; letter-spacing:.02em;
    color:#e5e7eb;
    display:flex; align-items:center; gap:8px;
    white-space:nowrap;
  }
  .elixirBar{
    flex:1;
    height:14px;
    border-radius:999px;
    background:rgba(255,255,255,.06);
    border:1px solid rgba(148,163,184,.18);
    overflow:hidden;
    position:relative;
  }
  .elixirFill{
    height:100%;
    width:0%;
    background: linear-gradient(90deg, rgba(168,85,247,.92), rgba(236,72,153,.92));
    box-shadow:0 0 18px rgba(168,85,247,.45);
  }
  .elixirTicks{
    position:absolute; inset:0;
    display:grid;
    grid-template-columns: repeat(10,1fr);
    pointer-events:none;
    opacity:.45;
  }
  .elixirTicks i{
    border-right:1px solid rgba(255,255,255,.10);
  }

  .cards{ display:grid; grid-template-columns:repeat(8,minmax(0,1fr)); gap:6px; }
  .card{
    min-width: 0;
    background: radial-gradient(circle at top, rgba(15,23,42,.95), rgba(2,6,23,.95));
    border:1px solid rgba(148,163,184,.25);
    border-radius:14px;
    padding:8px 6px;
    box-shadow: 0 12px 30px rgba(0,0,0,.35);
    cursor:pointer;
    user-select:none;
    position:relative;
  }
  .card.sel{outline:2px solid var(--accent); border-color: rgba(56,189,248,.45);}
  .card .top{display:flex; align-items:center; justify-content:center;}
  .card .name{display:none;}
  .card .cost{
    font-weight:1000;
    padding:3px 8px;
    border-radius:999px;
    background: rgba(168,85,247,.20);
    border:1px solid rgba(168,85,247,.35);
    font-size:.70rem;
  }
  .card .mid{ margin-top:2px; display:grid; place-items:center; }
  .card .emoji{font-size:30px; line-height:1;}
  .card .type,.card .rule{display:none;}
  .card .lock{ font-size:.65rem; text-align:center; color:#fca5a5; font-weight:800; margin-top:4px; }

  .draftBar{ display:none; align-items:center; justify-content:space-between; gap:10px; }
  .draftInfo{ font-size:.84rem; color:var(--muted); font-weight:800; }

  .draftOverlay{
    position:fixed;
    inset:0;
    z-index:80;
    display:none;
    align-items:center;
    justify-content:center;
    padding:12px;
    background: rgba(2,6,23,.62);
    backdrop-filter: blur(8px);
  }
  .draftOverlay.show{ display:flex; }
  .draftPanel{
    width:min(920px, 96vw);
    max-height:min(78dvh, 700px);
    border-radius:18px;
    background: linear-gradient(180deg, rgba(8,13,26,.94), rgba(2,6,23,.96));
    border:1px solid rgba(148,163,184,.30);
    box-shadow:0 28px 70px rgba(0,0,0,.6);
    padding:12px;
    display:grid;
    grid-template-rows:auto auto 1fr;
    gap:10px;
  }
  .draftHeader{display:flex; align-items:center; justify-content:space-between; gap:8px; flex-wrap:wrap;}
  .draftTitle{font-size:1rem; font-weight:1000; letter-spacing:.03em;}
  .draftCardScroll{
    overflow:auto;
    padding-right:4px;
  }
  .draftCardScroll .cards{ grid-template-columns:repeat(4,minmax(0,1fr)); }

  .toast{
    position:fixed;
    left:50%;
    bottom: calc(var(--hudH) + 10px);
    transform:translateX(-50%);
    padding:10px 14px;
    border-radius:12px;
    background:rgba(2,6,23,.92);
    border:1px solid rgba(148,163,184,.25);
    box-shadow:0 18px 50px rgba(0,0,0,.55);
    z-index:60;
    display:none;
    max-width:92vw;
    text-align:center;
    font-weight:900;
  }

  .fx{
    position:absolute;
    pointer-events:none;
    z-index:30;
    left:0; top:0;
  }
  .fxPop{
    position:absolute;
    transform:translate(-50%,-50%);
    font-weight:1000;
    font-size:14px;
    text-shadow:0 2px 10px rgba(0,0,0,.85);
    animation: pop 700ms ease-out forwards;
    white-space:nowrap;
  }
  @keyframes pop{
    0%{opacity:0; transform:translate(-50%,-35%) scale(.85)}
    20%{opacity:1; transform:translate(-50%,-50%) scale(1)}
    100%{opacity:0; transform:translate(-50%,-120%) scale(1.05)}
  }

  @media (max-width: 520px){
    :root{ --cell:46px; --gap:3px; --topH:70px; --hudH:132px; }
    .badge{font-size:.80rem; padding:6px 10px}
    .btn{font-size:.80rem; padding:7px 10px}
    .cards{grid-template-columns:repeat(4,minmax(0,1fr));}
    .card{padding:7px 6px;}
    .card .emoji{font-size:26px}
    .sprite, .sprite svg{width:40px; height:40px}
    .topbar{
      grid-template-columns: 1fr;
      justify-items:center;
      padding:8px 58px 8px 58px;
      height:auto;
      min-height:var(--topH);
    }
    .leftTools,
    .playerMeta{justify-self:center;}
    .playerMeta{
      width:100%;
      justify-content:center;
      overflow:auto;
      padding-bottom:2px;
    }
    .btn.fullscreenBtn{
      position:fixed;
      left:10px;
      top:50%;
      transform:translateY(-50%);
      z-index:85;
      background:rgba(2,6,23,.9);
      padding:10px 12px;
    }
    .draftPanel{max-height:min(82dvh, 760px);}
    .draftCardScroll .cards{ grid-template-columns:repeat(3,minmax(0,1fr)); }
  }
</style>
</head>
<body>
  <div class="topbar">
    <div class="leftTools">
      <button id="fullscreenBtn" class="btn fullscreenBtn" title="Toggle fullscreen">‚õ∂ Full</button>
    </div>
    <div class="centerHud">
      <span id="crownBadge" class="badge"><small>üëë</small> <span id="crownText">0‚Äì0</span></span>
      <span id="timerBadge" class="badge"><small>‚è±</small> <span id="timerText">‚Äî</span></span>
    </div>
    <div class="playerMeta">
      <span id="meBadge" class="badge"><small>You</small> <span id="meName">‚Äî</span> <small id="meElo">ELO ‚Äî</small></span>
      <span id="oppBadge" class="badge"><small>Opp</small> <span id="oppName">‚Äî</span> <small id="oppElo">ELO ‚Äî</small></span>
    </div>
  </div>

  <div class="wrap">
    <div class="viewport" id="viewport">
      <div class="hint" id="hint"></div>
      <div class="canvas" id="canvas">
        <div class="grid" id="grid" style="--w:9; --cell:56px; --gap:4px"></div>
        <div class="fx" id="fx"></div>
      </div>
    </div>
  </div>

  <div class="hud">
    <div class="hudTop">
      <div class="elixirWrap" id="elixirWrap">
        <div class="elixirLabel">üí† Elixir <span id="elixirNum">0</span>/10</div>
        <div class="elixirBar">
          <div class="elixirFill" id="elixirFill"></div>
          <div class="elixirTicks">
            <i></i><i></i><i></i><i></i><i></i><i></i><i></i><i></i><i></i><i></i>
          </div>
        </div>
      </div>
      <button id="cancelBtn" class="btn" style="display:none">‚úñ Cancel</button>
    </div>

    <div class="draftBar" id="draftBar">
      <div class="draftInfo" id="draftInfo">Pick 8 cards, then ready up.</div>
      <button id="readyBtn" class="btn">‚úÖ Ready</button>
    </div>

    <div class="cards" id="cards"></div>
  </div>

  <div class="toast" id="toast"></div>

  <div class="draftOverlay" id="draftOverlay">
    <div class="draftPanel">
      <div class="draftHeader">
        <div class="draftTitle">‚öîÔ∏è Draft your 8-card battle deck</div>
        <button id="readyBtnOverlay" class="btn">‚úÖ Ready</button>
      </div>
      <div class="draftInfo" id="draftInfoOverlay">Pick up to 8 cards.</div>
      <div class="draftCardScroll">
        <div class="cards" id="draftCards"></div>
      </div>
    </div>
  </div>

<script type="module">
/* ---------------- Firebase ---------------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, runTransaction
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};

const app  = initializeApp(firebaseConfig);
const db   = getFirestore(app);
const auth = getAuth(app);

signInAnonymously(auth).catch(console.error);

/* ---------------- URL params ---------------- */
const params   = new URLSearchParams(location.search);
const gameId   = params.get("gameId");
const username = params.get("username");
if (!gameId || !username) alert("Missing gameId or username in URL.");

/* Lobby + state refs */
const lobbyRef = doc(db, "lobbies", gameId);
// Firestore rules for this project allow game docs under /lobbies/{gameId}/crowncouncil/*
// (other game modes also use this path), so keep Forge Royale state there.
const stateRef = doc(db, "lobbies", gameId, "crowncouncil", "forgeroyale_state");

/* ---------------- DOM ---------------- */
const $ = (id)=>document.getElementById(id);
const timerText = $("timerText");
const crownText = $("crownText");
const meNameEl  = $("meName");
const oppNameEl = $("oppName");
const meEloEl   = $("meElo");
const oppEloEl  = $("oppElo");
const gridEl    = $("grid");
const canvasEl  = $("canvas");
const viewport  = $("viewport");
const cardsEl   = $("cards");
const elixirNum = $("elixirNum");
const elixirFill= $("elixirFill");
const elixirWrap= $("elixirWrap");
const draftBar = $("draftBar");
const draftInfo= $("draftInfo");
const readyBtn  = $("readyBtn");
const draftOverlay = $("draftOverlay");
const draftInfoOverlay = $("draftInfoOverlay");
const readyBtnOverlay = $("readyBtnOverlay");
const draftCardsEl = $("draftCards");
const fullscreenBtn = $("fullscreenBtn");
const hintEl    = $("hint");
const toastEl   = $("toast");
const cancelBtn = $("cancelBtn");
const fxEl      = $("fx");

/* ---------------- Board / grid (MOVES IN GRID SPACES ONLY) ---------------- */
let W=9, H=14;
gridEl.style.setProperty("--w", W);

const RIVER_Y0 = 6, RIVER_Y1 = 7;
const BRIDGES = new Set([ keyXY(2,RIVER_Y0), keyXY(2,RIVER_Y1), keyXY(6,RIVER_Y0), keyXY(6,RIVER_Y1) ]);
function keyXY(x,y){ return `${x},${y}`; }
function inside(x,y){ return x>=0 && x<W && y>=0 && y<H; }

function isRiver(x,y){
  return (y===RIVER_Y0 || y===RIVER_Y1) && !BRIDGES.has(keyXY(x,y));
}
function isBridge(x,y){ return BRIDGES.has(keyXY(x,y)); }

/* Deploy zones (troops only) */
function onMySide(p, x, y){
  if (p===0) return y >= (RIVER_Y1+1);   // bottom half
  return y <= (RIVER_Y0-1);             // top half
}

/* ---------------- Cards ---------------- */
const CARDS = {
  knight:  { id:"knight",  name:"Knight",  emoji:"üó°Ô∏è", kind:"troop", cost:3, place:"friendly", spawn:1,
             unit:{ hp:22, dmg:5, range:1, cdMs:900, spdMs:520, targets:"all", canHitAir:false } },
  archers: { id:"archers", name:"Archers", emoji:"üèπ", kind:"troop", cost:3, place:"friendly", spawn:2,
             unit:{ hp:12, dmg:4, range:3, cdMs:1100, spdMs:560, targets:"all", canHitAir:true } },
  goblins: { id:"goblins", name:"Goblins", emoji:"üü¢", kind:"troop", cost:2, place:"friendly", spawn:3,
             unit:{ hp:8,  dmg:3, range:1, cdMs:700, spdMs:480, targets:"all", canHitAir:false } },
  giant:   { id:"giant",   name:"Giant",   emoji:"ü™®", kind:"troop", cost:5, place:"friendly", spawn:1,
             unit:{ hp:48, dmg:6, range:1, cdMs:1200, spdMs:620, targets:"buildings", canHitAir:false } },
  wizard:  { id:"wizard",  name:"Wizard",  emoji:"üßô", kind:"troop", cost:4, place:"friendly", spawn:1,
             unit:{ hp:16, dmg:5, range:3, cdMs:1200, spdMs:600, targets:"all", splash:1, canHitAir:true } },
  golem:   { id:"golem", name:"Golem", emoji:"ü™®", kind:"troop", cost:6, place:"friendly", spawn:1,
             unit:{ hp:64, dmg:8, range:1, cdMs:1500, spdMs:760, targets:"all", canHitAir:false, splitInto:"miniGolem", splitCount:2 } },
  miniGolem:{ id:"miniGolem", name:"Mini Golem", emoji:"üß±", kind:"troop", cost:0, place:"friendly", spawn:1, hidden:true,
             unit:{ hp:18, dmg:4, range:1, cdMs:900, spdMs:540, targets:"all", canHitAir:false } },
  barbarian:{ id:"barbarian", name:"Barbarian", emoji:"ü™ì", kind:"troop", cost:4, place:"friendly", spawn:1,
             unit:{ hp:26, dmg:5, range:1, cdMs:1100, spdMs:510, targets:"all", canHitAir:false, cleaveRadius:1 } },
  necromancer:{ id:"necromancer", name:"Necromancer", emoji:"‚ò†Ô∏è", kind:"troop", cost:5, place:"friendly", spawn:1,
             unit:{ hp:20, dmg:3, range:3, cdMs:1300, spdMs:620, targets:"all", canHitAir:true, summonCard:"skeleton", summonEveryMs:10000, summonCount:1 } },
  skeleton:{ id:"skeleton", name:"Skeleton", emoji:"ü¶¥", kind:"troop", cost:0, place:"friendly", spawn:1, hidden:true,
             unit:{ hp:5, dmg:2, range:1, cdMs:900, spdMs:430, targets:"all", canHitAir:false } },
  darkprince:{ id:"darkprince", name:"Dark Prince", emoji:"üêé", kind:"troop", cost:5, place:"friendly", spawn:1,
             unit:{ hp:30, dmg:5, range:1, cdMs:1100, spdMs:580, targets:"all", canHitAir:false, chargeDmg:14, chargeRange:3, chargeSelfStunMs:4000 } },
  slime:{ id:"slime", name:"Slime", emoji:"üü£", kind:"troop", cost:3, place:"friendly", spawn:1,
             unit:{ hp:20, dmg:3, range:1, cdMs:900, spdMs:600, targets:"all", canHitAir:false, slowMs:1800 } },
  assassin:{ id:"assassin", name:"Assassin", emoji:"üó°Ô∏è", kind:"troop", cost:4, place:"any", spawn:1, rareEnemySide:true,
             unit:{ hp:14, dmg:4, range:1, cdMs:700, spdMs:450, targets:"all", canHitAir:false, stealth:true, firstHitDmg:12 } },
  dragon:{ id:"dragon", name:"Dragon", emoji:"üêâ", kind:"troop", cost:6, place:"friendly", spawn:1,
             unit:{ hp:32, dmg:6, range:3, cdMs:1200, spdMs:600, targets:"all", canHitAir:true, flying:true, splash:1 } },
  balloon:{ id:"balloon", name:"Balloon", emoji:"üéà", kind:"troop", cost:5, place:"friendly", spawn:1,
             unit:{ hp:34, dmg:14, range:1, cdMs:1800, spdMs:900, targets:"buildings", canHitAir:false, flying:true } },
  drake:{ id:"drake", name:"Drake", emoji:"üê≤", kind:"troop", cost:4, place:"friendly", spawn:1,
             unit:{ hp:22, dmg:5, range:3, cdMs:1000, spdMs:560, targets:"all", canHitAir:true, flying:true, airPriority:true } },
  wyvern:{ id:"wyvern", name:"Wyvern", emoji:"ü™∂", kind:"troop", cost:4, place:"friendly", spawn:1,
             unit:{ hp:20, dmg:4, range:3, cdMs:900, spdMs:540, targets:"all", canHitAir:false, flying:true } },
  paladin:{ id:"paladin", name:"Paladin", emoji:"üõ°Ô∏è", kind:"troop", cost:5, place:"friendly", spawn:1,
             unit:{ hp:34, dmg:4, range:1, cdMs:1000, spdMs:560, targets:"all", canHitAir:false, auraArmor:true } },
  musketeer:{ id:"musketeer", name:"Musketeer", emoji:"üéØ", kind:"troop", cost:4, place:"friendly", spawn:1,
             unit:{ hp:16, dmg:7, range:4, cdMs:1200, spdMs:620, targets:"all", canHitAir:true } },
  bomber:{ id:"bomber", name:"Bomber", emoji:"üí£", kind:"troop", cost:3, place:"friendly", spawn:1,
             unit:{ hp:11, dmg:6, range:3, cdMs:1100, spdMs:640, targets:"ground", canHitAir:false, splash:1 } },

  fireball:{ id:"fireball",name:"Fireball",emoji:"üî•", kind:"spell", cost:4, place:"any",
             spell:{ dmg:18, radius:1 } },
  zap:     { id:"zap",     name:"Zap",     emoji:"‚ö°", kind:"spell", cost:2, place:"any",
             spell:{ dmg:9, radius:1, stunMs:1200 } },
  heal:    { id:"heal",    name:"Heal",    emoji:"üíö", kind:"spell", cost:3, place:"any",
             spell:{ heal:16, radius:1 } },
  log:     { id:"log", name:"Log", emoji:"ü™µ", kind:"spell", cost:2, place:"any", spell:{ lineDmg:10 } },
  blizzard:{ id:"blizzard", name:"Blizzard", emoji:"‚ùÑÔ∏è", kind:"spell", cost:4, place:"any", spell:{ dmg:10, radius:2, stunMs:1800 } },
  haste:   { id:"haste", name:"Haste", emoji:"üí®", kind:"spell", cost:3, place:"any", spell:{ aura:{ type:"haste", radius:1, ttlMs:7000, speedMult:.65 } } },
  armor:   { id:"armor", name:"Armor", emoji:"üõ°Ô∏è", kind:"spell", cost:3, place:"any", spell:{ aura:{ type:"armor", radius:1, ttlMs:7000, dmgTakenMult:.5 } } },
  healingAura:{ id:"healingAura", name:"Healing Aura", emoji:"‚ú®", kind:"spell", cost:4, place:"any", spell:{ aura:{ type:"heal", radius:1, ttlMs:8000, healPctPerSec:.05 } } }
};

const CARD_POOL = Object.values(CARDS).filter(c=>!c.hidden).map(c=>c.id);
const BASE_DECK = ["knight","archers","goblins","giant","wizard","fireball","zap","heal"];
const ELO_REQ = { dragon: 1050, darkprince: 1100, assassin: 1150, balloon: 1200 };
const ELO_K = 28;


/* ---------------- Pretty SVG sprites ---------------- */
function wrapSprite(svg, p){
  const cls = (p===0) ? "sprite team0" : "sprite team1";
  return `<div class="${cls}">${svg}</div>`;
}

function svgKnight(){
  return `
  <svg viewBox="0 0 64 64" aria-hidden="true">
    <defs>
      <linearGradient id="kSteel" x1="0" x2="1">
        <stop offset="0" stop-color="#e2e8f0"/><stop offset="1" stop-color="#94a3b8"/>
      </linearGradient>
    </defs>
    <path d="M16 50c2-11 6-18 16-18s14 7 16 18" fill="rgba(2,6,23,.55)"/>
    <path d="M18 52c2-10 6-16 14-16s12 6 14 16" class="teamFill" opacity=".25"/>
    <path d="M24 52v-8c0-8 5-14 8-14s8 6 8 14v8" fill="url(#kSteel)" stroke="rgba(2,6,23,.75)" stroke-width="2" />
    <path d="M26 26c2-8 8-12 12-12s10 4 12 12l-6 6H32z" fill="url(#kSteel)" stroke="rgba(2,6,23,.75)" stroke-width="2"/>
    <path d="M38 14c6 2 10 6 12 10" class="teamStroke" stroke-width="4" stroke-linecap="round" opacity=".9"/>
    <rect x="30" y="28" width="12" height="6" rx="3" class="ink" opacity=".65"/>
    <circle cx="30" cy="46" r="3" class="teamFill" opacity=".9"/>
    <path d="M44 40l10-10 3 3-10 10z" fill="#cbd5e1" stroke="rgba(2,6,23,.75)" stroke-width="1.5"/>
    <path d="M51 27l6-6 3 3-6 6z" class="teamFill" stroke="rgba(2,6,23,.75)" stroke-width="1.2"/>
  </svg>`;
}

function svgGoblin(){
  return `
  <svg viewBox="0 0 64 64" aria-hidden="true">
    <path d="M16 50c2-11 6-18 16-18s14 7 16 18" fill="rgba(2,6,23,.55)"/>
    <path d="M22 52c2-8 5-13 10-13s8 5 10 13" class="teamFill" opacity=".20"/>
    <path d="M20 30c0-10 8-18 12-18s12 8 12 18v8H20z" class="gob" stroke="rgba(2,6,23,.80)" stroke-width="2"/>
    <path d="M18 26l-8-6 6-4 6 7z" class="gob2" stroke="rgba(2,6,23,.80)" stroke-width="2" stroke-linejoin="round"/>
    <path d="M46 26l8-6-6-4-6 7z" class="gob2" stroke="rgba(2,6,23,.80)" stroke-width="2" stroke-linejoin="round"/>
    <circle cx="28" cy="28" r="2.6" class="ink"/>
    <circle cx="36" cy="28" r="2.6" class="ink"/>
    <path d="M28 34c3 3 5 3 8 0" fill="none" stroke="rgba(2,6,23,.85)" stroke-width="2.5" stroke-linecap="round"/>
    <path d="M28 37l-2 4 4-1z" fill="#ffffff" opacity=".9"/>
    <path d="M36 37l2 4-4-1z" fill="#ffffff" opacity=".9"/>
    <path d="M22 46c2-6 5-9 10-9s8 3 10 9" class="teamFill" opacity=".55"/>
    <path d="M18 44l10-2 1 5-10 2z" fill="#a16207" stroke="rgba(2,6,23,.75)" stroke-width="1.5"/>
  </svg>`;
}

function svgGiant(){
  return `
  <svg viewBox="0 0 64 64" aria-hidden="true">
    <path d="M10 54c3-16 10-26 22-26s19 10 22 26" fill="rgba(2,6,23,.55)"/>
    <path d="M18 54c2-12 6-18 14-18s12 6 14 18" class="teamFill" opacity=".18"/>
    <path d="M18 30c0-12 10-20 14-20s14 8 14 20v10H18z" class="giant" stroke="rgba(2,6,23,.80)" stroke-width="2"/>
    <path d="M20 24c3-8 9-12 12-12s9 4 12 12" class="giant2" opacity=".85"/>
    <circle cx="28" cy="30" r="2.8" class="ink"/>
    <circle cx="36" cy="30" r="2.8" class="ink"/>
    <path d="M28 38c3 2 5 2 8 0" fill="none" stroke="rgba(2,6,23,.85)" stroke-width="2.5" stroke-linecap="round"/>
    <path d="M44 44l10 4-2 6-10-4z" fill="#64748b" stroke="rgba(2,6,23,.75)" stroke-width="1.5"/>
    <path d="M46 42l6-14 5 2-6 14z" class="stone" stroke="rgba(2,6,23,.75)" stroke-width="1.5"/>
    <path d="M22 50c3-7 6-10 10-10s7 3 10 10" class="teamFill" opacity=".40"/>
  </svg>`;
}

function svgArchers(){
  return `
  <svg viewBox="0 0 64 64" aria-hidden="true">
    <path d="M16 52c2-12 6-20 16-20s14 8 16 20" fill="rgba(2,6,23,.55)"/>
    <path d="M20 32c0-10 8-18 12-18s12 8 12 18v12H20z" fill="#0ea5e9" opacity=".20"/>
    <path d="M20 32c0-10 8-18 12-18s12 8 12 18v12H20z" fill="rgba(2,6,23,.35)" stroke="rgba(2,6,23,.80)" stroke-width="2"/>
    <path d="M18 28c4-10 10-16 14-16s10 6 14 16l-6 6H24z" class="teamFill" opacity=".70" stroke="rgba(2,6,23,.80)" stroke-width="2"/>
    <circle cx="28" cy="30" r="2.5" class="ink"/>
    <circle cx="36" cy="30" r="2.5" class="ink"/>
    <path d="M48 18c6 10 6 22 0 34" fill="none" stroke="#a16207" stroke-width="4" stroke-linecap="round"/>
    <path d="M48 18c-6 10-6 22 0 34" fill="none" stroke="#fde68a" stroke-width="2" stroke-linecap="round" opacity=".65"/>
    <path d="M46 22h14" stroke="#cbd5e1" stroke-width="2.8" stroke-linecap="round"/>
    <path d="M60 22l-4-3v6z" class="teamFill" opacity=".9"/>
  </svg>`;
}

function svgWizard(){
  return `
  <svg viewBox="0 0 64 64" aria-hidden="true">
    <path d="M14 54c2-16 8-26 18-26s16 10 18 26" fill="rgba(2,6,23,.55)"/>
    <path d="M18 52c2-12 6-18 14-18s12 6 14 18" class="teamFill" opacity=".18"/>
    <path d="M18 40c2-14 8-24 14-24s12 10 14 24v12H18z" fill="rgba(2,6,23,.35)" stroke="rgba(2,6,23,.80)" stroke-width="2"/>
    <path d="M22 22l10-14 10 14-10 6z" class="cloth" opacity=".85" stroke="rgba(2,6,23,.80)" stroke-width="2" stroke-linejoin="round"/>
    <path d="M24 30c0-6 5-10 8-10s8 4 8 10v6H24z" class="skin" opacity=".95" stroke="rgba(2,6,23,.75)" stroke-width="2"/>
    <circle cx="29" cy="32" r="2.5" class="ink"/>
    <circle cx="35" cy="32" r="2.5" class="ink"/>
    <path d="M26 38c3 2 9 2 12 0" fill="none" stroke="rgba(2,6,23,.85)" stroke-width="2.5" stroke-linecap="round"/>
    <path d="M46 44l10-10 3 3-10 10z" class="teamFill" opacity=".85" stroke="rgba(2,6,23,.75)" stroke-width="1.5"/>
    <circle cx="57" cy="31" r="4" fill="#fbbf24" opacity=".85"/>
    <circle cx="57" cy="31" r="2.2" fill="#fff" opacity=".55"/>
  </svg>`;
}

function svgTower(){
  return `
  <svg viewBox="0 0 64 64" aria-hidden="true">
    <path d="M16 56h32v-6H16z" class="stone2" opacity=".9"/>
    <path d="M18 52V22h28v30z" class="stone" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
    <path d="M18 22h28l-4-10H22z" class="stone2" stroke="rgba(2,6,23,.85)" stroke-width="2" stroke-linejoin="round"/>
    <path d="M24 12v6M32 12v6M40 12v6" stroke="rgba(2,6,23,.55)" stroke-width="3" stroke-linecap="round"/>
    <path d="M26 52V36h12v16z" fill="rgba(2,6,23,.55)"/>
    <path d="M20 30h6M38 30h6" stroke="rgba(2,6,23,.45)" stroke-width="3" stroke-linecap="round"/>
    <path d="M18 24h28" class="teamStroke" stroke-width="4" stroke-linecap="round" opacity=".9"/>
  </svg>`;
}

function svgCastle(){
  return `
  <svg viewBox="0 0 64 64" aria-hidden="true">
    <path d="M10 56h44v-7H10z" class="stone2" opacity=".9"/>
    <path d="M12 50V20h40v30z" class="stone" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
    <path d="M12 20h40l-4-10H16z" class="stone2" stroke="rgba(2,6,23,.85)" stroke-width="2" stroke-linejoin="round"/>
    <path d="M18 10v8M26 10v8M34 10v8M42 10v8" stroke="rgba(2,6,23,.55)" stroke-width="3" stroke-linecap="round"/>
    <path d="M22 50V34h20v16z" fill="rgba(2,6,23,.55)"/>
    <path d="M22 34c0-8 5-14 10-14s10 6 10 14" fill="rgba(2,6,23,.35)"/>
    <path d="M12 24h40" class="teamStroke" stroke-width="4" stroke-linecap="round" opacity=".9"/>
    <path d="M50 30l6 6-6 6-6-6z" class="teamFill" opacity=".8" stroke="rgba(2,6,23,.75)" stroke-width="1.5"/>
  </svg>`;
}

function spriteForUnit(type){
  if (type==="knight")  return svgKnight();
  if (type==="goblins") return svgGoblin();
  if (type==="giant")   return svgGiant();
  if (type==="archers") return svgArchers();
  if (type==="wizard")  return svgWizard();
  return `<svg viewBox="0 0 64 64"><circle cx="32" cy="32" r="16" class="teamFill"/></svg>`;
}
function spriteForStructure(kind){
  if (kind==="tower") return svgTower();
  if (kind==="castle") return svgCastle();
  return svgTower();
}

/* ---------------- Game state local cache ---------------- */
let S = null;
let lobbyPlayers = [];
let meIndex = 0;
let isHost = false;
let started = false;
let selectedCard = null;

let lobbyMeta = { eloMap:{}, deckMap:{} };
function cleanDeckForElo(deck, elo){
  const allow = (cid)=> (ELO_REQ[cid]||0) <= (elo||1000);
  const filtered = (deck||[]).filter(cid=>CARDS[cid] && !CARDS[cid].hidden && allow(cid));
  const fill = CARD_POOL.filter(allow);
  const out = [];
  for (const c of filtered){ if (!out.includes(c)) out.push(c); if (out.length>=8) break; }
  for (const c of fill){ if (!out.includes(c)) out.push(c); if (out.length>=8) break; }
  return out.slice(0,8);
}
function deckForPlayer(name){
  const elo = lobbyMeta.eloMap?.[name] || 1000;
  const saved = lobbyMeta.deckMap?.[name] || BASE_DECK;
  return cleanDeckForElo(saved, elo);
}

/* ---------------- Build grid DOM ---------------- */
function buildGrid(){
  const frag = document.createDocumentFragment();
  for (let y=0;y<H;y++){
    for (let x=0;x<W;x++){
      const d = document.createElement("div");
      d.className = "cell";
      if (y < RIVER_Y0) d.classList.add("side1");
      if (y > RIVER_Y1) d.classList.add("side0");
      if (isRiver(x,y)) d.classList.add("river","blocked");
      if (isBridge(x,y)) d.classList.add("bridge");
      d.dataset.x = String(x);
      d.dataset.y = String(y);
      d.innerHTML = `
        <div class="under"></div>
        <div class="piece"></div>
        <div class="hp"><i class="neutral" style="width:0%"></i></div>
      `;
      d.addEventListener("click", ()=> onCellClick(x,y));
      frag.appendChild(d);
    }
  }
  gridEl.innerHTML = "";
  gridEl.appendChild(frag);
}
buildGrid();

/* Fit board to screen */
let scale=1, pan={x:0,y:0};
function fitBoard(){
  const cell = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--cell")) || 56;
  const gap  = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--gap"))  || 4;
  const boardW = W*(cell+gap)-gap + 20;
  const boardH = H*(cell+gap)-gap + 20;
  const vw = viewport.clientWidth;
  const vh = viewport.clientHeight;
  const s = Math.min(vw/boardW, vh/boardH);
  scale = Math.min(2.0, Math.max(0.55, s));
  pan.x = Math.round((vw - boardW*scale)/2);
  pan.y = Math.round((vh - boardH*scale)/2);
  canvasEl.style.transform = `translate(${pan.x}px,${pan.y}px) scale(${scale})`;
}
new ResizeObserver(fitBoard).observe(viewport);
fitBoard();

/* ---------------- UI helpers ---------------- */
function toast(msg, ms=1400){
  toastEl.textContent = msg;
  toastEl.style.display = "block";
  clearTimeout(toastEl._t);
  toastEl._t = setTimeout(()=> toastEl.style.display="none", ms);
}
function hint(msg){
  if(!msg){ hintEl.style.display="none"; hintEl.textContent=""; return; }
  hintEl.textContent = msg;
  hintEl.style.display="block";
}
function getCell(x,y){
  const i = y*W + x;
  return gridEl.children[i] || null;
}
function fxPop(x,y,text,color){
  const cell = getCell(x,y);
  if(!cell) return;
  const rect = cell.getBoundingClientRect();
  const vr = viewport.getBoundingClientRect();
  const cx = rect.left - vr.left + rect.width/2;
  const cy = rect.top  - vr.top  + rect.height/2;

  const el = document.createElement("div");
  el.className = "fxPop";
  el.textContent = text;
  el.style.left = cx + "px";
  el.style.top  = cy + "px";
  el.style.color = color || "#e5e7eb";
  fxEl.appendChild(el);
  setTimeout(()=>el.remove(), 750);
}

/* ---------------- Lobby join + state create ---------------- */
async function joinLobby(){
  await runTransaction(db, async (tx)=>{
    const snap = await tx.get(lobbyRef);
    const lob = snap.exists() ? snap.data() : {};
    const players = Array.isArray(lob.players) ? lob.players.slice(0,2) : [];
    if (!players.includes(username)){
      if (players.length < 2) players.push(username);
    }
    const eloMap = { ...(lob.eloMap||{}) };
    if (!eloMap[username]) eloMap[username] = 1000;
    const deckMap = { ...(lob.deckMap||{}) };
    if (!deckMap[username]) deckMap[username] = BASE_DECK.slice();
    tx.set(lobbyRef, {
      ...lob,
      players,
      eloMap,
      deckMap,
      updatedAt: Date.now(),
      createdAt: lob.createdAt || Date.now()
    }, { merge:true });
  });

  const lobSnap = await getDoc(lobbyRef);
  const lob = lobSnap.exists() ? lobSnap.data() : {};
  lobbyMeta = { eloMap: lob.eloMap||{}, deckMap: lob.deckMap||{} };
  lobbyPlayers = Array.isArray(lob.players) ? lob.players.slice(0,2) : [];
  meIndex = lobbyPlayers.indexOf(username);
  if (meIndex < 0) meIndex = 0;
  isHost = (lobbyPlayers[0] === username);
}

function seededShuffle(arr, seedStr){
  let s=0;
  for (let i=0;i<seedStr.length;i++) s = (s*31 + seedStr.charCodeAt(i))>>>0;
  function rnd(){
    s ^= s<<13; s >>>= 0;
    s ^= s>>17; s >>>= 0;
    s ^= s<<5;  s >>>= 0;
    return (s>>>0) / 4294967296;
  }
  const a = arr.slice();
  for (let i=a.length-1;i>0;i--){
    const j = Math.floor(rnd()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}

function initialStructures(){
  return [
    {id:"p1_tL", p:1, kind:"tower",  x:2, y:2,  hp:120, maxhp:120, range:4, dmg:3, cdMs:1300, nextAtk:0},
    {id:"p1_tR", p:1, kind:"tower",  x:6, y:2,  hp:120, maxhp:120, range:4, dmg:3, cdMs:1300, nextAtk:0},
    {id:"p1_c",  p:1, kind:"castle", x:4, y:1,  hp:220, maxhp:220, range:5, dmg:4, cdMs:1300, nextAtk:0},

    {id:"p0_tL", p:0, kind:"tower",  x:2, y:11, hp:120, maxhp:120, range:4, dmg:3, cdMs:1300, nextAtk:0},
    {id:"p0_tR", p:0, kind:"tower",  x:6, y:11, hp:120, maxhp:120, range:4, dmg:3, cdMs:1300, nextAtk:0},
    {id:"p0_c",  p:0, kind:"castle", x:4, y:12, hp:220, maxhp:220, range:5, dmg:4, cdMs:1300, nextAtk:0},
  ];
}

function structureAt(structs, x,y){
  return (structs||[]).find(s=>s.hp>0 && s.x===x && s.y===y) || null;
}
function isStructureTile(structs, x,y){
  return !!structureAt(structs,x,y);
}

const MATCH_MS = 3*60*1000;
const DRAFT_MS = 30*1000;

async function ensureStateExists(){
  await runTransaction(db, async (tx)=>{
    const snap = await tx.get(stateRef);
    if (snap.exists()) return;

    const lobSnap = await tx.get(lobbyRef);
    const lob = lobSnap.exists() ? lobSnap.data() : {};
    const players = Array.isArray(lob.players) ? lob.players.slice(0,2) : [];

    const now = Date.now();
    const p0Name = players[0] || "p0";
    const p1Name = players[1] || "p1";
    const deck0 = seededShuffle(deckForPlayer(p0Name), gameId + ":p0");
    const deck1 = seededShuffle(deckForPlayer(p1Name), gameId + ":p1");

    tx.set(stateRef, {
      v:1,
      phase: (players.length>=2) ? "waiting" : "waiting",
      players,
      startedAt: null,
      draftEndsAt: (players.length>=2) ? (now + DRAFT_MS) : null,
      readyMap: {},
      lastTickAt: now,
      endsAt: null,
      winner: null,      // 0 or 1, or null for draw
      winReason: null,   // "castle" | "crowns" | "draw"

      crowns: [0,0],

      elixir: [0,0],
      hand: { p0: deck0.slice(0,4), p1: deck1.slice(0,4) },
      queue:{ p0: deck0.slice(4),  p1: deck1.slice(4) },

      structures: initialStructures(),
      units: [],
      orders: [],
      fx: [],
      auras: [],
      eloApplied: false
    });
  });
}

/* Keep players in state updated (host only) */
async function syncPlayersIntoStateIfNeeded(){
  const stSnap = await getDoc(stateRef);
  if (!stSnap.exists()) return;
  const st = stSnap.data();
  const want = lobbyPlayers.slice(0,2);
  const cur = Array.isArray(st.players) ? st.players : [];
  if (want.length && (cur.length!==want.length || cur.some((n,i)=>n!==want[i]))){
    await updateDoc(stateRef, { players: want });
  }
}

/* ---------------- Gameplay constants ---------------- */
let hostTimer = null;
const TICK_MS = 320;
const ELIXIR_MS_PER = 2800;
const MAX_ELIXIR = 10;
const FX_TTL = 900;
const MAX_FX = 120;

/* ---------------- BFS pathing on grid ---------------- */
function neighbors4(x,y){
  return [
    {x:x+1,y},{x:x-1,y},{x,y:y+1},{x,y:y-1}
  ].filter(p=>inside(p.x,p.y));
}
function walkable(structs, x,y, flying=false){
  if (!inside(x,y)) return false;
  if (!flying && isRiver(x,y)) return false;
  if (isStructureTile(structs,x,y)) return false;
  return true;
}
function bfsNextStep(structs, start, goals, flying=false){
  const q = [];
  const prev = new Map();
  const startK = keyXY(start.x,start.y);
  q.push(start);
  prev.set(startK, null);

  while(q.length){
    const cur = q.shift();
    const ck = keyXY(cur.x,cur.y);
    if (goals.has(ck)){
      let stepK = ck;
      let parent = prev.get(stepK);
      while(parent && parent !== startK){
        stepK = parent;
        parent = prev.get(stepK);
      }
      if (stepK === startK) return null;
      const [sx,sy] = stepK.split(",").map(Number);
      return {x:sx,y:sy};
    }
    for (const nb of neighbors4(cur.x,cur.y)){
      const nk = keyXY(nb.x,nb.y);
      if (prev.has(nk)) continue;
      if (!walkable(structs, nb.x, nb.y, flying)) continue;
      prev.set(nk, ck);
      q.push(nb);
    }
  }
  return null;
}

/* ---------------- Targeting helpers ---------------- */
function aliveStructsForP(structs, p){
  return (structs||[]).filter(s=>s.p===p && s.hp>0);
}
function enemyStructPriority(structs, enemyP){
  const towers = aliveStructsForP(structs, enemyP).filter(s=>s.kind==="tower");
  if (towers.length) return towers;
  const castle = aliveStructsForP(structs, enemyP).find(s=>s.kind==="castle");
  return castle ? [castle] : [];
}
function isFlying(u){ return !!u.flying; }
function canTarget(attacker, target){
  if (!target) return false;
  if (isFlying(target) && !attacker.canHitAir) return false;
  return true;
}
function activeAurasAt(st, x,y){
  const now = Date.now();
  return (st.auras||[]).filter(a=>a.until>now && inRadius(a.x,a.y,x,y,a.radius||0));
}
function speedMult(st, u){
  const list = activeAurasAt(st, u.x,u.y).filter(a=>a.type==="haste");
  if (!list.length) return 1;
  return Math.min(...list.map(a=>a.speedMult||1));
}
function damageTakenMult(st, x,y){
  const list = activeAurasAt(st, x,y).filter(a=>a.type==="armor");
  if (!list.length) return 1;
  return Math.min(...list.map(a=>a.dmgTakenMult||1));
}
function applyDamageToUnit(st, attacker, target, baseDmg, now){
  if (!target || target.hp<=0) return;
  let dmg = Math.max(1, Math.floor(baseDmg * damageTakenMult(st, target.x, target.y)));
  if (attacker?.type === "assassin" && !attacker.revealed){
    dmg = attacker.firstHitDmg || dmg;
    attacker.revealed = true;
  }
  target.hp -= dmg;
  if (attacker?.slowMs) target.stunUntil = Math.max(target.stunUntil||0, now + attacker.slowMs);
}
function findNearestEnemyUnit(units, meP, from, range){
  let best=null, bd=1e9;
  for (const u of (units||[])){
    if (u.hp<=0 || u.p===meP) continue;
    if (!canTarget(from, u)) continue;
    const d = Math.abs(u.x-from.x)+Math.abs(u.y-from.y);
    if (d<=range && d<bd){ bd=d; best=u; }
  }
  return best;
}
function findNearestEnemyStructure(structs, meP, from, range){
  let best=null, bd=1e9;
  for (const s of (structs||[])){
    if (s.hp<=0 || s.p===meP) continue;
    const d = Math.abs(s.x-from.x)+Math.abs(s.y-from.y);
    if (d<=range && d<bd){ bd=d; best=s; }
  }
  return best;
}

/* ---------------- Spawn / spell application ---------------- */
function newUnit(p, cardId, x,y){
  const c = CARDS[cardId];
  const u = c.unit;
  return {
    id: crypto.randomUUID(),
    p,
    type: cardId,
    x, y,
    hp: u.hp,
    maxhp: u.hp,
    dmg: u.dmg,
    range: u.range,
    cdMs: u.cdMs,
    spdMs: u.spdMs,
    splash: u.splash || 0,
    targets: u.targets || "all",
    canHitAir: !!u.canHitAir,
    flying: !!u.flying,
    cleaveRadius: u.cleaveRadius || 0,
    summonCard: u.summonCard || null,
    summonEveryMs: u.summonEveryMs || 0,
    summonCount: u.summonCount || 0,
    nextSummon: u.summonEveryMs ? (Date.now() + u.summonEveryMs) : 0,
    splitInto: u.splitInto || null,
    splitCount: u.splitCount || 0,
    chargeDmg: u.chargeDmg || 0,
    chargeRange: u.chargeRange || 0,
    chargeSelfStunMs: u.chargeSelfStunMs || 0,
    slowMs: u.slowMs || 0,
    revealed: !u.stealth,
    firstHitDmg: u.firstHitDmg || 0,
    airPriority: !!u.airPriority,
    nextAtk: 0,
    nextMove: 0,
    stunUntil: 0
  };
}
function inRadius(cx,cy,x,y,r){
  return Math.abs(cx-x)+Math.abs(cy-y) <= r;
}
function applySpell(st, p, cardId, tx, ty){
  const spec = CARDS[cardId].spell;
  const units = st.units;
  const structs= st.structures;
  const r = spec.radius|0;

  if (spec.dmg){
    for (const u of units){
      if (u.hp<=0) continue;
      if (!inRadius(tx,ty,u.x,u.y,r)) continue;
      if (u.p===p) continue;
      u.hp -= spec.dmg;
    }
    for (const s of structs){
      if (s.hp<=0) continue;
      if (!inRadius(tx,ty,s.x,s.y,r)) continue;
      if (s.p===p) continue;
      s.hp -= spec.dmg;
    }
    pushFx(st, tx,ty, "üí•", "#fb7185");
    pushFx(st, tx,ty, "üî•", "#fb7185", 120);
    pushFx(st, tx,ty, "üü†", "#fdba74", 220);
  }

  if (spec.stunMs){
    const now = Date.now();
    for (const u of units){
      if (u.hp<=0) continue;
      if (!inRadius(tx,ty,u.x,u.y,r)) continue;
      if (u.p===p) continue;
      u.stunUntil = Math.max(u.stunUntil||0, now + spec.stunMs);
    }
    pushFx(st, tx,ty, "‚ö°", "#fde68a");
  }

  if (spec.heal){
    for (const u of units){
      if (u.hp<=0) continue;
      if (!inRadius(tx,ty,u.x,u.y,r)) continue;
      if (u.p!==p) continue;
      u.hp = Math.min(u.maxhp, u.hp + spec.heal);
    }
    for (const s of structs){
      if (s.hp<=0) continue;
      if (!inRadius(tx,ty,s.x,s.y,r)) continue;
      if (s.p!==p) continue;
      s.hp = Math.min(s.maxhp, s.hp + Math.floor(spec.heal*0.6));
    }
    pushFx(st, tx,ty, "üíö", "#86efac");
  }

  if (spec.lineDmg){
    for (const u of units){
      if (u.hp<=0 || u.p===p) continue;
      if (u.x!==tx) continue;
      applyDamageToUnit(st, null, u, spec.lineDmg, Date.now());
    }
    for (const s of structs){
      if (s.hp<=0 || s.p===p) continue;
      if (s.x!==tx) continue;
      s.hp -= Math.max(1, Math.floor(spec.lineDmg * damageTakenMult(st, s.x,s.y)));
    }
    for (let yy=0;yy<H;yy++){ pushFx(st, tx, yy, "ü™µ", "#f59e0b", yy*35, 650); }
  }

  if (spec.aura){
    st.auras = st.auras || [];
    st.auras.push({
      id: crypto.randomUUID(),
      p,
      x:tx,y:ty,
      ...spec.aura,
      until: Date.now() + (spec.aura.ttlMs||0)
    });
    pushFx(st, tx,ty, "‚ú®", "#a78bfa");
  }
}

/* ---------------- Tick simulation (HOST ONLY, GRID-STEP) ---------------- */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function pushFx(st, x,y, text, color, delayMs=0, ttl=FX_TTL){
  st.fx.push({id:crypto.randomUUID(), x,y, text, color, at:Date.now()+delayMs, ttl});
}
function attackGlyph(type){
  return ({ knight:"‚öîÔ∏è", archers:"üèπ", goblins:"üî™", giant:"üëä", wizard:"‚ú®", golem:"ü™®", barbarian:"ü™ì", necromancer:"‚ò†Ô∏è", darkprince:"üêé", slime:"üß™", assassin:"üó°Ô∏è", dragon:"üî•", balloon:"üí£", drake:"üå™Ô∏è", wyvern:"ü™∂", skeleton:"ü¶¥", paladin:"üõ°Ô∏è", musketeer:"üéØ", bomber:"üí•" })[type] || "‚öîÔ∏è";
}
function awardCrown(st, destroyedStructure){
  const scorer = (destroyedStructure.p===0) ? 1 : 0;
  st.crowns = st.crowns || [0,0];
  if (destroyedStructure.kind==="tower") st.crowns[scorer] = (st.crowns[scorer]||0) + 1;
  if (destroyedStructure.kind==="castle") st.crowns[scorer] = (st.crowns[scorer]||0) + 3;
}

function tickSim(st){
  const now = Date.now();

  // timer end => crowns decide (unless castle already ended it)
  if (st.phase==="battle" && st.endsAt && now >= st.endsAt){
    const c0 = st.crowns?.[0] ?? 0;
    const c1 = st.crowns?.[1] ?? 0;
    st.phase = "gameover";
    if (c0>c1){ st.winner=0; st.winReason="crowns"; }
    else if (c1>c0){ st.winner=1; st.winReason="crowns"; }
    else { st.winner=null; st.winReason="draw"; }
    return;
  }

  const dt = clamp(now - (st.lastTickAt||now), 0, 800);

  // snapshot structure hp for crown-award transitions
  const prevHP = new Map((st.structures||[]).map(s=>[s.id, s.hp]));

  // elixir regen
  for (let p=0;p<2;p++){
    const e = (st.elixir?.[p] ?? 0) + dt/ELIXIR_MS_PER;
    st.elixir[p] = clamp(e, 0, MAX_ELIXIR);
  }

  // process orders (plays)
  const orders = Array.isArray(st.orders) ? st.orders : [];
  for (const o of orders){
    const p = o.p|0;
    const cardId = o.card;
    const card = CARDS[cardId];
    if (!card) continue;
    if (!Array.isArray(st.players) || st.players.length < 2) continue;

    const cost = card.cost|0;
    if ((st.elixir[p] ?? 0) + 1e-9 < cost) continue;

    const x=o.x|0, y=o.y|0;
    if (!inside(x,y)) continue;

    if (card.place === "friendly"){
      if (!onMySide(p, x, y)) continue;
      if (isRiver(x,y)) continue;
      if (isStructureTile(st.structures, x, y)) continue;
    }

    st.elixir[p] = clamp((st.elixir[p] ?? 0) - cost, 0, MAX_ELIXIR);

    if (card.kind === "troop"){
      const spawn = Math.max(1, card.spawn|0);
      for (let i=0;i<spawn;i++){
        const spots = [
          {x,y},{x:x-1,y},{x:x+1,y},{x,y:y-1},{x,y:y+1}
        ].filter(s=>inside(s.x,s.y) && !isRiver(s.x,s.y) && !isStructureTile(st.structures,s.x,s.y));
        const spot = spots[i % spots.length] || {x,y};
        st.units.push(newUnit(p, cardId, spot.x, spot.y));
      }
      pushFx(st, x,y, card.emoji, (p===0 ? "#60a5fa" : "#f87171"));
    } else {
      applySpell(st, p, cardId, x, y);
    }

    const pk = p===0 ? "p0" : "p1";
    const hand = st.hand?.[pk] ? st.hand[pk].slice() : [];
    const queue= st.queue?.[pk] ? st.queue[pk].slice() : [];

    const idx = hand.indexOf(cardId);
    if (idx >= 0){
      hand.splice(idx,1);
      queue.push(cardId);
      const draw = queue.shift();
      if (draw) hand.push(draw);
      st.hand[pk] = hand;
      st.queue[pk]= queue;
    }
  }
  st.orders = [];

  // clean fx
  st.fx = (st.fx||[]).filter(f=> (f.at + (f.ttl||FX_TTL)) > now).slice(-MAX_FX);

  // remove dead (deferred until after split logic)

  // aura upkeep + heal aura
  st.auras = (st.auras||[]).filter(a=>a.until>now);
  for (const a of st.auras){
    if (a.type!=="heal") continue;
    for (const u of st.units||[]){
      if (u.hp<=0 || u.p!==a.p) continue;
      if (!inRadius(a.x,a.y,u.x,u.y,a.radius||0)) continue;
      const amt = Math.max(1, Math.floor((u.maxhp||1) * (a.healPctPerSec||0) * (dt/1000)));
      u.hp = Math.min(u.maxhp, u.hp + amt);
      if (Math.random() < 0.35) pushFx(st, u.x,u.y, "+", "#fde047", 0, 500);
    }
  }

  // unit actions (grid-step)
  for (const u of st.units){
    if (u.hp<=0) continue;

    if (u.summonCard && u.summonEveryMs && now >= (u.nextSummon||0)){
      u.nextSummon = now + u.summonEveryMs;
      for (let i=0;i<(u.summonCount||1);i++){
        const spots = neighbors4(u.x,u.y).concat([{x:u.x,y:u.y}]).filter(s=>inside(s.x,s.y) && walkable(st.structures,s.x,s.y,false));
        const spot = spots[i % Math.max(1,spots.length)] || {x:u.x,y:u.y};
        st.units.push(newUnit(u.p, u.summonCard, spot.x, spot.y));
      }
      pushFx(st, u.x, u.y, "‚ò†Ô∏è", "#c4b5fd");
    }

    if ((u.stunUntil||0) > now) continue;

    let targetUnit = null;
    let targetStruct = null;

    if (u.airPriority){
      const enemies = (st.units||[]).filter(v=>v.hp>0 && v.p!==u.p && v.flying && canTarget(u,v));
      enemies.sort((a,b)=> (Math.abs(a.x-u.x)+Math.abs(a.y-u.y))-(Math.abs(b.x-u.x)+Math.abs(b.y-u.y)));
      if (enemies[0] && Math.abs(enemies[0].x-u.x)+Math.abs(enemies[0].y-u.y)<=u.range) targetUnit = enemies[0];
    }

    if (!targetUnit && u.targets !== "buildings") targetUnit = findNearestEnemyUnit(st.units, u.p, u, u.range);
    if (!targetUnit) targetStruct = findNearestEnemyStructure(st.structures, u.p, u, u.range);

    if (targetUnit || targetStruct){
      if (now >= (u.nextAtk||0)){
        const dmg = u.dmg|0;
        pushFx(st, u.x, u.y, attackGlyph(u.type), (u.p===0?"#60a5fa":"#f87171"), 0, 520);
        if (targetUnit){
          if (u.chargeDmg && u.chargeRange && (Math.abs(targetUnit.x-u.x)+Math.abs(targetUnit.y-u.y))<=u.chargeRange){
            applyDamageToUnit(st, u, targetUnit, u.chargeDmg, now);
            u.stunUntil = Math.max(u.stunUntil||0, now + (u.chargeSelfStunMs||0));
            pushFx(st, targetUnit.x, targetUnit.y, "üí¢", "#fca5a5");
            pushFx(st, targetUnit.x, targetUnit.y, "-", "#fca5a5", 120, 500);
          } else if (u.cleaveRadius){
            for (const v of st.units){
              if (v.hp<=0 || v.p===u.p) continue;
              if (!canTarget(u,v)) continue;
              if (inRadius(targetUnit.x,targetUnit.y,v.x,v.y,u.cleaveRadius|0)) applyDamageToUnit(st, u, v, dmg, now);
            }
            pushFx(st, targetUnit.x, targetUnit.y, "ü™ì", "#fde68a");
            pushFx(st, targetUnit.x, targetUnit.y, "‚ú¥Ô∏è", "#fde68a", 110, 500);
          } else if (u.splash){
            for (const v of st.units){
              if (v.hp<=0 || v.p===u.p) continue;
              if (!canTarget(u,v)) continue;
              if (inRadius(targetUnit.x,targetUnit.y,v.x,v.y,u.splash|0)) applyDamageToUnit(st, u, v, dmg, now);
            }
            pushFx(st, targetUnit.x, targetUnit.y, "üî•", "#fdba74");
            pushFx(st, targetUnit.x, targetUnit.y, "üí´", "#fdba74", 90, 520);
          } else {
            applyDamageToUnit(st, u, targetUnit, dmg, now);
            pushFx(st, targetUnit.x, targetUnit.y, "üí•", "#fde68a");
            pushFx(st, targetUnit.x, targetUnit.y, "-", "#fef3c7", 100, 480);
          }
        } else if (targetStruct){
          targetStruct.hp -= Math.max(1, Math.floor(dmg * damageTakenMult(st, targetStruct.x,targetStruct.y)));
          pushFx(st, targetStruct.x, targetStruct.y, "üí•", "#e5e7eb");
          pushFx(st, targetStruct.x, targetStruct.y, "-", "#f3f4f6", 120, 480);
        }
        u.nextAtk = now + (u.cdMs||1000);
      }
      continue;
    }

    if (now < (u.nextMove||0)) continue;
    u.nextMove = now + Math.max(180, Math.floor((u.spdMs||560) * speedMult(st, u)));

    const enemyP = u.p===0 ? 1 : 0;
    const candidates = enemyStructPriority(st.structures, enemyP);
    if (!candidates.length) continue;

    candidates.sort((a,b)=> (Math.abs(a.x-u.x)+Math.abs(a.y-u.y)) - (Math.abs(b.x-u.x)+Math.abs(b.y-u.y)));
    const tgt = candidates[0];

    const goals = new Set();
    for (let yy=0;yy<H;yy++){
      for (let xx=0;xx<W;xx++){
        if (!walkable(st.structures, xx,yy, !!u.flying)) continue;
        const d = Math.abs(xx-tgt.x)+Math.abs(yy-tgt.y);
        if (d <= (u.range||1)) goals.add(keyXY(xx,yy));
      }
    }
    const step = bfsNextStep(st.structures, {x:u.x,y:u.y}, goals, !!u.flying);
    if (step){ u.x = step.x; u.y = step.y; }
  }

  // split deaths
  const splitAdds = [];
  for (const u of st.units||[]){
    if (u.hp>0 || !u.splitInto || !u.splitCount) continue;
    for (let i=0;i<u.splitCount;i++){
      const spots = neighbors4(u.x,u.y).concat([{x:u.x,y:u.y}]).filter(s=>inside(s.x,s.y) && walkable(st.structures,s.x,s.y,false));
      const spot = spots[i % Math.max(1,spots.length)] || {x:u.x,y:u.y};
      splitAdds.push(newUnit(u.p, u.splitInto, spot.x, spot.y));
    }
    pushFx(st, u.x, u.y, "ü™®", "#93c5fd");
  }

  // structure AI: shoot nearest enemy unit
  for (const s of (st.structures||[])){
    if (s.hp<=0) continue;
    if (now < (s.nextAtk||0)) continue;
    const enemy = findNearestEnemyUnit(st.units, s.p, {x:s.x,y:s.y}, s.range||4);
    if (!enemy) continue;
    enemy.hp -= (s.dmg|0);
    s.nextAtk = now + (s.cdMs||1100);
    pushFx(st, s.x, s.y, "üèπ", (s.p===0 ? "#60a5fa" : "#f87171"), 0, 500);
    pushFx(st, enemy.x, enemy.y, "üí•", (s.p===0 ? "#60a5fa" : "#f87171"));
  }

  // clamp hp + remove dead units
  for (const s of (st.structures||[])) s.hp = Math.max(0, s.hp|0);
  st.units = (st.units||[]).filter(u=>u.hp>0);
  if (typeof splitAdds !== "undefined" && splitAdds.length) st.units.push(...splitAdds);

  // crown awards on structure death transitions
  for (const s of (st.structures||[])){
    const before = prevHP.get(s.id);
    if (before > 0 && s.hp <= 0){
      awardCrown(st, s);
      if (s.kind==="tower") pushFx(st, s.x, s.y, "üëë", "#fbbf24");
      if (s.kind==="castle") pushFx(st, s.x, s.y, "üí•üè∞", "#fb7185");
    }
  }

  // immediate win if castle destroyed
  const p0Castle = st.structures.find(x=>x.id==="p0_c");
  const p1Castle = st.structures.find(x=>x.id==="p1_c");
  if (p0Castle && p0Castle.hp<=0){
    st.phase = "gameover";
    st.winner = 1;
    st.winReason = "castle";
  } else if (p1Castle && p1Castle.hp<=0){
    st.phase = "gameover";
    st.winner = 0;
    st.winReason = "castle";
  }

  st.lastTickAt = now;
}

/* ---------------- Host loop (transaction-safe) ---------------- */
function startHostLoop(){
  if (!isHost || hostTimer) return;
  hostTimer = setInterval(async ()=>{
    try{
      await runTransaction(db, async (tx)=>{
        const snap = await tx.get(stateRef);
        if (!snap.exists()) return;
        const st = snap.data();

        const players = Array.isArray(st.players) ? st.players.slice(0,2) : [];

        // waiting draft phase
        if (st.phase === "waiting" && players.length>=2){
          const now = Date.now();
          const readyMap = st.readyMap || {};
          const bothReady = !!readyMap[players[0]] && !!readyMap[players[1]];
          const draftEndsAt = st.draftEndsAt || (now + DRAFT_MS);
          if (!st.draftEndsAt){
            tx.set(stateRef, { draftEndsAt }, { merge:true });
            return;
          }
          if (!(bothReady || now >= draftEndsAt)) return;
          const p0Name = players[0] || "p0";
          const p1Name = players[1] || "p1";
          const deck0 = seededShuffle(deckForPlayer(p0Name), gameId + ":p0");
          const deck1 = seededShuffle(deckForPlayer(p1Name), gameId + ":p1");
          tx.set(stateRef, {
            ...st,
            phase:"battle",
            winner:null,
            winReason:null,
            startedAt: now,
            draftEndsAt:null,
            readyMap:{},
            lastTickAt: now,
            endsAt: now + MATCH_MS,
            crowns:[0,0],
            elixir:[0,0],
            hand:{p0:deck0.slice(0,4), p1:deck1.slice(0,4)},
            queue:{p0:deck0.slice(4),  p1:deck1.slice(4)},
            structures: initialStructures(),
            units:[],
            orders:[],
            fx:[],
            auras:[],
            eloApplied:false
          }, { merge:true });
          return;
        }

        if (st.phase !== "battle") return;

        const next = JSON.parse(JSON.stringify(st));
        tickSim(next);
        tx.set(stateRef, next, { merge:true });
      });
    }catch(e){
      console.warn("host tick failed", e);
    }
  }, TICK_MS);
}


function expectedScore(a,b){ return 1/(1+Math.pow(10,(b-a)/400)); }
async function applyEloIfNeeded(st){
  if (!isHost || !st || st.phase!=="gameover" || st.eloApplied) return;
  const p0 = st.players?.[0], p1 = st.players?.[1];
  if (!p0 || !p1) return;
  const w = st.winner;
  await runTransaction(db, async (tx)=>{
    const lobSnap = await tx.get(lobbyRef);
    const lob = lobSnap.exists()?lobSnap.data():{};
    const eloMap = { ...(lob.eloMap||{}) };
    const r0 = eloMap[p0]||1000, r1 = eloMap[p1]||1000;
    const e0 = expectedScore(r0,r1), e1 = expectedScore(r1,r0);
    const s0 = w===0?1:w===1?0:0.5;
    const s1 = w===1?1:w===0?0:0.5;
    eloMap[p0] = Math.max(600, Math.round(r0 + ELO_K*(s0-e0)));
    eloMap[p1] = Math.max(600, Math.round(r1 + ELO_K*(s1-e1)));
    tx.set(lobbyRef, { eloMap, updatedAt: Date.now() }, { merge:true });
    tx.set(stateRef, { eloApplied:true }, { merge:true });
  });
}

/* ---------------- Rendering ---------------- */
let uiClock = null;
function pad2(n){ return String(n).padStart(2,"0"); }
function fmtMMSS(ms){
  const s = Math.max(0, Math.ceil(ms/1000));
  const m = Math.floor(s/60);
  const r = s%60;
  return `${m}:${pad2(r)}`;
}

function render(){
  if (!S){
    timerText.textContent = "‚Äî";
    crownText.textContent = "0‚Äì0";
    return;
  }

  const players = Array.isArray(S.players) ? S.players : [];
  const me = players[meIndex] || username;
  const opp = players[1-meIndex] || (players.length<2 ? "Waiting‚Ä¶" : "Opponent");
  meNameEl.textContent = me;
  oppNameEl.textContent = opp;
  const meElo = lobbyMeta.eloMap?.[me] || 1000;
  const oppElo = lobbyMeta.eloMap?.[opp] || 1000;
  const meSide = meIndex===0 ? "Bottom" : "Top";
  const oppSide = meIndex===0 ? "Top" : "Bottom";
  meEloEl.textContent = `ELO ${meElo} ‚Ä¢ ${meSide} ‚Ä¢ ${meIndex===0?"Blue":"Red"}`;
  oppEloEl.textContent = `ELO ${oppElo} ‚Ä¢ ${oppSide} ‚Ä¢ ${meIndex===0?"Red":"Blue"}`;
  $("meBadge").classList.toggle("blue", meIndex===0);
  $("meBadge").classList.toggle("red", meIndex===1);
  $("oppBadge").classList.toggle("blue", meIndex===1);
  $("oppBadge").classList.toggle("red", meIndex===0);


  // timer + crowns
  const c0 = S.crowns?.[0] ?? 0;
  const c1 = S.crowns?.[1] ?? 0;
  crownText.textContent = `${c0}‚Äì${c1}`;

  if (S.phase === "battle" && S.endsAt){
    timerText.textContent = fmtMMSS(S.endsAt - Date.now());
  } else if (S.phase === "waiting"){
    timerText.textContent = fmtMMSS((S.draftEndsAt||Date.now()) - Date.now());
  } else {
    timerText.textContent = "‚Äî";
  }

  if (S.phase === "waiting"){
    hint("30s draft: pick up to 8, tap again to remove, then press ready.");
  } else if (S.phase === "battle"){
    hint(selectedCard ? `Selected: ${CARDS[selectedCard].emoji} ${CARDS[selectedCard].name} ‚Äî tap a tile to play` : "Tap a card, then tap a tile to play.");
  } else if (S.phase === "gameover"){
    let msg = "Game Over.";
    if (S.winReason === "castle"){
      msg = (S.winner===meIndex) ? "YOU WIN üèÜ (Castle destroyed!)" : "YOU LOSE üíÄ (Castle destroyed!)";
    } else if (S.winReason === "crowns"){
      msg = (S.winner===meIndex) ? `YOU WIN üèÜ (Crowns ${c0}‚Äì${c1})` : `YOU LOSE üíÄ (Crowns ${c0}‚Äì${c1})`;
    } else if (S.winReason === "draw"){
      msg = `DRAW ü§ù (Crowns ${c0}‚Äì${c1})`;
    }
    hint(msg);
  }

  // my elixir
  const e = S.elixir?.[meIndex] ?? 0;
  elixirNum.textContent = String(Math.floor(e));
  elixirFill.style.width = (100 * (e/MAX_ELIXIR)) + "%";
  elixirWrap.style.display = (S.phase==="battle") ? "flex" : "none";
  const isDrafting = (S.phase==="waiting" && players.length>=2);
  draftBar.style.display = isDrafting ? "none" : "none";
  draftOverlay.classList.toggle("show", isDrafting);
  const myDeck = deckForPlayer(username);
  const deckCount = myDeck.length;
  const rm = S.readyMap || {};
  const readyCount = players.filter(n=>rm[n]).length;
  const draftText = `Deck ${deckCount}/8 ‚Ä¢ Ready ${readyCount}/${Math.min(players.length,2)} ‚Ä¢ ${fmtMMSS((S.draftEndsAt||Date.now())-Date.now())}`;
  draftInfo.textContent = draftText;
  draftInfoOverlay.textContent = draftText;
  const readyLabel = rm[username] ? "‚úÖ Ready" : "Ready";
  readyBtn.textContent = readyLabel;
  readyBtnOverlay.textContent = readyLabel;

  // cards / deck builder
  const pk = (meIndex===0) ? "p0" : "p1";
  const hand = (S.hand && S.hand[pk]) ? S.hand[pk] : [];
  const myElo = lobbyMeta.eloMap?.[username] || 1000;
  cardsEl.innerHTML = "";
  draftCardsEl.innerHTML = "";
  const activeCardsEl = isDrafting ? draftCardsEl : cardsEl;

  const sourceCards = (S.phase === "waiting") ? CARD_POOL : hand;
  for (const cid of sourceCards){
    const c = CARDS[cid];
    if (!c) continue;
    const req = ELO_REQ[cid] || 0;
    const locked = req > myElo;
    const inDeck = myDeck.includes(cid);
    const el = document.createElement("div");
    const selected = (S.phase === "waiting") ? inDeck : selectedCard===cid;
    el.className = "card" + (selected ? " sel" : "");
    el.innerHTML = `
      <div class="top"><div class="cost">${c.cost}</div></div>
      <div class="mid"><div class="emoji" title="${c.name}">${c.emoji}</div></div>
      ${locked ? `<div class="lock">ELO ${req}</div>` : ""}
    `;
    el.style.opacity = locked ? ".45" : "1";
    el.addEventListener("click", async ()=>{
      if (locked){ toast(`Requires ELO ${req}`); return; }
      if (S.phase === "waiting"){
        const next = myDeck.slice();
        const i = next.indexOf(cid);
        if (i>=0) next.splice(i,1); else if (next.length<8) next.push(cid);
        try{ await updateDoc(lobbyRef, { [`deckMap.${username}`]: next, updatedAt: Date.now() }); }
        catch(e){ console.warn(e); }
        return;
      }
      if (S.phase !== "battle"){ toast("Match not active."); return; }
      if (!hand.includes(cid)){ toast("Card not in hand."); return; }
      if (selectedCard === cid){ selectedCard = null; cancelBtn.style.display="none"; render(); return; }
      selectedCard = cid;
      cancelBtn.style.display="inline-block";
      render();
    });
    activeCardsEl.appendChild(el);
  }

  cancelBtn.style.display = (S.phase==="battle" && selectedCard) ? "inline-block" : "none";

  paintBoard();
  paintFx();
}

readyBtn.addEventListener("click", async ()=>{
  if (!S || S.phase!=="waiting") return;
  if ((S.players||[]).length<2){ toast("Waiting for opponent"); return; }
  try{
    await updateDoc(stateRef, { [`readyMap.${username}`]: !(S.readyMap?.[username]), lastReadyAt: Date.now() });
  }catch(e){ console.warn(e); toast("Ready update failed"); }
});
readyBtnOverlay.addEventListener("click", async ()=>{
  if (!S || S.phase!=="waiting") return;
  if ((S.players||[]).length<2){ toast("Waiting for opponent"); return; }
  try{
    await updateDoc(stateRef, { [`readyMap.${username}`]: !(S.readyMap?.[username]), lastReadyAt: Date.now() });
  }catch(e){ console.warn(e); toast("Ready update failed"); }
});

fullscreenBtn.addEventListener("click", async ()=>{
  try{
    if (!document.fullscreenElement) await document.documentElement.requestFullscreen();
    else await document.exitFullscreen();
  }catch(e){ console.warn(e); toast("Fullscreen unavailable on this device."); }
});

cancelBtn.addEventListener("click", ()=>{
  selectedCard = null;
  cancelBtn.style.display="none";
  render();
});

function paintBoard(){
  const structs = S.structures || [];
  const units = S.units || [];

  const groups = new Map();
  for (const u of units){
    if (u.hp<=0) continue;
    const k = keyXY(u.x,u.y);
    if (!groups.has(k)) groups.set(k, []);
    groups.get(k).push(u);
  }

  for (let y=0;y<H;y++){
    for (let x=0;x<W;x++){
      const cell = getCell(x,y);
      const under = cell.querySelector(".under");
      const piece = cell.querySelector(".piece");
      cell.classList.remove("placeHint","placeBlocked");
      const hpFill= cell.querySelector(".hp>i");

      under.style.background = "transparent";
      piece.innerHTML = "";
      piece.style.opacity = "1";
      hpFill.style.width = "0%";
      hpFill.className = "neutral";

      if (S.phase==="battle" && selectedCard){
        const c = CARDS[selectedCard];
        if (c){
          let valid = true;
          if (c.place === "friendly" && !onMySide(meIndex,x,y)) valid = false;
          if (c.place === "friendly" && isRiver(x,y)) valid = false;
          if (c.place === "friendly" && isStructureTile(S.structures,x,y)) valid = false;
          cell.classList.add(valid ? "placeHint" : "placeBlocked");
        }
      }

      const s = structureAt(structs,x,y);
      if (s && s.hp>0){
        const svg = spriteForStructure(s.kind);
        piece.innerHTML = wrapSprite(svg, s.p);
        under.style.background = `radial-gradient(circle at top, rgba(255,255,255,.12), rgba(0,0,0,0))`;

        const pct = Math.round(100 * (s.hp/s.maxhp));
        hpFill.style.width = pct + "%";
        hpFill.className = (s.p===0) ? "p0" : "p1";
        continue;
      }

      const g = groups.get(keyXY(x,y));
      if (g && g.length){
        const top = g[0];
        const svg = spriteForUnit(top.type);
        piece.innerHTML = wrapSprite(svg, top.p);
        if (top.type==="assassin" && !top.revealed && top.p!==meIndex){
          piece.style.opacity = ".25";
        } else {
          piece.style.opacity = "1";
        }

        if (g.length > 1){
          const badge = document.createElement("div");
          badge.className = "stack";
          badge.textContent = `+${g.length-1}`;
          piece.appendChild(badge);
        }

        const pct = Math.round(100 * (top.hp/top.maxhp));
        hpFill.style.width = pct + "%";
        hpFill.className = (top.p===0) ? "p0" : "p1";
      }
    }
  }
}

function paintFx(){
  fxEl.innerHTML = "";
  const now = Date.now();
  for (const f of (S.fx||[])){
    if (f.at + (f.ttl||FX_TTL) <= now) continue;
    fxPop(f.x, f.y, f.text || "‚ú®", f.color || "#e5e7eb");
  }
}

/* ---------------- Input: card -> click tile -> send order ---------------- */
async function onCellClick(x,y){
  if (!S || S.phase !== "battle") return;
  if (selectedCard == null){ toast("Pick a card first."); return; }

  const card = CARDS[selectedCard];
  if (!card) return;

  const myE = S.elixir?.[meIndex] ?? 0;
  if (myE + 1e-9 < (card.cost|0)){
    toast("Not enough elixir.");
    return;
  }
  if (card.place === "friendly" && !onMySide(meIndex, x,y)){
    toast("Troops must be placed on your side.");
    return;
  }
  if (card.place === "friendly" && isRiver(x,y)){
    toast("Can't place troops in the river.");
    return;
  }
  if (card.place === "friendly" && isStructureTile(S.structures, x,y)){
    toast("Can't place on a tower/castle.");
    return;
  }

  const order = { id: crypto.randomUUID(), p: meIndex, card: selectedCard, x, y, at: Date.now() };
  try{
    await runTransaction(db, async (tx)=>{
      const snap = await tx.get(stateRef);
      if (!snap.exists()) return;
      const st = snap.data();
      const ord = Array.isArray(st.orders) ? st.orders.slice() : [];
      ord.push(order);
      tx.update(stateRef, { orders: ord });
    });
  }catch(e){
    console.warn(e);
    toast("Play failed (retry).");
    return;
  }

  selectedCard = null;
  cancelBtn.style.display="none";
  render();
}

/* ---------------- Listen to lobby + state ---------------- */
function startListeners(){
  if (started) return;
  started = true;

  onSnapshot(lobbyRef, async (snap)=>{
    const lob = snap.exists() ? snap.data() : {};
    lobbyMeta = { eloMap: lob.eloMap||{}, deckMap: lob.deckMap||{} };
    lobbyPlayers = Array.isArray(lob.players) ? lob.players.slice(0,2) : lobbyPlayers;
    isHost = (lobbyPlayers[0] === username);
    await syncPlayersIntoStateIfNeeded();
    startHostLoop();
  });

  onSnapshot(stateRef, (snap)=>{
    if (!snap.exists()) return;
    S = snap.data();
    applyEloIfNeeded(S).catch(console.warn);
    render();
  });

  // local UI clock for timer text smoothness
  if (!uiClock){
    uiClock = setInterval(()=>{
      if (S && S.phase==="battle" && S.endsAt){
        timerText.textContent = fmtMMSS(S.endsAt - Date.now());
      }
      if (S && S.phase==="waiting" && S.draftEndsAt){
        timerText.textContent = fmtMMSS(S.draftEndsAt - Date.now());
      }
    }, 250);
  }
}

/* ---------------- Boot ---------------- */
onAuthStateChanged(auth, async (user)=>{
  if (!user) return;
  try{
    await joinLobby();
    await ensureStateExists();
    await syncPlayersIntoStateIfNeeded();
    startHostLoop();
    startListeners();
  }catch(e){
    console.error(e);
    toast("Init error. Check Firestore rules.", 2400);
  }
});
</script>
</body>
</html>











