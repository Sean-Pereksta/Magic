<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>üè∞ Royale Grid ‚Äî Firebase Clash</title>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<style>
  :root{
    --bg:#07090c;
    --panel: rgba(12,14,18,.78);
    --stroke: rgba(255,255,255,.12);
    --txt:#e7eef7;
    --muted: rgba(231,238,247,.70);
    --accent:#38bdf8;

    --p0:#60a5fa; /* blue side */
    --p1:#f87171; /* red side */

    /* IMPORTANT: board sizing now comes ONLY from these vars (no inline overrides) */
    --cell:32px;
    --gap:4px;

    --topH:52px;
    --hudH:148px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    background:
      radial-gradient(circle at 15% 10%, rgba(99,102,241,.25), transparent 40%),
      radial-gradient(circle at 85% 20%, rgba(236,72,153,.22), transparent 40%),
      radial-gradient(circle at 50% 100%, #090b14 0, #05060a 60%, #02030a 100%);
    color:var(--txt);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    overflow:hidden;
    touch-action:none;
  }

  .topbar{
    height:var(--topH);
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:6px 10px;
    background: linear-gradient(90deg,#020617,#070a12,#0b1020);
    border-bottom:1px solid rgba(148,163,184,.25);
    box-shadow:0 16px 40px rgba(0,0,0,.55);
    gap:8px;
    position:relative;
    z-index:50;
  }
  .leftTools,
  .centerHud,
  .playerMeta{display:flex; align-items:center; gap:8px;}
  .centerHud{flex:1; justify-content:center;}
  .badge{
    display:inline-flex; align-items:center; gap:8px;
    padding:6px 10px;
    border-radius:999px;
    background:rgba(2,6,23,.85);
    border:1px solid rgba(148,163,184,.28);
    font-weight:900;
    font-size:.8rem;
    color:#e5e7eb;
    backdrop-filter: blur(10px);
    white-space:nowrap;
  }
  .badge.blue{ border-color: rgba(96,165,250,.5); box-shadow:0 0 0 1px rgba(96,165,250,.2) inset; }
  .badge.red{ border-color: rgba(248,113,113,.5); box-shadow:0 0 0 1px rgba(248,113,113,.2) inset; }
  .badge small{opacity:.8; font-weight:800}
  #timerBadge{display:none;}
  .playerBadgeName{font-weight:900; max-width:110px; overflow:hidden; text-overflow:ellipsis;}
  .btn{
    appearance:none;
    border-radius:999px;
    padding:7px 11px;
    font-weight:900;
    cursor:pointer;
    border:1px solid rgba(148,163,184,.35);
    background:rgba(2,6,23,.72);
    color:#e5e7eb;
    font-size:.85rem;
  }
  .btn:hover{border-color:var(--accent)}
  .btn:active{transform:translateY(1px)}
  .btn.fullscreenBtn{
    border-color: rgba(56,189,248,.65);
    box-shadow: 0 0 0 1px rgba(56,189,248,.25) inset;
  }

  .wrap{
    height: calc(100dvh - var(--topH) - var(--hudH));
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
    overflow:hidden;
    padding:10px;
  }

  .arenaWindow{
    width:100%;
    height:100%;
    border-radius:20px;
    border:1px solid rgba(148,163,184,.35);
    background:linear-gradient(180deg, rgba(2,6,23,.72), rgba(2,6,23,.52));
    box-shadow:0 22px 48px rgba(0,0,0,.45), 0 0 0 1px rgba(56,189,248,.2) inset;
    padding:6px;
  }

  .viewport{
    width:100%;
    height:100%;
    position:relative;
    overflow:hidden;
    display:grid;
    place-items:center;
    user-select:none;
    border-radius:14px;
    touch-action:none; /* we handle panning + pinch ourselves */
  }

  .canvas{
    transform-origin: 0 0;
    will-change: transform;
    position:relative;
  }

  .grid{
    display:grid;
    grid-template-columns: repeat(var(--w), var(--cell));
    grid-auto-rows: var(--cell);
    gap:var(--gap);
    padding:12px;
    border-radius:22px;
    background:
      linear-gradient(180deg, rgba(22,163,74,.28), rgba(101,67,33,.25) 38%, rgba(22,163,74,.22) 100%),
      linear-gradient(160deg, rgba(15,23,42,.85), rgba(2,6,23,.92));
    box-shadow: 0 25px 60px rgba(0,0,0,.55), 0 0 0 1px rgba(148,163,184,.25) inset;
  }
  .cell{
    width:var(--cell); height:var(--cell);
    border-radius:12px;
    border:1px solid rgba(255,255,255,.10);
    background:
      radial-gradient(circle at 28% 26%, rgba(34,197,94,.18), transparent 45%),
      radial-gradient(circle at 70% 60%, rgba(59,130,246,.16), transparent 55%),
      linear-gradient(145deg, rgba(15,23,42,.35), rgba(2,6,23,.55));
    box-shadow: 0 1px 0 rgba(255,255,255,.10) inset, 0 10px 25px rgba(0,0,0,.25);
    position:relative;
    overflow:hidden;
    cursor:pointer;
  }
  .cell.side0{
    background:
      radial-gradient(circle at 30% 26%, rgba(59,130,246,.20), transparent 45%),
      radial-gradient(circle at 72% 60%, rgba(14,116,144,.18), transparent 55%),
      linear-gradient(145deg, rgba(15,23,42,.35), rgba(2,6,23,.55));
  }
  .cell.side1{
    background:
      radial-gradient(circle at 30% 26%, rgba(239,68,68,.18), transparent 45%),
      radial-gradient(circle at 72% 60%, rgba(244,114,182,.14), transparent 55%),
      linear-gradient(145deg, rgba(15,23,42,.35), rgba(2,6,23,.55));
  }
  .cell.river{
    background:
      linear-gradient(100deg, rgba(14,116,144,.9), rgba(56,189,248,.72) 45%, rgba(14,165,233,.85)),
      radial-gradient(circle at 20% 20%, rgba(186,230,253,.45), transparent 55%),
      linear-gradient(145deg, rgba(2,6,23,.72), rgba(15,23,42,.82));
    border-color: rgba(56,189,248,.48);
  }
  .cell.river::before{
    content:"";
    position:absolute;
    inset:-20% -120%;
    background:repeating-linear-gradient(95deg, rgba(186,230,253,.28) 0 8px, rgba(14,116,144,0) 8px 20px);
    animation:streamFlow 1.2s linear infinite;
    opacity:.8;
    pointer-events:none;
  }
  .cell.river::after{
    content:"";
    position:absolute;
    inset:0;
    background:linear-gradient(180deg, rgba(255,255,255,.22), rgba(255,255,255,0) 45%, rgba(8,47,73,.36));
    mix-blend-mode:screen;
    pointer-events:none;
  }
  .cell.bridge{
    background:
      linear-gradient(180deg, rgba(92,51,23,.92), rgba(55,31,13,.96)),
      repeating-linear-gradient(90deg, rgba(120,72,34,.95) 0 8px, rgba(76,41,18,.95) 8px 16px);
    border-color: rgba(180,83,9,.75);
    box-shadow: 0 0 0 1px rgba(251,191,36,.22) inset, 0 10px 18px rgba(0,0,0,.35);
  }
  .cell.bridge::before{
    content:"";
    position:absolute;
    inset:5px 2px;
    border-radius:9px;
    background:repeating-linear-gradient(180deg, rgba(217,119,6,.35) 0 3px, rgba(146,64,14,.1) 3px 8px);
    box-shadow:0 0 0 1px rgba(251,191,36,.28) inset;
    pointer-events:none;
  }
  .cell.bridge::after{
    content:"";
    position:absolute;
    left:4px; right:4px; top:4px; bottom:4px;
    border-top:2px solid rgba(254,215,170,.45);
    border-bottom:2px solid rgba(254,215,170,.45);
    border-radius:8px;
    pointer-events:none;
  }
  .cell.blocked::after{
    content:"";
    position:absolute; inset:0;
    background: linear-gradient(135deg, rgba(148,163,184,.08), rgba(0,0,0,.0));
    opacity:.55;
    pointer-events:none;
  }
  .cell.placeHint::before{
    content:"";
    position:absolute; inset:3px;
    border-radius:10px;
    border:2px dashed rgba(110,231,183,.9);
    background: rgba(16,185,129,.16);
    box-shadow:0 0 18px rgba(16,185,129,.35);
    pointer-events:none;
    z-index:2;
  }
  .cell.placeBlocked::before{
    content:"";
    position:absolute; inset:3px;
    border-radius:10px;
    border:2px dashed rgba(248,113,113,.7);
    background: rgba(239,68,68,.12);
    pointer-events:none;
    z-index:2;
  }

  .under{
    position:absolute; inset:0;
    opacity:.95;
  }

  /* --- SPRITES (SVG) --- */
  .piece{
    position:absolute; inset:0;
    display:grid; place-items:center;
    z-index:3;
    pointer-events:none;
    filter: drop-shadow(0 0 10px rgba(0,0,0,.65));
  }
  .sprite{
    width:44px; height:44px;
    display:grid; place-items:center;
  }
  .sprite svg{width:44px; height:44px}
  .team0{ --team: var(--p0); }
  .team1{ --team: var(--p1); }
  .sprite .teamFill{ fill: var(--team); }
  .sprite .teamStroke{ stroke: var(--team); }
  .sprite .ink{ fill: rgba(2,6,23,.92); }
  .sprite .shine{ fill: rgba(255,255,255,.22); }
  .sprite .steel{ fill: #cbd5e1; }
  .sprite .steel2{ fill:#94a3b8; }
  .sprite .stone{ fill:#94a3b8; }
  .sprite .stone2{ fill:#64748b; }
  .sprite .wood{ fill:#a16207; }
  .sprite .cloth{ fill:#a855f7; }
  .sprite .cloth2{ fill:#7c3aed; }
  .sprite .skin{ fill:#fde68a; }
  .sprite .gob{ fill:#22c55e; }
  .sprite .gob2{ fill:#16a34a; }
  .sprite .giant{ fill:#c084fc; }
  .sprite .giant2{ fill:#a855f7; }
  .sprite .bone{ fill:#e2e8f0; }
  .sprite .bone2{ fill:#cbd5e1; }
  .sprite .slime{ fill:#c4b5fd; }
  .sprite .slime2{ fill:#a78bfa; }
  .sprite .fire{ fill:#fb923c; }
  .sprite .fire2{ fill:#f97316; }
  .sprite .ice{ fill:#bfdbfe; }
  .sprite .ice2{ fill:#93c5fd; }
  .sprite .poison{ fill:#86efac; }
  .sprite .poison2{ fill:#4ade80; }
  .sprite .gold{ fill:#fbbf24; }

  .piece .stack{
    position:absolute;
    right:6px; top:6px;
    font-size:11px;
    font-weight:1000;
    padding:2px 6px;
    border-radius:999px;
    background:rgba(2,6,23,.85);
    border:1px solid rgba(148,163,184,.25);
    color:#e5e7eb;
  }

  .hp{
    position:absolute; left:6px; right:6px; bottom:6px; height:7px;
    background:rgba(2,6,23,.85);
    border:1px solid rgba(148,163,184,.20);
    border-radius:999px;
    overflow:hidden;
    z-index:4;
  }
  .hp > i{display:block; height:100%; width:0%;}
  .hp .p0{background:linear-gradient(90deg, var(--p0), #2563eb); box-shadow:0 0 16px rgba(96,165,250,.55)}
  .hp .p1{background:linear-gradient(90deg, var(--p1), #dc2626); box-shadow:0 0 16px rgba(248,113,113,.55)}
  .hp .neutral{background:linear-gradient(90deg, #a3e635, #22c55e)}

  .hint{
    position:absolute;
    left:50%; top:10px; transform:translateX(-50%);
    padding:8px 12px;
    border-radius:999px;
    background:rgba(2,6,23,.78);
    border:1px solid rgba(148,163,184,.25);
    font-weight:900;
    font-size:.85rem;
    color:#e5e7eb;
    z-index:20;
    display:none;
    max-width:92vw;
    text-align:center;
  }

  /* HUD */
  .hud{
    height:var(--hudH);
    background: linear-gradient(180deg, rgba(2,6,23,.55), rgba(2,6,23,.92));
    border-top:1px solid rgba(148,163,184,.20);
    box-shadow: 0 -18px 40px rgba(0,0,0,.55);
    padding:7px 9px;
    display:grid;
    grid-template-columns: 1fr;
    gap:8px;
  }
  .selectedTray{
    min-height:44px;
    border:1px solid rgba(56,189,248,.35);
    border-radius:12px;
    background:rgba(2,6,23,.68);
    box-shadow:0 0 0 1px rgba(56,189,248,.18) inset;
    display:flex;
    align-items:center;
    gap:6px;
    padding:5px 8px;
    overflow-x:auto;
    touch-action:pan-x;
  }
  .trayHint{
    font-size:.74rem;
    font-weight:800;
    color:var(--muted);
    white-space:nowrap;
  }
  .trayCard{
    flex:0 0 auto;
    min-width:58px;
    border:1px solid rgba(148,163,184,.35);
    border-radius:10px;
    background:rgba(15,23,42,.85);
    color:#dbe8f8;
    display:grid;
    place-items:center;
    gap:2px;
    padding:4px 7px;
    font-weight:900;
    cursor:pointer;
  }
  .trayCard .name{font-size:.57rem;max-width:84px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
  .trayCard .cost{font-size:.62rem; color:#c4b5fd;}
  .trayCard .icon svg{width:26px;height:26px; display:block}
  .hudTop{display:flex; align-items:center; justify-content:space-between; gap:10px;}
  .elixirWrap{
    display:flex; align-items:center; gap:10px; width:100%;
    max-width: 820px;
  }
  .elixirLabel{
    font-weight:1000; letter-spacing:.02em;
    color:#e5e7eb;
    display:flex; align-items:center; gap:8px;
    white-space:nowrap;
  }
  .elixirBar{
    flex:1;
    height:14px;
    border-radius:999px;
    background:rgba(255,255,255,.06);
    border:1px solid rgba(148,163,184,.18);
    overflow:hidden;
    position:relative;
  }
  .elixirFill{
    height:100%;
    width:0%;
    background: linear-gradient(90deg, rgba(168,85,247,.92), rgba(236,72,153,.92));
    box-shadow:0 0 18px rgba(168,85,247,.45);
  }
  .elixirTicks{
    position:absolute; inset:0;
    display:grid;
    grid-template-columns: repeat(10,1fr);
    pointer-events:none;
    opacity:.45;
  }
  .elixirTicks i{ border-right:1px solid rgba(255,255,255,.10); }

  .cards{ display:grid; grid-template-columns:repeat(8,minmax(0,1fr)); gap:6px; }
  .card{
    min-width: 0;
    background: radial-gradient(circle at top, rgba(15,23,42,.95), rgba(2,6,23,.95));
    border:1px solid rgba(148,163,184,.25);
    border-radius:12px;
    padding:8px 6px;
    box-shadow: 0 12px 30px rgba(0,0,0,.35);
    cursor:pointer;
    user-select:none;
    position:relative;
    touch-action:manipulation;
  }
  .card.sel{outline:2px solid var(--accent); border-color: rgba(56,189,248,.45);}
  .trayCard.queued{ outline:2px solid rgba(251,191,36,.95); border-color: rgba(251,191,36,.55); }
  .card .top{display:flex; align-items:center; justify-content:center;}
  .card .name{
    margin-top:3px;
    text-align:center;
    font-size:.66rem;
    font-weight:800;
    line-height:1.15;
    color:#dbe8f8;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .card .cost{
    font-weight:1000;
    padding:3px 8px;
    border-radius:999px;
    background: rgba(168,85,247,.20);
    border:1px solid rgba(168,85,247,.35);
    font-size:.70rem;
  }
  .card .mid{ margin-top:2px; display:grid; place-items:center; }
  .card .icon svg{width:34px;height:34px; display:block}
  .card .lock{ font-size:.65rem; text-align:center; color:#fca5a5; font-weight:800; margin-top:4px; }

  .draftOverlay{
    position:fixed;
    inset:0;
    z-index:80;
    display:none;
    align-items:center;
    justify-content:center;
    padding:12px;
    background: rgba(2,6,23,.62);
    backdrop-filter: blur(8px);
    touch-action:auto;
  }
  .draftOverlay.show{ display:flex; }
  .draftPanel{
    width:min(920px, 96vw);
    max-height:min(78dvh, 700px);
    border-radius:18px;
    background: linear-gradient(180deg, rgba(8,13,26,.94), rgba(2,6,23,.96));
    border:1px solid rgba(148,163,184,.30);
    box-shadow:0 28px 70px rgba(0,0,0,.6);
    padding:12px;
    display:grid;
    grid-template-rows:auto auto 1fr;
    gap:10px;
    pointer-events:auto;
  }
  .draftHeader{display:flex; align-items:center; justify-content:space-between; gap:8px; flex-wrap:wrap;}
  .draftTitle{font-size:1rem; font-weight:1000; letter-spacing:.03em;}
  .draftInfo{ font-size:.84rem; color:var(--muted); font-weight:800; }
  .draftCardScroll{
    overflow:auto;
    padding-right:4px;
    max-height:min(52dvh, 460px);
    border:1px solid rgba(148,163,184,.22);
    border-radius:12px;
    touch-action:auto;
  }
  .draftCardScroll .cards{ grid-template-columns:repeat(4,minmax(0,1fr)); }

  .toast{
    position:fixed;
    left:50%;
    bottom: calc(var(--hudH) + 10px);
    transform:translateX(-50%);
    padding:10px 14px;
    border-radius:12px;
    background:rgba(2,6,23,.92);
    border:1px solid rgba(148,163,184,.25);
    box-shadow:0 18px 50px rgba(0,0,0,.55);
    z-index:60;
    display:none;
    max-width:92vw;
    text-align:center;
    font-weight:900;
  }

  /* FX overlay */
  .fx{
    position:absolute;
    pointer-events:none;
    z-index:120;
    left:0; top:0;
    width:100%;
    height:100%;
    overflow:visible;
  }
  .fxPop{
    position:absolute;
    transform:translate(-50%,-50%);
    font-weight:1000;
    font-size:14px;
    text-shadow:0 2px 10px rgba(0,0,0,.85);
    animation: pop 700ms ease-out forwards;
    white-space:nowrap;
  }
  .fxPop.impact{ font-size:16px; filter: drop-shadow(0 0 10px rgba(251,191,36,.8)); }
  .fxPop.slash{ font-size:20px; animation: slashPop 420ms ease-out forwards; }
  .fxPop.spell{ font-size:18px; animation-duration: 900ms; }
  .fxPop.explosion{ font-size:30px; animation: explodePop 760ms ease-out forwards; }
  .fxPop.hit{ font-size:15px; }

  .fxProjectile{
    position:absolute;
    left:var(--sx, 0px);
    top:var(--sy, 0px);
    width:var(--len, 22px);
    height:3px;
    transform: translate(-50%,-50%) rotate(var(--ang,0deg));
    transform-origin:0 50%;
    border-radius:999px;
    background:linear-gradient(90deg, rgba(255,255,255,.05), currentColor 45%, rgba(255,255,255,.98));
    box-shadow:0 0 12px currentColor;
    animation: projectileLine var(--dur, 280ms) linear forwards;
  }
  .fxProjectile::after{
    content:var(--tip, "");
    position:absolute;
    right:-10px;
    top:50%;
    transform:translateY(-50%);
    font-size:14px;
    text-shadow:0 0 10px currentColor;
  }
  .fxSpark{
    position:absolute;
    left:var(--x,0px);
    top:var(--y,0px);
    width:7px;
    height:7px;
    border-radius:999px;
    background:radial-gradient(circle, rgba(255,255,255,.95), rgba(251,191,36,.9) 45%, rgba(245,158,11,0));
    box-shadow:0 0 16px rgba(251,191,36,.75);
    transform:translate(-50%,-50%);
    animation:sparkBurst var(--dur,460ms) ease-out forwards;
  }

  @keyframes pop{
    0%{opacity:0; transform:translate(-50%,-35%) scale(.85)}
    20%{opacity:1; transform:translate(-50%,-50%) scale(1)}
    100%{opacity:0; transform:translate(-50%,-120%) scale(1.05)}
  }
  @keyframes slashPop{
    0%{opacity:0; transform:translate(-50%,-50%) scale(.45) rotate(-26deg)}
    35%{opacity:1; transform:translate(-50%,-50%) scale(1.16) rotate(12deg)}
    100%{opacity:0; transform:translate(-50%,-60%) scale(1.4) rotate(20deg)}
  }
  @keyframes explodePop{
    0%{opacity:0; transform:translate(-50%,-50%) scale(.3)}
    25%{opacity:1; transform:translate(-50%,-50%) scale(1.25)}
    100%{opacity:0; transform:translate(-50%,-70%) scale(1.8)}
  }
  @keyframes projectileLine{
    0%{ opacity:.95; transform:translate(-50%,-50%) rotate(var(--ang,0deg)) scaleX(.35); }
    100%{ opacity:1; transform:translate(calc(-50% + var(--dx, 0px)), calc(-50% + var(--dy, 0px))) rotate(var(--ang,0deg)) scaleX(1); }
  }
  @keyframes sparkBurst{
    0%{opacity:1; transform:translate(-50%,-50%) scale(.4);}
    100%{opacity:0; transform:translate(calc(-50% + var(--sx,0px)), calc(-50% + var(--sy,0px))) scale(1.6);}
  }
  @keyframes streamFlow{
    0%{ transform:translateX(0);}
    100%{ transform:translateX(80px);}
  }

  /* Mobile: significantly smaller tiles + default zoomed-out fit */
  @media (max-width: 720px){
    :root{ --cell:22px; --gap:2px; --topH:46px; --hudH:182px; }
    .grid{ padding:8px; border-radius:18px; }
    .badge{font-size:.72rem; padding:4px 8px}
    .btn{font-size:.72rem; padding:5px 8px}
    .wrap{height: calc(100dvh - var(--topH) - var(--hudH));}
    .hud{padding:6px; gap:6px;}
    .cards{grid-template-columns:repeat(4,minmax(0,1fr));}
    .card{padding:9px 5px; min-height:86px;}
    .card .name{display:block; font-size:.59rem;}
    .sprite, .sprite svg{width:30px; height:30px}
    .card .icon svg{width:28px;height:28px}
    .selectedTray{min-height:54px;}
    .trayCard{min-width:66px; min-height:42px;}
    .topbar{
      padding:5px 48px 5px 6px;
      gap:4px;
    }
    .leftTools{position:absolute; right:6px; top:5px;}
    .playerMeta,.centerHud{gap:4px;}
    .playerBadgeName{max-width:72px;}
    #timerBadge{display:none;}
    #meBadge small:first-child,
    #oppBadge small:first-child{display:none;}
    .draftPanel{max-height:min(82dvh, 760px);}
    .draftCardScroll .cards{ grid-template-columns:repeat(3,minmax(0,1fr)); }
  }
</style>
</head>
<body>
  <div class="topbar">
    <div class="playerMeta">
      <span id="meBadge" class="badge"><small>You</small> <span id="meName" class="playerBadgeName">‚Äî</span> <small id="meElo">(1000)</small></span>
    </div>
    <div class="centerHud">
      <span id="crownBadge" class="badge"><small>üëë</small> <span id="crownText">0‚Äì0</span></span>
      <span id="timerBadge" class="badge"><small>‚è±</small> <span id="timerText">‚Äî</span></span>
    </div>
    <div class="playerMeta" style="justify-content:flex-end;">
      <span id="oppBadge" class="badge"><small>Opp</small> <span id="oppName" class="playerBadgeName">‚Äî</span> <small id="oppElo">(1000)</small></span>
    </div>
    <div class="leftTools">
      <button id="fitBtn" class="btn" title="Re-center + fit">‚§¢ Fit</button>
      <button id="fullscreenBtn" class="btn fullscreenBtn" title="Toggle fullscreen">‚õ∂ Full</button>
    </div>
  </div>

  <div class="wrap">
    <div class="arenaWindow">
      <div class="viewport" id="viewport">
        <div class="hint" id="hint"></div>
        <div class="canvas" id="canvas">
          <!-- IMPORTANT: no inline --cell overrides anymore -->
          <div class="grid" id="grid" style="--w:9"></div>
          <div class="fx" id="fx"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="hud">
    <div class="hudTop">
      <div class="elixirWrap" id="elixirWrap">
        <div class="elixirLabel">üí† Elixir <span id="elixirNum">0</span>/10</div>
        <div class="elixirBar">
          <div class="elixirFill" id="elixirFill"></div>
          <div class="elixirTicks">
            <i></i><i></i><i></i><i></i><i></i><i></i><i></i><i></i><i></i><i></i>
          </div>
        </div>
      </div>
      <button id="cancelBtn" class="btn" style="display:none">‚úñ Clear</button>
    </div>

    <div class="selectedTray" id="selectedTray" title="Tap empty tray area to clear selection">
      <span class="trayHint">Tap cards below to queue. Tap here to unselect.</span>
    </div>

    <div class="cards" id="cards"></div>
  </div>

  <div class="toast" id="toast"></div>

  <div class="draftOverlay" id="draftOverlay">
    <div class="draftPanel">
      <div class="draftHeader">
        <div class="draftTitle">‚öîÔ∏è Draft your 8-card battle deck</div>
        <button id="readyBtnOverlay" class="btn">‚úÖ Ready</button>
      </div>
      <div class="draftInfo" id="draftInfoOverlay">Pick up to 8 cards.</div>
      <div class="draftCardScroll">
        <div class="cards" id="draftCards"></div>
      </div>
    </div>
  </div>

<script type="module">
/* ---------------- Firebase ---------------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, runTransaction
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};

const app  = initializeApp(firebaseConfig);
const db   = getFirestore(app);
const auth = getAuth(app);

signInAnonymously(auth).catch(console.error);

/* ---------------- URL params ---------------- */
const params   = new URLSearchParams(location.search);
const gameId   = params.get("gameId");
const username = params.get("username");
if (!gameId || !username) alert("Missing gameId or username in URL.");

/* Lobby + state refs */
const lobbyRef = doc(db, "lobbies", gameId);
const stateRef = doc(db, "lobbies", gameId, "crowncouncil", "forgeroyale_state");

/* ---------------- DOM ---------------- */
const $ = (id)=>document.getElementById(id);
const timerText = $("timerText");
const crownText = $("crownText");
const meNameEl  = $("meName");
const oppNameEl = $("oppName");
const meEloEl   = $("meElo");
const oppEloEl  = $("oppElo");
const gridEl    = $("grid");
const canvasEl  = $("canvas");
const viewport  = $("viewport");
const cardsEl   = $("cards");
const elixirNum = $("elixirNum");
const elixirFill= $("elixirFill");
const elixirWrap= $("elixirWrap");
const draftOverlay = $("draftOverlay");
const draftInfoOverlay = $("draftInfoOverlay");
const readyBtnOverlay = $("readyBtnOverlay");
const draftCardsEl = $("draftCards");
const fullscreenBtn = $("fullscreenBtn");
const fitBtn = $("fitBtn");
const hintEl    = $("hint");
const toastEl   = $("toast");
const cancelBtn = $("cancelBtn");
const selectedTray = $("selectedTray");
const fxEl      = $("fx");

/* ---------------- Board / grid ---------------- */
let W=9, H=12;
gridEl.style.setProperty("--w", W);

function keyXY(x,y){ return `${x},${y}`; }
function inside(x,y){ return x>=0 && x<W && y>=0 && y<H; }

const RIVER_Y0 = 5, RIVER_Y1 = 6;
const BRIDGES = new Set([ keyXY(2,RIVER_Y0), keyXY(2,RIVER_Y1), keyXY(6,RIVER_Y0), keyXY(6,RIVER_Y1) ]);

function isRiver(x,y){
  return (y===RIVER_Y0 || y===RIVER_Y1) && !BRIDGES.has(keyXY(x,y));
}
function isBridge(x,y){ return BRIDGES.has(keyXY(x,y)); }

/* Deploy zones */
function onMySide(p, x, y){
  if (p===0) return y >= (RIVER_Y1+1);   // bottom
  return y <= (RIVER_Y0-1);             // top
}

/* ---------------- Cards ---------------- */
const CARDS = {
  knight:  { id:"knight",  name:"Knight",  emoji:"üó°Ô∏è", kind:"troop", cost:3, place:"friendly", spawn:1,
             unit:{ hp:22, dmg:5, range:1, cdMs:900,  spdMs:520, targets:"all", canHitAir:false } },
  archers: { id:"archers", name:"Archers", emoji:"üèπ", kind:"troop", cost:3, place:"friendly", spawn:2,
             unit:{ hp:12, dmg:4, range:3, cdMs:1100, spdMs:560, targets:"all", canHitAir:true } },
  flameArchers: { id:"flameArchers", name:"Flame Archers", emoji:"üî•", kind:"troop", cost:4, place:"friendly", spawn:2,
             unit:{ hp:12, dmg:3, range:3, cdMs:1450, spdMs:580, targets:"all", canHitAir:true, burnMs:3000, burnDps:2 } },
  goblins: { id:"goblins", name:"Goblins", emoji:"üü¢", kind:"troop", cost:2, place:"friendly", spawn:3,
             unit:{ hp:8,  dmg:3, range:1, cdMs:700,  spdMs:480, targets:"all", canHitAir:false } },
  giant:   { id:"giant",   name:"Giant",   emoji:"ü™®", kind:"troop", cost:5, place:"friendly", spawn:1,
             unit:{ hp:48, dmg:6, range:1, cdMs:1200, spdMs:620, targets:"buildings", canHitAir:false } },
  wizard:  { id:"wizard",  name:"Wizard",  emoji:"üßô", kind:"troop", cost:4, place:"friendly", spawn:1,
             unit:{ hp:16, dmg:5, range:3, cdMs:1200, spdMs:600, targets:"all", splash:1, canHitAir:true } },
  golem:   { id:"golem", name:"Golem", emoji:"ü™®", kind:"troop", cost:6, place:"friendly", spawn:1,
             unit:{ hp:64, dmg:8, range:1, cdMs:1500, spdMs:760, targets:"all", canHitAir:false, splitInto:"miniGolem", splitCount:2 } },
  miniGolem:{ id:"miniGolem", name:"Mini Golem", emoji:"üß±", kind:"troop", cost:0, place:"friendly", spawn:1, hidden:true,
             unit:{ hp:18, dmg:4, range:1, cdMs:900,  spdMs:540, targets:"all", canHitAir:false } },
  barbarian:{ id:"barbarian", name:"Barbarian", emoji:"ü™ì", kind:"troop", cost:4, place:"friendly", spawn:1,
             unit:{ hp:26, dmg:5, range:1, cdMs:1100, spdMs:510, targets:"all", canHitAir:false, cleaveRadius:1 } },
  necromancer:{ id:"necromancer", name:"Necromancer", emoji:"‚ò†Ô∏è", kind:"troop", cost:5, place:"friendly", spawn:1,
             unit:{ hp:20, dmg:3, range:3, cdMs:1300, spdMs:620, targets:"all", canHitAir:true, summonCard:"skeleton", summonEveryMs:10000, summonCount:1 } },
  skeleton:{ id:"skeleton", name:"Skeleton", emoji:"ü¶¥", kind:"troop", cost:0, place:"friendly", spawn:1, hidden:true,
             unit:{ hp:5, dmg:2, range:1, cdMs:900, spdMs:430, targets:"all", canHitAir:false } },
  darkprince:{ id:"darkprince", name:"Dark Prince", emoji:"üêé", kind:"troop", cost:5, place:"friendly", spawn:1,
             unit:{ hp:30, dmg:5, range:1, cdMs:1100, spdMs:580, targets:"all", canHitAir:false, chargeDmg:14, chargeRange:3, chargeSelfStunMs:4000 } },
  slime:{ id:"slime", name:"Slime", emoji:"üü£", kind:"troop", cost:3, place:"friendly", spawn:1,
             unit:{ hp:20, dmg:3, range:1, cdMs:900, spdMs:600, targets:"all", canHitAir:false, slowMs:1800 } },
  berserker:{ id:"berserker", name:"Berserker", emoji:"ü™ì", kind:"troop", cost:4, place:"friendly", spawn:1,
             unit:{ hp:24, dmg:4, range:1, cdMs:820, spdMs:520, targets:"all", canHitAir:false } },
  frostMage:{ id:"frostMage", name:"Frost Mage", emoji:"üßä", kind:"troop", cost:4, place:"friendly", spawn:1,
             unit:{ hp:15, dmg:3, range:3, cdMs:1050, spdMs:610, targets:"all", canHitAir:true, slowMs:2200 } },
  assassin:{ id:"assassin", name:"Assassin", emoji:"üó°Ô∏è", kind:"troop", cost:4, place:"any", spawn:1,
             unit:{ hp:14, dmg:4, range:1, cdMs:700, spdMs:450, targets:"all", canHitAir:false, stealth:true, firstHitDmg:12 } },
  dragon:{ id:"dragon", name:"Dragon", emoji:"üêâ", kind:"troop", cost:6, place:"friendly", spawn:1,
             unit:{ hp:32, dmg:6, range:3, cdMs:1200, spdMs:600, targets:"all", canHitAir:true, flying:true, splash:1 } },
  balloon:{ id:"balloon", name:"Balloon", emoji:"üéà", kind:"troop", cost:5, place:"friendly", spawn:1,
             unit:{ hp:34, dmg:14, range:1, cdMs:1800, spdMs:900, targets:"buildings", canHitAir:false, flying:true } },
  drake:{ id:"drake", name:"Drake", emoji:"üê≤", kind:"troop", cost:4, place:"friendly", spawn:1,
             unit:{ hp:22, dmg:5, range:3, cdMs:1000, spdMs:560, targets:"all", canHitAir:true, flying:true, airPriority:true } },
  wyvern:{ id:"wyvern", name:"Wyvern", emoji:"ü™∂", kind:"troop", cost:4, place:"friendly", spawn:1,
             unit:{ hp:20, dmg:4, range:3, cdMs:900, spdMs:540, targets:"all", canHitAir:false, flying:true } },
  paladin:{ id:"paladin", name:"Paladin", emoji:"üõ°Ô∏è", kind:"troop", cost:5, place:"friendly", spawn:1,
             unit:{ hp:34, dmg:4, range:1, cdMs:1000, spdMs:560, targets:"all", canHitAir:false, auraArmor:true } },
  musketeer:{ id:"musketeer", name:"Musketeer", emoji:"üéØ", kind:"troop", cost:4, place:"friendly", spawn:1,
             unit:{ hp:16, dmg:7, range:4, cdMs:1200, spdMs:620, targets:"all", canHitAir:true } },
  bomber:{ id:"bomber", name:"Bomber", emoji:"üí£", kind:"troop", cost:3, place:"friendly", spawn:1,
             unit:{ hp:11, dmg:6, range:3, cdMs:1100, spdMs:640, targets:"ground", canHitAir:false, splash:1 } },
  lavaElemental:{ id:"lavaElemental", name:"Lava Elemental", emoji:"üåã", kind:"troop", cost:6, place:"friendly", spawn:1,
             unit:{ hp:36, dmg:5, range:3, cdMs:1500, spdMs:700, targets:"all", canHitAir:false, lavaWaveRange:4, pushBack:1, burnMs:3500, burnDps:2 } },
  poisonDartBlower:{ id:"poisonDartBlower", name:"Poison Dart Blower", emoji:"‚ò†Ô∏è", kind:"troop", cost:4, place:"friendly", spawn:1,
             unit:{ hp:13, dmg:2, range:4, cdMs:1000, spdMs:560, targets:"all", canHitAir:true, poisonMs:4500, poisonDps:2 } },
  priest:{ id:"priest", name:"Priest", emoji:"‚õ™", kind:"troop", cost:4, place:"friendly", spawn:1,
             unit:{ hp:18, dmg:0, range:1, cdMs:1150, spdMs:520, targets:"none", canHitAir:false, healAmount:5, healOnlyTroops:true } },

  fireball:{ id:"fireball",name:"Fireball",emoji:"üî•", kind:"spell", cost:4, place:"any",
             spell:{ dmg:18, radius:1 } },
  zap:     { id:"zap",     name:"Zap",     emoji:"‚ö°", kind:"spell", cost:2, place:"any",
             spell:{ dmg:9, radius:1, stunMs:1200 } },
  heal:    { id:"heal",    name:"Heal",    emoji:"üíö", kind:"spell", cost:3, place:"any",
             spell:{ heal:16, radius:1 } },
  log:     { id:"log", name:"Log", emoji:"ü™µ", kind:"spell", cost:2, place:"any", spell:{ lineDmg:10 } },
  blizzard:{ id:"blizzard", name:"Blizzard", emoji:"‚ùÑÔ∏è", kind:"spell", cost:4, place:"any", spell:{ dmg:10, radius:2, stunMs:1800 } },
  quake:   { id:"quake", name:"Quake", emoji:"üåé", kind:"spell", cost:4, place:"any", spell:{ dmg:12, radius:2, stunMs:800 } },
  haste:   { id:"haste", name:"Haste", emoji:"üí®", kind:"spell", cost:3, place:"any", spell:{ aura:{ type:"haste", radius:1, ttlMs:7000, speedMult:.65 } } },
  armor:   { id:"armor", name:"Armor", emoji:"üõ°Ô∏è", kind:"spell", cost:3, place:"any", spell:{ aura:{ type:"armor", radius:1, ttlMs:7000, dmgTakenMult:.5 } } },
  healingAura:{ id:"healingAura", name:"Healing Aura", emoji:"‚ú®", kind:"spell", cost:4, place:"any", spell:{ aura:{ type:"heal", radius:1, ttlMs:8000, healPctPerSec:.05 } } }
};

const CARD_POOL = Object.values(CARDS).filter(c=>!c.hidden).map(c=>c.id);
const BASE_DECK = ["knight","archers","goblins","giant","wizard","fireball","zap","heal"];
const ELO_REQ = { dragon: 1050, darkprince: 1100, assassin: 1150, balloon: 1200 };
const ELO_K = 28;

/* ---------------- Unique SVG art for EVERY troop ---------------- */
function wrapSprite(svg, p){
  const cls = (p===0) ? "sprite team0" : "sprite team1";
  return `<div class="${cls}">${svg}</div>`;
}

function svgKnight(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M16 52c2-10 7-18 16-18s14 8 16 18" fill="rgba(2,6,23,.50)"/>
  <path d="M24 52v-8c0-8 5-14 8-14s8 6 8 14v8" class="steel" stroke="rgba(2,6,23,.80)" stroke-width="2"/>
  <path d="M26 26c2-8 8-12 12-12s10 4 12 12l-6 6H32z" class="steel2" stroke="rgba(2,6,23,.80)" stroke-width="2"/>
  <path d="M38 14c6 2 10 6 12 10" class="teamStroke" stroke-width="4" stroke-linecap="round" opacity=".9"/>
  <rect x="30" y="28" width="12" height="6" rx="3" class="ink" opacity=".65"/>
  <path d="M44 40l10-10 3 3-10 10z" class="steel" stroke="rgba(2,6,23,.80)" stroke-width="1.5"/>
  <path d="M51 27l6-6 3 3-6 6z" class="teamFill" stroke="rgba(2,6,23,.80)" stroke-width="1.2"/>
  <circle cx="30" cy="46" r="3" class="teamFill" opacity=".9"/>
</svg>`; }

function svgArchers(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M16 52c2-12 6-20 16-20s14 8 16 20" fill="rgba(2,6,23,.55)"/>
  <path d="M18 28c4-10 10-16 14-16s10 6 14 16l-6 6H24z" class="teamFill" opacity=".80" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <path d="M22 34c0-8 7-14 10-14s10 6 10 14v12H22z" fill="rgba(2,6,23,.35)" stroke="rgba(2,6,23,.80)" stroke-width="2"/>
  <circle cx="28" cy="30" r="2.5" class="ink"/><circle cx="36" cy="30" r="2.5" class="ink"/>
  <path d="M48 18c6 10 6 22 0 34" fill="none" stroke="#a16207" stroke-width="4" stroke-linecap="round"/>
  <path d="M48 18c-6 10-6 22 0 34" fill="none" stroke="#fde68a" stroke-width="2" stroke-linecap="round" opacity=".65"/>
  <path d="M46 22h14" stroke="#cbd5e1" stroke-width="2.8" stroke-linecap="round"/>
  <path d="M60 22l-4-3v6z" class="teamFill" opacity=".9"/>
</svg>`; }

function svgFlameArchers(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M16 52c2-12 6-20 16-20s14 8 16 20" fill="rgba(2,6,23,.55)"/>
  <path d="M18 28c4-10 10-16 14-16s10 6 14 16l-6 6H24z" class="teamFill" opacity=".78" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <path d="M22 34c0-8 7-14 10-14s10 6 10 14v12H22z" class="cloth2" opacity=".45" stroke="rgba(2,6,23,.80)" stroke-width="2"/>
  <circle cx="28" cy="30" r="2.5" class="ink"/><circle cx="36" cy="30" r="2.5" class="ink"/>
  <path d="M48 18c6 10 6 22 0 34" fill="none" stroke="#a16207" stroke-width="4" stroke-linecap="round"/>
  <path d="M46 22h14" stroke="#cbd5e1" stroke-width="2.8" stroke-linecap="round"/>
  <path d="M60 22l-4-3v6z" class="teamFill" opacity=".9"/>
  <path d="M55 18c2 2 2 4 0 6c-2-2-2-4 0-6z" class="fire" opacity=".9"/>
  <path d="M53 16c3 3 3 6 0 9c-3-3-3-6 0-9z" class="fire2" opacity=".65"/>
</svg>`; }

function svgGoblin(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M16 50c2-11 6-18 16-18s14 7 16 18" fill="rgba(2,6,23,.55)"/>
  <path d="M20 30c0-10 8-18 12-18s12 8 12 18v10H20z" class="gob" stroke="rgba(2,6,23,.80)" stroke-width="2"/>
  <path d="M18 26l-8-6 6-4 6 7z" class="gob2" stroke="rgba(2,6,23,.80)" stroke-width="2" stroke-linejoin="round"/>
  <path d="M46 26l8-6-6-4-6 7z" class="gob2" stroke="rgba(2,6,23,.80)" stroke-width="2" stroke-linejoin="round"/>
  <circle cx="28" cy="28" r="2.6" class="ink"/><circle cx="36" cy="28" r="2.6" class="ink"/>
  <path d="M28 34c3 3 5 3 8 0" fill="none" stroke="rgba(2,6,23,.85)" stroke-width="2.5" stroke-linecap="round"/>
  <path d="M18 44l10-2 1 5-10 2z" class="wood" stroke="rgba(2,6,23,.75)" stroke-width="1.5"/>
  <path d="M34 42l12 6-2 4-12-6z" class="teamFill" opacity=".65"/>
</svg>`; }

function svgGiant(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M10 54c3-16 10-26 22-26s19 10 22 26" fill="rgba(2,6,23,.55)"/>
  <path d="M18 30c0-12 10-20 14-20s14 8 14 20v10H18z" class="giant" stroke="rgba(2,6,23,.80)" stroke-width="2"/>
  <path d="M20 24c3-8 9-12 12-12s9 4 12 12" class="giant2" opacity=".85"/>
  <circle cx="28" cy="30" r="2.8" class="ink"/><circle cx="36" cy="30" r="2.8" class="ink"/>
  <path d="M44 44l10 4-2 6-10-4z" class="stone2" stroke="rgba(2,6,23,.75)" stroke-width="1.5"/>
  <path d="M46 42l6-14 5 2-6 14z" class="stone" stroke="rgba(2,6,23,.75)" stroke-width="1.5"/>
  <path d="M24 44h16" class="teamStroke" stroke-width="4" stroke-linecap="round" opacity=".8"/>
</svg>`; }

function svgWizard(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M14 54c2-16 8-26 18-26s16 10 18 26" fill="rgba(2,6,23,.55)"/>
  <path d="M18 40c2-14 8-24 14-24s12 10 14 24v12H18z" fill="rgba(2,6,23,.35)" stroke="rgba(2,6,23,.80)" stroke-width="2"/>
  <path d="M22 22l10-14 10 14-10 6z" class="cloth" opacity=".88" stroke="rgba(2,6,23,.80)" stroke-width="2" stroke-linejoin="round"/>
  <path d="M24 30c0-6 5-10 8-10s8 4 8 10v6H24z" class="skin" opacity=".95" stroke="rgba(2,6,23,.75)" stroke-width="2"/>
  <circle cx="29" cy="32" r="2.5" class="ink"/><circle cx="35" cy="32" r="2.5" class="ink"/>
  <path d="M46 44l10-10 3 3-10 10z" class="teamFill" opacity=".85" stroke="rgba(2,6,23,.75)" stroke-width="1.5"/>
  <circle cx="57" cy="31" r="4" class="gold" opacity=".85"/><circle cx="57" cy="31" r="2.2" fill="#fff" opacity=".55"/>
</svg>`; }

function svgGolem(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M10 56c3-18 12-28 22-28s19 10 22 28" fill="rgba(2,6,23,.55)"/>
  <path d="M18 30c0-10 8-18 14-18s14 8 14 18v14H18z" class="stone" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <path d="M22 22l10-10 10 10-10 6z" class="stone2" opacity=".9" stroke="rgba(2,6,23,.85)" stroke-width="2" stroke-linejoin="round"/>
  <path d="M24 36l6-6M34 44l8-8M26 46l10-10" stroke="rgba(2,6,23,.45)" stroke-width="3" stroke-linecap="round"/>
  <circle cx="27" cy="30" r="2.4" class="ink"/><circle cx="37" cy="30" r="2.4" class="ink"/>
  <path d="M26 40h12" class="teamStroke" stroke-width="4" stroke-linecap="round" opacity=".7"/>
</svg>`; }

function svgMiniGolem(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M16 56c2-14 8-22 16-22s14 8 16 22" fill="rgba(2,6,23,.55)"/>
  <path d="M22 34c0-8 6-14 10-14s10 6 10 14v14H22z" class="stone2" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <path d="M24 30l8-8 8 8-8 4z" class="stone" opacity=".85" stroke="rgba(2,6,23,.85)" stroke-width="2" stroke-linejoin="round"/>
  <circle cx="28" cy="34" r="2.2" class="ink"/><circle cx="36" cy="34" r="2.2" class="ink"/>
  <path d="M26 44h12" class="teamStroke" stroke-width="4" stroke-linecap="round" opacity=".65"/>
</svg>`; }

function svgBarbarian(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M14 54c2-16 8-26 18-26s16 10 18 26" fill="rgba(2,6,23,.55)"/>
  <path d="M20 34c0-10 8-18 12-18s12 8 12 18v16H20z" class="steel2" opacity=".65" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <path d="M22 22l10-10 10 10-10 6z" class="teamFill" opacity=".85" stroke="rgba(2,6,23,.85)" stroke-width="2" stroke-linejoin="round"/>
  <circle cx="28" cy="30" r="2.5" class="ink"/><circle cx="36" cy="30" r="2.5" class="ink"/>
  <path d="M44 44l12-6 3 6-12 6z" class="wood" stroke="rgba(2,6,23,.80)" stroke-width="1.4"/>
  <path d="M54 30l8 4-6 10-8-4z" class="steel" stroke="rgba(2,6,23,.80)" stroke-width="1.4"/>
</svg>`; }

function svgNecromancer(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M14 56c2-18 8-28 18-28s16 10 18 28" fill="rgba(2,6,23,.55)"/>
  <path d="M18 44c2-16 8-26 14-26s12 10 14 26v12H18z" class="cloth2" opacity=".82" stroke="rgba(2,6,23,.88)" stroke-width="2"/>
  <path d="M22 22l10-12 10 12-10 6z" class="cloth" opacity=".9" stroke="rgba(2,6,23,.88)" stroke-width="2" stroke-linejoin="round"/>
  <path d="M46 18v34" stroke="#cbd5e1" stroke-width="3.2" stroke-linecap="round"/>
  <circle cx="46" cy="16" r="5" class="bone" stroke="rgba(2,6,23,.85)" stroke-width="1.6"/>
  <circle cx="44" cy="16" r="1.4" class="ink"/><circle cx="48" cy="16" r="1.4" class="ink"/>
  <path d="M28 34h8" class="teamStroke" stroke-width="4" stroke-linecap="round" opacity=".7"/>
</svg>`; }

function svgSkeleton(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M16 56c2-14 7-22 16-22s14 8 16 22" fill="rgba(2,6,23,.55)"/>
  <circle cx="32" cy="22" r="10" class="bone" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <circle cx="28" cy="22" r="2.5" class="ink"/><circle cx="36" cy="22" r="2.5" class="ink"/>
  <path d="M28 28c3 2 5 2 8 0" fill="none" stroke="rgba(2,6,23,.85)" stroke-width="2.5" stroke-linecap="round"/>
  <path d="M24 52V34h16v18" class="bone2" opacity=".9" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <path d="M20 40h24" stroke="rgba(2,6,23,.50)" stroke-width="3" stroke-linecap="round"/>
  <path d="M28 36v16M36 36v16" stroke="rgba(2,6,23,.55)" stroke-width="3" stroke-linecap="round"/>
  <path d="M24 34l-8 8M40 34l8 8" stroke="rgba(2,6,23,.55)" stroke-width="3" stroke-linecap="round"/>
</svg>`; }

function svgDarkPrince(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M10 56c3-18 10-26 22-26s19 8 22 26" fill="rgba(2,6,23,.55)"/>
  <path d="M20 44c0-10 10-18 14-18s14 8 14 18v12H20z" class="steel" opacity=".65" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <path d="M18 40c0-12 8-20 14-20s14 8 14 20" class="teamStroke" stroke-width="4" stroke-linecap="round" opacity=".75"/>
  <path d="M16 46c-2-8 2-16 10-18l-2 10z" class="stone2" opacity=".8"/>
  <path d="M46 24c6 2 10 8 10 16l-10-4z" class="stone2" opacity=".8"/>
  <path d="M38 20l10-8 6 8-10 6z" class="teamFill" opacity=".9" stroke="rgba(2,6,23,.85)" stroke-width="2" stroke-linejoin="round"/>
</svg>`; }

function svgSlime(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M12 54c2-18 10-28 20-28s18 10 20 28" fill="rgba(2,6,23,.55)"/>
  <path d="M18 52c0-18 6-32 14-32s14 14 14 32v2H18z" class="slime" opacity=".92" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <path d="M22 46c2-4 6-6 10-6s8 2 10 6" class="slime2" opacity=".75"/>
  <circle cx="28" cy="34" r="2.6" class="ink"/><circle cx="36" cy="34" r="2.6" class="ink"/>
  <path d="M26 40c3 2 9 2 12 0" fill="none" stroke="rgba(2,6,23,.78)" stroke-width="2.5" stroke-linecap="round"/>
</svg>`; }

function svgBerserker(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M14 54c2-16 8-26 18-26s16 10 18 26" fill="rgba(2,6,23,.55)"/>
  <path d="M20 36c0-10 8-18 12-18s12 8 12 18v14H20z" class="steel2" opacity=".6" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <path d="M22 22l10-10 10 10-10 6z" class="teamFill" opacity=".9" stroke="rgba(2,6,23,.85)" stroke-width="2" stroke-linejoin="round"/>
  <path d="M14 44l12-6 3 6-12 6z" class="wood" stroke="rgba(2,6,23,.8)" stroke-width="1.4"/>
  <path d="M38 38l12-6 3 6-12 6z" class="wood" stroke="rgba(2,6,23,.8)" stroke-width="1.4"/>
  <circle cx="28" cy="30" r="2.3" class="ink"/><circle cx="36" cy="30" r="2.3" class="ink"/>
</svg>`; }

function svgFrostMage(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M14 54c2-16 8-26 18-26s16 10 18 26" fill="rgba(2,6,23,.55)"/>
  <path d="M18 44c2-16 8-26 14-26s12 10 14 26v12H18z" class="ice2" opacity=".35" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <path d="M22 22l10-14 10 14-10 6z" class="ice" opacity=".85" stroke="rgba(2,6,23,.85)" stroke-width="2" stroke-linejoin="round"/>
  <path d="M46 18v34" stroke="#cbd5e1" stroke-width="3.2" stroke-linecap="round"/>
  <path d="M46 16m-6 0h12M46 10v12M42 12l8 8M50 12l-8 8" class="ice" stroke-width="2.5" stroke-linecap="round"/>
  <circle cx="29" cy="32" r="2.4" class="ink"/><circle cx="35" cy="32" r="2.4" class="ink"/>
</svg>`; }

function svgAssassin(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M14 54c2-16 8-26 18-26s16 10 18 26" fill="rgba(2,6,23,.55)"/>
  <path d="M18 46c2-16 8-28 14-28s12 12 14 28v10H18z" fill="rgba(2,6,23,.55)" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <path d="M22 24l10-14 10 14-10 6z" class="teamFill" opacity=".35" stroke="rgba(2,6,23,.85)" stroke-width="2" stroke-linejoin="round"/>
  <path d="M28 34l-10 10 4 4 10-10z" class="steel" stroke="rgba(2,6,23,.85)" stroke-width="1.4"/>
  <path d="M36 34l10 10-4 4-10-10z" class="steel" stroke="rgba(2,6,23,.85)" stroke-width="1.4"/>
  <circle cx="29" cy="33" r="2.2" class="ink"/><circle cx="35" cy="33" r="2.2" class="ink"/>
</svg>`; }

function svgDragon(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M12 56c2-16 8-24 20-24s18 8 20 24" fill="rgba(2,6,23,.55)"/>
  <path d="M18 40c6-10 14-16 22-16c6 0 10 4 12 10c-6 2-10 6-12 12c-8-2-16-2-22 0c-1-2-2-4-2-6c0-0 0-0 0-0z" class="fire2" opacity=".55" stroke="rgba(2,6,23,.85)" stroke-width="2" stroke-linejoin="round"/>
  <path d="M18 30l-10 8 8 6 8-8z" class="fire" opacity=".8" stroke="rgba(2,6,23,.85)" stroke-width="2" stroke-linejoin="round"/>
  <path d="M46 30l10 8-8 6-8-8z" class="fire" opacity=".8" stroke="rgba(2,6,23,.85)" stroke-width="2" stroke-linejoin="round"/>
  <path d="M26 22c4-6 16-6 20 0c-2 8-6 12-10 12s-8-4-10-12z" class="teamFill" opacity=".75" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <circle cx="30" cy="26" r="2.2" class="ink"/><circle cx="42" cy="26" r="2.2" class="ink"/>
  <path d="M44 20l6-6" class="teamStroke" stroke-width="3" stroke-linecap="round"/>
</svg>`; }

function svgBalloon(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M20 56h24v-8H20z" class="wood" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <path d="M22 48l-6-10M42 48l6-10" stroke="#cbd5e1" stroke-width="2.5" stroke-linecap="round"/>
  <path d="M32 8c10 0 18 8 18 18c0 12-10 20-18 22c-8-2-18-10-18-22C14 16 22 8 32 8z" class="teamFill" opacity=".85" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <path d="M24 18c4-5 12-7 16-3" class="shine" opacity=".8"/>
  <circle cx="32" cy="52" r="4" class="fire" opacity=".9" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
</svg>`; }

function svgDrake(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M12 56c2-16 8-24 20-24s18 8 20 24" fill="rgba(2,6,23,.55)"/>
  <path d="M22 44c2-10 8-16 10-16s8 6 10 16" class="teamFill" opacity=".35"/>
  <path d="M24 26c4-10 18-10 22 0c-2 10-8 14-11 14s-9-4-11-14z" class="ice2" opacity=".55" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <path d="M18 30l-8 8 10 4z" class="ice" opacity=".65" stroke="rgba(2,6,23,.85)" stroke-width="2" stroke-linejoin="round"/>
  <path d="M46 30l8 8-10 4z" class="ice" opacity=".65" stroke="rgba(2,6,23,.85)" stroke-width="2" stroke-linejoin="round"/>
  <circle cx="30" cy="28" r="2.2" class="ink"/><circle cx="40" cy="28" r="2.2" class="ink"/>
  <path d="M44 18c4 2 6 6 6 10" class="teamStroke" stroke-width="3" stroke-linecap="round" opacity=".9"/>
</svg>`; }

function svgWyvern(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M12 56c2-16 8-24 20-24s18 8 20 24" fill="rgba(2,6,23,.55)"/>
  <path d="M20 30l-10 10 14 4 6-10z" class="steel2" opacity=".55" stroke="rgba(2,6,23,.85)" stroke-width="2" stroke-linejoin="round"/>
  <path d="M44 30l10 10-14 4-6-10z" class="steel2" opacity=".55" stroke="rgba(2,6,23,.85)" stroke-width="2" stroke-linejoin="round"/>
  <path d="M26 24c4-8 16-8 20 0c-2 10-6 14-10 14s-8-4-10-14z" class="teamFill" opacity=".7" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <circle cx="30" cy="26" r="2.2" class="ink"/><circle cx="42" cy="26" r="2.2" class="ink"/>
  <path d="M36 38c4 6 10 10 16 12" class="teamStroke" stroke-width="3" stroke-linecap="round" opacity=".75"/>
</svg>`; }

function svgPaladin(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M14 54c2-16 8-26 18-26s16 10 18 26" fill="rgba(2,6,23,.55)"/>
  <path d="M20 34c0-10 8-18 12-18s12 8 12 18v16H20z" class="steel" opacity=".8" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <path d="M22 22l10-10 10 10-10 6z" class="teamFill" opacity=".8" stroke="rgba(2,6,23,.85)" stroke-width="2" stroke-linejoin="round"/>
  <path d="M44 30l10 6v14l-10 6-10-6V36z" class="steel2" stroke="rgba(2,6,23,.85)" stroke-width="2" stroke-linejoin="round"/>
  <path d="M44 34v18M39 43h10" class="teamStroke" stroke-width="3" stroke-linecap="round"/>
  <circle cx="28" cy="30" r="2.2" class="ink"/><circle cx="36" cy="30" r="2.2" class="ink"/>
</svg>`; }

function svgMusketeer(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M14 54c2-16 8-26 18-26s16 10 18 26" fill="rgba(2,6,23,.55)"/>
  <path d="M20 36c0-10 8-18 12-18s12 8 12 18v14H20z" class="cloth" opacity=".55" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <path d="M22 20h20l-4-10H26z" class="teamFill" opacity=".85" stroke="rgba(2,6,23,.85)" stroke-width="2" stroke-linejoin="round"/>
  <path d="M44 38h18" stroke="#cbd5e1" stroke-width="3.2" stroke-linecap="round"/>
  <path d="M58 35v6" class="teamStroke" stroke-width="3" stroke-linecap="round"/>
  <circle cx="28" cy="30" r="2.2" class="ink"/><circle cx="36" cy="30" r="2.2" class="ink"/>
</svg>`; }

function svgBomber(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M14 54c2-16 8-26 18-26s16 10 18 26" fill="rgba(2,6,23,.55)"/>
  <path d="M20 30c0-10 8-18 12-18s12 8 12 18v14H20z" class="gob" opacity=".95" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <circle cx="28" cy="28" r="2.4" class="ink"/><circle cx="36" cy="28" r="2.4" class="ink"/>
  <path d="M44 44l10-10 4 4-10 10z" class="stone2" stroke="rgba(2,6,23,.85)" stroke-width="1.6"/>
  <circle cx="54" cy="34" r="5" class="stone" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <path d="M54 28c2-4 6-4 6 0c-3 1-5 3-6 6c-1-3-3-5-6-6c0-4 4-4 6 0z" class="fire" opacity=".85"/>
</svg>`; }

function svgLavaElemental(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M12 56c2-18 10-28 20-28s18 10 20 28" fill="rgba(2,6,23,.55)"/>
  <path d="M18 30c0-10 8-18 14-18s14 8 14 18v16H18z" class="stone2" opacity=".85" stroke="rgba(2,6,23,.9)" stroke-width="2"/>
  <path d="M22 36h20M24 28h16M24 44h16" class="fire" stroke-width="3" stroke-linecap="round" opacity=".9"/>
  <circle cx="28" cy="30" r="2.4" class="fire"/><circle cx="36" cy="30" r="2.4" class="fire"/>
  <path d="M26 22l6-10 6 10-6 6z" class="fire2" opacity=".75"/>
</svg>`; }

function svgPoisonDart(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M14 54c2-16 8-26 18-26s16 10 18 26" fill="rgba(2,6,23,.55)"/>
  <path d="M20 30c0-10 8-18 12-18s12 8 12 18v14H20z" class="gob2" opacity=".85" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <circle cx="28" cy="28" r="2.4" class="ink"/><circle cx="36" cy="28" r="2.4" class="ink"/>
  <path d="M44 34h18" stroke="#cbd5e1" stroke-width="3" stroke-linecap="round"/>
  <path d="M60 34l-5-4v8z" class="poison" opacity=".95"/>
  <path d="M46 40c2 2 4 4 6 6" class="poison2" stroke-width="3" stroke-linecap="round"/>
  <circle cx="46" cy="40" r="3.5" class="poison" opacity=".85"/>
</svg>`; }

function svgPriest(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M14 54c2-16 8-26 18-26s16 10 18 26" fill="rgba(2,6,23,.55)"/>
  <path d="M18 44c2-16 8-26 14-26s12 10 14 26v12H18z" class="cloth" opacity=".35" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <circle cx="32" cy="18" r="10" class="skin" opacity=".9" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <path d="M24 10c3-4 13-4 16 0" class="gold" opacity=".65"/>
  <circle cx="28" cy="18" r="2.4" class="ink"/><circle cx="36" cy="18" r="2.4" class="ink"/>
  <path d="M32 28v18M26 36h12" class="teamStroke" stroke-width="3" stroke-linecap="round" opacity=".85"/>
</svg>`; }

function spriteForUnit(type){
  switch(type){
    case "knight": return svgKnight();
    case "archers": return svgArchers();
    case "flameArchers": return svgFlameArchers();
    case "goblins": return svgGoblin();
    case "giant": return svgGiant();
    case "wizard": return svgWizard();
    case "golem": return svgGolem();
    case "miniGolem": return svgMiniGolem();
    case "barbarian": return svgBarbarian();
    case "necromancer": return svgNecromancer();
    case "skeleton": return svgSkeleton();
    case "darkprince": return svgDarkPrince();
    case "slime": return svgSlime();
    case "berserker": return svgBerserker();
    case "frostMage": return svgFrostMage();
    case "assassin": return svgAssassin();
    case "dragon": return svgDragon();
    case "balloon": return svgBalloon();
    case "drake": return svgDrake();
    case "wyvern": return svgWyvern();
    case "paladin": return svgPaladin();
    case "musketeer": return svgMusketeer();
    case "bomber": return svgBomber();
    case "lavaElemental": return svgLavaElemental();
    case "poisonDartBlower": return svgPoisonDart();
    case "priest": return svgPriest();
    default:
      return `<svg viewBox="0 0 64 64"><circle cx="32" cy="32" r="16" class="teamFill"/><circle cx="32" cy="32" r="6" class="shine"/></svg>`;
  }
}

/* Structures */
function svgTower(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M16 56h32v-6H16z" class="stone2" opacity=".9"/>
  <path d="M18 52V22h28v30z" class="stone" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <path d="M18 22h28l-4-10H22z" class="stone2" stroke="rgba(2,6,23,.85)" stroke-width="2" stroke-linejoin="round"/>
  <path d="M24 12v6M32 12v6M40 12v6" stroke="rgba(2,6,23,.55)" stroke-width="3" stroke-linecap="round"/>
  <path d="M26 52V36h12v16z" fill="rgba(2,6,23,.55)"/>
  <path d="M20 30h6M38 30h6" stroke="rgba(2,6,23,.45)" stroke-width="3" stroke-linecap="round"/>
  <path d="M18 24h28" class="teamStroke" stroke-width="4" stroke-linecap="round" opacity=".9"/>
</svg>`; }

function svgCastle(){ return `
<svg viewBox="0 0 64 64" aria-hidden="true">
  <path d="M10 56h44v-7H10z" class="stone2" opacity=".9"/>
  <path d="M12 50V20h40v30z" class="stone" stroke="rgba(2,6,23,.85)" stroke-width="2"/>
  <path d="M12 20h40l-4-10H16z" class="stone2" stroke="rgba(2,6,23,.85)" stroke-width="2" stroke-linejoin="round"/>
  <path d="M18 10v8M26 10v8M34 10v8M42 10v8" stroke="rgba(2,6,23,.55)" stroke-width="3" stroke-linecap="round"/>
  <path d="M22 50V34h20v16z" fill="rgba(2,6,23,.55)"/>
  <path d="M12 24h40" class="teamStroke" stroke-width="4" stroke-linecap="round" opacity=".9"/>
  <path d="M50 30l6 6-6 6-6-6z" class="teamFill" opacity=".8" stroke="rgba(2,6,23,.75)" stroke-width="1.5"/>
</svg>`; }

function spriteForStructure(kind){
  if (kind==="tower") return svgTower();
  if (kind==="castle") return svgCastle();
  return svgTower();
}

function cardIconHTML(cid, pForColor=0){
  const c = CARDS[cid];
  if(!c) return `<div class="icon">?</div>`;
  if (c.kind==="troop") return `<div class="icon">${wrapSprite(spriteForUnit(c.id), pForColor)}</div>`;
  // spells: simple icon
  return `<div class="icon"><div class="sprite team0"><svg viewBox="0 0 64 64">
    <circle cx="32" cy="32" r="18" class="teamFill" opacity=".35"/>
    <path d="M22 44c10-3 16-9 20-18" class="teamStroke" stroke-width="4" stroke-linecap="round" opacity=".9"/>
    <text x="32" y="40" text-anchor="middle" font-size="20" fill="#fff">${c.emoji || "‚ú®"}</text>
  </svg></div></div>`;
}

/* ---------------- Game state local cache ---------------- */
let S = null;
let lobbyPlayers = [];
let meIndex = 0;
let isHost = false;
let selectedCard = null;
let selectedQueue = [];
let lobbyMeta = { eloMap:{}, deckMap:{} };
let localDraftDeck = null;

function cleanDeckForElo(deck, elo){
  const allow = (cid)=> (ELO_REQ[cid]||0) <= (elo||1000);
  const filtered = (deck||[]).filter(cid=>CARDS[cid] && !CARDS[cid].hidden && allow(cid));
  const fill = CARD_POOL.filter(allow);
  const out = [];
  for (const c of filtered){ if (!out.includes(c)) out.push(c); if (out.length>=8) break; }
  for (const c of fill){ if (!out.includes(c)) out.push(c); if (out.length>=8) break; }
  return out.slice(0,8);
}
function editableDeckForPlayer(name){
  const elo = lobbyMeta.eloMap?.[name] || 1000;
  const allow = (cid)=> (ELO_REQ[cid]||0) <= elo;
  const source = (name===username && Array.isArray(localDraftDeck)) ? localDraftDeck : null;
  const saved = source || lobbyMeta.deckMap?.[name] || [];
  const out = [];
  for (const cid of saved){
    if (!CARDS[cid] || CARDS[cid].hidden || !allow(cid) || out.includes(cid)) continue;
    out.push(cid);
    if (out.length>=8) break;
  }
  return out;
}
function deckForPlayer(name){
  const elo = lobbyMeta.eloMap?.[name] || 1000;
  const saved = lobbyMeta.deckMap?.[name] || BASE_DECK;
  return cleanDeckForElo(saved, elo);
}

/* ---------------- Build grid DOM ---------------- */
function buildGrid(){
  const frag = document.createDocumentFragment();
  for (let y=0;y<H;y++){
    for (let x=0;x<W;x++){
      const d = document.createElement("div");
      d.className = "cell";
      if (y < RIVER_Y0) d.classList.add("side1");
      if (y > RIVER_Y1) d.classList.add("side0");
      if (isRiver(x,y)) d.classList.add("river","blocked");
      if (isBridge(x,y)) d.classList.add("bridge");
      d.dataset.x = String(x);
      d.dataset.y = String(y);
      d.innerHTML = `
        <div class="under"></div>
        <div class="piece"></div>
        <div class="hp"><i class="neutral" style="width:0%"></i></div>
      `;
      d.addEventListener("click", ()=> onCellClick(x,y));
      frag.appendChild(d);
    }
  }
  gridEl.innerHTML = "";
  gridEl.appendChild(frag);
}
buildGrid();

/* ---------------- View: pan + (optional) pinch zoom ---------------- */
let scale=1, pan={x:0,y:0};
let boardMetrics = { width: 0, height: 0 };
let isPanDrag = false;
const PAN_DRAG_THRESHOLD = 7;

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

function computeBoardMetrics(){
  const root = getComputedStyle(document.documentElement);
  const cell = parseFloat(root.getPropertyValue("--cell")) || 32;
  const gap  = parseFloat(root.getPropertyValue("--gap"))  || 4;

  const gs = getComputedStyle(gridEl);
  const padX = (parseFloat(gs.paddingLeft)||0) + (parseFloat(gs.paddingRight)||0);
  const padY = (parseFloat(gs.paddingTop)||0) + (parseFloat(gs.paddingBottom)||0);

  const boardW = W*cell + (W-1)*gap + padX;
  const boardH = H*cell + (H-1)*gap + padY;
  boardMetrics.width = boardW;
  boardMetrics.height = boardH;
}

function panBounds(){
  const vw = viewport.clientWidth;
  const vh = viewport.clientHeight;
  const scaledW = boardMetrics.width * scale;
  const scaledH = boardMetrics.height * scale;

  const lockX = scaledW <= vw;
  const lockY = scaledH <= vh;

  return {
    minX: lockX ? Math.round((vw - scaledW) / 2) : Math.round(vw - scaledW),
    maxX: lockX ? Math.round((vw - scaledW) / 2) : 0,
    minY: lockY ? Math.round((vh - scaledH) / 2) : Math.round(vh - scaledH),
    maxY: lockY ? Math.round((vh - scaledH) / 2) : 0
  };
}
function clampPan(){
  const b = panBounds();
  pan.x = Math.max(b.minX, Math.min(b.maxX, Math.round(pan.x)));
  pan.y = Math.max(b.minY, Math.min(b.maxY, Math.round(pan.y)));
}
function applyCanvasTransform(){
  clampPan();
  canvasEl.style.transform = `translate(${pan.x}px,${pan.y}px) scale(${scale})`;
}

/* More aggressive zoom-out on mobile */
function fitBoard(){
  computeBoardMetrics();
  const vw = viewport.clientWidth;
  const vh = viewport.clientHeight;
  const sFit = Math.min(vw/boardMetrics.width, vh/boardMetrics.height);

  const isMobile = window.matchMedia("(max-width: 720px)").matches;
  const minScale = isMobile ? 0.52 : 0.88;
  const maxScale = isMobile ? 1.25 : 1.7;

  // Mobile gets extra zoom-out so more fits at once
  const bias = isMobile ? 0.80 : 1.02;
  scale = clamp(sFit * bias, minScale, maxScale);

  pan.x = Math.round((vw - boardMetrics.width*scale)/2);
  pan.y = Math.round((vh - boardMetrics.height*scale)/2);
  applyCanvasTransform();
}
new ResizeObserver(fitBoard).observe(viewport);
fitBoard();

fitBtn.addEventListener("click", ()=> fitBoard());

/* Pointer pan + pinch */
const pointers = new Map(); // id -> {x,y}
let gesture = {
  mode: "none", // "pan" | "pinch"
  startPan: {x:0,y:0},
  startScale: 1,
  startDist: 0,
  startMid: {x:0,y:0},
  startMidWorld: {x:0,y:0}, // mid in "canvas space" (pre-transform)
};

function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
function midpoint(a,b){ return { x:(a.x+b.x)/2, y:(a.y+b.y)/2 }; }

function toCanvasWorld(clientX, clientY){
  // convert viewport-local point to "canvas world" (before translate/scale)
  const vr = viewport.getBoundingClientRect();
  const vx = clientX - vr.left;
  const vy = clientY - vr.top;
  return {
    x: (vx - pan.x) / scale,
    y: (vy - pan.y) / scale
  };
}

viewport.addEventListener("pointerdown", (e)=>{
  pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
  viewport.setPointerCapture?.(e.pointerId);

  if (pointers.size === 1){
    gesture.mode = "pan";
    gesture.startPan = {x:pan.x, y:pan.y};
    gesture.startScale = scale;
    gesture.startMid = {x:e.clientX, y:e.clientY};
  } else if (pointers.size === 2){
    // start pinch
    const pts = [...pointers.values()];
    gesture.mode = "pinch";
    gesture.startScale = scale;
    gesture.startDist = dist(pts[0], pts[1]);
    gesture.startMid = midpoint(pts[0], pts[1]);
    gesture.startPan = {x:pan.x, y:pan.y};
    gesture.startMidWorld = toCanvasWorld(gesture.startMid.x, gesture.startMid.y);
  }
}, {passive:false});

viewport.addEventListener("pointermove", (e)=>{
  if (!pointers.has(e.pointerId)) return;
  pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});

  if (pointers.size === 1 && gesture.mode === "pan"){
    const p0 = [...pointers.values()][0];
    const dx = p0.x - gesture.startMid.x;
    const dy = p0.y - gesture.startMid.y;

    if (!isPanDrag && Math.hypot(dx,dy) >= PAN_DRAG_THRESHOLD) isPanDrag = true;
    if (!isPanDrag) return;

    pan.x = gesture.startPan.x + dx;
    pan.y = gesture.startPan.y + dy;
    applyCanvasTransform();
    e.preventDefault();
  } else if (pointers.size === 2){
    // pinch (and also pan with midpoint)
    const pts = [...pointers.values()];
    const d = dist(pts[0], pts[1]);
    const mid = midpoint(pts[0], pts[1]);

    const isMobile = window.matchMedia("(max-width: 720px)").matches;
    const minScale = isMobile ? 0.45 : 0.75;
    const maxScale = isMobile ? 1.35 : 1.8;

    const nextScale = clamp(gesture.startScale * (d / Math.max(1, gesture.startDist)), minScale, maxScale);
    scale = nextScale;

    // Keep the same world point under the midpoint
    const vr = viewport.getBoundingClientRect();
    const vx = mid.x - vr.left;
    const vy = mid.y - vr.top;

    pan.x = vx - gesture.startMidWorld.x * scale;
    pan.y = vy - gesture.startMidWorld.y * scale;

    isPanDrag = true;
    applyCanvasTransform();
    e.preventDefault();
  }
}, {passive:false});

function endPointer(e){
  pointers.delete(e.pointerId);
  if (pointers.size === 0){
    // reset drag flag after click-cancel can run
    setTimeout(()=>{ isPanDrag = false; }, 0);
    gesture.mode = "none";
  } else if (pointers.size === 1){
    // drop from pinch to pan smoothly
    const p0 = [...pointers.values()][0];
    gesture.mode = "pan";
    gesture.startPan = {x:pan.x, y:pan.y};
    gesture.startMid = {x:p0.x, y:p0.y};
    gesture.startScale = scale;
  }
}

viewport.addEventListener("pointerup", endPointer, {passive:false});
viewport.addEventListener("pointercancel", endPointer, {passive:true});

gridEl.addEventListener("click", (e)=>{
  if (!isPanDrag) return;
  e.preventDefault();
  e.stopPropagation();
}, true);

/* ---------------- UI helpers ---------------- */
function toast(msg, ms=1400){
  toastEl.textContent = msg;
  toastEl.style.display = "block";
  clearTimeout(toastEl._t);
  toastEl._t = setTimeout(()=> toastEl.style.display="none", ms);
}
function hint(msg){
  if(!msg){ hintEl.style.display="none"; hintEl.textContent=""; return; }
  hintEl.textContent = msg;
  hintEl.style.display="block";
}
function getCell(x,y){
  const i = y*W + x;
  return gridEl.children[i] || null;
}
function getCellCenter(x,y){
  const cell = getCell(x,y);
  if(!cell) return null;
  const rect = cell.getBoundingClientRect();
  const vr = viewport.getBoundingClientRect();
  return {
    x: rect.left - vr.left + rect.width/2,
    y: rect.top  - vr.top  + rect.height/2
  };
}
function fxPop(x,y,text,color,cls="",ttl=750){
  const c = getCellCenter(x,y);
  if(!c) return;
  const el = document.createElement("div");
  el.className = `fxPop ${cls}`.trim();
  el.textContent = text;
  el.style.left = c.x + "px";
  el.style.top  = c.y + "px";
  el.style.color = color || "#e5e7eb";
  fxEl.appendChild(el);
  setTimeout(()=>el.remove(), ttl);
}
function fxProjectile(fromX,fromY,toX,toY,text,color,dur=280){
  const src = getCellCenter(fromX,fromY);
  const dst = getCellCenter(toX,toY);
  if(!src || !dst) return;
  const dx = (dst.x-src.x);
  const dy = (dst.y-src.y);
  const len = Math.hypot(dx,dy);
  const ang = Math.atan2(dy,dx) * 180/Math.PI;
  const el = document.createElement("div");
  el.className = "fxProjectile";
  el.style.color = color || "#e5e7eb";
  el.style.setProperty("--sx", src.x + "px");
  el.style.setProperty("--sy", src.y + "px");
  el.style.setProperty("--dx", dx + "px");
  el.style.setProperty("--dy", dy + "px");
  el.style.setProperty("--len", Math.max(12, len) + "px");
  el.style.setProperty("--ang", ang + "deg");
  el.style.setProperty("--dur", dur + "ms");
  el.style.setProperty("--tip", JSON.stringify(text || ""));
  fxEl.appendChild(el);
  setTimeout(()=>el.remove(), dur + 60);
}
function fxSparks(x,y,color="#fde68a",count=7,dur=450){
  const c = getCellCenter(x,y);
  if(!c) return;
  for (let i=0;i<count;i++){
    const el = document.createElement("div");
    el.className = "fxSpark";
    const ang = (Math.PI*2*i)/count;
    const dist = 8 + Math.random()*16;
    el.style.setProperty("--x", c.x + "px");
    el.style.setProperty("--y", c.y + "px");
    el.style.setProperty("--sx", (Math.cos(ang)*dist) + "px");
    el.style.setProperty("--sy", (Math.sin(ang)*dist) + "px");
    el.style.setProperty("--dur", (dur + Math.random()*140) + "ms");
    el.style.background = `radial-gradient(circle, rgba(255,255,255,.95), ${color} 46%, rgba(245,158,11,0))`;
    fxEl.appendChild(el);
    setTimeout(()=>el.remove(), dur + 220);
  }
}

/* ---------------- Lobby join + state create ---------------- */
async function joinLobby(){
  await runTransaction(db, async (tx)=>{
    const snap = await tx.get(lobbyRef);
    const lob = snap.exists() ? snap.data() : {};
    const players = Array.isArray(lob.players) ? lob.players.slice(0,2) : [];
    if (!players.includes(username)){
      if (players.length < 2) players.push(username);
    }
    const eloMap = { ...(lob.eloMap||{}) };
    if (!eloMap[username]) eloMap[username] = 1000;
    const deckMap = { ...(lob.deckMap||{}) };
    if (!deckMap[username]) deckMap[username] = [];
    tx.set(lobbyRef, {
      ...lob,
      players,
      eloMap,
      deckMap,
      updatedAt: Date.now(),
      createdAt: lob.createdAt || Date.now()
    }, { merge:true });
  });

  const lobSnap = await getDoc(lobbyRef);
  const lob = lobSnap.exists() ? lobSnap.data() : {};
  lobbyMeta = { eloMap: lob.eloMap||{}, deckMap: lob.deckMap||{} };
  localDraftDeck = null;
  lobbyPlayers = Array.isArray(lob.players) ? lob.players.slice(0,2) : [];
  meIndex = lobbyPlayers.indexOf(username);
  if (meIndex < 0) meIndex = 0;
  isHost = (lobbyPlayers[0] === username);
}

function seededShuffle(arr, seedStr){
  let s=0;
  for (let i=0;i<seedStr.length;i++) s = (s*31 + seedStr.charCodeAt(i))>>>0;
  function rnd(){
    s ^= s<<13; s >>>= 0;
    s ^= s>>17; s >>>= 0;
    s ^= s<<5;  s >>>= 0;
    return (s>>>0) / 4294967296;
  }
  const a = arr.slice();
  for (let i=a.length-1;i>0;i--){
    const j = Math.floor(rnd()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}

function initialStructures(){
  return [
    {id:"p1_tL", p:1, kind:"tower",  x:2, y:2,  hp:120, maxhp:120, range:4, dmg:3, cdMs:1300, nextAtk:0},
    {id:"p1_tR", p:1, kind:"tower",  x:6, y:2,  hp:120, maxhp:120, range:4, dmg:3, cdMs:1300, nextAtk:0},
    {id:"p1_c",  p:1, kind:"castle", x:4, y:1,  hp:220, maxhp:220, range:5, dmg:4, cdMs:1300, nextAtk:0},

    {id:"p0_tL", p:0, kind:"tower",  x:2, y:9, hp:120, maxhp:120, range:4, dmg:3, cdMs:1300, nextAtk:0},
    {id:"p0_tR", p:0, kind:"tower",  x:6, y:9, hp:120, maxhp:120, range:4, dmg:3, cdMs:1300, nextAtk:0},
    {id:"p0_c",  p:0, kind:"castle", x:4, y:10, hp:220, maxhp:220, range:5, dmg:4, cdMs:1300, nextAtk:0},
  ];
}

function structureAt(structs, x,y){
  return (structs||[]).find(s=>s.hp>0 && s.x===x && s.y===y) || null;
}
function isStructureTile(structs, x,y){
  return !!structureAt(structs,x,y);
}

const MATCH_MS = 3*60*1000;
const DRAFT_MS = 30*1000;

async function ensureStateExists(){
  await runTransaction(db, async (tx)=>{
    const snap = await tx.get(stateRef);
    if (snap.exists()) return;

    const lobSnap = await tx.get(lobbyRef);
    const lob = lobSnap.exists() ? lobSnap.data() : {};
    const players = Array.isArray(lob.players) ? lob.players.slice(0,2) : [];

    const now = Date.now();
    const p0Name = players[0] || "p0";
    const p1Name = players[1] || "p1";
    const deck0 = seededShuffle(deckForPlayer(p0Name), gameId + ":p0");
    const deck1 = seededShuffle(deckForPlayer(p1Name), gameId + ":p1");

    tx.set(stateRef, {
      v:1,
      phase: "waiting",
      players,
      startedAt: null,
      draftEndsAt: (players.length>=2) ? (now + DRAFT_MS) : null,
      readyMap: {},
      lastTickAt: now,
      endsAt: null,
      winner: null,
      winReason: null,

      crowns: [0,0],
      elixir: [0,0],
      hand: { p0: deck0.slice(0,4), p1: deck1.slice(0,4) },
      queue:{ p0: deck0.slice(4),  p1: deck1.slice(4) },

      structures: initialStructures(),
      units: [],
      orders: [],
      fx: [],
      auras: [],
      eloApplied: false
    });
  });
}

/* ---------------- Gameplay constants + sim ---------------- */
let hostTimer = null;
const TICK_MS = 320;
const ELIXIR_MS_PER = 2800;
const MAX_ELIXIR = 10;
const FX_TTL = 900;
const MAX_FX = 120;

/* BFS pathing */
function neighbors4(x,y){
  return [{x:x+1,y},{x:x-1,y},{x,y:y+1},{x,y:y-1}].filter(p=>inside(p.x,p.y));
}
function walkable(structs, x,y, flying=false){
  if (!inside(x,y)) return false;
  if (!flying && isRiver(x,y)) return false;
  if (isStructureTile(structs,x,y)) return false;
  return true;
}
function bfsNextStep(structs, start, goals, flying=false){
  const q = [];
  const prev = new Map();
  const startK = keyXY(start.x,start.y);
  q.push(start);
  prev.set(startK, null);

  while(q.length){
    const cur = q.shift();
    const ck = keyXY(cur.x,cur.y);
    if (goals.has(ck)){
      let stepK = ck;
      let parent = prev.get(stepK);
      while(parent && parent !== startK){
        stepK = parent;
        parent = prev.get(stepK);
      }
      if (stepK === startK) return null;
      const [sx,sy] = stepK.split(",").map(Number);
      return {x:sx,y:sy};
    }
    for (const nb of neighbors4(cur.x,cur.y)){
      const nk = keyXY(nb.x,nb.y);
      if (prev.has(nk)) continue;
      if (!walkable(structs, nb.x, nb.y, flying)) continue;
      prev.set(nk, ck);
      q.push(nb);
    }
  }
  return null;
}

/* Targeting helpers */
function aliveStructsForP(structs, p){
  return (structs||[]).filter(s=>s.p===p && s.hp>0);
}
function enemyStructPriority(structs, enemyP){
  const towers = aliveStructsForP(structs, enemyP).filter(s=>s.kind==="tower");
  if (towers.length) return towers;
  const castle = aliveStructsForP(structs, enemyP).find(s=>s.kind==="castle");
  return castle ? [castle] : [];
}
function isFlying(u){ return !!u.flying; }
function canTarget(attacker, target){
  if (!target) return false;
  if (isFlying(target) && !attacker.canHitAir) return false;
  return true;
}
function inRadius(cx,cy,x,y,r){
  return Math.abs(cx-x)+Math.abs(cy-y) <= r;
}
function activeAurasAt(st, x,y){
  const now = Date.now();
  return (st.auras||[]).filter(a=>a.until>now && inRadius(a.x,a.y,x,y,a.radius||0));
}
function speedMult(st, u){
  const list = activeAurasAt(st, u.x,u.y).filter(a=>a.type==="haste");
  if (!list.length) return 1;
  return Math.min(...list.map(a=>a.speedMult||1));
}
function damageTakenMult(st, x,y){
  const list = activeAurasAt(st, x,y).filter(a=>a.type==="armor");
  if (!list.length) return 1;
  return Math.min(...list.map(a=>a.dmgTakenMult||1));
}
function healUnit(st, u, amount, curePoison=true){
  if (!u || u.hp<=0 || amount<=0) return;
  u.hp = Math.min(u.maxhp, u.hp + amount);
  if (curePoison){
    u.poisonUntil = 0;
    u.poisonDps = 0;
    u.poisonAcc = 0;
  }
}
function pushUnitBack(st, attacker, target, steps=1){
  if (!target || target.hp<=0 || !steps) return;
  const dx = target.x - attacker.x;
  const dy = target.y - attacker.y;
  let stepX = 0, stepY = 0;
  if (Math.abs(dx) >= Math.abs(dy)) stepX = Math.sign(dx||1);
  else stepY = Math.sign(dy||1);
  for (let i=0;i<steps;i++){
    const nx = target.x + stepX;
    const ny = target.y + stepY;
    if (!inside(nx,ny) || !walkable(st.structures, nx, ny, !!target.flying)) break;
    target.x = nx; target.y = ny;
  }
}
function applyDamageToUnit(st, attacker, target, baseDmg, now){
  if (!target || target.hp<=0) return;
  let dmg = Math.max(1, Math.floor(baseDmg * damageTakenMult(st, target.x, target.y)));
  if (attacker?.type === "assassin" && !attacker.revealed){
    dmg = attacker.firstHitDmg || dmg;
    attacker.revealed = true;
  }
  target.hp -= dmg;
  if (attacker?.slowMs) target.stunUntil = Math.max(target.stunUntil||0, now + attacker.slowMs);
  if (attacker?.burnMs && attacker?.burnDps){
    target.burnUntil = Math.max(target.burnUntil||0, now + attacker.burnMs);
    target.burnDps = Math.max(target.burnDps||0, attacker.burnDps);
  }
  if (attacker?.poisonMs && attacker?.poisonDps){
    target.poisonUntil = Math.max(target.poisonUntil||0, now + attacker.poisonMs);
    target.poisonDps = Math.max(target.poisonDps||0, attacker.poisonDps);
  }
}

function findNearestEnemyUnit(units, meP, from, range){
  let best=null, bd=1e9;
  for (const u of (units||[])){
    if (u.hp<=0 || u.p===meP) continue;
    if (!canTarget(from, u)) continue;
    const d = Math.abs(u.x-from.x)+Math.abs(u.y-from.y);
    if (d<=range && d<bd){ bd=d; best=u; }
  }
  return best;
}
function findNearestDamagedAllyUnit(units, meP, from, range=Infinity){
  let best=null, bd=1e9;
  for (const u of (units||[])){
    if (u.hp<=0 || u.p!==meP) continue;
    if (u.id===from.id) continue;
    if (u.hp>=u.maxhp) continue;
    const d = Math.abs(u.x-from.x)+Math.abs(u.y-from.y);
    if (d<=range && d<bd){ bd=d; best=u; }
  }
  return best;
}
function findNearestEnemyStructure(structs, meP, from, range){
  let best=null, bd=1e9;
  for (const s of (structs||[])){
    if (s.hp<=0 || s.p===meP) continue;
    const d = Math.abs(s.x-from.x)+Math.abs(s.y-from.y);
    if (d<=range && d<bd){ bd=d; best=s; }
  }
  return best;
}

/* Spawn / spell application */
function newUnit(p, cardId, x,y){
  const c = CARDS[cardId];
  const u = c.unit;
  return {
    id: crypto.randomUUID(),
    p,
    type: cardId,
    x, y,
    hp: u.hp,
    maxhp: u.hp,
    dmg: u.dmg,
    range: u.range,
    cdMs: u.cdMs,
    spdMs: u.spdMs,
    splash: u.splash || 0,
    targets: u.targets || "all",
    canHitAir: !!u.canHitAir,
    flying: !!u.flying,
    cleaveRadius: u.cleaveRadius || 0,
    summonCard: u.summonCard || null,
    summonEveryMs: u.summonEveryMs || 0,
    summonCount: u.summonCount || 0,
    nextSummon: u.summonEveryMs ? (Date.now() + u.summonEveryMs) : 0,
    splitInto: u.splitInto || null,
    splitCount: u.splitCount || 0,
    chargeDmg: u.chargeDmg || 0,
    chargeRange: u.chargeRange || 0,
    chargeSelfStunMs: u.chargeSelfStunMs || 0,
    slowMs: u.slowMs || 0,
    revealed: !u.stealth,
    firstHitDmg: u.firstHitDmg || 0,
    airPriority: !!u.airPriority,
    lavaWaveRange: u.lavaWaveRange || 0,
    pushBack: u.pushBack || 0,
    burnMs: u.burnMs || 0,
    burnDps: u.burnDps || 0,
    poisonMs: u.poisonMs || 0,
    poisonDps: u.poisonDps || 0,
    healAmount: u.healAmount || 0,
    healOnlyTroops: !!u.healOnlyTroops,
    nextAtk: 0,
    nextMove: 0,
    stunUntil: 0,
    burnUntil: 0,
    burnAcc: 0,
    poisonUntil: 0,
    poisonAcc: 0
  };
}

function pushFx(st, x,y, text, color, delayMs=0, ttl=FX_TTL, cls="", source=null, icon=null){
  st.fx.push({id:crypto.randomUUID(), x,y, text, color, at:Date.now()+delayMs, ttl, cls, source, icon});
}
function attackGlyph(type){
  return ({ knight:"‚öîÔ∏è", archers:"üèπ", flameArchers:"üî•", goblins:"üî™", giant:"üëä", wizard:"‚ú®", golem:"ü™®",
    miniGolem:"üß±", barbarian:"ü™ì", necromancer:"‚ò†Ô∏è", darkprince:"üêé", slime:"üß™", berserker:"ü™ì", frostMage:"üßä",
    assassin:"üó°Ô∏è", dragon:"üî•", balloon:"üí£", drake:"üåÄ", wyvern:"ü™∂", skeleton:"ü¶¥", paladin:"üõ°Ô∏è", musketeer:"üéØ",
    bomber:"üí•", lavaElemental:"üåã", poisonDartBlower:"‚ò†Ô∏è", priest:"‚ú®" })[type] || "‚öîÔ∏è";
}
function projectileGlyph(type){
  return ({ archers:"‚û∂", flameArchers:"üî•", musketeer:"‚ú¶", wizard:"‚úß", dragon:"üî•", drake:"üåÄ", bomber:"üí£",
    necromancer:"‚ò†Ô∏è", poisonDartBlower:"‚ò†Ô∏è", lavaElemental:"üåã", frostMage:"‚ùÑ" })[type] || "‚Ä¢";
}
function projectileColorFor(type, base){
  return ({
    archers:"#fef08a", flameArchers:"#fb923c", musketeer:"#e2e8f0", wizard:"#c4b5fd", dragon:"#fb923c", drake:"#7dd3fc",
    bomber:"#fda4af", necromancer:"#c4b5fd", poisonDartBlower:"#86efac", lavaElemental:"#fdba74", frostMage:"#bfdbfe",
    wyvern:"#93c5fd"
  })[type] || base;
}
function isRangedTroop(u){
  return (u.range||1) > 1 || !!u.splash || ["archers","flameArchers","musketeer","wizard","dragon","drake","wyvern",
    "bomber","poisonDartBlower","lavaElemental","necromancer","frostMage","priest"].includes(u.type);
}
function awardCrown(st, destroyedStructure){
  const scorer = (destroyedStructure.p===0) ? 1 : 0;
  st.crowns = st.crowns || [0,0];
  if (destroyedStructure.kind==="tower") st.crowns[scorer] = (st.crowns[scorer]||0) + 1;
  if (destroyedStructure.kind==="castle") st.crowns[scorer] = (st.crowns[scorer]||0) + 3;
}

function applySpell(st, p, cardId, tx, ty){
  const spec = CARDS[cardId].spell;
  const units = st.units;
  const structs= st.structures;
  const r = spec.radius|0;
  const spellColor = ({ fireball:"#fb7185", zap:"#fde68a", heal:"#86efac", log:"#f59e0b", blizzard:"#93c5fd", quake:"#d6d3d1", haste:"#bae6fd", armor:"#c4b5fd", healingAura:"#67e8f9" })[cardId] || "#e5e7eb";

  pushFx(st, tx,ty, CARDS[cardId]?.emoji || "‚ú®", spellColor, 0, 900, "spell");
  if (r > 0){
    for (let rr=1; rr<=r; rr++){
      pushFx(st, tx,ty, "‚óå", spellColor, rr*70, 650, "spell");
    }
  }

  if (cardId === "fireball"){
    pushFx(st, tx,ty, "üî•", "#fb923c", 0, 920, "explosion");
    for (let i=0;i<8;i++) pushFx(st, tx,ty, "", "#fdba74", i*45, 420, "sparks");
  }
  if (cardId === "zap"){ pushFx(st, tx,ty, "‚ö°", "#fde047", 0, 700, "spell"); }
  if (cardId === "blizzard"){ pushFx(st, tx,ty, "‚ùÑÔ∏è", "#bfdbfe", 0, 920, "spell"); }
  if (cardId === "quake"){ pushFx(st, tx,ty, "üåé", "#d6d3d1", 0, 760, "impact"); }

  if (spec.dmg){
    for (const u of units){
      if (u.hp<=0) continue;
      if (!inRadius(tx,ty,u.x,u.y,r)) continue;
      if (u.p===p) continue;
      u.hp -= spec.dmg;
      pushFx(st, u.x,u.y, "‚úπ", "#fca5a5", 40, 560, "impact");
    }
    for (const s of structs){
      if (s.hp<=0) continue;
      if (!inRadius(tx,ty,s.x,s.y,r)) continue;
      if (s.p===p) continue;
      s.hp -= spec.dmg;
      pushFx(st, s.x,s.y, "üí•", "#fb7185", 60, 620, "explosion");
    }
    pushFx(st, tx,ty, "üí•", "#fb7185", 0, 760, "explosion");
  }

  if (spec.stunMs){
    const now = Date.now();
    for (const u of units){
      if (u.hp<=0) continue;
      if (!inRadius(tx,ty,u.x,u.y,r)) continue;
      if (u.p===p) continue;
      u.stunUntil = Math.max(u.stunUntil||0, now + spec.stunMs);
      pushFx(st, u.x,u.y, "‚ö°", "#fde68a", 80, 650, "spell");
    }
  }

  if (spec.heal){
    for (const u of units){
      if (u.hp<=0) continue;
      if (!inRadius(tx,ty,u.x,u.y,r)) continue;
      if (u.p!==p) continue;
      healUnit(st, u, spec.heal, true);
      pushFx(st, u.x,u.y, "+", "#bbf7d0", 90, 560, "spell");
    }
    for (const s of structs){
      if (s.hp<=0) continue;
      if (!inRadius(tx,ty,s.x,s.y,r)) continue;
      if (s.p!==p) continue;
      s.hp = Math.min(s.maxhp, s.hp + Math.floor(spec.heal*0.6));
      pushFx(st, s.x,s.y, "‚ú®", "#86efac", 90, 560, "spell");
    }
  }

  if (spec.lineDmg){
    for (const u of units){
      if (u.hp<=0 || u.p===p) continue;
      if (u.x!==tx) continue;
      applyDamageToUnit(st, null, u, spec.lineDmg, Date.now());
      pushFx(st, u.x,u.y, "ü™µ", "#f59e0b", 0, 640, "impact");
    }
    for (const s of structs){
      if (s.hp<=0 || s.p===p) continue;
      if (s.x!==tx) continue;
      s.hp -= Math.max(1, Math.floor(spec.lineDmg * damageTakenMult(st, s.x,s.y)));
      pushFx(st, s.x,s.y, "üí•", "#fdba74", 0, 700, "explosion");
    }
    for (let yy=0;yy<H;yy++){
      pushFx(st, tx, yy, "ü™µ", "#f59e0b", yy*35, 650, "spell");
    }
  }

  if (spec.aura){
    st.auras = st.auras || [];
    st.auras.push({
      id: crypto.randomUUID(),
      p,
      x:tx,y:ty,
      ...spec.aura,
      until: Date.now() + (spec.aura.ttlMs||0)
    });
    pushFx(st, tx,ty, "‚ú®", "#a78bfa", 0, 820, "spell");
  }
}

function tickSim(st){
  const now = Date.now();

  if (st.phase==="battle" && st.endsAt && now >= st.endsAt){
    const c0 = st.crowns?.[0] ?? 0;
    const c1 = st.crowns?.[1] ?? 0;
    st.phase = "gameover";
    if (c0>c1){ st.winner=0; st.winReason="crowns"; }
    else if (c1>c0){ st.winner=1; st.winReason="crowns"; }
    else { st.winner=null; st.winReason="draw"; }
    return;
  }

  const dt = clamp(now - (st.lastTickAt||now), 0, 800);

  const prevHP = new Map((st.structures||[]).map(s=>[s.id, s.hp]));

  // elixir regen
  for (let p=0;p<2;p++){
    const e = (st.elixir?.[p] ?? 0) + dt/ELIXIR_MS_PER;
    st.elixir[p] = clamp(e, 0, MAX_ELIXIR);
  }

  // process orders
  const orders = Array.isArray(st.orders) ? st.orders : [];
  for (const o of orders){
    const p = o.p|0;
    const cardId = o.card;
    const card = CARDS[cardId];
    if (!card) continue;
    if (!Array.isArray(st.players) || st.players.length < 2) continue;

    const cost = card.cost|0;
    if ((st.elixir[p] ?? 0) + 1e-9 < cost) continue;

    const x=o.x|0, y=o.y|0;
    if (!inside(x,y)) continue;

    if (card.place === "friendly"){
      if (!onMySide(p, x, y)) continue;
      if (isRiver(x,y)) continue;
      if (isStructureTile(st.structures, x, y)) continue;
    } else if (card.kind==="troop"){
      // "any" troop placement still can't be on structures / blocked river (unless flying)
      if (isStructureTile(st.structures, x, y)) continue;
      if (isRiver(x,y) && !card.unit?.flying) continue;
    }

    st.elixir[p] = clamp((st.elixir[p] ?? 0) - cost, 0, MAX_ELIXIR);

    if (card.kind === "troop"){
      const spawn = Math.max(1, card.spawn|0);
      for (let i=0;i<spawn;i++){
        const spots = [
          {x,y},{x:x-1,y},{x:x+1,y},{x,y:y-1},{x,y:y+1}
        ].filter(s=>inside(s.x,s.y) && (!isRiver(s.x,s.y) || !!card.unit?.flying) && !isStructureTile(st.structures,s.x,s.y));
        const spot = spots[i % spots.length] || {x,y};
        st.units.push(newUnit(p, cardId, spot.x, spot.y));
      }
      pushFx(st, x,y, card.emoji, (p===0 ? "#60a5fa" : "#f87171"));
    } else {
      applySpell(st, p, cardId, x, y);
    }

    // hand cycling
    const pk = p===0 ? "p0" : "p1";
    const hand = st.hand?.[pk] ? st.hand[pk].slice() : [];
    const queue= st.queue?.[pk] ? st.queue[pk].slice() : [];

    const idx = hand.indexOf(cardId);
    if (idx >= 0){
      hand.splice(idx,1);
      queue.push(cardId);
      const draw = queue.shift();
      if (draw) hand.push(draw);
      st.hand[pk] = hand;
      st.queue[pk]= queue;
    }
  }
  st.orders = [];

  // fx cleanup
  st.fx = (st.fx||[]).filter(f=> (f.at + (f.ttl||FX_TTL)) > now).slice(-MAX_FX);

  // aura upkeep + heal aura
  st.auras = (st.auras||[]).filter(a=>a.until>now);
  for (const a of st.auras){
    if (a.type!=="heal") continue;
    for (const u of st.units||[]){
      if (u.hp<=0 || u.p!==a.p) continue;
      if (!inRadius(a.x,a.y,u.x,u.y,a.radius||0)) continue;
      const amt = Math.max(1, Math.floor((u.maxhp||1) * (a.healPctPerSec||0) * (dt/1000)));
      healUnit(st, u, amt, true);
      if (Math.random() < 0.35) pushFx(st, u.x,u.y, "+", "#fde047", 0, 500);
    }
  }

  // burn + poison tick
  for (const u of (st.units||[])){
    if (u.hp<=0) continue;
    if ((u.burnUntil||0) > now && (u.burnDps||0) > 0){
      u.burnAcc = (u.burnAcc||0) + (u.burnDps * dt / 1000);
      const burnDmg = Math.floor(u.burnAcc||0);
      if (burnDmg > 0){
        u.hp -= burnDmg;
        u.burnAcc -= burnDmg;
        pushFx(st, u.x,u.y, "üî•", "#fb923c", 0, 520, "impact");
        if (Math.random() < 0.5) pushFx(st, u.x,u.y, "", "#fb923c", 50, 420, "sparks");
      }
    } else u.burnAcc = 0;

    if ((u.poisonUntil||0) > now && (u.poisonDps||0) > 0){
      u.poisonAcc = (u.poisonAcc||0) + (u.poisonDps * dt / 1000);
      const poisonDmg = Math.floor(u.poisonAcc||0);
      if (poisonDmg > 0){
        u.hp -= poisonDmg;
        u.poisonAcc -= poisonDmg;
        pushFx(st, u.x,u.y, "‚ò†Ô∏è", "#86efac", 0, 520, "impact");
        if (Math.random() < 0.55) pushFx(st, u.x,u.y, "‚ú£", "#4ade80", 40, 520, "spell");
      }
    } else u.poisonAcc = 0;
  }

  // unit actions
  for (const u of st.units){
    if (u.hp<=0) continue;

    if (u.summonCard && u.summonEveryMs && now >= (u.nextSummon||0)){
      u.nextSummon = now + u.summonEveryMs;
      for (let i=0;i<(u.summonCount||1);i++){
        const spots = neighbors4(u.x,u.y).concat([{x:u.x,y:u.y}]).filter(s=>inside(s.x,s.y) && walkable(st.structures,s.x,s.y,false));
        const spot = spots[i % Math.max(1,spots.length)] || {x:u.x,y:u.y};
        st.units.push(newUnit(u.p, u.summonCard, spot.x, spot.y));
      }
      pushFx(st, u.x, u.y, "‚ò†Ô∏è", "#c4b5fd");
    }

    if ((u.stunUntil||0) > now) continue;

    // healer behavior
    if (u.healAmount){
      const allyInRange = findNearestDamagedAllyUnit(st.units, u.p, u, u.range||1);
      if (allyInRange && now >= (u.nextAtk||0)){
        healUnit(st, allyInRange, u.healAmount, true);
        pushFx(st, u.x, u.y, "‚ú®", "#86efac", 0, 520, "spell");
        pushFx(st, allyInRange.x, allyInRange.y, "+", "#86efac", 60, 560, "spell");
        u.nextAtk = now + (u.cdMs||1000);
        continue;
      }
      if (now >= (u.nextMove||0)){
        u.nextMove = now + Math.max(180, Math.floor((u.spdMs||560) * speedMult(st, u)));
        const allyToHelp = findNearestDamagedAllyUnit(st.units, u.p, u, Infinity);
        if (allyToHelp){
          const goals = new Set();
          for (let yy=0;yy<H;yy++){
            for (let xx=0;xx<W;xx++){
              if (!walkable(st.structures, xx,yy, !!u.flying)) continue;
              const d = Math.abs(xx-allyToHelp.x)+Math.abs(yy-allyToHelp.y);
              if (d <= (u.range||1)) goals.add(keyXY(xx,yy));
            }
          }
          const step = bfsNextStep(st.structures, {x:u.x,y:u.y}, goals, !!u.flying);
          if (step){ u.x = step.x; u.y = step.y; }
        }
      }
      continue;
    }

    let targetUnit = null;
    let targetStruct = null;

    if (u.airPriority){
      const enemies = (st.units||[]).filter(v=>v.hp>0 && v.p!==u.p && v.flying && canTarget(u,v));
      enemies.sort((a,b)=> (Math.abs(a.x-u.x)+Math.abs(a.y-u.y))-(Math.abs(b.x-u.x)+Math.abs(b.y-u.y)));
      if (enemies[0] && Math.abs(enemies[0].x-u.x)+Math.abs(enemies[0].y-u.y)<=u.range) targetUnit = enemies[0];
    }

    if (!targetUnit && u.targets !== "buildings") targetUnit = findNearestEnemyUnit(st.units, u.p, u, u.range);
    if (!targetUnit) targetStruct = findNearestEnemyStructure(st.structures, u.p, u, u.range);

    if (targetUnit || targetStruct){
      if (now >= (u.nextAtk||0)){
        const dmg = u.dmg|0;
        const dist = targetUnit
          ? (Math.abs(targetUnit.x-u.x)+Math.abs(targetUnit.y-u.y))
          : (Math.abs(targetStruct.x-u.x)+Math.abs(targetStruct.y-u.y));
        const ranged = isRangedTroop(u);
        const baseColor = (u.p===0?"#60a5fa":"#f87171");
        const tColor = projectileColorFor(u.type, baseColor);

        // local FX entries (synced)
        pushFx(st, u.x, u.y, attackGlyph(u.type), tColor, 0, 520, ranged ? "impact" : "slash");

        if (targetUnit){
          if (ranged){
            pushFx(st, targetUnit.x, targetUnit.y, projectileGlyph(u.type), tColor, 0, 300, "impact", {x:u.x,y:u.y}, projectileGlyph(u.type));
          }
          if (u.lavaWaveRange){
            const axisX = Math.abs(targetUnit.x-u.x) >= Math.abs(targetUnit.y-u.y);
            const dirX = axisX ? Math.sign(targetUnit.x-u.x || (u.p===0 ? -1 : 1)) : 0;
            const dirY = axisX ? 0 : Math.sign(targetUnit.y-u.y || (u.p===0 ? -1 : 1));
            for (let i=1;i<=u.lavaWaveRange;i++){
              const wx = u.x + dirX*i;
              const wy = u.y + dirY*i;
              if (!inside(wx,wy)) break;
              pushFx(st, wx, wy, "üåä", "#fb923c", i*55, 620, "spell");
              for (const v of st.units){
                if (v.hp<=0 || v.p===u.p) continue;
                if (v.x!==wx || v.y!==wy) continue;
                if (!canTarget(u,v)) continue;
                applyDamageToUnit(st, u, v, dmg, now);
                pushUnitBack(st, u, v, u.pushBack||1);
                pushFx(st, v.x, v.y, "üî•", "#fb923c", 40, 620, "impact");
              }
            }
          } else if (u.chargeDmg && u.chargeRange && dist<=u.chargeRange){
            applyDamageToUnit(st, u, targetUnit, u.chargeDmg, now);
            u.stunUntil = Math.max(u.stunUntil||0, now + (u.chargeSelfStunMs||0));
            pushFx(st, targetUnit.x, targetUnit.y, "üí¢", "#fca5a5", 60, 560, "impact");
          } else if (u.cleaveRadius){
            for (const v of st.units){
              if (v.hp<=0 || v.p===u.p) continue;
              if (!canTarget(u,v)) continue;
              if (inRadius(targetUnit.x,targetUnit.y,v.x,v.y,u.cleaveRadius|0)){
                applyDamageToUnit(st, u, v, dmg, now);
                pushFx(st, v.x, v.y, "‚ú¶", "#fde68a", 40, 480, "hit");
              }
            }
            pushFx(st, targetUnit.x, targetUnit.y, "‚ï±", "#fde68a", 0, 420, "slash");
            pushFx(st, targetUnit.x, targetUnit.y, "‚ï≤", "#fde68a", 60, 420, "slash");
            pushFx(st, targetUnit.x, targetUnit.y, "", "#facc15", 80, 420, "sparks");
          } else if (u.splash){
            for (const v of st.units){
              if (v.hp<=0 || v.p===u.p) continue;
              if (!canTarget(u,v)) continue;
              if (inRadius(targetUnit.x,targetUnit.y,v.x,v.y,u.splash|0)){
                applyDamageToUnit(st, u, v, dmg, now);
                pushFx(st, v.x, v.y, "‚úπ", "#fdba74", 70, 520, "impact");
              }
            }
            pushFx(st, targetUnit.x, targetUnit.y, "üí•", "#fdba74", 0, 720, "explosion");
            pushFx(st, targetUnit.x, targetUnit.y, "", "#fdba74", 60, 420, "sparks");
          } else {
            applyDamageToUnit(st, u, targetUnit, dmg, now);
            if (ranged){
              pushFx(st, targetUnit.x, targetUnit.y, "‚úπ", "#fde68a", 40, 500, "impact");
            } else {
              pushFx(st, targetUnit.x, targetUnit.y, "‚ï±", "#fde68a", 0, 400, "slash");
              pushFx(st, targetUnit.x, targetUnit.y, "‚ú¶", "#fef3c7", 90, 450, "hit");
              pushFx(st, targetUnit.x, targetUnit.y, "", "#facc15", 70, 460, "sparks");
            }
          }
        } else if (targetStruct){
          targetStruct.hp -= Math.max(1, Math.floor(dmg * damageTakenMult(st, targetStruct.x,targetStruct.y)));
          if (ranged){
            pushFx(st, targetStruct.x, targetStruct.y, projectileGlyph(u.type), tColor, 0, 320, "impact", {x:u.x,y:u.y}, projectileGlyph(u.type));
          }
          pushFx(st, targetStruct.x, targetStruct.y, "üí•", "#e5e7eb", 80, 580, ranged ? "impact" : "slash");
          pushFx(st, targetStruct.x, targetStruct.y, "", "#facc15", 70, 460, "sparks");
        }
        u.nextAtk = now + (u.cdMs||1000);
      }
      continue;
    }

    if (now < (u.nextMove||0)) continue;
    u.nextMove = now + Math.max(180, Math.floor((u.spdMs||560) * speedMult(st, u)));

    const enemyP = u.p===0 ? 1 : 0;
    const candidates = enemyStructPriority(st.structures, enemyP);
    if (!candidates.length) continue;

    candidates.sort((a,b)=> (Math.abs(a.x-u.x)+Math.abs(a.y-u.y)) - (Math.abs(b.x-u.x)+Math.abs(b.y-u.y)));
    const tgt = candidates[0];

    const goals = new Set();
    for (let yy=0;yy<H;yy++){
      for (let xx=0;xx<W;xx++){
        if (!walkable(st.structures, xx,yy, !!u.flying)) continue;
        const d = Math.abs(xx-tgt.x)+Math.abs(yy-tgt.y);
        if (d <= (u.range||1)) goals.add(keyXY(xx,yy));
      }
    }
    const step = bfsNextStep(st.structures, {x:u.x,y:u.y}, goals, !!u.flying);
    if (step){ u.x = step.x; u.y = step.y; }
  }

  // split deaths
  const splitAdds = [];
  for (const u of st.units||[]){
    if (u.hp>0 || !u.splitInto || !u.splitCount) continue;
    for (let i=0;i<u.splitCount;i++){
      const spots = neighbors4(u.x,u.y).concat([{x:u.x,y:u.y}]).filter(s=>inside(s.x,s.y) && walkable(st.structures,s.x,s.y,false));
      const spot = spots[i % Math.max(1,spots.length)] || {x:u.x,y:u.y};
      splitAdds.push(newUnit(u.p, u.splitInto, spot.x, spot.y));
    }
    pushFx(st, u.x, u.y, "ü™®", "#93c5fd");
  }

  // structure AI
  for (const s of (st.structures||[])){
    if (s.hp<=0) continue;
    if (now < (s.nextAtk||0)) continue;
    const enemy = findNearestEnemyUnit(st.units, s.p, {x:s.x,y:s.y, canHitAir:true}, s.range||4);
    if (!enemy) continue;
    enemy.hp -= (s.dmg|0);
    s.nextAtk = now + (s.cdMs||1100);
    const sColor = (s.p===0 ? "#60a5fa" : "#f87171");
    pushFx(st, s.x, s.y, "üèπ", sColor, 0, 500, "impact");
    pushFx(st, enemy.x, enemy.y, "üèπ", sColor, 0, 280, "impact", {x:s.x,y:s.y}, "üèπ");
    pushFx(st, enemy.x, enemy.y, "‚ú∂", sColor, 80, 520, "hit");
  }

  // clamp + remove dead + add split
  for (const s of (st.structures||[])) s.hp = Math.max(0, s.hp|0);
  st.units = (st.units||[]).filter(u=>u.hp>0);
  if (splitAdds.length) st.units.push(...splitAdds);

  // crown awards on structure death transitions
  for (const s of (st.structures||[])){
    const before = prevHP.get(s.id);
    if (before > 0 && s.hp <= 0){
      awardCrown(st, s);
      if (s.kind==="tower") pushFx(st, s.x, s.y, "üëë", "#fbbf24");
      if (s.kind==="castle") pushFx(st, s.x, s.y, "üí•üè∞", "#fb7185");
    }
  }

  // win if castle destroyed
  const p0Castle = st.structures.find(x=>x.id==="p0_c");
  const p1Castle = st.structures.find(x=>x.id==="p1_c");
  if (p0Castle && p0Castle.hp<=0){
    st.phase = "gameover"; st.winner = 1; st.winReason = "castle";
  } else if (p1Castle && p1Castle.hp<=0){
    st.phase = "gameover"; st.winner = 0; st.winReason = "castle";
  }

  st.lastTickAt = now;
}

/* ---------------- Host loop ---------------- */
function startHostLoop(){
  if (!isHost || hostTimer) return;
  hostTimer = setInterval(async ()=>{
    try{
      await runTransaction(db, async (tx)=>{
        const snap = await tx.get(stateRef);
        if (!snap.exists()) return;
        const st = snap.data();

        const players = Array.isArray(st.players) ? st.players.slice(0,2) : [];

        if (st.phase === "waiting" && players.length>=2){
          const now = Date.now();
          const readyMap = st.readyMap || {};
          const bothReady = !!readyMap[players[0]] && !!readyMap[players[1]];
          const draftEndsAt = st.draftEndsAt || (now + DRAFT_MS);
          if (!st.draftEndsAt){
            tx.set(stateRef, { draftEndsAt }, { merge:true });
            return;
          }
          if (!(bothReady || now >= draftEndsAt)) return;

          const p0Name = players[0] || "p0";
          const p1Name = players[1] || "p1";
          const deck0 = seededShuffle(deckForPlayer(p0Name), gameId + ":p0");
          const deck1 = seededShuffle(deckForPlayer(p1Name), gameId + ":p1");

          tx.set(stateRef, {
            ...st,
            phase:"battle",
            winner:null,
            winReason:null,
            startedAt: now,
            draftEndsAt:null,
            readyMap:{},
            lastTickAt: now,
            endsAt: now + MATCH_MS,
            crowns:[0,0],
            elixir:[0,0],
            hand:{p0:deck0.slice(0,4), p1:deck1.slice(0,4)},
            queue:{p0:deck0.slice(4),  p1:deck1.slice(4)},
            structures: initialStructures(),
            units:[],
            orders:[],
            fx:[],
            auras:[],
            eloApplied:false
          }, { merge:true });
          return;
        }

        if (st.phase !== "battle") return;

        const next = JSON.parse(JSON.stringify(st));
        tickSim(next);
        tx.set(stateRef, next, { merge:true });
      });
    }catch(e){
      console.warn("host tick failed", e);
    }
  }, TICK_MS);
}

function expectedScore(a,b){ return 1/(1+Math.pow(10,(b-a)/400)); }
async function applyEloIfNeeded(st){
  if (!isHost || !st || st.phase!=="gameover" || st.eloApplied) return;
  const p0 = st.players?.[0], p1 = st.players?.[1];
  if (!p0 || !p1) return;
  const w = st.winner;
  await runTransaction(db, async (tx)=>{
    const lobSnap = await tx.get(lobbyRef);
    const lob = lobSnap.exists()?lobSnap.data():{};
    const eloMap = { ...(lob.eloMap||{}) };
    const r0 = eloMap[p0]||1000, r1 = eloMap[p1]||1000;
    const e0 = expectedScore(r0,r1), e1 = expectedScore(r1,r0);
    const s0 = w===0?1:w===1?0:0.5;
    const s1 = w===1?1:w===0?0:0.5;
    eloMap[p0] = Math.max(600, Math.round(r0 + ELO_K*(s0-e0)));
    eloMap[p1] = Math.max(600, Math.round(r1 + ELO_K*(s1-e1)));
    tx.set(lobbyRef, { eloMap, updatedAt: Date.now() }, { merge:true });
    tx.set(stateRef, { eloApplied:true }, { merge:true });
  });
}

/* ---------------- Rendering ---------------- */
function pad2(n){ return String(n).padStart(2,"0"); }
function fmtMMSS(ms){
  const s = Math.max(0, Math.ceil(ms/1000));
  const m = Math.floor(s/60);
  const r = s%60;
  return `${m}:${pad2(r)}`;
}

function renderSelectedTray(isDrafting=false, hand=[]){
  if (!selectedTray) return;

  if (isDrafting || S?.phase !== "battle"){
    selectedTray.innerHTML = '<span class="trayHint">Tap cards below to queue. Tap here to unselect.</span>';
    return;
  }

  selectedQueue = selectedQueue.filter(cid=>hand.includes(cid));
  if (selectedCard && !selectedQueue.includes(selectedCard)) selectedCard = null;

  if (!selectedQueue.length){
    selectedTray.innerHTML = '<span class="trayHint">No queued cards yet. Tap any troop/spell below.</span>';
    return;
  }

  selectedTray.innerHTML = '';
  for (const cid of selectedQueue){
    const c = CARDS[cid];
    if (!c) continue;
    const b = document.createElement('button');
    b.type = 'button';
    b.className = 'trayCard' + (selectedCard===cid ? ' queued' : '');
    b.innerHTML = `
      ${cardIconHTML(cid, meIndex)}
      <span class="name">${c.name}</span>
      <span class="cost">${c.cost} elixir</span>
    `;
    b.addEventListener('click', (ev)=>{
      ev.preventDefault();
      const idx = selectedQueue.indexOf(cid);
      if (idx>=0) selectedQueue.splice(idx,1);
      if (selectedCard===cid) selectedCard = selectedQueue[0] || null;
      render();
    });
    selectedTray.appendChild(b);
  }
}

selectedTray.addEventListener("click", (e)=>{
  // clicking empty area clears selection
  if (e.target === selectedTray || e.target.classList.contains("trayHint")){
    selectedCard = null;
    selectedQueue = [];
    cancelBtn.style.display="none";
    render();
  }
});

function render(){
  if (!S){
    timerText.textContent = "‚Äî";
    crownText.textContent = "0‚Äì0";
    return;
  }

  const players = Array.isArray(S.players) ? S.players : [];
  const me = players[meIndex] || username;
  const opp = players[1-meIndex] || (players.length<2 ? "Waiting‚Ä¶" : "Opponent");
  meNameEl.textContent = me;
  oppNameEl.textContent = opp;

  const meElo = lobbyMeta.eloMap?.[me] || 1000;
  const oppElo = lobbyMeta.eloMap?.[opp] || 1000;
  meEloEl.textContent = `(${meElo})`;
  oppEloEl.textContent = `(${oppElo})`;

  $("meBadge").classList.toggle("blue", meIndex===0);
  $("meBadge").classList.toggle("red", meIndex===1);
  $("oppBadge").classList.toggle("blue", meIndex===1);
  $("oppBadge").classList.toggle("red", meIndex===0);

  const c0 = S.crowns?.[0] ?? 0;
  const c1 = S.crowns?.[1] ?? 0;
  crownText.textContent = `${c0}‚Äì${c1}`;

  if (S.phase === "battle" && S.endsAt){
    timerText.textContent = fmtMMSS(S.endsAt - Date.now());
  } else if (S.phase === "waiting"){
    timerText.textContent = fmtMMSS((S.draftEndsAt||Date.now()) - Date.now());
  } else timerText.textContent = "‚Äî";

  if (S.phase === "waiting"){
    hint("30s draft: pick up to 8, tap again to remove, then press ready.");
  } else if (S.phase === "battle"){
    hint(selectedCard ? `Queued: ${CARDS[selectedCard].emoji} ${CARDS[selectedCard].name} ‚Äî tap a tile to play` : "Tap a troop or spell to add it to the queue, then tap a tile to play. Drag to pan, pinch to zoom.");
  } else if (S.phase === "gameover"){
    let msg = "Game Over.";
    if (S.winReason === "castle"){
      msg = (S.winner===meIndex) ? "YOU WIN üèÜ (Castle destroyed!)" : "YOU LOSE üíÄ (Castle destroyed!)";
    } else if (S.winReason === "crowns"){
      msg = (S.winner===meIndex) ? `YOU WIN üèÜ (Crowns ${c0}‚Äì${c1})` : `YOU LOSE üíÄ (Crowns ${c0}‚Äì${c1})`;
    } else if (S.winReason === "draw"){
      msg = `DRAW ü§ù (Crowns ${c0}‚Äì${c1})`;
    }
    hint(msg);
  }

  // my elixir
  const e = S.elixir?.[meIndex] ?? 0;
  elixirNum.textContent = String(Math.floor(e));
  elixirFill.style.width = (100 * (e/MAX_ELIXIR)) + "%";
  elixirWrap.style.display = (S.phase==="battle") ? "flex" : "none";

  const isDrafting = (S.phase==="waiting" && players.length>=2);
  draftOverlay.classList.toggle("show", isDrafting);
  if (!isDrafting) localDraftDeck = null;
  if (isDrafting && !Array.isArray(localDraftDeck)) localDraftDeck = editableDeckForPlayer(username);

  const myDeck = editableDeckForPlayer(username);
  const rm = S.readyMap || {};
  const readyLabel = rm[username] ? "‚úÖ Ready" : "Ready";
  readyBtnOverlay.textContent = readyLabel;

  const draftText = `Deck ${myDeck.length}/8 ‚Ä¢ Ready ${players.filter(n=>rm[n]).length}/${Math.min(players.length,2)} ‚Ä¢ ${fmtMMSS((S.draftEndsAt||Date.now())-Date.now())}`;
  draftInfoOverlay.textContent = draftText;

  // cards / deck builder
  const pk = (meIndex===0) ? "p0" : "p1";
  const hand = (S.hand && S.hand[pk]) ? S.hand[pk] : [];
  const myEloNow = lobbyMeta.eloMap?.[username] || 1000;

  cardsEl.innerHTML = "";
  draftCardsEl.innerHTML = "";
  const activeCardsEl = isDrafting ? draftCardsEl : cardsEl;

  const sourceCards = (S.phase === "waiting") ? CARD_POOL : hand;
  for (const cid of sourceCards){
    const c = CARDS[cid];
    if (!c) continue;
    const req = ELO_REQ[cid] || 0;
    const locked = req > myEloNow;
    const inDeck = myDeck.includes(cid);

    const el = document.createElement("div");
    const selected = (S.phase === "waiting") ? inDeck : selectedCard===cid;
    el.className = "card" + (selected ? " sel" : "");
    el.innerHTML = `
      <div class="top"><div class="cost">${c.cost}</div></div>
      <div class="mid">${cardIconHTML(cid, meIndex)}</div>
      <div class="name">${c.name}</div>
      ${locked ? `<div class="lock">ELO ${req}</div>` : ""}
    `;
    el.style.opacity = locked ? ".45" : "1";

    const onCardPress = async (ev)=>{
      ev.preventDefault();
      if (locked){ toast(`Requires ELO ${req}`); return; }

      if (S.phase === "waiting"){
        const current = Array.isArray(localDraftDeck) ? localDraftDeck.slice() : myDeck.slice();
        const i = current.indexOf(cid);
        if (i>=0) current.splice(i,1);
        else if (current.length<8) current.push(cid);
        else { toast("Deck already has 8 cards."); return; }
        localDraftDeck = current;
        render();
        try{ await updateDoc(lobbyRef, { [`deckMap.${username}`]: current, updatedAt: Date.now() }); }
        catch(e){ console.warn(e); toast("Deck sync failed. Retrying..."); localDraftDeck = null; render(); }
        return;
      }

      if (S.phase !== "battle"){ toast("Match not active."); return; }
      if (!hand.includes(cid)){ toast("Card not in hand."); return; }
      if (!selectedQueue.includes(cid)) selectedQueue.push(cid);
      selectedCard = cid;
      cancelBtn.style.display="inline-block";
      render();
    };

    el.addEventListener("pointerdown", onCardPress);
    activeCardsEl.appendChild(el);
  }

  renderSelectedTray(isDrafting, hand);
  cancelBtn.style.display = (S.phase==="battle" && selectedQueue.length) ? "inline-block" : "none";

  paintBoard();
  scheduleFxFromState();
}

readyBtnOverlay.addEventListener("click", async ()=>{
  if (!S || S.phase!=="waiting") return;
  if ((S.players||[]).length<2){ toast("Waiting for opponent"); return; }
  try{
    await updateDoc(stateRef, { [`readyMap.${username}`]: !(S.readyMap?.[username]), lastReadyAt: Date.now() });
  }catch(e){ console.warn(e); toast("Ready update failed"); }
});

fullscreenBtn.addEventListener("click", async ()=>{
  try{
    if (!document.fullscreenElement) await document.documentElement.requestFullscreen();
    else await document.exitFullscreen();
  }catch(e){ console.warn(e); toast("Fullscreen unavailable on this device."); }
});

cancelBtn.addEventListener("click", ()=>{
  selectedCard = null;
  selectedQueue = [];
  cancelBtn.style.display="none";
  render();
});

/* ---------------- Board paint ---------------- */
function paintBoard(){
  const structs = S.structures || [];
  const units = S.units || [];

  const groups = new Map();
  for (const u of units){
    if (u.hp<=0) continue;
    const k = keyXY(u.x,u.y);
    if (!groups.has(k)) groups.set(k, []);
    groups.get(k).push(u);
  }

  // show placement hints if queued
  const queued = (S.phase==="battle" && selectedCard && CARDS[selectedCard]);
  for (let y=0;y<H;y++){
    for (let x=0;x<W;x++){
      const cell = getCell(x,y);
      const under = cell.querySelector(".under");
      const piece = cell.querySelector(".piece");
      const hpFill= cell.querySelector(".hp>i");

      cell.classList.remove("placeHint","placeBlocked");

      under.style.background = "transparent";
      piece.innerHTML = "";
      piece.style.opacity = "1";
      hpFill.style.width = "0%";
      hpFill.className = "neutral";

      // subtle aura visuals
      if (S.auras?.length){
        const aHere = (S.auras||[]).filter(a=>a.until>Date.now() && inRadius(a.x,a.y,x,y,a.radius||0));
        if (aHere.length){
          const hasHaste = aHere.some(a=>a.type==="haste");
          const hasArmor = aHere.some(a=>a.type==="armor");
          const hasHeal  = aHere.some(a=>a.type==="heal");
          const col = hasHeal ? "rgba(34,197,94,.18)" : hasHaste ? "rgba(56,189,248,.18)" : hasArmor ? "rgba(168,85,247,.18)" : "rgba(255,255,255,.12)";
          under.style.background = `radial-gradient(circle at 50% 50%, ${col}, transparent 60%)`;
        }
      }

      // structures
      const s = structureAt(structs, x,y);
      if (s){
        piece.innerHTML = wrapSprite(spriteForStructure(s.kind), s.p);
        const pct = Math.max(0, Math.min(1, s.hp / (s.maxhp||1)));
        hpFill.style.width = (pct*100) + "%";
        hpFill.className = (s.p===0?"p0":"p1");
        continue;
      }

      // units
      const g = groups.get(keyXY(x,y));
      if (g && g.length){
        g.sort((a,b)=>b.hp-a.hp); // most alive first
        const top = g[0];
        piece.innerHTML = wrapSprite(spriteForUnit(top.type), top.p) + (g.length>1 ? `<div class="stack">${g.length}</div>` : "");
        const pct = Math.max(0, Math.min(1, top.hp / (top.maxhp||1)));
        hpFill.style.width = (pct*100) + "%";
        hpFill.className = (top.p===0?"p0":"p1");
        // stealth: if enemy assassin not revealed, fade a bit
        if (top.type==="assassin" && top.p!==meIndex && !top.revealed){
          piece.style.opacity = ".45";
        }
      }
    }
  }

  if (queued){
    const card = CARDS[selectedCard];
    for (let y=0;y<H;y++){
      for (let x=0;x<W;x++){
        const cell = getCell(x,y);
        if (!cell) continue;

        let ok = true;
        if (!inside(x,y)) ok=false;

        if (card.kind==="troop"){
          const flying = !!card.unit?.flying;
          if (isStructureTile(S.structures, x,y)) ok=false;
          if (isRiver(x,y) && !flying) ok=false;
          if (card.place==="friendly" && !onMySide(meIndex, x,y)) ok=false;
        } else {
          // spells: can be anywhere
          ok = inside(x,y);
        }

        cell.classList.add(ok ? "placeHint" : "placeBlocked");
      }
    }
  }
}

/* ---------------- FX render (from synced state) ---------------- */
const fxTimers = new Map();
function scheduleFxFromState(){
  if (!S || !Array.isArray(S.fx)) return;
  const now = Date.now();

  for (const f of S.fx){
    if (fxTimers.has(f.id)) continue;

    const delay = Math.max(0, (f.at||now) - now);
    const ttl = f.ttl || FX_TTL;

    const t = setTimeout(()=>{
      // show
      if (f.cls === "sparks"){
        fxSparks(f.x, f.y, f.color || "#fde68a", 7, 420);
      } else if (f.source && typeof f.source.x==="number"){
        fxProjectile(f.source.x, f.source.y, f.x, f.y, f.icon || f.text || "", f.color || "#e5e7eb", 260);
      } else {
        fxPop(f.x, f.y, f.text || "", f.color || "#e5e7eb", f.cls || "", Math.min(900, ttl));
      }
      // cleanup after TTL buffer
      setTimeout(()=>{ fxTimers.delete(f.id); }, ttl + 120);
    }, delay);

    fxTimers.set(f.id, t);
  }

  // prune timers for fx no longer in state (optional)
  if (fxTimers.size > 260){
    for (const [id, t] of fxTimers){
      if (!S.fx.some(x=>x.id===id)){
        clearTimeout(t);
        fxTimers.delete(id);
      }
    }
  }
}

/* ---------------- Client play: place troop/spell ---------------- */
async function onCellClick(x,y){
  if (isPanDrag) return;
  if (!S || S.phase!=="battle") return;
  if (!selectedQueue.length || !selectedCard) return;

  const cid = selectedCard;
  const card = CARDS[cid];
  if (!card) return;

  // client-side placement guard (host also validates)
  if (card.kind==="troop"){
    const flying = !!card.unit?.flying;
    if (isStructureTile(S.structures, x,y)) { toast("Can't place on a structure."); return; }
    if (isRiver(x,y) && !flying) { toast("Can't place on river."); return; }
    if (card.place==="friendly" && !onMySide(meIndex, x,y)) { toast("Place on your side."); return; }
  }

  try{
    await runTransaction(db, async (tx)=>{
      const snap = await tx.get(stateRef);
      if (!snap.exists()) return;
      const st = snap.data();
      if (st.phase !== "battle") return;

      const orders = Array.isArray(st.orders) ? st.orders.slice(0,50) : [];
      orders.push({ id: crypto.randomUUID(), p: meIndex, card: cid, x, y, t: Date.now() });
      tx.set(stateRef, { orders }, { merge:true });
    });

    // locally pop from queue immediately
    const idx = selectedQueue.indexOf(cid);
    if (idx>=0) selectedQueue.splice(idx,1);
    selectedCard = selectedQueue[0] || null;
    if (!selectedQueue.length) cancelBtn.style.display="none";
    render();

  }catch(e){
    console.warn(e);
    toast("Play failed (sync). Try again.");
  }
}

/* ---------------- Snapshots + boot ---------------- */
function updateFromLobbyDoc(lob){
  lobbyMeta = { eloMap: lob.eloMap||{}, deckMap: lob.deckMap||{} };
  lobbyPlayers = Array.isArray(lob.players) ? lob.players.slice(0,2) : [];
  meIndex = lobbyPlayers.indexOf(username);
  if (meIndex < 0) meIndex = 0;
  isHost = (lobbyPlayers[0] === username);
  if (isHost) startHostLoop();
}

let uiTimer = null;

async function boot(){
  await joinLobby();
  await ensureStateExists();
  if (isHost) startHostLoop();

  onSnapshot(lobbyRef, (snap)=>{
    if (!snap.exists()) return;
    updateFromLobbyDoc(snap.data());
    render();
  });

  onSnapshot(stateRef, (snap)=>{
    if (!snap.exists()) return;
    S = snap.data();
    if (isHost) startHostLoop();
    if (!uiTimer){
      uiTimer = setInterval(()=>{
        // keep timer + hint feeling alive even between snapshots
        if (S && (S.phase==="battle" || S.phase==="waiting")) render();
      }, 250);
    }
    render();
    applyEloIfNeeded(S).catch(()=>{});
  });

  // initial render fallback
  render();
}
boot().catch(e=>{ console.error(e); toast("Boot failed. Check console."); });

</script>
</body>
</html>



