<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Micro Wars ‚Äî Sentries + Blinkers + Guardians</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --panel-w: 320px; --bg:#0e0f12; --ink:#e7ecf2; --muted:#8ba0b3; --accent:#4da3ff;
    --good:#50e3a4; --bad:#ff6b6b; --warn:#ffd166; --grid:#1a1e25; --ring-blue:#4da3ff33; --ring-green:#38ef7d33;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial,"Noto Sans";user-select:none;overflow:hidden}
  #wrap{display:grid;grid-template-columns:1fr var(--panel-w);height:100%}
  #hudTop{position:absolute;top:10px;left:10px;right:calc(var(--panel-w) + 10px);display:flex;gap:12px;align-items:center;pointer-events:none}
  .chip{pointer-events:auto;background:#151922;border:1px solid #2a3240;padding:6px 10px;border-radius:999px;font-weight:600;display:inline-flex;align-items:center;gap:8px;box-shadow:0 1px 0 #0008,inset 0 1px 0 #ffffff08}
  .chip .dot{width:8px;height:8px;border-radius:50%;display:inline-block}
  #canvas{display:block;background:#0b0d11}
  #panel{background:#0f1218;border-left:1px solid #1f2631;padding:14px 14px 80px 14px;overflow-y:auto}
  h2,h3{margin:10px 0 6px}
  #selList{display:grid;grid-template-columns:1fr auto;gap:6px 8px}
  .row{display:flex;align-items:center;justify-content:space-between;gap:8px}
  .btn{background:#162131;border:1px solid #2a3240;color:var(--ink);padding:8px 10px;border-radius:10px;font-weight:700;cursor:pointer;box-shadow:inset 0 -1px 0 #0008,0 1px 0 #0006}
  .btn:hover{filter:brightness(1.1)}
  .btn[disabled]{opacity:.55;cursor:not-allowed}
  #abilityTray{display:flex;flex-wrap:wrap;gap:8px;margin-top:6px}
  .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;background:#0e1420;border:1px solid #2a3240;border-bottom-color:#1a2230;padding:0 6px;border-radius:6px;font-weight:700}
  #legend{font-size:13px;color:var(--muted);margin-top:10px}
  #legend b{color:var(--ink)}
  #levelFlash{position:absolute;inset:0 calc(var(--panel-w) + 0px) auto 0;display:flex;align-items:center;justify-content:center;pointer-events:none;font-weight:900;font-size:42px;letter-spacing:2px;color:#ffffffdd;text-shadow:0 2px 20px #000;opacity:0;transition:opacity .4s ease}
  #over{position:absolute;inset:0;display:none;align-items:center;justify-content:center;backdrop-filter:blur(2px);background:#0009}
  #overCard{width:min(560px,92vw);background:#0f1218;border:1px solid #2a3240;border-radius:16px;padding:18px;box-shadow:0 12px 50px #000a,inset 0 1px 0 #ffffff06}
  #overCard h2{margin:0 0 6px}
  .field{display:flex;gap:10px;align-items:center;margin:10px 0}
  .field input{flex:1 1 auto;background:#0b0f18;border:1px solid #273142;color:var(--ink);padding:10px 12px;border-radius:10px;outline:none}
  .listy{font-size:13px;color:var(--muted)}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#151a22;border:1px solid #253043;margin-right:6px}
  #controls{font-size:12px;color:#a9b6c6;line-height:1.4}
  .small{font-size:12px;color:var(--muted)}
  #cornerHelp{position:absolute;bottom:8px;left:8px;right:calc(var(--panel-w) + 8px);display:flex;gap:8px;align-items:center;pointer-events:none;opacity:.9}
  #cornerHelp .chip{pointer-events:auto}
</style>
</head>
<body>
<div id="wrap">
  <div style="position:relative;">
    <canvas id="canvas"></canvas>
    <div id="hudTop">
      <div id="levelChip" class="chip"><span class="dot" style="background:var(--accent)"></span> Wave <b id="levelNum">1</b></div>
      <div id="armyChip" class="chip"><span class="dot" style="background:var(--good)"></span> Army: <b id="armyType">Sentries + Blinkers</b> <span class="small" id="armyCount"></span></div>
      <div id="enemyChip" class="chip"><span class="dot" style="background:var(--bad)"></span> Enemies: <b id="enemyCount"></b></div>
      <div class="chip" title="Frames per second">FPS: <b id="fps">60</b></div>
    </div>
    <div id="levelFlash">WAVE 1</div>
    <div id="cornerHelp">
      <div class="chip">
        Box-select with left drag. <b>Right-click = Move</b>.
        <span class="kbd">A</span> Attack-nearest,
        <span class="kbd">B</span> Blink ‚Üí <b>Left-click</b> to Blink,
        <span class="kbd">F</span> Forcefield ‚Üí <b>Left-click</b> to place,
        <span class="kbd">Esc</span> cancel.
      </div>
    </div>
    <div id="over">
      <div id="overCard">
        <h2>Game Over</h2>
        <div class="listy">You reached <b>Wave <span id="finalLevel">1</span></b>. Save your score?</div>
        <div class="field">
          <input type="text" id="playerName" placeholder="Your name" maxlength="40"/>
          <button class="btn" id="saveScore">Save to Firebase</button>
        </div>
        <div class="small" id="saveMsg"></div>
        <div class="listy" style="margin-top:12px">
          <span class="pill">Sentry = üì° (beam)</span>
          <span class="pill">Blinker = üî∑ (bolt + Blink)</span>
          <span class="pill">Guardian = üõ°Ô∏è (melee tank)</span>
          <span class="pill">Ling = üêú</span>
          <span class="pill">Bling = üü¢ (AoE)</span>
          <span class="pill">Sting = ü¶ü (ranged)</span>
          <span class="pill">Brute = üëπ (cleave)</span>
          <span class="pill">Pickup = üéÅ</span>
          <span class="pill">Forcefield = üîµ (solid, pushes)</span>
        </div>
      </div>
    </div>
  </div>
  <aside id="panel">
    <h2>Selected <span id="selCount">0</span></h2>
    <div class="row" style="margin-bottom:6px">
      <div id="selBreakdown" class="small">‚Äî</div>
      <button id="clearSel" class="btn" title="Clear selection">Clear</button>
    </div>
    <div id="abilityTray">
      <button id="blinkBtn" class="btn" title="Enter Blink targeting mode (B). Blinkers teleport a short distance and auto-spread.">Blink (B)</button>
      <button id="forceBtn" class="btn" title="Enter Forcefield targeting mode (F). Uses one Sentry's cooldown.">Forcefield (F)</button>
      <button id="attackBtn" class="btn" title="Selected attack nearest enemy in aggro range">Attack Nearest (A)</button>
    </div>

    <h3 style="margin-top:16px;">Units</h3>
    <div id="selList"></div>

    <h3 style="margin-top:16px;">Legend</h3>
    <div id="legend">
      <div><b>üì° Sentry</b> ‚Äî low HP, beam (1 dmg @ 3/sec). Ability: <b>Forcefield</b> (5s, 10s CD; solid, pushes both teams).</div>
      <div><b>üî∑ Blinker</b> ‚Äî ranged bolt; <b>Blink</b> short-range with spread placement.</div>
      <div><b>üõ°Ô∏è Guardian</b> ‚Äî melee, tanky frontliner.</div>
      <div><b>üêú Ling</b> ‚Äî fast melee swarmer.</div>
      <div><b>üü¢ Bling</b> ‚Äî kamikaze + splash on hit and on death.</div>
      <div><b>ü¶ü Sting</b> ‚Äî short-ranged shooter.</div>
      <div><b>üëπ Brute</b> ‚Äî slow, tanky melee with cleave splash.</div>
      <div><b>üéÅ Pickup</b> ‚Äî walk over to spawn reinforcements (now includes Guardians).</div>
    </div>

    <h3 style="margin-top:16px;">Controls</h3>
    <div id="controls">
      ‚Ä¢ Left-drag to box-select. Click to select one.<br/>
      ‚Ä¢ Right-click ground to <b>move</b> there (movement overrides attacking).<br/>
      ‚Ä¢ <span class="kbd">A</span>: Attack nearest (if any in aggro range).<br/>
      ‚Ä¢ <span class="kbd">B</span>: Blink targeting ‚Üí <b>left-click</b> to blink selected Blinkers (auto-spread).<br/>
      ‚Ä¢ <span class="kbd">F</span>: Forcefield targeting ‚Üí <b>left-click</b> to place. Only <b>one</b> Sentry pays the cooldown.<br/>
      ‚Ä¢ Edge-pan the camera by pushing the mouse to canvas edges.<br/>
    </div>
  </aside>
</div>

<!-- Firebase (Compat v9) -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
<script>
/* ===========================
   Firebase
   =========================== */
const firebaseConfig = {
  apiKey:"AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain:"bible-game-246c0.firebaseapp.com",
  databaseURL:"https://bible-game-246c0-default-rtdb.firebaseio.com",
  projectId:"bible-game-246c0",
  storageBucket:"bible-game-246c0.firebasestorage.app",
  messagingSenderId:"959619818996",
  appId:"1:959619818996:web:5a9fbf492e23c765e445a1",
  measurementId:"G-8PR6LVKSH3"
};
let fbApp, fbDb;
try{ fbApp=firebase.initializeApp(firebaseConfig); fbDb=firebase.database(); }
catch(e){ console.warn("Firebase init error:", e); }

/* ===========================
   Helpers & Constants
   =========================== */
const TWO_PI=Math.PI*2;
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const rand=(a,b)=>a+Math.random()*(b-a);
const randi=(a,b)=>Math.floor(rand(a,b+1));
const dist2=(a,b)=>{const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy;};
const nowMS=()=>performance.now();

/* Smaller map (tight action) */
const MAP_W=3600, MAP_H=2400;
const VIEWPAD=180, EDGE_SCROLL=640, GRID=60;

/* Pickups */
const PICKUP_INTERVAL_RANGE=[8000,14000];
const MAX_ACTIVE_PICKUPS=5;

/* Forcefield (small & solid) */
const FORCEFIELD={ radius:40, push:3000, durMs:5000, cdMs:10000 };

const COLORS={
  hpGood:"#4de395", hpBad:"#ff6b81",
  ringSelf:"#4da3ff", ringEnemy:"#38ef7d",
  beam:"#79aaff", beamCore:"#cfe2ff",
  stingBolt:"#31dd77", blueBolt:"#5fb0ff",
  selBox:"#4da3ff88", selStroke:"#4da3ff",
  fieldFill:"rgba(80,150,255,0.12)", fieldStroke:"rgba(80,150,255,0.85)"
};

const PLAYER=1, ENEMY=2;

const UNIT_TYPES={
  SENTRY:"sentry",
  BLINKER:"blinker",
  GUARDIAN:"guardian",
  LING:"ling", BLING:"bling", STING:"sting", BRUTE:"brute",
};

const PLURAL_LABEL={
  sentry:"Sentries", blinker:"Blinkers", guardian:"Guardians"
};

/* ===========================
   Unit Stats
   =========================== */
const UNIT_STATS={
  // Player
  sentry:{ emoji:"üì°", r:10, team:PLAYER, maxHp:45, speed:170, range:240, aggro:360,
           beam:{dmg:2, rate:3}, forceCd:FORCEFIELD.cdMs },
  blinker:{ emoji:"üî∑", r:14, team:PLAYER, maxHp:70, speed:205, range:220, fireRate:0.6, dmg:16, projSpeed:640, aggro:380,
            blink:{ dist:180, cd:7000 } },
  guardian:{ emoji:"üõ°Ô∏è", r:13, team:PLAYER, maxHp:160, speed:150, range:20, fireRate:1.0, dmg:18, aggro:400, melee:true },

  // Enemies
  ling:{  emoji:"üêú", r:8,  team:ENEMY, maxHp:40,  speed:220, range:18, fireRate:1.6, dmg:12, aggro:400, melee:true },
  bling:{ emoji:"üü¢", r:10, team:ENEMY, maxHp:46,  speed:190, range:14, fireRate:1.2, dmg:32, aggro:380, melee:true, explode:{ radius:64, dmg:28 } },
  sting:{ emoji:"ü¶ü", r:9,  team:ENEMY, maxHp:60,  speed:160, range:100, fireRate:0.5, dmg:22, projSpeed:460, aggro:360 },
  brute:{ emoji:"üëπ", r:13, team:ENEMY, maxHp:180, speed:120, range:20, fireRate:0.9, dmg:30, aggro:420, melee:true, cleave:{ radius:54, dmg:18 } }
};

function makeUnit(kind,x,y){
  const S=UNIT_STATS[kind];
  return {
    id:Math.random().toString(36).slice(2),
    kind, team:S.team, x,y, vx:0,vy:0,
    r:S.r, maxHp:S.maxHp, hp:S.maxHp,
    speed:S.speed, range:S.range||0, fireRate:S.fireRate||0, dmg:S.dmg||0, projSpeed:S.projSpeed||0, aggro:S.aggro||0,
    melee:!!S.melee,
    beamTickCd:0,
    buffs:{ ffCdUntil:0, blinkCdUntil:0 },
    cleave:S.cleave||null, explode:S.explode||null,
    target:null, order:null, cd:0, alive:true, selected:false
  };
}

/* ===========================
   State
   =========================== */
const state={
  level:1,
  units:[], projs:[], splashes:[], pickups:[], fields:[],
  camera:{x:MAP_W/2-800, y:MAP_H/2-500, w:0, h:0},
  dragging:false, dragStart:null, dragEnd:null,
  mouse:{x:0,y:0,worldX:0,worldY:0,overCanvas:false},
  keys:{},
  forceMode:false, blinkMode:false,
  gameOver:false,
  nextPickupAt:0,
  _spawnNextWaveAt:null
};

const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");

const $=(id)=>document.getElementById(id);
const levelNum=$("levelNum"), enemyCountEl=$("enemyCount"), armyCountEl=$("armyCount"), armyTypeEl=$("armyType");
const levelFlash=$("levelFlash"), selCountEl=$("selCount"), selBreakdownEl=$("selBreakdown"), selListEl=$("selList");
const blinkBtn=$("blinkBtn"), forceBtn=$("forceBtn"), attackBtn=$("attackBtn"), clearSelBtn=$("clearSel");
const fpsEl=$("fps"), over=$("over"), finalLevelEl=$("finalLevel"), playerNameEl=$("playerName");
const saveScoreBtn=$("saveScore"), saveMsgEl=$("saveMsg");

/* ===========================
   Layout
   =========================== */
function resize(){
  const panelW=parseInt(getComputedStyle(document.documentElement).getPropertyValue("--panel-w"));
  const w=window.innerWidth - panelW, h=window.innerHeight;
  canvas.width=w; canvas.height=h; state.camera.w=w; state.camera.h=h;
}
window.addEventListener("resize", resize);

/* ===========================
   Spawning & Waves
   =========================== */
function spawnInitialArmy(){
  const cx=MAP_W/2, cy=MAP_H/2, ringR=120;
  const sentries=6, blinkers=3; // start with these two; Guardians come from pickups
  for (let i=0;i<sentries;i++){
    const a=Math.random()*TWO_PI, d=rand(10,ringR);
    state.units.push(makeUnit(UNIT_TYPES.SENTRY, cx+Math.cos(a)*d, cy+Math.sin(a)*d));
  }
  for (let i=0;i<blinkers;i++){
    const a=Math.random()*TWO_PI, d=rand(10,ringR);
    state.units.push(makeUnit(UNIT_TYPES.BLINKER, cx+Math.cos(a)*d, cy+Math.sin(a)*d));
  }
}
// Return the (player) unit at a world point without changing selection
function getUnitAt(wx, wy){
  for (let i = state.units.length - 1; i >= 0; i--){
    const u = state.units[i];
    if (!u.alive || u.team !== PLAYER || u.isStructure) continue;
    const rr = u.r + 4;
    if (dist2({x: wx, y: wy}, u) <= rr * rr) return u;
  }
  return null;
}

// Select every living player unit of a given kind
function selectAllOfKind(kind, additive = false){
  if (!additive) clearSelection();
  for (const u of state.units){
    if (u.alive && u.team === PLAYER && !u.isStructure && u.kind === kind){
      u.selected = true;
    }
  }
  refreshSelectionUI();
}


function pickEnemyKind(level){
  const r=Math.random();
  const bruteBias=Math.min(Math.max((level-5)*0.06,0),0.40);
  const stingBias=Math.min(0.12 + level*0.01, 0.28);
  const blingBias=Math.min(0.08 + level*0.012, 0.26);
  const lingBase=1-(bruteBias+stingBias+blingBias);
  if (r < lingBase) return UNIT_TYPES.LING;
  if (r < lingBase + stingBias) return UNIT_TYPES.STING;
  if (r < lingBase + stingBias + blingBias) return UNIT_TYPES.BLING;
  return UNIT_TYPES.BRUTE;
}
function edgeCenter(edge,margin){
  switch(edge){
    case 0: return {x:rand(margin,MAP_W-margin), y:margin};
    case 1: return {x:MAP_W-margin, y:rand(margin,MAP_H-margin)};
    case 2: return {x:rand(margin,MAP_W-margin), y:MAP_H-margin};
    default:return {x:margin, y:rand(margin,MAP_H-margin)};
  }
}
function spawnWave(level){
  levelNum.textContent=level; showWaveFlash(level);
  const base = 5 + Math.floor((level-1)*2);
  const clusters = Math.min(1 + Math.floor((level-1)/4), 3);
  const margin=40;
  const basePer = Math.max(5, Math.floor(base/clusters));
  const remainder = base - basePer*clusters;
  for (let c=0;c<clusters;c++){
    const edge=randi(0,3), center=edgeCenter(edge, margin);
    const radius=rand(90,160), count=basePer + (c<remainder?1:0);
    for (let i=0;i<count;i++){
      const kind=pickEnemyKind(level), ang=Math.random()*TWO_PI, d=rand(0,radius);
      const x=clamp(center.x+Math.cos(ang)*d, margin, MAP_W-margin);
      const y=clamp(center.y+Math.sin(ang)*d, margin, MAP_H-margin);
      state.units.push(makeUnit(kind,x,y));
    }
  }
}
function showWaveFlash(n){
  levelFlash.textContent="WAVE "+n; levelFlash.style.opacity=1;
  setTimeout(()=> levelFlash.style.opacity=0, 900);
}

/* ===========================
   Pickups (now include Guardians)
   =========================== */
function spawnPickup(){
  if (state.pickups.length >= MAX_ACTIVE_PICKUPS) return;
  const margin=140, x=rand(margin,MAP_W-margin), y=rand(margin,MAP_H-margin);
  state.pickups.push({ id:Math.random().toString(36).slice(2), x,y, r:18, born:performance.now(), life:rand(17000,26000), wobble:Math.random()*TWO_PI });
}
function grantReinforcements(){
  const around = state.units.find(u=>u.alive && u.team===PLAYER) || {x:MAP_W/2,y:MAP_H/2};
  const n = Math.min(4 + Math.floor(state.level/2), 12);
  const ringR=110;
  let spawnedGuardian=false;
  for (let i=0;i<n;i++){
    const a=Math.random()*TWO_PI, d=rand(12, ringR);
    let kind;
    // Weighted mix: ~55% Sentry, ~25% Blinker, ~20% Guardian (guarantee at least 1 Guardian per pickup)
    const r=Math.random();
    if (r < 0.20) { kind=UNIT_TYPES.GUARDIAN; spawnedGuardian=true; }
    else if (r < 0.45) kind=UNIT_TYPES.BLINKER;
    else kind=UNIT_TYPES.SENTRY;
    state.units.push(makeUnit(kind,
      clamp(around.x + Math.cos(a)*d,12,MAP_W-12),
      clamp(around.y + Math.sin(a)*d,12,MAP_H-12)));
  }
  if (!spawnedGuardian){
    // add one guardian near the last spawn spot for tank presence
    const a=Math.random()*TWO_PI, d=rand(24, ringR);
    state.units.push(makeUnit(UNIT_TYPES.GUARDIAN,
      clamp(around.x + Math.cos(a)*d,12,MAP_W-12),
      clamp(around.y + Math.sin(a)*d,12,MAP_H-12)));
  }
}
function checkPickupCollisions(){
  for (let i=state.pickups.length-1;i>=0;i--){
    const p=state.pickups[i];
    let collected=false;
    for (const u of state.units){
      if (!u.alive || u.team!==PLAYER) continue;
      const rr=u.r + p.r + 2;
      if (dist2(u,p) <= rr*rr){ collected=true; break; }
    }
    if (collected){
      grantReinforcements();
      state.pickups.splice(i,1);
      state.splashes.push({ x:p.x, y:p.y, r:80, t:performance.now(), dur:320 });
    }
  }
}

/* ===========================
   Blink helpers (spread & avoid forcefields)
   =========================== */
function spotOccupied(x,y,r, ignoreId=null){
  for (const o of state.units){
    if (!o.alive) continue;
    if (ignoreId && o.id===ignoreId) continue;
    const minD=r + o.r + 2, dx=x - o.x, dy=y - o.y;
    if (dx*dx + dy*dy < minD*minD) return true;
  }
  for (const f of state.fields){
    const minD=r + f.r + 2, dx=x - f.x, dy=y - f.y;
    if (dx*dx + dy*dy < minD*minD) return true;
  }
  return false;
}
function findBlinkSpot(u,x,y){
  x = clamp(x, u.r, MAP_W - u.r);
  y = clamp(y, u.r, MAP_H - u.r);
  if (!spotOccupied(x,y,u.r,u.id)) return {x,y};
  for (let rad=8; rad<=72; rad+=8){
    const steps=16;
    for (let i=0;i<steps;i++){
      const ang=(i/steps)*TWO_PI;
      const tx=clamp(x + Math.cos(ang)*rad, u.r, MAP_W-u.r);
      const ty=clamp(y + Math.sin(ang)*rad, u.r, MAP_H-u.r);
      if (!spotOccupied(tx,ty,u.r,u.id)) return {x:tx,y:ty};
    }
  }
  return {x:u.x, y:u.y};
}
function tryBlink(units, wx, wy){
  const now=performance.now();
  for (const u of units){
    if (u.kind!==UNIT_TYPES.BLINKER) continue;
    const B=UNIT_STATS.blinker.blink;
    if (now < u.buffs.blinkCdUntil) continue;
    const dx=wx - u.x, dy=wy - u.y, d=Math.hypot(dx,dy);
    const step=Math.min(B.dist, d || 0.0001);
    const nx=u.x + dx/(d||1)*step, ny=u.y + dy/(d||1)*step;
    const free=findBlinkSpot(u, nx, ny);
    u.x=free.x; u.y=free.y; u.vx=0; u.vy=0; u.order=null;
    u.buffs.blinkCdUntil = now + B.cd;
  }
}

/* ===========================
   Forcefields (solid + seam block)
   =========================== */
function placeForcefield(x,y){
  const now=performance.now();
  const elig=selectedUnits().filter(u=>u.kind===UNIT_TYPES.SENTRY && now>=u.buffs.ffCdUntil);
  if (!elig.length) return;
  const user=elig[0];
  user.buffs.ffCdUntil = now + FORCEFIELD.cdMs;
  const f={ id:Math.random().toString(36).slice(2), x:clamp(x,20,MAP_W-20), y:clamp(y,20,MAP_H-20), r:FORCEFIELD.radius, born:now, dur:FORCEFIELD.durMs };
  state.fields.push(f);

  // Eject any units inside so it behaves like a solid obstacle immediately
  for (const u of state.units){
    if (!u.alive) continue;
    const dx=u.x - f.x, dy=u.y - f.y; let d=Math.hypot(dx,dy);
    const minR=f.r + u.r + 2;
    if (d < minR){
      if (d===0){ const a=Math.random()*TWO_PI; d=0.0001; u.x=f.x + Math.cos(a)*minR; u.y=f.y + Math.sin(a)*minR; }
      else { const ux=dx/d, uy=dy/d; u.x=f.x + ux*minR; u.y=f.y + uy*minR; }
      const kick=220, kdx=u.x - f.x, kdy=u.y - f.y, kd=Math.hypot(kdx,kdy)||1;
      u.vx += (kdx/kd)*kick; u.vy += (kdy/kd)*kick;
    }
  }
}

/* ===========================
   Selection
   =========================== */
function worldFromScreen(x,y){ return {x:x+state.camera.x, y:y+state.camera.y}; }
function screenFromWorld(x,y){ return {x:x-state.camera.x, y:y-state.camera.y}; }
function clearSelection(){ for (const u of state.units) u.selected=false; }
function selectedUnits(){ return state.units.filter(u=>u.selected && u.alive && u.team===PLAYER); }

function selectAtPoint(wx,wy,additive=false){
  let hit=null;
  for (let i=state.units.length-1;i>=0;i--){
    const u=state.units[i];
    if (u.team!==PLAYER || !u.alive) continue;
    const rr=u.r+4;
    if (dist2({x:wx,y:wy}, u) <= rr*rr){ hit=u; break; }
  }
  if (!additive) clearSelection();
  if (hit) hit.selected = !additive || !hit.selected;
  refreshSelectionUI();
  return hit;
}
function selectRect(wx1,wy1,wx2,wy2,additive=false){
  const x1=Math.min(wx1,wx2), x2=Math.max(wx1,wx2), y1=Math.min(wy1,wy2), y2=Math.max(wy1,wy2);
  if (!additive) clearSelection();
  for (const u of state.units){
    if (u.team!==PLAYER || !u.alive) continue;
    if (u.x>=x1 && u.x<=x2 && u.y>=y1 && u.y<=y2) u.selected=true;
  }
  refreshSelectionUI();
}

/* ===========================
   Commands
   =========================== */
function commandMove(units,wx,wy){
  state.forceMode=false; state.blinkMode=false;
  for (const u of units){ u.order={type:"move", x:wx, y:wy}; u.target=null; }
}
function commandAttackNearest(units){
  state.forceMode=false; state.blinkMode=false;
  for (const u of units){
    const t=nearestEnemyInAggro(u);
    if (t){ u.order={type:"attack", targetId:t.id}; u.target=t; }
  }
}

/* ===========================
   AI & Combat
   =========================== */
function nearestEnemyInAggro(u){
  let best=null, bestD2=Infinity;
  for (const e of state.units){
    if (!e.alive || e.team===u.team) continue;
    const d2=dist2(u,e);
    if (d2 < bestD2 && d2 <= u.aggro*u.aggro){ best=e; bestD2=d2; }
  }
  return best;
}
function nearestOpposite(u){
  let best=null, bestD2=Infinity;
  for (const v of state.units){
    if (!v.alive || v.team===u.team) continue;
    const d2=dist2(u,v);
    if (d2 < bestD2){ best=v; bestD2=d2; }
  }
  return best;
}
function isEnemyInRange(u,e){ const r=u.range + (e.r||0); return dist2(u,e) <= r*r; }

function applySplash(x,y,radius,dmg,sourceTeam,sourceKind=null){
  state.splashes.push({x,y,r:radius,t:performance.now(),dur:260});
  for (const u of state.units){
    if (!u.alive) continue;
    if (sourceKind==="bling" && u.kind==="bling") continue;
    if (dist2(u,{x,y}) <= radius*radius){
      u.hp -= dmg;
      if (u.hp <= 0) killUnit(u, sourceTeam);
    }
  }
}
function killUnit(u,killerTeam){
  if (!u.alive) return;
  u.alive=false;
  if (u.kind===UNIT_TYPES.BLING && u.explode){
    applySplash(u.x,u.y, u.explode.radius, u.explode.dmg, killerTeam, "bling");
  }
}

/* ===========================
   Physics (solid fields + seam block)
   =========================== */
function steerAndCollide(dt){
  const sepStrength=1400, damp=0.86, accMul=8.0;

  // prune expired fields
  for (let i=state.fields.length-1;i>=0;i--){
    const f=state.fields[i];
    if (performance.now() - f.born > f.dur) state.fields.splice(i,1);
  }

  for (let i=0;i<state.units.length;i++){
    const a=state.units[i]; if (!a.alive) continue;

    let ax=0, ay=0; const baseSpeed=a.speed;

    if (a.order && a.order.type==="move"){
      const dx=a.order.x - a.x, dy=a.order.y - a.y, d=Math.hypot(dx,dy);
      if (d>6){ ax += (dx/(d||1))*baseSpeed; ay += (dy/(d||1))*baseSpeed; }
      else { a.order=null; a.vx*=0.6; a.vy*=0.6; }
    } else if (a.target && a.target.alive){
      const inRange=isEnemyInRange(a, a.target);
      if (!inRange){ const dx=a.target.x - a.x, dy=a.target.y - a.y, d=Math.hypot(dx,dy)||1; ax += (dx/d)*baseSpeed; ay += (dy/d)*baseSpeed; }
      else { a.vx*=0.7; a.vy*=0.7; }
    } else if (a.team===ENEMY){
      const t=nearestOpposite(a);
      if (t){ const dx=t.x - a.x, dy=t.y - a.y, d=Math.hypot(dx,dy)||1; if (a.melee || d>(a.range*0.85)){ ax+=(dx/d)*baseSpeed; ay+=(dy/d)*baseSpeed; } else { a.vx*=0.92; a.vy*=0.92; } }
      else { a.vx*=0.96; a.vy*=0.96; }
    } else {
      const e=nearestEnemyInAggro(a);
      if (e){ const inRange=isEnemyInRange(a,e); a.target=e; if (!inRange){ const dx=e.x-a.x, dy=e.y-a.y, d=Math.hypot(dx,dy)||1; ax+=(dx/d)*baseSpeed; ay+=(dy/d)*baseSpeed; } else { a.vx*=0.8; a.vy*=0.8; } }
      else { a.vx*=0.95; a.vy*=0.95; }
    }

    // Separation
    for (let j=i+1;j<state.units.length;j++){
      const b=state.units[j]; if (!b.alive) continue;
      const dx=b.x-a.x, dy=b.y-a.y, d2=dx*dx+dy*dy, minDist=a.r+b.r+2;
      if (d2>0 && d2 < minDist*minDist){
        const d=Math.sqrt(d2), overlap=(minDist-d), ux=(dx/(d||1)), uy=(dy/(d||1)), push=(overlap*sepStrength)*dt/1000;
        a.vx -= ux*push; a.vy -= uy*push; b.vx += ux*push; b.vy += uy*push;
      }
    }

    // Solid forcefield repulsion
    for (const f of state.fields){
      const dx=a.x - f.x, dy=a.y - f.y, d=Math.hypot(dx,dy), rr=f.r + a.r + 4;
      if (d < rr && d>0){
        const repel=(1 - (d/rr)), push=FORCEFIELD.push * repel * (dt/1000);
        a.vx += (dx/d)*push; a.vy += (dy/d)*push;
      }
    }

    // Seam blocking between touching fields
    for (let fi=0; fi<state.fields.length; fi++){
      for (let fj=fi+1; fj<state.fields.length; fj++){
        const f1=state.fields[fi], f2=state.fields[fj];
        const abx=f2.x - f1.x, aby=f2.y - f1.y, L=Math.hypot(abx,aby);
        if (L <= 0.0001) continue;
        const R=f1.r + a.r + 2, S=f2.r + a.r + 2;
        if (L <= R + S){
          const t = ((a.x - f1.x)*abx + (a.y - f1.y)*aby)/(L*L);
          if (t>0 && t<1){
            const px=f1.x + t*abx, py=f1.y + t*aby;
            const dx=a.x - px, dy=a.y - py, dist=Math.hypot(dx,dy);
            const thresh = a.r + 2;
            if (dist < thresh){
              const pen=(thresh - dist);
              const dirx=(dist>0? dx/dist : -aby/L), diry=(dist>0? dy/dist : abx/L);
              const push=(FORCEFIELD.push*1.6)*(pen/thresh)*(dt/1000);
              a.vx += dirx*push; a.vy += diry*push;
              a.x += dirx*(pen*0.35); a.y += diry*(pen*0.35);
            }
          }
        }
      }
    }

    // Integrate
    a.vx += (ax - a.vx)*(accMul*dt/1000); a.vy += (ay - a.vy)*(accMul*dt/1000);
    a.vx *= damp; a.vy *= damp;
    const maxSpd=baseSpeed*1.1, spd=Math.hypot(a.vx,a.vy);
    if (spd>maxSpd){ a.vx=a.vx/spd*maxSpd; a.vy=a.vy/spd*maxSpd; }
    a.x=clamp(a.x + a.vx*dt/1000, a.r, MAP_W - a.r);
    a.y=clamp(a.y + a.vy*dt/1000, a.r, MAP_H - a.r);
  }
}

function combatAndAbilities(dt){
  const now=performance.now();

  for (const u of state.units){
    if (!u.alive) continue;
    u.cd=Math.max(0, u.cd - dt);

    // target upkeep
    if (u.team===PLAYER){
      if (!u.target || !u.target.alive){ const e=nearestEnemyInAggro(u); if (e) u.target=e; }
    } else { u.target=nearestOpposite(u); }

    if (u.melee){
      if (u.target && u.target.alive && isEnemyInRange(u,u.target) && u.cd<=0){
        u.target.hp -= u.dmg; u.cd = 1000/u.fireRate;
        if (u.kind===UNIT_TYPES.BRUTE && u.cleave){ applySplash(u.target.x, u.target.y, u.cleave.radius, u.cleave.dmg, u.team); }
        if (u.target.hp<=0) killUnit(u.target, u.team);
        if (u.kind===UNIT_TYPES.BLING && u.explode){ killUnit(u, u.team); }
      }
    } else if (u.kind===UNIT_TYPES.SENTRY){
      const tgt=(u.target && u.target.alive && isEnemyInRange(u,u.target)) ? u.target : null;
      u.beamTickCd -= dt;
      if (tgt && u.beamTickCd<=0){
        tgt.hp -= 1;
        if (tgt.hp<=0) killUnit(tgt, u.team);
        u.beamTickCd = 1000/UNIT_STATS.sentry.beam.rate;
      }
    } else {
      // generic ranged (Blinker, Sting)
      const moving=Math.hypot(u.vx,u.vy)>28;
      const tgt=u.target && u.target.alive ? u.target : null;
      if (tgt && isEnemyInRange(u,tgt) && u.cd<=0 && !moving){
        fireProjectile(u, tgt); u.cd = 1000/u.fireRate;
      }
    }
  }

  // projectiles
  for (let i=state.projs.length-1;i>=0;i--){
    const p=state.projs[i]; p.life -= dt; if (p.life<=0){ state.projs.splice(i,1); continue; }
    p.x += p.vx*dt/1000; p.y += p.vy*dt/1000;
    for (const u of state.units){
      if (!u.alive || u.team===p.team) continue;
      const rr=u.r+4;
      if (dist2(p,u) <= rr*rr){
        u.hp -= p.dmg; if (u.hp<=0) killUnit(u, p.team);
        state.projs.splice(i,1); break;
      }
    }
  }

  // HUD + gated waves
  const anyPlayers=state.units.some(u=>u.alive && u.team===PLAYER);
  const anyEnemies=state.units.some(u=>u.alive && u.team===ENEMY);
  enemyCountEl.textContent = state.units.filter(u=>u.team===ENEMY && u.alive).length;
  armyCountEl.textContent  = "("+state.units.filter(u=>u.team===PLAYER && u.alive).length+")";

  if (!anyPlayers && !state.gameOver){
    state.gameOver=true; finalLevelEl.textContent=state.level; over.style.display="flex";
  }
  if (!anyEnemies && anyPlayers && !state.gameOver){
    if (!state._spawnNextWaveAt) state._spawnNextWaveAt = now + 1000;
  }
  if (state._spawnNextWaveAt && now >= state._spawnNextWaveAt){
    state._spawnNextWaveAt=null; state.level+=1; spawnWave(state.level);
  }
}

function fireProjectile(shooter,target){
  if (!target || !target.alive) return;
  const ang=Math.atan2(target.y - shooter.y, target.x - shooter.x), spd=shooter.projSpeed||480;
  state.projs.push({ id:Math.random().toString(36).slice(2), team:shooter.team, fromKind:shooter.kind,
    x:shooter.x, y:shooter.y, vx:Math.cos(ang)*spd, vy:Math.sin(ang)*spd, dmg:shooter.dmg, life:2000 });
}

/* ===========================
   Camera
   =========================== */
function updateCamera(dt){
  if (!state.mouse.overCanvas) return;
  const mx=state.mouse.x, my=state.mouse.y; let vx=0, vy=0;
  if (mx < VIEWPAD) vx=-EDGE_SCROLL; else if (mx > canvas.width - VIEWPAD) vx=EDGE_SCROLL;
  if (my < VIEWPAD) vy=-EDGE_SCROLL; else if (my > canvas.height - VIEWPAD) vy=EDGE_SCROLL;
  const fx = mx < VIEWPAD ? (1 - mx/VIEWPAD) : (mx > canvas.width - VIEWPAD ? (mx - (canvas.width - VIEWPAD))/VIEWPAD : 0);
  const fy = my < VIEWPAD ? (1 - my/VIEWPAD) : (my > canvas.height - VIEWPAD ? (my - (canvas.height - VIEWPAD))/VIEWPAD : 0);
  state.camera.x = clamp(state.camera.x + vx*fx*dt/1000, 0, MAP_W - canvas.width);
  state.camera.y = clamp(state.camera.y + vy*fy*dt/1000, 0, MAP_H - canvas.height);
}

/* ===========================
   Rendering
   =========================== */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Grid
  ctx.save(); ctx.translate(-state.camera.x,-state.camera.y);
  ctx.lineWidth=1; ctx.strokeStyle="#151a22";
  for (let x=0;x<=MAP_W;x+=GRID){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,MAP_H); ctx.stroke(); }
  for (let y=0;y<=MAP_H;y+=GRID){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(MAP_W,y); ctx.stroke(); }
  ctx.restore();

  // Forcefields
  for (const f of state.fields){
    const sc=screenFromWorld(f.x,f.y);
    ctx.beginPath(); ctx.arc(sc.x, sc.y, f.r, 0, TWO_PI);
    ctx.fillStyle=COLORS.fieldFill; ctx.fill();
    ctx.lineWidth=3; ctx.strokeStyle=COLORS.fieldStroke; ctx.stroke();
  }

  // Splashes
  const now=performance.now();
  for (let i=state.splashes.length-1;i>=0;i--){
    const s=state.splashes[i], t=(now - s.t)/s.dur;
    if (t>=1){ state.splashes.splice(i,1); continue; }
    const alpha=1-t, sr=s.r*(0.9+0.2*t), sc=screenFromWorld(s.x,s.y);
    ctx.beginPath(); ctx.arc(sc.x, sc.y, sr, 0, TWO_PI);
    ctx.fillStyle=`rgba(51,255,136,${0.18*alpha})`; ctx.fill();
    ctx.lineWidth=2; ctx.strokeStyle=`rgba(51,255,136,${0.7*alpha})`; ctx.stroke();
  }

  // Projectiles
  for (const p of state.projs){
    const sc=screenFromWorld(p.x,p.y);
    if (p.fromKind===UNIT_TYPES.BLINKER){ ctx.fillStyle=COLORS.blueBolt; }
    else { ctx.fillStyle=COLORS.stingBolt; }
    ctx.beginPath(); ctx.arc(sc.x, sc.y, 3, 0, TWO_PI); ctx.fill();
  }

  // Units
  ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.font="20px system-ui, emoji";
  for (const u of state.units){
    if (!u.alive) continue;
    const sc=screenFromWorld(u.x,u.y);

    if (u.selected){
      ctx.beginPath(); ctx.arc(sc.x, sc.y, u.r+6, 0, TWO_PI);
      ctx.strokeStyle=COLORS.selStroke; ctx.lineWidth=2; ctx.stroke();
    }

    ctx.beginPath(); ctx.arc(sc.x, sc.y, u.r+2, 0, TWO_PI);
    ctx.strokeStyle = u.team===PLAYER ? COLORS.ringSelf : COLORS.ringEnemy; ctx.lineWidth=4; ctx.stroke();
    ctx.fillText(UNIT_STATS[u.kind].emoji, sc.x, sc.y + 1);

    // HP bar
    const w=Math.max(28, u.r*3), h=5, pct=clamp(u.hp/u.maxHp,0,1);
    ctx.fillStyle="#000000aa"; ctx.fillRect(sc.x - w/2, sc.y - u.r - 16, w, h);
    ctx.fillStyle = pct>0.5 ? COLORS.hpGood : COLORS.hpBad;
    ctx.fillRect(sc.x - w/2, sc.y - u.r - 16, w*pct, h);
    ctx.strokeStyle="#00000055"; ctx.lineWidth=1; ctx.strokeRect(sc.x - w/2, sc.y - u.r - 16, w, h);

    // Cooldowns
    if (u.kind===UNIT_TYPES.SENTRY && u.buffs.ffCdUntil>now){
      const rem=(u.buffs.ffCdUntil - now)/1000; drawCooldownDot(sc.x + w/2 + 6, sc.y - u.r - 13, rem, "#4da3ff");
    }
    if (u.kind===UNIT_TYPES.BLINKER && u.buffs.blinkCdUntil>now){
      const rem=(u.buffs.blinkCdUntil - now)/1000; drawCooldownDot(sc.x + w/2 + 6, sc.y - u.r - 13, rem, "#79aaff");
    }
  }

  // Sentry beams (on top)
  ctx.lineWidth=2.5;
  for (const u of state.units){
    if (!u.alive || u.kind!==UNIT_TYPES.SENTRY) continue;
    const tgt=(u.target && u.target.alive && isEnemyInRange(u,u.target))? u.target : null;
    if (!tgt) continue;
    const s=screenFromWorld(u.x,u.y), e=screenFromWorld(tgt.x,tgt.y);
    ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y);
    ctx.strokeStyle=COLORS.beam; ctx.stroke();
    ctx.lineWidth=1.2; ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y);
    ctx.strokeStyle=COLORS.beamCore; ctx.stroke();
    ctx.lineWidth=2.5;
  }

  // Pickups
  for (const p of state.pickups){
    const sc=screenFromWorld(p.x,p.y);
    const pulse=0.6 + 0.4*Math.sin((performance.now()+p.wobble*1000)/300);
    ctx.beginPath(); ctx.arc(sc.x, sc.y, p.r+6, 0, TWO_PI);
    ctx.strokeStyle=`rgba(255,209,102,${0.45*pulse})`; ctx.lineWidth=3; ctx.stroke();
    ctx.font="22px system-ui, emoji"; ctx.fillText("üéÅ", sc.x, sc.y+1);
  }

  // Selection box
  if (state.dragging && state.dragStart && state.dragEnd){
    const s=screenFromWorld(state.dragStart.x,state.dragStart.y);
    const e=screenFromWorld(state.dragEnd.x,state.dragEnd.y);
    const x=Math.min(s.x,e.x), y=Math.min(s.y,e.y), w=Math.abs(s.x-e.x), h=Math.abs(s.y-e.y);
    ctx.fillStyle=COLORS.selBox; ctx.fillRect(x,y,w,h);
    ctx.strokeStyle=COLORS.selStroke; ctx.lineWidth=2; ctx.strokeRect(x,y,w,h);
  }
}
function drawCooldownDot(x,y,secs,color="#a3b1c3"){
  const r=6; ctx.beginPath(); ctx.arc(x,y,r,0,TWO_PI); ctx.fillStyle="#000a"; ctx.fill();
  ctx.beginPath(); ctx.arc(x,y,r-1,0,TWO_PI); ctx.fillStyle=color; ctx.fill();
  ctx.fillStyle="#000"; ctx.font="10px ui-monospace, monospace"; ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.fillText(Math.ceil(secs), x, y);
}

/* ===========================
   UI Refresh
   =========================== */
function refreshSelectionUI(){
  const sel=selectedUnits(); selCountEl.textContent=sel.length;
  const nS = sel.filter(u=>u.kind===UNIT_TYPES.SENTRY).length;
  const nB = sel.filter(u=>u.kind===UNIT_TYPES.BLINKER).length;
  const nG = sel.filter(u=>u.kind===UNIT_TYPES.GUARDIAN).length;
  selBreakdownEl.textContent = sel.length ? `üì° ${nS}  ¬∑  üî∑ ${nB}  ¬∑  üõ°Ô∏è ${nG}` : "‚Äî";
  selListEl.innerHTML="";
  for (const u of sel.slice(0,80)){
    const row=document.createElement("div"); row.className="row";
    row.innerHTML = `<div>${UNIT_STATS[u.kind].emoji} <span class="small">${u.kind}</span></div>
                     <div class="small">${Math.ceil(u.hp)}/${u.maxHp}</div>`;
    selListEl.appendChild(row);
  }
  attackBtn.disabled = sel.length===0;
}
function updateArmyHud(){
  const player=state.units.filter(u=>u.team===PLAYER && u.alive);
  const kinds=Array.from(new Set(player.map(u=>u.kind)));
  const label = kinds.length ? kinds.map(k=>PLURAL_LABEL[k]||k).join(" + ") : "‚Äî";
  armyTypeEl.textContent = label;
  armyCountEl.textContent = "("+player.length+")";
}

/* ===========================
   Input
   =========================== */
canvas.addEventListener("contextmenu", (e)=>e.preventDefault());
canvas.addEventListener("mouseenter", ()=> state.mouse.overCanvas=true);
canvas.addEventListener("mouseleave", ()=> state.mouse.overCanvas=false);
canvas.addEventListener("mousemove", (e)=>{
  const rect=canvas.getBoundingClientRect();
  state.mouse.x=e.clientX - rect.left; state.mouse.y=e.clientY - rect.top;
  const w=worldFromScreen(state.mouse.x, state.mouse.y); state.mouse.worldX=w.x; state.mouse.worldY=w.y;
  if (state.dragging) state.dragEnd={ x:w.x, y:w.y };
});
canvas.addEventListener("mousedown", (e)=>{
  const w=worldFromScreen(e.offsetX, e.offsetY);
  if (e.button===0){
    if (state.forceMode){ placeForcefield(w.x, w.y); state.forceMode=false; return; }
    if (state.blinkMode){
      const sels=selectedUnits().filter(u=>u.kind===UNIT_TYPES.BLINKER);
      if (sels.length) tryBlink(sels, w.x, w.y);
      state.blinkMode=false; return;
    }
    state.dragging=true; state.dragStart={x:w.x,y:w.y}; state.dragEnd={x:w.x,y:w.y};
  } else if (e.button===2){
    const sel=selectedUnits(); if (!sel.length) return;
    commandMove(sel, w.x, w.y);
  }
});
canvas.addEventListener("dblclick", (e)=>{
  const rect = canvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
  const w = worldFromScreen(sx, sy);

  const u = getUnitAt(w.x, w.y);
  if (u){
    const additive = !!state.keys["ShiftLeft"] || !!state.keys["ShiftRight"];
    selectAllOfKind(u.kind, additive);
  }
  e.preventDefault();
});

window.addEventListener("mouseup", (e)=>{
  if (!state.dragging) return;
  const additive=!!state.keys["ShiftLeft"] || !!state.keys["ShiftRight"];
  if (!state.dragStart || !state.dragEnd) return;
  const dx=Math.abs(state.dragEnd.x - state.dragStart.x), dy=Math.abs(state.dragEnd.y - state.dragStart.y);
  if (dx<6 && dy<6) selectAtPoint(state.dragEnd.x, state.dragEnd.y, additive);
  else selectRect(state.dragStart.x, state.dragStart.y, state.dragEnd.x, state.dragEnd.y, additive);
  state.dragging=false; state.dragStart=state.dragEnd=null;
});
window.addEventListener("keydown", (e)=>{
  state.keys[e.code]=true;
  if (e.code==="KeyA"){ const sel=selectedUnits(); if (sel.length) commandAttackNearest(sel); e.preventDefault(); }
  else if (e.code==="KeyF"){
    const now=performance.now();
    const ready=selectedUnits().some(u=>u.kind===UNIT_TYPES.SENTRY && now>=u.buffs.ffCdUntil);
    if (ready) state.forceMode=true;
  } else if (e.code==="KeyB"){
    if (selectedUnits().some(u=>u.kind===UNIT_TYPES.BLINKER)) state.blinkMode=true;
  } else if (e.code==="Escape"){
    state.forceMode=false; state.blinkMode=false;
  }
});
window.addEventListener("keyup", (e)=> state.keys[e.code]=false);

forceBtn.addEventListener("click", ()=>{
  const now=performance.now();
  if (selectedUnits().some(u=>u.kind===UNIT_TYPES.SENTRY && now>=u.buffs.ffCdUntil)) state.forceMode=true;
});
blinkBtn.addEventListener("click", ()=>{
  if (selectedUnits().some(u=>u.kind===UNIT_TYPES.BLINKER)) state.blinkMode=true;
});
attackBtn.addEventListener("click", ()=> commandAttackNearest(selectedUnits()));
clearSelBtn.addEventListener("click", ()=>{ clearSelection(); refreshSelectionUI(); });

saveScoreBtn.addEventListener("click", ()=>{
  const name=(playerNameEl.value||"").trim().slice(0,40);
  if (!name){ saveMsgEl.textContent="Please enter a name."; return; }
  if (!fbDb){ saveMsgEl.textContent="Firebase not initialized."; return; }
  const entry={ game:"Micro Wars ‚Äî Guardians", name, level:state.level, ts:Date.now() };
  fbDb.ref("Flag").push(entry).then(()=> saveMsgEl.textContent="Saved! üéâ").catch(err=> saveMsgEl.textContent="Error: "+err.message);
});

/* ===========================
   Main Loop
   =========================== */
let last=nowMS(), fpsS=nowMS(), frames=0;
function tick(){
  const t=nowMS(); let dt=t - last; if (dt>60) dt=60; last=t;

  if (!state.gameOver){
    if (t >= state.nextPickupAt){ spawnPickup(); state.nextPickupAt = t + rand(PICKUP_INTERVAL_RANGE[0], PICKUP_INTERVAL_RANGE[1]); }
    for (let i=state.pickups.length-1;i>=0;i--){ const p=state.pickups[i]; if (t - p.born > p.life) state.pickups.splice(i,1); }
    checkPickupCollisions();

    steerAndCollide(dt);
    combatAndAbilities(dt);
    updateCamera(dt);
  }

  draw();
  refreshSelectionUI(); updateArmyHud();
  canvas.style.cursor = (state.forceMode || state.blinkMode) ? "crosshair" : "default";

  frames++; if (t - fpsS >= 500){ fpsEl.textContent=Math.round(frames * 1000/(t - fpsS)); fpsS=t; frames=0; }
  requestAnimationFrame(tick);
}

/* ===========================
   Start
   =========================== */
function init(){
  resize();
  spawnInitialArmy();
  state.level=1; levelNum.textContent=1;
  state.nextPickupAt = performance.now() + rand(4000,8000);
  state.camera.x = MAP_W/2 - canvas.width/2;
  state.camera.y = MAP_H/2 - canvas.height/2;
  setTimeout(()=> spawnWave(state.level), 1200);
  requestAnimationFrame(tick);
}
init();
</script>
</body>
</html>













