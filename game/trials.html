<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>üî• Gun Arena ‚Äî Roguelite</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <style>
    :root{
      --bg:#020617;
      --panel:#020617;
      --ink:#e5e7eb;
      --muted:#9ca3af;
      --accent:#22c55e;
      --accent-soft:#064e3b;
      --bad:#ef4444;
      --epic:#a855f7;
      --rare:#3b82f6;
      --common:#6b7280;
      --legend:#f97316;
      --radius:12px;
      --shadow:0 14px 40px rgba(15,23,42,.7);
    }
    *{box-sizing:border-box;}
    html,body{
      margin:0;
      padding:0;
      height:100%;
      overflow:hidden;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      background:radial-gradient(circle at top,#020617,#000);
      color:var(--ink);
      touch-action:none;
      -webkit-user-select:none;
      user-select:none;
    }
    #root{
      position:relative;
      width:100%;
      height:100%;
      display:flex;
      flex-direction:column;
    }
    header{
      height:44px;
      padding:4px 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      background:linear-gradient(to right,#020617,#0b1120);
      border-bottom:1px solid #111827;
      z-index:20;
    }
    header .left, header .right{
      display:flex;
      align-items:center;
      gap:10px;
      font-size:13px;
      color:var(--muted);
    }
    .pill{
      padding:4px 10px;
      border-radius:999px;
      background:#020617;
      border:1px solid #1f2937;
      font-size:12px;
      display:flex;
      align-items:center;
      gap:6px;
    }
    .pill span.value{
      color:var(--ink);
      font-weight:600;
    }
    #fullscreenBtn{
      border:none;
      outline:none;
      border-radius:999px;
      padding:4px 8px;
      font-size:16px;
      background:#020617;
      color:var(--muted);
      border:1px solid #1f2937;
      cursor:pointer;
    }
    #fullscreenBtn:hover{
      background:#111827;
    }

    #gameContainer{
      position:relative;
      flex:1;
      background:#020617;
      overflow:hidden;
    }
    #gameCanvas{
      width:100%;
      height:100%;
      display:block;
      background:radial-gradient(circle at center,#020617,#000);
    }

    /* Virtual joysticks */
    .joystick{
      position:absolute;
      bottom:24px;
      width:140px;
      height:140px;
      border-radius:999px;
      background:radial-gradient(circle at center,rgba(15,23,42,.92),rgba(15,23,42,.7));
      border:1px solid #1f2937;
      box-shadow:0 12px 40px rgba(0,0,0,.8);
      touch-action:none;
    }
    #leftStick{ left:16px; }
    #rightStick{ right:16px; }

    .stick-inner{
      position:absolute;
      left:50%;
      top:50%;
      width:60px;
      height:60px;
      margin:-30px 0 0 -30px;
      border-radius:999px;
      background:radial-gradient(circle at 30% 30%,#0ea5e9,#1d4ed8);
      box-shadow:0 8px 25px rgba(15,23,42,.9);
      transition:transform .05s linear;
    }

    /* Overlay */
    .overlay{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      background:radial-gradient(circle at top,rgba(15,23,42,.96),rgba(3,7,18,.98));
      z-index:30;
    }
    .overlay.hidden{ display:none; }

    .overlay-card{
      width:min(900px,95vw);
      max-height:90vh;
      background:linear-gradient(145deg,#020617,#020617,#020617);
      border-radius:18px;
      border:1px solid #1e293b;
      box-shadow:var(--shadow);
      padding:16px 18px 18px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .overlay-header{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:10px;
      font-size:14px;
    }
    .overlay-header h2{
      margin:0;
      font-size:18px;
    }
    .overlay-header p{
      margin:2px 0 0;
      color:var(--muted);
      font-size:13px;
    }
    .overlay-body{
      display:flex;
      gap:14px;
      margin-top:6px;
      flex-wrap:wrap;
    }
    .leaderboard{
      flex:1.2;
      min-width:260px;
      background:radial-gradient(circle at top,#020617,#020617);
      border-radius:14px;
      border:1px solid #1f2937;
      padding:10px 12px;
      overflow:auto;
      max-height:360px;
      font-size:13px;
    }
    .leaderboard h3{
      margin:0 0 6px;
      font-size:14px;
      color:var(--muted);
    }
    .leaderboard table{
      width:100%;
      border-collapse:collapse;
      font-size:12px;
    }
    .leaderboard th,
    .leaderboard td{
      padding:4px 4px;
      text-align:left;
      border-bottom:1px solid #0f172a;
    }
    .leaderboard tr.highlight{
      background:rgba(34,197,94,.15);
    }
    .leaderboard th{
      color:var(--muted);
      font-weight:500;
      font-size:11px;
    }

    .upgrade-grid{
      flex:1;
      min-width:260px;
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(140px,1fr));
      gap:10px;
    }
    .upgrade-card{
      border-radius:14px;
      border:1px solid #111827;
      background:radial-gradient(circle at top,#020617,#020617);
      padding:10px;
      cursor:pointer;
      display:flex;
      flex-direction:column;
      gap:6px;
      transition:transform .12s ease, box-shadow .12s ease, border-color .12s ease;
    }
    .upgrade-card:hover{
      transform:translateY(-3px);
      box-shadow:0 16px 45px rgba(15,23,42,.95);
    }
    .upgrade-title{
      font-size:13px;
      font-weight:600;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:6px;
    }
    .rarity-pill{
      font-size:10px;
      padding:2px 6px;
      border-radius:999px;
      border:1px solid;
      text-transform:uppercase;
      letter-spacing:.03em;
    }
    .rarity-common{ color:#9ca3af; border-color:#4b5563; }
    .rarity-rare{ color:#60a5fa; border-color:#1d4ed8; }
    .rarity-epic{ color:#e879f9; border-color:#a855f7;}
    .rarity-legend{ color:#fdba74; border-color:#f97316;}
    .upgrade-desc{
      font-size:12px;
      color:var(--muted);
    }

    .overlay-footer{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-top:6px;
      font-size:12px;
      color:var(--muted);
    }

    .badge{
      display:inline-flex;
      align-items:center;
      gap:4px;
      padding:3px 8px;
      border-radius:999px;
      background:#020617;
      border:1px solid #1f2937;
      font-size:11px;
    }

    /* Small mobile tweaks */
    @media (max-width:720px){
      header{height:40px; padding:2px 6px;}
      .pill{padding:2px 8px; font-size:11px;}
      #leftStick,#rightStick{
        width:120px;
        height:120px;
        bottom:16px;
      }
      .stick-inner{
        width:54px;
        height:54px;
        margin:-27px 0 0 -27px;
      }
      .overlay-card{
        padding:10px 10px 12px;
      }
      .overlay-header h2{
        font-size:16px;
      }
      .leaderboard{max-height:230px;}
    }

    .restart-button{
      width:100%;
      padding:10px;
      border-radius:12px;
      border:1px solid #1f2937;
      background:linear-gradient(to right,#0f172a,#111827);
      color:#e5e7eb;
      font-size:14px;
      font-weight:600;
      cursor:pointer;
      text-align:center;
    }
    .restart-button:hover{
      background:linear-gradient(to right,#111827,#1f2937);
    }
  </style>
</head>
<body>
<div id="root">
  <header>
    <div class="left">
      <div class="pill">Lvl <span id="levelDisplay" class="value">1</span></div>
      <div class="pill">HP <span id="hpDisplay" class="value">100 / 100</span></div>
      <div class="pill">Kills <span id="scoreDisplay" class="value">0</span></div>
      <div class="pill">Round <span id="roundDisplay" class="value">1</span></div>
    </div>
    <div class="right">
      <div class="pill">
        Name
        <span id="nameDisplay" class="value">Player</span>
      </div>
      <button id="fullscreenBtn" title="Toggle fullscreen">‚õ∂</button>
    </div>
  </header>

  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <!-- Joysticks -->
    <div id="leftStick" class="joystick">
      <div class="stick-inner"></div>
    </div>
    <div id="rightStick" class="joystick">
      <div class="stick-inner"></div>
    </div>

    <!-- Round end + Upgrades + Leaderboard -->
    <div id="roundOverlay" class="overlay hidden">
      <div class="overlay-card">
        <div class="overlay-header">
          <div>
            <h2 id="overlayTitle">Round Complete</h2>
            <p id="overlaySubtitle">
              Choose one upgrade and see how your run ranks among all players.
            </p>
          </div>
          <div class="badge">
            <span>Best Run</span>
            <strong id="bestRunBadge">‚Äì</strong>
          </div>
        </div>
        <div class="overlay-body">
          <div class="leaderboard">
            <h3>üèÜ All-Time Highscores</h3>
            <div id="leaderboardStatus" style="font-size:12px;color:var(--muted);margin-bottom:4px;">
              Loading leaderboard...
            </div>
            <table id="leaderboardTable">
              <thead>
              <tr>
                <th>#</th>
                <th>Name</th>
                <th>Lvl</th>
                <th>Kills</th>
              </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
          <div class="upgrade-grid" id="upgradeGrid">
            <!-- Upgrade cards / restart button injected here -->
          </div>
        </div>
        <div class="overlay-footer">
          <div id="overlayFooterHint">
            <span style="color:var(--legend);font-weight:600;">Legendary</span> cards are very rare and only appear in late game.
          </div>
          <div id="runPlacement">
            <!-- Filled with "You placed #X of Y" -->
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Firebase (same project as your other games) -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>

<script>
  // üî• Using your existing config
  const firebaseConfig = {
    apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
    authDomain: "bible-game-246c0.firebaseapp.com",
    databaseURL: "https://bible-game-246c0-default-rtdb.firebaseio.com",
    projectId: "bible-game-246c0",
    storageBucket: "bible-game-246c0.firebasestorage.app",
    messagingSenderId: "959619818996",
    appId: "1:959619818996:web:5a9fbf492e23c765e445a1",
    measurementId: "G-8PR6LVKSH3"
  };
  let db = null;
  let scoresRef = null;
  try{
    if(firebaseConfig && firebaseConfig.projectId){
      firebase.initializeApp(firebaseConfig);
      db = firebase.firestore();
      scoresRef = db.collection("gunArenaScores");
    }
  }catch(e){
    console.warn("Firebase init failed:", e);
  }
</script>

<script>
(function(){
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const container = document.getElementById("gameContainer");
  const roundOverlay = document.getElementById("roundOverlay");
  const upgradeGrid = document.getElementById("upgradeGrid");
  const leaderboardTableBody = document.querySelector("#leaderboardTable tbody");
  const leaderboardStatus = document.getElementById("leaderboardStatus");
  const overlayTitle = document.getElementById("overlayTitle");
  const overlaySubtitle = document.getElementById("overlaySubtitle");
  const runPlacement = document.getElementById("runPlacement");
  const bestRunBadge = document.getElementById("bestRunBadge");
  const overlayFooterHint = document.getElementById("overlayFooterHint");

  const levelDisplay = document.getElementById("levelDisplay");
  const hpDisplay = document.getElementById("hpDisplay");
  const scoreDisplay = document.getElementById("scoreDisplay");
  const roundDisplay = document.getElementById("roundDisplay");
  const nameDisplay = document.getElementById("nameDisplay");
  const fullscreenBtn = document.getElementById("fullscreenBtn");

  let playerName = localStorage.getItem("gunArenaPlayerName") || null;
  if(!playerName){
    playerName = prompt("Enter a name for the leaderboard:", "Commander") || "Commander";
    localStorage.setItem("gunArenaPlayerName", playerName);
  }
  nameDisplay.textContent = playerName;

  function resizeCanvas(){
    const rect = container.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
  }
  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  fullscreenBtn.addEventListener("click", ()=>{
    if(!document.fullscreenElement){
      (document.documentElement.requestFullscreen && document.documentElement.requestFullscreen());
    }else{
      (document.exitFullscreen && document.exitFullscreen());
    }
  });

  // Virtual joystick helpers
  const moveInput = {x:0,y:0};
  const shootInput = {x:0,y:0};
  setupJoystick(document.getElementById("leftStick"), moveInput);
  setupJoystick(document.getElementById("rightStick"), shootInput);

  function setupJoystick(el, target){
    const knob = el.querySelector(".stick-inner");
    let active = false;
    let rect = null;

    function updatePos(clientX, clientY){
      if(!rect) rect = el.getBoundingClientRect();
      const cx = rect.left + rect.width/2;
      const cy = rect.top + rect.height/2;
      let dx = clientX - cx;
      let dy = clientY - cy;
      const max = rect.width*0.4;
      const dist = Math.hypot(dx,dy);
      if(dist > 0){
        const k = Math.min(dist, max) / dist;
        dx *= k;
        dy *= k;
        target.x = dx/max;
        target.y = dy/max;
        knob.style.transform = `translate(${dx}px,${dy}px)`;
      }else{
        target.x = 0;
        target.y = 0;
        knob.style.transform = "translate(0,0)";
      }
    }

    function reset(){
      active = false;
      rect = null;
      target.x = 0;
      target.y = 0;
      knob.style.transform = "translate(0,0)";
    }

    el.addEventListener("pointerdown",(e)=>{
      active = true;
      rect = el.getBoundingClientRect();
      el.setPointerCapture(e.pointerId);
      updatePos(e.clientX,e.clientY);
    });
    el.addEventListener("pointermove",(e)=>{
      if(!active) return;
      updatePos(e.clientX,e.clientY);
    });
    el.addEventListener("pointerup",(e)=>{
      reset();
      el.releasePointerCapture(e.pointerId);
    });
    el.addEventListener("pointercancel",reset);
    el.addEventListener("pointerleave",()=>{ if(!active) reset(); });
  }

  // Keyboard fallback
  const keys = {};
  window.addEventListener("keydown",(e)=>{ keys[e.key.toLowerCase()] = true;});
  window.addEventListener("keyup",(e)=>{ keys[e.key.toLowerCase()] = false;});

  // World + game state
  const WORLD_SIZE = 2800;
  const halfWorld = WORLD_SIZE/2;

 const state = {
  level:1,
  round:1,
  kills:0,          // total run kills
  roundKills:0,     // kills this round (for target)
  bestLevel:1,
  bestKills:0,
  inRound:true,
  showOverlay:false,
  lastOutcome:"win", // "win" | "death"
  enemies:[],
  bullets:[],
  enemyBullets:[],
  rockets:[],
  fireZones:[],
  poisonZones:[],
  obstacles:[],
  particles:[],
  time:0,
  enemyScale:1,
  targetKills:12,
  spawnBudget:0,    // how many more enemies can spawn this round
  spawnTimer:0,     // for continuous edge spawns
  enemyTypeCap:1,
  roundEnemyTypes:[0], // üëà NEW: which enemy types are allowed this round
  isBossRound:false,
  isBigBoss:false,
  worldWidth:WORLD_SIZE,
  worldHeight:WORLD_SIZE,
  player:{
    x:0,
    y:0,
    radius:26,
    maxHp:100,
    hp:100,
    speed:240,
    regen:0.4,         // hp per sec
    baseDamage:14,
    fireRate:2.8,      // shots/s
    projectileCount:1,
    projectileSpread:0.18,
    bulletSpeed:560,
    knockback:200,
    explosionRadius:0,
    splinter:0,
    poisonLevel:0,
    freezeLevel:0,
    lightningLevel:0,
    weakenLevel:0,
    clipSize:9,
    ammo:9,
    reloadTime:1.7,
    reloadTimer:0,
    shotCooldown:0,
    dragonShot:false,
    dragonCounter:0,
    dragonLevel:0
  }
};


  function resetPlayerStats(){
    const p = state.player;
    p.x = 0;
    p.y = 0;
    p.radius = 26;
    p.maxHp = 100;
    p.hp = 100;
    p.speed = 240;
    p.regen = 0.4;
    p.baseDamage = 14;
    p.fireRate = 2.8;
    p.projectileCount = 1;
    p.projectileSpread = 0.18;
    p.bulletSpeed = 560;
    p.knockback = 200;
    p.explosionRadius = 0;
    p.splinter = 0;
    p.poisonLevel = 0;
    p.freezeLevel = 0;
    p.lightningLevel = 0;
    p.weakenLevel = 0;
    p.clipSize = 9;
    p.ammo = 9;
    p.reloadTime = 1.7;
    p.reloadTimer = 0;
    p.shotCooldown = 0;
    p.dragonShot = false;
    p.dragonCounter = 0;
    p.dragonLevel = 0;
  }

  function resetWorld(){
    state.worldWidth = WORLD_SIZE;
    state.worldHeight = WORLD_SIZE;
    state.obstacles = [];
    state.enemies = [];
    state.bullets = [];
    state.enemyBullets = [];
    state.rockets = [];
    state.fireZones = [];
    state.poisonZones = [];
    state.particles = [];
    // Random blocks
    const count = 18;
    for(let i=0;i<count;i++){
      const w = 120 + Math.random()*200;
      const h = 120 + Math.random()*200;
      const x = (Math.random()-0.5)*(WORLD_SIZE-600);
      const y = (Math.random()-0.5)*(WORLD_SIZE-600);
      state.obstacles.push({x,y,w,h});
    }
    state.player.x = 0;
    state.player.y = 0;
  }

 function startRound(){
  state.inRound = true;
  state.showOverlay = false;
  roundOverlay.classList.add("hidden");

  // target kills scales slowly with level
  state.targetKills = 10 + state.level * 2;
  state.spawnBudget = state.targetKills;

  // üé≤ NEW: randomly choose which enemy types are allowed this round
  state.roundEnemyTypes = pickRoundEnemyTypes(state.level);

  spawnWave();
  updateHud();
}

function pickRoundEnemyTypes(level){
  // Unlock more enemy types as you go deeper
  // 0..6 are your defined types
  const maxUnlocked = Math.min(6, Math.floor((level - 1) / 3) + 1);
  const pool = [];
  for(let i = 0; i <= maxUnlocked; i++){
    pool.push(i);
  }

  const types = [];
  const minTypes = 1;
  // As you go higher, you can get more mixed waves
  const maxTypes = Math.min(pool.length, 2 + Math.floor(level / 7)); // up to 3‚Äì4 types later
  const targetCount = Math.max(
    minTypes,
    Math.min(maxTypes, 1 + Math.floor(Math.random() * maxTypes))
  );

  while(types.length < targetCount && pool.length){
    const idx = Math.floor(Math.random() * pool.length);
    types.push(pool.splice(idx, 1)[0]);
  }
  return types;
}

function spawnWave(){
  state.enemies.length = 0;
  const level = state.level;
  const isBossRound = level % 5 === 0;
  const isBigBoss = level % 10 === 0;

  const hpScale = 1 + 0.18 * (level - 1);
  state.enemyScale = hpScale;

  const allowedTypes = (state.roundEnemyTypes && state.roundEnemyTypes.length)
    ? state.roundEnemyTypes
    : [0];

  if(isBossRound){
    const bossCount = isBigBoss ? 1 : 2;
    const bossType = allowedTypes[Math.floor(Math.random() * allowedTypes.length)];

    for(let i = 0; i < bossCount; i++){
      const enemy = makeEnemy(bossType, true, isBigBoss);
      placeEnemyOnEdge(enemy);        // ‚úÖ use this
      state.enemies.push(enemy);
    }

    const minions = 4 + Math.floor(level / 2);
    for(let i = 0; i < minions; i++){
      const type = allowedTypes[Math.floor(Math.random() * allowedTypes.length)];
      const e = makeEnemy(type, false, false);
      placeEnemyOnEdge(e);            // ‚úÖ and here
      state.enemies.push(e);
    }
    return;
  }

  let remaining = state.spawnBudget;
  while(remaining > 0){
    const type = allowedTypes[Math.floor(Math.random() * allowedTypes.length)];
    const e = makeEnemy(type, false, false);
    placeEnemyOnEdge(e);              // ‚úÖ and here
    state.enemies.push(e);
    remaining--;
  }
}


  // Spawn at the edges of the arena, not around the player
  function placeEnemyOnEdge(enemy){
    const side = Math.floor(Math.random()*4);
    const margin = 60;
    if(side === 0){
      // left
      enemy.x = -halfWorld + margin;
      enemy.y = (Math.random()-0.5)*(WORLD_SIZE - margin*2);
    }else if(side === 1){
      // right
      enemy.x = halfWorld - margin;
      enemy.y = (Math.random()-0.5)*(WORLD_SIZE - margin*2);
    }else if(side === 2){
      // top
      enemy.y = -halfWorld + margin;
      enemy.x = (Math.random()-0.5)*(WORLD_SIZE - margin*2);
    }else{
      // bottom
      enemy.y = halfWorld - margin;
      enemy.x = (Math.random()-0.5)*(WORLD_SIZE - margin*2);
    }
  }

  // Types:
  // 0 = üêú Ant (fast, splits)
  // 1 = üëª Ghost (teleports, ignores walls)
  // 2 = üê∫ Wolf (dash)
  // 3 = üë∫ Goblin (rockets)
  // 4 = ü™® Golem (splits to mini golems)
  // 5 = üßô‚Äç‚ôÄÔ∏è Witch (poison circles)
  // 6 = ü¶ë Squid (big laser)
  function makeEnemy(type,boss,bigBoss){
    const baseHp    = [30, 60, 80, 70, 180, 90, 100][type] || 60;
    const baseSpeed = [180,120,160,120, 60, 90, 80][type] || 100;
    const baseDmg   = [ 8, 12, 16, 18,  22, 14, 18][type] || 15;

    const lvl = state.level;
    const hpScale = 1 + 0.18*(lvl-1);
    const spdScale= 1 + 0.06*(lvl-1);
    const dmgScale= 1 + 0.12*(lvl-1);

    let hp = baseHp * hpScale;
    let speed = baseSpeed * spdScale;
    let dmg = baseDmg * dmgScale;

    if(boss){
      const healthMult = bigBoss?14:9;
      hp *= healthMult;
      speed *= bigBoss?1.15:1.08;
      dmg *= bigBoss?2.0:1.6;
    }

    const e = {
      id:Math.random().toString(36).slice(2),
      type,
      boss,
      bigBoss,
      x:0,y:0,
      vx:0,vy:0,
      radius: boss?40:26,
      maxHp:hp,
      hp:hp,
      speed,
      damage:dmg,
      behaviorTimer:0,
      slowFactor:1,
      poisonTimer:0,
      poisonDps:0,
      weakenTimer:0,
      lightningCooldown:0,
      // per-type state:
      splitTimer:0,
      teleportTimer:0,
      teleportCooldown:1.5 + Math.random()*2,
      dashState:"chase",
      dashCooldown:1.5 + Math.random()*1.5,
      dashWindup:0,
      dashTime:0,
      dashTargetX:0,
      dashTargetY:0,
      rocketTimer:0,
      small:false,
      castTimer:0,
      laserWindup:0,
      laserFiring:0,
      laserCooldown:1.5 + Math.random()*1.5,
      laserDir:0,
      mixTimer:0
    };

    return e;
  }

  // === Upgrades: scaled splinters, explosions, stackable elementals, upgradeable dragon ===
  const upgrades = [
    // COMMON
    { id:"dmg1", name:"+15% Damage", rarity:"common",
      desc:"+15% bullet damage.",
      apply:p=>{ p.baseDamage*=1.15; }
    },
    { id:"rate1", name:"+20% Fire Rate", rarity:"common",
      desc:"Shoot 20% faster.",
      apply:p=>{ p.fireRate*=1.20; }
    },
    { id:"proj1", name:"+1 Projectile", rarity:"common",
      desc:"Fire +1 projectile per shot.",
      apply:p=>{ p.projectileCount+=1; }
    },
    { id:"speed1", name:"+15% Move Speed", rarity:"common",
      desc:"Move 15% faster.",
      apply:p=>{ p.speed*=1.15; }
    },
    { id:"clip1", name:"+4 Clip Size", rarity:"common",
      desc:"+4 bullets per clip.",
      apply:p=>{ p.clipSize+=4; p.ammo=p.clipSize; }
    },
    { id:"reload1", name:"Reload +15% faster", rarity:"common",
      desc:"Shorter reload time.",
      apply:p=>{ p.reloadTime*=0.85; }
    },
    { id:"hp1", name:"+20 Max HP", rarity:"common",
      desc:"+20 max HP and heal 20.",
      apply:p=>{ p.maxHp+=20; p.hp=Math.min(p.maxHp,p.hp+20); }
    },

    // RARE
    { id:"dmg2", name:"+35% Damage", rarity:"rare",
      desc:"Big damage spike.",
      apply:p=>{ p.baseDamage*=1.35; }
    },
    { id:"rate2", name:"+40% Fire Rate", rarity:"rare",
      desc:"Shoot much faster.",
      apply:p=>{ p.fireRate*=1.40; }
    },
    { id:"proj2", name:"+2 Projectiles", rarity:"rare",
      desc:"More bullets in each volley.",
      apply:p=>{ p.projectileCount+=2; }
    },
    { id:"spread1", name:"Tight Spread", rarity:"rare",
      desc:"Projectiles are more accurate.",
      apply:p=>{ p.projectileSpread*=0.7; }
    },
    { id:"knock1", name:"Knockback+", rarity:"rare",
      desc:"Bullets knock enemies back harder.",
      apply:p=>{ p.knockback*=1.6; }
    },
    { id:"expl1", name:"Small Explosions", rarity:"rare",
      desc:"Bullets create small splash damage that grows with more picks.",
      apply:p=>{
        if(p.explosionRadius === 0){
          p.explosionRadius = 60;
        }else{
          p.explosionRadius += 30;
        }
      }
    },
    { id:"splinter1", name:"Splinter Shot", rarity:"rare",
      desc:"Bullets split into more shards on hit (stacks).",
      apply:p=>{ p.splinter += 1; }
    },

    // EPIC
    { id:"poison1", name:"Poison Rounds", rarity:"epic",
      desc:"Bullets apply stacking poison damage over time.",
      apply:p=>{ p.poisonLevel = (p.poisonLevel || 0) + 1; }
    },
    { id:"freeze1", name:"Freeze Rounds", rarity:"epic",
      desc:"Bullets apply stronger slows each level.",
      apply:p=>{ p.freezeLevel = (p.freezeLevel || 0) + 1; }
    },
    { id:"light1", name:"Chain Lightning", rarity:"epic",
      desc:"Bullets arc to more targets and proc more often.",
      apply:p=>{ p.lightningLevel = (p.lightningLevel || 0) + 1; }
    },
    { id:"weaken1", name:"Weaken", rarity:"epic",
      desc:"Bullets make enemies take more damage for longer (stacks).",
      apply:p=>{ p.weakenLevel = (p.weakenLevel || 0) + 1; }
    },
    { id:"expl2", name:"Bigger Explosions", rarity:"epic",
      desc:"Explosion radius grows a lot each time you pick this.",
      apply:p=>{
        if(p.explosionRadius === 0){
          p.explosionRadius = 80;
        }
        p.explosionRadius += 45;
      }
    },
    { id:"splinter2", name:"Multi Splinter", rarity:"epic",
      desc:"Adds even more splinters to each hit (stacks).",
      apply:p=>{ p.splinter += 2; }
    },

    // LEGENDARY
    { id:"dragon", name:"Dragon Shot", rarity:"legend",
      desc:"Unlocks/empowers Dragon Shot. More levels = more frequent, stronger fire.",
      apply:p=>{
        p.dragonShot = true;
        p.dragonLevel = (p.dragonLevel || 0) + 1;
      }
    }
  ];

  function rarityWeight(r){
    if(r==="common") return 70;
    if(r==="rare") return 25;
    if(r==="epic") return 5;
    if(r==="legend") return 1;
    return 1;
  }

  function pickUpgrades(level){
    const pool = upgrades.filter(u=>{
      if(u.rarity === "legend"){
        return level>=25;
      }
      return true;
    });

    const picks = [];
    const used = new Set();
    while(picks.length<3 && picks.length<pool.length){
      let totalW = 0;
      for(const u of pool) totalW += rarityWeight(u.rarity);
      let roll = Math.random()*totalW;
      let chosen = null;
      for(const u of pool){
        roll -= rarityWeight(u.rarity);
        if(roll<=0){
          chosen = u;
          break;
        }
      }
      if(!chosen) chosen = pool[0];
      if(used.has(chosen.id)) continue;
      used.add(chosen.id);
      picks.push(chosen);
    }
    return picks;
  }

  function restartRun(){
    // restart from level 1, no free level-ups on death
    state.level = 1;
    state.round = 1;
    state.kills = 0;
    state.roundKills = 0;
    state.time = 0;
    resetPlayerStats();
    resetWorld();
    startRound();
    state.showOverlay = false;
  }

  function showRoundOverlay(){
    state.inRound = false;
    state.showOverlay = true;

    const isDeath = state.player.hp <= 0;
    state.lastOutcome = isDeath ? "death" : "win";

    overlayTitle.textContent = isDeath ? "You Died" : `Round ${state.round} Complete`;
    overlaySubtitle.textContent = isDeath
      ? "Your run has ended. Check the leaderboard and start a new run."
      : "Pick one upgrade for your gun build, then continue to the next round.";
    overlayFooterHint.style.visibility = isDeath ? "hidden" : "visible";

    state.bestLevel = Math.max(state.bestLevel,state.level);
    state.bestKills = Math.max(state.bestKills,state.kills);
    bestRunBadge.textContent = `Lvl ${state.bestLevel} ‚Ä¢ ${state.bestKills} kills`;

    // Build panel content
    upgradeGrid.innerHTML = "";
    if(!isDeath){
      const available = pickUpgrades(state.level);
      available.forEach(up=>{
        const card = document.createElement("div");
        card.className = "upgrade-card";
        const rarityClass = up.rarity === "legend" ? "legend" : up.rarity;
        card.innerHTML = `
          <div class="upgrade-title">
            <span>${up.name}</span>
            <span class="rarity-pill rarity-${rarityClass}">
              ${up.rarity.toUpperCase()}
            </span>
          </div>
          <div class="upgrade-desc">${up.desc}</div>
        `;
        card.addEventListener("click",()=>{
          up.apply(state.player);
          // Heal a bit on upgrade
          state.player.hp = Math.min(state.player.maxHp, state.player.hp+10);
          state.level++;          // ‚¨Ö only level up on a win
          state.round++;
          startRound();
        });
        upgradeGrid.appendChild(card);
      });
    }else{
      const btn = document.createElement("button");
      btn.className = "restart-button";
      btn.textContent = "üîÅ Start New Run (Back to Level 1)";
      btn.addEventListener("click", ()=>{
        restartRun();
      });
      upgradeGrid.appendChild(btn);
    }

    // Save score + load leaderboard
    if(scoresRef && db){
      const thisRun = {name:playerName, level:state.level, kills:state.kills, ts:Date.now()};
      scoresRef.add(thisRun).then(()=>{
        updateLeaderboard(thisRun);
      }).catch(err=>{
        console.warn("Failed to save score:",err);
        leaderboardStatus.textContent = "Could not save score. Offline?";
      });
    }else{
      leaderboardStatus.textContent = "Firebase not configured. Leaderboard disabled.";
      leaderboardTableBody.innerHTML = "";
    }

    roundOverlay.classList.remove("hidden");
  }

  async function updateLeaderboard(thisRun){
    leaderboardStatus.textContent = "Loading leaderboard...";
    leaderboardTableBody.innerHTML = "";
    let placementText = "";
    try{
      // top 20
      const snap = await scoresRef.orderBy("kills","desc").limit(20).get();
      let i=1;
      let highlightIndex = null;
      snap.forEach(doc=>{
        const d = doc.data();
        const tr = document.createElement("tr");
        const isThis = (d.name===thisRun.name && d.kills===thisRun.kills && d.level===thisRun.level);
        if(isThis){
          tr.classList.add("highlight");
          highlightIndex = i;
        }
        tr.innerHTML = `
          <td>${i}</td>
          <td>${d.name||"?"}</td>
          <td>${d.level||1}</td>
          <td>${d.kills||0}</td>
        `;
        leaderboardTableBody.appendChild(tr);
        i++;
      });
      leaderboardStatus.textContent = snap.empty ? "No scores yet. You are the first!" : "";
      // Placement across all scores
      const higherSnap = await scoresRef.where("kills",">",thisRun.kills).get();
      const rank = higherSnap.size+1;
      const total = (await scoresRef.get()).size;
      placementText = `Your run: #${rank} of ${total} all-time (by kills).`;
      if(highlightIndex!=null){
        placementText += ` You are currently #${highlightIndex} on the visible board.`;
      }
    }catch(err){
      console.warn("Leaderboard error:",err);
      placementText = "Leaderboard unavailable (error).";
      leaderboardStatus.textContent = "Leaderboard unavailable.";
    }
    runPlacement.textContent = placementText;
  }

  function updateHud(){
    levelDisplay.textContent = state.level;
    scoreDisplay.textContent = state.kills;
    roundDisplay.textContent = state.round;
    hpDisplay.textContent = `${Math.round(state.player.hp)} / ${Math.round(state.player.maxHp)}`;
  }

  // === Game loop ===
  let lastTime = performance.now();
  resetWorld();
  startRound();

  function loop(now){
    const dt = Math.min((now-lastTime)/1000,0.04);
    lastTime = now;
    state.time += dt;
    step(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function step(dt){
    if(state.showOverlay) return;

    const p = state.player;

    // Keyboard fallback movement
    let kbX = 0, kbY = 0;
    if(keys["w"]||keys["arrowup"]) kbY-=1;
    if(keys["s"]||keys["arrowdown"]) kbY+=1;
    if(keys["a"]||keys["arrowleft"]) kbX-=1;
    if(keys["d"]||keys["arrowright"]) kbX+=1;
    let moveX = moveInput.x + kbX;
    let moveY = moveInput.y + kbY;
    const moveLen = Math.hypot(moveX,moveY);
    if(moveLen>1){ moveX/=moveLen; moveY/=moveLen; }

    // Move player
    p.x += moveX*p.speed*dt;
    p.y += moveY*p.speed*dt;
    // Clamp inside world
    p.x = Math.max(-halfWorld+60, Math.min(halfWorld-60, p.x));
    p.y = Math.max(-halfWorld+60, Math.min(halfWorld-60, p.y));
    // Prevent running through walls (obstacles)
    for(const ob of state.obstacles){
      const rx1 = ob.x-ob.w/2;
      const ry1 = ob.y-ob.h/2;
      const rx2 = ob.x+ob.w/2;
      const ry2 = ob.y+ob.h/2;
      const nx = clamp(p.x,rx1,rx2);
      const ny = clamp(p.y,ry1,ry2);
      const dx = p.x-nx;
      const dy = p.y-ny;
      const dist = Math.hypot(dx,dy);
      const minDist = p.radius+2;
      if(dist < minDist){
        const push = (minDist - (dist||1));
        p.x += (dx/(dist||1))*push;
        p.y += (dy/(dist||1))*push;
      }
    }

    // Regen
    p.hp = Math.min(p.maxHp, p.hp + p.regen*dt);

    // Shooting
    const aimLen = Math.hypot(shootInput.x,shootInput.y);
    const wantsShoot = aimLen>0.25;
    p.shotCooldown -= dt;
    if(p.reloadTimer>0){
      p.reloadTimer -= dt;
      if(p.reloadTimer<=0){
        p.ammo = p.clipSize;
      }
    }
    if(wantsShoot && p.shotCooldown<=0 && p.reloadTimer<=0){
      const dirAngle = Math.atan2(shootInput.y,shootInput.x);
      fireShot(dirAngle);
      p.shotCooldown = 1/p.fireRate;
      p.ammo--;
      if(p.ammo<=0){
        p.reloadTimer = p.reloadTime;
      }
    }

    // Update bullets
    for(let i=state.bullets.length-1;i>=0;i--){
      const b = state.bullets[i];
      b.life -= dt;
      if(b.life<=0){
        state.bullets.splice(i,1);
        continue;
      }
      if(b.dragon){
        // steer toward nearest enemy
        const tgt = findNearestEnemy(b.x,b.y,400);
        if(tgt){
          const angle = Math.atan2(tgt.y-b.y,tgt.x-b.x);
          b.vx += Math.cos(angle)*b.homing*dt;
          b.vy += Math.sin(angle)*b.homing*dt;
          const speed = Math.hypot(b.vx,b.vy)||1;
          const s = b.speed/speed;
          b.vx*=s; b.vy*=s;
        }
      }
      b.x += b.vx*dt;
      b.y += b.vy*dt;
      // collision with obstacles
      for(const ob of state.obstacles){
        if(circleRectOverlap(b.x,b.y,4,ob)){
          bulletImpact(b,null,i);
          break;
        }
      }
    }

    // Enemy bullets
    for(let i=state.enemyBullets.length-1;i>=0;i--){
      const eb = state.enemyBullets[i];
      eb.life -= dt;
      if(eb.life<=0){
        state.enemyBullets.splice(i,1);
        continue;
      }
      eb.x += eb.vx*dt;
      eb.y += eb.vy*dt;
      // hit player
      const dx = eb.x - p.x;
      const dy = eb.y - p.y;
      if(dx*dx+dy*dy < (p.radius*0.7)*(p.radius*0.7)){
        p.hp -= eb.damage;
        state.enemyBullets.splice(i,1);
        if(p.hp<=0){
          p.hp = 0;
          updateHud();
          showRoundOverlay(); // death -> no leveling up
          return;
        }
      }
    }

    // Goblin rockets
    for(let i=state.rockets.length-1;i>=0;i--){
      const r = state.rockets[i];
      r.time += dt;
      const t = Math.min(1, r.time / r.ttl);
      r.x = r.sx + (r.tx-r.sx)*t;
      r.y = r.sy + (r.ty-r.sy)*t;
      if(r.time>=r.ttl){
        // Explosion
        const dx = p.x - r.tx;
        const dy = p.y - r.ty;
        if(dx*dx+dy*dy < r.radius*r.radius){
          p.hp -= r.damage;
          if(p.hp<=0){
            p.hp = 0;
            updateHud();
            showRoundOverlay();
            return;
          }
        }
        // Particle ring (big impact)
        state.particles.push({
          type:"ring",
          x:r.tx,
          y:r.ty,
          life:0.55,
          maxLife:0.55,
          radius:r.radius
        });
        state.rockets.splice(i,1);
      }
    }

    // Fire zones (dragon / explosion) ‚Äì damage enemies only
    for(let i=state.fireZones.length-1;i>=0;i--){
      const fz = state.fireZones[i];
      fz.life -= dt;
      if(fz.life<=0){
        state.fireZones.splice(i,1);
        continue;
      }
    }

    // Enemies
    let aliveEnemies = 0;
    for(let i=state.enemies.length-1;i>=0;i--){
      const e = state.enemies[i];
      e.behaviorTimer += dt;
      e.lightningCooldown = Math.max(0,e.lightningCooldown-dt);

      // Status effects
      if(e.poisonTimer>0){
        e.poisonTimer -= dt;
        e.hp -= e.poisonDps*dt;
      }
      if(e.weakenTimer>0){
        e.weakenTimer -= dt;
      }

      let effectiveSpeed = e.speed * (e.slowFactor || 1);

      const dx = p.x - e.x;
      const dy = p.y - e.y;
      const dist = Math.hypot(dx,dy)||1;

      // Boss mix abilities: occasionally do extra stuff
      if(e.boss){
        e.mixTimer += dt;
        if(e.mixTimer>4){
          e.mixTimer = 0;
          const roll = Math.floor(Math.random()*3);
          if(roll===0){
            // spawn ant minion
            const child = makeEnemy(0,false,false);
            child.x = e.x + (Math.random()-0.5)*120;
            child.y = e.y + (Math.random()-0.5)*120;
            state.enemies.push(child);
          }else if(roll===1){
            // spawn poison circle near player
            const ang = Math.random()*Math.PI*2;
            const rr = 80 + Math.random()*160;
            const zx = p.x + Math.cos(ang)*rr;
            const zy = p.y + Math.sin(ang)*rr;
            state.poisonZones.push({
              x:zx,y:zy,
              radius:80,
              telegraphTime:0.7,
              activeTime:2.0,
              timer:0,
              active:false,
              dps:16
            });
          }else{
            // fire rocket toward area near player
            const offAng = Math.random()*Math.PI*2;
            const offRad = 60+Math.random()*100;
            const tx = p.x + Math.cos(offAng)*offRad;
            const ty = p.y + Math.sin(offAng)*offRad;
            state.rockets.push({
              sx:e.x, sy:e.y,
              x:e.x, y:e.y,
              tx,ty,
              radius:110,
              damage:e.damage*1.3,
              ttl:1.1,
              time:0
            });
          }
        }
      }

      // Behavior by enemy type
      if(e.type===0){
        // üêú Ant ‚Äì fast chaser, splits
        e.vx = (dx/dist)*effectiveSpeed;
        e.vy = (dy/dist)*effectiveSpeed;
        e.splitTimer += dt;
        if(e.splitTimer>=8){
          e.splitTimer = 0;
          if(Math.random()<0.5){
            const child = makeEnemy(0,false,false);
            child.x = e.x + (Math.random()-0.5)*60;
            child.y = e.y + (Math.random()-0.5)*60;
            state.enemies.push(child);
          }
        }
      }else if(e.type===1){
        // üëª Ghost ‚Äì slow drift + random teleports, ignores walls
        e.vx = (dx/dist)*effectiveSpeed*0.6;
        e.vy = (dy/dist)*effectiveSpeed*0.6;
        e.teleportTimer += dt;
        if(e.teleportTimer>=e.teleportCooldown){
          e.teleportTimer = 0;
          e.teleportCooldown = 1.8 + Math.random()*2.2;
          const r = 220 + Math.random()*200;
          const ang = Math.random()*Math.PI*2;
          e.x = p.x + Math.cos(ang)*r;
          e.y = p.y + Math.sin(ang)*r;
        }
      }else if(e.type===2){
        // üê∫ Wolf ‚Äì dash attacker
        if(e.dashState==="chase"){
          e.vx = (dx/dist)*effectiveSpeed;
          e.vy = (dy/dist)*effectiveSpeed;
          e.dashCooldown -= dt;
          if(e.dashCooldown<=0 && dist<480){
            e.dashState = "windup";
            e.dashWindup = 0.5;
            e.dashTargetX = p.x;
            e.dashTargetY = p.y;
            e.dashCooldown = 3 + Math.random()*2;
          }
        }else if(e.dashState==="windup"){
          e.vx *= 0.4;
          e.vy *= 0.4;
          e.dashWindup -= dt;
          if(e.dashWindup<=0){
            e.dashState = "dash";
            const dir = Math.atan2(e.dashTargetY-e.y, e.dashTargetX-e.x);
            e.vx = Math.cos(dir)*effectiveSpeed*4.0;
            e.vy = Math.sin(dir)*effectiveSpeed*4.0;
            e.dashTime = 0.28;
          }
        }else if(e.dashState==="dash"){
          e.dashTime -= dt;
          if(e.dashTime<=0){
            e.dashState="chase";
          }
        }
      }else if(e.type===3){
        // üë∫ Goblin ‚Äì mid-range kiter with rockets
        const desired = 420;
        if(dist>desired+50){
          e.vx = (dx/dist)*effectiveSpeed;
          e.vy = (dy/dist)*effectiveSpeed;
        }else if(dist<desired-80){
          e.vx = -(dx/dist)*effectiveSpeed;
          e.vy = -(dy/dist)*effectiveSpeed;
        }else{
          e.vx *= 0.85;
          e.vy *= 0.85;
        }
        e.rocketTimer += dt;
        const interval = e.boss?1.4:2.1;
        if(e.rocketTimer>=interval){
          e.rocketTimer = 0;
          const offAng = Math.random()*Math.PI*2;
          const offRad = 40+Math.random()*100;
          const tx = p.x + Math.cos(offAng)*offRad;
          const ty = p.y + Math.sin(offAng)*offRad;
          state.rockets.push({
            sx:e.x, sy:e.y,
            x:e.x, y:e.y,
            tx,ty,
            radius:90,
            damage:e.damage*(e.boss?1.5:1.2),
            ttl:1.0,
            time:0
          });
        }
      }else if(e.type===4){
        // ü™® Golem ‚Äì slow tank, splits when dead
        e.vx = (dx/dist)*effectiveSpeed*0.6;
        e.vy = (dy/dist)*effectiveSpeed*0.6;
      }else if(e.type===5){
        // üßô‚Äç‚ôÄÔ∏è Witch ‚Äì keeps distance, casts poison circles
        const minDist = 420;
        const maxDist = 700;
        if(dist>maxDist){
          e.vx = (dx/dist)*effectiveSpeed*0.7;
          e.vy = (dy/dist)*effectiveSpeed*0.7;
        }else if(dist<minDist){
          e.vx = -(dx/dist)*effectiveSpeed*0.7;
          e.vy = -(dy/dist)*effectiveSpeed*0.7;
        }else{
          e.vx *= 0.8;
          e.vy *= 0.8;
        }
        e.castTimer += dt;
        const castInterval = e.boss?2.4:3.3;
        if(e.castTimer>=castInterval){
          e.castTimer = 0;
          const circles = e.boss?4:3;
          for(let c=0;c<circles;c++){
            const ang = Math.random()*Math.PI*2;
            const rr = 80 + Math.random()*160;
            const zx = p.x + Math.cos(ang)*rr;
            const zy = p.y + Math.sin(ang)*rr;
            state.poisonZones.push({
              x:zx,y:zy,
              radius:70,
              telegraphTime:0.7,
              activeTime:1.8,
              timer:0,
              active:false,
              dps:16
            });
          }
        }
      }else if(e.type===6){
        // ü¶ë Squid ‚Äì laser caster
        const idealDist = 520;
        if(dist>idealDist+60){
          e.vx = (dx/dist)*effectiveSpeed*0.8;
          e.vy = (dy/dist)*effectiveSpeed*0.8;
        }else if(dist<idealDist-80){
          e.vx = -(dx/dist)*effectiveSpeed*0.8;
          e.vy = -(dy/dist)*effectiveSpeed*0.8;
        }else{
          e.vx *= 0.7;
          e.vy *= 0.7;
        }

        if(e.laserFiring>0){
          e.laserFiring -= dt;
          if(e.laserFiring<=0){
            e.laserFiring = 0;
            e.laserCooldown = 2 + Math.random()*1.5;
          }
        }else{
          e.laserCooldown -= dt;
          if(e.laserWindup>0){
            e.laserWindup -= dt;
            if(e.laserWindup<=0){
              // Fire beam now
              e.laserFiring = 0.35;
              const beamLen = 1000;
              const bw = 40;
              const ax = e.x;
              const ay = e.y;
              const bx = e.x + Math.cos(e.laserDir)*beamLen;
              const by = e.y + Math.sin(e.laserDir)*beamLen;
              const tproj = ((p.x-ax)*Math.cos(e.laserDir)+(p.y-ay)*Math.sin(e.laserDir))/beamLen;
              if(tproj>0 && tproj<1){
                const projX = ax + (bx-ax)*tproj;
                const projY = ay + (by-ay)*tproj;
                const d2 = (p.x-projX)**2+(p.y-projY)**2;
                if(d2 < bw*bw){
                  p.hp -= e.damage*(e.boss?2.0:1.4);
                  if(p.hp<=0){
                    p.hp = 0;
                    updateHud();
                    showRoundOverlay();
                    return;
                  }
                }
              }
            }
          }else if(e.laserCooldown<=0 && dist<900){
            e.laserWindup = 0.8;
            e.laserDir = Math.atan2(dy,dx);
          }
        }
      }

      // Move enemy
      e.x += e.vx*dt;
      e.y += e.vy*dt;

      // collisions with obstacles (ghosts ignore)
      if(e.type!==1){
        for(const ob of state.obstacles){
          const nearestX = clamp(e.x, ob.x-ob.w/2, ob.x+ob.w/2);
          const nearestY = clamp(e.y, ob.y-ob.h/2, ob.y+ob.h/2);
          const dx2 = e.x-nearestX;
          const dy2 = e.y-nearestY;
          const dist2 = Math.hypot(dx2,dy2);
          if(dist2 < e.radius+4){
            const diff = (e.radius+4)-(dist2||1);
            e.x += (dx2/(dist2||1))*diff;
            e.y += (dy2/(dist2||1))*diff;
          }
        }
      }

      // hit player by contact
      if(!state.showOverlay){
        const d2p = (e.x-p.x)**2+(e.y-p.y)**2;
        const range = e.radius+p.radius*0.5;
        if(d2p < range*range){
          p.hp -= e.damage*dt*0.45;
          if(p.hp<=0){
            p.hp=0;
            updateHud();
            showRoundOverlay();
            return;
          }
        }
      }

      // Death handling
      if(e.hp<=0){
        onEnemyDeath(e);
        state.enemies.splice(i,1);
        continue;
      }else{
        aliveEnemies++;
      }
    }

    // Poison zones ‚Äì damage player
    for(let i=state.poisonZones.length-1;i>=0;i--){
      const z = state.poisonZones[i];
      z.timer += dt;
      if(!z.active && z.timer>=z.telegraphTime){
        z.active = true;
      }
      if(z.timer >= z.telegraphTime + z.activeTime){
        state.poisonZones.splice(i,1);
        continue;
      }
      if(z.active){
        const dx = p.x - z.x;
        const dy = p.y - z.y;
        if(dx*dx+dy*dy < z.radius*z.radius){
          p.hp -= z.dps*dt;
          if(p.hp<=0){
            p.hp=0;
            updateHud();
            showRoundOverlay();
            return;
          }
        }
      }
    }

    // Particles
    for(let i=state.particles.length-1;i>=0;i--){
      const part = state.particles[i];
      part.life -= dt;
      if(part.life<=0){
        state.particles.splice(i,1);
      }
    }

    // Bullet vs enemy collisions
    for(let i=state.bullets.length-1;i>=0;i--){
      const b = state.bullets[i];
      let removed=false;
      for(let j=state.enemies.length-1;j>=0;j--){
        const e = state.enemies[j];
        const dx = e.x-b.x;
        const dy = e.y-b.y;
        if(dx*dx+dy*dy < (e.radius+6)*(e.radius+6)){
          bulletImpact(b,e,i);
          removed=true;
          break;
        }
      }
      if(removed) continue;
    }

    // Fire zones apply damage to enemies
    for(const fz of state.fireZones){
      for(const e of state.enemies){
        const dx = e.x-fz.x;
        const dy = e.y-fz.y;
        if(dx*dx+dy*dy < fz.radius*fz.radius){
          e.hp -= fz.dps*dt;
        }
      }
    }

    // Continuous spawning from edges while we still need kills this round
    if(state.inRound && state.spawnBudget > 0){
      state.spawnTimer += dt;
      const baseDelay = 0.9;
      const minDelay = 0.35;
      const spawnDelay = Math.max(minDelay, baseDelay - state.level*0.03); // slightly faster over time
      while(state.spawnTimer >= spawnDelay && state.spawnBudget > 0){
        const type = Math.floor(Math.random()*state.enemyTypeCap);
        const e = makeEnemy(type,false,false);
        placeEnemyOnEdge(e);
        state.enemies.push(e);
        state.spawnBudget--;
        state.spawnTimer -= spawnDelay;
      }
    }

    // Check round end (you must kill enough AND clear remaining enemies)
    updateHud();
    if(state.inRound){
      const enemiesAlive = state.enemies.length;
      if(state.roundKills >= state.targetKills && enemiesAlive===0){
        showRoundOverlay(); // win -> upgrades + level up
      }
    }
  }

  function fireShot(angle){
    const p = state.player;
    const baseAngle = angle;
    const n = p.projectileCount;
    const spread = p.projectileSpread;

    // Dragon interval depends on dragonLevel (more levels = more frequent)
    const dragonLvl = p.dragonLevel || 0;
    const baseInterval = 6;
    const dragonInterval = dragonLvl > 0
      ? Math.max(2, baseInterval - (dragonLvl - 1))
      : Infinity;

    for(let i=0;i<n;i++){
      const offset = spread*(n===1?0:(i-(n-1)/2));
      const a = baseAngle + offset;
      const speed = p.bulletSpeed;
      const dragon = p.dragonShot && (++p.dragonCounter % dragonInterval === 0);
      const bullet = {
        x:p.x + Math.cos(a)* (p.radius+6),
        y:p.y + Math.sin(a)* (p.radius+6),
        vx:Math.cos(a)*speed,
        vy:Math.sin(a)*speed,
        speed,
        damage:p.baseDamage,
        life:2.1,
        dragon,
        dragonLevel: dragon ? (p.dragonLevel || 1) : 0,
        homing:420,
        poisonLevel:p.poisonLevel||0,
        freezeLevel:p.freezeLevel||0,
        lightningLevel:p.lightningLevel||0,
        weakenLevel:p.weakenLevel||0
      };
      state.bullets.push(bullet);
    }
  }

  function onEnemyDeath(e){
    state.kills++;
    state.roundKills++;

    // Golem split
    if(e.type===4 && !e.small){
      for(let m=0;m<2;m++){
        const child = makeEnemy(4,false,false);
        child.small = true;
        child.radius = e.radius*0.7;
        child.maxHp = e.maxHp*0.3;
        child.hp = child.maxHp;
        child.speed = e.speed*1.7;
        child.x = e.x + (Math.random()-0.5)*50;
        child.y = e.y + (Math.random()-0.5)*50;
        state.enemies.push(child);
      }
    }
  }

  function bulletImpact(b,e,bulletIndex){
    const p = state.player;
    const impactX = e ? e.x : b.x;
    const impactY = e ? e.y : b.y;

    // Extra hit impact particles
    state.particles.push({
      type:"hit",
      x:impactX,
      y:impactY,
      life:0.22,
      maxLife:0.22,
      radius:14
    });

    if(e){
      let dmg = b.damage;
      if(e.weakenTimer>0){
        dmg*=1.4;
      }
      e.hp -= dmg;
      // Knockback
      const dx = e.x-b.x;
      const dy = e.y-b.y;
      const dist = Math.hypot(dx,dy)||1;
      e.x += (dx/dist)*p.knockback*0.04;
      e.y += (dy/dist)*p.knockback*0.04;

      // Poison
      if(p.poisonLevel>0){
        e.poisonTimer = 2.2;
        e.poisonDps = 7*p.poisonLevel;
      }
      // Freeze (slow)
      if(p.freezeLevel>0){
        e.slowFactor = 0.3;
        setTimeout(()=>{ e.slowFactor = 1; }, 700+300*p.freezeLevel);
      }
      // Weaken
      if(p.weakenLevel>0){
        e.weakenTimer = 2+p.weakenLevel;
      }
      // Lightning chain
      if(p.lightningLevel>0 && Math.random()<0.6){
        const chains = 1+p.lightningLevel;
        chainLightning(e.x,e.y,chains,dmg*0.7);
      }

      // Explosion
      if(p.explosionRadius>0){
        const rad = p.explosionRadius;
        for(const other of state.enemies){
          if(other===e) continue;
          const dx2 = other.x-e.x;
          const dy2 = other.y-e.y;
          if(dx2*dx2+dy2*dy2 < rad*rad){
            other.hp -= dmg*0.6;
          }
        }
        state.fireZones.push({
          x:e.x,y:e.y,
          radius:rad*0.7,
          dps:4+2*p.poisonLevel,
          life:0.7
        });
      }

      // Splinter
      if(p.splinter>0){
        for(let k=0;k<p.splinter;k++){
          const a = Math.random()*Math.PI*2;
          const speed = p.bulletSpeed*0.7;
          state.bullets.push({
            x:e.x,
            y:e.y,
            vx:Math.cos(a)*speed,
            vy:Math.sin(a)*speed,
            speed,
            damage:p.baseDamage*0.25,
            life:1.0,
            dragon:false,
            dragonLevel:0,
            homing:0,
            poisonLevel:p.poisonLevel||0,
            freezeLevel:p.freezeLevel||0,
            lightningLevel:p.lightningLevel||0,
            weakenLevel:p.weakenLevel||0
          });
        }
      }

      // Dragon fire zone
      if(b.dragon){
        const dl = b.dragonLevel || 1;
        state.fireZones.push({
          x:e.x,
          y:e.y,
          radius:100 + 24*dl,
          dps:7 + 4*dl,
          life:1.8 + 0.25*dl
        });
      }
    }
    state.bullets.splice(bulletIndex,1);
  }

  function chainLightning(x,y,count,damage){
    for(let i=0;i<count;i++){
      const target = findNearestEnemy(x,y,260);
      if(!target) break;
      target.hp -= damage;
      x = target.x;
      y = target.y;
    }
  }

  function findNearestEnemy(x,y,maxDist){
    let best=null;
    let bestD=maxDist*maxDist;
    for(const e of state.enemies){
      const dx=e.x-x, dy=e.y-y;
      const d=dx*dx+dy*dy;
      if(d<bestD){
        bestD=d;
        best=e;
      }
    }
    return best;
  }

  function spawnEnemyBullet(x,y,angle,damage,speed){
    state.enemyBullets.push({
      x,y,
      vx:Math.cos(angle)*speed,
      vy:Math.sin(angle)*speed,
      damage,
      life:3
    });
  }

  function circleRectOverlap(cx,cy,r,rect){
    const rx1 = rect.x-rect.w/2;
    const ry1 = rect.y-rect.h/2;
    const rx2 = rect.x+rect.w/2;
    const ry2 = rect.y+rect.h/2;
    const nx = clamp(cx,rx1,rx2);
    const ny = clamp(cy,ry1,ry2);
    const dx = cx-nx;
    const dy = cy-ny;
    return dx*dx+dy*dy < r*r;
  }

  function clamp(v,min,max){ return v<min?min:v>max?max:v; }

  function getBulletColor(b){
    if(b.dragon) return "#f97316"; // dragon always fiery

    const poison = b.poisonLevel>0;
    const freeze = b.freezeLevel>0;
    const lightning = b.lightningLevel>0;
    const weaken = b.weakenLevel>0;

    if(poison && freeze) return "#a3e635"; // toxic ice
    if(freeze)           return "#22d3ee";
    if(poison)           return "#22c55e";
    if(lightning)        return "#facc15";
    if(weaken)           return "#e879f9";

    return "#e5e7eb";
  }

  function getEnemyEmoji(e){
    switch(e.type){
      case 0: return "üêú";
      case 1: return "üëª";
      case 2: return "üê∫";
      case 3: return "üë∫";
      case 4: return "ü™®";
      case 5: return "üßô‚Äç‚ôÄÔ∏è";
      case 6: return "ü¶ë";
      default:return "‚ùì";
    }
  }

  // Draw
  function draw(){
    const w = canvas.width;
    const h = canvas.height;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "#020617";
    ctx.fillRect(0,0,w,h);

    const p = state.player;
    const camX = p.x - w/2;
    const camY = p.y - h/2;
    ctx.setTransform(1,0,0,1,-camX,-camY);

    // Arena background grid
    ctx.save();
    ctx.strokeStyle="#020617";
    ctx.lineWidth=1;
    const step=160;
    for(let x=-halfWorld;x<=halfWorld;x+=step){
      ctx.beginPath();
      ctx.moveTo(x,-halfWorld);
      ctx.lineTo(x,halfWorld);
      ctx.stroke();
    }
    for(let y=-halfWorld;y<=halfWorld;y+=step){
      ctx.beginPath();
      ctx.moveTo(-halfWorld,y);
      ctx.lineTo(halfWorld,y);
      ctx.stroke();
    }
    ctx.restore();

    // Obstacles
    for(const ob of state.obstacles){
      ctx.save();
      ctx.translate(ob.x,ob.y);
      ctx.fillStyle="#0f172a";
      ctx.strokeStyle="#111827";
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.rect(-ob.w/2,-ob.h/2,ob.w,ob.h);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    // Fire zones (dragon / explosions)
    for(const fz of state.fireZones){
      ctx.save();
      ctx.translate(fz.x,fz.y);
      const alpha = Math.max(0,fz.life/2.5);
      const grd = ctx.createRadialGradient(0,0,0,0,0,fz.radius);
      grd.addColorStop(0,`rgba(248,113,113,${alpha})`);
      grd.addColorStop(1,`rgba(127,29,29,0)`);
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.arc(0,0,fz.radius,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // Poison zones (witch)
    for(const z of state.poisonZones){
      ctx.save();
      ctx.translate(z.x,z.y);
      const alpha = z.active ? 0.4 : 0.25;
      const grd = ctx.createRadialGradient(0,0,0,0,0,z.radius);
      grd.addColorStop(0,`rgba(74,222,128,${alpha})`);
      grd.addColorStop(1,"rgba(22,101,52,0)");
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.arc(0,0,z.radius,0,Math.PI*2);
      ctx.fill();

      ctx.strokeStyle = z.active ? "rgba(22,163,74,.9)" : "rgba(190,242,100,.9)";
      ctx.setLineDash(z.active?[]:[6,6]);
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0,0,z.radius,0,Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    // Explosion / hit particles
    for(const par of state.particles){
      ctx.save();
      ctx.translate(par.x,par.y);
      const t = par.life / par.maxLife;
      if(par.type === "hit"){
        // small starburst lines
        ctx.strokeStyle=`rgba(248,250,252,${t})`;
        ctx.lineWidth=2;
        const rays = 6;
        const len = par.radius * (1-t);
        for(let i=0;i<rays;i++){
          const a = (Math.PI*2 * i)/rays;
          ctx.beginPath();
          ctx.moveTo(Math.cos(a)*2, Math.sin(a)*2);
          ctx.lineTo(Math.cos(a)*(len+4), Math.sin(a)*(len+4));
          ctx.stroke();
        }
      }else{ // ring
        ctx.strokeStyle=`rgba(248,250,252,${t})`;
        ctx.lineWidth=2;
        ctx.beginPath();
        ctx.arc(0,0,par.radius*(1-t*0.3),0,Math.PI*2);
        ctx.stroke();
      }
      ctx.restore();
    }

    // Enemy telegraphs
    for(const e of state.enemies){
      // Wolf dash line
      if(e.type===2 && e.dashState==="windup"){
        ctx.save();
        ctx.strokeStyle="rgba(248,250,252,.7)";
        ctx.lineWidth = e.boss?6:4;
        ctx.setLineDash([8,8]);
        ctx.beginPath();
        ctx.moveTo(e.x,e.y);
        ctx.lineTo(e.dashTargetX,e.dashTargetY);
        ctx.stroke();
        ctx.restore();
      }
      // Squid laser telegraph & beam
      if(e.type===6){
        const beamLen = 1000;
        const a = e.laserDir || Math.atan2(state.player.y-e.y,state.player.x-e.x);
        if(e.laserWindup>0){
          ctx.save();
          ctx.strokeStyle="rgba(191,219,254,.7)";
          ctx.lineWidth=e.boss?5:3;
          ctx.setLineDash([10,8]);
          ctx.beginPath();
          ctx.moveTo(e.x,e.y);
          ctx.lineTo(e.x+Math.cos(a)*beamLen, e.y+Math.sin(a)*beamLen);
          ctx.stroke();
          ctx.restore();
        }
        if(e.laserFiring>0){
          ctx.save();
          ctx.strokeStyle="#f97316";
          ctx.lineWidth=e.boss?9:7;
          ctx.setLineDash([]);
          ctx.beginPath();
          ctx.moveTo(e.x,e.y);
          ctx.lineTo(e.x+Math.cos(a)*beamLen, e.y+Math.sin(a)*beamLen);
          ctx.stroke();
          ctx.restore();
        }
      }
    }

    // Enemy bullets
    for(const eb of state.enemyBullets){
      ctx.save();
      ctx.translate(eb.x,eb.y);
      ctx.fillStyle="#f97316";
      ctx.beginPath();
      ctx.arc(0,0,5,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // Goblin rockets (‚úñ marker)
    for(const r of state.rockets){
      ctx.save();
      ctx.translate(r.x,r.y);
      ctx.fillStyle="#f97316";
      ctx.font="18px system-ui,emoji";
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      ctx.fillText("‚úñ",0,0);
      ctx.restore();
    }

    // Bullets
    for(const b of state.bullets){
      ctx.save();
      ctx.translate(b.x,b.y);
      ctx.rotate(Math.atan2(b.vy,b.vx));
      ctx.fillStyle = getBulletColor(b);
      ctx.beginPath();
      ctx.rect(-6,-2,12,4);
      ctx.fill();
      ctx.restore();
    }

    // Enemies
    for(const e of state.enemies){
      ctx.save();
      ctx.translate(e.x,e.y);
      const r = e.radius;

      // Body glow
      let color="#ef4444";
      if(e.type===0) color="#f97316";
      else if(e.type===1) color="#6366f1";
      else if(e.type===2) color="#facc15";
      else if(e.type===3) color="#22c55e";
      else if(e.type===4) color="#a855f7";
      else if(e.type===5) color="#ec4899";
      else if(e.type===6) color="#38bdf8";

      const grd = ctx.createRadialGradient(0,-r*0.3, r*0.2, 0,0,r);
      grd.addColorStop(0,"#f9fafb");
      grd.addColorStop(1,color);
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.arc(0,0,r,0,Math.PI*2);
      ctx.fill();

      // boss ring
      if(e.boss){
        ctx.strokeStyle = e.bigBoss?"#f97316":"#fbbf24";
        ctx.lineWidth = e.bigBoss?5:3;
        ctx.beginPath();
        ctx.arc(0,0,r+6,0,Math.PI*2);
        ctx.stroke();
      }

      // HP bar
      const barW = r*2;
      const hpRatio = Math.max(0,e.hp/e.maxHp);
      ctx.save();
      ctx.translate(-barW/2, -r-12);
      ctx.fillStyle="rgba(15,23,42,.8)";
      ctx.fillRect(0,0,barW,5);
      ctx.fillStyle="#22c55e";
      ctx.fillRect(0,0,barW*hpRatio,5);
      ctx.restore();

      // Emoji symbol
      ctx.font = `${r*1.3}px system-ui,emoji`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(getEnemyEmoji(e),0,0);

      ctx.restore();
    }

    // Player
    ctx.save();
    ctx.translate(p.x,p.y);
    const pr = p.radius;
    const pg = ctx.createRadialGradient(0,-pr*0.4, pr*0.3, 0,0,pr);
    pg.addColorStop(0,"#e0f2fe");
    pg.addColorStop(1,"#0ea5e9");
    ctx.fillStyle=pg;
    ctx.beginPath();
    ctx.arc(0,0,pr,0,Math.PI*2);
    ctx.fill();

    // gun direction sprite
    const aimLen = Math.hypot(shootInput.x,shootInput.y);
    if(aimLen>0.2){
      const a = Math.atan2(shootInput.y,shootInput.x);
      ctx.rotate(a);
      ctx.fillStyle="#f9fafb";
      ctx.fillRect(pr*0.2,-5,pr+16,10);
    }
    ctx.restore();

    // Player HP bar directly above character
    ctx.save();
    ctx.translate(p.x, p.y - p.radius - 18);
    const barW = 70;
    const barH = 7;
    const ratio = Math.max(0, p.hp / p.maxHp);
    ctx.fillStyle = "rgba(15,23,42,.9)";
    ctx.fillRect(-barW/2, 0, barW, barH);
    ctx.fillStyle = "#22c55e";
    ctx.fillRect(-barW/2, 0, barW*ratio, barH);
    ctx.strokeStyle = "rgba(15,23,42,1)";
    ctx.lineWidth = 1.5;
    ctx.strokeRect(-barW/2, 0, barW, barH);
    ctx.restore();

    // reset transform for UI if needed
    ctx.setTransform(1,0,0,1,0,0);
  }
})();
</script>
</body>
</html>




