<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>üè∞ Mountain Blade ‚Äî Castle Siege</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{ --w:1280px; --h:720px; --tile:48px; }
  *{ box-sizing:border-box }
  html, body { height:100%; margin:0; overflow-x:hidden; background:#0b1014; color:#eaf1ff; font-family:system-ui,Segoe UI,Arial }
  body{ display:grid; place-items:center; }
  .frame{
    width:min(100vw, var(--w));
    height:min(100dvh, var(--h));
    border:1px solid #21324a; border-radius:12px; overflow:hidden;
    box-shadow:0 10px 40px rgba(0,0,0,.35); background:#0e1726; position:relative;
  }
  .titlebar{ height:38px; display:flex; align-items:center; gap:8px; padding:0 10px; background:#0f1a2b; border-bottom:1px solid #203049; font-weight:700 }
  .titlebar .dot{ width:10px; height:10px; border-radius:50% } .red{background:#ff5f57}.yellow{background:#ffbd2e}.green{background:#28c840}
  .view{ position:absolute; inset:38px 0 0 0 }
  canvas{ width:100%; height:100%; display:block; background:#0d1020; cursor:crosshair }
  #ui{ position:absolute; inset:0; pointer-events:none }
  #timer{ position:absolute; top:8px; left:50%; transform:translateX(-50%); background:#0f1a2bcc; border:1px solid #2c3f5a; border-radius:10px; padding:6px 10px; font-weight:800 }
  #board{ position:absolute; top:8px; right:8px; min-width:260px; background:#0f1a2bcc; border:1px solid #2c3f5a; border-radius:10px; padding:8px 10px }
  #board h3{ margin:0 0 6px 0; font-size:14px; color:#cfe }
  .row{ display:flex; justify-content:space-between; gap:10px; font-size:13px; color:#cbd5e1 }
  #legend{ position:absolute; left:8px; top:8px; background:#0f1a2bcc; border:1px solid #2c3f5a; border-radius:10px; padding:6px 10px; font-size:12px }
  #hint{ position:absolute; top:44px; left:50%; transform:translateX(-50%); background:#15243dcc; border:1px solid #355; border-radius:10px; padding:6px 10px; font-size:13px; display:none }
  #banner{ position:absolute; left:50%; top:28%; transform:translateX(-50%); font-size:26px; padding:10px 16px; background:#102030aa; border:1px solid #345; border-radius:12px; display:none }
  #hud{ position:absolute; left:0; right:0; bottom:0; height:108px; background:rgba(0,0,0,.35); backdrop-filter:blur(4px); border-top:1px solid #263042; display:flex; align-items:center; gap:16px; padding:10px 16px; pointer-events:auto }
  #selInfo{ min-width:280px; line-height:1.25 }
  #abilities{ display:flex; gap:10px }
  .slot{ width:72px; height:72px; border:1px solid #445; border-radius:10px; display:flex; flex-direction:column; align-items:center; justify-content:center; background:#1a2232; position:relative; cursor:pointer; pointer-events:auto }
  .slot .key{ position:absolute; right:6px; bottom:4px; font-size:12px; color:#9ab }
  .slot .emoji{ font-size:24px } .slot .name{ font-size:11px; color:#c9d4e3; margin-top:4px; text-align:center; line-height:1.1; padding:0 4px }
  .slot.oncd::after{ content:""; position:absolute; inset:0; background:rgba(0,0,0,.45); border-radius:10px }
  .cd-badge{ position:absolute; top:4px; right:6px; font-size:11px; color:#cfe; background:#0008; border:1px solid #345; border-radius:6px; padding:1px 5px }
  #mobileBar{ position:absolute; left:10px; right:10px; top:46px; display:none; gap:8px; z-index:8; pointer-events:auto; flex-wrap:wrap }
  .mbtn{ border:1px solid #3f5575; background:#13243ade; color:#eaf1ff; border-radius:10px; padding:8px 10px; font-weight:700; font-size:12px }
  .mbtn.active{ outline:2px solid #8fd3ff }
  .mobile-only{ display:none }
  @media (max-width: 900px), (pointer: coarse){
    body{ place-items:stretch }
    .frame{ width:100vw; height:100dvh; border-radius:0; border:0 }
    #mobileBar,.mobile-only{ display:flex }
    #legend{ display:none }
    #hud{ height:120px }
    #selInfo{ min-width:180px; font-size:13px }
  }
</style>
</head>
<body>
  <div class="frame">
    <div class="titlebar">
      <span class="dot red"></span><span class="dot yellow"></span><span class="dot green"></span>
      <span>üè∞ Mountain Blade ‚Äî Castle Siege</span>
    </div>
    <div class="view">
      <canvas id="cv"></canvas>
      <div id="ui">
        <div id="timer">‚öîÔ∏è Breach the wall and defeat the defenders</div>
        <div id="legend">Left-drag: select ‚Ä¢ Right-click: <b>attack-move</b> (enemy = focus) ‚Ä¢ Tap ground: command ‚Ä¢ Hold+drag: pan ‚Ä¢ Q/W/E/R: ability</div>
        <div id="board"><h3>Armies on field</h3><div id="boardRows"></div></div>
        <div id="hint"></div>
        <div id="banner"></div>
        <div id="mobileBar" class="mobile-only">
          <button id="btnFS" class="mbtn">‚õ∂ Fullscreen</button>
          <button id="btnBox" class="mbtn">‚¨ö Box Select</button>
          <button id="btnCancelSel" class="mbtn">‚úñ Cancel Select</button>
        </div>
        <div id="hud">
          <div id="selInfo">Select units</div>
          <div id="abilities"></div>
        </div>
      </div>
    </div>
  </div>

<script type="module">
/* ---------- Firebase ---------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
import { getFirestore, doc, getDoc, updateDoc, runTransaction } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
await signInAnonymously(auth);
const db  = getFirestore(app);
const MO_ROOT = ["games_rogueduel", "mountandblade_online"];
const moDoc = (name, id) => doc(db, ...MO_ROOT, name, id);

/* ---------- Params ---------- */
const Q = new URLSearchParams(location.search);
const ME  = Q.get("username") || "anon";
const SIEGE_ID = Q.get("siegeId");
const RETURN_ROUTE = "/game/mountonline.html";

/* ---------- Visuals ---------- */
const COLOR_PLAYER = "#ff5c5c";
const COLOR_AI     = "#4da3ff";
function teamTint(owner){ return owner==="Defenders" ? COLOR_AI : COLOR_PLAYER; }

/* ---------- Canvas / World ---------- */
const cv = document.getElementById("cv");
const ctx = cv.getContext("2d", { alpha:false });

function resizeCanvas(){
  const w = Math.floor(cv.clientWidth);
  const h = Math.floor(cv.clientHeight);
  if (cv.width !== w || cv.height !== h){ cv.width = w; cv.height = h; }
  clampCam();
}
window.addEventListener("resize", resizeCanvas);

const TILE=48;
const GRID_W=160, GRID_H=64;
const WORLD = { w: GRID_W*TILE, h: GRID_H*TILE };

const cam={ x: 0, y: 0, speed:1600 };
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function clampCam(){ cam.x=clamp(cam.x,0,WORLD.w-cv.width); cam.y=clamp(cam.y,0,WORLD.h-cv.height); }
function manh(ax,ay,bx,by){ return Math.abs(ax-bx)+Math.abs(ay-by); }
function cheby(ax,ay,bx,by){ return Math.max(Math.abs(ax-bx),Math.abs(ay-by)); }
function worldToGrid(wx,wy){ return { gx: clamp(Math.floor(wx/TILE),0,GRID_W-1), gy: clamp(Math.floor(wy/TILE),0,GRID_H-1) }; }

/* ---------- Grid tactics constants ---------- */
const PX_TO_SQUARES_PER_SEC = 1 / (TILE*0.9);
const AGGRO_TILES = 7;

/* ---------- Unit Types (includes NEW troops) ---------- */
const TYPES = {
  recruit:        { name:"Recruit",        emoji:"üßë‚Äçüåæ", hp:50,  dmg:5,  rangeTiles:1, atkSpd:1.0, moveSpd:180, armor:0, abilities:[] },
  footman:        { name:"Footman",        emoji:"üõ°Ô∏è",  hp:85,  dmg:7,  rangeTiles:1, atkSpd:1.0, moveSpd:175, armor:2, abilities:[{slot:1,key:"Q",id:"brace",label:"Brace",target:"self",cd:10,dur:4}] },
  swordsman:      { name:"Swordsman",      emoji:"üó°Ô∏è",  hp:100, dmg:10, rangeTiles:1, atkSpd:1.0, moveSpd:170, armor:4, abilities:[{slot:1,key:"Q",id:"shieldwall",label:"Shield Wall",target:"self",cd:12,dur:5}] },

  /* NEW */
  romanSergeant:  { name:"Sergeant",       emoji:"üõ°Ô∏è‚öîÔ∏è", hp:120, dmg:12, rangeTiles:1, atkSpd:1.0, moveSpd:175, armor:5, abilities:[
                     {slot:1,key:"Q",id:"rally",label:"Rally (+25% dmg/speed)",target:"self",cd:20,dur:8, radiusTiles:3, speedMul:1.25, dmgMul:1.25}
                   ]},
  romanChampion:  { name:"Champion",       emoji:"üó°Ô∏èüî•", hp:130, dmg:14, rangeTiles:1, atkSpd:1.2, moveSpd:180, armor:5, abilities:[
                     {slot:1,key:"Q",id:"fury",label:"Fury (+50% atk spd)",target:"self",cd:14,dur:5, atkSpdMul:1.5}
                   ]},
  dragonKnight:   { name:"Dragon",         emoji:"üê≤",  hp:140, dmg:18, rangeTiles:1, atkSpd:1.0, moveSpd:320, armor:3, abilities:[
                     {slot:1,key:"Q",id:"decapitate",label:"Decapitate (100 dmg)",target:"pointOrUnit",cd:10, rangeTiles:2, dmg:100, ap:1.0}
                   ]},
  venetianSaint:  { name:"Saint",          emoji:"üïäÔ∏è",  hp:75,  dmg:4,  rangeTiles:2, atkSpd:0.7, moveSpd:240, armor:1, abilities:[
                     {slot:1,key:"Q",id:"healArea",label:"Heal Area (3√ó3, 25)",target:"point",cd:12,size:3, heal:25, rangeTiles:6}
                   ]},

  cavalry:        { name:"Cavalry",        emoji:"üêé",  hp:115, dmg:12, rangeTiles:1, atkSpd:0.9, moveSpd:440, armor:2, abilities:[{slot:1,key:"Q",id:"charge",label:"Charge",target:"pointOrUnit",cd:6}] },
  archer:         { name:"Archer",         emoji:"üèπ",  hp:60,  dmg:7,  rangeTiles:4, atkSpd:0.9, moveSpd:250, armor:1,
                    abilities:[{slot:1,key:"Q",id:"volley",label:"Volley",target:"point",cd:12,size:3,channel:6000, rangeTiles:8}] },
  crossbowman:    { name:"Crossbowman",    emoji:"üéØ",  hp:66,  dmg:12, rangeTiles:4, atkSpd:0.7, moveSpd:240, armor:1,
                    abilities:[{slot:1,key:"Q",id:"pierceBolt",label:"Piercing Bolt",target:"pointOrUnit",cd:8, dmg:28, ap:0.65, rangeTiles:10, speedTiles:10}] },
  veteranArcher:  { name:"Veteran Archer", emoji:"üèπ‚ú®", hp:64,  dmg:9,  rangeTiles:5, atkSpd:1.1, moveSpd:250, armor:1,
                    abilities:[{slot:1,key:"Q",id:"volley",label:"Volley+",target:"point",cd:10,size:3,channel:5000, rangeTiles:9}] },
  monk:           { name:"Monk",           emoji:"üßò",  hp:68,  dmg:6,  rangeTiles:1, atkSpd:0.9, moveSpd:245, armor:1, abilities:[{slot:1,key:"Q",id:"focus",label:"Focus (+dmg)",target:"self",cd:12,dur:5, dmgUp:3}] },
  priest:         { name:"Priest",         emoji:"‚úùÔ∏è",  hp:70,  dmg:3,  rangeTiles:2, atkSpd:0.7, moveSpd:240, armor:1, abilities:[{slot:1,key:"Q",id:"mend",label:"Mend (HoT)",target:"self",cd:10,dur:5, healPerSec:8}] },
  mage:           { name:"Mage",           emoji:"üîÆ",  hp:56,  dmg:14, rangeTiles:3, atkSpd:0.7, moveSpd:255, armor:0, abilities:[
                    {slot:1,key:"Q",id:"fireburst",label:"Fireburst",target:"point",cd:12,size:2, dmg:20, rangeTiles:6},
                    {slot:2,key:"W",id:"arcaneBolt",label:"Arcane Bolt",target:"pointOrUnit",cd:7,dmg:34, ap:0.5, rangeTiles:10, speedTiles:10}
                   ] },
  /* Siege structures */
  ballista:       { name:"Ballista",       emoji:"üéØ",  hp:100, dmg:0,  rangeTiles:14, atkSpd:0.33, moveSpd:0,   armor:1, boltDmg:25, boltAP:0.3, boltSpeedTiles:9 },
  wall:           { name:"Wall",           emoji:"üß±",  hp:500, dmg:0,  rangeTiles:0,  atkSpd:0,    moveSpd:0,   armor:4 }
};
const TIER   = {
  recruit:1, footman:2, archer:2, monk:2,
  swordsman:3, cavalry:3, crossbowman:3, veteranArcher:3, priest:3, mage:3, ballista:3, wall:0,
  romanSergeant:4, venetianSaint:4,
  romanChampion:5, dragonKnight:5
};
const REWARD = { 1:2, 2:5, 3:8, 4:10, 5:12 };

/* ---------- State ---------- */
let state=null;
let ownerMods={};
let siege=null;

/* ---------- Input ---------- */
const mouse={x:0,y:0,worldX:0,worldY:0,inside:false, inViewport:false, clientX:0, clientY:0};
const viewEl=document.querySelector(".view");
function rect(el){ return el.getBoundingClientRect(); }
function rel(el,e){ const r=el.getBoundingClientRect(); return { x:e.clientX-r.left, y:e.clientY-r.top, w:r.width, h:r.height }; }
let dragging=false, dragStart=null, selection=new Set(), targeting=null;
const localFX=[];
let lastClickAt=0, lastClickCell=null;
const isCoarse = window.matchMedia("(pointer: coarse)").matches || /Android|iPhone|iPad|Mobile/i.test(navigator.userAgent);
let mobileMode = { boxSelect:false, pointerDown:false, pointerMoved:false, panActive:false, holdTimer:null, startWorld:null, startClient:null, justPanned:false };
const commandMarkers=[];

function nearestOpenAround(gx, gy, occ, reserved){
  if(!occupiedOrReserved(gx,gy,occ,reserved)) return {gx,gy};
  const q=[{gx,gy}], seen=new Set([gx+"|"+gy]);
  for(let qi=0; qi<q.length && qi<GRID_W*GRID_H; qi++){
    const cur=q[qi];
    for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]]){
      const nx=cur.gx+dx, ny=cur.gy+dy;
      if(nx<0||ny<0||nx>=GRID_W||ny>=GRID_H) continue;
      const k=nx+"|"+ny; if(seen.has(k)) continue; seen.add(k);
      if(!occupiedOrReserved(nx,ny,occ,reserved)) return {gx:nx,gy:ny};
      q.push({gx:nx,gy:ny});
    }
  }
  return null;
}

/* ---------- UI helpers ---------- */
function flash(t){ const h=document.getElementById("hint"); h.textContent=t; h.style.display="block"; clearTimeout(flash._t); flash._t=setTimeout(()=>h.style.display="none",900); }
function showHint(t){ const h=document.getElementById("hint"); h.textContent=t; h.style.display="block"; }
function hideHint(){ document.getElementById("hint").style.display="none"; }
  function popupDmgAt(unit, amount, color = "#ff4d4d") {
  const dur = 800; // ms
  localFX.push({
    kind: "dmg",
    gx: unit.gx,
    gy: unit.gy,
    text: `-${amount}`,
    color,
    start: Date.now(),
    dur,
    until: Date.now() + dur
  });
}


/* ---------- Siege geometry ---------- */
const WALL_X = Math.floor(GRID_W * 0.62);
const WALL   = { hp:500, maxHp:500, alive:true };
const BALLISTA_POS = [
  { gx: WALL_X+3, gy: Math.floor(GRID_H*0.25) },
  { gx: WALL_X+3, gy: Math.floor(GRID_H*0.50) },
  { gx: WALL_X+3, gy: Math.floor(GRID_H*0.75) }
];
const WALL_SEGMENT_POS = [
  { gx: WALL_X, gy: Math.floor(GRID_H*0.25) },
  { gx: WALL_X, gy: Math.floor(GRID_H*0.50) },
  { gx: WALL_X, gy: Math.floor(GRID_H*0.75) }
];
function isWallBlocking(u, nx, ny){
  if(!WALL.alive) return false;
  if(nx === WALL_X) return true;
  if(u.gx < WALL_X && nx >= WALL_X) return true;
  if(u.gx > WALL_X && nx <= WALL_X-1) return true;
  return false;
}

/* ---------- Mods ---------- */
function bannerMods(){ return { melee:1, ranged:1, speed:1, armorMul:1, magic:1, cavDmg:1, priestHeal:1, footmanHp:1 }; }

/* ---------- Firebase load ---------- */
async function loadSiege(){
  if(!SIEGE_ID){ alert("Missing siegeId."); history.back(); return null; }
  const s = await getDoc(moDoc("sieges", SIEGE_ID));
  if(!s.exists()){ alert("Siege not found."); history.back(); return null; }
  return s.data();
}

/* ---------- Build armies ---------- */
const MKEY = {
  recruits:"recruit", footmen:"footman", swordsmen:"swordsman", cavalry:"cavalry",
  archers:"archer", crossbowmen:"crossbowman", veteranArchers:"veteranArcher",
  monks:"monk", priests:"priest", mages:"mage",
  /* NEW */
  romanSergeants:"romanSergeant", romanChampions:"romanChampion",
  dragonKnights:"dragonKnight", venetianSaints:"venetianSaint"
};

function mkUnit(type, owner, gx, gy){
  const base=TYPES[type];
  return {
    id: owner.slice(0,2).toUpperCase() + "-" + Math.random().toString(36).slice(2,7),
    tt:type, o:owner,
    gx, gy,
    hp: base.hp, maxHp: base.hp,
    dmg: base.dmg, rangeTiles: base.rangeTiles, atkSpd: base.atkSpd, moveSpd: base.moveSpd,
    armor: base.armor, acd:{}, _aura:null, _channel:null, _charge:null, _hold:false,
    goalGX:null, goalGY:null, nextStepAt:0, axisPref:(Math.random()<.5)?"x":"y",
    priestHealMul: 1, _lastBy:null
  };
}

function spawnPlayerArmy(units, owner, army, origin){
  const order = [
    "recruits","footmen","swordsmen",
    "romanSergeants","romanChampions","dragonKnights","venetianSaints",
    "cavalry","archers","crossbowmen","veteranArchers","monks","priests","mages"
  ];
  const pool=[];
  for(const key of order){
    const typeId=MKEY[key]; if(!typeId) continue;
    const n=Math.max(0, parseInt(army[key]||0,10));
    for(let i=0;i<n;i++) pool.push(typeId);
  }
  let row=0,col=0, perRow=12;
  for(const typeId of pool){
    const gx = clamp(origin.gx + col,0,GRID_W-1);
    const gy = clamp(origin.gy + row,0,GRID_H-1);
    units.push(mkUnit(typeId, owner, gx, gy));
    col++; if(col>=perRow){ col=0; row++; }
  }
}

function defenderComposition(n){
  const W = { footman:.22, swordsman:.10, archer:.22, crossbowman:.08, veteranArcher:.06, monk:.10, priest:.10, mage:.12 };
  const base={}; let total=0; const floors={}, remainders=[];
  for(const k of Object.keys(W)){
    const raw=n * W[k]; const f=Math.floor(raw);
    floors[k]=f; base[k]=f; total+=f; remainders.push({k, frac: raw - f});
  }
  let rem = Math.max(0, n - total);
  remainders.sort((a,b)=>b.frac - a.frac);
  let i=0; while(rem>0){ base[remainders[i%remainders.length].k]++; rem--; i++; }
  return base;
}

function spawnDefenders(units, n){
  const counts = defenderComposition(n);
  const rowsY = [
    Math.floor(GRID_H*0.18),
    Math.floor(GRID_H*0.35),
    Math.floor(GRID_H*0.52),
    Math.floor(GRID_H*0.69),
    Math.floor(GRID_H*0.86)
  ];
  const origins = rowsY.map((gy,i)=>({ gx: WALL_X+6 + (i%2?3:0), gy: gy-6 }));
  const order = ["footman","swordsman","archer","crossbowman","veteranArcher","monk","priest","mage"];
  let oidx=0;
  for(const typeId of order){
    let left = counts[typeId]||0; if(left<=0) continue;
    while(left>0){
      const take = Math.min(left, 16);
      const org = origins[oidx % origins.length]; oidx++;
      let row=0,col=0, perRow=8;
      for(let i=0;i<take;i++){
        const gx = clamp(org.gx + col, 0, GRID_W-1);
        const gy = clamp(org.gy + row, 0, GRID_H-1);
        const u = mkUnit(typeId, "Defenders", gx, gy);
        u._hold = true; // hold until wall falls
        units.push(u);
        col++; if(col>=perRow){ col=0; row++; }
      }
      left -= take;
    }
  }
  for(const p of BALLISTA_POS){
    const b = mkUnit("ballista", "Defenders", p.gx, p.gy);
    b._hold = true;
    units.push(b);
  }
  for(const p of WALL_SEGMENT_POS){
    const w = mkUnit("wall","Defenders", p.gx, p.gy);
    w.hp = WALL.hp; w.maxHp = WALL.maxHp; w._hold = true;
    units.push(w);
  }
}

/* ---------- Occupancy / movement helpers ---------- */
function occupancy(units){ const m=new Map(); for(const u of units){ const k=u.gx+"|"+u.gy; if(!m.has(k)) m.set(k,[]); m.get(k).push(u);} return m; }
function occupiedOrReserved(gx,gy, occ, reserved){ return occ.has(gx+"|"+gy) || reserved.has(gx+"|"+gy); }
function moveTo(u, gx, gy, occ, reserved){
  const fromK = u.gx+"|"+u.gy; const list = occ.get(fromK)||[]; const idx=list.indexOf(u);
  if(idx>=0){ list.splice(idx,1); if(!list.length) occ.delete(fromK); }
  u.gx=gx; u.gy=gy;
  const toK = gx+"|"+gy; (occ.get(toK)||occ.set(toK,[]).get(toK)).push(u); reserved.add(toK);
}
function neighborStepToward(u, goalGX, goalGY, occ, reserved){
  if(u.gx===goalGX && u.gy===goalGY) return null;
  const dx = goalGX - u.gx, dy = goalGY - u.gy;
  const cand = [
    {gx:u.gx+Math.sign(dx), gy:u.gy},
    {gx:u.gx, gy:u.gy+Math.sign(dy)},
  ];
  cand.sort((a,b)=>{
    const pa = (u.axisPref==="x" ? (a.gx!==u.gx?0:1) : (a.gy!==u.gy?0:1));
    const pb = (u.axisPref==="x" ? (b.gx!==u.gx?0:1) : (b.gy!==u.gy?0:1));
    return pa - pb;
  });
  let best=null, bd=1e9;
  for(const c of cand){
    if(c.gx<0||c.gy<0||c.gx>=GRID_W||c.gy>=GRID_H) continue;
    if(isWallBlocking(u, c.gx, c.gy)) continue;
    const k=c.gx+"|"+c.gy;
    if(occ.has(k) || reserved.has(k)) continue;
    const d = manh(c.gx,c.gy, goalGX, goalGY);
    if(d<bd){ bd=d; best=c; }
  }
  return best;
}
function nearestFree(gx,gy, occ){
  const seen = new Set([gx+"|"+gy]); const q=[{gx,gy}]; let qi=0;
  while(qi<q.length && q.length<GRID_W*GRID_H){
    const cur=q[qi++], neigh=[[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dx,dy] of neigh){
      const nx=cur.gx+dx, ny=cur.gy+dy;
      if(nx<0||ny<0||nx>=GRID_W||ny>=GRID_H) continue;
      const k=nx+"|"+ny; if(seen.has(k)) continue; seen.add(k);
      if(!occ.get(k) || occ.get(k).length===0) return {gx:nx,gy:ny};
      q.push({gx:nx,gy:ny});
    }
  }
  return null;
}

/* ---------- Orders ---------- */
function orderAttackMove(ids, gx, gy){
  const occ = occupancy(state.units);
  const reserved = new Set();
  let idx = 0;
  for (const u of state.units){
    if (!ids.includes(u.id) || u.o === "Defenders") continue;
    const ring = Math.ceil(Math.sqrt(ids.length));
    const ox = (idx % ring) - Math.floor(ring/2);
    const oy = Math.floor(idx / ring) - Math.floor(ring/2);
    const desired = nearestOpenAround(gx+ox, gy+oy, occ, reserved) || nearestOpenAround(gx, gy, occ, reserved) || {gx,gy};
    u.goalGX=desired.gx; u.goalGY=desired.gy;
    reserved.add(desired.gx+"|"+desired.gy);
    idx++;
  }
  commandMarkers.push({gx,gy,until:Date.now()+1200});
}
function orderFocus(ids, targetId){
  const t = state.units.find(x=>x.id===targetId);
  if(!t) return;
  for (const u of state.units){ if (ids.includes(u.id) && u.o !== "Defenders"){ u.goalGX=t.gx; u.goalGY=t.gy; } }
}
function orderNearest(ids){
  for (const u of state.units){
    if (!ids.includes(u.id) || u.o==="Defenders") continue;
    let best=null, bd=1e9;
    for(const v of state.units){ if(v.o===u.o) continue; const d=manh(u.gx,u.gy,v.gx,v.gy); if(d<bd){ bd=d; best=v; } }
    if(best){ u.goalGX=best.gx; u.goalGY=best.gy; }
  }
}
function toggleHold(ids){
  for (const u of state.units){
    if (ids.includes(u.id) && u.o !== "Defenders"){
      u._hold = !u._hold;
      if(u._hold){ u.goalGX=null; u.goalGY=null; }
    }
  }
}

/* ---------- Abilities ---------- */
function updateCooldownBadges(){
  const abilEl=document.getElementById("abilities"); if(!abilEl) return;
  const sel=getUnitsView().filter(u=>selection.has(u.id));
  for(let s=1;s<=4;s++){
    const el=abilEl.querySelector(`[data-slot="${s}"]`); if(!el) continue;
    let allOnCd = sel.length>0, minRem = Infinity;
    for(const u of sel){ const rem = (u.acd?.[s]||0); if (rem<=0) allOnCd=false; if (rem>0 && rem<minRem) minRem=rem; }
    el.classList.toggle("oncd", allOnCd);
    let badge=el.querySelector(".cd-badge");
    if(allOnCd && isFinite(minRem)){
      const secs=Math.ceil(minRem);
      if(!badge){ badge=document.createElement("div"); badge.className="cd-badge"; el.appendChild(badge); }
      badge.textContent=`${secs}s`;
    } else if(badge){ badge.remove(); }
  }
}
setInterval(updateCooldownBadges, 200);

function slotAbility(slot){
  const sel=getUnitsView().filter(u=>selection.has(u.id));
  for(const u of sel){ const a=(TYPES[u.tt].abilities||[]).find(x=>x.slot===slot); if(a) return a; }
  return null;
}

/* Range text helper */
function rangeText(ab){ return (typeof ab.rangeTiles==="number") ? ` (range ${ab.rangeTiles})` : ""; }

const AbilityHandlers={
  brace:      { cast(g,u,ab,{mode},now){ if(mode!=="self")return false; u._aura={kind:"brace", until:now+ab.dur*1000}; return true; } },
  shieldwall: { cast(g,u,ab,{mode},now){ if(mode!=="self")return false; u._aura={kind:"shield",until:now+ab.dur*1000}; return true; } },
  focus:      { cast(g,u,ab,{mode},now){ if(mode!=="self")return false; u._aura={kind:"focus", until:now+ab.dur*1000, dmgUp:3}; return true; } },
  mend:       { cast(g,u,ab,{mode},now){ if(mode!=="self")return false; u._aura={kind:"mend",  until:now+ab.dur*1000, healPerSec:8*u.priestHealMul}; return true; } },

  /* NEW */
  rally:      { cast(g,u,ab,{mode},now){
                  if(mode!=="self") return false;
                  const until = now + (ab.dur||8)*1000;
                  const rad = ab.radiusTiles ?? 3;
                  for(const v of g.units){
                    if(v.o!==u.o) continue;
                    if(cheby(u.gx,u.gy,v.gx,v.gy) <= rad){
                      v._aura = { kind:"rally", until, speedMul:ab.speedMul||1.25, dmgMul:ab.dmgMul||1.25 };
                    }
                  }
                  g.effects.push({ type:"squareOnce", who:u.o, xgx:u.gx, xgy:u.gy, size:rad*2+1, when:now+120, did:false, until:now+600, color:"#7ccfff", dmg:0, pierce:0 });
                  return true;
               } },
  fury:       { cast(g,u,ab,{mode},now){ if(mode!=="self")return false; u._aura={kind:"fury", until:now+(ab.dur||5)*1000, atkSpdMul:ab.atkSpdMul||1.5}; return true; } },
  decapitate: { cast(g,u,ab,{mode,gx,gy},now){
                  const targ = g.units.find(v=> v.o!==u.o && v.gx===gx && v.gy===gy);
                  if(!targ) return false;
                  if(cheby(u.gx,u.gy,gx,gy) > (ab.rangeTiles||2)) return false;
                  applyDamage(g, targ, ab.dmg||100, ab.ap??1.0, u.o);
                  localFX.push({kind:"burst",gx:targ.gx,gy:targ.gy,until:Date.now()+400});
                  return true;
               } },
  healArea:   { cast(g,u,ab,{mode,gx,gy},now){
                  if(mode!=="point") return false;
                  g.effects.push({ type:"healSquareOnce", who:u.o, xgx:gx, xgy:gy, size:ab.size||3, when:now+120, did:false, until:now+600, color:"#98f5e1", heal:ab.heal||25 });
                  return true;
               } },

  volley:     { cast(g,u,ab,{mode,gx,gy},now){
                  if(mode!=="point")return false;
                  if(typeof ab.rangeTiles==="number" && cheby(u.gx,u.gy,gx,gy) > ab.rangeTiles) return false;
                  const size=ab.size||3; const until=now+(ab.channel||6000);
                  u._channel={kind:"volley",until};
                  g.effects.push({ type:"squarePulse", who:u.o, xgx:gx, xgy:gy, size, pulses:[now+700,now+2500,now+4300], next:0, until, color:"#bde3ff", dmg:10, pierce:0.15 });
                  return true;
               } },
  fireburst:  { cast(g,u,ab,{mode,gx,gy},now){
                  if(mode!=="point")return false;
                  if(typeof ab.rangeTiles==="number" && cheby(u.gx,u.gy,gx,gy) > ab.rangeTiles) return false;
                  g.effects.push({ type:"squareOnce", who:u.o, xgx:gx, xgy:gy, size:ab.size||2, when:now+120, did:false, until:now+600, color:"#f88", dmg:(ab.dmg||20), pierce:0.2 });
                  return true; } },
  arcaneBolt: { cast(g,u,ab,{mode,gx,gy},now){
                  const range=ab.rangeTiles||10, speed=ab.speedTiles||10, dmg=(ab.dmg||34), ap=ab.ap??0.5;
                  const path=bresenham(u.gx,u.gy,gx,gy).slice(1, range+1);
                  (g.projs=g.projs||[]).push({ type:"bolt", who:u.o, path, idx:0, speedTiles:speed, nextHopAt:Date.now(), hopMs:Math.max(40,Math.floor(1000/speed)), dmg, ap, color:"#baf" });
                  return true; } },
  pierceBolt: { cast(g,u,ab,{mode,gx,gy},now){
                  const range=ab.rangeTiles||10, speed=ab.speedTiles||10, dmg=(ab.dmg||28), ap=ab.ap??0.65;
                  const path=bresenham(u.gx,u.gy,gx,gy).slice(1, range+1);
                  (g.projs=g.projs||[]).push({ type:"bolt", who:u.o, path, idx:0, speedTiles:speed, nextHopAt:Date.now(), hopMs:Math.max(40,Math.floor(1000/speed)), dmg, ap, color:"#cde" });
                  return true; } },
  charge:     { cast(g,u,ab,{mode,gx,gy},now){ const path=bresenham(u.gx,u.gy,gx,gy).slice(1,6); u._charge = { path, idx:0, until:now+2500 }; return true; } },
};

function castSlot(slot){
  const ids=Array.from(selection); if(!ids.length) return;
  const ab=slotAbility(slot); if(!ab){ flash("No ability on this slot for selection"); return; }

  if(ab.target==="self"){
    let casted=false;
    for(const u of state.units){
      if(!ids.includes(u.id) || u.o==="Defenders") continue;
      if((u.acd?.[ab.slot]||0) > 0) continue;
      if(AbilityHandlers[ab.id]?.cast(state,u,ab,{mode:"self"},Date.now())){ u.acd[ab.slot]=ab.cd; casted=true; }
    }
    if(casted) fxRingOnSelection(); else flash("‚è≥ All selected are on cooldown");
  }else{
    targeting={slot:ab.slot,ab,ids};
    showHint(`üéØ ${ab.label}${rangeText(ab)}: click a tile (Esc cancel)`);
    const once=(e)=>{
      if(e.button!==0){ cv.removeEventListener("click", once); hideHint(); targeting=null; return;}
      const {gx,gy}=worldToGrid(mouse.worldX,mouse.worldY);

      let any=false;
      for(const u of state.units){
        if(!ids.includes(u.id) || u.o==="Defenders") continue;
        if((u.acd?.[ab.slot]||0) > 0) continue;
        if(typeof ab.rangeTiles==="number" && cheby(u.gx,u.gy,gx,gy) > ab.rangeTiles) continue;
        if(AbilityHandlers[ab.id]?.cast(state,u,ab,{mode:"point",gx,gy},Date.now())){ u.acd[ab.slot]=ab.cd; any=true; }
      }
      if(!any){
        if(typeof ab.rangeTiles==="number") flash(`‚ùå Out of range (max ${ab.rangeTiles})`);
        else flash("‚è≥ All selected are on cooldown");
      } else {
        fxTile(gx,gy);
      }
      hideHint(); targeting=null;
      cv.removeEventListener("click", once);
    };
    cv.addEventListener("click", once);
  }
}
function fxRingOnSelection(){ for(const u of getUnitsView().filter(u=>selection.has(u.id))){ localFX.push({kind:"ring",gx:u.gx,gy:u.gy,color:"#9bf",until:Date.now()+550}); } }
function fxTile(gx,gy){ localFX.push({kind:"tile",gx,gy,color:"#aef",until:Date.now()+700}); }

/* ---------- Geometry helpers ---------- */
function bresenham(x0,y0,x1,y1){
  const pts=[]; let dx=Math.abs(x1-x0), sx=x0<x1?1:-1; let dy=-Math.abs(y1-y0), sy=y0<y1?1:-1; let err=dx+dy, x=x0,y=y0;
  while(true){ pts.push({gx:x,gy:y}); if(x===x1&&y===y1) break; const e2=2*err; if(e2>=dy){ err+=dy; x+=sx; } if(e2<=dx){ err+=dx; y+=sy; } }
  return pts;
}

/* ---------- Damage & Healing ---------- */
function applyDamage(g, target, dmg, ap, owner){
  const baseArmor=(TYPES[target.tt].armor||0);
  const auraArmor = (target._aura?.kind==="shield"?3:0) + (target._aura?.kind==="brace"?2:0);
  const totalArmor = baseArmor + auraArmor;
  const effArmor = Math.max(0, totalArmor - totalArmor*(ap||0));
  const hit = Math.max(1, Math.round(dmg - effArmor));

  if(target.tt==="wall"){
    WALL.hp = Math.max(0, WALL.hp - hit);
    for(const w of g.units){ if(w.tt==="wall") w.hp = WALL.hp; }
    if(WALL.hp<=0 && WALL.alive){
      WALL.alive=false;
      for(const v of g.units){ if(v.o==="Defenders" && v.tt!=="wall"){ v._hold=false; } }
      localFX.push({kind:"tile",gx:WALL_X-1,gy:Math.floor(GRID_H/2),color:"#f90",until:Date.now()+900});
    }
    target._lastBy = owner;
    return;
  }

  target.hp -= hit;
  target._lastBy = owner;
  popupDmgAt(target, hit, "#ffb86b");
}
function applyHeal(target, amount){
  target.hp = Math.min(target.maxHp, target.hp + Math.max(0, amount|0));
}
function healSquare(g,cx,cy,size,owner,heal){
  const half=Math.floor(size/2);
  for(const v of g.units){
    if(v.o!==owner) continue;
    if(Math.abs(v.gx-cx)<=half && Math.abs(v.gy-cy)<=half){
      applyHeal(v, heal);
      localFX.push({kind:"tile",gx:v.gx,gy:v.gy,color:"#a7f3d0",until:Date.now()+300});
    }
  }
}

/* ---------- Helpers ---------- */
function getUnitsView(){ return state?.units || []; }
function nearestEnemy(u, ownerTag, list){
  let best=null, bd=1e9;
  for(const v of list){ if(v.o===ownerTag) continue; const d=manh(u.gx,u.gy,v.gx,v.gy); if(d<bd){ bd=d; best=v; } }
  return best;
}

/* ---------- Sim ---------- */
function inRange(u, v){
  const r=u.rangeTiles||1;
  return r>1 ? (cheby(u.gx,u.gy,v.gx,v.gy) <= r) : (manh(u.gx,u.gy,v.gx,v.gy) <= 1);
}

function simulate(g, dt){
  const now = Date.now();

  // cooldowns/auras
  for(const u of g.units){
    if(u.cd>0) u.cd = Math.max(0, u.cd - dt);
    for(const k in (u.acd||{})) u.acd[k] = Math.max(0, u.acd[k]-dt);
    if(u._aura && u._aura.until <= now) u._aura = null;
    if(u._aura?.kind==="mend") u.hp = Math.min(u.maxHp, u.hp + (u._aura.healPerSec||8)*dt);
    if(u._channel && u._channel.until <= now) u._channel = null;
  }
  g.effects = (g.effects||[]).filter(e=>e.until ? e.until > now : true);

  // projectiles
  {
    const keep=[];
    for(const pr of (g.projs||[])){
      if(pr.type==="bolt"){
        if(now>=pr.nextHopAt){
          const hops=1+Math.floor((now-pr.nextHopAt)/pr.hopMs);
          pr.nextHopAt+=hops*pr.hopMs;
          pr.idx=Math.min(pr.idx+hops, pr.path.length-1);
        }
        const tile=pr.path[pr.idx]||pr.path[pr.path.length-1];
        let hit=null;
        for(const u of g.units){ if(u.o===pr.who) continue; if(u.gx===tile.gx&&u.gy===tile.gy){hit=u;break;} }
        if(hit){ applyDamage(g,hit,pr.dmg,pr.ap||0.5,pr.who); continue; }
        if(pr.idx<pr.path.length-1) keep.push(pr);
      } else keep.push(pr);
    }
    g.projs = keep;
  }

  // effects
  for(const e of (g.effects||[])){
    if(e.type==="squarePulse"){
      while(e.next<e.pulses.length && now>=e.pulses[e.next]){ pulseSquare(g,e.xgx,e.xgy,e.size,e.who,e.dmg,e.pierce||0,true); e.next++; }
    }
    if(e.type==="squareOnce"){
      if(!e.did && now>=e.when){ pulseSquare(g,e.xgx,e.xgy,e.size,e.who,e.dmg,e.pierce||0,true); e.did=true; }
    }
    if(e.type==="healSquareOnce"){
      if(!e.did && now>=e.when){ healSquare(g,e.xgx,e.xgy,e.size,e.who,e.heal||25); e.did=true; }
    }
  }
  function pulseSquare(g,cx,cy,size,owner,dmg,pierce,withFX){
    const half=Math.floor(size/2);
    for(const v of g.units){
      if(v.o===owner) continue;
      if(Math.abs(v.gx-cx)<=half && Math.abs(v.gy-cy)<=half){
        applyDamage(g, v, dmg, pierce||0, owner);
        if(withFX){ localFX.push({kind:"burst",gx:v.gx,gy:v.gy,until:Date.now()+280}); }
      }
    }
  }

  const occ  = occupancy(g.units);
  const reserved = new Set();

  // Charge movement + impact
  for(const u of g.units){
    if(u._channel) continue;
    if(u._charge && u._charge.until > now){
      const step = u._charge.path[u._charge.idx];
      if(step){
        if(!isWallBlocking(u, step.gx, step.gy) && !occupiedOrReserved(step.gx,step.gy, occ, reserved)){
          moveTo(u, step.gx, step.gy, occ, reserved);
          u._charge.idx++;
        }else{
          u._charge.until = now;
        }
      }else{
        u._charge.until = now;
      }
      if(!u._charge || u._charge.idx>= (u._charge.path?.length||0)){
        const DMG=14;
        for(const v of g.units){
          if(v.o===u.o) continue;
          if(manh(u.gx,u.gy,v.gx,v.gy)<=1){
            applyDamage(g, v, DMG, 0, u.o);
          }
        }
      }
    }
  }

  // Targeting & attacks (with auras)
  for(const u of g.units){
    if(u._channel) continue;

    let target = nearestEnemy(u, u.o, g.units);
    const tSpec=TYPES[u.tt];
    const rng=tSpec.rangeTiles||1;
    const inR = target && (rng>1 ? cheby(u.gx,u.gy,target.gx,target.gy)<=rng : manh(u.gx,u.gy,target.gx,target.gy)<=1);

    if(inR && u.cd<=0 && target){
      if(tSpec.boltDmg){
        const range=rng, speed=tSpec.boltSpeedTiles||9, dmg=tSpec.boltDmg, ap=tSpec.boltAP||0.3;
        const path=bresenham(u.gx,u.gy,target.gx,target.gy).slice(1, range+1);
        (g.projs=g.projs||[]).push({ type:"bolt", who:u.o, path, idx:0, speedTiles:speed, nextHopAt:Date.now(), hopMs:Math.max(60,Math.floor(1000/speed)), dmg, ap, color:"#ffa55b" });
        u.cd = Math.max(.05, 1/(u.atkSpd||0.25));
      } else {
        const baseD = (u.dmg||5) + (u._aura?.dmgUp||0);
        const dmg = Math.round(baseD * (u._aura?.dmgMul || 1));
        applyDamage(g, target, dmg, 0, u.o);
        const effAtk = Math.max(0.1, (u.atkSpd||1) * (u._aura?.atkSpdMul || 1));
        u.cd = Math.max(.05, 1/effAtk);
      }
    }

    if(u._hold) continue;

    if(target && !inR){
      const bd = manh(u.gx,u.gy,target.gx,target.gy);
      if(bd <= AGGRO_TILES && (u.goalGX==null || u.goalGY==null)){
        u.goalGX = target.gx; u.goalGY = target.gy;
      }
    }
  }

  // Movement (respect rally/brace)
  for(const u of g.units){
    if(u._channel) continue;
    if(u.goalGX==null || u.goalGY==null) continue;
    const speedSquares = Math.max(0.5,(u.moveSpd||200))*PX_TO_SQUARES_PER_SEC*(u._aura?.kind==="brace"?0.75:1)*(u._aura?.speedMul||1);
    const stepEveryMs  = Math.max(80, Math.floor(1000/Math.max(0.5,speedSquares)));
    if(now < u.nextStepAt) continue;
    u.nextStepAt = now + stepEveryMs;

    if(u.gx===u.goalGX && u.gy===u.goalGY){ u.goalGX=null; u.goalGY=null; continue; }

    const step = neighborStepToward(u, u.goalGX, u.goalGY, occ, reserved);
    if(step){ moveTo(u, step.gx, step.gy, occ, reserved); }
  }

  // Push out overlaps (gentle)
  const occ2 = occupancy(g.units);
  for(const [k, list] of occ2){
    if(list.length<=1) continue;
    const keep = list[0];
    for(let i=1;i<list.length;i++){
      const u = list[i];
      const free = nearestFree(u.gx,u.gy, occ2);
      if(free && !isWallBlocking(u, free.gx, free.gy)){
        u.gx=free.gx; u.gy=free.gy;
        const nk=free.gx+"|"+free.gy; occ2.set(nk,(occ2.get(nk)||[]).concat(u));
      }
    }
    occ2.set(k,[keep]);
  }

  // deaths/stat keeping
  const survivors=[]; const deaths=[];
  for(const u of g.units){ if(u.hp>0) survivors.push(u); else deaths.push(u); }
  if(deaths.length){
    g.stats = g.stats || {};
    if(!g.stats.Attackers) g.stats.Attackers={killsByType:{}, lostByType:{}};
    if(!g.stats.Defenders) g.stats.Defenders={killsByType:{}, lostByType:{}};
    for(const dead of deaths){
      const killer = dead._lastBy==="Defenders" ? "Defenders" : "Attackers";
      const victim = dead.o==="Defenders" ? "Defenders" : "Attackers";
      g.stats[victim].lostByType[dead.tt] = (g.stats[victim].lostByType[dead.tt]||0)+1;
      if(killer){ g.stats[killer].killsByType[dead.tt] = (g.stats[killer].killsByType[dead.tt]||0)+1; }
    }
  }
  g.units = survivors;

  return g;
}

/* ---------- Picking / HUD ---------- */
function pickUnitAt(wx,wy, owner){
  const {gx,gy}=worldToGrid(wx,wy);
  for(const u of getUnitsView()){ if(owner && u.o!==owner) continue; if(u.gx===gx && u.gy===gy) return u; }
  return null;
}
function pickEnemyAt(wx,wy,myOwner){
  const {gx,gy}=worldToGrid(wx,wy);
  for(const u of getUnitsView()){ if(u.o===myOwner) continue; if(u.gx===gx && u.gy===gy) return u; }
  return null;
}
function pickInRect(x0,y0,x1,y1,owner){
  const out=[]; const g0=worldToGrid(x0,y0), g1=worldToGrid(x1,y1);
  const minGX=Math.min(g0.gx,g1.gx), maxGX=Math.max(g0.gx,g1.gx), minGY=Math.min(g0.gy,g1.gy), maxGY=Math.max(g0.gy,g1.gy);
  for(const u of getUnitsView()){ if(owner && u.o!==owner) continue; if(u.gx>=minGX&&u.gx<=maxGX&&u.gy>=minGY&&u.gy<=maxGY) out.push(u.id); }
  return out;
}
function renderHUD(){
  const abilEl=document.getElementById("abilities"); const selInfo=document.getElementById("selInfo");
  const sel=getUnitsView().filter(u=>selection.has(u.id));
  selInfo.innerHTML = sel.length ? `${sel.length} unit(s) selected ‚Äî <strong>A</strong>: nearest ‚Ä¢ <strong>H</strong>: hold` : "Select units";
  const slotMap=new Map();
  for(const u of sel){ for(const a of (TYPES[u.tt].abilities||[])){ if(!slotMap.has(a.slot)) slotMap.set(a.slot,{ name:a.label, key:a.key, emoji:TYPES[u.tt].emoji }); } }
  const keys={1:"Q",2:"W",3:"E",4:"R"}; abilEl.innerHTML="";
  for(let s=1;s<=4;s++){
    const spec=slotMap.get(s);
    const div=document.createElement("div"); div.className="slot"; div.dataset.slot=String(s);
    div.innerHTML = spec ? `<div class="emoji">${spec.emoji}</div><div class="name">${spec.name}</div><span class="key">${keys[s]}</span>` : `<div class="emoji">‚Äî</div><div class="name">‚Äî</div><span class="key">${keys[s]}</span>`;
    if(spec) div.onclick=()=>castSlot(s);
    abilEl.appendChild(div);
  }
  updateCooldownBadges();
}
function renderBoard(){
  const rows=document.getElementById("boardRows"); rows.innerHTML="";
  const counts={}; for(const u of getUnitsView()){ const tag = (u.o==="Defenders" ? "Defenders" : "Attackers"); counts[tag]=(counts[tag]||0)+1; }
  const ents=Object.entries(counts).sort((a,b)=>b[1]-a[1]||a[0].localeCompare(b[0]));
  for(const [name,c] of ents){
    const tint = name==="Defenders" ? COLOR_AI : COLOR_PLAYER;
    const d=document.createElement("div"); d.className="row";
    d.innerHTML=`<span style="color:${tint}">${name}</span><span>${c}</span>`;
    rows.appendChild(d);
  }
}

/* ---------- Input handlers ---------- */
window.addEventListener("mousemove",(e)=>{ const r=rect(viewEl); mouse.clientX=e.clientX; mouse.clientY=e.clientY; mouse.inViewport = e.clientX>=r.left && e.clientX<=r.right && e.clientY<=r.bottom && e.clientY>=r.top; });
cv.addEventListener("mousemove",(e)=>{ const r=rel(cv,e); mouse.inside=r.x>=0&&r.y>=0&&r.x<=r.w&&r.y<=r.h; mouse.x=r.x; mouse.y=r.y; mouse.worldX=cam.x+mouse.x; mouse.worldY=cam.y+mouse.y; });

cv.addEventListener("mousedown",(e)=>{
  if(e.button===2){
    e.preventDefault();
    const ids=Array.from(selection); if(!ids.length) return;
    const enemy = pickEnemyAt(mouse.worldX, mouse.worldY, "Attackers");
    if (enemy){ orderFocus(ids, enemy.id); }
    else { const {gx,gy}=worldToGrid(mouse.worldX,mouse.worldY); orderAttackMove(ids,gx,gy); }
    return;
  }
  dragging=true; dragStart={x:mouse.x,y:mouse.y};
});

window.addEventListener("mouseup",(e)=>{
  if(!dragging) return; dragging=false;
  const dx=mouse.x-dragStart.x, dy=mouse.y-dragStart.y, tiny=Math.hypot(dx,dy)<6;
  const now=performance.now();
  if(tiny){
    const grid=worldToGrid(mouse.worldX,mouse.worldY);
    const u = pickUnitAt(mouse.worldX,mouse.worldY, "Attackers");
    const dbl = (lastClickCell && lastClickCell.gx===grid.gx && lastClickCell.gy===grid.gy && (now-lastClickAt)<300);
    lastClickAt=now; lastClickCell=grid;
    if(u){
      if(dbl){ selection.clear(); for (const w of getUnitsView()){ if(w.o!=="Defenders" && w.tt===u.tt) selection.add(w.id); } }
      else { if(!e.shiftKey) selection.clear(); selection.add(u.id); }
      renderHUD();
    } else {
      if(!e.shiftKey) selection.clear();
      renderHUD();
    }
  }else{
    const minx=Math.min(dragStart.x,mouse.x)+cam.x, maxx=Math.max(dragStart.x,mouse.x)+cam.x;
    const miny=Math.min(dragStart.y,mouse.y)+cam.y, maxy=Math.max(dragStart.y,mouse.y)+cam.y;
    const ids = pickInRect(minx,miny,maxx,maxy, "Attackers");
    if(!e.shiftKey) selection.clear();
    ids.forEach(id=>selection.add(id));
    renderHUD();
  }
});
cv.addEventListener("contextmenu", e=>e.preventDefault());

function setBoxSelect(v){ mobileMode.boxSelect=v; const b=document.getElementById("btnBox"); if(b) b.classList.toggle("active", v); }
async function enterFullscreen(){ const root=document.querySelector('.frame'); try{ if(document.fullscreenElement) await document.exitFullscreen(); else await (root.requestFullscreen?.()||document.documentElement.requestFullscreen?.()); }catch(e){} }
(function setupMobileButtons(){
  const fs=document.getElementById("btnFS"), box=document.getElementById("btnBox"), cancel=document.getElementById("btnCancelSel");
  fs && fs.addEventListener('click', enterFullscreen);
  box && box.addEventListener('click', ()=> setBoxSelect(!mobileMode.boxSelect));
  cancel && cancel.addEventListener('click', ()=>{ selection.clear(); renderHUD(); });
})();

function handleTapCommand(wx, wy){
  const ids=Array.from(selection); if(!ids.length) return;
  const enemy=pickEnemyAt(wx,wy,"Attackers");
  if(enemy) orderFocus(ids, enemy.id);
  else { const {gx,gy}=worldToGrid(wx,wy); orderAttackMove(ids,gx,gy); }
}

cv.addEventListener('pointerdown',(e)=>{
  if(!isCoarse) return;
  cv.setPointerCapture(e.pointerId);
  const r=rel(cv,e); mouse.x=r.x; mouse.y=r.y; mouse.worldX=cam.x+r.x; mouse.worldY=cam.y+r.y;
  mobileMode.pointerDown=true; mobileMode.pointerMoved=false; mobileMode.panActive=false; mobileMode.justPanned=false;
  mobileMode.startWorld={x:mouse.worldX,y:mouse.worldY}; mobileMode.startClient={x:e.clientX,y:e.clientY};
  clearTimeout(mobileMode.holdTimer);
  mobileMode.holdTimer=setTimeout(()=>{ mobileMode.panActive=true; },180);
});
cv.addEventListener('pointermove',(e)=>{
  if(!isCoarse || !mobileMode.pointerDown) return;
  const dx=e.clientX-mobileMode.startClient.x, dy=e.clientY-mobileMode.startClient.y;
  if(Math.hypot(dx,dy)>8) mobileMode.pointerMoved=true;
  if(mobileMode.panActive){
    cam.x=clamp(cam.x-dx,0,WORLD.w-cv.width); cam.y=clamp(cam.y-dy,0,WORLD.h-cv.height);
    mobileMode.startClient={x:e.clientX,y:e.clientY}; mobileMode.justPanned=true;
  }
});
cv.addEventListener('pointerup',(e)=>{
  if(!isCoarse) return;
  clearTimeout(mobileMode.holdTimer);
  const r=rel(cv,e); const wx=cam.x+r.x, wy=cam.y+r.y;
  const unit=pickUnitAt(wx,wy,"Attackers");
  if(mobileMode.panActive || mobileMode.justPanned){ mobileMode.pointerDown=false; mobileMode.panActive=false; return; }
  if(unit){ selection.clear(); selection.add(unit.id); renderHUD(); mobileMode.pointerDown=false; return; }
  if(mobileMode.boxSelect){
    const x0=Math.min(mobileMode.startWorld.x,wx), x1=Math.max(mobileMode.startWorld.x,wx), y0=Math.min(mobileMode.startWorld.y,wy), y1=Math.max(mobileMode.startWorld.y,wy);
    const ids=pickInRect(x0,y0,x1,y1,"Attackers"); selection.clear(); ids.forEach(id=>selection.add(id)); renderHUD();
  }else handleTapCommand(wx,wy);
  mobileMode.pointerDown=false;
});

window.addEventListener("keydown",(e)=>{
  const k=e.key.toLowerCase();
  if(k==="escape"){ targeting=null; hideHint(); }
  if(["q","w","e","r"].includes(k)){ e.preventDefault(); castSlot({q:1,w:2,e:3,r:4}[k]); }
  if(k==="a"){ e.preventDefault(); const ids=Array.from(selection); if(!ids.length) return; orderNearest(ids); }
  if(k==="h"){ e.preventDefault(); const ids=Array.from(selection); if(!ids.length) return; toggleHold(ids); }
});

/* ---------- Draw ---------- */
function roundedRectPath(ctx, x, y, w, h, r){
  const rr=Math.min(r,w/2,h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  ctx.closePath();
}

function draw(){
  const dt=16/1000;

  // edge pan
  let vx=0,vy=0;
  const marginX=60, marginTop=80, marginBot=160;
  if(mouse.inViewport){
    if(mouse.x<=marginX) vx-=1; else if(mouse.x>=cv.width-marginX) vx+=1;
    if(mouse.y<=marginTop) vy-=1; else if(mouse.y>=cv.height-marginBot) vy+=1;
  }
  cam.x += vx*cam.speed*dt; cam.y += vy*cam.speed*dt; clampCam();

  ctx.fillStyle="#0d1020"; ctx.fillRect(0,0,cv.width,cv.height);
  // grid
  ctx.strokeStyle="rgba(255,255,255,.06)"; ctx.lineWidth=1;
  for(let x=-cam.x%(TILE*4); x<cv.width; x+=TILE*4){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cv.height); ctx.stroke(); }
  for(let y=-cam.y%(TILE*4); y<cv.height; y+=TILE*4){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cv.width,y); ctx.stroke(); }

  // wall
  if(WALL.alive){
    const sx=WALL_X*TILE - cam.x;
    ctx.fillStyle="#4c596b"; ctx.globalAlpha=.95; ctx.fillRect(sx, 0 - cam.y, TILE, WORLD.h);
    const wx=sx + TILE/2, wy=20 - cam.y;
    const frac=Math.max(0,Math.min(1, WALL.hp/WALL.maxHp));
    ctx.globalAlpha=1;
    ctx.fillStyle="#e2e8f0"; ctx.textAlign="center"; ctx.font="12px system-ui";
    ctx.fillText(`Wall ${WALL.hp}/${WALL.maxHp}`, wx, wy);
    ctx.fillStyle="#111827"; ctx.fillRect(wx-40, wy+8, 80, 6);
    ctx.fillStyle=frac>0.5?"#35d07f":(frac>0.25?"#ffd166":"#ff6b6b");
    ctx.fillRect(wx-40, wy+8, 80*frac, 6);
  }

  // effects
  for(const e of (state?.effects||[])){
    const size=e.size||2, half=Math.floor(size/2);
    const sx=(e.xgx-half)*TILE - cam.x, sy=(e.xgy-half)*TILE - cam.y;
    ctx.save();
    ctx.globalAlpha=.18; ctx.fillStyle=e.color||"#fff"; ctx.fillRect(sx,sy,size*TILE,size*TILE);
    ctx.globalAlpha=1; ctx.lineWidth=3; ctx.strokeStyle=e.color||"#fff"; ctx.strokeRect(sx,sy,size*TILE,size*TILE);
    ctx.restore();
  }

  // projectiles
  for(const p of (state?.projs||[])){
    if(p.type==="bolt"){
      const step = p.path[Math.min(p.idx, p.path.length-1)] || p.path[p.path.length-1];
      const sx=step.gx*TILE - cam.x, sy=step.gy*TILE - cam.y;
      ctx.globalAlpha=.95; ctx.fillStyle=p.color||"#baf";
      ctx.fillRect(sx+TILE*.25, sy+TILE*.25, TILE*.5, TILE*.5);
      ctx.globalAlpha=1;
    }
  }

  // units
  ctx.textAlign="center"; ctx.textBaseline="middle";
  for(const u of getUnitsView()){
    const team = (u.o==="Defenders") ? COLOR_AI : COLOR_PLAYER;
    const sx=u.gx*TILE + TILE/2 - cam.x, sy=u.gy*TILE + TILE/2 - cam.y;
    const w=TILE*.96, h=TILE*.96, x0=sx-w/2, y0=sy-h/2;

    ctx.save(); ctx.shadowColor="rgba(0,0,0,.7)"; ctx.shadowBlur=14; ctx.shadowOffsetY=3;
    roundedRectPath(ctx,x0,y0,w,h,8); ctx.fillStyle="#fff"; ctx.fill(); ctx.restore();

    roundedRectPath(ctx,x0,y0,w,h,8); ctx.lineWidth=3; ctx.strokeStyle=team; ctx.stroke();
    ctx.fillStyle=team+"66"; roundedRectPath(ctx,x0+4,y0+4,w-8, Math.max(10,Math.floor(TILE*.18)), 6); ctx.fill();

    ctx.font="24px system-ui"; ctx.fillStyle="#0a0a0a"; ctx.fillText(TYPES[u.tt].emoji, sx, sy+2);

    if(selection.has(u.id) && u.o!=="Defenders"){ ctx.save(); ctx.shadowColor="#fff"; ctx.shadowBlur=14; roundedRectPath(ctx,x0,y0,w,h,8); ctx.lineWidth=2; ctx.strokeStyle="#fff"; ctx.stroke(); ctx.restore(); }

    // HP bar
    const maxHp=(TYPES[u.tt].hp||1);
    const hpFrac=Math.max(0,Math.min(1,u.hp / maxHp));
    const barPad=8, barW=w-barPad*2, barH=6, barX=x0+barPad, barY=y0+h-barPad-barH;
    ctx.fillStyle="#e7e7e7"; roundedRectPath(ctx,barX,barY,barW,barH,3); ctx.fill();
    ctx.fillStyle = hpFrac>0.5? "#35d07f" : (hpFrac>0.25? "#ffd166" : "#ff6b6b");
    roundedRectPath(ctx,barX,barY,barW*hpFrac,barH,3); ctx.fill();

    if(u._channel){ ctx.save(); ctx.globalAlpha=.45; ctx.strokeStyle="#bde3ff"; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(sx,sy,TILE*.45,0,Math.PI*2); ctx.stroke(); ctx.restore(); }
  }

  // local fx
  for(let i=localFX.length-1;i>=0;i--){
    const fx=localFX[i]; const rem=fx.until-Date.now(); if(rem<=0){ localFX.splice(i,1); continue; }
    const a=Math.max(0, Math.min(1, rem/600));
    if(fx.kind==="ring"){ const cx=fx.gx*TILE + TILE/2 - cam.x, cy=fx.gy*TILE + TILE/2 - cam.y; ctx.save(); ctx.globalAlpha=.2+.6*a; ctx.strokeStyle=fx.color||"#9bf"; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(cx,cy,TILE*.45*(1+0.15*(1-a)),0,Math.PI*2); ctx.stroke(); ctx.restore(); }
    if(fx.kind==="tile"){ const sx=(fx.gx)*TILE - cam.x, sy=(fx.gy)*TILE - cam.y; ctx.save(); ctx.globalAlpha=.22+.3*a; ctx.fillStyle=fx.color||"#aef"; ctx.fillRect(sx,sy,TILE,TILE); ctx.restore(); }
    if(fx.kind==="burst"){ const cx=fx.gx*TILE + TILE/2 - cam.x, cy=fx.gy*TILE + TILE/2 - cam.y; ctx.save(); ctx.globalAlpha=.65*a; ctx.lineWidth=2; ctx.strokeStyle="#fff"; ctx.beginPath(); ctx.moveTo(cx-6,cy); ctx.lineTo(cx+6,cy); ctx.moveTo(cx,cy-6); ctx.lineTo(cx,cy+6); ctx.stroke(); ctx.restore(); }
  // local fx
for (let i = localFX.length - 1; i >= 0; i--) {
  const fx = localFX[i];
  const rem = fx.until - Date.now();
  if (rem <= 0) { localFX.splice(i, 1); continue; }

  const a = Math.max(0, Math.min(1, rem / (fx.dur || 600))); // 1‚Üí0 over life

  if (fx.kind === "ring") {
    // (existing)
  }
  if (fx.kind === "tile") {
    // (existing)
  }
  if (fx.kind === "burst") {
    // (existing)
  }

  // NEW: damage text
  if (fx.kind === "dmg") {
    const t = 1 - a; // 0‚Üí1 over life
    const cx = fx.gx * TILE + TILE / 2 - cam.x;
    const cy = fx.gy * TILE - cam.y; // start just above the unit
    const y  = cy - 8 - 28 * t;      // float upward

    ctx.save();
    ctx.globalAlpha = 0.9 * (1 - t * 0.7);
    ctx.font = "bold 18px system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";

    // outline for readability
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(0,0,0,.75)";
    ctx.strokeText(fx.text, cx, y);

    // fill
    ctx.fillStyle = fx.color || "#ff4d4d";
    ctx.fillText(fx.text, cx, y);
    ctx.restore();
  }
}

  }

  // command markers
  for(let i=commandMarkers.length-1;i>=0;i--){
    const m=commandMarkers[i];
    if(Date.now()>m.until){ commandMarkers.splice(i,1); continue; }
    const cx=m.gx*TILE+TILE/2-cam.x, cy=m.gy*TILE+TILE/2-cam.y;
    ctx.save(); ctx.strokeStyle="#9bf"; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(cx,cy,14,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx,cy-18); ctx.lineTo(cx+6,cy-8); ctx.lineTo(cx-6,cy-8); ctx.closePath(); ctx.fillStyle="#9bf"; ctx.fill(); ctx.restore();
  }

  // drag box
  if(dragging){ const x=Math.min(dragStart.x,mouse.x), y=Math.min(dragStart.y,mouse.y), w=Math.abs(mouse.x-dragStart.x), h=Math.abs(mouse.y-dragStart.y); ctx.strokeStyle="#9bf"; ctx.lineWidth=1.5; ctx.strokeRect(x,y,w,h); }

  renderBoard(); updateCooldownBadges();
  requestAnimationFrame(draw);
}

/* ---------- Win/Lose + settle ---------- */
function aliveOwners(){
  const tags={ Attackers:false, Defenders:false };
  for(const u of (state?.units||[])){
    if(u.o==="Defenders") tags.Defenders=true; else tags.Attackers=true;
    if(tags.Attackers && tags.Defenders) break;
  }
  return Object.entries(tags).filter(([,v])=>v).map(([k])=>k);
}

async function tryFinalizeSiege(attackerWon){
  if(!SIEGE_ID || !siege) return;
  try{
    await runTransaction(db, async (tx)=>{
      const sRef = moDoc("sieges", SIEGE_ID);
      const cRef = moDoc("castles", siege.castleId);
      const sSnap = await tx.get(sRef);
      if(!sSnap.exists()) return;
      const outcome = { attackerWon, remainingGarrison: Math.max(0, state.units.filter(u=>u.o==="Defenders" && u.tt!=="wall" && u.tt!=="ballista").length) };
      tx.update(sRef, { status:"ended", outcome });
      const patch = { siegeId: null, garrison: outcome.remainingGarrison };
      if(attackerWon){
        patch.owner = ME;
        patch.ownerName = ME;
        patch.ownerAlly = sSnap.data().attackerAllyId || null;
        patch.ownerColor = sSnap.data().attackerAllyColor || "#60a5fa";
      }
      tx.update(cRef, patch);
    });
  }catch(e){}
}

async function settleAndExit(attackerWon){
  const stats = state?.stats || {};
  let goldGain=0;
  const myTag = "Attackers";
  for(const [tKill, nKill] of Object.entries(stats[myTag]?.killsByType||{})){ const tier = TIER[tKill] || 0; goldGain += (REWARD[tier]||0) * (nKill||0); }
  const lost = stats[myTag]?.lostByType || {};

  await runTransaction(db, async (tx)=>{
    const pref = moDoc("players", ME);
    const snap = await tx.get(pref); if(!snap.exists()) return;
    const me = snap.data();
    const army = {...(me.army||{})};
    for(const [tLost, nLost] of Object.entries(lost)){
      const mKey = Object.keys(MKEY).find(k=>MKEY[k]===tLost);
      if(!mKey) continue;
      const remove = Math.floor((nLost||0)/3);
      if(remove > 0) army[mKey] = Math.max(0, (army[mKey]||0) - remove);
    }
    tx.update(pref, { army, gold: (me.gold||0) + goldGain, active:true, inBattle:false, lastSeen: Date.now() });
  });

  await tryFinalizeSiege(attackerWon);
  location.href = `${RETURN_ROUTE}?username=${encodeURIComponent(ME)}`;
}

/* ---------- Game loop ---------- */
let lastTime=performance.now(), acc=0;
const FIXED = 1/20;
function loop(){
  const now=performance.now(); acc += Math.min(0.25,(now-lastTime)/1000); lastTime=now;
  while(acc>=FIXED){ state = simulate(state, FIXED); acc -= FIXED; }
  const alive = aliveOwners();
  if(alive.length===1){
    const attackerWon = (alive[0]==="Attackers");
    document.getElementById("banner").textContent = attackerWon ? "üèÜ Wall breached ‚Äî Castle Taken!" : "üíÄ Your army was repelled!";
    document.getElementById("banner").style.display="block";
    setTimeout(()=>settleAndExit(attackerWon), 1200);
    return;
  }
  requestAnimationFrame(loop);
}

/* ---------- Init ---------- */
(async function init(){
  resizeCanvas();
  updateDoc(moDoc("players", ME), { active:false, inBattle:true, lastSeen: Date.now() }).catch(()=>{});
  siege = await loadSiege(); if(!siege) return;

  ownerMods[ME] = bannerMods();

  const meSnap = await getDoc(moDoc("players", ME));
  if(!meSnap.exists()){ alert("Your profile was not found."); return; }

  const units=[];
  // Attackers: far left
  const originAtk = { gx: 6, gy: Math.floor(GRID_H/2) - 10 };
  spawnPlayerArmy(units, "Attackers", meSnap.data().army||{}, originAtk);

  // Defenders: behind wall
  const garrisonCount = Math.max(0, parseInt(siege.garrisonAtStart||0,10));
  spawnDefenders(units, garrisonCount);

  for(const u of units){
    u.cd=0; u.acd=u.acd||{}; u._aura=null; u._channel=null; u._charge=null;
    u.goalGX=null; u.goalGY=null; u.nextStepAt=0; u.axisPref=(Math.random()<.5)?"x":"y";
  }

  state = { units, effects:[], projs:[], stats: { Attackers:{killsByType:{},lostByType:{}}, Defenders:{killsByType:{},lostByType:{}} } };

  // Center camera on attacker formation
  const myUnits = units.filter(u=>u.o==="Attackers");
  const cx = myUnits.reduce((s,u)=>s+u.gx,0)/Math.max(1,myUnits.length);
  const cy = myUnits.reduce((s,u)=>s+u.gy,0)/Math.max(1,myUnits.length);
  cam.x = clamp(cx*TILE - cv.width/2, 0, WORLD.w-cv.width);
  cam.y = clamp(cy*TILE - cv.height/2, 0, WORLD.h-cv.height);
  clampCam();

  draw(); loop();
})();

/* ---------- Safety ---------- */
window.addEventListener("beforeunload", ()=>{
  updateDoc(moDoc("players", ME), { active:true, inBattle:false, lastSeen: Date.now() }).catch(()=>{});
});
</script>
</body>
</html>





