<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>🌿 Grass Realms — game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
  :root{ --bg:#f7f8fb; --ink:#1f2937; --muted:#6b7280; --card:#fff; --line:#e5e7eb; --accent:#2e7d32; }
  *{box-sizing:border-box}
  body{margin:0;font-family:Segoe UI,Arial,Helvetica,sans-serif;background:var(--bg);color:var(--ink)}
  header{display:flex;align-items:center;gap:8px;padding:10px 14px;border-bottom:1px solid var(--line);background:#fff;position:sticky;top:0;z-index:5}
  header .tag{font-size:12px;color:#fff;background:var(--accent);padding:2px 8px;border-radius:14px}
  main{padding:12px;display:grid;grid-template-columns:1fr 420px;gap:12px}
  .board{display:grid;grid-template-areas:"p0 p1" "p2 p3"; gap:12px;}
  .playerPanel{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:10px;min-height:220px;position:relative}
  .playerPanel .hdr{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
  .playerPanel .hdr .hp{font-weight:600}

  /* REPLACED: show tiles instead of one big emoji clump */
  .playerPanel .emojiClump{
    display:grid;
    grid-template-columns:repeat(auto-fill,minmax(90px,1fr));
    gap:8px;
    min-height:80px;
  }

  /* Per-card tiles */
  .tile{
    position:relative;
    border:1px solid var(--line);
    background:#fff;
    border-radius:10px;
    padding:6px 6px 8px 6px;
  }
  .tile .label{
    font-size:11px;
    color:var(--muted);
    text-align:center;
    line-height:1.1;
    margin-bottom:2px;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .tile .emj{
    font-size:24px;
    line-height:1.2;
    text-align:center;
  }
  .tile .meta{
    font-size:11px;
    color:var(--muted);
    text-align:center;
    margin-top:2px;
  }
  .tile .hp{
    position:absolute;
    top:4px; right:6px;
    font-size:10px;
    background:#eef7ee;
    color:#1b5e20;
    border-radius:6px;
    padding:1px 6px;
  }
  .tile .cnt{
    position:absolute;
    top:4px; left:6px;
    font-size:10px;
    background:#f1f5f9;
    color:#334155;
    border-radius:6px;
    padding:1px 6px;
  }

  .playerPanel .meta{font-size:12px;color:var(--muted)}
  .you{outline:2px solid #1976d2}
  .active{box-shadow:0 0 0 3px rgba(46,125,50,.35)}
  .rightCol{display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:12px}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .controls select, .controls button{padding:8px 10px;font-size:14px}
  .shopGrid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}
  .shopItem{border:1px solid var(--line);border-radius:10px;padding:8px}
  .shopItem h4{margin:0 0 4px 0;font-size:14px}
  .small{font-size:12px;color:var(--muted)}
  .targets{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
  .targets select{padding:6px 8px}
  .log{max-height:260px;overflow:auto;border:1px solid var(--line);border-radius:10px;background:#fff}
  .logLine{padding:6px 8px;border-bottom:1px dashed var(--line);font-size:13px}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#eef7ee;color:#1b5e20;font-size:12px}
  .queue{margin-top:8px;border-top:1px dashed var(--line);padding-top:8px}
  .qItem{font-size:12px;color:var(--muted);margin:2px 0}
  .needTarget{background:#fff7e6;border:1px solid #ffe0a3;padding:8px;border-radius:8px}
  .spacer{flex:1}
</style>

</head>
<body>
  <header>
    <strong>🌿 Grass Realms</strong>
    <span id="hdrLobby" class="tag" style="display:none"></span>
    <span id="hdrUser" class="tag" style="display:none"></span>
    <span id="hdrRole" class="tag" style="display:none"></span>
    <span class="spacer"></span>
    <span class="small" id="statusNote"></span>
  </header>

  <main>
    <section class="board" id="board">
      <div class="playerPanel" id="p0"></div>
      <div class="playerPanel" id="p1"></div>
      <div class="playerPanel" id="p2"></div>
      <div class="playerPanel" id="p3"></div>
    </section>

    <aside class="rightCol">
      <div class="card">
        <h3>Your Turn Controls</h3>
        <div class="controls">
  <label>Die:
    <select id="dieSelect"><option>d6</option></select>
  </label>
  <button id="rollBtn">🎲 Roll</button>
  <button id="resolveBtn">▶ Resolve Next (auto / no‑target)</button>
  <button id="applyTargetBtn">🎯 Apply Trigger (with target)</button>
  <button id="endTurnBtn">⏭ End Turn</button>
  <span id="lastRollBadge" class="pill" style="display:none;margin-left:8px"></span> <!-- NEW -->
</div>

        <div id="targetBox" class="targets"></div>
        <div id="queueBox" class="queue small"></div>

        <div style="margin-top:8px" class="small">
          Roll → resolve each trigger in order. If a trigger needs a target, choose player & item and click <b>Apply Trigger</b>.
          Walls protect <b>structures</b> (not troops). Opponent‑turn triggers fire on enemy rolls.
        </div>
      </div>

      <div class="card">
        <h3>Shop</h3>
        <div id="shop" class="shopGrid"></div>
      </div>

      <div class="card">
        <h3>Run Log</h3>
        <div id="log" class="log"></div>
      </div>
    </aside>
  </main>

  <script type="module">
    // -------- Firebase --------
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import {
      getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot, where,
      collection, addDoc, serverTimestamp, runTransaction, query, orderBy, limit, getDocs
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
      authDomain: "bible-game-246c0.firebaseapp.com",
      projectId: "bible-game-246c0",
      storageBucket: "bible-game-246c0.appspot.com",
      messagingSenderId: "959619818996",
      appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
    };
    const app = initializeApp(firebaseConfig);
    const db  = getFirestore(app);

    // -------- URL params from lobby redirect --------
    const qp = new URLSearchParams(location.search);
    const lobbyId = qp.get('gameId') || '';     // the lobby doc id
    const myName  = qp.get('username') || '';
    if (!lobbyId || !myName) {
      document.getElementById('statusNote').textContent = 'Missing gameId or username in URL.';
    }

    // -------- RNG --------
    function mulberry32(seed){ return function(){ let t = seed += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; } }

    // ---------- Catalog ----------
    const RAW_CARDS = [
      { 
  key:'townhall',
  name:'Town Hall',
  emoji:'🏰',
  type:'structure',
  cost:0,
  hp:50,
  max:1,
  triggers:[1,2,3,4,5,6],
  timing:'every',                 // fires on every roll (see timing fix below)
  onTrigger:{ kind:'earn', value:1 }, // instant income; no queue item
  immutable:true
},
      { key:'farm', name:'Farm', emoji:'🌾', type:'structure', cost:1, hp:2, max:3, triggers:[1,2], timing:'every', onTrigger:{kind:'earn', value:1} },
      { key:'mill', name:'Lumber Mill', emoji:'🪵', type:'structure', cost:2, hp:3, max:3, triggers:[3], timing:'every', onTrigger:{kind:'earn', value:3} },
      { key:'mine', name:'Mine', emoji:'⛏️', type:'structure', cost:3, hp:3, max:3, triggers:[4], timing:'every', onTrigger:{kind:'earn', value:3} },

      // Gray
      { key:'footman', name:'Footman', emoji:'🗡️', type:'troop', cost:2, hp:4, max:3, triggers:[3,4], timing:'every', onTrigger:{kind:'attack_any', value:1} },
      { key:'spy', name:'Spy', emoji:'🕵️', type:'troop', cost:2, hp:3, max:3, triggers:[5], timing:'opponent', onTrigger:{kind:'steal_fixed', value:2} },
      { key:'knight', name:'Knight', emoji:'🐴', type:'troop', cost:3, hp:6, max:3, triggers:[5], timing:'your', onTrigger:{kind:'attack_any', value:4} },
      { key:'wall_stone', name:'Stone Wall', emoji:'🧱', type:'wall', cost:3, hp:5, max:3, triggers:[], timing:null },
      { key:'archtwrX', name:'Archer Tower', emoji:'🏹', type:'structure', cost:5, hp:6, max:3, triggers:[3], timing:'your', onTrigger:{kind:'destroy_troop'} },
      { key:'trebuchet', name:'Trebuchet', emoji:'🏗️', type:'structure', cost:5, hp:7, max:3, triggers:[2], timing:'your', onTrigger:{kind:'destroy_structure_non_temple'} },

      // White
      { key:'white_temple', name:'White Temple', emoji:'🤍⛪', type:'structure', cost:4, hp:5, max:3, triggers:[6], timing:'your', onTrigger:{kind:'heal_town', value:3} },
      { key:'white_devotee', name:'Devotee', emoji:'🕯️', type:'troop', cost:3, hp:4, max:3, triggers:[4], timing:'every', requiresTemple:'white_temple', onTrigger:{kind:'earn_per_temple', temple:'white_temple', per:1} },
      { key:'white_recruiter', name:'Recruiter', emoji:'📜', type:'troop', cost:4, hp:5, max:3, triggers:[7], timing:'your', requiresTemple:'white_temple', onTrigger:{kind:'acquire_troop_cost_leq_temples', temple:'white_temple'} },
      { key:'white_scholar', name:'Scholar', emoji:'📚', type:'troop', cost:5, hp:5, max:3, triggers:[9], timing:'every', requiresTemple:'white_temple', onTrigger:{kind:'heal_and_earn', heal:3, coins:3} },
      { key:'white_paladin', name:'Paladin', emoji:'🛡️', type:'troop', cost:6, hp:8, max:3, triggers:[8], timing:'every', requiresTemple:'white_temple', onTrigger:{kind:'attack_any_and_heal', dmg:7, heal:3} },
      { key:'white_highpriest', name:'High Priest', emoji:'🙏', type:'troop', cost:7, hp:8, max:3, triggers:[11], timing:'every', requiresTemple:'white_temple', onTrigger:{kind:'attack_any_and_destroy_troop', dmg:5} },
      { key:'white_pylon', name:'Temple Pylon', emoji:'🗼', type:'wall', cost:4, hpDynamic:{perTemple:'white_temple', perHP:1}, max:3, triggers:[], timing:null },

      // Black
      { key:'black_temple', name:'Black Temple', emoji:'🖤⛪', type:'structure', cost:4, hp:5, max:3, triggers:[6], timing:'your', onTrigger:{kind:'each_other_lose_hp', value:1} },
      { key:'black_acolyte', name:'Acolyte', emoji:'🩸', type:'troop', cost:3, hp:4, max:3, triggers:[8], timing:'opponent', requiresTemple:'black_temple', onTrigger:{kind:'active_loses_per_temple', temple:'black_temple', per:2} },
      { key:'black_tithetaker', name:'Tithe Taker', emoji:'🧾', type:'troop', cost:4, hp:5, max:3, triggers:[5], timing:'every', requiresTemple:'black_temple', onTrigger:{kind:'lose_hp_gain_coins', lose:2, coins:3} },
      { key:'black_falseprophet', name:'False Prophet', emoji:'🗿', type:'troop', cost:5, hp:6, max:3, triggers:[11], timing:'every', requiresTemple:'black_temple', onTrigger:{kind:'others_sacrifice_cards_per_temple', temple:'black_temple'} },
      { key:'black_oathbreaker', name:'Oathbreaker', emoji:'🗡️🩸', type:'troop', cost:6, hp:7, max:3, triggers:[7], timing:'your', requiresTemple:'black_temple', onTrigger:{kind:'lose_then_attack_any', lose:1, dmg:8} },
      { key:'black_necromancer', name:'Necromancer', emoji:'💀', type:'troop', cost:8, hp:9, max:3, triggers:[9], timing:'every', requiresTemple:'black_temple', onTrigger:{kind:'destroy_troop'} },
      { key:'black_altar', name:'Altar', emoji:'⛓️', type:'structure', cost:5, hp:6, max:3, triggers:[], timing:'passive', passive:{altar:true} },

      // Red
      { key:'red_temple', name:'Red Temple', emoji:'🔴⛪', type:'structure', cost:4, hp:5, max:3, triggers:[6], timing:'your', onTrigger:{kind:'attack_any', value:2} },
      { key:'red_warrior', name:'Warrior', emoji:'🗡️', type:'troop', cost:3, hp:5, max:3, triggers:[7], timing:'your', requiresTemple:'red_temple', onTrigger:{kind:'attack_any', value:4} },
      { key:'red_raider', name:'Raider', emoji:'🏴‍☠️', type:'troop', cost:4, hp:5, max:3, triggers:[6], timing:'opponent', requiresTemple:'red_temple', onTrigger:{kind:'steal_and_make_sacrifice_farm', steal:1} },
      { key:'red_barbarian', name:'Barbarian', emoji:'🪓', type:'troop', cost:5, hp:7, max:3, triggers:[9], timing:'your', requiresTemple:'red_temple', onTrigger:{kind:'destroy_farm_and_damage_per_temple', temple:'red_temple', per:2} },
      { key:'red_ranger', name:'Ranger', emoji:'🏹', type:'troop', cost:6, hp:7, max:3, triggers:[7], timing:'every', requiresTemple:'red_temple', onTrigger:{kind:'damage_per_temple_and_gain', temple:'red_temple', per:1, coins:2} },
      { key:'red_warlord', name:'Warlord', emoji:'⚔️', type:'troop', cost:8, hp:10, max:3, triggers:[11,12], timing:'your', requiresTemple:'red_temple', onTrigger:{kind:'destroy_structure_and_attack_any', dmg:5} },
      { key:'red_fortress', name:'Fortress', emoji:'🏯', type:'structure', cost:7, hp:9, max:2, triggers:[], timing:'passive', passive:{fortress:true} },

      // Green
      { key:'green_temple', name:'Green Temple', emoji:'🟢⛪', type:'structure', cost:4, hp:5, max:3, triggers:[6], timing:'your', onTrigger:{kind:'earn', value:1} },
      { key:'green_shaman', name:'Shaman', emoji:'🌀', type:'troop', cost:3, hp:5, max:3, triggers:[5], timing:'every', requiresTemple:'green_temple', onTrigger:{kind:'earn', value:2} },
      { key:'green_sage', name:'Sage', emoji:'🌿', type:'troop', cost:4, hp:6, max:3, triggers:[7], timing:'every', requiresTemple:'green_temple', onTrigger:{kind:'heal_and_earn', heal:3, coins:3} },
      { key:'green_druid', name:'Druidic Warrior', emoji:'🧙‍♂️', type:'troop', cost:5, hp:8, max:3, triggers:[9], timing:'your', requiresTemple:'green_temple', onTrigger:{kind:'attack_any_per_temple', temple:'green_temple', per:2} },
      { key:'green_goliath', name:'Goliath', emoji:'🗿', type:'troop', cost:7, hp:12, max:2, triggers:[11,12], timing:'your', requiresTemple:'green_temple', onTrigger:{kind:'goliath_special'} },
      { key:'green_elemental', name:'Elemental', emoji:'🌪️', type:'troop', cost:8, hp:10, max:2, triggers:[9,10], timing:'your', requiresTemple:'green_temple', onTrigger:{kind:'gain_and_destroy_two_walls', coins:4} },
      { key:'green_livingwall', name:'Living Wall', emoji:'🌳', type:'wall', cost:6, hpDynamic:{perTemple:'green_temple', perHP:2}, max:3, triggers:[], timing:null },
    ];
    const CARD_CATALOG = {}; for (const c of RAW_CARDS){ CARD_CATALOG[c.key] = { ...c }; }
    const STARTERS = ['townhall','farm','mill'];

    // ---------- Helpers / UI ----------
    const $ = s=>document.querySelector(s);
    const logDiv = $('#log');
    function logLine(msg){ const d=document.createElement('div'); d.className='logLine'; d.textContent=msg; logDiv.appendChild(d); logDiv.scrollTop=logDiv.scrollHeight; }

    // ---------- Game State (stored in lobbies/{lobbyId}) ----------
    let me = { name: myName, idx: -1 };
    let state = null;
    let isHost = false;
    let rng = null;
    let unsubLobby = null, unsubIntents = null;

    // ---------- Rendering ----------
    function emojiClumpForPlayer(p){
      const owned = p.owned||[];
      const sorted = owned.slice().sort((a,b)=>(CARD_CATALOG[a.key]?.type||'').localeCompare(CARD_CATALOG[b.key]?.type||'')); 
      let s=''; for (const e of sorted){ const c=CARD_CATALOG[e.key]; if(!c) continue; const em=Array.from({length:e.count||1},()=>c.emoji).join(''); s+=`${em}${e.hp!=null?' ('+e.hp+')':''} `; }
      return s.trim();
    }
    function render(){
      const hdrLobby=$('#hdrLobby'), hdrUser=$('#hdrUser'), hdrRole=$('#hdrRole');
      hdrLobby.style.display=lobbyId?'':'none'; hdrLobby.textContent='Lobby: '+lobbyId;
      hdrUser.style.display=myName?'':'none'; hdrUser.textContent=myName;
      hdrRole.style.display=isHost?'':'none'; hdrRole.textContent='Host';

      const panels=[$('#p0'),$('#p1'),$('#p2'),$('#p3')]; panels.forEach(p=>{p.innerHTML=''; p.classList.remove('you','active');});
      if (!state) return;

      const players=state.players||[]; const turnIdx=state.turnIdx??0;
      players.forEach((p,i)=>{
        const panel=panels[i]; if (!panel) return;
        panel.classList.toggle('you',p.name===me.name); panel.classList.toggle('active',i===turnIdx);
        const hdr=document.createElement('div'); hdr.className='hdr';
        hdr.innerHTML=`<div><strong>${p.name}</strong> ${i===turnIdx?'<span class="pill">Active</span>':''}</div>
                       <div class="hp">💰 ${p.gold||0} | 🏰 ${p.townHp||0}</div>`;
        const cl=document.createElement('div'); cl.className='emojiClump';
renderOwnedTiles(cl, p);
        const mt=document.createElement('div'); mt.className='meta';
        mt.textContent=(p.unlocked==='d20'?'d20':p.unlocked==='2d6'?'2d6':'d6')+' unlocked';
        panel.appendChild(hdr); panel.appendChild(cl); panel.appendChild(mt);
      });

      renderControls(); renderShop(); renderQueueAndTargets();
    }
    function myPlayer(){ if (!state) return null; return (state.players||[]).find(p=>p.name===me.name)||null; }
    function isMyTurn(){ const p=myPlayer(); if (!p||!state) return false; return (state.players||[]).findIndex(x=>x.name===p.name)===(state.turnIdx??0); }
    function allowedDiceFor(player){ const u=player?.unlocked||'d6'; if (u==='d20') return ['d6','2d6','d20']; if (u==='2d6') return ['d6','2d6']; return ['d6']; }
    function renderOwnedTiles(container, player){
  container.innerHTML = '';
  const owned = player?.owned || [];
  for (let i=0; i<owned.length; i++){
    const e = owned[i];
    const c = CARD_CATALOG[e.key];
    if (!c) continue;

    const tile  = document.createElement('div'); tile.className='tile';
    const label = document.createElement('div'); label.className='label'; label.textContent = c.name;
    const emj   = document.createElement('div'); emj.className='emj';   emj.textContent = c.emoji;

    const rolls = (c.triggers && c.triggers.length) ? c.triggers.join(',') : '—';
    const meta  = document.createElement('div'); meta.className='meta'; meta.innerHTML = `🎲 ${rolls}`;

    // badges
    if (e.hp != null){
      const hp = document.createElement('div'); hp.className='hp'; hp.textContent = `HP ${e.hp}`;
      tile.appendChild(hp);
    }
    const count = e.count || 1;
    if (count > 1){
      const cnt = document.createElement('div'); cnt.className='cnt'; cnt.textContent = `x${count}`;
      tile.appendChild(cnt);
    }

    tile.appendChild(label);
    tile.appendChild(emj);
    tile.appendChild(meta);
    container.appendChild(tile);
  }
}

function renderControls(){
  const p = myPlayer();
  const dieSel = $('#dieSelect');

  if (!p){
    if (dieSel) dieSel.innerHTML = '<option>d6</option>';
    $('#rollBtn').disabled = true;
    $('#resolveBtn').disabled = true;
    $('#applyTargetBtn').disabled = true;
    $('#endTurnBtn').disabled = true;
    const lb = $('#lastRollBadge'); if (lb) lb.style.display='none';
    return;
  }

  if (dieSel){
    dieSel.innerHTML = allowedDiceFor(p).map(o=>`<option value="${o}">${o}</option>`).join('');
  }

  const isTurn   = isMyTurn();
  const phase    = state?.phase || 'await_roll';
  const resolving = (phase === 'resolving');

  // Look at the *current* queue item to decide if a target is needed
  let needsT = false;
  if (resolving){
    const cur = (state?.resolveQueue || [])[0];
    if (cur){
      const kind = CARD_CATALOG[cur.key]?.onTrigger?.kind;
      needsT = triggerNeedsTarget(kind);
    }
  }

  $('#rollBtn').disabled        = !isTurn || (phase !== 'await_roll');
  $('#resolveBtn').disabled     = !isTurn || !resolving || needsT;   // disabled if a target is needed
  $('#applyTargetBtn').disabled = !isTurn || !resolving || !needsT;  // enabled only when a target is needed
  $('#endTurnBtn').disabled     = !isTurn; // always available on your turn (with forfeit logic in handler)

  // Last roll badge
  const lb = $('#lastRollBadge');
  if (lb){
    if (state?.lastRoll?.value){
      lb.style.display = '';
      lb.textContent = `Last roll: ${state.lastRoll.value} (${state.lastRoll.mode})`;
    } else {
      lb.style.display = 'none';
    }
  }
}

    function renderShop(){
      const shop=$('#shop'); shop.innerHTML=''; const p=myPlayer(); if (!p) return;
      Object.values(CARD_CATALOG).forEach(card=>{
        if (card.immutable) return;
        if (card.requiresTemple){
          const hasTemple=(p.owned||[]).some(e=>e.key===card.requiresTemple);
          if (!hasTemple) return;
        }
        const have=(p.owned||[]).find(e=>e.key===card.key)?.count||0;
        const max=card.max??3; if (have>=max) return;

        const div=document.createElement('div'); div.className='shopItem';
        const trig = card.triggers?.length?(' | Roll: '+card.triggers.join(',')):''; 
        div.innerHTML=`<h4>${card.emoji} ${card.name}</h4>
          <div class="small">Cost: ${card.cost} | HP: ${card.hp ?? '—'}${trig}</div>
          <button ${( !isMyTurn() || state?.phase!=='buy' || (p.gold||0) < card.cost )?'disabled':''} data-key="${card.key}">Buy</button>`;
        div.querySelector('button').addEventListener('click', ()=>intentBuy(card.key));
        shop.appendChild(div);
      });
    }

    // ---------- Target UI ----------
    function triggerNeedsTarget(kind){
  return [
    'attack_any','attack_structure','attack_troop',
    'attack_any_and_heal','attack_any_and_destroy_troop',
    'destroy_troop','destroy_structure_non_temple',
    'destroy_structure_and_attack_any','lose_then_attack_any',
    'goliath_special','damage_per_temple_and_gain',
    'attack_any_per_temple','gain_and_destroy_two_walls' // NEW
  ].includes(kind);
}
function allowedTargetTypesFor(kind){
  switch(kind){
    // Troop attacks can hit walls directly now
    case 'attack_any':
    case 'attack_any_and_heal':
    case 'attack_any_per_temple':
    case 'lose_then_attack_any':
    case 'damage_per_temple_and_gain':
    case 'attack_any_and_destroy_troop':
      return ['wall','troop','structure','townhall'];

    case 'attack_structure':
      return ['wall','structure']; // structure-focused attacks already allowed walls

    case 'destroy_structure_non_temple':
      return ['structure']; // keep walls out for this destroy, per earlier rule

    case 'destroy_structure_and_attack_any':
      return ['structure']; // first target still a structure; second hit logic respects walls

    case 'attack_troop':
    case 'destroy_troop':
      return ['troop'];

    case 'goliath_special':
      return ['wall','troop','structure','townhall'];

    case 'gain_and_destroy_two_walls':
      return ['wall'];

    default:
      return [];
  }
}



    function listTargetableEntries(p, type){
      const owned=p.owned||[];
      if (type==='troop') return owned.map((e,idx)=>({idx, e, c:CARD_CATALOG[e.key]})).filter(x=>x.c?.type==='troop' && x.e.hp>0);
      if (type==='wall')  return owned.map((e,idx)=>({idx, e, c:CARD_CATALOG[e.key]})).filter(x=>x.c?.type==='wall' && x.e.hp>0);
      if (type==='structure') return owned.map((e,idx)=>({idx, e, c:CARD_CATALOG[e.key]})).filter(x=>x.c?.type==='structure' && x.e.key!=='townhall' && x.e.hp>0);
      return [];
    }
function renderQueueAndTargets(){
  const qb = $('#queueBox'); qb.innerHTML = '';
  const tb = $('#targetBox'); tb.innerHTML = '';
  if (!state) return;

  const q = state.resolveQueue || [];
  if (!q.length){
    qb.innerHTML = '<div class="small">No triggers pending.</div>';
    return;
  }

  const current = q[0];
  const owner   = (state.players || [])[current?.ownerIdx];
  const card    = CARD_CATALOG[current?.key];

  if (!current || !owner || !card){
    qb.innerHTML = '<div class="small">Waiting for next trigger…</div>';
    return;
  }

  // Header for current + a peek at the queue
  const title = document.createElement('div');
  title.innerHTML = `<div><b>Current trigger:</b> ${owner.name} — ${card.emoji} ${card.name}${current.roll ? ` (roll ${current.roll})` : ''}</div>`;
  qb.appendChild(title);

  if (q.length > 1){
    const ol = document.createElement('div'); ol.className = 'small';
    for (let i = 1; i < q.length; i++){
      const t = q[i], o = (state.players||[])[t.ownerIdx], c = CARD_CATALOG[t.key];
      const line = document.createElement('div'); line.className = 'qItem';
      line.textContent = `${i+1}. ${o?.name ?? '(?)'} — ${c?.name ?? '(unknown)'}`;
      ol.appendChild(line);
    }
    qb.appendChild(ol);
  }

  // Only the current turn's actor chooses targets (adjust if you want owner to choose)
  if (!isMyTurn()){
    const note = document.createElement('div'); note.className = 'small';
    note.textContent = 'Waiting for the active player to resolve.';
    tb.appendChild(note);
    return;
  }

  const kind = card.onTrigger?.kind;
  const needsTarget = triggerNeedsTarget(kind);
  if (!needsTarget){
    const note = document.createElement('div'); note.className = 'small';
    note.textContent = 'This effect needs no target. Use "Resolve Next".';
    tb.appendChild(note);
    return;
  }

  // Build targeting UI
  const box = document.createElement('div'); box.className = 'needTarget';
  const selP = document.createElement('select'); selP.id = 'selTargetPlayer';
  const selT = document.createElement('select'); selT.id = 'selTargetType';
  const selE = document.createElement('select'); selE.id = 'selTargetEntry';

  const enemies = (state.players||[]).filter(p => !p.eliminated && p.name !== owner.name);
  const opts    = allowedTargetTypesFor(kind);

  // --- helpers (use closure vars) ---
  const refreshApplyButton = () => {
    const applyBtn = document.getElementById('applyTargetBtn');
    if (!applyBtn) return;

    const tName = selP.value;
    const tType = selT.value;

    // Normalize selected entry index
    const tIdxRaw = selE.disabled ? null : selE.value; // '' means none
    const tIdx = (tIdxRaw === '' || tIdxRaw == null) ? null : Number(tIdxRaw);

    const players = (state.players || []);
    const target = players.find(p => p.name === tName) || null;

    const hasTargetPlayer = !!tName && enemies.some(e => e.name === tName) && !!target;
    const validTown = (tType === 'townhall') ? ((target?.townHp || 0) > 0) : true;

    // Walls shield Town Hall + structures
    const shieldUp = target ? (typeof hasActiveWall === 'function' ? hasActiveWall(target) : false) : false;
    const structOrTH = (tType === 'structure' || tType === 'townhall');
    const blockedByWalls = shieldUp && structOrTH;

    // Validate selected entry when not townhall
    let validEntry = true;
    if (tType !== 'townhall') {
      if (tIdx === null || Number.isNaN(tIdx)) {
        validEntry = false;
      } else {
        const entry = target?.owned?.[tIdx];
        const etype = entry ? CARD_CATALOG[entry.key]?.type : null;
        const alive = (entry?.hp || 0) > 0;
        validEntry = !!entry && alive && (etype === tType);
      }
    }

    const ok = hasTargetPlayer && validTown && validEntry && !blockedByWalls;
    applyBtn.disabled = !ok;

    // Helpful tooltip when disabled
    if (!ok) {
      let reason = '';
      if (!hasTargetPlayer)          reason = 'Select a valid target player.';
      else if (!validTown)           reason = 'Town Hall is already destroyed.';
      else if (blockedByWalls)       reason = 'Walls are up — destroy walls first.';
      else if (!validEntry && tType!=='townhall') reason = 'Select a valid target entry.';
      applyBtn.title = reason || 'Not allowed.';
    } else {
      applyBtn.title = '';
    }
  };

  function refillEntries(){
    selE.innerHTML = '';

    const targetName = selP.value;
    const typ = selT.value;
    const players = (state.players || []);
    const target = players.find(p => p.name === targetName) || null;

    const currentKind = card?.onTrigger?.kind || '';
    const ATTACK_KINDS = new Set([
      'attack_any','attack_structure','attack_troop',
      'attack_any_and_heal','attack_any_per_temple',
      'damage_per_temple_and_gain','lose_then_attack_any',
      'attack_any_and_destroy_troop','goliath_special'
    ]);
    const isAttack = ATTACK_KINDS.has(currentKind);
    const isTempleKey = (k) => (k==='white_temple'||k==='black_temple'||k==='red_temple'||k==='green_temple');

    if (!target){
      selE.disabled = true;
      const o = document.createElement('option'); o.value=''; o.textContent='(no target player)';
      selE.appendChild(o);
      refreshApplyButton();
      return;
    }

    // Town Hall pseudo-entry
    if (typ === 'townhall'){
      selE.disabled = true;
      const dead = (target.townHp || 0) <= 0;
      const blocked = typeof hasActiveWall === 'function' ? hasActiveWall(target) : false;

      const o = document.createElement('option');
      o.value = '';
      if (dead)        o.textContent = '(Town Hall destroyed)';
      else if (blocked && isAttack) o.textContent = '(Town Hall — blocked by walls)';
      else             o.textContent = '(Town Hall)';
      selE.appendChild(o);

      refreshApplyButton();
      return;
    }

    // Structures blocked by walls only for attack-kind effects
    if (typ === 'structure'){
      const shieldUp = (typeof hasActiveWall === 'function') ? hasActiveWall(target) : false;
      if (shieldUp && isAttack){
        selE.disabled = true;
        const o = document.createElement('option'); o.value=''; o.textContent='(structures blocked by walls)';
        selE.appendChild(o);
        refreshApplyButton();
        return;
      }
    }

    // Real entries (wall/troop/structure)
    selE.disabled = false;

    let items = listTargetableEntries(target, typ); // [{idx, e, c}]
    // For destroy_structure_non_temple, filter temples out
    if (typ === 'structure' && currentKind === 'destroy_structure_non_temple'){
      items = items.filter(it => !isTempleKey(it.e.key));
    }

    if (!items.length){
      const o = document.createElement('option'); o.value=''; o.textContent='(none)';
      selE.appendChild(o);
      selE.disabled = true;
      refreshApplyButton();
      return;
    }

    items.forEach(it => {
      const o = document.createElement('option');
      o.value = String(it.idx);
      const hp = (it.e.hp ?? 0);
      o.textContent = `${it.c.emoji} ${it.c.name} (HP ${hp})`;
      selE.appendChild(o);
    });

    refreshApplyButton();
  }

  // --- Populate selects ---
  // Players
  if (!enemies.length){
    selP.innerHTML = '<option value="">(no enemy)</option>';
  } else {
    enemies.forEach(p => {
      const o = document.createElement('option');
      o.value = p.name; o.textContent = p.name; selP.appendChild(o);
    });
  }

  // Types
  opts.forEach(t => {
    const o = document.createElement('option');
    o.value = t; o.textContent = t; selT.appendChild(o);
  });

  // Preselect first entries…
  if (selP.options.length) selP.selectedIndex = 0;
  if (selT.options.length) selT.selectedIndex = 0;

  // …and if this is an attack and the first enemy has walls, default to 'wall'
  const ATTACK_KINDS = new Set([
    'attack_any','attack_structure','attack_troop',
    'attack_any_and_heal','attack_any_per_temple',
    'damage_per_temple_and_gain','lose_then_attack_any',
    'attack_any_and_destroy_troop','goliath_special'
  ]);
  const isAttack = ATTACK_KINDS.has(kind);
  const firstEnemy = enemies[0];
  if (isAttack && firstEnemy && typeof hasActiveWall==='function' && hasActiveWall(firstEnemy)){
    const wallOpt = Array.from(selT.options).find(o => o.value === 'wall');
    if (wallOpt) selT.value = 'wall';
  }

  // Initial fill + listeners
  refillEntries();
  selP.addEventListener('change', refillEntries);
  selT.addEventListener('change', refillEntries);
  selE.addEventListener('change', refreshApplyButton);

  box.appendChild(document.createTextNode('Target: '));
  box.appendChild(selP);
  box.appendChild(selT);
  box.appendChild(selE);
  tb.appendChild(box);
}




    // ---------- Engine (same logic, stored under lobbies/{id}) ----------
    function computeUnlockForPlayer(p){
      let u='d6'; for (const e of (p.owned||[])){ const c=CARD_CATALOG[e.key]; if (!c) continue;
        for (const n of (c.triggers||[])){ if (n>=7 && n<=12) u='2d6'; if (n>=13) return 'd20'; } }
      return u;
    }
    function rollDie(mode, rdRef = state){
  if (!rng) rng = mulberry32((rdRef.seed||1) + (rdRef.rollCount||0));
  if (mode==='d6') return 1+Math.floor(rng()*6);
  if (mode==='2d6') return (1+Math.floor(rng()*6)) + (1+Math.floor(rng()*6));
  if (mode==='d20') return 1+Math.floor(rng()*20);
  return 1;
}
    function addOrIncOwned(p,key){
      const c=CARD_CATALOG[key]; if (!c) return;
      let hp=c.hp;
      if (c.hpDynamic){ const temples=(p.owned||[]).find(e=>e.key===c.hpDynamic.perTemple)?.count||0; hp=Math.max(1, temples*(c.hpDynamic.perHP||1)); }
      const f=(p.owned||[]).find(e=>e.key===key);
      if (f){ f.count=(f.count||1)+1; f.hp=hp; } else { (p.owned||(p.owned=[])).push({key, count:1, hp}); }
    }
      function damageEntry(entry, dmg, owner, rd){
    entry.hp = Math.max(0,(entry.hp||0)-(dmg||0));
    if (entry.hp<=0){
      const diedCard = CARD_CATALOG[entry.key];
      if (diedCard?.type==='troop'){
        for (const pl of (rd.players||[])){
          if ((pl.owned||[]).some(e=>e.key==='black_altar')) pl.gold = (pl.gold||0)+1;
        }
      }
      entry.count = (entry.count||1)-1;
      if (entry.count>0){ entry.hp = CARD_CATALOG[entry.key]?.hp || 1; }
      else { entry._remove = true; }
    }
  }

    function firstOfTypeIdx(p, type){
      const owned=p.owned||[];
      if (type==='troop') return owned.findIndex(e=>CARD_CATALOG[e.key]?.type==='troop' && e.hp>0);
      if (type==='wall')  return owned.findIndex(e=>CARD_CATALOG[e.key]?.type==='wall' && e.hp>0);
      if (type==='structure') return owned.findIndex(e=>CARD_CATALOG[e.key]?.type==='structure' && e.key!=='townhall' && e.hp>0);
      return -1;
    }
  function applyAttackToSpecific(owner, target, targetType, targetIdx, rawDmg, rd){
  const troopBuff = (owner.owned||[]).some(e=>e.key==='red_fortress') ? 1 : 0;
  const dmg = rawDmg + troopBuff;

  // walls must be destroyed before hitting structures or Town Hall
  if ((targetType==='structure' || targetType==='townhall') && hasActiveWall(target)){
    return `blocked by walls — destroy walls first.`;
  }

  if (targetType==='townhall'){
    target.townHp = Math.max(0,(target.townHp||0)-dmg);
    return `hits ${target.name}'s 🏰 Town Hall for ${dmg}.`;
  }

  if (targetIdx==null || targetIdx<0) return 'no valid target.';
  const entry = target.owned[targetIdx]; if (!entry) return 'no valid target.';

  // type guard (safety against mismatched UI indices)
  const realType = CARD_CATALOG[entry.key]?.type;
  if (targetType==='structure' && realType!=='structure') return 'invalid target.';
  if (targetType==='wall'      && realType!=='wall')      return 'invalid target.';
  if (targetType==='troop'     && realType!=='troop')     return 'invalid target.';

  damageEntry(entry, dmg, target, rd);
  return `hits ${target.name}'s ${CARD_CATALOG[entry.key].name} for ${dmg}.`;
}


function destroySpecific(target, targetType, targetIdx, allowTemple=true, rd){
  if (targetType==='townhall') return 'cannot destroy Town Hall.';
  if (targetIdx==null || targetIdx<0) return 'no valid target.';
  const entry = target.owned[targetIdx]; if (!entry) return 'no valid target.';

  const card = CARD_CATALOG[entry.key];
  const ttype = card?.type;

  // enforce requested type
  if (targetType==='structure' && ttype!=='structure') return 'invalid target.';
  if (targetType==='wall'      && ttype!=='wall')      return 'invalid target.';
  if (targetType==='troop'     && ttype!=='troop')     return 'invalid target.';

  const isTemple = (entry.key==='white_temple'||entry.key==='black_temple'||entry.key==='red_temple'||entry.key==='green_temple');
  if (!allowTemple && isTemple) return 'cannot destroy Temple with this effect.';

  damageEntry(entry, entry.hp||9999, target, rd);
  return `destroys ${target.name}'s ${card.name}.`;
}


const INSTANT_EARN_KINDS = new Set(['earn', 'earn_per_temple']);

function applyInstantIncome(owner, card){
  const ot = card.onTrigger || {};
  if (ot.kind === 'earn') {
    const v = ot.value || 0;
    owner.gold = (owner.gold || 0) + v;
    return v;
  }
  if (ot.kind === 'earn_per_temple') {
    const n = (owner.owned||[]).find(e=>e.key===ot.temple)?.count || 0;
    const amt = n * (ot.per || 0);
    owner.gold = (owner.gold || 0) + amt;
    return amt;
  }
  return 0;
}

   function buildResolveQueueAfterRoll(rd, rollerIdx, rollVal){
  const q = [];
  const players = rd.players || [];
  const earnedBy = new Map(); // name -> coins earned this roll

  players.forEach((p,i)=>{
    const timing = (i===rollerIdx) ? ['every','your'] : ['opponent'];
    (p.owned||[]).forEach(e=>{
      const c = CARD_CATALOG[e.key]; if (!c) return;
      if (!c.triggers?.includes(rollVal)) return;
      if (!c.timing || !timing.includes(c.timing)) return;

      const copies = Math.max(1, e.count||1);
      for (let k=0; k<copies; k++){
        const kind = c.onTrigger?.kind;
        if (INSTANT_EARN_KINDS.has(kind)){
          const got = applyInstantIncome(p, c);
          if (got>0) earnedBy.set(p.name, (earnedBy.get(p.name)||0) + got);
        } else {
          q.push({ ownerIdx:i, key:e.key, roll:rollVal });
        }
      }
    });
  });

  // Make a tiny summary like: "Auto‑income: Alice +2, Bob +1"
  const parts = [];
  earnedBy.forEach((amt, nm) => parts.push(`${nm} +${amt}`));
  const autoNote = parts.length ? `Auto‑income: ${parts.join(', ')}` : '';

  return { q, autoNote };
}
    function hasActiveWall(p){
  return (p?.owned||[]).some(e => CARD_CATALOG[e.key]?.type==='wall' && (e.hp||0) > 0);
}


    function postResolveCleanup(rd){
      for (const pl of rd.players){ pl.owned = (pl.owned||[]).filter(e=>!e._remove); }
      for (const p of rd.players){ if (!p.eliminated && (p.townHp||0)<=0){ p.eliminated=true; p.owned=[]; p.gold=0; } }
    }
function hostResolveOne(rd, manual){
  const stack = rd.resolveQueue || [];
  if (!stack.length) return { changed:false, msg:'No triggers.' };

  const trig  = stack[0];
  const owner = rd.players[trig.ownerIdx];
  const card  = CARD_CATALOG[trig.key];
  const kind  = card.onTrigger?.kind;
  let msg     = `${owner.name} triggers ${card.emoji} ${card.name}: `;
  const activeName   = rd.lastRoll?.by;
  const activePlayer = (rd.players||[]).find(p=>p.name===activeName) || null;

  const needsTarget = triggerNeedsTarget(kind);

  // Skip if needs a target but none exist anywhere
  if (needsTarget){
    const ownerPlayer = rd.players[trig.ownerIdx];
    const enemies = (rd.players||[]).filter(p=>!p.eliminated && p.name!==ownerPlayer.name);
    const kinds = allowedTargetTypesFor(kind);
    const enemyHasAnyValid = enemies.some(ep=>{
      return kinds.some(typ=>{
        if (typ==='townhall') return (ep.townHp||0) > 0;
        const items = listTargetableEntries(ep, typ);
        return items.length > 0;
      });
    });
    if (!enemyHasAnyValid){
      rd.resolveQueue.shift();
      postResolveCleanup(rd);
      return { changed:true, msg: `${owner.name}'s ${card.name} had no valid targets (skipped).` };
    }
  }

  // If target needed but not provided, auto-pick if only one; else wait
  if (needsTarget && !manual){
    const ownerPlayer = rd.players[trig.ownerIdx];
    const enemies = (rd.players||[]).filter(p=>!p.eliminated && p.name!==ownerPlayer.name);
    const types = allowedTargetTypesFor(kind);

    let possibleTargets = [];
    enemies.forEach(ep=>{
      types.forEach(typ=>{
        if (typ==='townhall' && (ep.townHp||0)>0){
          possibleTargets.push({ player:ep, type:'townhall', idx:null });
        } else {
          listTargetableEntries(ep, typ).forEach(it=>{
            possibleTargets.push({ player:ep, type:typ, idx:it.idx });
          });
        }
      });
    });

    if (possibleTargets.length === 1){
      const pick = possibleTargets[0];
      manual = { targetPlayer: pick.player.name, targetType: pick.type, targetEntryIdx: pick.idx };
    } else {
      return { changed:false, msg:'Target required.' };
    }
  }

  const applyAndShift = (extraMsg) => {
    stack.shift();
    rd.resolveQueue = stack;
    postResolveCleanup(rd);
    return { changed:true, msg: extraMsg ? (msg + extraMsg) : msg };
  };

  switch(kind){
    // ----- Non-targeted effects -----
    case 'earn': {
      const v = (card.onTrigger.value||0);
      owner.gold = (owner.gold||0) + v;
      return applyAndShift(`+${v} coin(s).`);
    }
    case 'earn_per_temple': {
      const n = (owner.owned||[]).find(e=>e.key===card.onTrigger.temple)?.count || 0;
      const amt = n * (card.onTrigger.per||0);
      owner.gold = (owner.gold||0) + amt;
      return applyAndShift(`+${amt} coin(s).`);
    }
    case 'heal_town': {
      const v = (card.onTrigger.value||0);
      owner.townHp = (owner.townHp||0) + v;
      return applyAndShift(`heals Town Hall ${v}.`);
    }
    case 'heal_and_earn': {
      const h = (card.onTrigger.heal||0);
      const c = (card.onTrigger.coins||0);
      owner.townHp = (owner.townHp||0) + h;
      owner.gold   = (owner.gold||0) + c;
      return applyAndShift(`heals ${h} & +${c} coins.`);
    }
    case 'each_other_lose_hp': {
      const v = (card.onTrigger.value||0);
      (rd.players||[]).forEach((p,i)=>{
        if (i!==trig.ownerIdx && !p.eliminated){
          p.townHp = Math.max(0, (p.townHp||0) - v);
        }
      });
      return applyAndShift(`each other player loses ${v}.`);
    }
    case 'active_loses_per_temple': {
      const t = activePlayer; if (!t) return applyAndShift('no active opponent.');
      const n = (owner.owned||[]).find(e=>e.key===card.onTrigger.temple)?.count || 0;
      const loss = n * (card.onTrigger.per||0);
      t.townHp = Math.max(0, (t.townHp||0) - loss);
      return applyAndShift(`${t.name} loses ${loss} health.`);
    }
    case 'lose_hp_gain_coins': {
      const lose = (card.onTrigger.lose||0);
      const gain = (card.onTrigger.coins||0);
      owner.townHp = Math.max(0, (owner.townHp||0) - lose);
      owner.gold   = (owner.gold||0) + gain;
      return applyAndShift(`loses ${lose}, gains ${gain} coins.`);
    }
    case 'others_sacrifice_cards_per_temple': {
      const times = (owner.owned||[]).find(e=>e.key===card.onTrigger.temple)?.count || 0;
      (rd.players||[]).forEach((p,i)=>{
        if (i===trig.ownerIdx || p.eliminated) return;
        for (let k=0;k<times;k++){
          let idx = firstOfTypeIdx(p,'troop');
          if (idx<0) idx = firstOfTypeIdx(p,'structure');
          if (idx<0) idx = firstOfTypeIdx(p,'wall');
          if (idx>=0) damageEntry(p.owned[idx], p.owned[idx].hp||9999, p, rd);
        }
      });
      return applyAndShift(`others sacrifice ${times} card(s).`);
    }
    case 'steal_fixed': {
      const act = activePlayer; if (!act) return applyAndShift('no active.');
      const amt = Math.min((act.gold||0), (card.onTrigger.value||0));
      act.gold   = (act.gold||0) - amt;
      owner.gold = (owner.gold||0) + amt;
      return applyAndShift(`steals ${amt} from ${act.name}.`);
    }
    case 'steal_and_make_sacrifice_farm': {
      const act = activePlayer; if (!act) return applyAndShift('no active.');
      const amt = Math.min((act.gold||0), 1);
      act.gold   = (act.gold||0) - amt;
      owner.gold = (owner.gold||0) + amt;
      const fIdx = (act.owned||[]).findIndex(e=>e.key==='farm' && e.hp>0);
      if (fIdx>=0) damageEntry(act.owned[fIdx], act.owned[fIdx].hp||9999, act, rd);
      return applyAndShift(`steals ${amt} from ${act.name}${fIdx>=0? ' and forces a Farm to be sacrificed.':'.'}`);
    }

    // ----- Targeted effects -----
    case 'attack_any':
    case 'attack_structure':
    case 'attack_troop':
    case 'attack_any_and_heal':
    case 'attack_any_per_temple':
    case 'damage_per_temple_and_gain':
    case 'lose_then_attack_any':
    case 'attack_any_and_destroy_troop':
    case 'destroy_troop':
    case 'destroy_structure_non_temple':
    case 'destroy_structure_and_attack_any':
    case 'goliath_special':
    case 'gain_and_destroy_two_walls': { // NEW kind handled here
      const tName = manual?.targetPlayer;
      const tType = manual?.targetType;
      const tIdx  = (manual?.targetEntryIdx!=null) ? Number(manual.targetEntryIdx) : null;
      const target = (rd.players||[]).find(p=>p.name===tName);
      if (!target) return applyAndShift('no enemy.');

      switch(kind){
        case 'attack_any': {
          const out = applyAttackToSpecific(owner, target, tType, tIdx, (card.onTrigger.value||0), rd);
          return applyAndShift(out);
        }
        case 'attack_structure': {
          if (tType==='troop') return applyAndShift('invalid target (troop).');
          const out = applyAttackToSpecific(owner, target, tType, tIdx, (card.onTrigger.value||0), rd);
          return applyAndShift(out);
        }
        case 'attack_troop': {
          if (tType!=='troop') return applyAndShift('invalid target (needs troop).');
          const out = applyAttackToSpecific(owner, target, 'troop', tIdx, (card.onTrigger.value||0), rd);
          return applyAndShift(out);
        }
        case 'attack_any_and_heal': {
          const out = applyAttackToSpecific(owner, target, tType, tIdx, (card.onTrigger.dmg||0), rd);
          owner.townHp = (owner.townHp||0) + (card.onTrigger.heal||0);
          return applyAndShift(out + ` Heals ${card.onTrigger.heal||0}.`);
        }
        case 'attack_any_per_temple': {
          const n = (owner.owned||[]).find(e=>e.key===card.onTrigger.temple)?.count || 0;
          const out = applyAttackToSpecific(owner, target, tType, tIdx, n*(card.onTrigger.per||0), rd);
          return applyAndShift(out);
        }
        case 'damage_per_temple_and_gain': {
          const n = (owner.owned||[]).find(e=>e.key===card.onTrigger.temple)?.count || 0;
          const out = applyAttackToSpecific(owner, target, tType, tIdx, n*(card.onTrigger.per||0), rd);
          owner.gold = (owner.gold||0) + (card.onTrigger.coins||0);
          return applyAndShift(out + ` Gains ${card.onTrigger.coins||0} coins.`);
        }
        case 'lose_then_attack_any': {
          owner.townHp = Math.max(0, (owner.townHp||0) - (card.onTrigger.lose||0));
          const out = applyAttackToSpecific(owner, target, tType, tIdx, (card.onTrigger.dmg||0), rd);
          return applyAndShift(`loses ${card.onTrigger.lose||0}. ` + out);
        }
        case 'attack_any_and_destroy_troop': {
          const out = applyAttackToSpecific(owner, target, tType, tIdx, (card.onTrigger.dmg||0), rd);
          const troopIdx = firstOfTypeIdx(target,'troop');
          if (troopIdx>=0) damageEntry(target.owned[troopIdx], target.owned[troopIdx].hp||9999, target, rd);
          return applyAndShift(out + (troopIdx>=0 ? ` Destroys a troop.` : ` No troop to destroy.`));
        }
        case 'destroy_troop': {
          if (tType!=='troop') return applyAndShift('invalid target (needs troop).');
          const out = destroySpecific(target, 'troop', tIdx, true, rd);
          return applyAndShift(out);
        }
        case 'destroy_structure_non_temple': {
          if (tType==='troop' || tType==='townhall') return applyAndShift('invalid target.');
          const out = destroySpecific(target, 'structure', tIdx, /*allowTemple*/false, rd);
          return applyAndShift(out);
        }
        case 'destroy_structure_and_attack_any': {
          if (tType==='troop' || tType==='townhall') return applyAndShift('invalid first target.');
          const out1 = destroySpecific(target, tType, tIdx, /*allowTemple*/true, rd);
        
          // SECOND HIT: must respect wall shielding. If walls remain, hit a wall; else Town Hall.
          let out2 = '';
          if (hasActiveWall(target)){
            const wIdx = firstOfTypeIdx(target,'wall');
            if (wIdx>=0) out2 = applyAttackToSpecific(owner, target, 'wall', wIdx, (card.onTrigger.dmg||0), rd);
            else         out2 = 'no wall to hit.';
          } else {
            out2 = applyAttackToSpecific(owner, target, 'townhall', null, (card.onTrigger.dmg||0), rd);
          }
          return applyAndShift(out1 + ' ' + out2);
        }
        case 'goliath_special': {
          if (trig.roll===12){
            const wIdx = firstOfTypeIdx(target,'wall');  if (wIdx>=0) damageEntry(target.owned[wIdx], target.owned[wIdx].hp||9999, target, rd);
            const trIdx= firstOfTypeIdx(target,'troop'); if (trIdx>=0) damageEntry(target.owned[trIdx], target.owned[trIdx].hp||9999, target, rd);
            const out  = applyAttackToSpecific(owner, target, tType, tIdx, 10, rd);
            return applyAndShift(`${wIdx>=0?'destroys a wall. ':''}${trIdx>=0?'destroys a troop. ':''}${out}`);
          } else {
            const out = applyAttackToSpecific(owner, target, tType, tIdx, 10, rd);
            return applyAndShift(out);
          }
        }
        case 'gain_and_destroy_two_walls': { // NEW
          if (tType!=='wall' || tIdx==null) return applyAndShift('invalid target (needs wall).');
          owner.gold = (owner.gold||0) + (card.onTrigger.coins||0);
          // destroy selected wall
          destroySpecific(target, 'wall', tIdx, true, rd);
          // destroy another wall if present
          const w2 = firstOfTypeIdx(target,'wall');
          if (w2>=0) destroySpecific(target, 'wall', w2, true, rd);
          return applyAndShift(`gains ${card.onTrigger.coins||0} coins and destroys up to two walls.`);
        }
      }
      break;
    }

    // ----- Acquire (non-target UI) -----
    case 'acquire_troop_cost_leq_temples': {
      const tCount = (owner.owned||[]).find(e=>e.key===card.onTrigger.temple)?.count || 0;
      const maxCost = tCount;
      const choices = Object.values(CARD_CATALOG)
        .filter(c => c.type==='troop' && (c.cost||0) <= maxCost);
      if (choices.length){
        choices.sort((a,b)=> (a.cost-b.cost) || ((b.hp||0)-(a.hp||0)));
        addOrIncOwned(owner, choices[0].key);
        owner.unlocked = computeUnlockForPlayer(owner);
        return applyAndShift(`acquires ${choices[0].name} (cost ≤ ${maxCost}).`);
      }
      return applyAndShift(`no troop available at cost ≤ ${maxCost}.`);
    }
  }

  // Fallback
  stack.shift();
  rd.resolveQueue = stack;
  postResolveCleanup(rd);
  return { changed:true, msg };
}



  // Add this once (top-level, above the function)
let _processingIntents = false;

// Requires: import { where } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js"

// hostApplyIntents: processes queued intents in order, resilient to missing indexes
async function hostApplyIntents(){
  if (!isHost || !state) return;
  if (_processingIntents) return; // prevent parallel runs
  _processingIntents = true;

  try {
    const movesRef = collection(db, 'lobbies', lobbyId, 'intents');

    // --- Build list of unprocessed intents with a server-ordered query,
    // --- and gracefully fall back if the composite index isn't created yet.
    let pendingDocs = [];
    try {
      const snap = await getDocs(query(
        movesRef,
        where('processed','==',false),
        orderBy('ts','asc'),
        orderBy('__name__','asc'),
        limit(50)
      ));
      pendingDocs = snap.docs;
    } catch (err){
      console.warn('Composite index missing; falling back to client-side sort.', err);
      // Fallback path: filter by processed and sort in JS by ts then id
      const snap = await getDocs(query(
        movesRef,
        where('processed','==',false),
        limit(100)
      ));
      pendingDocs = snap.docs.sort((a,b)=>{
        const ta = a.data()?.ts?.toMillis?.() ?? 0;
        const tb = b.data()?.ts?.toMillis?.() ?? 0;
        if (ta !== tb) return ta - tb;
        return a.id.localeCompare(b.id);
      });
    }

    for (const d of pendingDocs){
      const mv = d.data();
      if (mv.processed) continue;

      await runTransaction(db, async (tx) => {
        const ref = doc(db, 'lobbies', lobbyId);
        const rs  = await tx.get(ref);
        if (!rs.exists()) return;

        const rd = rs.data().game || null;
        if (!rd) return; // no game yet

        const players = rd.players || [];
        const tIdx    = rd.turnIdx ?? 0;
        let   phase   = rd.phase || 'await_roll'; // must be let so we can repair
        const actor   = players[tIdx];
        const isActor = mv.from === actor?.name;

        // --- Phase auto-repair: don't sit in 'resolving' with an empty queue
        if (phase === 'resolving' && !((rd.resolveQueue||[]).length)){
          rd.phase = 'buy';
          rd._lastMsg = (rd._lastMsg || '') + ' [auto-repair: no pending triggers]';
          phase = 'buy';
          tx.update(ref, { game: rd });
          // continue; we still want to try handling this mv against repaired phase
        }

        // --- ROLL ---
        if (mv.type === 'ROLL' && isActor && phase === 'await_roll') {
          const mode = mv.payload?.mode || 'd6';
          const v    = rollDie(mode, rd); // deterministic RNG from state

          // Always record the roll so UI shows it even if queue build fails
          rd.lastRoll = { mode, value: v, by: actor.name };
          rd._lastMsg = `${actor.name} rolled ${v} (${mode}).`;

          try {
            const { q, autoNote } = buildResolveQueueAfterRoll(rd, tIdx, v);
            rd.resolveQueue = Array.isArray(q) ? q : [];
            rd.phase = rd.resolveQueue.length ? 'resolving' : 'buy';
            if (autoNote) rd._lastMsg += ' — ' + autoNote;
          } catch (e) {
            console.error('Queue build failed:', e);
            rd.resolveQueue = [];
            rd.phase = 'buy';
            rd._lastMsg += ' (auto-resolve disabled this roll due to an error)';
          }

          rd.rollCount = (rd.rollCount || 0) + 1;

          // Safety: if we're in 'resolving' with empty queue, bump to 'buy'
          if (rd.phase === 'resolving' && !(rd.resolveQueue?.length)) rd.phase = 'buy';

          tx.update(ref, { game: rd });
          tx.update(doc(db, 'lobbies', lobbyId, 'intents', d.id), { processed: true });
          return;
        }

        // --- RESOLVE (no target) ---
        if (mv.type === 'RESOLVE_NEXT' && isActor && phase === 'resolving'){
          const res = hostResolveOne(rd, null);
          if (res?.msg) rd._lastMsg = res.msg;
          if (!(rd.resolveQueue?.length)) rd.phase = 'buy';

          tx.update(ref, { game: rd });
          tx.update(doc(db, 'lobbies', lobbyId, 'intents', d.id), { processed: true });
          return;
        }

        // --- RESOLVE (with target) ---
        if (mv.type === 'RESOLVE_WITH_TARGET' && isActor && phase === 'resolving'){
          const manual = {
            targetPlayer:   String(mv.payload?.targetPlayer ?? ''),
            targetType:     String(mv.payload?.targetType ?? ''),
            targetEntryIdx: (mv.payload?.targetEntryIdx == null ? null : Number(mv.payload.targetEntryIdx))
          };
          const res = hostResolveOne(rd, manual);
          if (res?.msg) rd._lastMsg = res.msg;
          if (!(rd.resolveQueue?.length)) rd.phase = 'buy';

          tx.update(ref, { game: rd });
          tx.update(doc(db, 'lobbies', lobbyId, 'intents', d.id), { processed: true });
          return;
        }

        // --- BUY ---
        if (mv.type === 'BUY' && isActor && phase === 'buy'){
          const key  = mv.payload?.key;
          const card = CARD_CATALOG[key];
          if (card){
            const have     = (actor.owned?.find(e => e.key === key)?.count) || 0;
            const max      = card.max ?? 3;
            const okTemple = !card.requiresTemple || (actor.owned || []).some(e => e.key === card.requiresTemple);
            if ((actor.gold || 0) >= card.cost && have < max && okTemple){
              actor.gold    -= card.cost;
              addOrIncOwned(actor, key);
              actor.unlocked = computeUnlockForPlayer(actor);
              rd._lastMsg    = `${actor.name} bought ${card.name}.`;
            }
          }
          // remain in buy so End Turn stays enabled
          rd.phase = 'buy';

          tx.update(ref, { game: rd });
          tx.update(doc(db, 'lobbies', lobbyId, 'intents', d.id), { processed: true });
          return;
        }

        // --- END TURN (allowed in any phase; can optionally forfeit remaining resolves)
        if (mv.type === 'END_TURN' && isActor){
          const forfeit = !!(mv.payload && mv.payload.forfeitRemaining);
          if (forfeit) rd.resolveQueue = [];

          // Advance to next non-eliminated player
          const players = rd.players || [];
          let next = (tIdx + 1) % players.length;
          for (let g = 0; g < players.length; g++){
            if (!(players[next]?.eliminated)) break;
            next = (next + 1) % players.length;
          }

          rd.turnIdx  = next;
          rd.phase    = 'await_roll';
          rd.lastRoll = null;

          const alive = players.filter(p => !p.eliminated);
          if (alive.length <= 1) rd.phase = 'finished';

          tx.update(ref, { game: rd });
          tx.update(doc(db, 'lobbies', lobbyId, 'intents', d.id), { processed: true });
          return;
        }

        // === Smarter fallback ===
        // If it's not a known type OR it's not from the current actor, consume it.
        // Otherwise (known type + current actor but wrong phase), leave it unprocessed
        // so it can run when the phase flips (prevents "my click vanished").
        const validTypes = new Set(['ROLL','RESOLVE_NEXT','RESOLVE_WITH_TARGET','BUY','END_TURN']);
        const isValidType = validTypes.has(mv.type);
        const isCurrentActor = isActor;

        if (!isValidType || !isCurrentActor){
          tx.update(doc(db,'lobbies', lobbyId, 'intents', d.id), { processed:true });
          return;
        }
        // else: known + current actor + wrong phase → do nothing (leave unprocessed)
      });
    }
  } finally {
    _processingIntents = false;
  }
}
    // ---------- Intents ----------
    async function pushIntent(type, payload={}){ if (!lobbyId||!myName) return; await addDoc(collection(db,'lobbies',lobbyId,'intents'),{type,from:myName,payload,ts:serverTimestamp(),processed:false}); }
    function intentRoll(mode){ pushIntent('ROLL',{mode}); }
    function intentResolve(){ pushIntent('RESOLVE_NEXT',{}); }
    function intentResolveWithTarget(){
      const q=state?.resolveQueue||[]; if (!q.length) return;
      const card=CARD_CATALOG[q[0].key]; const kind=card.onTrigger?.kind;
      if (!triggerNeedsTarget(kind)) return;
      const tp = $('#selTargetPlayer')?.value || '';
      const tt = $('#selTargetType')?.value || '';
      const te = $('#selTargetEntry')?.value || '';
      pushIntent('RESOLVE_WITH_TARGET',{targetPlayer:tp, targetType:tt, targetEntryIdx: te===''? null : Number(te)});
    }
    function intentBuy(key){ pushIntent('BUY',{key}); }
   function intentEndTurn(payload={}){ pushIntent('END_TURN', payload); }

    // ---------- Init helpers ----------
    function mkStarter(name){
      const p={name, gold:0, townHp:50, unlocked:'d6', owned:[]};
      for (const k of STARTERS){ const c=CARD_CATALOG[k]; p.owned.push({key:k, count:1, hp:c.hp}); }
      return p;
    }

    async function hostMaybeInitializeGame(lobbySnap){
      const data = lobbySnap.data();
      const hasGame = !!data.game;
      if (hasGame) return;

      // Players come in as array of names from the lobby
      const names = Array.isArray(data.players) ? data.players : [];
      const players = names.slice(0,4).map(n => mkStarter(n));

      const seed = Math.floor(Math.random()*1e9);
     const game = {
        createdAt: serverTimestamp(),
        host: data.host || myName,
        players,
        maxPlayers: Math.min(Math.max(players.length || 2, 2), 4),
        turnIdx: 0,
        phase: 'await_roll',
        seed,
        rollCount: 0,
        resolveQueue: [],
        _lastMsg: 'Game initialized.'
      };
      await updateDoc(doc(db,'lobbies',lobbyId), { game });
    }

    function attachListeners(){
      if (unsubLobby) unsubLobby(); if (unsubIntents) unsubIntents();

      const lobbyRef = doc(db,'lobbies',lobbyId);
      unsubLobby = onSnapshot(lobbyRef, async (snap)=>{
        if (!snap.exists()) return;
        const lobby = snap.data();
        isHost = (lobby.host === myName);

        // Host initializes once when status is "started" and no game yet
        if (isHost && lobby.status === 'started' && !lobby.game) {
          await hostMaybeInitializeGame(snap);
          return;
        }

        state = lobby.game || null;
        if (state){
          me.idx = (state.players||[]).findIndex(p=>p.name===myName);
          if (state._lastMsg) logLine(state._lastMsg);
          render();
          if (isHost) hostApplyIntents();
        } else {
          document.getElementById('statusNote').textContent = 'Waiting for host to initialize the game...';
        }
      });

      unsubIntents = onSnapshot(collection(db,'lobbies',lobbyId,'intents'), ()=>{
        if (isHost) hostApplyIntents();
      });
    }

    // ---------- UI bindings ----------
    document.getElementById('rollBtn').addEventListener('click', ()=>{
      if (!isMyTurn()) return; const mode=$('#dieSelect').value;
      const allow=allowedDiceFor(myPlayer()); if (!allow.includes(mode)) return alert('Die not unlocked');
      intentRoll(mode);
    });
    document.getElementById('resolveBtn').addEventListener('click', ()=>{ if (isMyTurn()) intentResolve(); });
    document.getElementById('applyTargetBtn').addEventListener('click', ()=>{ if (isMyTurn()) intentResolveWithTarget(); });
   document.getElementById('endTurnBtn').addEventListener('click', ()=>{
  if (!isMyTurn()) return;

  const hasPending = (state?.phase === 'resolving') && ((state?.resolveQueue?.length || 0) > 0);
  if (hasPending){
    const ok = confirm('You still have unresolved actions. End turn and forfeit the rest?');
    if (!ok) return;
    intentEndTurn({ forfeitRemaining: true });
  } else {
    intentEndTurn({ forfeitRemaining: false });
  }
});


    // ---------- Boot ----------
    (async function boot(){
      if (!lobbyId || !myName) return;
      // Header tags
      document.getElementById('hdrLobby').style.display='';
      document.getElementById('hdrUser').style.display='';
      document.getElementById('hdrLobby').textContent='Lobby: '+lobbyId;
      document.getElementById('hdrUser').textContent=myName;

      attachListeners();
    })();
      console.log('SCRIPT LOADED OK');

  </script>
</body>
</html>




