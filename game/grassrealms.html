<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>üåø Grass Realms ‚Äî game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{ --bg:#f7f8fb; --ink:#1f2937; --muted:#6b7280; --card:#fff; --line:#e5e7eb; --accent:#2e7d32; }
    *{box-sizing:border-box}
    body{margin:0;font-family:Segoe UI,Arial,Helvetica,sans-serif;background:var(--bg);color:var(--ink)}
    header{display:flex;align-items:center;gap:8px;padding:10px 14px;border-bottom:1px solid var(--line);background:#fff;position:sticky;top:0;z-index:5}
    header .tag{font-size:12px;color:#fff;background:var(--accent);padding:2px 8px;border-radius:14px}
    main{padding:12px;display:grid;grid-template-columns:1fr 420px;gap:12px}
    .board{display:grid;grid-template-areas:"p0 p1" "p2 p3"; gap:12px;}
    .playerPanel{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:10px;min-height:220px;position:relative}
    .playerPanel .hdr{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
    .playerPanel .hdr .hp{font-weight:600}
    .playerPanel .emojiClump{font-size:22px;line-height:1.2;min-height:80px}
    .playerPanel .meta{font-size:12px;color:var(--muted)}
    .you{outline:2px solid #1976d2}
    .active{box-shadow:0 0 0 3px rgba(46,125,50,.35)}
    .rightCol{display:flex;flex-direction:column;gap:12px}
    .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:12px}
    .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    .controls select, .controls button{padding:8px 10px;font-size:14px}
    .shopGrid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}
    .shopItem{border:1px solid var(--line);border-radius:10px;padding:8px}
    .shopItem h4{margin:0 0 4px 0;font-size:14px}
    .small{font-size:12px;color:var(--muted)}
    .targets{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
    .targets select{padding:6px 8px}
    .log{max-height:260px;overflow:auto;border:1px solid var(--line);border-radius:10px;background:#fff}
    .logLine{padding:6px 8px;border-bottom:1px dashed var(--line);font-size:13px}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#eef7ee;color:#1b5e20;font-size:12px}
    .queue{margin-top:8px;border-top:1px dashed var(--line);padding-top:8px}
    .qItem{font-size:12px;color:var(--muted);margin:2px 0}
    .needTarget{background:#fff7e6;border:1px solid #ffe0a3;padding:8px;border-radius:8px}
    .spacer{flex:1}
  </style>
</head>
<body>
  <header>
    <strong>üåø Grass Realms</strong>
    <span id="hdrLobby" class="tag" style="display:none"></span>
    <span id="hdrUser" class="tag" style="display:none"></span>
    <span id="hdrRole" class="tag" style="display:none"></span>
    <span class="spacer"></span>
    <span class="small" id="statusNote"></span>
  </header>

  <main>
    <section class="board" id="board">
      <div class="playerPanel" id="p0"></div>
      <div class="playerPanel" id="p1"></div>
      <div class="playerPanel" id="p2"></div>
      <div class="playerPanel" id="p3"></div>
    </section>

    <aside class="rightCol">
      <div class="card">
        <h3>Your Turn Controls</h3>
        <div class="controls">
  <label>Die:
    <select id="dieSelect"><option>d6</option></select>
  </label>
  <button id="rollBtn">üé≤ Roll</button>
  <button id="resolveBtn">‚ñ∂ Resolve Next (auto / no‚Äëtarget)</button>
  <button id="applyTargetBtn">üéØ Apply Trigger (with target)</button>
  <button id="endTurnBtn">‚è≠ End Turn</button>
  <span id="lastRollBadge" class="pill" style="display:none;margin-left:8px"></span> <!-- NEW -->
</div>

        <div id="targetBox" class="targets"></div>
        <div id="queueBox" class="queue small"></div>

        <div style="margin-top:8px" class="small">
          Roll ‚Üí resolve each trigger in order. If a trigger needs a target, choose player & item and click <b>Apply Trigger</b>.
          Walls protect <b>structures</b> (not troops). Opponent‚Äëturn triggers fire on enemy rolls.
        </div>
      </div>

      <div class="card">
        <h3>Shop</h3>
        <div id="shop" class="shopGrid"></div>
      </div>

      <div class="card">
        <h3>Run Log</h3>
        <div id="log" class="log"></div>
      </div>
    </aside>
  </main>

  <script type="module">
    // -------- Firebase --------
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import {
      getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot,
      collection, addDoc, serverTimestamp, runTransaction, query, orderBy, limit, getDocs
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
      authDomain: "bible-game-246c0.firebaseapp.com",
      projectId: "bible-game-246c0",
      storageBucket: "bible-game-246c0.appspot.com",
      messagingSenderId: "959619818996",
      appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
    };
    const app = initializeApp(firebaseConfig);
    const db  = getFirestore(app);

    // -------- URL params from lobby redirect --------
    const qp = new URLSearchParams(location.search);
    const lobbyId = qp.get('gameId') || '';     // the lobby doc id
    const myName  = qp.get('username') || '';
    if (!lobbyId || !myName) {
      document.getElementById('statusNote').textContent = 'Missing gameId or username in URL.';
    }

    // -------- RNG --------
    function mulberry32(seed){ return function(){ let t = seed += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; } }

    // ---------- Catalog ----------
    const RAW_CARDS = [
      { key:'townhall', name:'Town Hall', emoji:'üè∞', type:'structure', cost:0, hp:50, max:1, triggers:[], timing:null, immutable:true },
      { key:'farm', name:'Farm', emoji:'üåæ', type:'structure', cost:1, hp:2, max:3, triggers:[1,2], timing:'every', onTrigger:{kind:'earn', value:1} },
      { key:'mill', name:'Lumber Mill', emoji:'ü™µ', type:'structure', cost:2, hp:3, max:3, triggers:[3], timing:'every', onTrigger:{kind:'earn', value:3} },
      { key:'mine', name:'Mine', emoji:'‚õèÔ∏è', type:'structure', cost:3, hp:3, max:3, triggers:[4], timing:'every', onTrigger:{kind:'earn', value:3} },

      // Gray
      { key:'footman', name:'Footman', emoji:'üó°Ô∏è', type:'troop', cost:2, hp:4, max:3, triggers:[3,4], timing:'every', onTrigger:{kind:'attack_any', value:1} },
      { key:'spy', name:'Spy', emoji:'üïµÔ∏è', type:'troop', cost:2, hp:3, max:3, triggers:[5], timing:'opponent', onTrigger:{kind:'steal_fixed', value:2} },
      { key:'knight', name:'Knight', emoji:'üê¥', type:'troop', cost:3, hp:6, max:3, triggers:[5], timing:'your', onTrigger:{kind:'attack_any', value:4} },
      { key:'wall_stone', name:'Stone Wall', emoji:'üß±', type:'wall', cost:3, hp:5, max:3, triggers:[], timing:null },
      { key:'archtwrX', name:'Archer Tower', emoji:'üèπ', type:'structure', cost:5, hp:6, max:3, triggers:[3], timing:'your', onTrigger:{kind:'destroy_troop'} },
      { key:'trebuchet', name:'Trebuchet', emoji:'üèóÔ∏è', type:'structure', cost:5, hp:7, max:3, triggers:[2], timing:'your', onTrigger:{kind:'destroy_structure_non_temple'} },

      // White
      { key:'white_temple', name:'White Temple', emoji:'ü§ç‚õ™', type:'structure', cost:4, hp:5, max:3, triggers:[6], timing:'your', onTrigger:{kind:'heal_town', value:3} },
      { key:'white_devotee', name:'Devotee', emoji:'üïØÔ∏è', type:'troop', cost:3, hp:4, max:3, triggers:[4], timing:'every', requiresTemple:'white_temple', onTrigger:{kind:'earn_per_temple', temple:'white_temple', per:1} },
      { key:'white_recruiter', name:'Recruiter', emoji:'üìú', type:'troop', cost:4, hp:5, max:3, triggers:[7], timing:'your', requiresTemple:'white_temple', onTrigger:{kind:'acquire_troop_cost_leq_temples', temple:'white_temple'} },
      { key:'white_scholar', name:'Scholar', emoji:'üìö', type:'troop', cost:5, hp:5, max:3, triggers:[9], timing:'every', requiresTemple:'white_temple', onTrigger:{kind:'heal_and_earn', heal:3, coins:3} },
      { key:'white_paladin', name:'Paladin', emoji:'üõ°Ô∏è', type:'troop', cost:6, hp:8, max:3, triggers:[8], timing:'every', requiresTemple:'white_temple', onTrigger:{kind:'attack_any_and_heal', dmg:7, heal:3} },
      { key:'white_highpriest', name:'High Priest', emoji:'üôè', type:'troop', cost:7, hp:8, max:3, triggers:[11], timing:'every', requiresTemple:'white_temple', onTrigger:{kind:'attack_any_and_destroy_troop', dmg:5} },
      { key:'white_pylon', name:'Temple Pylon', emoji:'üóº', type:'wall', cost:4, hpDynamic:{perTemple:'white_temple', perHP:1}, max:3, triggers:[], timing:null },

      // Black
      { key:'black_temple', name:'Black Temple', emoji:'üñ§‚õ™', type:'structure', cost:4, hp:5, max:3, triggers:[6], timing:'your', onTrigger:{kind:'each_other_lose_hp', value:1} },
      { key:'black_acolyte', name:'Acolyte', emoji:'ü©∏', type:'troop', cost:3, hp:4, max:3, triggers:[8], timing:'opponent', requiresTemple:'black_temple', onTrigger:{kind:'active_loses_per_temple', temple:'black_temple', per:2} },
      { key:'black_tithetaker', name:'Tithe Taker', emoji:'üßæ', type:'troop', cost:4, hp:5, max:3, triggers:[5], timing:'every', requiresTemple:'black_temple', onTrigger:{kind:'lose_hp_gain_coins', lose:2, coins:3} },
      { key:'black_falseprophet', name:'False Prophet', emoji:'üóø', type:'troop', cost:5, hp:6, max:3, triggers:[11], timing:'every', requiresTemple:'black_temple', onTrigger:{kind:'others_sacrifice_cards_per_temple', temple:'black_temple'} },
      { key:'black_oathbreaker', name:'Oathbreaker', emoji:'üó°Ô∏èü©∏', type:'troop', cost:6, hp:7, max:3, triggers:[7], timing:'your', requiresTemple:'black_temple', onTrigger:{kind:'lose_then_attack_any', lose:1, dmg:8} },
      { key:'black_necromancer', name:'Necromancer', emoji:'üíÄ', type:'troop', cost:8, hp:9, max:3, triggers:[9], timing:'every', requiresTemple:'black_temple', onTrigger:{kind:'destroy_troop'} },
      { key:'black_altar', name:'Altar', emoji:'‚õìÔ∏è', type:'structure', cost:5, hp:6, max:3, triggers:[], timing:'passive', passive:{altar:true} },

      // Red
      { key:'red_temple', name:'Red Temple', emoji:'üî¥‚õ™', type:'structure', cost:4, hp:5, max:3, triggers:[6], timing:'your', onTrigger:{kind:'attack_any', value:2} },
      { key:'red_warrior', name:'Warrior', emoji:'üó°Ô∏è', type:'troop', cost:3, hp:5, max:3, triggers:[7], timing:'your', requiresTemple:'red_temple', onTrigger:{kind:'attack_any', value:4} },
      { key:'red_raider', name:'Raider', emoji:'üè¥‚Äç‚ò†Ô∏è', type:'troop', cost:4, hp:5, max:3, triggers:[6], timing:'opponent', requiresTemple:'red_temple', onTrigger:{kind:'steal_and_make_sacrifice_farm', steal:1} },
      { key:'red_barbarian', name:'Barbarian', emoji:'ü™ì', type:'troop', cost:5, hp:7, max:3, triggers:[9], timing:'your', requiresTemple:'red_temple', onTrigger:{kind:'destroy_farm_and_damage_per_temple', temple:'red_temple', per:2} },
      { key:'red_ranger', name:'Ranger', emoji:'üèπ', type:'troop', cost:6, hp:7, max:3, triggers:[7], timing:'every', requiresTemple:'red_temple', onTrigger:{kind:'damage_per_temple_and_gain', temple:'red_temple', per:1, coins:2} },
      { key:'red_warlord', name:'Warlord', emoji:'‚öîÔ∏è', type:'troop', cost:8, hp:10, max:3, triggers:[11,12], timing:'your', requiresTemple:'red_temple', onTrigger:{kind:'destroy_structure_and_attack_any', dmg:5} },
      { key:'red_fortress', name:'Fortress', emoji:'üèØ', type:'structure', cost:7, hp:9, max:2, triggers:[], timing:'passive', passive:{fortress:true} },

      // Green
      { key:'green_temple', name:'Green Temple', emoji:'üü¢‚õ™', type:'structure', cost:4, hp:5, max:3, triggers:[6], timing:'your', onTrigger:{kind:'earn', value:1} },
      { key:'green_shaman', name:'Shaman', emoji:'üåÄ', type:'troop', cost:3, hp:5, max:3, triggers:[5], timing:'every', requiresTemple:'green_temple', onTrigger:{kind:'earn', value:2} },
      { key:'green_sage', name:'Sage', emoji:'üåø', type:'troop', cost:4, hp:6, max:3, triggers:[7], timing:'every', requiresTemple:'green_temple', onTrigger:{kind:'heal_and_earn', heal:3, coins:3} },
      { key:'green_druid', name:'Druidic Warrior', emoji:'üßô‚Äç‚ôÇÔ∏è', type:'troop', cost:5, hp:8, max:3, triggers:[9], timing:'your', requiresTemple:'green_temple', onTrigger:{kind:'attack_any_per_temple', temple:'green_temple', per:2} },
      { key:'green_goliath', name:'Goliath', emoji:'üóø', type:'troop', cost:7, hp:12, max:2, triggers:[11,12], timing:'your', requiresTemple:'green_temple', onTrigger:{kind:'goliath_special'} },
      { key:'green_elemental', name:'Elemental', emoji:'üå™Ô∏è', type:'troop', cost:8, hp:10, max:2, triggers:[9,10], timing:'your', requiresTemple:'green_temple', onTrigger:{kind:'gain_and_destroy_two_walls', coins:4} },
      { key:'green_livingwall', name:'Living Wall', emoji:'üå≥', type:'wall', cost:6, hpDynamic:{perTemple:'green_temple', perHP:2}, max:3, triggers:[], timing:null },
    ];
    const CARD_CATALOG = {}; for (const c of RAW_CARDS){ CARD_CATALOG[c.key] = { ...c }; }
    const STARTERS = ['townhall','farm','mill'];

    // ---------- Helpers / UI ----------
    const $ = s=>document.querySelector(s);
    const logDiv = $('#log');
    function logLine(msg){ const d=document.createElement('div'); d.className='logLine'; d.textContent=msg; logDiv.appendChild(d); logDiv.scrollTop=logDiv.scrollHeight; }

    // ---------- Game State (stored in lobbies/{lobbyId}) ----------
    let me = { name: myName, idx: -1 };
    let state = null;
    let isHost = false;
    let rng = null;
    let unsubLobby = null, unsubIntents = null;

    // ---------- Rendering ----------
    function emojiClumpForPlayer(p){
      const owned = p.owned||[];
      const sorted = owned.slice().sort((a,b)=>(CARD_CATALOG[a.key]?.type||'').localeCompare(CARD_CATALOG[b.key]?.type||'')); 
      let s=''; for (const e of sorted){ const c=CARD_CATALOG[e.key]; if(!c) continue; const em=Array.from({length:e.count||1},()=>c.emoji).join(''); s+=`${em}${e.hp!=null?' ('+e.hp+')':''} `; }
      return s.trim();
    }
    function render(){
      const hdrLobby=$('#hdrLobby'), hdrUser=$('#hdrUser'), hdrRole=$('#hdrRole');
      hdrLobby.style.display=lobbyId?'':'none'; hdrLobby.textContent='Lobby: '+lobbyId;
      hdrUser.style.display=myName?'':'none'; hdrUser.textContent=myName;
      hdrRole.style.display=isHost?'':'none'; hdrRole.textContent='Host';

      const panels=[$('#p0'),$('#p1'),$('#p2'),$('#p3')]; panels.forEach(p=>{p.innerHTML=''; p.classList.remove('you','active');});
      if (!state) return;

      const players=state.players||[]; const turnIdx=state.turnIdx??0;
      players.forEach((p,i)=>{
        const panel=panels[i]; if (!panel) return;
        panel.classList.toggle('you',p.name===me.name); panel.classList.toggle('active',i===turnIdx);
        const hdr=document.createElement('div'); hdr.className='hdr';
        hdr.innerHTML=`<div><strong>${p.name}</strong> ${i===turnIdx?'<span class="pill">Active</span>':''}</div>
                       <div class="hp">üí∞ ${p.gold||0} | üè∞ ${p.townHp||0}</div>`;
        const cl=document.createElement('div'); cl.className='emojiClump'; cl.textContent=emojiClumpForPlayer(p);
        const mt=document.createElement('div'); mt.className='meta';
        mt.textContent=(p.unlocked==='d20'?'d20':p.unlocked==='2d6'?'2d6':'d6')+' unlocked';
        panel.appendChild(hdr); panel.appendChild(cl); panel.appendChild(mt);
      });

      renderControls(); renderShop(); renderQueueAndTargets();
    }
    function myPlayer(){ if (!state) return null; return (state.players||[]).find(p=>p.name===me.name)||null; }
    function isMyTurn(){ const p=myPlayer(); if (!p||!state) return false; return (state.players||[]).findIndex(x=>x.name===p.name)===(state.turnIdx??0); }
    function allowedDiceFor(player){ const u=player?.unlocked||'d6'; if (u==='d20') return ['d6','2d6','d20']; if (u==='2d6') return ['d6','2d6']; return ['d6']; }
function renderControls(){
  const p = myPlayer();
  const dieSel = $('#dieSelect');

  if (!p){
    if (dieSel) dieSel.innerHTML = '<option>d6</option>';
    $('#rollBtn').disabled = true;
    $('#resolveBtn').disabled = true;
    $('#applyTargetBtn').disabled = true;
    $('#endTurnBtn').disabled = true;
    const lb = $('#lastRollBadge'); if (lb) lb.style.display='none';
    return;
  }

  if (dieSel){
    dieSel.innerHTML = allowedDiceFor(p).map(o=>`<option value="${o}">${o}</option>`).join('');
  }

  const isTurn   = isMyTurn();
  const phase    = state?.phase || 'await_roll';
  const resolving = (phase === 'resolving');

  // Look at the *current* queue item to decide if a target is needed
  let needsT = false;
  if (resolving){
    const cur = (state?.resolveQueue || [])[0];
    if (cur){
      const kind = CARD_CATALOG[cur.key]?.onTrigger?.kind;
      needsT = triggerNeedsTarget(kind);
    }
  }

  $('#rollBtn').disabled        = !isTurn || (phase !== 'await_roll');
  $('#resolveBtn').disabled     = !isTurn || !resolving || needsT;   // disabled if a target is needed
  $('#applyTargetBtn').disabled = !isTurn || !resolving || !needsT;  // enabled only when a target is needed
  $('#endTurnBtn').disabled     = !isTurn; // always available on your turn (with forfeit logic in handler)

  // Last roll badge
  const lb = $('#lastRollBadge');
  if (lb){
    if (state?.lastRoll?.value){
      lb.style.display = '';
      lb.textContent = `Last roll: ${state.lastRoll.value} (${state.lastRoll.mode})`;
    } else {
      lb.style.display = 'none';
    }
  }
}

    function renderShop(){
      const shop=$('#shop'); shop.innerHTML=''; const p=myPlayer(); if (!p) return;
      Object.values(CARD_CATALOG).forEach(card=>{
        if (card.immutable) return;
        if (card.requiresTemple){
          const hasTemple=(p.owned||[]).some(e=>e.key===card.requiresTemple);
          if (!hasTemple) return;
        }
        const have=(p.owned||[]).find(e=>e.key===card.key)?.count||0;
        const max=card.max??3; if (have>=max) return;

        const div=document.createElement('div'); div.className='shopItem';
        const trig = card.triggers?.length?(' | Roll: '+card.triggers.join(',')):''; 
        div.innerHTML=`<h4>${card.emoji} ${card.name}</h4>
          <div class="small">Cost: ${card.cost} | HP: ${card.hp ?? '‚Äî'}${trig}</div>
          <button ${( !isMyTurn() || state?.phase!=='buy' || (p.gold||0) < card.cost )?'disabled':''} data-key="${card.key}">Buy</button>`;
        div.querySelector('button').addEventListener('click', ()=>intentBuy(card.key));
        shop.appendChild(div);
      });
    }

    // ---------- Target UI ----------
    function triggerNeedsTarget(kind){
      return ['attack_any','attack_structure','attack_troop','attack_any_and_heal','attack_any_and_destroy_troop','destroy_troop','destroy_structure_non_temple','destroy_structure_and_attack_any','lose_then_attack_any','goliath_special','damage_per_temple_and_gain','attack_any_per_temple'].includes(kind);
    }
    function allowedTargetTypesFor(kind){
      switch(kind){
        case 'attack_any':
        case 'attack_any_and_heal':
        case 'attack_any_per_temple':
        case 'lose_then_attack_any':
        case 'damage_per_temple_and_gain':
          return ['troop','structure','townhall'];
        case 'attack_any_and_destroy_troop':
          return ['troop','structure','townhall'];
        case 'attack_structure':
        case 'destroy_structure_non_temple':
        case 'destroy_structure_and_attack_any':
          return ['wall','structure','townhall'];
        case 'attack_troop':
        case 'destroy_troop':
          return ['troop'];
        case 'goliath_special':
          return ['wall','troop','structure','townhall'];
        default: return [];
      }
    }
    function listTargetableEntries(p, type){
      const owned=p.owned||[];
      if (type==='troop') return owned.map((e,idx)=>({idx, e, c:CARD_CATALOG[e.key]})).filter(x=>x.c?.type==='troop' && x.e.hp>0);
      if (type==='wall')  return owned.map((e,idx)=>({idx, e, c:CARD_CATALOG[e.key]})).filter(x=>x.c?.type==='wall' && x.e.hp>0);
      if (type==='structure') return owned.map((e,idx)=>({idx, e, c:CARD_CATALOG[e.key]})).filter(x=>x.c?.type==='structure' && x.e.key!=='townhall' && x.e.hp>0);
      return [];
    }
 function renderQueueAndTargets(){
  const qb = $('#queueBox'); qb.innerHTML = '';
  const tb = $('#targetBox'); tb.innerHTML = '';
  if (!state) return;

  const q = state.resolveQueue || [];
  if (!q.length){
    qb.innerHTML = '<div class="small">No triggers pending.</div>';
    return;
  }

  const current = q[0];
  const owner   = (state.players || [])[current.ownerIdx];
  const card    = CARD_CATALOG[current.key];

  const title = document.createElement('div');
  title.innerHTML = `<div><b>Current trigger:</b> ${owner.name} ‚Äî ${card.emoji} ${card.name}${current.roll ? ` (roll ${current.roll})` : ''}</div>`;
  qb.appendChild(title);

  if (q.length > 1){
    const ol = document.createElement('div'); ol.className = 'small';
    for (let i = 1; i < q.length; i++){
      const t = q[i], o = (state.players||[])[t.ownerIdx], c = CARD_CATALOG[t.key];
      const line = document.createElement('div'); line.className = 'qItem';
      line.textContent = `${i+1}. ${o.name} ‚Äî ${c.name}`;
      ol.appendChild(line);
    }
    qb.appendChild(ol);
  }

  if (isMyTurn()){
    const kind = card.onTrigger?.kind;
    if (triggerNeedsTarget(kind)){
      const box = document.createElement('div'); 
      box.className = 'needTarget';
      const opts = allowedTargetTypesFor(kind);

      const selP = document.createElement('select'); selP.id = 'selTargetPlayer';
      const selT = document.createElement('select'); selT.id = 'selTargetType';
      const selE = document.createElement('select'); selE.id = 'selTargetEntry';

      const enemies = (state.players||[]).filter(p => !p.eliminated && p.name !== owner.name);

      // helper to enable/disable the Apply button based on current selection
      const refreshApplyButton = () => {
        const applyBtn = document.getElementById('applyTargetBtn');
        if (!applyBtn) return;
        const tName = selP.value;
        const tType = selT.value;
        const tIdx  = selE.disabled ? null : selE.value; // '' means none
        const hasTargetPlayer = !!tName && enemies.some(e => e.name === tName);
        const validTown = (tType === 'townhall') ? (((state.players||[]).find(p=>p.name===tName)?.townHp || 0) > 0) : true;
        const validEntry = (tType === 'townhall') ? true : (tIdx !== '');
        applyBtn.disabled = !(hasTargetPlayer && validTown && validEntry);
      };

      // Populate enemies
      if (!enemies.length){
        selP.innerHTML = '<option value="">(no enemy)</option>';
      } else {
        enemies.forEach(p => {
          const o = document.createElement('option');
          o.value = p.name; o.textContent = p.name; selP.appendChild(o);
        });
      }

      // Populate types
      opts.forEach(t => {
        const o = document.createElement('option');
        o.value = t; o.textContent = t; selT.appendChild(o);
      });

      function refillEntries(){
        selE.innerHTML = '';
        const targetName = selP.value;
        const typ = selT.value;
        const target = (state.players||[]).find(p => p.name === targetName);

        if (!target){
          selE.disabled = true;
          const o = document.createElement('option'); o.value=''; o.textContent='(no target)'; selE.appendChild(o);
          refreshApplyButton();
          return;
        }

        if (typ === 'townhall'){
          selE.disabled = true;
          const dead = (target.townHp || 0) <= 0;
          const o = document.createElement('option'); 
          o.value = ''; 
          o.textContent = dead ? '(Town Hall destroyed)' : '(Town Hall)';
          selE.appendChild(o);
          refreshApplyButton();
          return;
        }

        selE.disabled = false;
        const items = listTargetableEntries(target, typ);
        if (!items.length){
          const o = document.createElement('option'); o.value=''; o.textContent='(none)'; selE.appendChild(o);
          selE.disabled = true; // nothing to pick
          refreshApplyButton();
          return;
        }

        items.forEach(it => {
          const o = document.createElement('option');
          o.value = String(it.idx);
          o.textContent = `${it.c.emoji} ${it.c.name} (HP ${it.e.hp})`;
          selE.appendChild(o);
        });

        refreshApplyButton();
      }

      selP.addEventListener('change', () => { refillEntries(); });
      selT.addEventListener('change', () => { refillEntries(); });
      selE.addEventListener('change', () => { refreshApplyButton(); });

      // Preselect first entries and fill
      if (selP.options.length) selP.selectedIndex = 0;
      if (selT.options.length) selT.selectedIndex = 0;
      refillEntries();

      box.appendChild(document.createTextNode('Target: '));
      box.appendChild(selP);
      box.appendChild(selT);
      box.appendChild(selE);
      tb.appendChild(box);
    } else {
      const note = document.createElement('div'); note.className = 'small';
      note.textContent = 'This effect needs no target. Use "Resolve Next".';
      tb.appendChild(note);
    }
  }
}



    // ---------- Engine (same logic, stored under lobbies/{id}) ----------
    function computeUnlockForPlayer(p){
      let u='d6'; for (const e of (p.owned||[])){ const c=CARD_CATALOG[e.key]; if (!c) continue;
        for (const n of (c.triggers||[])){ if (n>=7 && n<=12) u='2d6'; if (n>=13) return 'd20'; } }
      return u;
    }
    function rollDie(mode, rdRef = state){
  if (!rng) rng = mulberry32((rdRef.seed||1) + (rdRef.rollCount||0));
  if (mode==='d6') return 1+Math.floor(rng()*6);
  if (mode==='2d6') return (1+Math.floor(rng()*6)) + (1+Math.floor(rng()*6));
  if (mode==='d20') return 1+Math.floor(rng()*20);
  return 1;
}
    function addOrIncOwned(p,key){
      const c=CARD_CATALOG[key]; if (!c) return;
      let hp=c.hp;
      if (c.hpDynamic){ const temples=(p.owned||[]).find(e=>e.key===c.hpDynamic.perTemple)?.count||0; hp=Math.max(1, temples*(c.hpDynamic.perHP||1)); }
      const f=(p.owned||[]).find(e=>e.key===key);
      if (f){ f.count=(f.count||1)+1; f.hp=hp; } else { (p.owned||(p.owned=[])).push({key, count:1, hp}); }
    }
      function damageEntry(entry, dmg, owner, rd){
    entry.hp = Math.max(0,(entry.hp||0)-(dmg||0));
    if (entry.hp<=0){
      const diedCard = CARD_CATALOG[entry.key];
      if (diedCard?.type==='troop'){
        for (const pl of (rd.players||[])){
          if ((pl.owned||[]).some(e=>e.key==='black_altar')) pl.gold = (pl.gold||0)+1;
        }
      }
      entry.count = (entry.count||1)-1;
      if (entry.count>0){ entry.hp = CARD_CATALOG[entry.key]?.hp || 1; }
      else { entry._remove = true; }
    }
  }

    function firstOfTypeIdx(p, type){
      const owned=p.owned||[];
      if (type==='troop') return owned.findIndex(e=>CARD_CATALOG[e.key]?.type==='troop' && e.hp>0);
      if (type==='wall')  return owned.findIndex(e=>CARD_CATALOG[e.key]?.type==='wall' && e.hp>0);
      if (type==='structure') return owned.findIndex(e=>CARD_CATALOG[e.key]?.type==='structure' && e.key!=='townhall' && e.hp>0);
      return -1;
    }
    function applyAttackToSpecific(owner, target, targetType, targetIdx, rawDmg, rd){
      const troopBuff = (owner.owned||[]).some(e=>e.key==='red_fortress') ? 1 : 0;
      const dmg = rawDmg + troopBuff;
      if (targetType==='townhall'){ target.townHp = Math.max(0,(target.townHp||0)-dmg); return `hits ${target.name}'s üè∞ Town Hall for ${dmg}.`; }
      if (targetIdx==null || targetIdx<0) return 'no valid target.';
      const entry = target.owned[targetIdx]; if (!entry) return 'no valid target.';
      damageEntry(entry, dmg, target, rd);
      return `hits ${target.name}'s ${CARD_CATALOG[entry.key].name} for ${dmg}.`;
    }

    function destroySpecific(target, targetType, targetIdx, allowTemple=true, rd){
      if (targetType==='townhall') return 'cannot destroy Town Hall.';
      if (targetIdx==null || targetIdx<0) return 'no valid target.';
      const entry = target.owned[targetIdx]; if (!entry) return 'no valid target.';
      const isTemple = /temple/i.test(CARD_CATALOG[entry.key]?.name||'');
      if (!allowTemple && isTemple) return 'cannot destroy Temple with this effect.';
      damageEntry(entry, entry.hp||9999, target, rd);
      return `destroys ${target.name}'s ${CARD_CATALOG[entry.key].name}.`;
    }
const INSTANT_EARN_KINDS = new Set(['earn', 'earn_per_temple']);

function applyInstantIncome(owner, card){
  const ot = card.onTrigger || {};
  if (ot.kind === 'earn') {
    const v = ot.value || 0;
    owner.gold = (owner.gold || 0) + v;
    return v;
  }
  if (ot.kind === 'earn_per_temple') {
    const n = (owner.owned||[]).find(e=>e.key===ot.temple)?.count || 0;
    const amt = n * (ot.per || 0);
    owner.gold = (owner.gold || 0) + amt;
    return amt;
  }
  return 0;
}

   function buildResolveQueueAfterRoll(rd, rollerIdx, rollVal){
  const q = [];
  const players = rd.players || [];
  const earnedBy = new Map(); // name -> coins earned this roll

  players.forEach((p,i)=>{
    const timing = (i===rollerIdx) ? ['every','your'] : ['opponent'];
    (p.owned||[]).forEach(e=>{
      const c = CARD_CATALOG[e.key]; if (!c) return;
      if (!c.triggers?.includes(rollVal)) return;
      if (!c.timing || !timing.includes(c.timing)) return;

      const copies = Math.max(1, e.count||1);
      for (let k=0; k<copies; k++){
        const kind = c.onTrigger?.kind;
        if (INSTANT_EARN_KINDS.has(kind)){
          const got = applyInstantIncome(p, c);
          if (got>0) earnedBy.set(p.name, (earnedBy.get(p.name)||0) + got);
        } else {
          q.push({ ownerIdx:i, key:e.key, roll:rollVal });
        }
      }
    });
  });

  // Make a tiny summary like: "Auto‚Äëincome: Alice +2, Bob +1"
  const parts = [];
  earnedBy.forEach((amt, nm) => parts.push(`${nm} +${amt}`));
  const autoNote = parts.length ? `Auto‚Äëincome: ${parts.join(', ')}` : '';

  return { q, autoNote };
}

    function postResolveCleanup(rd){
      for (const pl of rd.players){ pl.owned = (pl.owned||[]).filter(e=>!e._remove); }
      for (const p of rd.players){ if (!p.eliminated && (p.townHp||0)<=0){ p.eliminated=true; p.owned=[]; p.gold=0; } }
    }
function hostResolveOne(rd, manual){
  const stack = rd.resolveQueue || [];
  if (!stack.length) return { changed:false, msg:'No triggers.' };

  const trig  = stack[0];
  const owner = rd.players[trig.ownerIdx];
  const card  = CARD_CATALOG[trig.key];
  const kind  = card.onTrigger?.kind;
  let msg     = `${owner.name} triggers ${card.emoji} ${card.name}: `;
  const activeName   = rd.lastRoll?.by;
  const activePlayer = (rd.players||[]).find(p=>p.name===activeName) || null;

  const needsTarget = triggerNeedsTarget(kind);

  // --- If this trigger needs a target but there are none, auto-skip it
  if (needsTarget){
    const ownerPlayer = rd.players[trig.ownerIdx];
    const enemies = (rd.players||[]).filter(p=>!p.eliminated && p.name!==ownerPlayer.name);
    const kinds = allowedTargetTypesFor(kind);
    const enemyHasAnyValid = enemies.some(ep=>{
      return kinds.some(typ=>{
        if (typ==='townhall') return (ep.townHp||0) > 0;
        const items = listTargetableEntries(ep, typ);
        return items.length > 0;
      });
    });
    if (!enemyHasAnyValid){
      rd.resolveQueue.shift();
      postResolveCleanup(rd);
      return { changed:true, msg: `${owner.name}'s ${card.name} had no valid targets (skipped).` };
    }
  }

  // If target needed but not provided, ask the UI to provide it
if (needsTarget && !manual){
  const ownerPlayer = rd.players[trig.ownerIdx];
  const enemies = (rd.players||[]).filter(p=>!p.eliminated && p.name!==ownerPlayer.name);
  const types = allowedTargetTypesFor(kind);

  let possibleTargets = [];
  enemies.forEach(ep=>{
    types.forEach(typ=>{
      if (typ==='townhall' && (ep.townHp||0)>0){
        possibleTargets.push({ player:ep, type:'townhall', idx:null });
      } else {
        listTargetableEntries(ep, typ).forEach(it=>{
          possibleTargets.push({ player:ep, type:typ, idx:it.idx });
        });
      }
    });
  });

  if (possibleTargets.length === 1){
    const pick = possibleTargets[0];
    manual = { targetPlayer: pick.player.name, targetType: pick.type, targetEntryIdx: pick.idx };
    // fall through to normal targeted handling
  } else {
    return { changed:false, msg:'Target required.' };
  }
}

  const applyAndShift = (extraMsg) => {
    stack.shift();
    rd.resolveQueue = stack;
    postResolveCleanup(rd);
    return { changed:true, msg: extraMsg ? (msg + extraMsg) : msg };
  };

  switch(kind){
    // ----- Non-targeted effects -----
    case 'earn': {
      const v = (card.onTrigger.value||0);
      owner.gold = (owner.gold||0) + v;
      return applyAndShift(`+${v} coin(s).`);
    }
    case 'earn_per_temple': {
      const n = (owner.owned||[]).find(e=>e.key===card.onTrigger.temple)?.count || 0;
      const amt = n * (card.onTrigger.per||0);
      owner.gold = (owner.gold||0) + amt;
      return applyAndShift(`+${amt} coin(s).`);
    }
    case 'heal_town': {
      const v = (card.onTrigger.value||0);
      owner.townHp = (owner.townHp||0) + v;
      return applyAndShift(`heals Town Hall ${v}.`);
    }
    case 'heal_and_earn': {
      const h = (card.onTrigger.heal||0);
      const c = (card.onTrigger.coins||0);
      owner.townHp = (owner.townHp||0) + h;
      owner.gold   = (owner.gold||0) + c;
      return applyAndShift(`heals ${h} & +${c} coins.`);
    }
    case 'each_other_lose_hp': {
      const v = (card.onTrigger.value||0);
      (rd.players||[]).forEach((p,i)=>{
        if (i!==trig.ownerIdx && !p.eliminated){
          p.townHp = Math.max(0, (p.townHp||0) - v);
        }
      });
      return applyAndShift(`each other player loses ${v}.`);
    }
    case 'active_loses_per_temple': {
      const t = activePlayer; if (!t) return applyAndShift('no active opponent.');
      const n = (owner.owned||[]).find(e=>e.key===card.onTrigger.temple)?.count || 0;
      const loss = n * (card.onTrigger.per||0);
      t.townHp = Math.max(0, (t.townHp||0) - loss);
      return applyAndShift(`${t.name} loses ${loss} health.`);
    }
    case 'lose_hp_gain_coins': {
      const lose = (card.onTrigger.lose||0);
      const gain = (card.onTrigger.coins||0);
      owner.townHp = Math.max(0, (owner.townHp||0) - lose);
      owner.gold   = (owner.gold||0) + gain;
      return applyAndShift(`loses ${lose}, gains ${gain} coins.`);
    }
    case 'others_sacrifice_cards_per_temple': {
      const times = (owner.owned||[]).find(e=>e.key===card.onTrigger.temple)?.count || 0;
      (rd.players||[]).forEach((p,i)=>{
        if (i===trig.ownerIdx || p.eliminated) return;
        for (let k=0;k<times;k++){
          let idx = firstOfTypeIdx(p,'troop');
          if (idx<0) idx = firstOfTypeIdx(p,'structure');
          if (idx<0) idx = firstOfTypeIdx(p,'wall');
          if (idx>=0) damageEntry(p.owned[idx], p.owned[idx].hp||9999, p, rd);
        }
      });
      return applyAndShift(`others sacrifice ${times} card(s).`);
    }
    case 'steal_fixed': {
      const act = activePlayer; if (!act) return applyAndShift('no active.');
      const amt = Math.min((act.gold||0), (card.onTrigger.value||0));
      act.gold   = (act.gold||0) - amt;
      owner.gold = (owner.gold||0) + amt;
      return applyAndShift(`steals ${amt} from ${act.name}.`);
    }
    case 'steal_and_make_sacrifice_farm': {
      const act = activePlayer; if (!act) return applyAndShift('no active.');
      const amt = Math.min((act.gold||0), 1);
      act.gold   = (act.gold||0) - amt;
      owner.gold = (owner.gold||0) + amt;
      const fIdx = (act.owned||[]).findIndex(e=>e.key==='farm' && e.hp>0);
      if (fIdx>=0) damageEntry(act.owned[fIdx], act.owned[fIdx].hp||9999, act, rd);
      return applyAndShift(`steals ${amt} from ${act.name}${fIdx>=0? ' and forces a Farm to be sacrificed.':'.'}`);
    }

    // ----- Targeted effects -----
    case 'attack_any':
    case 'attack_structure':
    case 'attack_troop':
    case 'attack_any_and_heal':
    case 'attack_any_per_temple':
    case 'damage_per_temple_and_gain':
    case 'lose_then_attack_any':
    case 'attack_any_and_destroy_troop':
    case 'destroy_troop':
    case 'destroy_structure_non_temple':
    case 'destroy_structure_and_attack_any':
    case 'goliath_special': {
      const tName = manual?.targetPlayer;
      const tType = manual?.targetType;
      const tIdx  = (manual?.targetEntryIdx!=null) ? Number(manual.targetEntryIdx) : null;
      const target = (rd.players||[]).find(p=>p.name===tName);
      if (!target) return applyAndShift('no enemy.');

      switch(kind){
        case 'attack_any': {
          const out = applyAttackToSpecific(owner, target, tType, tIdx, (card.onTrigger.value||0), rd);
          return applyAndShift(out);
        }
        case 'attack_structure': {
          if (tType==='troop') return applyAndShift('invalid target (troop).');
          const out = applyAttackToSpecific(owner, target, tType, tIdx, (card.onTrigger.value||0), rd);
          return applyAndShift(out);
        }
        case 'attack_troop': {
          if (tType!=='troop') return applyAndShift('invalid target (needs troop).');
          const out = applyAttackToSpecific(owner, target, 'troop', tIdx, (card.onTrigger.value||0), rd);
          return applyAndShift(out);
        }
        case 'attack_any_and_heal': {
          const out = applyAttackToSpecific(owner, target, tType, tIdx, (card.onTrigger.dmg||0), rd);
          owner.townHp = (owner.townHp||0) + (card.onTrigger.heal||0);
          return applyAndShift(out + ` Heals ${card.onTrigger.heal||0}.`);
        }
        case 'attack_any_per_temple': {
          const n = (owner.owned||[]).find(e=>e.key===card.onTrigger.temple)?.count || 0;
          const out = applyAttackToSpecific(owner, target, tType, tIdx, n*(card.onTrigger.per||0), rd);
          return applyAndShift(out);
        }
        case 'damage_per_temple_and_gain': {
          const n = (owner.owned||[]).find(e=>e.key===card.onTrigger.temple)?.count || 0;
          const out = applyAttackToSpecific(owner, target, tType, tIdx, n*(card.onTrigger.per||0), rd);
          owner.gold = (owner.gold||0) + (card.onTrigger.coins||0);
          return applyAndShift(out + ` Gains ${card.onTrigger.coins||0} coins.`);
        }
        case 'lose_then_attack_any': {
          owner.townHp = Math.max(0, (owner.townHp||0) - (card.onTrigger.lose||0));
          const out = applyAttackToSpecific(owner, target, tType, tIdx, (card.onTrigger.dmg||0), rd);
          return applyAndShift(`loses ${card.onTrigger.lose||0}. ` + out);
        }
        case 'attack_any_and_destroy_troop': {
          const out = applyAttackToSpecific(owner, target, tType, tIdx, (card.onTrigger.dmg||0), rd);
          const troopIdx = firstOfTypeIdx(target,'troop');
          if (troopIdx>=0) damageEntry(target.owned[troopIdx], target.owned[troopIdx].hp||9999, target, rd);
          return applyAndShift(out + (troopIdx>=0 ? ` Destroys a troop.` : ` No troop to destroy.`));
        }
        case 'destroy_troop': {
          if (tType!=='troop') return applyAndShift('invalid target (needs troop).');
          const out = destroySpecific(target, 'troop', tIdx, true, rd);
          return applyAndShift(out);
        }
        case 'destroy_structure_non_temple': {
          if (tType==='troop') return applyAndShift('invalid target.');
          const out = destroySpecific(target, 'structure', tIdx, /*allowTemple*/false, rd);
          return applyAndShift(out);
        }
        case 'destroy_structure_and_attack_any': {
          if (tType==='troop') return applyAndShift('invalid first target.');
          const out1 = destroySpecific(target, 'structure', tIdx, true, rd);
          const out2 = applyAttackToSpecific(owner, target, 'structure', firstOfTypeIdx(target,'structure'), (card.onTrigger.dmg||0), rd);
          return applyAndShift(out1 + ' ' + out2);
        }
        case 'goliath_special': {
          if (trig.roll===12){
            const wIdx = firstOfTypeIdx(target,'wall');  if (wIdx>=0) damageEntry(target.owned[wIdx], target.owned[wIdx].hp||9999, target, rd);
            const trIdx= firstOfTypeIdx(target,'troop'); if (trIdx>=0) damageEntry(target.owned[trIdx], target.owned[trIdx].hp||9999, target, rd);
            const out  = applyAttackToSpecific(owner, target, tType, tIdx, 10, rd);
            return applyAndShift(`${wIdx>=0?'destroys a wall. ':''}${trIdx>=0?'destroys a troop. ':''}${out}`);
          } else {
            const out = applyAttackToSpecific(owner, target, tType, tIdx, 10, rd);
            return applyAndShift(out);
          }
        }
      }
      break;
    }

    // ----- Acquire UI (minimal auto-pick for now) -----
    case 'acquire_troop_cost_leq_temples': {
      const tCount = (owner.owned||[]).find(e=>e.key===card.onTrigger.temple)?.count || 0;
      const maxCost = tCount;
      const choices = Object.values(CARD_CATALOG)
        .filter(c => c.type==='troop' && (c.cost||0) <= maxCost);
      if (choices.length){
        // simple heuristic: cheapest, then highest HP
        choices.sort((a,b)=> (a.cost-b.cost) || ((b.hp||0)-(a.hp||0)));
        addOrIncOwned(owner, choices[0].key);
        owner.unlocked = computeUnlockForPlayer(owner);
        return applyAndShift(`acquires ${choices[0].name} (cost ‚â§ ${maxCost}).`);
      }
      return applyAndShift(`no troop available at cost ‚â§ ${maxCost}.`);
    }
  }

  // Fallback ‚Äî should rarely hit
  stack.shift();
  rd.resolveQueue = stack;
  postResolveCleanup(rd);
  return { changed:true, msg };
}


  // Add this once (top-level, above the function)
let _processingIntents = false;

async function hostApplyIntents(){
  if (!isHost || !state) return;
  if (_processingIntents) return;           // prevent parallel runs
  _processingIntents = true;
  try {
    const movesRef = collection(db, 'lobbies', lobbyId, 'intents');
    const qy = query(movesRef, orderBy('ts', 'asc'), limit(25));
    const snap = await getDocs(qy);

    for (const d of snap.docs){
      const mv = d.data(); 
      if (mv.processed) continue;

      await runTransaction(db, async (tx) => {
        const ref = doc(db, 'lobbies', lobbyId);
        const rs  = await tx.get(ref); 
        if (!rs.exists()) return;

        const rd = rs.data().game || null; 
        if (!rd) return;                   // no game yet

        const players = rd.players || [];
        const tIdx    = rd.turnIdx ?? 0;
        const phase   = rd.phase || 'await_roll';
        const actor   = players[tIdx];
        const isActor = mv.from === actor?.name;

        // --- ROLL ---
       // --- ROLL ---
if (mv.type === 'ROLL' && isActor && phase === 'await_roll') {
  const mode = mv.payload?.mode || 'd6';
  const v = rollDie(mode, rd); // use rd for seed/rollCount

  rd.lastRoll = { mode, value: v, by: actor.name };
  rd._lastMsg = `${actor.name} rolled ${v} (${mode}).`;

  const { q, autoNote } = buildResolveQueueAfterRoll(rd, tIdx, v); // <-- destructure
  rd.resolveQueue = q;
  rd.phase = q.length ? 'resolving' : 'buy';

  if (autoNote) rd._lastMsg += ' ‚Äî ' + autoNote;
  rd.rollCount = (rd.rollCount || 0) + 1;

  tx.update(ref, { game: rd });
  tx.update(doc(db, 'lobbies', lobbyId, 'intents', d.id), { processed: true });
  return;
}



        // --- RESOLVE (no target) ---
        if (mv.type === 'RESOLVE_NEXT' && isActor && phase === 'resolving'){
          const res = hostResolveOne(rd, null);
          rd._lastMsg = res.msg;
          if (!(rd.resolveQueue?.length)) rd.phase = 'buy';

          tx.update(ref, { game: rd });
          tx.update(doc(db, 'lobbies', lobbyId, 'intents', d.id), { processed: true });
          return;
        }

        // --- RESOLVE (with target) ---
        if (mv.type === 'RESOLVE_WITH_TARGET' && isActor && phase === 'resolving'){
          const manual = {
            targetPlayer:   mv.payload?.targetPlayer,
            targetType:     mv.payload?.targetType,
            targetEntryIdx: mv.payload?.targetEntryIdx
          };
          const res = hostResolveOne(rd, manual);
          rd._lastMsg = res.msg;
          if (!(rd.resolveQueue?.length)) rd.phase = 'buy';

          tx.update(ref, { game: rd });
          tx.update(doc(db, 'lobbies', lobbyId, 'intents', d.id), { processed: true });
          return;
        }

        // --- BUY ---
        if (mv.type === 'BUY' && isActor && phase === 'buy'){
          const key  = mv.payload?.key; 
          const card = CARD_CATALOG[key];
          if (card){
            const have     = (actor.owned?.find(e => e.key === key)?.count) || 0;
            const max      = card.max ?? 3;
            const okTemple = !card.requiresTemple || (actor.owned || []).some(e => e.key === card.requiresTemple);
            if ((actor.gold || 0) >= card.cost && have < max && okTemple){
              actor.gold    -= card.cost;
              addOrIncOwned(actor, key);
              actor.unlocked = computeUnlockForPlayer(actor);
              rd._lastMsg    = `${actor.name} bought ${card.name}.`;
            }
          }
          rd.phase = 'buy'; // keep End Turn enabled

          tx.update(ref, { game: rd });
          tx.update(doc(db, 'lobbies', lobbyId, 'intents', d.id), { processed: true });
          return;
        }

        // --- END TURN ---
        // --- END TURN (allowed in any phase; can optionally forfeit remaining resolves)
        if (mv.type === 'END_TURN' && isActor){
          // If they chose to forfeit (e.g., clicked End Turn while resolving), wipe the queue
          const forfeit = !!(mv.payload && mv.payload.forfeitRemaining);
          if (forfeit) rd.resolveQueue = [];
        
          // Advance turn
          const players = rd.players || [];
          let next = (tIdx + 1) % players.length;
          for (let g = 0; g < players.length; g++){
            if (!(players[next]?.eliminated)) break;
            next = (next + 1) % players.length;
          }
        
          rd.turnIdx  = next;
          rd.phase    = 'await_roll';
          rd.lastRoll = null;
        
          const alive = players.filter(p => !p.eliminated);
          if (alive.length <= 1) rd.phase = 'finished';
        
          tx.update(ref, { game: rd });
          tx.update(doc(db, 'lobbies', lobbyId, 'intents', d.id), { processed: true });
          return;
        }


        // Fallback: don't let a malformed intent block the queue
        tx.update(doc(db, 'lobbies', lobbyId, 'intents', d.id), { processed: true });
      });
    }
  } finally {
    _processingIntents = false;
  }
}


    // ---------- Intents ----------
    async function pushIntent(type, payload={}){ if (!lobbyId||!myName) return; await addDoc(collection(db,'lobbies',lobbyId,'intents'),{type,from:myName,payload,ts:serverTimestamp(),processed:false}); }
    function intentRoll(mode){ pushIntent('ROLL',{mode}); }
    function intentResolve(){ pushIntent('RESOLVE_NEXT',{}); }
    function intentResolveWithTarget(){
      const q=state?.resolveQueue||[]; if (!q.length) return;
      const card=CARD_CATALOG[q[0].key]; const kind=card.onTrigger?.kind;
      if (!triggerNeedsTarget(kind)) return;
      const tp = $('#selTargetPlayer')?.value || '';
      const tt = $('#selTargetType')?.value || '';
      const te = $('#selTargetEntry')?.value || '';
      pushIntent('RESOLVE_WITH_TARGET',{targetPlayer:tp, targetType:tt, targetEntryIdx: te===''? null : Number(te)});
    }
    function intentBuy(key){ pushIntent('BUY',{key}); }
   function intentEndTurn(payload={}){ pushIntent('END_TURN', payload); }

    // ---------- Init helpers ----------
    function mkStarter(name){
      const p={name, gold:0, townHp:50, unlocked:'d6', owned:[]};
      for (const k of STARTERS){ const c=CARD_CATALOG[k]; p.owned.push({key:k, count:1, hp:c.hp}); }
      return p;
    }

    async function hostMaybeInitializeGame(lobbySnap){
      const data = lobbySnap.data();
      const hasGame = !!data.game;
      if (hasGame) return;

      // Players come in as array of names from the lobby
      const names = Array.isArray(data.players) ? data.players : [];
      const players = names.slice(0,4).map(n => mkStarter(n));

      const seed = Math.floor(Math.random()*1e9);
     const game = {
        createdAt: serverTimestamp(),
        host: data.host || myName,
        players,
        maxPlayers: Math.min(Math.max(players.length || 2, 2), 4),
        turnIdx: 0,
        phase: 'await_roll',
        seed,
        rollCount: 0,
        resolveQueue: [],
        _lastMsg: 'Game initialized.'
      };
      await updateDoc(doc(db,'lobbies',lobbyId), { game });
    }

    function attachListeners(){
      if (unsubLobby) unsubLobby(); if (unsubIntents) unsubIntents();

      const lobbyRef = doc(db,'lobbies',lobbyId);
      unsubLobby = onSnapshot(lobbyRef, async (snap)=>{
        if (!snap.exists()) return;
        const lobby = snap.data();
        isHost = (lobby.host === myName);

        // Host initializes once when status is "started" and no game yet
        if (isHost && lobby.status === 'started' && !lobby.game) {
          await hostMaybeInitializeGame(snap);
          return;
        }

        state = lobby.game || null;
        if (state){
          me.idx = (state.players||[]).findIndex(p=>p.name===myName);
          if (state._lastMsg) logLine(state._lastMsg);
          render();
          if (isHost) hostApplyIntents();
        } else {
          document.getElementById('statusNote').textContent = 'Waiting for host to initialize the game...';
        }
      });

      unsubIntents = onSnapshot(collection(db,'lobbies',lobbyId,'intents'), ()=>{
        if (isHost) hostApplyIntents();
      });
    }

    // ---------- UI bindings ----------
    document.getElementById('rollBtn').addEventListener('click', ()=>{
      if (!isMyTurn()) return; const mode=$('#dieSelect').value;
      const allow=allowedDiceFor(myPlayer()); if (!allow.includes(mode)) return alert('Die not unlocked');
      intentRoll(mode);
    });
    document.getElementById('resolveBtn').addEventListener('click', ()=>{ if (isMyTurn()) intentResolve(); });
    document.getElementById('applyTargetBtn').addEventListener('click', ()=>{ if (isMyTurn()) intentResolveWithTarget(); });
   document.getElementById('endTurnBtn').addEventListener('click', ()=>{
  if (!isMyTurn()) return;

  const hasPending = (state?.phase === 'resolving') && ((state?.resolveQueue?.length || 0) > 0);
  if (hasPending){
    const ok = confirm('You still have unresolved actions. End turn and forfeit the rest?');
    if (!ok) return;
    intentEndTurn({ forfeitRemaining: true });
  } else {
    intentEndTurn({ forfeitRemaining: false });
  }
});


    // ---------- Boot ----------
    (async function boot(){
      if (!lobbyId || !myName) return;
      // Header tags
      document.getElementById('hdrLobby').style.display='';
      document.getElementById('hdrUser').style.display='';
      document.getElementById('hdrLobby').textContent='Lobby: '+lobbyId;
      document.getElementById('hdrUser').textContent=myName;

      attachListeners();
    })();
      console.log('SCRIPT LOADED OK');

  </script>
</body>
</html>













