<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>üåø Grass Realms ‚Äî game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
  :root{ --bg:#f7f8fb; --ink:#1f2937; --muted:#6b7280; --card:#fff; --line:#e5e7eb; --accent:#2e7d32; }
  *{box-sizing:border-box}
  body{margin:0;font-family:Segoe UI,Arial,Helvetica,sans-serif;background:var(--bg);color:var(--ink)}
  header{display:flex;align-items:center;gap:8px;padding:10px 14px;border-bottom:1px solid var(--line);background:#fff;position:sticky;top:0;z-index:5}
  header .tag{font-size:12px;color:#fff;background:var(--accent);padding:2px 8px;border-radius:14px}
  main{padding:12px;display:grid;grid-template-columns:1fr 420px;gap:12px}
  .board{display:grid;grid-template-areas:"p0 p1" "p2 p3"; gap:12px;}
  .playerPanel{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:10px;min-height:220px;position:relative}
  .playerPanel .hdr{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
  .playerPanel .hdr .hp{font-weight:600}

  /* REPLACED: show tiles instead of one big emoji clump */
  .playerPanel .emojiClump{
    display:grid;
    grid-template-columns:repeat(auto-fill,minmax(90px,1fr));
    gap:8px;
    min-height:80px;
  }

  /* Per-card tiles */
  .tile{
    position:relative;
    border:1px solid var(--line);
    background:#fff;
    border-radius:10px;
    padding:6px 6px 8px 6px;
  }
  .tile .label{
    font-size:11px;
    color:var(--muted);
    text-align:center;
    line-height:1.1;
    margin-bottom:2px;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .tile .emj{
    font-size:24px;
    line-height:1.2;
    text-align:center;
  }
  .tile .meta{
    font-size:11px;
    color:var(--muted);
    text-align:center;
    margin-top:2px;
  }
  .tile .hp{
    position:absolute;
    top:4px; right:6px;
    font-size:10px;
    background:#eef7ee;
    color:#1b5e20;
    border-radius:6px;
    padding:1px 6px;
  }
  .tile .cnt{
    position:absolute;
    top:4px; left:6px;
    font-size:10px;
    background:#f1f5f9;
    color:#334155;
    border-radius:6px;
    padding:1px 6px;
  }

  .playerPanel .meta{font-size:12px;color:var(--muted)}
  .you{outline:2px solid #1976d2}
  .active{box-shadow:0 0 0 3px rgba(46,125,50,.35)}
  .rightCol{display:flex;flex-direction:column;gap:12px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:12px}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .controls select, .controls button{padding:8px 10px;font-size:14px}
  .shopGrid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}
  .shopItem{border:1px solid var(--line);border-radius:10px;padding:8px}
  .shopItem h4{margin:0 0 4px 0;font-size:14px}
  .small{font-size:12px;color:var(--muted)}
  .targets{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
  .targets select{padding:6px 8px}
  .log{max-height:260px;overflow:auto;border:1px solid var(--line);border-radius:10px;background:#fff}
  .logLine{padding:6px 8px;border-bottom:1px dashed var(--line);font-size:13px}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#eef7ee;color:#1b5e20;font-size:12px}
  .queue{margin-top:8px;border-top:1px dashed var(--line);padding-top:8px}
  .qItem{font-size:12px;color:var(--muted);margin:2px 0}
  .needTarget{background:#fff7e6;border:1px solid #ffe0a3;padding:8px;border-radius:8px}
  .spacer{flex:1}
</style>

</head>
<body>
  <header>
    <strong>üåø Grass Realms</strong>
    <span id="hdrLobby" class="tag" style="display:none"></span>
    <span id="hdrUser" class="tag" style="display:none"></span>
    <span id="hdrRole" class="tag" style="display:none"></span>
    <span class="spacer"></span>
    <span class="small" id="statusNote"></span>
  </header>

  <main>
    <section class="board" id="board">
      <div class="playerPanel" id="p0"></div>
      <div class="playerPanel" id="p1"></div>
      <div class="playerPanel" id="p2"></div>
      <div class="playerPanel" id="p3"></div>
    </section>

    <aside class="rightCol">
      <div class="card">
        <h3>Your Turn Controls</h3>
        <div class="controls">
  <label>Die:
    <select id="dieSelect"><option>d6</option></select>
  </label>
  <button id="rollBtn">üé≤ Roll</button>
  <button id="resolveBtn">‚ñ∂ Resolve Next (auto / no‚Äëtarget)</button>
  <button id="applyTargetBtn">üéØ Apply Trigger (with target)</button>
  <button id="endTurnBtn">‚è≠ End Turn</button>
  <span id="lastRollBadge" class="pill" style="display:none;margin-left:8px"></span> <!-- NEW -->
</div>

        <div id="targetBox" class="targets"></div>
        <div id="queueBox" class="queue small"></div>

        <div style="margin-top:8px" class="small">
          Roll ‚Üí resolve each trigger in order. If a trigger needs a target, choose player & item and click <b>Apply Trigger</b>.
          Walls protect <b>structures</b> (not troops). Opponent‚Äëturn triggers fire on enemy rolls.
        </div>
      </div>

      <div class="card">
        <h3>Shop</h3>
        <div id="shop" class="shopGrid"></div>
      </div>

      <div class="card">
        <h3>Run Log</h3>
        <div id="log" class="log"></div>
      </div>
    </aside>
  </main>

  <script type="module">
    // -------- Firebase --------
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import {
      getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot, where,
      collection, addDoc, serverTimestamp, runTransaction, query, orderBy, limit, getDocs
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
      authDomain: "bible-game-246c0.firebaseapp.com",
      projectId: "bible-game-246c0",
      storageBucket: "bible-game-246c0.appspot.com",
      messagingSenderId: "959619818996",
      appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
    };
    const app = initializeApp(firebaseConfig);
    const db  = getFirestore(app);

    // -------- URL params from lobby redirect --------
    const qp = new URLSearchParams(location.search);
    const lobbyId = qp.get('gameId') || '';     // the lobby doc id
    const myName  = qp.get('username') || '';
    if (!lobbyId || !myName) {
      document.getElementById('statusNote').textContent = 'Missing gameId or username in URL.';
    }

    // -------- RNG --------
    function mulberry32(seed){ return function(){ let t = seed += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; } }

    // ---------- Catalog ----------
    const RAW_CARDS = [
    // ---- Core / Economy ---- 
{ 
  key:'townhall', name:'Town Hall', emoji:'üè∞', type:'structure',
  cost:0, hp:20, max:1,
  triggers:[1,2,3,4,5,6], timing:'every',
  onTrigger:{ kind:'earn', value:1 }, // +1 coin on any 1‚Äì6
  immutable:true,
  details:'Your base. Triggers on any roll; gain +1 coin every turn. Max 1 and cannot be removed by standard effects.'
},

{ key:'farm', name:'Farm', emoji:'üåæ', type:'structure', cost:1, hp:2, max:3, triggers:[1,2], timing:'every', onTrigger:{kind:'earn', value:1},
  details:'Early economy. On 1‚Äì2 every turn, gain +1 coin.'
},
{ key:'mill', name:'Lumber Mill', emoji:'ü™µ', type:'structure', cost:2, hp:3, max:3, triggers:[3], timing:'every', onTrigger:{kind:'earn', value:3},
  details:'Solid income. On 3 every turn, gain +3 coins.'
},
{ key:'mine', name:'Mine', emoji:'‚õèÔ∏è', type:'structure', cost:3, hp:3, max:3, triggers:[4], timing:'every', onTrigger:{kind:'earn', value:3},
  details:'Riskier income spike. On 4 every turn, gain +3 coins.'
},

// ---- Gray ----
{ key:'footman', name:'Footman', emoji:'üó°Ô∏è', type:'troop', cost:2, hp:4, max:3, triggers:[3,4,7], timing:'your', onTrigger:{kind:'attack_any', value:1},
  details:'Reliably chips away. On 3, 4, or 7 every turn, deal 1 damage to any target.'
},
{ key:'spy', name:'Spy', emoji:'üïµÔ∏è', type:'troop', cost:2, hp:3, max:3, triggers:[5,7], timing:'opponent', onTrigger:{kind:'steal_fixed', value:2},
  details:'Sneak economy denial. On an opponent‚Äôs 5 or 7, steal 2 coins from the active player.'
},
{ key:'knight', name:'Knight', emoji:'üê¥', type:'troop', cost:3, hp:6, max:3, triggers:[5,7,9], timing:'your', onTrigger:{kind:'attack_any', value:4},
  details:'Heavy hitter on your turn. On 5, 7, or 9, deal 4 damage to any target.'
},
{ key:'wall_stone', name:'Stone Wall', emoji:'üß±', type:'wall', cost:3, hp:5, max:3, triggers:[], timing:null,
  details:'Sturdy barrier (wall). Priority target for siege/targeting rules; soaks damage to protect backline.'
},
{ key:'archtwrX', name:'Archer Tower', emoji:'üèπ', type:'structure', cost:5, hp:6, max:3, triggers:[3], timing:'your', onTrigger:{kind:'destroy_troop'},
  details:'Precision removal. On your 3, destroy one enemy troop.'
},
{ key:'trebuchet', name:'Trebuchet', emoji:'üèóÔ∏è', type:'structure', cost:5, hp:7, max:3, triggers:[2], timing:'your', onTrigger:{kind:'destroy_structure_non_temple'},
  details:'Siege engine. On your 2, destroy one enemy non-Temple structure.'
},

// ---- White ----
{ key:'white_temple', name:'White Temple', emoji:'ü§ç‚õ™', type:'structure', cost:4, hp:5, max:3, triggers:[6], timing:'your', onTrigger:{kind:'heal_town', value:3},
  details:'Sanctuary. On your 6, heal your Town Hall for 3.'
},
{ key:'white_devotee', name:'Devotee', emoji:'üïØÔ∏è', type:'troop', cost:3, hp:4, max:3, triggers:[4,7], timing:'every', requiresTemple:'white_temple', onTrigger:{kind:'earn_per_temple', temple:'white_temple', per:1},
  details:'Tithes scale with faith. On 4 or 7 every turn, gain +1 coin per White Temple you control (requires White Temple).'
},
{ key:'white_recruiter', name:'Recruiter', emoji:'üìú', type:'troop', cost:4, hp:5, max:3, triggers:[7,9], timing:'your', requiresTemple:'white_temple', onTrigger:{kind:'acquire_troop_cost_leq_temples', temple:'white_temple'},
  details:'Free enlistment. On your 7 or 9, acquire a troop with cost ‚â§ your number of White Temples (requires White Temple).'
},
{ key:'white_scholar', name:'Scholar', emoji:'üìö', type:'troop', cost:5, hp:5, max:3, triggers:[7,9,11], timing:'your', requiresTemple:'white_temple', onTrigger:{kind:'heal_and_earn', heal:3, coins:3},
  details:'Sustain and economy. On 7, 9, or 11 every turn, heal 3 and gain 3 coins (requires White Temple).'
},
{ key:'white_paladin', name:'Paladin', emoji:'üõ°Ô∏è', type:'troop', cost:6, hp:8, max:3, triggers:[8,10,12], timing:'your', requiresTemple:'white_temple', onTrigger:{kind:'attack_any_and_heal', dmg:7, heal:3},
  details:'Smite and restore. On 8, 10, or 12 every turn, deal 7 to any target and heal 3 (requires White Temple).'
},
{
  key:'white_highpriest', name:'High Priest', emoji:'üôè', type:'troop', cost:7, hp:8, max:3,
  triggers:[11,13,17], timing:'your', requiresTemple:'white_temple',
  onTrigger:{kind:'attack_any_and_destroy_troop', dmg:5},
  // NEW: d20 crazy tier
  onTriggerCrazy:{ kind:'smite_all_enemy_troops', dmg:3 }, // hits all enemy troops
  details:'Judgment. On 11, 13, or 17 every turn, deal 5 to any target and destroy an enemy troop. Crazy (d20): smite all enemy troops for 3 (AOE).'
},
{ key:'white_pylon', name:'Temple Pylon', emoji:'üóº', type:'wall', cost:4, hpDynamic:{perTemple:'white_temple', perHP:3}, max:3, requiresTemple:'white_temple', triggers:[], timing:null,
  details:'Scaling wall. Gains +3 HP for each White Temple you control (requires White Temple).'
},

// ---- Black ----
{ key:'black_temple', name:'Black Temple', emoji:'üñ§‚õ™', type:'structure', cost:4, hp:5, max:3, triggers:[6], timing:'your', onTrigger:{kind:'each_other_lose_hp', value:1},
  details:'Dread aura. On your 6, each other player loses 1 Town Hall HP.'
},
{ key:'black_acolyte', name:'Acolyte', emoji:'ü©∏', type:'troop', cost:3, hp:4, max:3, triggers:[8,10], timing:'opponent', requiresTemple:'black_temple', onTrigger:{kind:'active_loses_per_temple', temple:'black_temple', per:2},
  details:'Bleed the active. On an opponent‚Äôs 8 or 10, the active player loses 2 HP per Black Temple you control (requires Black Temple).'
},
{ key:'black_tithetaker', name:'Tithe Taker', emoji:'üßæ', type:'troop', cost:4, hp:5, max:3, triggers:[5,7,9], timing:'every', requiresTemple:'black_temple', onTrigger:{kind:'lose_hp_gain_coins', lose:2, coins:3},
  details:'Profit at a price. On 5, 7, or 9 every turn, you lose 2 HP and gain 3 coins (requires Black Temple).'
},
{
  key:'black_falseprophet', name:'False Prophet', emoji:'üóø', type:'troop', cost:5, hp:6, max:3,
  triggers:[11,13,17], timing:'your', requiresTemple:'black_temple',
  onTrigger:{kind:'others_sacrifice_cards_per_temple', temple:'black_temple'},
  onTriggerCrazy:{ kind:'steal_from_each_enemy', coins:1 }, // steal 1 from each enemy
  details:'Corrupt influence. On 11, 13, or 17 every turn, others must sacrifice cards per your Black Temples. Crazy (d20): steal 1 coin from each enemy.'
},
{ key:'black_oathbreaker', name:'Oathbreaker', emoji:'üó°Ô∏èü©∏', type:'troop', cost:6, hp:7, max:3, triggers:[7,9,11], timing:'your', requiresTemple:'black_temple', onTrigger:{kind:'lose_then_attack_any', lose:1, dmg:8},
  details:'Blood for power. On your 7, 9, or 11, you lose 1 HP then deal 8 to any target (requires Black Temple).'
},
{
  key:'black_necromancer', name:'Necromancer', emoji:'üíÄ', type:'troop', cost:8, hp:9, max:3,
  triggers:[9,13,17], timing:'your', requiresTemple:'black_temple',
  onTrigger:{kind:'destroy_troop'},
  onTriggerCrazy:{ kind:'smite_all_enemy_troops', dmg:2 }, // AOE ping to all enemy troops
  details:'End the living. On 9, 13, or 17 every turn, destroy an enemy troop. Crazy (d20): deal 2 AOE to all enemy troops.'
},
{ key:'black_altar', name:'Altar', emoji:'‚õìÔ∏è', type:'structure', cost:5, hp:6, max:3, triggers:[], timing:'passive', passive:{altar:true},
  details:'Passive focus (Altar). No trigger; counts as an Altar for effects that reference it.'
},

// ---- Red ----
{ key:'red_temple', name:'Red Temple', emoji:'üî¥‚õ™', type:'structure', cost:4, hp:5, max:3, triggers:[6], timing:'your', onTrigger:{kind:'attack_any', value:2},
  details:'Battle shrine. On your 6, deal 2 damage to any target.'
},
{ key:'red_warrior', name:'Warrior', emoji:'üó°Ô∏è', type:'troop', cost:3, hp:5, max:3, triggers:[7,9,11], timing:'your', requiresTemple:'red_temple', onTrigger:{kind:'attack_any', value:4},
  details:'Frontline bruiser. On your 7, 9, or 11, deal 4 damage to any target (requires Red Temple).'
},
{ key:'red_raider', name:'Raider', emoji:'üè¥‚Äç‚ò†Ô∏è', type:'troop', cost:4, hp:5, max:3, triggers:[6,8,10], timing:'opponent', requiresTemple:'red_temple', onTrigger:{kind:'steal_and_make_sacrifice_farm', steal:1},
  details:'Pillage on their turn. On an opponent‚Äôs 6, 8, or 10, steal 1 coin and make the active player sacrifice a Farm (requires Red Temple).'
},
{ key:'red_barbarian', name:'Barbarian', emoji:'ü™ì', type:'troop', cost:5, hp:7, max:3, triggers:[9,11,13], timing:'your', requiresTemple:'red_temple', onTrigger:{kind:'destroy_farm_and_damage_per_temple', temple:'red_temple', per:2},
  details:'Ravage the fields. On your 9, 11, or 13, destroy a Farm and deal 2 damage per Red Temple you control (requires Red Temple).'
},
{ key:'red_ranger', name:'Ranger', emoji:'üèπ', type:'troop', cost:6, hp:7, max:3, triggers:[7,9,11], timing:'every', requiresTemple:'red_temple', onTrigger:{kind:'damage_per_temple_and_gain', temple:'red_temple', per:1, coins:2},
  details:'Skirmish and loot. On 7, 9, or 11 every turn, deal 1 damage per Red Temple you control and gain 2 coins (requires Red Temple).'
},
{
  key:'red_warlord', name:'Warlord', emoji:'‚öîÔ∏è', type:'troop', cost:8, hp:10, max:3,
  triggers:[11,12,13,15,19], timing:'your', requiresTemple:'red_temple',
  onTrigger:{kind:'destroy_structure_and_attack_any', dmg:5},
  onTriggerCrazy:{ kind:'destroy_all_enemy_walls' }, // devastates fortifications
  details:'Total war. On your 11/12/13/15/19, destroy a structure then deal 5 to any target. Crazy (d20): destroy all enemy walls.'
},
{ key:'red_fortress', name:'Fortress', emoji:'üèØ', type:'structure', cost:7, hp:9, max:2, triggers:[], timing:'passive', passive:{fortress:true},
  details:'Passive fortification (Fortress). No trigger; counts as a Fortress for rules/effects.'
},

// ---- Green ----
{ key:'green_temple', name:'Green Temple', emoji:'üü¢‚õ™', type:'structure', cost:4, hp:5, max:3, triggers:[6], timing:'your', onTrigger:{kind:'earn', value:1},
  details:'Growth shrine. On your 6, gain +1 coin.'
},
{ key:'green_shaman', name:'Shaman', emoji:'üåÄ', type:'troop', cost:3, hp:5, max:3, triggers:[5,7,9], timing:'every', requiresTemple:'green_temple', onTrigger:{kind:'earn', value:2},
  details:'Channel abundance. On 5, 7, or 9 every turn, gain +2 coins (requires Green Temple).'
},
{ key:'green_sage', name:'Sage', emoji:'üåø', type:'troop', cost:4, hp:6, max:3, triggers:[7,9,11], timing:'every', requiresTemple:'green_temple', onTrigger:{kind:'heal_and_earn', heal:3, coins:3},
  details:'Balanced growth. On 7, 9, or 11 every turn, heal 3 and gain 3 coins (requires Green Temple).'
},
{ key:'green_druid', name:'Druidic Warrior', emoji:'üßô‚Äç‚ôÇÔ∏è', type:'troop', cost:5, hp:8, max:3, triggers:[9,11], timing:'your', requiresTemple:'green_temple', onTrigger:{kind:'attack_any_per_temple', temple:'green_temple', per:2},
  details:'Nature‚Äôs strike. On your 9 or 11, deal 2 damage per Green Temple you control to any target (requires Green Temple).'
},
{
  key:'green_goliath', name:'Goliath', emoji:'üóø', type:'troop', cost:7, hp:12, max:2,
  triggers:[11,12,13,17], timing:'your', requiresTemple:'green_temple',
  onTrigger:{kind:'goliath_special'},
  onTriggerCrazy:{ kind:'destroy_all_enemy_walls' }, // smash every wall
  details:'Colossal presence. On your 11/12/13/17, trigger Goliath‚Äôs special (see rules). Crazy (d20): destroy all enemy walls.'
},
{
  key:'green_elemental', name:'Elemental', emoji:'üå™Ô∏è', type:'troop', cost:8, hp:10, max:2,
  triggers:[9,10,13,16], timing:'your', requiresTemple:'green_temple',
  onTrigger:{kind:'gain_and_destroy_two_walls', coins:4},
  onTriggerCrazy:{ kind:'smite_all_enemy_troops', dmg:2 },
  details:'Storm surge. On your 9/10/13/16, gain 4 coins and destroy up to two enemy walls. Crazy (d20): deal 2 AOE to all enemy troops.'
},
{ key:'green_livingwall', name:'Living Wall', emoji:'üå≥', type:'wall', cost:6, hpDynamic:{perTemple:'green_temple', perHP:2}, max:3, requiresTemple:'green_temple', triggers:[], timing:null,
  details:'Vine-bound rampart. Gains +2 HP for each Green Temple you control (requires Green Temple).'
},

    ];
    const CARD_CATALOG = {}; for (const c of RAW_CARDS){ CARD_CATALOG[c.key] = { ...c }; }
    const STARTERS = ['townhall','farm','mill'];

    // ---------- Helpers / UI ----------
    const $ = s=>document.querySelector(s);
    const logDiv = $('#log');
    function logLine(msg){ const d=document.createElement('div'); d.className='logLine'; d.textContent=msg; logDiv.appendChild(d); logDiv.scrollTop=logDiv.scrollHeight; }

    // ---------- Game State (stored in lobbies/{lobbyId}) ----------
    let me = { name: myName, idx: -1 };
    let state = null;
    let isHost = false;
    let rng = null;
    let unsubLobby = null, unsubIntents = null;

    // ---------- Rendering ----------
    function emojiClumpForPlayer(p){
      const owned = p.owned||[];
      const sorted = owned.slice().sort((a,b)=>(CARD_CATALOG[a.key]?.type||'').localeCompare(CARD_CATALOG[b.key]?.type||'')); 
      let s=''; for (const e of sorted){ const c=CARD_CATALOG[e.key]; if(!c) continue; const em=Array.from({length:e.count||1},()=>c.emoji).join(''); s+=`${em}${e.hp!=null?' ('+e.hp+')':''} `; }
      return s.trim();
    }
    function render(){
      const hdrLobby=$('#hdrLobby'), hdrUser=$('#hdrUser'), hdrRole=$('#hdrRole');
      hdrLobby.style.display=lobbyId?'':'none'; hdrLobby.textContent='Lobby: '+lobbyId;
      hdrUser.style.display=myName?'':'none'; hdrUser.textContent=myName;
      hdrRole.style.display=isHost?'':'none'; hdrRole.textContent='Host';

      const panels=[$('#p0'),$('#p1'),$('#p2'),$('#p3')]; panels.forEach(p=>{p.innerHTML=''; p.classList.remove('you','active');});
      if (!state) return;

      const players=state.players||[]; const turnIdx=state.turnIdx??0;
      players.forEach((p,i)=>{
        const panel=panels[i]; if (!panel) return;
        panel.classList.toggle('you',p.name===me.name); panel.classList.toggle('active',i===turnIdx);
        const hdr=document.createElement('div'); hdr.className='hdr';
        hdr.innerHTML=`<div><strong>${p.name}</strong> ${i===turnIdx?'<span class="pill">Active</span>':''}</div>
                       <div class="hp">üí∞ ${p.gold||0} | üè∞ ${p.townHp||0}</div>`;
        const cl=document.createElement('div'); cl.className='emojiClump';
renderOwnedTiles(cl, p);
        const mt=document.createElement('div'); mt.className='meta';
        mt.textContent=(p.unlocked==='d20'?'d20':p.unlocked==='2d6'?'2d6':'d6')+' unlocked';
        panel.appendChild(hdr); panel.appendChild(cl); panel.appendChild(mt);
      });

      renderControls(); renderShop(); renderQueueAndTargets();
    }
    function myPlayer(){ if (!state) return null; return (state.players||[]).find(p=>p.name===me.name)||null; }
    function isMyTurn(){ const p=myPlayer(); if (!p||!state) return false; return (state.players||[]).findIndex(x=>x.name===p.name)===(state.turnIdx??0); }
    function allowedDiceFor(player){ const u=player?.unlocked||'d6'; if (u==='d20') return ['d6','2d6','d20']; if (u==='2d6') return ['d6','2d6']; return ['d6']; }
   function renderOwnedTiles(container, player){
  container.innerHTML = '';
  const owned = player?.owned || [];
  for (let i=0; i<owned.length; i++){
    const e = owned[i];
    const c = CARD_CATALOG[e.key];
    if (!c) continue;

    const tile  = document.createElement('div'); tile.className='tile';
    const label = document.createElement('div'); label.className='label'; label.textContent = c.name;
    const emj   = document.createElement('div'); emj.className='emj';   emj.textContent = c.emoji;

    // üîΩ Tooltip on hover (native browser tooltip)
    const tip = buildCardTip(c);
    emj.title  = tip;         // hover over emoji
    tile.title = tip;         // hover anywhere on the tile

    const rolls = (c.triggers && c.triggers.length) ? c.triggers.join(',') : '‚Äî';
    const meta  = document.createElement('div'); meta.className='meta'; meta.innerHTML = `üé≤ ${rolls}`;

    if (e.hp != null){
      const hp = document.createElement('div'); hp.className='hp'; hp.textContent = `HP ${e.hp}`;
      tile.appendChild(hp);
    }
    const count = e.count || 1;
    if (count > 1){
      const cnt = document.createElement('div'); cnt.className='cnt'; cnt.textContent = `x${count}`;
      tile.appendChild(cnt);
    }

    tile.appendChild(label);
    tile.appendChild(emj);
    tile.appendChild(meta);
    container.appendChild(tile);
  }
}

    function buildCardTip(card){
  const rolls  = card.triggers?.length ? card.triggers.join(',') : '‚Äî';
  const timing = card.timing || '‚Äî';
  const hpTxt  = (card.hp ?? card.hpDynamic) ? ` | HP: ${card.hp ?? 'dynamic'}` : '';
  return `${card.emoji} ${card.name}\n${card.details || ''}\nRolls: ${rolls} | Timing: ${timing}${hpTxt}`;
}


function renderControls(){
  const p = myPlayer();
  const dieSel = $('#dieSelect');

  if (!p){
    if (dieSel) dieSel.innerHTML = '<option>d6</option>';
    $('#rollBtn').disabled = true;
    $('#resolveBtn').disabled = true;
    $('#applyTargetBtn').disabled = true;
    $('#endTurnBtn').disabled = true;
    const lb = $('#lastRollBadge'); if (lb) lb.style.display='none';
    return;
  }

  // keep your die to the last chosen, clamped to what's unlocked
  if (dieSel){
    const allowed = allowedDiceFor(p); // ['d6'] | ['d6','2d6'] | ['d6','2d6','d20']
    const desired = allowed.includes(uiPrefs.die) ? uiPrefs.die : allowed[allowed.length-1]; // prefer highest allowed if previous is invalid
    dieSel.innerHTML = allowed.map(o=>`<option value="${o}">${o}</option>`).join('');
    dieSel.value = desired; // restore
    if (!dieSel.dataset.bound){
      dieSel.addEventListener('change', ()=>{
        uiPrefs.die = dieSel.value;
        savePrefs(uiPrefs);
      });
      dieSel.dataset.bound = '1';
    }
  }

  const isTurn   = isMyTurn();
  const phase    = state?.phase || 'await_roll';
  const resolving = (phase === 'resolving');

  // Use effective (crazy or normal) effect to decide target need
  let needsT = false;
  if (resolving){
    const cur = (state?.resolveQueue || [])[0];
    if (cur){
      const card = CARD_CATALOG[cur.key];
      const eff  = (cur.useCrazy && card.onTriggerCrazy) ? card.onTriggerCrazy : (card.onTrigger || {});
      needsT = triggerNeedsTarget(eff.kind);
    }
  }

  $('#rollBtn').disabled        = !isTurn || (phase !== 'await_roll');
  $('#resolveBtn').disabled     = !isTurn || !resolving || needsT;
  $('#applyTargetBtn').disabled = !isTurn || !resolving || !needsT;
  $('#endTurnBtn').disabled     = !isTurn;

  const lb = $('#lastRollBadge');
  if (lb){
    if (state?.lastRoll?.value){
      lb.style.display = '';
      lb.textContent = `Last roll: ${state.lastRoll.value} (${state.lastRoll.mode})`;
    } else {
      lb.style.display = 'none';
    }
  }
}


    // ---- UI Prefs (persisted per lobby & user) ----
const PREFS_KEY = `gr_prefs_${lobbyId}_${myName}`;
function loadPrefs(){ try { return JSON.parse(localStorage.getItem(PREFS_KEY) || '{}'); } catch { return {}; } }
function savePrefs(p){ try { localStorage.setItem(PREFS_KEY, JSON.stringify(p)); } catch {} }
let uiPrefs = Object.assign({ die:'d6', target:{ player:'', type:'', entry:null } }, loadPrefs());

    function renderShop(){
  const shop = $('#shop'); shop.innerHTML = '';
  const p = myPlayer(); if (!p) return;

  const canBuyNow = isMyTurn() && (state?.phase === 'buy');

  // Helper to compute current HP for dynamic-HP cards
  function computeHpNow(card){
    if (!card.hpDynamic) return (card.hp ?? '‚Äî');
    const perTemple = card.hpDynamic.perTemple;
    const perHP     = card.hpDynamic.perHP || 1;
    const temples = (p.owned||[]).find(e=>e.key===perTemple)?.count || 0;
    const hpNow = Math.max(1, temples * perHP);
    return `${hpNow} (scales)`;
  }

  // Sort by cost then name for a nicer shop
  const cards = Object.values(CARD_CATALOG)
    .filter(card => {
      if (card.immutable) return false;
      if (card.requiresTemple){
        const hasTemple = (p.owned||[]).some(e=>e.key===card.requiresTemple);
        if (!hasTemple) return false;
      }
      const have = (p.owned||[]).find(e=>e.key===card.key)?.count || 0;
      const max  = card.max ?? 3;
      return have < max;
    })
    .sort((a,b)=> (a.cost - b.cost) || a.name.localeCompare(b.name));

  cards.forEach(card=>{
    const have = (p.owned||[]).find(e=>e.key===card.key)?.count || 0;
    const max  = card.max ?? 3;
    const rolls = (card.triggers?.length ? card.triggers.join(',') : '‚Äî');
    const hpLabel = computeHpNow(card);
    const timing = card.timing || '‚Äî';

    // Build a nice hover tooltip (uses your `details`)
    const reqTxt = card.requiresTemple ? `\nRequires: ${CARD_CATALOG[card.requiresTemple]?.emoji || ''} ${CARD_CATALOG[card.requiresTemple]?.name || 'Temple'}` : '';
    const tip = `${card.emoji} ${card.name}
${card.details || ''}
Cost: ${card.cost} | HP: ${hpLabel}
Rolls: ${rolls} | Timing: ${timing}${reqTxt}`.trim();

    const div = document.createElement('div');
    div.className = 'shopItem';
    div.title = tip;

    // Header
    const h4 = document.createElement('h4');
    const emj = document.createElement('span');
    emj.className = 'emj';
    emj.textContent = card.emoji;
    emj.title = tip; // emoji-specific tooltip too
    h4.appendChild(emj);
    h4.appendChild(document.createTextNode(' ' + card.name));
    div.appendChild(h4);

    // Meta line
    const meta = document.createElement('div');
    meta.className = 'small';
    const parts = [
      `Cost: ${card.cost}`,
      `HP: ${hpLabel}`,
      (rolls !== '‚Äî' ? `Roll: ${rolls}` : null),
      (card.requiresTemple ? `Req: ${CARD_CATALOG[card.requiresTemple]?.emoji || ''} ${CARD_CATALOG[card.requiresTemple]?.name || ''}` : null),
      `${have}/${max}`
    ].filter(Boolean);
    meta.textContent = parts.join(' | ');
    div.appendChild(meta);

    // Buy button
    const btn = document.createElement('button');
    btn.textContent = 'Buy';
    const afford = (p.gold || 0) >= card.cost;
    btn.disabled = !(canBuyNow && afford);
    if (btn.disabled){
      if (!isMyTurn())          btn.title = 'Not your turn';
      else if (state?.phase!=='buy') btn.title = 'Not in buy phase';
      else if (!afford)         btn.title = `Need ${card.cost} gold`;
    } else {
      btn.title = '';
    }
    btn.addEventListener('click', ()=>intentBuy(card.key));
    div.appendChild(btn);

    shop.appendChild(div);
  });
}


    // ---------- Target UI ----------
    function triggerNeedsTarget(kind){
  return [
    'attack_any',
    'attack_structure',
    'attack_troop',
    'attack_any_and_heal',
    'attack_any_per_temple',
    'damage_per_temple_and_gain',
    'lose_then_attack_any',
    'attack_any_and_destroy_troop',
    'destroy_troop',
    'destroy_structure_non_temple',
    'destroy_structure_and_attack_any',
    'goliath_special',
    'gain_and_destroy_two_walls'
    // note: crazy kinds (smite_all_enemy_troops, destroy_all_enemy_walls, steal_from_each_enemy) are targetless
  ].includes(kind);
}
function allowedTargetTypesFor(kind){
  switch(kind){
    // Troop/attack effects can hit walls directly now
    case 'attack_any':
    case 'attack_any_and_heal':
    case 'attack_any_per_temple':
    case 'lose_then_attack_any':
    case 'damage_per_temple_and_gain':
    case 'attack_any_and_destroy_troop':
      return ['wall','troop','structure','townhall'];

    case 'attack_structure':
      return ['wall','structure']; // structures or walls (not Town Hall)

    case 'attack_troop':
    case 'destroy_troop':
      return ['troop'];

    case 'destroy_structure_non_temple':
      return ['structure']; // cannot pick walls or Town Hall

    case 'destroy_structure_and_attack_any':
      return ['structure']; // first target is a structure only; second hit is auto-chosen

    case 'goliath_special':
      return ['wall','troop','structure','townhall'];

    case 'gain_and_destroy_two_walls':
      return ['wall'];

    default:
      return [];
  }
}
    function listTargetableEntries(p, type){
      const owned=p.owned||[];
      if (type==='troop') return owned.map((e,idx)=>({idx, e, c:CARD_CATALOG[e.key]})).filter(x=>x.c?.type==='troop' && x.e.hp>0);
      if (type==='wall')  return owned.map((e,idx)=>({idx, e, c:CARD_CATALOG[e.key]})).filter(x=>x.c?.type==='wall' && x.e.hp>0);
      if (type==='structure') return owned.map((e,idx)=>({idx, e, c:CARD_CATALOG[e.key]})).filter(x=>x.c?.type==='structure' && x.e.key!=='townhall' && x.e.hp>0);
      return [];
    }
function renderQueueAndTargets(){
  const qb = $('#queueBox'); qb.innerHTML = '';
  const tb = $('#targetBox'); tb.innerHTML = '';
  if (!state) return;

  const q = state.resolveQueue || [];
  if (!q.length){
    qb.innerHTML = '<div class="small">No triggers pending.</div>';
    return;
  }

  const current = q[0];
  const owner   = (state.players || [])[current?.ownerIdx];
  const card    = CARD_CATALOG[current?.key];

  if (!current || !owner || !card){
    qb.innerHTML = '<div class="small">Waiting for next trigger‚Ä¶</div>';
    return;
  }

  // Effective effect: prefer CRAZY when queued that way
  const eff  = (current.useCrazy && card.onTriggerCrazy) ? card.onTriggerCrazy : (card.onTrigger || {});
  const kind = eff.kind || '';

  // Header for current + CRAZY badge
  const title = document.createElement('div');
  title.innerHTML = `<div><b>Current trigger:</b> ${owner.name} ‚Äî ${card.emoji} ${card.name}${
    current.roll ? ` (roll ${current.roll}${current.useCrazy ? ' ‚Ä¢ CRAZY':''})` : ''
  }</div>`;
  qb.appendChild(title);

  // Peek remaining queue
  if (q.length > 1){
    const ol = document.createElement('div'); ol.className = 'small';
    for (let i = 1; i < q.length; i++){
      const t = q[i], o = (state.players||[])[t.ownerIdx], c = CARD_CATALOG[t.key];
      const line = document.createElement('div'); line.className = 'qItem';
      line.textContent = `${i+1}. ${o?.name ?? '(?)'} ‚Äî ${c?.name ?? '(unknown)'}`;
      ol.appendChild(line);
    }
    qb.appendChild(ol);
  }

  // Only the active player chooses targets (change if you want owner to choose)
  if (!isMyTurn()){
    const note = document.createElement('div'); note.className = 'small';
    note.textContent = 'Waiting for the active player to resolve.';
    tb.appendChild(note);
    return;
  }

  const needsTarget = triggerNeedsTarget(kind);
  if (!needsTarget){
    const note = document.createElement('div'); note.className = 'small';
    note.textContent = 'This effect needs no target. Use "Resolve Next".';
    tb.appendChild(note);
    return;
  }

  // ---- Targeting UI ----
  const box = document.createElement('div'); box.className = 'needTarget';
  const selP = document.createElement('select'); selP.id = 'selTargetPlayer';
  const selT = document.createElement('select'); selT.id = 'selTargetType';
  const selE = document.createElement('select'); selE.id = 'selTargetEntry';

  // Persist prefs (guards if helpers weren‚Äôt added yet)
  try{ if (typeof uiPrefs === 'undefined') window.uiPrefs = { die:'d6', target:{ player:'', type:'', entry:null } }; }catch{}
  const persist = (typeof savePrefs === 'function') ? savePrefs : function(){};

  const enemies = (state.players||[]).filter(p => !p.eliminated && p.name !== owner.name);
  const opts    = allowedTargetTypesFor(kind);

  // Players list
  if (!enemies.length){
    selP.innerHTML = '<option value="">(no enemy)</option>';
  } else {
    enemies.forEach(p => {
      const o = document.createElement('option');
      o.value = p.name; o.textContent = p.name; selP.appendChild(o);
    });
  }

  // Types list
  opts.forEach(t => {
    const o = document.createElement('option');
    o.value = t; o.textContent = t; selT.appendChild(o);
  });

  // Restore previous target choices when valid; else pick sensible defaults
  const ATTACK_KINDS = new Set([
    'attack_any','attack_structure','attack_troop',
    'attack_any_and_heal','attack_any_per_temple',
    'damage_per_temple_and_gain','lose_then_attack_any',
    'attack_any_and_destroy_troop','goliath_special'
  ]);

  // Player
  if (uiPrefs.target?.player && enemies.some(e=>e.name===uiPrefs.target.player)){
    selP.value = uiPrefs.target.player;
  } else if (enemies.length){
    selP.value = enemies[0].name;
  }

  // Type/category
  if (uiPrefs.target?.type && opts.includes(uiPrefs.target.type)){
    selT.value = uiPrefs.target.type;
  } else if (opts.length){
    const isAttack = ATTACK_KINDS.has(kind);
    const firstEnemy = enemies[0];
    if (isAttack && firstEnemy && typeof hasActiveWall==='function' && hasActiveWall(firstEnemy) && opts.includes('wall')){
      selT.value = 'wall';
    } else {
      selT.value = opts[0];
    }
  }

  // --- Apply button enablement helper
  const refreshApplyButton = () => {
    const applyBtn = document.getElementById('applyTargetBtn');
    if (!applyBtn) return;

    const tName = selP.value;
    const tType = selT.value;

    // Normalize selected entry index
    const tIdxRaw = selE.disabled ? null : selE.value; // '' means none
    const tIdx = (tIdxRaw === '' || tIdxRaw == null) ? null : Number(tIdxRaw);

    const players = (state.players || []);
    const target = players.find(p => p.name === tName) || null;

    const hasTargetPlayer = !!tName && enemies.some(e => e.name === tName) && !!target;
    const validTown = (tType === 'townhall') ? ((target?.townHp || 0) > 0) : true;

    // Walls shield Town Hall + structures for attack-kind effects
    const isAttack = ATTACK_KINDS.has(kind);
    const shieldUp = target ? (typeof hasActiveWall === 'function' ? hasActiveWall(target) : false) : false;
    const structOrTH = (tType === 'structure' || tType === 'townhall');
    const blockedByWalls = isAttack && shieldUp && structOrTH;

    // Validate selected entry when not townhall
    let validEntry = true;
    if (tType !== 'townhall') {
      if (tIdx === null || Number.isNaN(tIdx)) {
        validEntry = false;
      } else {
        const entry = target?.owned?.[tIdx];
        const etype = entry ? CARD_CATALOG[entry.key]?.type : null;
        const alive = (entry?.hp || 0) > 0;
        validEntry = !!entry && alive && (etype === tType);
      }
    }

    const ok = hasTargetPlayer && validTown && validEntry && !blockedByWalls;
    applyBtn.disabled = !ok;

    // Helpful tooltip when disabled
    if (!ok) {
      let reason = '';
      if (!hasTargetPlayer)          reason = 'Select a valid target player.';
      else if (!validTown)           reason = 'Town Hall is already destroyed.';
      else if (blockedByWalls)       reason = 'Walls are up ‚Äî destroy walls first.';
      else if (!validEntry && tType!=='townhall') reason = 'Select a valid target entry.';
      applyBtn.title = reason || 'Not allowed.';
    } else {
      applyBtn.title = '';
    }
  };

  // --- Fill the entry dropdown based on chosen player/type
  function refillEntries(){
    selE.innerHTML = '';

    const targetName = selP.value;
    const typ        = selT.value;
    const players    = (state.players || []);
    const target     = players.find(p => p.name === targetName) || null;

    const currentKind = eff?.kind || '';
    const isAttack = ATTACK_KINDS.has(currentKind);
    const isTempleKey = (k) => (k==='white_temple'||k==='black_temple'||k==='red_temple'||k==='green_temple');

    if (!target){
      selE.disabled = true;
      const o = document.createElement('option'); o.value=''; o.textContent='(no target player)';
      selE.appendChild(o);
      refreshApplyButton();
      return;
    }

    // Town Hall pseudo-entry
    if (typ === 'townhall'){
      selE.disabled = true;
      const dead = (target.townHp || 0) <= 0;
      const blocked = typeof hasActiveWall === 'function' ? hasActiveWall(target) : false;

      const o = document.createElement('option');
      o.value = '';
      if (dead)              o.textContent = '(Town Hall destroyed)';
      else if (blocked && isAttack) o.textContent = '(Town Hall ‚Äî blocked by walls)';
      else                   o.textContent = '(Town Hall)';
      selE.appendChild(o);

      refreshApplyButton();
      return;
    }

    // Structures blocked by walls for attack-kind effects
    if (typ === 'structure'){
      const shieldUp = (typeof hasActiveWall === 'function') ? hasActiveWall(target) : false;
      if (shieldUp && isAttack){
        selE.disabled = true;
        const o = document.createElement('option'); o.value=''; o.textContent='(structures blocked by walls)';
        selE.appendChild(o);
        refreshApplyButton();
        return;
      }
    }

    // Real entries (wall/troop/structure)
    selE.disabled = false;

    let items = listTargetableEntries(target, typ); // [{idx, e, c}]
    // For destroy_structure_non_temple, filter temples out
    if (typ === 'structure' && currentKind === 'destroy_structure_non_temple'){
      items = items.filter(it => !isTempleKey(it.e.key));
    }

    if (!items.length){
      const o = document.createElement('option'); o.value=''; o.textContent='(none)';
      selE.appendChild(o);
      selE.disabled = true;
      refreshApplyButton();
      return;
    }

    items.forEach(it => {
      const o = document.createElement('option');
      o.value = String(it.idx);
      const hp = (it.e.hp ?? 0);
      o.textContent = `${it.c.emoji} ${it.c.name} (HP ${hp})`;
      selE.appendChild(o);
    });

    // Try to restore previously selected entry if still valid
    if (uiPrefs.target && uiPrefs.target.entry != null){
      const exists = Array.from(selE.options).some(o => Number(o.value) === Number(uiPrefs.target.entry));
      if (exists) selE.value = String(uiPrefs.target.entry);
    }

    refreshApplyButton();
  }

  // Initial fill + listeners + persistence
  refillEntries();

  selP.addEventListener('change', ()=>{
    uiPrefs.target.player = selP.value;
    persist(uiPrefs);
    refillEntries();
  });
  selT.addEventListener('change', ()=>{
    uiPrefs.target.type = selT.value;
    persist(uiPrefs);
    refillEntries();
  });
  selE.addEventListener('change', ()=>{
    uiPrefs.target.entry = (selE.disabled || selE.value==='') ? null : Number(selE.value);
    persist(uiPrefs);
    refreshApplyButton();
  });

  box.appendChild(document.createTextNode('Target: '));
  box.appendChild(selP);
  box.appendChild(selT);
  box.appendChild(selE);
  tb.appendChild(box);
}

    // ---------- Engine (same logic, stored under lobbies/{id}) ----------
    function computeUnlockForPlayer(p){
      let u='d6'; for (const e of (p.owned||[])){ const c=CARD_CATALOG[e.key]; if (!c) continue;
        for (const n of (c.triggers||[])){ if (n>=7 && n<=12) u='2d6'; if (n>=13) return 'd20'; } }
      return u;
    }
    function rollDie(mode, rdRef = state){
  if (!rng) rng = mulberry32((rdRef.seed||1) + (rdRef.rollCount||0));
  if (mode==='d6') return 1+Math.floor(rng()*6);
  if (mode==='2d6') return (1+Math.floor(rng()*6)) + (1+Math.floor(rng()*6));
  if (mode==='d20') return 1+Math.floor(rng()*20);
  return 1;
}
    function addOrIncOwned(p,key){
      const c=CARD_CATALOG[key]; if (!c) return;
      let hp=c.hp;
      if (c.hpDynamic){ const temples=(p.owned||[]).find(e=>e.key===c.hpDynamic.perTemple)?.count||0; hp=Math.max(1, temples*(c.hpDynamic.perHP||1)); }
      const f=(p.owned||[]).find(e=>e.key===key);
      if (f){ f.count=(f.count||1)+1; f.hp=hp; } else { (p.owned||(p.owned=[])).push({key, count:1, hp}); }
    }
      function damageEntry(entry, dmg, owner, rd){
    entry.hp = Math.max(0,(entry.hp||0)-(dmg||0));
    if (entry.hp<=0){
      const diedCard = CARD_CATALOG[entry.key];
      if (diedCard?.type==='troop'){
        for (const pl of (rd.players||[])){
          if ((pl.owned||[]).some(e=>e.key==='black_altar')) pl.gold = (pl.gold||0)+1;
        }
      }
      entry.count = (entry.count||1)-1;
      if (entry.count>0){ entry.hp = CARD_CATALOG[entry.key]?.hp || 1; }
      else { entry._remove = true; }
    }
  }

    function firstOfTypeIdx(p, type){
      const owned=p.owned||[];
      if (type==='troop') return owned.findIndex(e=>CARD_CATALOG[e.key]?.type==='troop' && e.hp>0);
      if (type==='wall')  return owned.findIndex(e=>CARD_CATALOG[e.key]?.type==='wall' && e.hp>0);
      if (type==='structure') return owned.findIndex(e=>CARD_CATALOG[e.key]?.type==='structure' && e.key!=='townhall' && e.hp>0);
      return -1;
    }
  function applyAttackToSpecific(owner, target, targetType, targetIdx, rawDmg, rd){
  const troopBuff = (owner.owned||[]).some(e=>e.key==='red_fortress') ? 1 : 0;
  const dmg = rawDmg + troopBuff;

  // walls must be destroyed before hitting structures or Town Hall
  if ((targetType==='structure' || targetType==='townhall') && hasActiveWall(target)){
    return `blocked by walls ‚Äî destroy walls first.`;
  }

  if (targetType==='townhall'){
    target.townHp = Math.max(0,(target.townHp||0)-dmg);
    return `hits ${target.name}'s üè∞ Town Hall for ${dmg}.`;
  }

  if (targetIdx==null || targetIdx<0) return 'no valid target.';
  const entry = target.owned[targetIdx]; if (!entry) return 'no valid target.';

  // type guard (safety against mismatched UI indices)
  const realType = CARD_CATALOG[entry.key]?.type;
  if (targetType==='structure' && realType!=='structure') return 'invalid target.';
  if (targetType==='wall'      && realType!=='wall')      return 'invalid target.';
  if (targetType==='troop'     && realType!=='troop')     return 'invalid target.';

  damageEntry(entry, dmg, target, rd);
  return `hits ${target.name}'s ${CARD_CATALOG[entry.key].name} for ${dmg}.`;
}


function destroySpecific(target, targetType, targetIdx, allowTemple=true, rd){
  if (targetType==='townhall') return 'cannot destroy Town Hall.';
  if (targetIdx==null || targetIdx<0) return 'no valid target.';
  const entry = target.owned[targetIdx]; if (!entry) return 'no valid target.';

  const card = CARD_CATALOG[entry.key];
  const ttype = card?.type;

  // enforce requested type
  if (targetType==='structure' && ttype!=='structure') return 'invalid target.';
  if (targetType==='wall'      && ttype!=='wall')      return 'invalid target.';
  if (targetType==='troop'     && ttype!=='troop')     return 'invalid target.';

  const isTemple = (entry.key==='white_temple'||entry.key==='black_temple'||entry.key==='red_temple'||entry.key==='green_temple');
  if (!allowTemple && isTemple) return 'cannot destroy Temple with this effect.';

  damageEntry(entry, entry.hp||9999, target, rd);
  return `destroys ${target.name}'s ${card.name}.`;
}


const INSTANT_EARN_KINDS = new Set(['earn', 'earn_per_temple']);
    const HIGH_ROLL_EDGE = 7;
const HIGH_ROLL_DMG_BONUS  = 2;
const HIGH_ROLL_COIN_BONUS = 1;
const HIGH_ROLL_HEAL_BONUS = 1;

function applyInstantIncome(owner, card){
  const ot = card.onTrigger || {};
  if (ot.kind === 'earn') {
    const v = ot.value || 0;
    owner.gold = (owner.gold || 0) + v;
    return v;
  }
  if (ot.kind === 'earn_per_temple') {
    const n = (owner.owned||[]).find(e=>e.key===ot.temple)?.count || 0;
    const amt = n * (ot.per || 0);
    owner.gold = (owner.gold || 0) + amt;
    return amt;
  }
  return 0;
}

  function buildResolveQueueAfterRoll(rd, actorIdx, rollValue, modeOpt){
  const mode  = modeOpt || rd.lastRoll?.mode || 'd6';
  const isD20 = (mode === 'd20');

  const q = [];
  const players  = rd.players || [];
  const earnedBy = new Map(); // name -> coins earned this roll

  function timingMatches(ownerIdx, timing){
    if (!timing || timing === 'every')   return true;
    if (timing === 'your')               return ownerIdx === actorIdx;
    if (timing === 'opponent')           return ownerIdx !== actorIdx;
    return false;
  }

  players.forEach((p, ownerIdx) => {
    (p.owned || []).forEach(e => {
      const card = CARD_CATALOG[e.key];
      if (!card) return;

      if (!card.triggers?.includes(rollValue)) return;
      if (!timingMatches(ownerIdx, card.timing)) return;

      const copies = Math.max(1, e.count || 1);
      for (let k = 0; k < copies; k++){
        // In d20 mode, prefer the crazy effect if present; otherwise use normal
        const crazy = (isD20 && card.onTriggerCrazy) ? card.onTriggerCrazy : null;
        const action = crazy || card.onTrigger;
        if (!action) continue;

        // Instant earn effects resolve immediately; others go to queue
        const kind = action.kind;
        if (INSTANT_EARN_KINDS.has(kind)){
          // Reuse existing helper (uses card.onTrigger), but we want the
          // 'action' semantics; for earn kinds they‚Äôre identical here.
          const got = applyInstantIncome(p, { onTrigger: action });
          if (got > 0) earnedBy.set(p.name, (earnedBy.get(p.name) || 0) + got);
        } else {
          q.push({
            ownerIdx,
            key: e.key,
            roll: rollValue,
            useCrazy: !!crazy
          });
        }
      }
    });
  });

  const parts = [];
  earnedBy.forEach((amt, nm) => parts.push(`${nm} +${amt}`));
  const autoNote = parts.length ? `Auto-income: ${parts.join(', ')}` : '';

  return { q, autoNote };
}

    function hasActiveWall(p){
  return (p?.owned||[]).some(e => CARD_CATALOG[e.key]?.type==='wall' && (e.hp||0) > 0);
}


    function postResolveCleanup(rd){
      for (const pl of rd.players){ pl.owned = (pl.owned||[]).filter(e=>!e._remove); }
      for (const p of rd.players){ if (!p.eliminated && (p.townHp||0)<=0){ p.eliminated=true; p.owned=[]; p.gold=0; } }
    }
function hostResolveOne(rd, manual){
  const stack = rd.resolveQueue || [];
  if (!stack.length) return { changed:false, msg:'No triggers.' };

  const trig   = stack[0];
  const owner  = rd.players[trig.ownerIdx];
  const card   = CARD_CATALOG[trig.key];
  const roll   = trig.roll || 0;
  const mode   = rd.lastRoll?.mode || 'd6';

  // Prefer the queued flag from buildResolveQueueAfterRoll; also fall back to d20 check
  const useCrazy = (trig.useCrazy && !!card.onTriggerCrazy) || (mode === 'd20' && !!card.onTriggerCrazy);

  const eff   = useCrazy ? (card.onTriggerCrazy || {}) : (card.onTrigger || {});
  const kind  = eff.kind;

  const isTroop   = (CARD_CATALOG[trig.key]?.type === 'troop');
  const highTroop = isTroop && (roll >= HIGH_ROLL_EDGE); // 7+ bonus

  // Bonus helpers: only apply for troop triggers on 7+
  const bonusDmg   = (x)=> x + (highTroop ? HIGH_ROLL_DMG_BONUS  : 0);
  const bonusCoins = (x)=> x + (highTroop ? HIGH_ROLL_COIN_BONUS : 0);
  const bonusHeal  = (x)=> x + (highTroop ? HIGH_ROLL_HEAL_BONUS : 0);

  let msg = `${owner.name} triggers ${card.emoji} ${card.name}${useCrazy ? ' [CRAZY]' : ''}: `;

  const activeName   = rd.lastRoll?.by;
  const activePlayer = (rd.players||[]).find(p=>p.name===activeName) || null;

  const needsTarget = triggerNeedsTarget(kind);

  // --- If this trigger needs a target but there are none, auto-skip it
  if (needsTarget){
    const ownerPlayer = rd.players[trig.ownerIdx];
    const enemies = (rd.players||[]).filter(p=>!p.eliminated && p.name!==ownerPlayer.name);
    const kinds = allowedTargetTypesFor(kind);
    const enemyHasAnyValid = enemies.some(ep=>{
      return kinds.some(typ=>{
        if (typ==='townhall') return (ep.townHp||0) > 0;
        const items = listTargetableEntries(ep, typ);
        return items.length > 0;
      });
    });
    if (!enemyHasAnyValid){
      stack.shift();
      rd.resolveQueue = stack;
      postResolveCleanup(rd);
      return { changed:true, msg: `${owner.name}'s ${card.name} had no valid targets (skipped).` };
    }
  }

  // If target needed but not provided, auto-pick if exactly one exists
  if (needsTarget && !manual){
    const ownerPlayer = rd.players[trig.ownerIdx];
    const enemies = (rd.players||[]).filter(p=>!p.eliminated && p.name!==ownerPlayer.name);
    const types = allowedTargetTypesFor(kind);

    let possibleTargets = [];
    enemies.forEach(ep=>{
      types.forEach(typ=>{
        if (typ==='townhall' && (ep.townHp||0)>0){
          possibleTargets.push({ player:ep, type:'townhall', idx:null });
        } else {
          listTargetableEntries(ep, typ).forEach(it=>{
            possibleTargets.push({ player:ep, type:typ, idx:it.idx });
          });
        }
      });
    });

    if (possibleTargets.length === 1){
      const pick = possibleTargets[0];
      manual = { targetPlayer: pick.player.name, targetType: pick.type, targetEntryIdx: pick.idx };
    } else {
      return { changed:false, msg:'Target required.' };
    }
  }

  const applyAndShift = (extraMsg) => {
    stack.shift();
    rd.resolveQueue = stack;
    postResolveCleanup(rd);
    return { changed:true, msg: extraMsg ? (msg + extraMsg) : msg };
  };

  switch(kind){
    // ===== Non-targeted effects =====
    case 'earn': {
      const v = bonusCoins(eff.value||0);
      owner.gold = (owner.gold||0) + v;
      return applyAndShift(`+${v} coin(s).`);
    }
    case 'earn_per_temple': {
      const n = (owner.owned||[]).find(e=>e.key===eff.temple)?.count || 0;
      const amt = bonusCoins(n * (eff.per||0));
      owner.gold = (owner.gold||0) + amt;
      return applyAndShift(`+${amt} coin(s).`);
    }
    case 'heal_town': {
      const v = bonusHeal(eff.value||0);
      owner.townHp = (owner.townHp||0) + v;
      return applyAndShift(`heals Town Hall ${v}.`);
    }
    case 'heal_and_earn': {
      const h = bonusHeal(eff.heal||0);
      const c = bonusCoins(eff.coins||0);
      owner.townHp = (owner.townHp||0) + h;
      owner.gold   = (owner.gold||0) + c;
      return applyAndShift(`heals ${h} & +${c} coins.`);
    }
    case 'each_other_lose_hp': {
      const v = eff.value||0; // structure, no troop bonus
      (rd.players||[]).forEach((p,i)=>{
        if (i!==trig.ownerIdx && !p.eliminated){
          p.townHp = Math.max(0, (p.townHp||0) - v);
        }
      });
      return applyAndShift(`each other player loses ${v}.`);
    }
    case 'active_loses_per_temple': {
      const t = activePlayer; if (!t) return applyAndShift('no active opponent.');
      const n = (owner.owned||[]).find(e=>e.key===eff.temple)?.count || 0;
      const loss = (n * (eff.per||0)) + (highTroop ? HIGH_ROLL_DMG_BONUS : 0);
      t.townHp = Math.max(0, (t.townHp||0) - loss);
      return applyAndShift(`${t.name} loses ${loss} health.`);
    }
    case 'lose_hp_gain_coins': {
      const lose = eff.lose||0; // self-loss unaffected
      const gain = bonusCoins(eff.coins||0);
      owner.townHp = Math.max(0, (owner.townHp||0) - lose);
      owner.gold   = (owner.gold||0) + gain;
      return applyAndShift(`loses ${lose}, gains ${gain} coins.`);
    }
    case 'others_sacrifice_cards_per_temple': {
      const times = (owner.owned||[]).find(e=>e.key===eff.temple)?.count || 0;
      (rd.players||[]).forEach((p,i)=>{
        if (i===trig.ownerIdx || p.eliminated) return;
        for (let k=0;k<times;k++){
          let idx = firstOfTypeIdx(p,'troop');
          if (idx<0) idx = firstOfTypeIdx(p,'structure');
          if (idx<0) idx = firstOfTypeIdx(p,'wall');
          if (idx>=0) damageEntry(p.owned[idx], p.owned[idx].hp||9999, p, rd);
        }
      });
      return applyAndShift(`others sacrifice ${times} card(s).`);
    }
    case 'steal_fixed': {
      const act = activePlayer; if (!act) return applyAndShift('no active.');
      const take = (eff.value||0) + (highTroop ? HIGH_ROLL_COIN_BONUS : 0);
      const amt = Math.min((act.gold||0), take);
      act.gold   = (act.gold||0) - amt;
      owner.gold = (owner.gold||0) + amt;
      return applyAndShift(`steals ${amt} from ${act.name}.`);
    }
    case 'steal_and_make_sacrifice_farm': {
      const act = activePlayer; if (!act) return applyAndShift('no active.');
      const steal = 1 + (highTroop?HIGH_ROLL_COIN_BONUS:0);
      const amt = Math.min((act.gold||0), steal);
      act.gold   = (act.gold||0) - amt;
      owner.gold = (owner.gold||0) + amt;
      const fIdx = (act.owned||[]).findIndex(e=>e.key==='farm' && e.hp>0);
      if (fIdx>=0) damageEntry(act.owned[fIdx], act.owned[fIdx].hp||9999, act, rd);
      return applyAndShift(`steals ${amt} from ${act.name}${fIdx>=0? ' and forces a Farm to be sacrificed.':'.'}`);
    }

    // ===== CRAZY (d20) non-targeted effects =====
    case 'smite_all_enemy_troops': {
      const dmg = eff.dmg || 0; // no extra highTroop bonus on AOE unless desired
      (rd.players||[]).forEach((p,i)=>{
        if (i===trig.ownerIdx || p.eliminated) return;
        (p.owned||[]).forEach(en=>{
          const cc = CARD_CATALOG[en.key];
          if (cc?.type==='troop' && (en.hp||0) > 0){
            damageEntry(en, dmg, p, rd);
          }
        });
      });
      return applyAndShift(`smite hits all enemy troops for ${dmg}.`);
    }
    case 'destroy_all_enemy_walls': {
      (rd.players||[]).forEach((p,i)=>{
        if (i===trig.ownerIdx || p.eliminated) return;
        (p.owned||[]).forEach(en=>{
          const cc = CARD_CATALOG[en.key];
          if (cc?.type==='wall' && (en.hp||0) > 0){
            damageEntry(en, en.hp||9999, p, rd);
          }
        });
      });
      return applyAndShift(`destroys all enemy walls.`);
    }
    case 'steal_from_each_enemy': {
      const take = eff.coins || 0;
      let total = 0;
      (rd.players||[]).forEach((p,i)=>{
        if (i===trig.ownerIdx || p.eliminated) return;
        const amt = Math.min((p.gold||0), take);
        p.gold = (p.gold||0) - amt;
        total += amt;
      });
      owner.gold = (owner.gold||0) + total;
      return applyAndShift(`steals ${take} from each enemy (${total} total).`);
    }

    // ===== Targeted effects =====
    case 'attack_any':
    case 'attack_structure':
    case 'attack_troop':
    case 'attack_any_and_heal':
    case 'attack_any_per_temple':
    case 'damage_per_temple_and_gain':
    case 'lose_then_attack_any':
    case 'attack_any_and_destroy_troop':
    case 'destroy_troop':
    case 'destroy_structure_non_temple':
    case 'destroy_structure_and_attack_any':
    case 'goliath_special':
    case 'gain_and_destroy_two_walls': {
      const tName = manual?.targetPlayer;
      const tType = manual?.targetType;
      const tIdx  = (manual?.targetEntryIdx!=null) ? Number(manual.targetEntryIdx) : null;
      const target = (rd.players||[]).find(p=>p.name===tName);
      if (!target) return applyAndShift('no enemy.');

      switch(kind){
        case 'attack_any': {
          const out = applyAttackToSpecific(owner, target, tType, tIdx, bonusDmg(eff.value||0), rd);
          return applyAndShift(out);
        }
        case 'attack_structure': {
          if (tType==='troop') return applyAndShift('invalid target (troop).');
          const out = applyAttackToSpecific(owner, target, tType, tIdx, bonusDmg(eff.value||0), rd);
          return applyAndShift(out);
        }
        case 'attack_troop': {
          if (tType!=='troop') return applyAndShift('invalid target (needs troop).');
          const out = applyAttackToSpecific(owner, target, 'troop', tIdx, bonusDmg(eff.value||0), rd);
          return applyAndShift(out);
        }
        case 'attack_any_and_heal': {
          const out = applyAttackToSpecific(owner, target, tType, tIdx, bonusDmg(eff.dmg||0), rd);
          const healAmt = bonusHeal(eff.heal||0);
          owner.townHp = (owner.townHp||0) + healAmt;
          return applyAndShift(out + ` Heals ${healAmt}.`);
        }
        case 'attack_any_per_temple': {
          const n = (owner.owned||[]).find(e=>e.key===eff.temple)?.count || 0;
          const out = applyAttackToSpecific(owner, target, tType, tIdx, bonusDmg(n*(eff.per||0)), rd);
          return applyAndShift(out);
        }
        case 'damage_per_temple_and_gain': {
          const n = (owner.owned||[]).find(e=>e.key===eff.temple)?.count || 0;
          const out = applyAttackToSpecific(owner, target, tType, tIdx, bonusDmg(n*(eff.per||0)), rd);
          const coins = bonusCoins(eff.coins||0);
          owner.gold = (owner.gold||0) + coins;
          return applyAndShift(out + ` Gains ${coins} coins.`);
        }
        case 'lose_then_attack_any': {
          owner.townHp = Math.max(0, (owner.townHp||0) - (eff.lose||0));
          const out = applyAttackToSpecific(owner, target, tType, tIdx, bonusDmg(eff.dmg||0), rd);
          return applyAndShift(`loses ${eff.lose||0}. ` + out);
        }
        case 'attack_any_and_destroy_troop': {
          const out = applyAttackToSpecific(owner, target, tType, tIdx, bonusDmg(eff.dmg||0), rd);
          const troopIdx = firstOfTypeIdx(target,'troop');
          if (troopIdx>=0) damageEntry(target.owned[troopIdx], target.owned[troopIdx].hp||9999, target, rd);
          return applyAndShift(out + (troopIdx>=0 ? ` Destroys a troop.` : ` No troop to destroy.`));
        }
        case 'destroy_troop': {
          if (tType!=='troop') return applyAndShift('invalid target (needs troop).');
          const out = destroySpecific(target, 'troop', tIdx, true, rd);
          if (highTroop) owner.gold = (owner.gold||0) + HIGH_ROLL_COIN_BONUS;
          return applyAndShift(out + (highTroop ? ` (+${HIGH_ROLL_COIN_BONUS} bonus coin)` : ''));
        }
        case 'destroy_structure_non_temple': {
          if (tType==='troop' || tType==='townhall') return applyAndShift('invalid target.');
          const out = destroySpecific(target, 'structure', tIdx, /*allowTemple*/false, rd);
          return applyAndShift(out);
        }
        case 'destroy_structure_and_attack_any': {
          if (tType==='troop' || tType==='townhall') return applyAndShift('invalid first target.');
          const out1 = destroySpecific(target, tType, tIdx, /*allowTemple*/true, rd);
          // Second hit respects wall shielding: hit a wall if any, else Town Hall
          let out2 = '';
          if (hasActiveWall(target)){
            const wIdx = firstOfTypeIdx(target,'wall');
            if (wIdx>=0) out2 = applyAttackToSpecific(owner, target, 'wall', wIdx, bonusDmg(eff.dmg||0), rd);
            else         out2 = 'no wall to hit.';
          } else {
            out2 = applyAttackToSpecific(owner, target, 'townhall', null, bonusDmg(eff.dmg||0), rd);
          }
          return applyAndShift(out1 + ' ' + out2);
        }
        case 'goliath_special': {
          if (trig.roll===12){
            const wIdx = firstOfTypeIdx(target,'wall');  if (wIdx>=0) damageEntry(target.owned[wIdx], target.owned[wIdx].hp||9999, target, rd);
            const trIdx= firstOfTypeIdx(target,'troop'); if (trIdx>=0) damageEntry(target.owned[trIdx], target.owned[trIdx].hp||9999, target, rd);
            const out  = applyAttackToSpecific(owner, target, tType, tIdx, bonusDmg(10), rd);
            return applyAndShift(`${wIdx>=0?'destroys a wall. ':''}${trIdx>=0?'destroys a troop. ':''}${out}`);
          } else {
            const out = applyAttackToSpecific(owner, target, tType, tIdx, bonusDmg(10), rd);
            return applyAndShift(out);
          }
        }
        case 'gain_and_destroy_two_walls': {
          if (tType!=='wall' || tIdx==null) return applyAndShift('invalid target (needs wall).');
          const coins = bonusCoins(eff.coins||0);
          owner.gold = (owner.gold||0) + coins;
          // destroy selected wall
          destroySpecific(target, 'wall', tIdx, true, rd);
          // destroy another wall if present
          const w2 = firstOfTypeIdx(target,'wall');
          if (w2>=0) destroySpecific(target, 'wall', w2, true, rd);
          return applyAndShift(`gains ${coins} coins and destroys up to two walls.`);
        }
      }
      break;
    }
  }

  // Fallback ‚Äî should rarely hit
  stack.shift();
  rd.resolveQueue = stack;
  postResolveCleanup(rd);
  return { changed:true, msg };
}

  // Add this once (top-level, above the function)
let _processingIntents = false;

// Requires: import { where } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js"

// hostApplyIntents: processes queued intents in order, resilient to missing indexes
async function hostApplyIntents(){
  if (!isHost || !state) return;
  if (_processingIntents) return; // prevent parallel runs
  _processingIntents = true;

  try {
    const movesRef = collection(db, 'lobbies', lobbyId, 'crowncouncil');

    // --- Build list of unprocessed intents with a server-ordered query,
    // --- and gracefully fall back if the composite index isn't created yet.
    let pendingDocs = [];
    try {
      const snap = await getDocs(query(
        movesRef,
        where('kind','==','intent'),
        where('processed','==',false),
        orderBy('ts','asc'),
        orderBy('__name__','asc'),
        limit(50)
      ));
      pendingDocs = snap.docs;
    } catch (err){
      console.warn('Composite index missing; falling back to client-side sort.', err);
      // Fallback path: filter by processed and sort in JS by ts then id
      const snap = await getDocs(query(
        movesRef,
        where('kind','==','intent'),
        where('processed','==',false),
        limit(100)
      ));
      pendingDocs = snap.docs.sort((a,b)=>{
        const ta = a.data()?.ts?.toMillis?.() ?? 0;
        const tb = b.data()?.ts?.toMillis?.() ?? 0;
        if (ta !== tb) return ta - tb;
        return a.id.localeCompare(b.id);
      });
    }

    for (const d of pendingDocs){
      const mv = d.data();
      if (mv.processed) continue;

      await runTransaction(db, async (tx) => {
        const ref = doc(db, 'lobbies', lobbyId);
        const rs  = await tx.get(ref);
        if (!rs.exists()) return;

        const rd = rs.data().game || null;
        if (!rd) return; // no game yet

        const players = rd.players || [];
        const tIdx    = rd.turnIdx ?? 0;
        let   phase   = rd.phase || 'await_roll'; // must be let so we can repair
        const actor   = players[tIdx];
        const isActor = mv.from === actor?.name;

        // --- Phase auto-repair: don't sit in 'resolving' with an empty queue
        if (phase === 'resolving' && !((rd.resolveQueue||[]).length)){
          rd.phase = 'buy';
          rd._lastMsg = (rd._lastMsg || '') + ' [auto-repair: no pending triggers]';
          phase = 'buy';
          tx.update(ref, { game: rd });
          // continue; we still want to try handling this mv against repaired phase
        }

        // --- ROLL ---
        if (mv.type === 'ROLL' && isActor && phase === 'await_roll') {
          const mode = mv.payload?.mode || 'd6';
          const v    = rollDie(mode, rd); // deterministic RNG from state

          // Always record the roll so UI shows it even if queue build fails
          rd.lastRoll = { mode, value: v, by: actor.name };
          rd._lastMsg = `${actor.name} rolled ${v} (${mode}).`;

          try {
            const { q, autoNote } = buildResolveQueueAfterRoll(rd, tIdx, v, mode);
            rd.resolveQueue = Array.isArray(q) ? q : [];
            rd.phase = rd.resolveQueue.length ? 'resolving' : 'buy';
            if (autoNote) rd._lastMsg += ' ‚Äî ' + autoNote;
          } catch (e) {
            console.error('Queue build failed:', e);
            rd.resolveQueue = [];
            rd.phase = 'buy';
            rd._lastMsg += ' (auto-resolve disabled this roll due to an error)';
          }

          rd.rollCount = (rd.rollCount || 0) + 1;

          // Safety: if we're in 'resolving' with empty queue, bump to 'buy'
          if (rd.phase === 'resolving' && !(rd.resolveQueue?.length)) rd.phase = 'buy';

          tx.update(ref, { game: rd });
          tx.update(doc(db, 'lobbies', lobbyId, 'crowncouncil', d.id), { processed: true });
          return;
        }

        // --- RESOLVE (no target) ---
        if (mv.type === 'RESOLVE_NEXT' && isActor && phase === 'resolving'){
          const res = hostResolveOne(rd, null);
          if (res?.msg) rd._lastMsg = res.msg;
          if (!(rd.resolveQueue?.length)) rd.phase = 'buy';

          tx.update(ref, { game: rd });
          tx.update(doc(db, 'lobbies', lobbyId, 'crowncouncil', d.id), { processed: true });
          return;
        }

        // --- RESOLVE (with target) ---
        if (mv.type === 'RESOLVE_WITH_TARGET' && isActor && phase === 'resolving'){
          const manual = {
            targetPlayer:   String(mv.payload?.targetPlayer ?? ''),
            targetType:     String(mv.payload?.targetType ?? ''),
            targetEntryIdx: (mv.payload?.targetEntryIdx == null ? null : Number(mv.payload.targetEntryIdx))
          };
          const res = hostResolveOne(rd, manual);
          if (res?.msg) rd._lastMsg = res.msg;
          if (!(rd.resolveQueue?.length)) rd.phase = 'buy';

          tx.update(ref, { game: rd });
          tx.update(doc(db, 'lobbies', lobbyId, 'crowncouncil', d.id), { processed: true });
          return;
        }

        // --- BUY ---
        if (mv.type === 'BUY' && isActor && phase === 'buy'){
          const key  = mv.payload?.key;
          const card = CARD_CATALOG[key];
          if (card){
            const have     = (actor.owned?.find(e => e.key === key)?.count) || 0;
            const max      = card.max ?? 3;
            const okTemple = !card.requiresTemple || (actor.owned || []).some(e => e.key === card.requiresTemple);
            if ((actor.gold || 0) >= card.cost && have < max && okTemple){
              actor.gold    -= card.cost;
              addOrIncOwned(actor, key);
              actor.unlocked = computeUnlockForPlayer(actor);
              rd._lastMsg    = `${actor.name} bought ${card.name}.`;
            }
          }
          // remain in buy so End Turn stays enabled
          rd.phase = 'buy';

          tx.update(ref, { game: rd });
          tx.update(doc(db, 'lobbies', lobbyId, 'crowncouncil', d.id), { processed: true });
          return;
        }

        // --- END TURN (allowed in any phase; can optionally forfeit remaining resolves)
        if (mv.type === 'END_TURN' && isActor){
          const forfeit = !!(mv.payload && mv.payload.forfeitRemaining);
          if (forfeit) rd.resolveQueue = [];

          // Advance to next non-eliminated player
          const players = rd.players || [];
          let next = (tIdx + 1) % players.length;
          for (let g = 0; g < players.length; g++){
            if (!(players[next]?.eliminated)) break;
            next = (next + 1) % players.length;
          }

          rd.turnIdx  = next;
          rd.phase    = 'await_roll';
          rd.lastRoll = null;

          const alive = players.filter(p => !p.eliminated);
          if (alive.length <= 1) rd.phase = 'finished';

          tx.update(ref, { game: rd });
          tx.update(doc(db, 'lobbies', lobbyId, 'crowncouncil', d.id), { processed: true });
          return;
        }

        // === Smarter fallback ===
        // If it's not a known type OR it's not from the current actor, consume it.
        // Otherwise (known type + current actor but wrong phase), leave it unprocessed
        // so it can run when the phase flips (prevents "my click vanished").
        const validTypes = new Set(['ROLL','RESOLVE_NEXT','RESOLVE_WITH_TARGET','BUY','END_TURN']);
        const isValidType = validTypes.has(mv.type);
        const isCurrentActor = isActor;

        if (!isValidType || !isCurrentActor){
          tx.update(doc(db,'lobbies', lobbyId, 'crowncouncil', d.id), { processed:true });
          return;
        }
        // else: known + current actor + wrong phase ‚Üí do nothing (leave unprocessed)
      });
    }
  } finally {
    _processingIntents = false;
  }
}
    // ---------- Intents ----------
    async function pushIntent(type, payload={}){ if (!lobbyId||!myName) return; await addDoc(collection(db,'lobbies',lobbyId,'crowncouncil'),{kind:'intent',type,from:myName,payload,ts:serverTimestamp(),processed:false}); }
    function intentRoll(mode){ pushIntent('ROLL',{mode}); }
    function intentResolve(){ pushIntent('RESOLVE_NEXT',{}); }
    function intentResolveWithTarget(){
      const q=state?.resolveQueue||[]; if (!q.length) return;
      const card=CARD_CATALOG[q[0].key]; const kind=card.onTrigger?.kind;
      if (!triggerNeedsTarget(kind)) return;
      const tp = $('#selTargetPlayer')?.value || '';
      const tt = $('#selTargetType')?.value || '';
      const te = $('#selTargetEntry')?.value || '';
      pushIntent('RESOLVE_WITH_TARGET',{targetPlayer:tp, targetType:tt, targetEntryIdx: te===''? null : Number(te)});
    }
    function intentBuy(key){ pushIntent('BUY',{key}); }
   function intentEndTurn(payload={}){ pushIntent('END_TURN', payload); }

    // ---------- Init helpers ----------
    function mkStarter(name){
      const p={name, gold:0, townHp:20, unlocked:'d6', owned:[]};
      for (const k of STARTERS){ const c=CARD_CATALOG[k]; p.owned.push({key:k, count:1, hp:c.hp}); }
      return p;
    }

    async function hostMaybeInitializeGame(lobbySnap){
      const data = lobbySnap.data();
      const hasGame = !!data.game;
      if (hasGame) return;

      // Players come in as array of names from the lobby
      const names = Array.isArray(data.players) ? data.players : [];
      const players = names.slice(0,4).map(n => mkStarter(n));

      const seed = Math.floor(Math.random()*1e9);
     const game = {
        createdAt: serverTimestamp(),
        host: data.host || myName,
        players,
        maxPlayers: Math.min(Math.max(players.length || 2, 2), 4),
        turnIdx: 0,
        phase: 'await_roll',
        seed,
        rollCount: 0,
        resolveQueue: [],
        _lastMsg: 'Game initialized.'
      };
      await updateDoc(doc(db,'lobbies',lobbyId), { game });
    }

    function attachListeners(){
      if (unsubLobby) unsubLobby(); if (unsubIntents) unsubIntents();

      const lobbyRef = doc(db,'lobbies',lobbyId);
      unsubLobby = onSnapshot(lobbyRef, async (snap)=>{
        if (!snap.exists()) return;
        const lobby = snap.data();
        isHost = (lobby.host === myName);

        // Host initializes once when status is "started" and no game yet
        if (isHost && lobby.status === 'started' && !lobby.game) {
          await hostMaybeInitializeGame(snap);
          return;
        }

        state = lobby.game || null;
        if (state){
          me.idx = (state.players||[]).findIndex(p=>p.name===myName);
          if (state._lastMsg) logLine(state._lastMsg);
          render();
          if (isHost) hostApplyIntents();
        } else {
          document.getElementById('statusNote').textContent = 'Waiting for host to initialize the game...';
        }
      });

      unsubIntents = onSnapshot(query(collection(db,'lobbies',lobbyId,'crowncouncil'), where('kind','==','intent')), ()=>{
        if (isHost) hostApplyIntents();
      });
    }

    // ---------- UI bindings ----------
    document.getElementById('rollBtn').addEventListener('click', ()=>{
      if (!isMyTurn()) return; const mode=$('#dieSelect').value;
      const allow=allowedDiceFor(myPlayer()); if (!allow.includes(mode)) return alert('Die not unlocked');
      intentRoll(mode);
    });
    document.getElementById('resolveBtn').addEventListener('click', ()=>{ if (isMyTurn()) intentResolve(); });
    document.getElementById('applyTargetBtn').addEventListener('click', ()=>{ if (isMyTurn()) intentResolveWithTarget(); });
   document.getElementById('endTurnBtn').addEventListener('click', ()=>{
  if (!isMyTurn()) return;

  const hasPending = (state?.phase === 'resolving') && ((state?.resolveQueue?.length || 0) > 0);
  if (hasPending){
    const ok = confirm('You still have unresolved actions. End turn and forfeit the rest?');
    if (!ok) return;
    intentEndTurn({ forfeitRemaining: true });
  } else {
    intentEndTurn({ forfeitRemaining: false });
  }
});


    // ---------- Boot ----------
    (async function boot(){
      if (!lobbyId || !myName) return;
      // Header tags
      document.getElementById('hdrLobby').style.display='';
      document.getElementById('hdrUser').style.display='';
      document.getElementById('hdrLobby').textContent='Lobby: '+lobbyId;
      document.getElementById('hdrUser').textContent=myName;

      attachListeners();
    })();
      console.log('SCRIPT LOADED OK');

  </script>
</body>
</html>









