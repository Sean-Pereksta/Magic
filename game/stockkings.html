<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>📈 Stock Kings — 5 Round Showdown</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <style>
    :root{
      --bg:#0e1116; --ink:#e9eef5; --muted:#9db0c4; --card:#121722; --br:#1e2734;
      --accent:#4da3ff; --good:#38ef7d; --bad:#ff6b6b; --warn:#ffd166;
      --tile:#0f141e; --tile-br:#1b2533; --shadow:0 12px 36px rgba(0,0,0,.25);
      --stage-max: 1100px; --radius:16px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--ink);
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";
      -webkit-tap-highlight-color: transparent;
    }
    button { touch-action: manipulation; cursor:pointer }

    .wrap{display:grid; grid-template-rows:auto 1fr; min-height:100%}

    /* Top Bar */
    .top{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding:10px 12px; border-bottom:1px solid var(--br); background:#0b0f17; position:sticky; top:0; z-index:5;
    }
    .round{font-weight:800}
    .timer{font-weight:900; font-size:20px; letter-spacing:.5px}
    .wins{display:flex; gap:10px; flex-wrap:wrap; font-size:13px; color:var(--muted)}
    .wins .me{color:#fff; font-weight:800}

    /* Layout */
    .board{
      display:grid;
      grid-template-columns: minmax(0,1fr) min(max(660px, 66vw), var(--stage-max)) minmax(0,1fr);
      gap:12px; padding:12px;
    }
    @media (max-width: 1080px){
      .board{grid-template-columns: 1fr}
    }
    .rail{ display:flex; flex-direction:column; gap:12px; }
    @media (max-width:1080px){
      #leftRail, #rightRail{ display:none; }
    }

    /* Center stage */
    .stage{
      width:100%; max-width: var(--stage-max); margin: 0 auto;
      display:grid; gap:12px;
      grid-template-areas:
        "top"
        "grid"
        "bottom";
      grid-template-rows: auto 1fr auto;
      min-height: calc(100vh - 120px);
    }
    @supports (height: 100svh) {
      .stage{ min-height: calc(100svh - 120px); }
    }

    .players-top{ grid-area: top; display:flex; flex-wrap:wrap; gap:10px; justify-content:center; }
    .players-bottom{ grid-area: bottom; display:flex; flex-wrap:wrap; gap:10px; justify-content:center; }

    /* Stocks grid (always centered) */
    .stocks{
      grid-area: grid;
      display:grid; gap:12px;
      grid-template-columns: repeat(3, minmax(220px,1fr));
      justify-items:stretch; align-items:start;
    }
    @media (max-width: 860px){
      .stocks{ grid-template-columns: repeat(2, minmax(200px,1fr)); }
    }
    @media (max-width: 520px){
      .stocks{ grid-template-columns: 1fr; }
    }

    /* Player cards */
    .pbox{
      background:var(--card); border:1px solid var(--tile-br); border-radius:14px; padding:10px;
      display:flex; flex-direction:column; align-items:center; gap:4px; min-width: 190px; box-shadow:var(--shadow);
    }
    .pbox.me{ outline:2px solid var(--accent) }
    .p-val{ font-weight:900; font-size:18px }
    .p-name{ font-weight:800; color:var(--muted) }
    .p-wins{ font-size:12px; color:var(--muted) }
    .p-cash,.p-net{ font-size:12px; color:var(--muted) }

    /* Stock tile */
    .tile{
      background:var(--card); border:1px solid var(--tile-br); border-radius:var(--radius); padding:12px; display:grid;
      grid-template-rows: auto auto auto 1fr auto; gap:8px; position:relative; min-height: 210px; box-shadow:var(--shadow);
    }
    .head{display:flex; justify-content:space-between; align-items:baseline}
    .sym{font-weight:900; letter-spacing:.5px; font-size:18px}
    .price{font-weight:900}
    .spark{height:28px; width:100%;}
    .mine{ font-size:12px; color:var(--muted); display:flex; gap:8px; flex-wrap:wrap }
    .mine .pl{ font-weight:800 }

    .barwrap{
      border:1px solid var(--tile-br); border-radius:10px; padding:4px; height:100px; overflow:hidden; background:linear-gradient(180deg,#0c1320 0%,#0a101a 100%);
      position:relative;
    }
    .bar{
      position:absolute; left:4px; right:4px; bottom:4px; height:10px; border-radius:8px; background:var(--good);
      transition: height .25s ease;
    }
    .row{display:flex; gap:8px; align-items:center; justify-content:space-between}
    .btn{
      appearance:none; border:1px solid var(--tile-br); background:#132033; color:#fff; padding:10px 12px; border-radius:10px; font-weight:800;
    }
    .btn.sell{ background:#2c1a1a; border-color:#412121 }
    .btn:disabled{opacity:.6}
    .btn:hover{filter:brightness(1.06)}
    .cost{font-weight:700; color:var(--muted); font-size:12px}

    /* Overlay for match end */
    .overlay{
      position:fixed; inset:0; background:rgba(0,0,0,.6);
      display:none; align-items:center; justify-content:center; z-index:20;
    }
    .overlay.show{ display:flex }
    .modal{
      background:var(--card); border:1px solid var(--br); border-radius:16px; padding:18px; width:min(560px, 92vw);
      box-shadow:0 30px 80px rgba(0,0,0,.45);
    }
    .modal h2{ margin:0 0 8px 0 }
    .modal p{ color:var(--muted); margin:6px 0 12px }
    .modal .btn{ width:100% }
  </style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <div class="round">
      <span id="modeLabel">Local Practice</span> · Round <b id="roundNo">1</b>/<b>5</b>
    </div>
    <div class="timer" id="timer">01:30</div>
    <div class="wins" id="winsBar"></div>
  </div>

  <div class="board">
    <div class="rail" id="leftRail"></div>

    <div class="stage">
      <div class="players-top" id="topRail"></div>

      <div class="stocks" id="stocksGrid"><!-- tiles injected --></div>

      <div class="players-bottom" id="bottomRail"></div>
    </div>

    <div class="rail" id="rightRail"></div>
  </div>
</div>

<!-- Match end overlay -->
<div class="overlay" id="overlay">
  <div class="modal">
    <h2 id="overlayTitle">Match Over</h2>
    <p id="overlayMsg">Great game!</p>
    <button class="btn" id="overlayBtn">Play Again</button>
  </div>
</div>

<script type="module">
/* ===========================================================
   Firebase (multiplayer via lobby)
   =========================================================== */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot,
  runTransaction, serverTimestamp, increment
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);

/* ===========================================================
   Game constants
   =========================================================== */
const params     = new URLSearchParams(location.search);
const gameId     = params.get("gameId");
const username   = params.get("username") || "Player";
const LOBBY_REF  = gameId ? doc(db, "lobbies", gameId)      : null;
const GAME_REF   = gameId ? doc(db, "stockkings", gameId)   : null;

const ROUNDS          = 5;
const ROUND_MS        = 90_000;   // 1.5 minutes
const START_CASH      = 100;
const BASE_PRICE      = 15;
const MIN_PRICE       = 3;
const MAX_PRICE       = 60;
const HISTORY_LEN     = 48;
const ORDER_IMPACT    = 0.02;     // per-share impact scaled by 1/sqrt(N)
const STOCKS = [
  { key:"METAL",  name:"Metal"  },
  { key:"WOOL",   name:"Wool"   },
  { key:"WHEAT",  name:"Wheat"  },
  { key:"COFFEE", name:"Coffee" },
  { key:"ROCK",   name:"Rock"   },
];
const N = STOCKS.length;

/* small cross-impact matrix (gentle, symmetric-ish) */
const X = [
  /*        M     Wl    Wh    Cf    Rk */
  /* M */ [ 0.00, -0.06, 0.08, 0.00, 0.10],
  /* Wl */[-0.06, 0.00,  0.05, 0.02, 0.00],
  /* Wh */[ 0.08, 0.05,  0.00, 0.12, 0.00],
  /* Cf */[ 0.00, 0.02,  0.12, 0.00, 0.00],
  /* Rk */[ 0.10, 0.00,  0.00, 0.00, 0.00],
];

/* ===========================================================
   DOM helpers
   =========================================================== */
const $ = (id)=> document.getElementById(id);
const stocksGrid  = $("stocksGrid");
const topRail     = $("topRail");
const bottomRail  = $("bottomRail");
const leftRail    = $("leftRail");
const rightRail   = $("rightRail");
const timerEl     = $("timer");
const roundEl     = $("roundNo");
const winsBar     = $("winsBar");
const modeLabel   = $("modeLabel");
const overlayEl   = $("overlay");
const overlayTitle= $("overlayTitle");
const overlayMsg  = $("overlayMsg");
const overlayBtn  = $("overlayBtn");
const fmt$ = (n)=> "$" + Number(n).toFixed(2);
const clamp = (v,a,b)=> Math.max(a, Math.min(b,v));

/* ===========================================================
   Local state
   =========================================================== */
let lobbyData   = null;
let isHost      = false;
let gameData    = null;      // Firestore game doc snapshot data
let tickerId    = null;      // host drift loop
let timerId     = null;      // UI clock loop
const bound     = new Set();

/* ===========================================================
   Builders
   =========================================================== */
function initStocks(){
  const out = [];
  for (let i=0;i<N;i++){
    const base = BASE_PRICE * (1 + (Math.random()*0.10 - 0.05)); // ~±5%
    out.push({
      key: STOCKS[i].key,
      name: STOCKS[i].name,
      price: Number(base.toFixed(2)),
      min: MIN_PRICE, max: MAX_PRICE,
      history: Array.from({length: 12}, ()=> Number((base*(1+ (Math.random()*0.02 - 0.01))).toFixed(2)))
    });
  }
  return out;
}
function initPortfolios(players){
  const p = {};
  for (const name of players){
    p[name] = { cash: START_CASH, holdings: Array(N).fill(0), avgCost: Array(N).fill(0) };
  }
  return p;
}
function holdingsValue(name, d){
  const pf = d?.portfolios?.[name]; if (!pf) return 0;
  let v = 0;
  for (let i=0;i<N;i++) v += (pf.holdings[i]||0) * d.stocks[i].price;
  return v;
}
function netValue(name, d){
  const pf = d?.portfolios?.[name]; if (!pf) return 0;
  return pf.cash + holdingsValue(name, d);
}

/* ===========================================================
   UI: Stock tiles and Players
   =========================================================== */
function ensureTiles(){
  if (stocksGrid.childElementCount) return;
  const frag = document.createDocumentFragment();
  for (let i=0;i<N;i++){
    const tile = document.createElement("div");
    tile.className = "tile";
    tile.innerHTML = `
      <div class="head">
        <div class="sym"><span id="s-name-${i}">—</span></div>
        <div class="price" id="s-price-${i}">$0.00</div>
      </div>
      <canvas class="spark" height="28" id="s-spark-${i}"></canvas>
      <div class="mine" id="s-mine-${i}">You own 0</div>
      <div class="barwrap"><div class="bar" id="s-bar-${i}" style="height:12px;"></div></div>
      <div class="row">
        <button class="btn buy"  id="s-buy-${i}">Buy</button>
        <div class="cost" id="s-cost-${i}">$0.00</div>
        <button class="btn sell" id="s-sell-${i}">Sell</button>
      </div>
    `;
    frag.appendChild(tile);
  }
  stocksGrid.appendChild(frag);
  sizeAllSparks();
}
function sizeSpark(i){
  const c = $(`s-spark-${i}`); if (!c) return;
  const tile = c.closest(".tile");
  const w = tile ? tile.clientWidth : 220;
  c.width = Math.max(160, w - 24);
  c.height = 28;
}
function sizeAllSparks(){ for(let i=0;i<N;i++) sizeSpark(i); }
function drawSpark(i, history){
  const c = $(`s-spark-${i}`); if (!c) return;
  const ctx = c.getContext("2d");
  ctx.clearRect(0,0,c.width,c.height);
  const n = history.length, min = Math.min(...history), max = Math.max(...history);
  const pad = 2, H = c.height - pad*2, W = c.width - pad*2;

  ctx.strokeStyle = "#2a3d57";
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(pad, pad + H); ctx.lineTo(pad+W, pad + H); ctx.stroke();

  ctx.strokeStyle = "#6cc1ff";
  ctx.lineWidth = 2; ctx.beginPath();
  for (let k=0;k<n;k++){
    const x = pad + (W*(k/(n-1||1)));
    const t = (history[k]-min)/Math.max(0.0001,(max-min));
    const y = pad + H - t*H;
    if (k===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();
}
function bindOnce(id, fn){
  if (bound.has(id)) return;
  const el = $(id); if (!el) return;
  el.addEventListener("click", fn);
  bound.add(id);
}
function renderStocks(){
  ensureTiles();
  if (!gameData?.stocks) return;
  requestAnimationFrame(()=>{
    sizeAllSparks();
    const me = gameData.portfolios?.[username];
    for (let i=0;i<N;i++){
      const s = gameData.stocks[i]; if (!s) continue;
      $(`s-name-${i}`).textContent  = s.name;
      $(`s-price-${i}`).textContent = fmt$(s.price);
      $(`s-cost-${i}`).textContent  = `Buy ${fmt$(s.price)} · Sell ${fmt$(s.price)}`;
      drawSpark(i, s.history || [s.price]);

      // bar
      const bar = $(`s-bar-${i}`);
      if (bar && bar.parentElement){
        const wrapH = (bar.parentElement.offsetHeight) || 100;
        const hMax = Math.max(12, wrapH - 8);
        const t = clamp((s.price - MIN_PRICE) / (MAX_PRICE - MIN_PRICE), 0, 1);
        bar.style.height = (8 + t*(hMax-8)) + "px";
        bar.style.background = "linear-gradient(180deg,#5dffb3,#21a86a)";
      }

      // your position: qty, avg cost, current vs avg
      const mine = $(`s-mine-${i}`);
      if (mine){
        let txt = "You own 0";
        mine.innerHTML = "";
        if (me){
          const qty = me.holdings?.[i] || 0;
          const avg = me.avgCost?.[i] || 0;
          if (qty <= 0){
            mine.textContent = "You own 0";
          } else {
            const diffPct = avg > 0 ? ((s.price - avg) / avg) * 100 : 0;
            const span1 = document.createElement("span");
            const span2 = document.createElement("span");
            const span3 = document.createElement("span");
            const pl    = document.createElement("span");
            span1.textContent = `Own ${qty}`;
            span2.textContent = `Avg ${fmt$(avg)}`;
            span3.textContent = `Now ${fmt$(s.price)}`;
            pl.className = "pl";
            pl.textContent = `(${diffPct>=0?'+':''}${diffPct.toFixed(1)}%)`;
            pl.style.color = diffPct>=0 ? "var(--good)" : "var(--bad)";
            mine.appendChild(span1); mine.appendChild(span2); mine.appendChild(span3); mine.appendChild(pl);
          }
        } else {
          mine.textContent = txt;
        }
      }

      bindOnce(`s-buy-${i}`,  ()=> order("buy", i));
      bindOnce(`s-sell-${i}`, ()=> order("sell", i));
    }
  });
}
function cssSafe(s){ return String(s).replace(/[^a-zA-Z0-9_-]/g, "_"); }
function renderPlayers(){
  const players = gameData?.players || [username];
  const wins    = gameData?.wins    || {};
  // top bar tiny wins
  winsBar.innerHTML = "";
  for (const p of players){
    const span = document.createElement("span");
    span.textContent = `${p}: ${wins[p]||0}`;
    if (p===username) span.className = "me";
    winsBar.appendChild(span);
  }
  // player panels (now with cash & net)
  const boxes = players.map(p=>{
    const div = document.createElement("div");
    div.className = "pbox" + (p===username ? " me":"");
    const net = gameData ? netValue(p, gameData) : START_CASH;
    const cash = gameData?.portfolios?.[p]?.cash ?? START_CASH;
    div.innerHTML = `
      <div class="p-val" id="pval-${cssSafe(p)}">${fmt$(net)}</div>
      <div class="p-name">${p}</div>
      <div class="p-cash" id="pcash-${cssSafe(p)}">Cash: ${fmt$(cash)}</div>
      <div class="p-net"  id="pnet-${cssSafe(p)}">Net: ${fmt$(net)}</div>
      <div class="p-wins">Round Wins: <b>${wins[p]||0}</b></div>
    `;
    return div;
  });
  topRail.innerHTML = bottomRail.innerHTML = leftRail.innerHTML = rightRail.innerHTML = "";
  const q = Math.ceil(boxes.length/4);
  const g = [ boxes.slice(0,q), boxes.slice(q,2*q), boxes.slice(2*q,3*q), boxes.slice(3*q) ];
  g[0].forEach(el=> topRail.appendChild(el));
  g[2].forEach(el=> bottomRail.appendChild(el));
  g[1].forEach(el=> rightRail.appendChild(el));
  g[3].forEach(el=> leftRail.appendChild(el));
}
function refreshPlayerValues(){
  if (!gameData) return;
  for (const p of (gameData.players||[])){
    const cash = gameData?.portfolios?.[p]?.cash ?? START_CASH;
    const net  = netValue(p, gameData);
    const id = cssSafe(p);
    const pv = $(`pval-${id}`), pc = $(`pcash-${id}`), pn = $(`pnet-${id}`);
    if (pv) pv.textContent = fmt$(net);
    if (pc) pc.textContent = `Cash: ${fmt$(cash)}`;
    if (pn) pn.textContent = `Net: ${fmt$(net)}`;
  }
}

/* ===========================================================
   Host loop: price drift + round controller
   =========================================================== */
function stopLoops(){ if (tickerId){ clearInterval(tickerId); tickerId=null; } if (timerId){ clearInterval(timerId); timerId=null; } }

function startHostLoop(){
  if (!isHost || !GAME_REF) return;
  stopLoops();
  tickerId = setInterval(async ()=>{
    try{
      await runTransaction(db, async (tx)=>{
        const snap = await tx.get(GAME_REF); if (!snap.exists()) return;
        const d = snap.data(); if (d.status !== "running") return;
        const now = Date.now();

        // price drift (gentle mean reversion + small cross-impacts)
        const stocks = d.stocks.map(s => ({...s}));
        const del = new Array(N).fill(0);
        for (let i=0;i<N;i++){
          const s = stocks[i];
          const meanRev = (BASE_PRICE - s.price) / (MAX_PRICE - MIN_PRICE);
          const noise   = (Math.random()*0.010 - 0.005);
          del[i] = meanRev * 0.25 + noise;
        }
        for (let i=0;i<N;i++){
          let mix = del[i];
          for (let j=0;j<N;j++){
            if (j===i) continue;
            mix += X[i][j] * del[j] * 0.35;
          }
          let np = stocks[i].price * (1 + mix);
          np = clamp(np, MIN_PRICE, MAX_PRICE);
          stocks[i].price = Number(np.toFixed(2));
          const hist = (stocks[i].history || []).slice(-HISTORY_LEN+1);
          hist.push(stocks[i].price);
          stocks[i].history = hist;
        }

        // round end?
        const left = (d.roundEndAt || 0) - now;
        if (left <= 0){
          const players = d.players || [];
          let best = -Infinity, winners = [];
          for (const p of players){
            const val = netValue(p, {stocks, portfolios:d.portfolios});
            if (val > best + 1e-6){ best = val; winners = [p]; }
            else if (Math.abs(val - best) < 1e-6){ winners.push(p); }
          }
          const wins = {...d.wins};
          for (const w of winners) wins[w] = (wins[w]||0) + 1;

          if ((d.round||1) >= ROUNDS){
            tx.update(GAME_REF, { status:"finished", wins, stocks });
          } else {
            tx.update(GAME_REF, {
              round: (d.round||1)+1,
              roundEndAt: Date.now() + ROUND_MS,
              wins,
              portfolios: initPortfolios(players),
              stocks: initStocks()
            });
          }
        } else {
          tx.update(GAME_REF, { stocks });
        }
      });
    }catch(e){ /* ignore transient errors */ }
  }, 1000);
}

function startUiClock(){
  timerId = setInterval(()=>{
    if (!gameData) return;
    const ms = Math.max(0, (gameData.roundEndAt || 0) - Date.now());
    const s  = Math.ceil(ms/1000);
    const mm = String(Math.floor(s/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    timerEl.textContent = `${mm}:${ss}`;
    refreshPlayerValues();
    renderStocks(); // keeps your per-stock “mine” row fresh
  }, 250);
}

/* ===========================================================
   Multiplayer bootstrapping
   =========================================================== */
async function ensureGameDoc(){
  if (!GAME_REF || !lobbyData) return;
  const g = await getDoc(GAME_REF);
  if (g.exists()) return;
  if (!isHost) return;
  const players = Array.isArray(lobbyData.players) && lobbyData.players.length ? lobbyData.players : [username];
  const payload = {
    host: lobbyData.host || username,
    players,
    status: "running",
    round: 1,
    roundEndAt: Date.now() + ROUND_MS,
    wins: Object.fromEntries(players.map(p=>[p,0])),
    portfolios: initPortfolios(players),
    stocks: initStocks(),
    createdAt: serverTimestamp()
  };
  await setDoc(GAME_REF, payload);
  startHostLoop();
}

if (LOBBY_REF){
  onSnapshot(LOBBY_REF, (snap)=>{
    if (!snap.exists()) return;
    lobbyData = snap.data();
    isHost = lobbyData.host === username;
    modeLabel.textContent = "Multiplayer";
    ensureGameDoc();
  });
}

if (GAME_REF){
  onSnapshot(GAME_REF, async (snap)=>{
    if (!snap.exists()) return;
    gameData = snap.data();

    // backward compat: if an older doc lacks avgCost, hydrate it locally
    for (const p of gameData.players || []){
      if (!gameData.portfolios?.[p]?.avgCost){
        gameData.portfolios[p].avgCost = Array(N).fill(0);
      }
    }

    roundEl.textContent = gameData.round || 1;
    renderPlayers();
    renderStocks();
    if (!timerId) startUiClock();

    if (gameData.status === "finished"){
      const entries = Object.entries(gameData.wins || {});
      const topCount = Math.max(...entries.map(([,c])=>c), 0);
      const champs = entries.filter(([,c])=> c===topCount).map(([n])=>n);

      overlayTitle.textContent = "Match Over";
      overlayMsg.textContent   = `Winner${champs.length>1?'s':''}: ${champs.join(', ')}  —  ${topCount} round win${topCount===1?'':'s'}`;
      overlayEl.classList.add("show");

      if (isHost){
        for (const c of champs){
          try{
            await updateDoc(doc(db,"users",c), { wins: increment(1) });
          }catch(e){
            try{ await setDoc(doc(db,"users",c), { wins: 1 }, { merge:true }); }catch(_){}
          }
        }
        stopLoops();
      }
    }
  });
}

/* ===========================================================
   Orders (1 share per click) — maintains avg cost
   =========================================================== */
function impactScale(data){
  const n = Math.max(1, (data?.players || []).length);
  return ORDER_IMPACT / Math.sqrt(n);
}

async function order(kind, idx){
  if (GAME_REF){
    try{
      await runTransaction(db, async (tx)=>{
        const snap = await tx.get(GAME_REF); if (!snap.exists()) return;
        const d = snap.data(); if (d.status!=="running") return;

        const portfolios = {...d.portfolios};
        const me = {...(portfolios[username] || { cash: START_CASH, holdings: Array(N).fill(0), avgCost: Array(N).fill(0) })};
        if (!me.avgCost) me.avgCost = Array(N).fill(0); // compat
        const stocks = d.stocks.map(s=> ({...s}));
        const s = stocks[idx]; if (!s) return;
        const price = s.price;

        if (kind==="buy"){
          if (me.cash < price) return;
          const qty0 = me.holdings[idx]||0;
          const avg0 = me.avgCost[idx]||0;
          me.cash = Number((me.cash - price).toFixed(2));
          me.holdings[idx] = qty0 + 1;
          const avgNew = (qty0*avg0 + price) / (qty0 + 1);
          me.avgCost[idx] = Number(avgNew.toFixed(2));
          s.price = Number(clamp(price * (1 + impactScale(d)), MIN_PRICE, MAX_PRICE).toFixed(2));
        }else{
          const qty0 = me.holdings[idx]||0;
          if (qty0 <= 0) return;
          me.holdings[idx] = qty0 - 1;
          me.cash = Number((me.cash + price).toFixed(2));
          if (me.holdings[idx] === 0) me.avgCost[idx] = 0; // reset basis when flat
          s.price = Number(clamp(price * (1 - impactScale(d)), MIN_PRICE, MAX_PRICE).toFixed(2));
        }

        const hist = (s.history || []).slice(-HISTORY_LEN+1); hist.push(s.price); s.history = hist;

        portfolios[username] = me;
        stocks[idx] = s;
        tx.update(GAME_REF, { portfolios, stocks });
      });
    }catch(e){ /* ignore */ }
    return;
  }

  // Local practice
  if (!gameData) return;
  const me = gameData.portfolios[username];
  if (!me.avgCost) me.avgCost = Array(N).fill(0);
  const s  = gameData.stocks[idx]; if (!s) return;

  if (kind==="buy"){
    if (me.cash < s.price) return;
    const qty0 = me.holdings[idx]||0, avg0 = me.avgCost[idx]||0;
    me.cash = Number((me.cash - s.price).toFixed(2));
    me.holdings[idx] = qty0 + 1;
    const avgNew = (qty0*avg0 + s.price) / (qty0 + 1);
    me.avgCost[idx] = Number(avgNew.toFixed(2));
    s.price = Number(clamp(s.price * (1 + 0.02), MIN_PRICE, MAX_PRICE).toFixed(2));
  }else{
    const qty0 = me.holdings[idx]||0;
    if (qty0 <= 0) return;
    me.holdings[idx] = qty0 - 1;
    me.cash = Number((me.cash + s.price).toFixed(2));
    if (me.holdings[idx] === 0) me.avgCost[idx] = 0;
    s.price = Number(clamp(s.price * (1 - 0.02), MIN_PRICE, MAX_PRICE).toFixed(2));
  }
  const hist = (s.history || []).slice(-HISTORY_LEN+1); hist.push(s.price); s.history = hist;
  renderStocks(); refreshPlayerValues();
}
window.order = order;

/* ===========================================================
   Local practice fallback (no gameId)
   =========================================================== */
function startLocalPractice(){
  modeLabel.textContent = "Local Practice";
  gameData = {
    players: [username],
    wins: { [username]: 0 },
    round: 1,
    roundEndAt: Date.now() + ROUND_MS,
    portfolios: initPortfolios([username]),
    stocks: initStocks(),
    status: "running"
  };
  roundEl.textContent = "1";
  renderPlayers(); renderStocks();

  stopLoops();
  startUiClock();

  // drift + rounds
  tickerId = setInterval(()=>{
    const d = gameData; if (!d || d.status!=="running") return;
    // drift
    for (let i=0;i<N;i++){
      const s = d.stocks[i];
      const meanRev = (BASE_PRICE - s.price) / (MAX_PRICE - MIN_PRICE);
      const noise   = (Math.random()*0.010 - 0.005);
      let np = s.price * (1 + meanRev*0.25 + noise);
      np = clamp(np, MIN_PRICE, MAX_PRICE);
      s.price = Number(np.toFixed(2));
      const hist = (s.history || []).slice(-HISTORY_LEN+1); hist.push(s.price); s.history = hist;
    }
    renderStocks();

    // end round
    const left = (d.roundEndAt || 0) - Date.now();
    if (left <= 0){
      // in practice, count it as a win if net >= start cash
      const val = netValue(username, d);
      if (val >= START_CASH) d.wins[username] = (d.wins[username]||0) + 1;

      if ((d.round||1) >= ROUNDS){
        overlayTitle.textContent = "Practice Over";
        overlayMsg.textContent   = `Your round wins: ${d.wins[username]||0}`;
        overlayEl.classList.add("show");
        stopLoops();
      }else{
        d.round += 1;
        d.roundEndAt = Date.now() + ROUND_MS;
        d.portfolios = initPortfolios(d.players);
        d.stocks     = initStocks();
        roundEl.textContent = d.round;
        renderPlayers(); renderStocks();
      }
    }
  }, 1000);
}

/* ===========================================================
   Boot
   =========================================================== */
ensureTiles();
overlayBtn.addEventListener("click", ()=>{
  overlayEl.classList.remove("show");
  if (GAME_REF && isHost){
    (async ()=>{
      try{
        await setDoc(GAME_REF, {
          host: lobbyData?.host || username,
          players: gameData?.players || [username],
          status: "running",
          round: 1,
          roundEndAt: Date.now() + ROUND_MS,
          wins: Object.fromEntries((gameData?.players||[username]).map(p=>[p,0])),
          portfolios: initPortfolios(gameData?.players||[username]),
          stocks: initStocks(),
          createdAt: serverTimestamp()
        });
        startHostLoop();
      }catch(e){}
    })();
  }else{
    startLocalPractice();
  }
});

if (!GAME_REF){
  startLocalPractice();
}else{
  (async ()=>{
    const ls = await getDoc(LOBBY_REF);
    if (ls.exists()){
      isHost = (ls.data().host === username);
      if (isHost) startHostLoop();
    }
  })();
}

let rez=null; window.addEventListener("resize", ()=>{ clearTimeout(rez); rez=setTimeout(()=>{ sizeAllSparks(); renderStocks(); }, 80); });
</script>
</body>
</html>



