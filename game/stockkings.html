<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>StockKings: Figure-8 Rush</title>
  <style>
    :root{--bg:#060910;--panel:#0f1726;--line:#2f4468;--ink:#ecf3ff;--muted:#9fb0cc;--accent:#57b2ff;--good:#60f0a1;--warn:#ffd972;--bad:#ff6f89}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,Segoe UI,Roboto,sans-serif}
    #app{position:relative;height:100%;overflow:hidden}
    #scene{position:absolute;inset:0}
    .hud{position:absolute;inset:0;pointer-events:none;display:flex;flex-direction:column;justify-content:space-between;padding:12px}
    .top{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .chip{pointer-events:auto;background:rgba(10,15,25,.8);border:1px solid var(--line);border-radius:12px;padding:8px 10px;font-weight:700}
    .chip small{display:block;color:var(--muted);font-weight:600}
    .big{font-size:24px;font-weight:900}
    .board{pointer-events:auto;background:rgba(8,11,19,.9);border:1px solid var(--line);border-radius:14px;padding:10px;max-width:460px;max-height:45vh;overflow:auto}
    table{width:100%;border-collapse:collapse;font-size:13px}
    th,td{padding:6px;border-bottom:1px solid #21324e;text-align:left}
    .modalWrap{position:absolute;inset:0;background:rgba(3,6,12,.74);display:none;align-items:center;justify-content:center;padding:16px;z-index:20}
    .modalWrap.show{display:flex}
    .modal{pointer-events:auto;background:var(--panel);border:1px solid var(--line);border-radius:16px;max-width:700px;width:min(700px,95vw);padding:16px;box-shadow:0 16px 60px rgba(0,0,0,.45)}
    .modal h2{margin:0 0 8px}
    .modal p{margin:6px 0;color:var(--muted)}
    .btns{display:flex;flex-wrap:wrap;gap:10px;margin-top:12px}
    button{cursor:pointer;border:1px solid #35649f;background:#1d4b80;color:#fff;border-radius:10px;padding:10px 12px;font-weight:700}
    button.ghost{background:#182133;border-color:#344867}
    button.warn{background:#6d4f12;border-color:#a0802e}
    button:disabled{opacity:.5;cursor:not-allowed}
    .obstacles{display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:8px;margin-top:10px}
    .obstacle{border:1px solid #35517a;background:#13233b;border-radius:12px;padding:10px}
    .obstacle h4{margin:0 0 6px}
    .obstacle p{margin:0 0 8px;font-size:12px}
    .controls{position:absolute;inset:auto 0 10px 0;display:none;justify-content:space-between;padding:0 10px;z-index:8}
    .pad,.boost{pointer-events:auto;background:rgba(8,14,24,.75);border:1px solid #35517a;border-radius:14px;touch-action:none}
    .pad{width:150px;height:150px;position:relative}
    .padDot{position:absolute;width:26px;height:26px;border-radius:50%;background:#68b8ff;left:62px;top:62px;pointer-events:none}
    .boost{width:120px;height:120px;display:grid;place-items:center;font-weight:900}
    .boost.onCd{background:rgba(45,18,18,.86);border-color:#8b3f3f}
    .msg{font-size:13px;color:var(--muted)}
    .fullBtn{pointer-events:auto;position:absolute;right:12px;bottom:12px;z-index:12;background:rgba(9,16,27,.92);border:1px solid #4a77b5}
    .board.hidden{display:none}
    @media (max-width:920px){.controls{display:flex}.board{max-width:none}}
  </style>
</head>
<body>
<div id="app">
  <canvas id="scene"></canvas>
  <div class="hud">
    <div class="top">
      <div class="chip"><small>Phase</small><span id="phaseText">Loading‚Ä¶</span></div>
      <div class="chip"><small>Lap</small><span id="lapText">1 / 3</span></div>
      <div class="chip"><small>Lap Timer</small><span class="big" id="lapTimer">00.000</span></div>
      <div class="chip"><small>Boost</small><span id="boostText">Ready</span></div>
      <div class="chip"><small>Status</small><span id="statusText">Connecting to race‚Ä¶</span></div>
    </div>
    <div class="board" id="resultsBoard">
      <h3 style="margin:0 0 8px">üèÅ Round Results</h3>
      <table>
        <thead><tr><th>Player</th><th>L1</th><th>L2</th><th>L3</th><th>Avg</th></tr></thead>
        <tbody id="scoreRows"></tbody>
      </table>
      <div class="msg" id="waitingMsg">Finish lap 1 to begin timeout pressure on everyone else.</div>
    </div>
  </div>

  <div class="controls">
    <div class="pad" id="pad"><div class="padDot" id="padDot"></div></div>
    <button class="boost" id="boostBtn">BOOST</button>
  </div>

  <button id="fullscreenBtn" class="fullBtn">‚õ∂ Fullscreen</button>

  <div class="modalWrap show" id="overlay">
    <div class="modal">
      <h2 id="overlayTitle">Figure-8 Rush</h2>
      <p id="overlayBody">Get ready.</p>
      <div class="btns" id="overlayButtons"></div>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.162/build/three.module.js";
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig={apiKey:"AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",authDomain:"bible-game-246c0.firebaseapp.com",projectId:"bible-game-246c0",storageBucket:"bible-game-246c0.appspot.com",messagingSenderId:"959619818996",appId:"1:959619818996:web:5a9fbf492e23c765e445a1"};
const app=initializeApp(firebaseConfig); const auth=getAuth(app); const db=getFirestore(app);

const params=new URLSearchParams(location.search);
const gameId=(params.get("gameId")||"").trim();
const username=(params.get("username")||"Racer").trim();
const LOBBY_REF=gameId?doc(db,"lobbies",gameId):null;
const RACE_REF=gameId?doc(db,"lobbies",gameId,"crowncouncil","stockkingsRace"):null;

const OBSTACLES={
  meteorites:{name:"Meteorites",desc:"Telegraphed impacts stun for 3s.",stun:3},
  monsters:{name:"Track Monsters",desc:"Sprint side to side and body-check racers."},
  eggs:{name:"Egg Storm",desc:"Bouncy eggs spill out and knock racers backward."},
  towers:{name:"Lightning Towers",desc:"Flash strikes inside warning circles."},
  rhinos:{name:"Rhino Stampede",desc:"Charge opposite race flow and launch racers back."}
};
const obstacleOrder=Object.keys(OBSTACLES);
const el=id=>document.getElementById(id);

let uid="",isHost=false,raceState=null,lobbyState=null,lapStart=0,currentLap=1,isRacing=false;
let firstCheckpoint=false,lastParam=0,stunUntil=0,boostReadyAt=0,lastHitAt=0;
let useLocalRace=false;
const keys={forward:false,left:false,right:false,boost:false};

const renderer=new THREE.WebGLRenderer({canvas:el("scene"),antialias:true}); renderer.setPixelRatio(Math.min(devicePixelRatio,2));
const scene=new THREE.Scene(); scene.background=new THREE.Color(0x6fb5ff);
const camera=new THREE.PerspectiveCamera(62,1,0.1,1000); camera.position.set(0,30,32);
scene.add(new THREE.HemisphereLight(0xcde8ff,0x32551c,1.2));
const sun=new THREE.DirectionalLight(0xffffff,1); sun.position.set(18,40,20); scene.add(sun);

const ground=new THREE.Mesh(new THREE.PlaneGeometry(320,320),new THREE.MeshStandardMaterial({color:0x3a8b35}));
ground.rotation.x=-Math.PI/2; scene.add(ground);

const TRACK={samples:920,roadWidth:12,grassShoulder:10,wallThickness:1.4,wallHeight:2.3};
const trackRadius=t=>50+8*Math.sin(t*3)+4*Math.sin(t*7+0.8);
const trackCenter=t=>new THREE.Vector3(Math.cos(t)*trackRadius(t),0,Math.sin(t)*trackRadius(t));
const trackPath=[];
for(let i=0;i<TRACK.samples;i++){const t=(i/TRACK.samples)*Math.PI*2; trackPath.push(trackCenter(t).setY(0.04));}

function buildTrack(){
  const roadMat=new THREE.MeshStandardMaterial({color:0x8e6a3a});
  const shoulderMat=new THREE.MeshStandardMaterial({color:0x3f8d39});
  const wallMat=new THREE.MeshStandardMaterial({color:0xcfd8e5,metalness:.15,roughness:.7});
  for(let i=0;i<trackPath.length;i++){
    const a=trackPath[i],b=trackPath[(i+1)%trackPath.length];
    const len=a.distanceTo(b),mid=new THREE.Vector3().addVectors(a,b).multiplyScalar(.5);
    const tangent=new THREE.Vector3().subVectors(b,a).normalize();
    const normal=new THREE.Vector3(-tangent.z,0,tangent.x);

    const shoulderMesh=new THREE.Mesh(new THREE.BoxGeometry(TRACK.roadWidth+TRACK.grassShoulder*2,0.14,len+1.2),shoulderMat);
    shoulderMesh.position.set(mid.x,0.06,mid.z); shoulderMesh.lookAt(b.x,mid.y,b.z); shoulderMesh.rotateY(Math.PI/2); scene.add(shoulderMesh);

    const roadMesh=new THREE.Mesh(new THREE.BoxGeometry(TRACK.roadWidth,0.25,len+1),roadMat);
    roadMesh.position.copy(mid); roadMesh.lookAt(b.x,mid.y,b.z); roadMesh.rotateY(Math.PI/2); scene.add(roadMesh);

    const outerWallPos=mid.clone().addScaledVector(normal,TRACK.roadWidth*.5+TRACK.grassShoulder+TRACK.wallThickness*.6);
    const innerWallPos=mid.clone().addScaledVector(normal,-(TRACK.roadWidth*.5+TRACK.grassShoulder+TRACK.wallThickness*.6));
    [outerWallPos,innerWallPos].forEach(pos=>{
      const wall=new THREE.Mesh(new THREE.BoxGeometry(TRACK.wallThickness,TRACK.wallHeight,len+1.5),wallMat);
      wall.position.set(pos.x,TRACK.wallHeight*.5,pos.z); wall.lookAt(pos.x+tangent.x,pos.y,pos.z+tangent.z); wall.rotateY(Math.PI/2); scene.add(wall);
    });
  }
}
buildTrack();

function buildCar(){
  const g=new THREE.Group();
  const body=new THREE.Mesh(new THREE.BoxGeometry(2.6,.9,4.2),new THREE.MeshStandardMaterial({color:0x2376ff,metalness:.2,roughness:.4})); body.position.y=.9;
  const top=new THREE.Mesh(new THREE.BoxGeometry(1.8,.7,2),new THREE.MeshStandardMaterial({color:0xd8e8ff})); top.position.set(0,1.45,-.2);
  g.add(body,top);
  [[-1,.35,-1.3],[1,.35,-1.3],[-1,.35,1.3],[1,.35,1.3]].forEach(([x,y,z])=>{const w=new THREE.Mesh(new THREE.CylinderGeometry(.45,.45,.4,16),new THREE.MeshStandardMaterial({color:0x111111}));w.rotation.z=Math.PI/2;w.position.set(x,y,z);g.add(w);});
  const flame=new THREE.Mesh(new THREE.ConeGeometry(.25,1.2,9),new THREE.MeshBasicMaterial({color:0xff7a22,transparent:true,opacity:.85})); flame.position.set(0,.9,2.7); flame.rotation.x=Math.PI/2; g.add(flame); g.flame=flame;
  return g;
}
const car=buildCar(); car.position.set(0,.1,-6); scene.add(car);

function nearestParam(x,z){
  let bestT=0,best=1e9,bestIdx=0;
  for(let i=0;i<trackPath.length;i++){
    const p=trackPath[i],d=(p.x-x)**2+(p.z-z)**2;
    if(d<best){best=d;bestT=(i/trackPath.length)*Math.PI*2;bestIdx=i;}
  }
  const p=trackPath[bestIdx],next=trackPath[(bestIdx+1)%trackPath.length],prev=trackPath[(bestIdx-1+trackPath.length)%trackPath.length];
  const tangent=new THREE.Vector3().subVectors(next,prev).normalize();
  const normal=new THREE.Vector3(-tangent.z,0,tangent.x);
  return {t:bestT,d:Math.sqrt(best),point:p,normal};
}
function isBetweenRoundsPhase(phase){return phase==="lap_wait"||phase==="obstacle_select"||phase==="finished";}
function chooseObstacle(type){
  if(useLocalRace){applyObstaclePick(type,false); return;}
  if(!RACE_REF) return;
  updateDoc(RACE_REF,{pickedObstacle:type,updatedAt:serverTimestamp()});
}

const threats=[];
function spawnThreats(){ threats.splice(0).forEach(t=>scene.remove(t.mesh));
  const active=raceState?.obstacles||[];
  active.forEach((type,idx)=>{for(let i=0;i<3;i++){const t=((idx*3+i+1)/11)*Math.PI*2; const c=trackCenter(t); let mesh;
    if(type==="meteorites"){mesh=new THREE.Mesh(new THREE.CylinderGeometry(1.8,1.8,.05,24),new THREE.MeshBasicMaterial({color:0xffc266,transparent:true,opacity:.35}));mesh.position.set(c.x,.06,c.z);threats.push({type,mesh,r:2,mode:"warn",timer:2+Math.random()*4});}
    if(type==="monsters"){mesh=new THREE.Mesh(new THREE.BoxGeometry(1.5,1.8,1.5),new THREE.MeshStandardMaterial({color:0x6f32a8}));mesh.position.set(c.x,1,c.z);threats.push({type,mesh,r:1.6,vx:Math.random()>.5?1:-1});}
    if(type==="eggs"){mesh=new THREE.Mesh(new THREE.SphereGeometry(.8,16,12),new THREE.MeshStandardMaterial({color:0xf4efe5}));mesh.position.set(c.x,.8,c.z);threats.push({type,mesh,r:1.2,v:new THREE.Vector3((Math.random()-.5)*3,0,(Math.random()-.5)*3)});}
    if(type==="towers"){mesh=new THREE.Group();const p=new THREE.Mesh(new THREE.CylinderGeometry(.8,1.1,4,10),new THREE.MeshStandardMaterial({color:0x45526b}));p.position.y=2;const ring=new THREE.Mesh(new THREE.RingGeometry(2.4,2.9,22),new THREE.MeshBasicMaterial({color:0x9ec9ff,side:THREE.DoubleSide,transparent:true,opacity:.55}));ring.rotation.x=-Math.PI/2;mesh.add(p,ring);mesh.position.set(c.x,0,c.z);threats.push({type,mesh,r:2.8,flash:0});}
    if(type==="rhinos"){mesh=new THREE.Mesh(new THREE.BoxGeometry(2.2,1.4,3.4),new THREE.MeshStandardMaterial({color:0x7b7f86}));mesh.position.set(c.x,.7,c.z);threats.push({type,mesh,r:1.8,t});}
    if(mesh)scene.add(mesh);
  }})
}

function showModal(title,body,buttons){
  el("overlayTitle").textContent=title; el("overlayBody").innerHTML=body; const wrap=el("overlayButtons"); wrap.innerHTML="";
  buttons.forEach(b=>{const bt=document.createElement("button"); bt.textContent=b.label; if(b.className)bt.className=b.className; bt.onclick=b.onClick; wrap.appendChild(bt);});
  el("overlay").classList.add("show");
}
function hideModal(){el("overlay").classList.remove("show");}

async function ensureRaceDoc(){
  if(!RACE_REF) return;
  const snap=await getDoc(RACE_REF); if(snap.exists()) return;
  await setDoc(RACE_REF,{game:"stockkings-racer",phase:"pregame",round:1,maxRounds:3,players:{},obstacles:[],selectorUid:null,lastSelectorReason:"",winnerUid:null,updatedAt:serverTimestamp()},{merge:true});
}

async function joinRacePlayer(){
  if(!RACE_REF||!uid)return;
  await setDoc(RACE_REF,{players:{[uid]:{name:username,laps:[],avg:null,lastLap:null,finished:false}}},{merge:true});
}

function avg(arr){const v=arr.filter(n=>typeof n==='number');return v.length?(v.reduce((a,b)=>a+b,0)/v.length):null;}
function fmt(n){return typeof n==='number'?n.toFixed(2)+"s":"‚Äî";}

function renderBoard(){
  const players=raceState?.players||{}; const rows=Object.entries(players).sort((a,b)=>((a[1].avg??999)-(b[1].avg??999)));
  el("scoreRows").innerHTML=rows.map(([id,p])=>`<tr><td>${p.name||id}${id===uid?" (you)":""}</td><td>${fmt(p.laps?.[0])}</td><td>${fmt(p.laps?.[1])}</td><td>${fmt(p.laps?.[2])}</td><td>${fmt(p.avg)}</td></tr>`).join("");
  const ph=raceState?.phase||"pregame";
  el("resultsBoard").classList.toggle("hidden",!isBetweenRoundsPhase(ph));
  el("phaseText").textContent=ph.replaceAll("_"," ");
  el("lapText").textContent=`${raceState?.round||1} / 3`;
  if(ph==="lap_wait"&&raceState?.deadlineAt){const sec=Math.max(0,Math.ceil((raceState.deadlineAt-Date.now())/1000));el("waitingMsg").textContent=`Waiting for racers. ${sec}s deadline remains.`;} else {
    el("waitingMsg").textContent= raceState?.selectorUid?`Slowest lap chooses next threat.`:`Finish lap ${raceState?.round||1} to lock your time.`;
  }
  if(raceState?.winnerUid){const w=players[raceState.winnerUid];showModal("üèÜ Race Complete",`${w?.name||"Winner"} wins with lowest average lap time!<br/><br/>Please return to lobby for another match.`,[{label:"Return to Lobby",onClick:()=>location.href="/lobby/lobby.html"}]);}
}

async function hostMaybeStart(){ if(!isHost||!RACE_REF||!raceState) return;
  if(useLocalRace) return;
  if(raceState.phase==="pregame"){ await updateDoc(RACE_REF,{phase:"countdown",countdownEndsAt:Date.now()+10000,updatedAt:serverTimestamp()}); }
}

async function hostTick(){
  if(useLocalRace) return;
  if(!isHost||!raceState||!RACE_REF) return;
  const now=Date.now();
  if(raceState.phase==="countdown"&&now>raceState.countdownEndsAt){ await updateDoc(RACE_REF,{phase:"racing",updatedAt:serverTimestamp()}); return; }
  if(raceState.phase==="lap_wait"&&raceState.deadlineAt&&now>raceState.deadlineAt){
    const players=structuredClone(raceState.players||{}); Object.entries(players).forEach(([id,p])=>{ if((p.laps?.length||0)<raceState.round){p.laps=(p.laps||[]);p.laps[raceState.round-1]=30; p.avg=avg(p.laps);} });
    const vals=Object.entries(players).map(([id,p])=>({id,t:p.laps[raceState.round-1]??30})); const maxT=Math.max(...vals.map(v=>v.t)); const bottoms=vals.filter(v=>v.t===maxT);
    const pick=bottoms[Math.floor(Math.random()*bottoms.length)]?.id||vals[0]?.id||null;
    await updateDoc(RACE_REF,{players,phase:"obstacle_select",selectorUid:pick,selectEndsAt:now+15000,lastSelectorReason:bottoms.length>1?"Tie on slowest; random bottom performer selected.":"Slowest lap selects next threat.",updatedAt:serverTimestamp()});
    return;
  }
  if(raceState.phase==="obstacle_select"&&raceState.selectEndsAt&&now>raceState.selectEndsAt){
    const used=raceState.obstacles||[]; const opts=obstacleOrder.filter(o=>!used.includes(o)); const pick=opts[Math.floor(Math.random()*Math.max(opts.length,1))]||obstacleOrder[Math.floor(Math.random()*obstacleOrder.length)];
    await applyObstaclePick(pick,true);
  }
}

async function applyObstaclePick(type,auto=false){
  if(useLocalRace&&raceState){
    const obs=[...(raceState.obstacles||[])]; if(!obs.includes(type))obs.push(type);
    const round=(raceState.round||1)+1;
    if(round>3){
      const players=structuredClone(raceState.players||{}); let bestId=null,best=1e9; Object.entries(players).forEach(([id,p])=>{p.avg=avg(p.laps||[]); if((p.avg??999)<best){best=p.avg;bestId=id;}});
      raceState={...raceState,obstacles:obs,phase:"finished",winnerUid:bestId};
    } else {
      raceState={...raceState,obstacles:obs,round,phase:"countdown",countdownEndsAt:Date.now()+4500,selectorUid:null,lastSelectorReason:auto?"Auto-picked due to timeout.":""};
    }
    return;
  }
  if(!isHost||!RACE_REF||!raceState)return;
  const obs=[...(raceState.obstacles||[])]; if(!obs.includes(type))obs.push(type);
  const round=(raceState.round||1)+1;
  if(round>3){
    const players=structuredClone(raceState.players||{}); let bestId=null,best=1e9; Object.entries(players).forEach(([id,p])=>{p.avg=avg(p.laps||[]); if((p.avg??999)<best){best=p.avg;bestId=id;}});
    await updateDoc(RACE_REF,{obstacles:obs,phase:"finished",winnerUid:bestId,updatedAt:serverTimestamp()});
  } else {
    await updateDoc(RACE_REF,{obstacles:obs,round,phase:"countdown",countdownEndsAt:Date.now()+10000,selectorUid:null,lastSelectorReason:auto?"Auto-picked due to timeout.":"",updatedAt:serverTimestamp()});
  }
}

async function submitLap(){
  if(!raceState||!uid||!isRacing) return;
  isRacing=false;
  const lap=((Date.now()-lapStart)/1000); const players=structuredClone(raceState.players||{}); const me=players[uid]||{name:username,laps:[]};
  me.laps=me.laps||[]; me.laps[raceState.round-1]=Math.min(30,lap); me.lastLap=me.laps[raceState.round-1]; me.avg=avg(me.laps); players[uid]=me;
  const lapsForRound=Object.values(players).map(p=>(p.laps?.length||0)>=raceState.round);
  const anyFinished=lapsForRound.some(Boolean);
  const everyoneDone=lapsForRound.every(Boolean);
  const patch={players,updatedAt:serverTimestamp()};
  if(!raceState.deadlineAt&&anyFinished){patch.phase="lap_wait"; patch.deadlineAt=Date.now()+30000;}
  if(everyoneDone){
    const vals=Object.entries(players).map(([id,p])=>({id,t:p.laps[raceState.round-1]??30})); const maxT=Math.max(...vals.map(v=>v.t)); const bottoms=vals.filter(v=>v.t===maxT);
    patch.phase="obstacle_select"; patch.selectorUid=bottoms[Math.floor(Math.random()*bottoms.length)].id; patch.selectEndsAt=Date.now()+15000; patch.lastSelectorReason=bottoms.length>1?"Tie on slowest; random bottom performer selected.":"Slowest lap selects next threat.";
  }
  if(useLocalRace){
    raceState={...raceState,...patch};
    if(everyoneDone&&!raceState.selectEndsAt){raceState.selectEndsAt=Date.now()+2500;}
    return;
  }
  if(!RACE_REF) return;
  await updateDoc(RACE_REF,patch);
}

function startLapLocal(){currentLap=raceState?.round||1;lapStart=Date.now();isRacing=true;firstCheckpoint=false;lastParam=nearestParam(car.position.x,car.position.z).t;stunUntil=0;}

function updateThreats(dt){
  const now=performance.now()/1000;
  threats.forEach(t=>{
    if(t.type==="meteorites"){t.timer-=dt;if(t.timer<0){t.timer=3+Math.random()*4; t.mesh.material.color.setHex(0xff4b4b); setTimeout(()=>{if(performance.now()/1000-now<.2)return; t.mesh.material.color.setHex(0xffc266);},220);} }
    if(t.type==="monsters"){t.mesh.position.x+=t.vx*dt*4;if(Math.abs(t.mesh.position.x)>45)t.vx*=-1;}
    if(t.type==="eggs"){t.mesh.position.addScaledVector(t.v,dt); t.v.multiplyScalar(.985);}
    if(t.type==="towers"){t.flash=Math.max(0,t.flash-dt); if(Math.random()<.01)t.flash=.25; t.mesh.children[1].material.opacity=.45+(t.flash*1.8);}
    if(t.type==="rhinos"){t.t=(t.t+dt*.9)%(Math.PI*2); const c=trackCenter(t.t); t.mesh.position.set(c.x,.7,c.z);} 
    const d=t.mesh.position.distanceTo(car.position);
    if(d<t.r+1.1 && Date.now()-lastHitAt>1200){lastHitAt=Date.now();
      if(t.type==="meteorites"||t.type==="towers"){stunUntil=Math.max(stunUntil,Date.now()+3000);} 
      if(t.type==="eggs"){const dir=new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion); car.position.addScaledVector(dir,-2.2); scene.remove(t.mesh); t.dead=true;}
      if(t.type==="rhinos"||t.type==="monsters"){const dir=new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion); car.position.addScaledVector(dir,-5.8); stunUntil=Math.max(stunUntil,Date.now()+1000);}    }
  });
  for(let i=threats.length-1;i>=0;i--)if(threats[i].dead)threats.splice(i,1);
}

function updateCar(dt){
  const stunned=Date.now()<stunUntil;
  let speed=11;
  if(keys.forward&&!stunned)speed=18;
  if(keys.boost&&Date.now()>boostReadyAt&&!stunned){speed=30;boostReadyAt=Date.now()+8000;}
  const near=nearestParam(car.position.x,car.position.z); if(near.d>TRACK.roadWidth*.5)speed*=0.54;
  const turn=(keys.left?-1:0)+(keys.right?1:0);
  car.rotation.y-=turn*dt*2.2;
  const forward=new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion);
  car.position.addScaledVector(forward,speed*dt);
  const lane=nearestParam(car.position.x,car.position.z);
  const toCar=new THREE.Vector3().subVectors(car.position,lane.point);
  const lateral=toCar.dot(lane.normal);
  const maxLateral=(TRACK.roadWidth*.5+TRACK.grassShoulder)-(TRACK.wallThickness*.8);
  if(Math.abs(lateral)>maxLateral){
    const clamped=THREE.MathUtils.clamp(lateral,-maxLateral,maxLateral);
    car.position.copy(lane.point).addScaledVector(lane.normal,clamped);
  }
  car.position.y=.1;
  car.flame.scale.set(1,keys.boost?1.7:.7,keys.boost?1.7:.7);
  const p=nearestParam(car.position.x,car.position.z).t;
  if(p>Math.PI*.9&&p<Math.PI*1.1)firstCheckpoint=true;
  if(firstCheckpoint && lastParam>5.7 && p<.5){submitLap();}
  lastParam=p;
}

function render(){
  const now=Date.now();
  if(raceState?.phase==="countdown"&&raceState.countdownEndsAt){ const s=Math.max(0,Math.ceil((raceState.countdownEndsAt-now)/1000)); showModal("Race starts soon",`<b>${s}</b> seconds until launch.<br/>Use fullscreen for best control.`,[{label:"Enter Fullscreen",onClick:()=>document.documentElement.requestFullscreen?.(),className:"warn"},{label:"Ready",onClick:hideModal,className:"ghost"}]); }
  if(raceState?.phase==="racing"&&!isRacing){hideModal();startLapLocal();}
  if(raceState?.phase==="obstacle_select"){
    const canPick=raceState.selectorUid===uid; const opts=obstacleOrder.filter(o=>!(raceState.obstacles||[]).includes(o));
    showModal(canPick?"Choose the next threat":"Waiting for slowest racer","<b>"+(raceState.lastSelectorReason||"Slowest racer chooses.")+"</b>",canPick?opts.map(o=>({label:OBSTACLES[o].name,onClick:()=>chooseObstacle(o)})).concat([{label:"Random",className:"ghost",onClick:()=>chooseObstacle(opts[Math.floor(Math.random()*opts.length)]||obstacleOrder[0])}]):[{label:"Waiting...",className:"ghost",onClick:()=>{}}]);
  }
  const lapElapsed=isRacing?((Date.now()-lapStart)/1000):0;
  el("lapTimer").textContent=lapElapsed.toFixed(3);
  el("statusText").textContent=Date.now()<stunUntil?"Stunned!":"On track";
  const bLeft=Math.max(0,(boostReadyAt-Date.now())/1000); el("boostText").textContent=bLeft?`Cooldown ${bLeft.toFixed(1)}s`:"Ready";
}

function startLocalFallback(reason=""){
  if(useLocalRace) return;
  useLocalRace=true;
  const localPlayerId=uid||"local-player";
  raceState={game:"stockkings-racer",phase:"countdown",round:1,maxRounds:3,players:{[localPlayerId]:{name:username,laps:[],avg:null,lastLap:null}},obstacles:[],selectorUid:null,lastSelectorReason:"",winnerUid:null,countdownEndsAt:Date.now()+5000};
  isHost=true;
  el("statusText").textContent="Local mode";
  showModal("Local Mode Enabled",`Multiplayer sync is unavailable right now${reason?` (${reason})`:""}. You can still race solo.`,[{label:"Enter Fullscreen",onClick:()=>document.documentElement.requestFullscreen?.(),className:"warn"},{label:"Race",onClick:hideModal}]);
  setInterval(()=>{
    if(!raceState) return;
    const now=Date.now();
    if(raceState.phase==="countdown"&&now>raceState.countdownEndsAt){raceState={...raceState,phase:"racing"};}
    if(raceState.phase==="obstacle_select"&&raceState.selectEndsAt&&now>raceState.selectEndsAt){const used=raceState.obstacles||[]; const opts=obstacleOrder.filter(o=>!used.includes(o)); const pick=opts[0]||obstacleOrder[0]; applyObstaclePick(pick,true);}
  },220);
}

let prev=performance.now();
function loop(t){
  const dt=Math.min(.033,(t-prev)/1000); prev=t;
  updateThreats(dt); if(raceState?.phase==="racing")updateCar(dt);
  const forward=new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion);
  const follow=new THREE.Vector3().copy(car.position).addScaledVector(forward,-10.5);
  follow.y=6.6;
  const lookAt=new THREE.Vector3().copy(car.position).addScaledVector(forward,12);
  lookAt.y=0.5;
  camera.position.lerp(follow,.18); camera.lookAt(lookAt);
  renderer.setSize(innerWidth,innerHeight,false); camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.render(scene,camera); render(); requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

function setupControls(){
  addEventListener("keydown",e=>{if(e.key==='ArrowUp'||e.key==='w')keys.forward=true; if(e.key==='ArrowLeft'||e.key==='a')keys.left=true; if(e.key==='ArrowRight'||e.key==='d')keys.right=true; if(e.key===' ')keys.boost=true;});
  addEventListener("keyup",e=>{if(e.key==='ArrowUp'||e.key==='w')keys.forward=false; if(e.key==='ArrowLeft'||e.key==='a')keys.left=false; if(e.key==='ArrowRight'||e.key==='d')keys.right=false; if(e.key===' ')keys.boost=false;});
  const pad=el("pad"),dot=el("padDot");
  function movePad(ev){const r=pad.getBoundingClientRect(); const t=(ev.touches?ev.touches[0]:ev); const x=Math.max(0,Math.min(r.width,t.clientX-r.left)); const y=Math.max(0,Math.min(r.height,t.clientY-r.top)); dot.style.left=(x-13)+"px"; dot.style.top=(y-13)+"px"; keys.forward=y<r.height*.8; keys.left=x<r.width*.4; keys.right=x>r.width*.6; }
  ["touchstart","touchmove","mousedown","mousemove"].forEach(evt=>pad.addEventListener(evt,e=>{if(evt.includes("move")&&e.buttons===0&&!e.touches)return; movePad(e);}, {passive:false}));
  ["touchend","mouseup","mouseleave"].forEach(evt=>pad.addEventListener(evt,()=>{keys.forward=keys.left=keys.right=false; dot.style.left="62px"; dot.style.top="62px";}));
  const boost=el("boostBtn"); const down=()=>keys.boost=true, up=()=>keys.boost=false;
  boost.addEventListener("touchstart",down,{passive:true}); boost.addEventListener("touchend",up); boost.addEventListener("mousedown",down); boost.addEventListener("mouseup",up); boost.addEventListener("mouseleave",up);
}
setupControls();

const fullscreenBtn=el("fullscreenBtn");
function syncFullscreenLabel(){fullscreenBtn.textContent=document.fullscreenElement?"‚§¢ Exit Fullscreen":"‚õ∂ Fullscreen";}
fullscreenBtn.addEventListener("click",async()=>{if(document.fullscreenElement){await document.exitFullscreen?.();} else {await document.documentElement.requestFullscreen?.();} syncFullscreenLabel();});
document.addEventListener("fullscreenchange",syncFullscreenLabel);
syncFullscreenLabel();

onAuthStateChanged(auth, async user=>{
  if(!user){await signInAnonymously(auth); return;}
  uid=user.uid; el("statusText").textContent="Connected";
  if(!gameId){showModal("Missing gameId","Open from lobby to use multiplayer syncing.",[ {label:"Back to lobby",onClick:()=>location.href="/lobby/lobby.html"} ]); return;}
  try{
    const lobbySnap=await getDoc(LOBBY_REF); lobbyState=lobbySnap.data()||{}; isHost=lobbyState.hostUid===uid;
    await ensureRaceDoc(); await joinRacePlayer();
  }catch(err){
    if(err?.code==="permission-denied"){startLocalFallback("permission denied"); return;}
    throw err;
  }
  onSnapshot(RACE_REF, snap=>{
    if(!snap.exists()) return; raceState=snap.data();
    if(raceState.pickedObstacle&&isHost){applyObstaclePick(raceState.pickedObstacle,false).then(()=>updateDoc(RACE_REF,{pickedObstacle:null}));}
    spawnThreats(); renderBoard(); hostMaybeStart();
  }, err=>{
    if(err?.code==="permission-denied") startLocalFallback("permission denied");
  });
  setInterval(hostTick,400);
});
</script>
</body>
</html>
