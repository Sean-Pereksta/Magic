<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>StockKings: Figure-8 Rush (Multiplayer)</title>
  <style>
    :root{--bg:#060910;--panel:#0f1726;--line:#2f4468;--ink:#ecf3ff;--muted:#9fb0cc;--accent:#57b2ff;--good:#60f0a1;--warn:#ffd972;--bad:#ff6f89}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,Segoe UI,Roboto,sans-serif}
    #app{position:relative;height:100%;overflow:hidden}
    #scene{position:absolute;inset:0}
    .hud{position:absolute;inset:0;pointer-events:none;display:flex;flex-direction:column;justify-content:space-between;padding:12px}
    .top{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .chip{pointer-events:auto;background:rgba(10,15,25,.82);border:1px solid var(--line);border-radius:12px;padding:8px 10px;font-weight:800}
    .chip small{display:block;color:var(--muted);font-weight:650}
    .big{font-size:24px;font-weight:950}
    .board{pointer-events:auto;background:rgba(8,11,19,.9);border:1px solid var(--line);border-radius:14px;padding:10px;max-width:520px;max-height:48vh;overflow:auto}
    table{width:100%;border-collapse:collapse;font-size:13px}
    th,td{padding:6px;border-bottom:1px solid #21324e;text-align:left}
    .msg{font-size:13px;color:var(--muted);margin-top:8px}
    .tags{display:flex;flex-wrap:wrap;gap:6px;margin-top:8px}
    .tag{font-size:12px;padding:4px 8px;border-radius:999px;border:1px solid #2f4468;background:rgba(87,178,255,.08);color:#cfe7ff}

    .modalWrap{position:absolute;inset:0;background:rgba(3,6,12,.74);display:none;align-items:center;justify-content:center;padding:16px;z-index:20}
    .modalWrap.show{display:flex}
    .modal{pointer-events:auto;background:var(--panel);border:1px solid var(--line);border-radius:16px;max-width:760px;width:min(760px,95vw);padding:16px;box-shadow:0 16px 60px rgba(0,0,0,.45)}
    .modal h2{margin:0 0 8px}
    .modal p{margin:6px 0;color:var(--muted);line-height:1.35}
    .btns{display:flex;flex-wrap:wrap;gap:10px;margin-top:12px}
    button{cursor:pointer;border:1px solid #35649f;background:#1d4b80;color:#fff;border-radius:10px;padding:10px 12px;font-weight:900}
    button.ghost{background:#182133;border-color:#344867}
    button.warn{background:#6d4f12;border-color:#a0802e}
    button:disabled{opacity:.55;cursor:not-allowed}

    .controls{position:absolute;inset:auto 0 10px 0;display:none;justify-content:space-between;padding:0 10px;z-index:8}
    .pad,.boost{pointer-events:auto;background:rgba(8,14,24,.75);border:1px solid #35517a;border-radius:14px;touch-action:none}
    .pad{width:150px;height:150px;position:relative}
    .padDot{position:absolute;width:26px;height:26px;border-radius:50%;background:#68b8ff;left:62px;top:62px;pointer-events:none;box-shadow:0 0 14px rgba(104,184,255,.45)}
    .boost{width:120px;height:120px;display:grid;place-items:center;font-weight:1000;letter-spacing:.4px}
    .boost.onCd{background:rgba(45,18,18,.86);border-color:#8b3f3f}
    @media (max-width:920px){.controls{display:flex}.board{max-width:none}}
  </style>
</head>
<body>
<div id="app">
  <canvas id="scene"></canvas>

  <div class="hud">
    <div class="top">
      <div class="chip"><small>Status</small><span id="statusText">Connecting‚Ä¶</span></div>
      <div class="chip"><small>Phase</small><span id="phaseText">‚Äî</span></div>
      <div class="chip"><small>Round</small><span id="roundText">‚Äî</span></div>
      <div class="chip"><small>Lap Timer</small><span class="big" id="lapTimer">00.000</span></div>
      <div class="chip"><small>Boost</small><span id="boostText">Ready</span></div>
    </div>

    <div class="board">
      <h3 style="margin:0 0 8px">üèÅ Round Results</h3>
      <table>
        <thead><tr><th>Player</th><th>R1</th><th>R2</th><th>R3</th><th>Avg</th></tr></thead>
        <tbody id="scoreRows"></tbody>
      </table>
      <div class="tags" id="threatTags"></div>
      <div class="msg" id="waitingMsg">‚Äî</div>
    </div>
  </div>

  <div class="controls">
    <div class="pad" id="pad"><div class="padDot" id="padDot"></div></div>
    <button class="boost" id="boostBtn">BOOST</button>
  </div>

  <div class="modalWrap show" id="overlay">
    <div class="modal">
      <h2 id="overlayTitle">StockKings: Figure-8 Rush</h2>
      <p id="overlayBody">Connecting‚Ä¶</p>
      <div class="btns" id="overlayButtons"></div>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.162/build/three.module.js";
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
import {
  getFirestore, doc, getDoc, setDoc, onSnapshot, runTransaction
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

/* ============================================================
   CONFIG
============================================================ */
const firebaseConfig={
  apiKey:"AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain:"bible-game-246c0.firebaseapp.com",
  projectId:"bible-game-246c0",
  storageBucket:"bible-game-246c0.appspot.com",
  messagingSenderId:"959619818996",
  appId:"1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app=initializeApp(firebaseConfig);
const auth=getAuth(app);
const db=getFirestore(app);

const LS_USER  = "gh.username";
const LS_LOBBY = "gh.lastLobbyId";

const params=new URLSearchParams(location.search);
const gameId=(params.get("gameId")||localStorage.getItem(LS_LOBBY)||"").trim();
const username=(params.get("username")||localStorage.getItem(LS_USER)||"Racer").trim();

if(gameId) localStorage.setItem(LS_LOBBY, gameId);
if(username) localStorage.setItem(LS_USER, username);

const LOBBY_REF = gameId ? doc(db,"lobbies",gameId) : null;
const RACE_REF  = gameId ? doc(db,"lobbies",gameId,"crowncouncil","stockkingsRace") : null;

const COUNTDOWN_MS = 10000;
const DEADLINE_MS  = 30000;
const SELECT_MS    = 15000;
const MAX_ROUNDS   = 3;

const OBSTACLES={
  meteorites:{name:"Meteorites",desc:"Telegraphed impacts that stun briefly.",stunMs:2200},
  monsters:{name:"Track Monsters",desc:"Slam side-to-side and body-check racers."},
  eggs:{name:"Egg Storm",desc:"Bouncy eggs spill out and knock racers backward."},
  towers:{name:"Lightning Towers",desc:"Periodic zaps near the tower ring."},
  rhinos:{name:"Rhino Stampede",desc:"Stampede along the track and shove racers back."}
};
const obstacleOrder=Object.keys(OBSTACLES);

/* ============================================================
   DOM
============================================================ */
const el=id=>document.getElementById(id);

let overlayKey="";
function showOverlay(key,title,body,buttons){
  if(overlayKey!==key){
    overlayKey=key;
    el("overlayTitle").textContent=title;
    el("overlayBody").innerHTML=body;
    const wrap=el("overlayButtons"); wrap.innerHTML="";
    (buttons||[]).forEach(b=>{
      const bt=document.createElement("button");
      bt.textContent=b.label;
      if(b.className) bt.className=b.className;
      if(b.disabled) bt.disabled=true;
      bt.onclick=b.onClick||(()=>{});
      wrap.appendChild(bt);
    });
    el("overlay").classList.add("show");
  }else{
    // Update body if same mode but dynamic text (countdown)
    el("overlayTitle").textContent=title;
    el("overlayBody").innerHTML=body;
  }
}
function hideOverlay(){
  overlayKey="";
  el("overlay").classList.remove("show");
}

/* ============================================================
   RACE STATE
============================================================ */
let uid="";
let lobbyState=null;
let raceState=null;
let lobbyUnsub=null;
let raceUnsub=null;

let pendingTxn=false;
async function txn(mutator){
  if(!RACE_REF) return;
  if(pendingTxn) return;
  pendingTxn=true;
  try{
    await runTransaction(db, async (tx)=>{
      const snap=await tx.get(RACE_REF);
      if(!snap.exists()) return;
      const d=snap.data();
      const out = mutator(d);
      if(!out) return;
      tx.set(RACE_REF, out, {merge:false});
    });
  }catch(e){
    // console.warn("txn failed", e);
  }finally{
    pendingTxn=false;
  }
}

function now(){ return Date.now(); }
function avg(arr){
  const v=(arr||[]).filter(n=>typeof n==="number");
  return v.length ? (v.reduce((a,b)=>a+b,0)/v.length) : null;
}
function fmt(n){ return typeof n==="number" ? n.toFixed(2)+"s" : "‚Äî"; }

function expectedPlayers(){
  return (raceState?.expectedPlayers && Array.isArray(raceState.expectedPlayers) && raceState.expectedPlayers.length)
    ? raceState.expectedPlayers
    : (lobbyState?.players || [username]);
}

function getPlayer(name){
  const p=(raceState?.players||{})[name];
  if(!p) return null;
  return p;
}

/* ============================================================
   ENSURE DOCS
============================================================ */
async function ensureRaceDoc(){
  if(!RACE_REF) return;
  const snap=await getDoc(RACE_REF);
  if(snap.exists()) return;

  const exp = (lobbyState?.players && lobbyState.players.length) ? lobbyState.players.slice(0,8) : [username];
  const basePlayers = {};
  exp.forEach(n=>{
    basePlayers[n]={name:n,laps:[],avg:null,lastLap:null};
  });
  basePlayers[username] = basePlayers[username] || {name:username,laps:[],avg:null,lastLap:null};

  await setDoc(RACE_REF,{
    game:"stockkings-race",
    phase:"lobby_wait",
    round:1,
    maxRounds:MAX_ROUNDS,
    expectedPlayers:exp,
    players:basePlayers,
    obstacles:[], // stacked cumulatively
    countdownEndsAt:null,
    deadlineAt:null,
    selector:null,
    selectEndsAt:null,
    lastSelectorReason:"",
    winnerName:null,
    updatedAtMs: now(),
    createdAtMs: now()
  }, {merge:false});
}

async function ensureMeInPlayers(){
  if(!RACE_REF) return;
  await txn((d)=>{
    const exp = (Array.isArray(d.expectedPlayers) && d.expectedPlayers.length) ? d.expectedPlayers.slice(0,8) : (lobbyState?.players||[username]).slice(0,8);
    if(!exp.includes(username)) exp.push(username);
    exp.splice(8);

    const players = d.players || {};
    if(!players[username]){
      players[username]={name:username,laps:[],avg:null,lastLap:null};
    }else{
      players[username].name = players[username].name || username;
      players[username].laps = players[username].laps || [];
      players[username].avg  = (typeof players[username].avg === "number") ? players[username].avg : avg(players[username].laps);
    }

    // add any expected players missing
    exp.forEach(n=>{
      if(!players[n]) players[n]={name:n,laps:[],avg:null,lastLap:null};
    });

    d.expectedPlayers = exp;
    d.players = players;
    d.updatedAtMs = now();
    return d;
  });
}

function lobbyStarted(){
  return (lobbyState?.status === "started");
}

async function maybeStartFromLobby(){
  if(!raceState) return;
  if(!lobbyStarted()) return;

  // If race is lobby_wait/pregame ‚Üí start countdown
  if(raceState.phase==="lobby_wait"){
    await txn((d)=>{
      if(d.phase!=="lobby_wait") return null;
      d.phase="countdown";
      d.countdownEndsAt = now() + COUNTDOWN_MS;
      d.deadlineAt = null;
      d.selector = null;
      d.selectEndsAt = null;
      d.lastSelectorReason = "";
      d.updatedAtMs = now();
      return d;
    });
  }
}

/* ============================================================
   ROUND LOGIC (NO HOST REQUIRED)
============================================================ */
function computeBottomSelector(d){
  const exp = (d.expectedPlayers||[]).slice(0,8);
  const round = d.round||1;
  const players = d.players||{};
  const entries = exp.map(n=>{
    const t = players[n]?.laps?.[round-1];
    return {name:n, t: (typeof t==="number") ? t : 30};
  });
  const maxT = Math.max(...entries.map(e=>e.t));
  const bottoms = entries.filter(e=>e.t===maxT);
  return bottoms[Math.floor(Math.random()*bottoms.length)].name;
}

function computeWinner(d){
  const exp = (d.expectedPlayers||[]).slice(0,8);
  const players = d.players||{};
  let bestName=null, best=1e18;
  exp.forEach(n=>{
    const a = avg(players[n]?.laps||[]);
    if(typeof a==="number" && a<best){ best=a; bestName=n; }
  });
  return bestName || exp[0] || null;
}

async function finalizeDeadlineIfNeeded(){
  if(!raceState) return;
  if(raceState.phase!=="lap_wait") return;
  if(!raceState.deadlineAt) return;
  const t=now();
  if(t<raceState.deadlineAt) return;

  await txn((d)=>{
    if(d.phase!=="lap_wait") return null;
    if(!d.deadlineAt || now()<d.deadlineAt) return null;

    const round=d.round||1;
    const exp=(d.expectedPlayers||[]).slice(0,8);
    d.players = d.players || {};
    exp.forEach(n=>{
      const p=d.players[n] || (d.players[n]={name:n,laps:[],avg:null,lastLap:null});
      p.laps = p.laps || [];
      if(typeof p.laps[round-1] !== "number"){
        p.laps[round-1]=30;
        p.lastLap=30;
        p.avg=avg(p.laps);
      }
    });

    // Everyone done now
    if(round >= (d.maxRounds||MAX_ROUNDS)){
      d.phase="finished";
      d.winnerName = computeWinner(d);
      d.updatedAtMs = now();
      return d;
    }

    d.phase="obstacle_select";
    d.selector = computeBottomSelector(d);
    d.selectEndsAt = now() + SELECT_MS;
    d.lastSelectorReason = "Deadline reached ‚Äî slowest lap chooses next threat.";
    d.updatedAtMs = now();
    return d;
  });
}

async function advanceCountdownIfNeeded(){
  if(!raceState) return;
  if(raceState.phase!=="countdown") return;
  if(!raceState.countdownEndsAt) return;
  if(now() < raceState.countdownEndsAt) return;

  await txn((d)=>{
    if(d.phase!=="countdown") return null;
    if(!d.countdownEndsAt || now() < d.countdownEndsAt) return null;
    d.phase="racing";
    d.deadlineAt = null;
    d.selector = null;
    d.selectEndsAt = null;
    d.lastSelectorReason = "";
    d.updatedAtMs = now();
    return d;
  });
}

function pickFromAvailable(used){
  const all=obstacleOrder;
  const avail=all.filter(o=>!used.includes(o));
  if(avail.length) return avail[Math.floor(Math.random()*avail.length)];
  return all[Math.floor(Math.random()*all.length)];
}

async function chooseThreat(type=null, auto=false){
  if(!raceState) return;
  if(raceState.phase!=="obstacle_select") return;

  const t=now();
  const exp = expectedPlayers();
  const single = exp.length<=1;

  await txn((d)=>{
    if(d.phase!=="obstacle_select") return null;

    const exp=(d.expectedPlayers||[]).slice(0,8);
    const single = exp.length<=1;

    const canPick = single || auto || (d.selector===username);
    if(!canPick) return null;

    const used = Array.isArray(d.obstacles) ? d.obstacles.slice() : [];
    let pick = (type && obstacleOrder.includes(type)) ? type : null;

    const all=obstacleOrder;
    const avail=all.filter(o=>!used.includes(o));

    if(!pick){
      pick = avail.length ? avail[Math.floor(Math.random()*avail.length)] : pickFromAvailable(used);
    }else{
      // If we still have unused types, prevent repeats until exhausted
      if(avail.length && used.includes(pick)){
        pick = avail[Math.floor(Math.random()*avail.length)];
      }
    }

    if(avail.length){
      if(!used.includes(pick)) used.push(pick);
    }else{
      // after exhaustion allow repeats (stack chaos mode)
      used.push(pick);
    }

    const nextRound = (d.round||1) + 1;
    d.obstacles = used;
    d.round = nextRound;
    d.phase = "countdown";
    d.countdownEndsAt = now() + COUNTDOWN_MS;
    d.deadlineAt = null;
    d.selector = null;
    d.selectEndsAt = null;
    d.lastSelectorReason = auto ? "Auto-picked (timeout / solo)." : "";
    d.updatedAtMs = now();
    return d;
  });
}

async function autoPickIfNeeded(){
  if(!raceState) return;
  if(raceState.phase!=="obstacle_select") return;
  const exp = expectedPlayers();
  const single = exp.length<=1;

  if(single){
    // immediate auto pick in solo to keep flow
    await chooseThreat(null,true);
    return;
  }
  if(raceState.selectEndsAt && now() >= raceState.selectEndsAt){
    await chooseThreat(null,true);
  }
}

/* ============================================================
   SUBMIT LAP (TXN)
============================================================ */
async function submitLap(lapSeconds){
  if(!raceState) return;
  const t=now();

  await txn((d)=>{
    const exp=(d.expectedPlayers||[]).slice(0,8);
    if(!exp.includes(username)) exp.push(username);

    const round=d.round||1;
    const maxRounds=d.maxRounds||MAX_ROUNDS;

    // Only accept during racing / lap_wait, and if deadline not passed
    if(!(d.phase==="racing" || d.phase==="lap_wait")) return null;
    if(d.deadlineAt && t > d.deadlineAt) return null;

    d.players = d.players || {};
    const me = d.players[username] || (d.players[username]={name:username,laps:[],avg:null,lastLap:null});
    me.laps = me.laps || [];
    if(typeof me.laps[round-1] === "number") return null; // already submitted

    const time = Math.min(30, Math.max(0.5, lapSeconds));
    me.laps[round-1]=time;
    me.lastLap=time;
    me.avg=avg(me.laps);

    // Ensure everyone has player objects
    exp.forEach(n=>{
      const p=d.players[n] || (d.players[n]={name:n,laps:[],avg:null,lastLap:null});
      p.laps = p.laps || [];
      p.avg = (typeof p.avg==="number") ? p.avg : avg(p.laps);
    });

    d.expectedPlayers = exp;

    // Determine completion
    const doneForRound = exp.map(n => typeof d.players[n]?.laps?.[round-1] === "number");
    const anyFinished = doneForRound.some(Boolean);
    const everyoneDone = doneForRound.every(Boolean);

    if(everyoneDone){
      // End of round
      if(round >= maxRounds){
        d.phase="finished";
        d.winnerName = computeWinner(d);
        d.updatedAtMs = now();
        return d;
      }
      d.phase="obstacle_select";
      d.selector = computeBottomSelector(d);
      d.selectEndsAt = now() + SELECT_MS;
      d.lastSelectorReason = "Slowest lap chooses next threat.";
      d.deadlineAt = null;
      d.updatedAtMs = now();
      return d;
    }

    // Not everyone done ‚Äî if first finisher triggers waiting window
    if(!d.deadlineAt && anyFinished){
      d.phase="lap_wait";
      d.deadlineAt = now() + DEADLINE_MS;
      d.updatedAtMs = now();
      return d;
    }

    d.updatedAtMs = now();
    return d;
  });
}

/* ============================================================
   THREE SETUP
============================================================ */
const renderer=new THREE.WebGLRenderer({canvas:el("scene"),antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));

const scene=new THREE.Scene();
scene.background=new THREE.Color(0x68b5ff);

const camera=new THREE.PerspectiveCamera(62,1,0.1,1200);
camera.position.set(0,23,22);

scene.add(new THREE.HemisphereLight(0xcde8ff,0x274b22,1.1));
const sun=new THREE.DirectionalLight(0xffffff,1);
sun.position.set(18,40,20);
sun.castShadow=false;
scene.add(sun);

const ground=new THREE.Mesh(
  new THREE.PlaneGeometry(280,280),
  new THREE.MeshStandardMaterial({color:0x2e8a3f,roughness:.95})
);
ground.rotation.x=-Math.PI/2;
scene.add(ground);

// Subtle fog
scene.fog = new THREE.FogExp2(0x68b5ff, 0.012);

/* Track */
const trackPath=[];
for(let i=0;i<760;i++){
  const t=(i/760)*Math.PI*2;
  const x=36*Math.sin(t);
  const z=18*Math.sin(t)*Math.cos(t);
  trackPath.push(new THREE.Vector3(x,0.03,z));
}
for(let i=1;i<trackPath.length;i++){
  const a=trackPath[i-1],b=trackPath[i];
  const len=a.distanceTo(b);
  const mid=new THREE.Vector3().addVectors(a,b).multiplyScalar(.5);
  const mesh=new THREE.Mesh(
    new THREE.BoxGeometry(8,0.25,len+1),
    new THREE.MeshStandardMaterial({color:0x8a5d30,roughness:.85,metalness:0.02})
  );
  mesh.position.copy(mid);
  mesh.lookAt(b.x,mid.y,b.z);
  mesh.rotateY(Math.PI/2);
  scene.add(mesh);
}

const trackCenter=(t)=>new THREE.Vector3(36*Math.sin(t),0,18*Math.sin(t)*Math.cos(t));
function nearestParam(x,z){
  let bestT=0,best=1e18;
  for(let i=0;i<trackPath.length;i++){
    const p=trackPath[i];
    const d=(p.x-x)**2+(p.z-z)**2;
    if(d<best){ best=d; bestT=(i/trackPath.length)*Math.PI*2; }
  }
  return {t:bestT,d:Math.sqrt(best)};
}

/* Seeded rocks (deterministic per gameId) */
function hashSeed(s){
  let h=2166136261>>>0;
  for(let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h = Math.imul(h,16777619); }
  return h>>>0;
}
function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
}
const rand = mulberry32(hashSeed(gameId||"solo"));
const roadRocks=[];
function spawnRoadRocks(){
  roadRocks.splice(0).forEach(r=>scene.remove(r.mesh));
  const rockMat = new THREE.MeshStandardMaterial({color:0x5a5f66,roughness:.95,metalness:0.0});
  for(let i=0;i<22;i++){
    const t = (i/22)*Math.PI*2 + (rand()-0.5)*0.12;
    const c = trackCenter(t);
    // place within track width
    const off = (rand()-0.5)*6.0;
    const n = new THREE.Vector3().subVectors(trackCenter(t+0.02), trackCenter(t-0.02)).normalize();
    const right = new THREE.Vector3(n.z,0,-n.x).normalize();
    const pos = new THREE.Vector3(c.x,0.15,c.z).addScaledVector(right, off);

    const s = 0.5 + rand()*0.9;
    const mesh = new THREE.Mesh(new THREE.DodecahedronGeometry(s,0), rockMat);
    mesh.position.copy(pos);
    mesh.rotation.set(rand()*3, rand()*3, rand()*3);
    scene.add(mesh);
    roadRocks.push({mesh, r: s*0.95, hitCd:0});
  }
}
spawnRoadRocks();

/* Car */
function buildCar(){
  const g=new THREE.Group();
  const body=new THREE.Mesh(
    new THREE.BoxGeometry(2.6,.9,4.2),
    new THREE.MeshStandardMaterial({color:0x1f74ff,metalness:.25,roughness:.35})
  );
  body.position.y=.9;

  const top=new THREE.Mesh(
    new THREE.BoxGeometry(1.8,.7,2),
    new THREE.MeshStandardMaterial({color:0xd8e8ff,metalness:.05,roughness:.5})
  );
  top.position.set(0,1.45,-.2);

  g.add(body,top);

  [[-1,.35,-1.3],[1,.35,-1.3],[-1,.35,1.3],[1,.35,1.3]].forEach(([x,y,z])=>{
    const w=new THREE.Mesh(
      new THREE.CylinderGeometry(.45,.45,.4,16),
      new THREE.MeshStandardMaterial({color:0x101218,roughness:.9})
    );
    w.rotation.z=Math.PI/2;
    w.position.set(x,y,z);
    g.add(w);
  });

  // Boost flame (will shift orange->blue)
  const flameMat = new THREE.MeshBasicMaterial({color:0xff7a22,transparent:true,opacity:.9});
  const flame = new THREE.Mesh(new THREE.ConeGeometry(.28,1.35,10), flameMat);
  flame.position.set(0,.9,2.7);
  flame.rotation.x=Math.PI/2;
  g.add(flame);
  g.flame = flame;
  g.flameMat = flameMat;

  return g;
}
const car=buildCar();
scene.add(car);

function resetCarToStart(){
  car.position.set(0,.1,-6);
  car.rotation.set(0,0,0);
}
resetCarToStart();

/* ============================================================
   THREATS (STACKED)
============================================================ */
const threats=[];
const boomFX=[];

function addBoom(pos, colorHex){
  const ring = new THREE.Mesh(
    new THREE.RingGeometry(0.2,0.6,28),
    new THREE.MeshBasicMaterial({color:colorHex,transparent:true,opacity:0.85,side:THREE.DoubleSide})
  );
  ring.rotation.x=-Math.PI/2;
  ring.position.set(pos.x,0.08,pos.z);
  scene.add(ring);
  boomFX.push({mesh:ring, life:0.45});
}

function spawnThreats(){
  threats.splice(0).forEach(t=>scene.remove(t.mesh));
  boomFX.splice(0).forEach(b=>scene.remove(b.mesh));

  const active=(raceState?.obstacles||[]);
  active.forEach((type,idx)=>{
    for(let i=0;i<3;i++){
      const tt=((idx*3+i+1)/11)*Math.PI*2;
      const c=trackCenter(tt);
      let mesh=null;

      if(type==="meteorites"){
        mesh=new THREE.Mesh(
          new THREE.CylinderGeometry(1.8,1.8,.05,24),
          new THREE.MeshBasicMaterial({color:0xffc266,transparent:true,opacity:.33})
        );
        mesh.position.set(c.x,.06,c.z);
        threats.push({type,mesh,r:2.2,timer:2+Math.random()*4, hot:0});
      }

      if(type==="monsters"){
        mesh=new THREE.Mesh(
          new THREE.BoxGeometry(1.5,1.8,1.5),
          new THREE.MeshStandardMaterial({color:0x6f32a8,roughness:.65,metalness:.05,emissive:0x1a0830,emissiveIntensity:.35})
        );
        mesh.position.set(c.x,1,c.z);
        threats.push({type,mesh,r:1.7,vx:Math.random()>.5?1:-1});
      }

      if(type==="eggs"){
        mesh=new THREE.Mesh(
          new THREE.SphereGeometry(.82,18,12),
          new THREE.MeshStandardMaterial({color:0xf4efe5,roughness:.4,metalness:.0})
        );
        mesh.position.set(c.x,.82,c.z);
        threats.push({type,mesh,r:1.25,v:new THREE.Vector3((Math.random()-.5)*3,0,(Math.random()-.5)*3)});
      }

      if(type==="towers"){
        mesh=new THREE.Group();
        const p=new THREE.Mesh(
          new THREE.CylinderGeometry(.8,1.1,4,10),
          new THREE.MeshStandardMaterial({color:0x3e4b63,roughness:.85})
        );
        p.position.y=2;

        const ring=new THREE.Mesh(
          new THREE.RingGeometry(2.4,3.0,26),
          new THREE.MeshBasicMaterial({color:0x9ec9ff,side:THREE.DoubleSide,transparent:true,opacity:.55})
        );
        ring.rotation.x=-Math.PI/2;

        const core=new THREE.Mesh(
          new THREE.SphereGeometry(.28,14,10),
          new THREE.MeshBasicMaterial({color:0xbfe0ff})
        );
        core.position.y=3.9;

        mesh.add(p,ring,core);
        mesh.position.set(c.x,0,c.z);
        threats.push({type,mesh,r:2.9,flash:0, cool: 1.0+Math.random()*2.2});
      }

      if(type==="rhinos"){
        mesh=new THREE.Mesh(
          new THREE.BoxGeometry(2.2,1.4,3.4),
          new THREE.MeshStandardMaterial({color:0x7b7f86,roughness:.8,metalness:.08,emissive:0x0c0c0c,emissiveIntensity:.15})
        );
        mesh.position.set(c.x,.7,c.z);
        threats.push({type,mesh,r:2.0,t:tt});
      }

      if(mesh) scene.add(mesh);
    }
  });
}

/* ============================================================
   GAMEPLAY (LOCAL)
============================================================ */
let isRacing=false;
let lapStart=0;
let firstCheckpoint=false;
let lastParam=0;

let stunUntil=0;
let boostReadyAt=0;
let lastHitAt=0;
let bumpSlowUntil=0;

const keys={forward:false,left:false,right:false,boost:false};

function startLapLocal(){
  resetCarToStart();
  isRacing=true;
  lapStart=now();
  firstCheckpoint=false;
  lastParam=nearestParam(car.position.x,car.position.z).t;
  stunUntil=0;
  bumpSlowUntil=0;
}

function updateThreats(dt){
  const sec=performance.now()/1000;

  // boom FX
  for(let i=boomFX.length-1;i>=0;i--){
    const b=boomFX[i];
    b.life-=dt;
    const s = 1 + (0.45-b.life)*5.0;
    b.mesh.scale.set(s,s,s);
    b.mesh.material.opacity = Math.max(0, b.life/0.45) * 0.85;
    if(b.life<=0){ scene.remove(b.mesh); boomFX.splice(i,1); }
  }

  threats.forEach(t=>{
    if(t.type==="meteorites"){
      t.timer -= dt;
      t.hot = Math.max(0, t.hot - dt);
      if(t.timer < 0){
        t.timer = 3 + Math.random()*4;
        t.hot = 0.28; // boom window
        t.mesh.material.color.setHex(0xff4b4b);
        addBoom(t.mesh.position, 0xff4b4b);
        setTimeout(()=>{ // revert to warn
          if(performance.now()/1000 - sec < .25) return;
          if(t.mesh && t.mesh.material) t.mesh.material.color.setHex(0xffc266);
        }, 210);
      }
    }
    if(t.type==="monsters"){
      t.mesh.position.x += t.vx*dt*4;
      if(Math.abs(t.mesh.position.x)>45) t.vx*=-1;
    }
    if(t.type==="eggs"){
      t.mesh.position.addScaledVector(t.v,dt);
      t.v.multiplyScalar(.985);
    }
    if(t.type==="towers"){
      t.flash = Math.max(0, t.flash-dt);
      t.cool -= dt;
      if(t.cool<=0){
        t.cool = 1.0 + Math.random()*2.2;
        t.flash = 0.22;
        addBoom(t.mesh.position, 0x9ec9ff);
      }
      const ring=t.mesh.children[1];
      ring.material.opacity = 0.42 + (t.flash*2.0);
    }
    if(t.type==="rhinos"){
      t.t = (t.t + dt*0.92)%(Math.PI*2);
      const c=trackCenter(t.t);
      t.mesh.position.set(c.x,.7,c.z);
    }

    // collision checks
    const d=t.mesh.position.distanceTo(car.position);
    if(d<t.r+1.05 && now()-lastHitAt>1200){
      // Meteorites only punish during boom window (feels fairer)
      if(t.type==="meteorites" && t.hot<=0) return;

      lastHitAt=now();
      if(t.type==="meteorites"||t.type==="towers"){
        stunUntil=Math.max(stunUntil, now() + (t.type==="meteorites"?2200:1700));
      }
      if(t.type==="eggs"){
        const dir=new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);
        car.position.addScaledVector(dir,-2.1);
        scene.remove(t.mesh); t.dead=true;
      }
      if(t.type==="rhinos"||t.type==="monsters"){
        const dir=new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);
        car.position.addScaledVector(dir,-5.6);
        stunUntil=Math.max(stunUntil, now()+900);
      }
    }
  });

  for(let i=threats.length-1;i>=0;i--) if(threats[i].dead) threats.splice(i,1);
}

function updateRoadRocks(dt){
  for(const r of roadRocks){
    r.hitCd = Math.max(0, r.hitCd - dt);
    const d = r.mesh.position.distanceTo(car.position);
    if(d < r.r + 1.05 && r.hitCd<=0){
      r.hitCd = 1.2;
      bumpSlowUntil = Math.max(bumpSlowUntil, now()+650);
      const back=new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);
      car.position.addScaledVector(back,-0.9);
      addBoom(r.mesh.position, 0x5a5f66);
    }
  }
}

function updateCar(dt){
  const t=now();
  const stunned = t < stunUntil;

  // Base speed auto-drive; holding forward increases
  let speed=11;
  if(keys.forward && !stunned) speed=18;

  // bump slow
  if(t < bumpSlowUntil) speed *= 0.72;

  // boost
  const boosting = keys.boost && (t > boostReadyAt) && !stunned;
  if(boosting){
    speed=30;
    boostReadyAt=t+8000;
  }

  // off-track penalty
  const near=nearestParam(car.position.x,car.position.z);
  if(near.d>4.2) speed*=0.54;

  // steering
  const turn=(keys.left?-1:0)+(keys.right?1:0);
  car.rotation.y -= turn*dt*2.2;

  // move forward along car direction
  const forward=new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion);
  car.position.addScaledVector(forward, speed*dt);
  car.position.y=.1;

  // flame visuals: orange idle, blue burst on boost press, blue fade on cooldown
  const cdLeft = Math.max(0, (boostReadyAt - t)/1000);
  const blueBurst = boosting ? 1 : Math.max(0, 1 - (cdLeft/8)); // fades after use
  const baseColor = new THREE.Color(0xff7a22);
  const boostColor = new THREE.Color(0x3bd7ff);
  car.flameMat.color.copy(baseColor).lerp(boostColor, Math.min(1, blueBurst));
  const flameScale = boosting ? 1.9 : (t < boostReadyAt ? 1.0 : 0.75);
  car.flame.scale.set(1, flameScale, flameScale);

  // lap detection
  const p=nearestParam(car.position.x,car.position.z).t;
  if(p>Math.PI*.9 && p<Math.PI*1.1) firstCheckpoint=true;
  if(firstCheckpoint && lastParam>5.7 && p<.5){
    // completed a lap for this round
    const lapSec = (t - lapStart)/1000;
    isRacing=false;
    submitLap(lapSec);
  }
  lastParam=p;
}

/* ============================================================
   UI RENDER
============================================================ */
function renderBoard(){
  const exp = expectedPlayers().slice(0,8);
  const players = raceState?.players || {};
  const rows = exp.map(n=>{
    const p = players[n] || {name:n,laps:[],avg:null};
    const laps = p.laps || [];
    return {name:n, l1:laps[0], l2:laps[1], l3:laps[2], avg: avg(laps)};
  }).sort((a,b)=>((a.avg??999)-(b.avg??999)));

  el("scoreRows").innerHTML = rows.map(r=>`
    <tr>
      <td>${r.name}${r.name===username ? " (you)" : ""}</td>
      <td>${fmt(r.l1)}</td>
      <td>${fmt(r.l2)}</td>
      <td>${fmt(r.l3)}</td>
      <td>${fmt(r.avg)}</td>
    </tr>
  `).join("");

  const phase = raceState?.phase || "‚Äî";
  el("phaseText").textContent = phase.replaceAll("_"," ");
  el("roundText").textContent = `${raceState?.round||1} / ${raceState?.maxRounds||MAX_ROUNDS}`;

  const used = (raceState?.obstacles||[]);
  const tagBox = el("threatTags");
  tagBox.innerHTML = used.length ? used.map(o=>`<span class="tag">‚ö†Ô∏è ${OBSTACLES[o]?.name||o}</span>`).join("") : `<span class="tag">No threats yet</span>`;

  const t=now();
  const expCount = expectedPlayers().length;

  if(!lobbyState){
    el("waitingMsg").textContent = "Connecting to lobby‚Ä¶";
  }else if(!lobbyStarted()){
    el("waitingMsg").textContent = "Waiting for lobby host to start the match‚Ä¶";
  }else if(phase==="countdown"){
    const s = Math.max(0, Math.ceil(((raceState?.countdownEndsAt||t)-t)/1000));
    el("waitingMsg").textContent = `Round starts in ${s}s.`;
  }else if(phase==="lap_wait"){
    const s = Math.max(0, Math.ceil(((raceState?.deadlineAt||t)-t)/1000));
    el("waitingMsg").textContent = `Waiting for racers‚Ä¶ ${s}s remaining before timeouts. (${expCount} players)`;
  }else if(phase==="obstacle_select"){
    el("waitingMsg").textContent = (raceState?.selector===username)
      ? "You were slowest ‚Äî choose the next threat!"
      : `Waiting for ${raceState?.selector||"slowest racer"} to choose the next threat‚Ä¶`;
  }else if(phase==="racing"){
    el("waitingMsg").textContent = "Race!";
  }else if(phase==="finished"){
    const w = raceState?.winnerName || "Winner";
    el("waitingMsg").textContent = `üèÜ Winner: ${w}`;
  }else{
    el("waitingMsg").textContent = "Syncing‚Ä¶";
  }
}

function renderOverlay(){
  const t=now();
  const phase = raceState?.phase;

  if(!gameId){
    showOverlay("nogame","Missing gameId",
      "Open StockKings from the Lobby so multiplayer syncing works.",
      [{label:"Back to Lobby", className:"warn", onClick:()=>location.href="/lobby/lobby.html"}]
    );
    return;
  }

  if(!lobbyState){
    showOverlay("connLobby","Connecting to Lobby‚Ä¶",
      "Establishing lobby connection. If this hangs, your rules/auth aren't passing.",
      []
    );
    return;
  }

  if(!lobbyStarted()){
    showOverlay("waitStart","Waiting for Lobby Start",
      "The host hasn‚Äôt started the match yet.<br/><br/>Go back to the lobby and press <b>Start Game</b>.",
      [{label:"Back to Lobby", className:"warn", onClick:()=>location.href="/lobby/lobby.html"}]
    );
    return;
  }

  if(!raceState){
    showOverlay("connRace","Connecting to Race State‚Ä¶",
      "Joining the race document and syncing players‚Ä¶",
      []
    );
    return;
  }

  if(phase==="countdown"){
    const s = Math.max(0, Math.ceil(((raceState.countdownEndsAt||t)-t)/1000));
    showOverlay("countdown","Race starts soon",
      `<b style="font-size:28px">${s}</b> seconds until launch.<br/>Boost cooldown: <b>8s</b>.<br/>Threats stack each round.`,
      [{label:"Fullscreen", className:"warn", onClick:()=>document.documentElement.requestFullscreen?.()},{label:"Ready", className:"ghost", onClick:hideOverlay}]
    );
    return;
  }

  if(phase==="obstacle_select"){
    const exp = expectedPlayers();
    const single = exp.length<=1;

    const used = raceState.obstacles||[];
    const all = obstacleOrder;
    const avail = all.filter(o=>!used.includes(o));
    const options = avail.length ? avail : all;

    const canPick = single || (raceState.selector===username);

    const buttons = canPick
      ? options.map(o=>({
          label:OBSTACLES[o].name,
          onClick:()=>chooseThreat(o,false)
        })).concat([{
          label:"Random",
          className:"ghost",
          onClick:()=>chooseThreat(null,false)
        }])
      : [{label:"Waiting‚Ä¶", className:"ghost", disabled:true}];

    const reason = raceState.lastSelectorReason || "Slowest lap chooses the next threat.";
    const end = raceState.selectEndsAt || (t+SELECT_MS);
    const s = Math.max(0, Math.ceil((end - t)/1000));

    showOverlay("pickThreat", canPick ? "Choose the next threat" : "Waiting for threat choice",
      `<b>${reason}</b><br/>Selection closes in <b>${s}s</b>.`,
      buttons
    );
    return;
  }

  if(phase==="finished"){
    const w = raceState.winnerName || "Winner";
    const players = raceState.players || {};
    const a = avg(players[w]?.laps||[]);
    showOverlay("finished","üèÜ Race Complete",
      `<b>${w}</b> wins with the lowest average time (${typeof a==="number"?a.toFixed(2)+"s":"‚Äî"}).<br/><br/>Return to lobby for another match.`,
      [{label:"Return to Lobby", className:"warn", onClick:()=>location.href="/lobby/lobby.html"}]
    );
    return;
  }

  // racing / lap_wait: no overlay
  hideOverlay();
}

function renderHUD(){
  const t=now();
  const lapElapsed = isRacing ? ((t - lapStart)/1000) : 0;
  el("lapTimer").textContent = lapElapsed.toFixed(3);

  const cdLeft = Math.max(0,(boostReadyAt - t)/1000);
  el("boostText").textContent = cdLeft ? `Cooldown ${cdLeft.toFixed(1)}s` : "Ready";
  el("boostBtn").classList.toggle("onCd", cdLeft>0.01);

  let status =
    !uid ? "Auth‚Ä¶" :
    !lobbyState ? "Connecting to lobby‚Ä¶" :
    !lobbyStarted() ? "Waiting for lobby start‚Ä¶" :
    !raceState ? "Connecting to race‚Ä¶" :
    (t < stunUntil) ? "Stunned!" :
    (raceState.phase==="lap_wait") ? "Waiting‚Ä¶" :
    (raceState.phase==="racing") ? "Racing" :
    "Syncing‚Ä¶";

  el("statusText").textContent = status;
}

/* ============================================================
   MAIN LOOP
============================================================ */
let prev=performance.now();
function loop(ts){
  const dt=Math.min(.033,(ts-prev)/1000); prev=ts;

  // threats always animate for visuals
  updateThreats(dt);
  updateRoadRocks(dt);

  if(raceState?.phase==="racing"){
    if(!isRacing) startLapLocal();
    updateCar(dt);
  }else{
    isRacing=false;
  }

  // camera follow
  const follow=new THREE.Vector3(
    car.position.x+Math.sin(car.rotation.y)*13,
    15,
    car.position.z+Math.cos(car.rotation.y)*13
  );
  camera.position.lerp(follow,.08);
  camera.lookAt(car.position.x,1.2,car.position.z);

  renderer.setSize(innerWidth,innerHeight,false);
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.render(scene,camera);

  renderHUD();
  renderBoard();
  renderOverlay();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ============================================================
   CONTROLS
============================================================ */
function setupControls(){
  addEventListener("keydown",e=>{
    if(e.key==='ArrowUp'||e.key==='w') keys.forward=true;
    if(e.key==='ArrowLeft'||e.key==='a') keys.left=true;
    if(e.key==='ArrowRight'||e.key==='d') keys.right=true;
    if(e.key===' ') keys.boost=true;
  });
  addEventListener("keyup",e=>{
    if(e.key==='ArrowUp'||e.key==='w') keys.forward=false;
    if(e.key==='ArrowLeft'||e.key==='a') keys.left=false;
    if(e.key==='ArrowRight'||e.key==='d') keys.right=false;
    if(e.key===' ') keys.boost=false;
  });

  // Mobile pad
  const pad=el("pad"), dot=el("padDot");
  function movePad(ev){
    const r=pad.getBoundingClientRect();
    const t=(ev.touches?ev.touches[0]:ev);
    const x=Math.max(0,Math.min(r.width, t.clientX-r.left));
    const y=Math.max(0,Math.min(r.height, t.clientY-r.top));
    dot.style.left=(x-13)+"px";
    dot.style.top=(y-13)+"px";
    keys.forward = y < r.height*0.82;
    keys.left    = x < r.width*0.40;
    keys.right   = x > r.width*0.60;
  }
  ["touchstart","touchmove","mousedown","mousemove"].forEach(evt=>{
    pad.addEventListener(evt, e=>{
      if(evt.includes("move") && e.buttons===0 && !e.touches) return;
      movePad(e);
    }, {passive:false});
  });
  ["touchend","mouseup","mouseleave"].forEach(evt=>{
    pad.addEventListener(evt, ()=>{
      keys.forward=keys.left=keys.right=false;
      dot.style.left="62px";
      dot.style.top="62px";
    });
  });

  // Boost
  const boost=el("boostBtn");
  const down=()=>keys.boost=true, up=()=>keys.boost=false;
  boost.addEventListener("touchstart",down,{passive:true});
  boost.addEventListener("touchend",up);
  boost.addEventListener("mousedown",down);
  boost.addEventListener("mouseup",up);
  boost.addEventListener("mouseleave",up);
}
setupControls();

/* ============================================================
   NETWORK BOOTSTRAP
============================================================ */
function attachLobby(){
  if(!LOBBY_REF) return;
  if(lobbyUnsub) lobbyUnsub();

  lobbyUnsub = onSnapshot(LOBBY_REF, async (snap)=>{
    if(!snap.exists()){
      lobbyState=null;
      showOverlay("nolobby","Lobby not found",
        "This lobby no longer exists. Return to the lobby and start again.",
        [{label:"Back to Lobby", className:"warn", onClick:()=>location.href="/lobby/lobby.html"}]
      );
      return;
    }

    lobbyState = snap.data() || {};

    // Ensure race doc exists and is sane
    await ensureRaceDoc();
    await ensureMeInPlayers();

    // Attach race snapshot once
    if(!raceUnsub){
      raceUnsub = onSnapshot(RACE_REF, (rsnap)=>{
        if(!rsnap.exists()) return;
        const prevObsSig = JSON.stringify(raceState?.obstacles||[]);
        const next = rsnap.data();
        raceState = next;

        // respawn threats only if obstacle stack changed
        const nextObsSig = JSON.stringify(raceState?.obstacles||[]);
        if(nextObsSig !== prevObsSig){
          spawnThreats();
        }
      });
    }

    // start flow when lobby starts
    await maybeStartFromLobby();
  });
}

function tickStateMachine(){
  // any client can advance time-based phases (transactions make it safe)
  if(!raceState) return;
  advanceCountdownIfNeeded();
  finalizeDeadlineIfNeeded();
  autoPickIfNeeded();
}

onAuthStateChanged(auth, async (user)=>{
  if(!user){
    await signInAnonymously(auth);
    return;
  }
  uid=user.uid;

  if(!gameId){
    showOverlay("nogame","Missing gameId",
      "Open StockKings from the Lobby so multiplayer syncing works.",
      [{label:"Back to Lobby", className:"warn", onClick:()=>location.href="/lobby/lobby.html"}]
    );
    return;
  }

  attachLobby();
  setInterval(tickStateMachine, 250);
});

signInAnonymously(auth).catch(()=>{});
</script>
</body>
</html>
