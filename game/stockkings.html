<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
        content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <title>üìà StockKings ‚Äî Donut Rush (3-Lap Threat Stack)</title>

  <style>
    :root{
      --bg0:#050812;
      --bg2:#0b1b3f;
      --panel: rgba(14, 23, 38, .78);
      --line: rgba(87,178,255,.22);
      --line2: rgba(255,255,255,.08);
      --ink:#ecf3ff;
      --muted:#a9bad8;
      --muted2:#7f93b7;
      --accent:#57b2ff;
      --good:#60f0a1;
      --warn:#ffd972;
      --bad:#ff6f89;
      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --r: 14px;
    }

    *{ box-sizing:border-box; }
    html,body{
      height:100%;
      margin:0;
      color:var(--ink);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background:
        radial-gradient(1200px 900px at 20% 10%, rgba(87,178,255,.18), transparent 58%),
        radial-gradient(900px 700px at 80% 0%, rgba(96,240,161,.12), transparent 55%),
        radial-gradient(900px 700px at 50% 100%, rgba(255,111,137,.10), transparent 55%),
        linear-gradient(180deg, var(--bg2), var(--bg0));
      overflow:hidden;
      overscroll-behavior:none;
      touch-action:none;
    }

    /* subtle film grain */
    body::before{
      content:"";
      position:fixed; inset:0;
      pointer-events:none;
      opacity:.06;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='240' height='240'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='240' height='240' filter='url(%23n)' opacity='.55'/%3E%3C/svg%3E");
      mix-blend-mode:overlay;
    }

    #app{ position:relative; height:100%; width:100%; overflow:hidden; }
    #scene{
      position:absolute; inset:0;
      width:100%; height:100%;
      display:block;
      touch-action:none;
    }

    .hud{
      position:absolute; inset:0;
      pointer-events:none;
      display:flex;
      flex-direction:column;
      justify-content:space-between;
      padding:
        calc(12px + env(safe-area-inset-top))
        calc(12px + env(safe-area-inset-right))
        calc(12px + env(safe-area-inset-bottom))
        calc(12px + env(safe-area-inset-left));
      gap:12px;
      z-index:5;
    }

    .top{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:stretch;
    }

    .chip{
      pointer-events:auto;
      background: linear-gradient(180deg, rgba(14,23,38,.82), rgba(8,11,19,.72));
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 9px 11px;
      font-weight: 900;
      letter-spacing:.2px;
      box-shadow: 0 10px 28px rgba(0,0,0,.26);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      min-width: 128px;
      position:relative;
      overflow:hidden;
    }
    .chip::after{
      content:"";
      position:absolute; inset:-1px;
      border-radius:12px;
      background:
        radial-gradient(160px 70px at 20% 0%, rgba(87,178,255,.20), transparent 60%),
        radial-gradient(140px 70px at 80% 100%, rgba(96,240,161,.12), transparent 60%);
      opacity:.75;
      pointer-events:none;
      mix-blend-mode:screen;
    }
    .chip > *{ position:relative; z-index:1; }

    .chip small{
      display:block;
      color: var(--muted2);
      font-weight: 750;
      letter-spacing:.25px;
      margin-bottom:2px;
    }
    .big{ font-size: 24px; font-weight: 950; }

    .board{
      pointer-events:auto;
      background: linear-gradient(180deg, rgba(8,11,19,.90), rgba(14,23,38,.74));
      border: 1px solid var(--line);
      border-radius: var(--r);
      padding: 12px;
      max-width: 660px;
      max-height: 54vh;
      overflow:auto;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    .board h3{
      margin:0 0 10px;
      font-weight: 1000;
      letter-spacing:.2px;
    }

    table{
      width:100%;
      border-collapse:collapse;
      font-size: 13px;
      border-radius: 12px;
      overflow:hidden;
    }
    thead th{
      position:sticky;
      top:0;
      z-index:2;
      background: rgba(10,15,25,.92);
      border-bottom:1px solid var(--line2);
      padding:8px 8px;
      text-align:left;
      color:#dff0ff;
      font-weight:950;
      letter-spacing:.2px;
    }
    tbody td{
      padding:7px 8px;
      border-bottom:1px solid rgba(255,255,255,.06);
      color:#eaf3ff;
      white-space:nowrap;
    }
    tbody tr:nth-child(odd) td{ background: rgba(255,255,255,.02); }
    tbody tr:hover td{ background: rgba(87,178,255,.06); }

    .youRow td{
      background: rgba(96,240,161,.06) !important;
      border-bottom: 1px solid rgba(96,240,161,.12);
    }

    .msg{
      font-size: 13px;
      color: var(--muted);
      margin-top: 10px;
      line-height:1.35;
    }

    .tags{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      margin-top:10px;
    }
    .tag{
      font-size: 12px;
      padding: 5px 9px;
      border-radius:999px;
      border:1px solid rgba(87,178,255,.22);
      background: rgba(87,178,255,.08);
      color: #cfe7ff;
      font-weight:850;
      letter-spacing:.15px;
    }

    /* Overlay modal */
    .modalWrap{
      position:absolute; inset:0;
      background: radial-gradient(900px 700px at 50% 10%, rgba(87,178,255,.14), transparent 55%),
                  rgba(3,6,12,.72);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      z-index:20;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }
    .modalWrap.show{ display:flex; }
    .modal{
      pointer-events:auto;
      background: linear-gradient(180deg, rgba(14,23,38,.92), rgba(8,11,19,.86));
      border:1px solid rgba(87,178,255,.28);
      border-radius: 18px;
      max-width: 820px;
      width: min(820px, 95vw);
      padding: 16px 16px 14px;
      box-shadow: 0 26px 90px rgba(0,0,0,.55);
      animation: pop .14s ease-out;
      position:relative;
      overflow:hidden;
    }
    .modal::before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(380px 180px at 20% 0%, rgba(87,178,255,.20), transparent 60%),
        radial-gradient(320px 160px at 80% 100%, rgba(255,111,137,.14), transparent 60%);
      opacity:.7;
      pointer-events:none;
      mix-blend-mode:screen;
    }
    .modal > *{ position:relative; z-index:1; }
    @keyframes pop{
      from{ transform: translateY(8px) scale(.985); opacity:.0; }
      to  { transform: translateY(0) scale(1); opacity:1; }
    }
    .modal h2{ margin:0 0 8px; font-weight: 1050; letter-spacing:.2px; }
    .modal p{ margin:6px 0; color: var(--muted); line-height:1.35; }

    .btns{ display:flex; flex-wrap:wrap; gap:10px; margin-top:12px; }

    button{
      cursor:pointer;
      border: 1px solid rgba(87,178,255,.32);
      background: linear-gradient(180deg, rgba(29,75,128,.92), rgba(20,55,98,.92));
      color:#fff;
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 950;
      letter-spacing:.2px;
      box-shadow: 0 10px 24px rgba(0,0,0,.22);
      transition: transform .08s ease, filter .08s ease, opacity .08s ease;
      user-select:none;
    }
    button:hover{ filter: brightness(1.07); }
    button:active{ transform: translateY(1px); }
    button.ghost{
      background: linear-gradient(180deg, rgba(24,33,51,.86), rgba(18,25,40,.86));
      border-color: rgba(255,255,255,.14);
    }
    button.warn{
      background: linear-gradient(180deg, rgba(109,79,18,.92), rgba(84,58,12,.92));
      border-color: rgba(255,217,114,.35);
    }
    button:disabled{ opacity:.55; cursor:not-allowed; filter:none; transform:none; }

    /* Mobile controls */
    .controls{
      position:absolute;
      inset:auto 0 calc(10px + env(safe-area-inset-bottom)) 0;
      display:none;
      justify-content:space-between;
      padding:0 10px;
      z-index:8;
      pointer-events:none;
    }
    .pad,.boost{
      pointer-events:auto;
      background: rgba(8,14,24,.70);
      border: 1px solid rgba(87,178,255,.28);
      border-radius: 16px;
      touch-action:none;
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .pad{
      width:150px;height:150px;
      position:relative;
    }
    .pad::after{
      content:"";
      position:absolute; inset:10px;
      border-radius: 14px;
      border: 1px dashed rgba(255,255,255,.10);
      opacity:.55;
      pointer-events:none;
    }
    .padDot{
      position:absolute;
      width:26px;height:26px;
      border-radius:50%;
      background: radial-gradient(circle at 30% 30%, #bfe6ff, #2e8dff);
      left:62px; top:62px;
      pointer-events:none;
      box-shadow: 0 0 18px rgba(87,178,255,.55);
    }

    .boost{
      width:120px;height:120px;
      display:grid;
      place-items:center;
      font-weight:1050;
      letter-spacing:.5px;
      text-transform:uppercase;
    }
    .boost.onCd{
      background: rgba(45,18,18,.80);
      border-color: rgba(255,111,137,.36);
    }

    .mobileFsBtn{
      position:absolute;
      right:10px;
      top: calc(10px + env(safe-area-inset-top));
      z-index:12;
      display:none;
      padding: 9px 12px;
      border-radius: 12px;
      background: rgba(8,14,24,.74);
      border: 1px solid rgba(87,178,255,.28);
      color:#fff;
      font-weight: 900;
      letter-spacing:.2px;
      box-shadow: 0 12px 34px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .mobileFsBtn.show{ display:block; }

    @media (max-width:920px){
      .controls{ display:flex; pointer-events:auto; }
    }

    /* ‚úÖ Hide UI until AFTER the full 3-lap series finishes (except lap timer chip) */
    body.uiMinimal .top .chip:not(#lapChip){ display:none; }
    body.uiMinimal .board{ display:none; }
  </style>
</head>

<body class="uiMinimal">
<div id="app">
  <canvas id="scene"></canvas>
  <button id="mobileFsBtn" class="mobileFsBtn" type="button">‚õ∂ Fullscreen</button>

  <div class="hud">
    <div class="top">
      <div class="chip" id="lapChip"><small>Lap Timer</small><span class="big" id="lapTimer">00.000</span></div>
      <div class="chip"><small>Status</small><span id="statusText">Connecting‚Ä¶</span></div>
      <div class="chip"><small>Lap</small><span id="lapText">‚Äî</span></div>
      <div class="chip"><small>Players</small><span id="playersText">‚Äî</span></div>
      <div class="chip"><small>Boost</small><span id="boostText">Ready</span></div>
      <div class="chip"><small>Room</small><span id="roomText">‚Äî</span></div>
    </div>

    <div class="board">
      <h3>üèÅ Final Results (Avg Wins)</h3>
      <table>
        <thead><tr><th>Player</th><th>L1</th><th>L2</th><th>L3</th><th>Avg</th><th>Note</th></tr></thead>
        <tbody id="scoreRows"></tbody>
      </table>
      <div class="tags" id="tags"></div>
      <div class="msg" id="msg">‚Äî</div>
    </div>
  </div>

  <div class="controls">
    <div class="pad" id="pad"><div class="padDot" id="padDot"></div></div>
    <button class="boost" id="boostBtn" type="button">BOOST</button>
  </div>

  <div class="modalWrap show" id="overlay">
    <div class="modal">
      <h2 id="overlayTitle">StockKings ‚Äî Donut Rush</h2>
      <p id="overlayBody">Connecting‚Ä¶</p>
      <div class="btns" id="overlayButtons"></div>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.162/build/three.module.js";
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getAuth, signInAnonymously, onAuthStateChanged, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
import { getFirestore, doc, onSnapshot, runTransaction, setDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

/* ============================================================
   FIREBASE INIT
============================================================ */
const firebaseConfig={
  apiKey:"AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain:"bible-game-246c0.firebaseapp.com",
  projectId:"bible-game-246c0",
  storageBucket:"bible-game-246c0.appspot.com",
  messagingSenderId:"959619818996",
  appId:"1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app=initializeApp(firebaseConfig);
const auth=getAuth(app);
const db=getFirestore(app);

/* ============================================================
   URL + LOCAL STORAGE
============================================================ */
const LS_USER="gh.username";
const LS_LOBBY="gh.lastLobbyId";
const params=new URLSearchParams(location.search);

function randId(){
  return "sk-" + Math.random().toString(36).slice(2,8) + "-" + Math.random().toString(36).slice(2,6);
}

let gameId=(params.get("gameId")||localStorage.getItem(LS_LOBBY)||"").trim();
let username=(params.get("username")||localStorage.getItem(LS_USER)||"Racer").trim();

if(!gameId){
  gameId = randId();
  params.set("gameId", gameId);
  history.replaceState(null, "", `${location.pathname}?${params.toString()}`);
}
if(!username) username="Racer";
localStorage.setItem(LS_LOBBY, gameId);
localStorage.setItem(LS_USER, username);

const RACE_REF = doc(db, "lobbies", gameId, "stockkings", "race");

/* ============================================================
   DOM
============================================================ */
const el=id=>document.getElementById(id);

let overlayKey="";
function showOverlay(key,title,body,buttons){
  overlayKey=key;
  el("overlayTitle").textContent=title;
  el("overlayBody").innerHTML=body;
  const wrap=el("overlayButtons"); wrap.innerHTML="";
  (buttons||[]).forEach(b=>{
    const bt=document.createElement("button");
    bt.textContent=b.label;
    if(b.className) bt.className=b.className;
    if(b.disabled) bt.disabled=true;
    bt.type="button";
    bt.onclick=b.onClick||(()=>{});
    wrap.appendChild(bt);
  });
  el("overlay").classList.add("show");
}
function hideOverlay(){
  overlayKey="";
  el("overlay").classList.remove("show");
}

function isMobile(){ return innerWidth < 920; }

async function requestFullscreen(){
  try{
    const root=document.documentElement;
    if(document.fullscreenElement){
      await document.exitFullscreen?.();
      return;
    }
    await root.requestFullscreen?.();
  }catch(e){}
}
function updateFullscreenBtn(){
  const btn=el("mobileFsBtn");
  if(!btn) return;
  btn.classList.toggle("show", isMobile());
  btn.textContent=document.fullscreenElement?"üóó Exit Fullscreen":"‚õ∂ Fullscreen";
}

/* ============================================================
   AUTH (Anonymous)
============================================================ */
async function ensureAuthed(){
  let signInErr = null;

  try { await setPersistence(auth, browserLocalPersistence); }
  catch(e){ console.warn("setPersistence failed:", e); }

  if(auth.currentUser) return auth.currentUser;

  try{
    await signInAnonymously(auth);
  }catch(e){
    signInErr = e;
    console.error("signInAnonymously failed:", e);
  }

  return await new Promise((resolve, reject)=>{
    const timeout=setTimeout(()=>{
      reject(signInErr || new Error("auth-timeout"));
    }, 10000);

    const unsub=onAuthStateChanged(auth, (u)=>{
      if(u){
        clearTimeout(timeout);
        unsub();
        resolve(u);
      }
    });
  });
}

/* ============================================================
   GAME RULES / THREATS
============================================================ */
const MAX_PLAYERS=8;
const MAX_LAPS=3;
const READY_START_DELAY_MS=1300;
const DEADLINE_MS=30000;
const SELECT_MS=10000;

const OBSTACLES={
  meteorites:{
    name:"Meteorite Strikes",
    desc:"Telegraphed impacts. Big blast + knockback + stun.",
  },
  monsters:{
    name:"Track Monsters",
    desc:"They roam the road. Hit = bounce back.",
  },
  rhinos:{
    name:"Rhino Stampede",
    desc:"Run opposite direction. Hit = stun 3s + shove.",
  },
  towers:{
    name:"Lightning Towers",
    desc:"Every 5s they zap inside their circle. Stun 1s.",
  }
};
const obstacleOrder=["meteorites","monsters","rhinos","towers"];

/* ============================================================
   READY-RACE STATE (3 laps, slowest picks next threat)
============================================================ */
let raceState=null;
let raceUnsub=null;
let pendingTxn=false;
let myUid="";
let offlineMode=false;

const ACTIVE_WINDOW_MS=20000;
const PRESENCE_PING_MS=3500;

function now(){ return Date.now(); }
function avg(nums){
  const v=(nums||[]).filter(n=>typeof n==="number");
  return v.length ? (v.reduce((a,b)=>a+b,0)/v.length) : null;
}
function fmt(n){ return typeof n==="number" ? n.toFixed(2)+"s" : "‚Äî"; }
function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }

function ensurePlayerObj(d, uid, name){
  d.players=d.players||{};
  d.players[uid]=d.players[uid]||{
    uid, name,
    ready:false,
    lastSeenMs:0,
    laps:[],
    avg:null
  };
  d.players[uid].name = name || d.players[uid].name || "Racer";
  if(typeof d.players[uid].ready!=="boolean") d.players[uid].ready=false;
  if(typeof d.players[uid].lastSeenMs!=="number") d.players[uid].lastSeenMs=0;
  d.players[uid].laps = Array.isArray(d.players[uid].laps) ? d.players[uid].laps : [];
  d.players[uid].avg = (typeof d.players[uid].avg==="number") ? d.players[uid].avg : avg(d.players[uid].laps);
}

function pruneParticipants(d){
  const parts = Array.isArray(d.participants) ? d.participants.slice() : [];
  const players = d.players || {};
  const keep = parts.filter(uid => (now() - (players[uid]?.lastSeenMs||0)) < (5*60*1000));
  const uniq=[];
  for(const uid of keep){ if(!uniq.includes(uid)) uniq.push(uid); }
  d.participants = uniq.slice(0, MAX_PLAYERS);
}

function activeParticipants(d){
  pruneParticipants(d);
  const parts = Array.isArray(d.participants) ? d.participants : [];
  const players = d.players || {};
  const t=now();
  const act = parts.filter(uid => (t - (players[uid]?.lastSeenMs||0)) < ACTIVE_WINDOW_MS);
  if(myUid && parts.includes(myUid) && !act.includes(myUid)) act.push(myUid);
  return act.slice(0, MAX_PLAYERS);
}

function roster(d){
  return (Array.isArray(d.roundPlayers) && d.roundPlayers.length)
    ? d.roundPlayers.slice(0, MAX_PLAYERS)
    : activeParticipants(d);
}

function computeSlowestUidForLap(d, lapIdx){
  const r=roster(d);
  const players=d.players||{};
  const entries=r.map(uid=>{
    const t=players[uid]?.laps?.[lapIdx];
    return {uid, t:(typeof t==="number")?t:30};
  });
  const worst=Math.max(...entries.map(e=>e.t));
  const bottoms=entries.filter(e=>e.t===worst);
  return bottoms[Math.floor(Math.random()*bottoms.length)].uid;
}

function computeWinnerUid(d){
  const r = roster(d);
  let bestUid=null, best=1e18;
  for(const uid of r){
    const a = avg(d.players?.[uid]?.laps||[]);
    if(typeof a==="number" && a<best){ best=a; bestUid=uid; }
  }
  return bestUid;
}

async function txn(mutator){
  if(pendingTxn) return;
  pendingTxn=true;
  try{
    await runTransaction(db, async (tx)=>{
      const snap=await tx.get(RACE_REF);
      if(!snap.exists()) return;
      const d=snap.data();
      const out=mutator(d);
      if(!out) return;
      tx.set(RACE_REF, out, {merge:false});
    });
  }catch(e){
    showOverlay("txerr","Sync error",
      `<b>${String(e?.code||"error")}</b><br/>${String(e?.message||e)}`,
      [{label:"Reload", className:"warn", onClick:()=>location.reload()}]
    );
  }finally{
    pendingTxn=false;
  }
}

async function ensureRaceDoc(){
  await runTransaction(db, async (tx)=>{
    const snap=await tx.get(RACE_REF);
    if(snap.exists()) return;
    tx.set(RACE_REF, {
      game:"stockkings-3lap-threatstack",
      phase:"ready",            // ready | countdown | racing | lap_wait | obstacle_select | finished
      participants:[],
      players:{},
      roundPlayers:[],
      lap:1,
      maxLaps:MAX_LAPS,
      obstacles:[],             // stacked types
      obstacleHistory:[],       // [{lap:2,type,chosenByUid}]
      selectorUid:null,
      selectEndsAt:null,
      startAtMs:null,
      deadlineAt:null,
      winnerUid:null,
      updatedAtMs: now(),
      createdAtMs: now()
    }, {merge:false});
  });
}

async function joinRace(){
  await txn((d)=>{
    pruneParticipants(d);
    d.participants = Array.isArray(d.participants) ? d.participants : [];
    if(myUid && !d.participants.includes(myUid)) d.participants.push(myUid);
    d.participants = d.participants.slice(0, MAX_PLAYERS);

    ensurePlayerObj(d, myUid, username);
    d.players[myUid].lastSeenMs = now();
    d.players[myUid].name = username;

    d.updatedAtMs = now();
    return d;
  });
}

async function presencePing(){
  if(!myUid) return;
  try{
    await setDoc(RACE_REF, {
      players: { [myUid]: { name: username, lastSeenMs: now() } }
    }, {merge:true});
  }catch(e){
    console.warn("presencePing failed:", e);
  }
}

async function setMyReady(ready){
  await txn((d)=>{
    if(!["ready","countdown"].includes(d.phase)) return null;

    pruneParticipants(d);
    d.participants = Array.isArray(d.participants) ? d.participants : [];
    if(myUid && !d.participants.includes(myUid)) d.participants.push(myUid);
    d.participants = d.participants.slice(0, MAX_PLAYERS);

    ensurePlayerObj(d, myUid, username);
    d.players[myUid].ready = !!ready;
    d.players[myUid].lastSeenMs = now();
    d.players[myUid].name = username;

    // If someone unreadies during countdown, revert to ready
    if(d.phase==="countdown"){
      d.phase="ready";
      d.startAtMs=null;
      d.deadlineAt=null;
      d.roundPlayers=[];
      d.lap=1;
      d.selectorUid=null;
      d.selectEndsAt=null;
      d.obstacles=[];
      d.obstacleHistory=[];
      d.winnerUid=null;
      // keep laps but they won't matter; we reset on start
    }

    d.updatedAtMs=now();
    return d;
  });
}

async function maybeStartIfAllReady(){
  await txn((d)=>{
    if(d.phase!=="ready") return null;

    const act = activeParticipants(d);
    if(!act.length) return null;

    act.forEach(uid=>ensurePlayerObj(d, uid, d.players?.[uid]?.name||"Racer"));
    const allReady = act.every(uid=>!!d.players?.[uid]?.ready);
    if(!allReady) return null;

    d.roundPlayers = act.slice(0, MAX_PLAYERS);

    // reset laps + avg
    d.roundPlayers.forEach(uid=>{
      ensurePlayerObj(d, uid, d.players?.[uid]?.name||"Racer");
      d.players[uid].laps = [];
      d.players[uid].avg = null;
    });

    d.lap=1;
    d.obstacles=[];
    d.obstacleHistory=[];
    d.selectorUid=null;
    d.selectEndsAt=null;
    d.winnerUid=null;

    d.phase="countdown";
    d.startAtMs = now() + READY_START_DELAY_MS;
    d.deadlineAt = d.startAtMs + DEADLINE_MS;

    d.updatedAtMs = now();
    return d;
  });
}

async function maybeFlipCountdownToRacing(){
  await txn((d)=>{
    if(d.phase!=="countdown") return null;
    if(!d.startAtMs) return null;
    if(now() < d.startAtMs) return null;
    d.phase="racing";
    d.updatedAtMs=now();
    return d;
  });
}

async function ensureDeadlineIfNeeded(){
  await txn((d)=>{
    if(d.phase!=="racing") return null;
    if(d.deadlineAt) return null;
    d.deadlineAt = (d.startAtMs||now()) + DEADLINE_MS;
    d.updatedAtMs=now();
    return d;
  });
}

async function submitLap(timeSec){
  await txn((d)=>{
    if(!(d.phase==="racing" || d.phase==="lap_wait")) return null;

    const lap = (d.lap||1);
    const lapIdx = lap-1;

    const r = roster(d);
    ensurePlayerObj(d, myUid, username);
    if(!r.includes(myUid)) return null;

    // deadline lockout
    if(d.deadlineAt && now() > d.deadlineAt) return null;

    const me=d.players[myUid];
    me.laps = Array.isArray(me.laps) ? me.laps : [];
    if(typeof me.laps[lapIdx] === "number") return null;

    const t = clamp(timeSec, 0.5, 30);
    me.laps[lapIdx]=t;
    me.avg = avg(me.laps);
    me.lastSeenMs = now();

    // if first finisher, go into lap_wait with hard deadline
    const anyFinished = r.some(uid=>typeof d.players?.[uid]?.laps?.[lapIdx]==="number");
    if(anyFinished && !d.deadlineAt){
      d.phase="lap_wait";
      d.deadlineAt = now() + DEADLINE_MS;
    }

    const everyoneDone = r.every(uid=>typeof d.players?.[uid]?.laps?.[lapIdx]==="number");
    if(everyoneDone){
      // move to obstacle select or finished
      if(lap >= (d.maxLaps||MAX_LAPS)){
        d.phase="finished";
        d.winnerUid = computeWinnerUid(d);
        d.updatedAtMs=now();
        return d;
      }

      d.phase="obstacle_select";
      d.selectorUid = computeSlowestUidForLap(d, lapIdx);
      d.selectEndsAt = now() + SELECT_MS;
      d.deadlineAt = null;
      d.updatedAtMs=now();
      return d;
    }

    d.updatedAtMs=now();
    return d;
  });
}

async function finalizeDeadlineIfNeeded(){
  await txn((d)=>{
    if(!(d.phase==="lap_wait" || d.phase==="racing")) return null;
    if(!d.deadlineAt) return null;
    if(now() < d.deadlineAt) return null;

    const lap = (d.lap||1);
    const lapIdx = lap-1;
    const r = roster(d);
    d.players=d.players||{};
    r.forEach(uid=>{
      ensurePlayerObj(d, uid, d.players?.[uid]?.name||"Racer");
      const p=d.players[uid];
      p.laps = Array.isArray(p.laps) ? p.laps : [];
      if(typeof p.laps[lapIdx] !== "number") p.laps[lapIdx]=30;
      p.avg = avg(p.laps);
    });

    // advance
    if(lap >= (d.maxLaps||MAX_LAPS)){
      d.phase="finished";
      d.winnerUid = computeWinnerUid(d);
      d.updatedAtMs=now();
      return d;
    }

    d.phase="obstacle_select";
    d.selectorUid = computeSlowestUidForLap(d, lapIdx);
    d.selectEndsAt = now() + SELECT_MS;
    d.deadlineAt = null;
    d.updatedAtMs=now();
    return d;
  });
}

function pickRandomObstacle(d){
  const all=obstacleOrder;
  // prefer unused first, then anything (stack can repeat if you want)
  const used=Array.isArray(d.obstacles)?d.obstacles:[];
  const avail=all.filter(o=>!used.includes(o));
  const pool = avail.length ? avail : all;
  return pool[Math.floor(Math.random()*pool.length)];
}

async function chooseObstacle(type=null, auto=false){
  await txn((d)=>{
    if(d.phase!=="obstacle_select") return null;
    const lap = (d.lap||1);
    const nextLap = lap+1;

    const r=roster(d);
    const single = r.length<=1;
    const canPick = single || auto || (d.selectorUid===myUid);
    if(!canPick) return null;

    const all=obstacleOrder;
    let pick=(type && all.includes(type))?type:null;
    if(!pick) pick=pickRandomObstacle(d);

    d.obstacles = Array.isArray(d.obstacles) ? d.obstacles.slice() : [];
    d.obstacles.push(pick); // stack

    d.obstacleHistory = Array.isArray(d.obstacleHistory) ? d.obstacleHistory.slice() : [];
    d.obstacleHistory.push({lap: nextLap, type: pick, chosenByUid: (auto ? "auto" : d.selectorUid)});

    d.lap = nextLap;
    d.phase="countdown";
    d.startAtMs = now() + READY_START_DELAY_MS;
    d.deadlineAt = d.startAtMs + DEADLINE_MS;

    d.selectorUid=null;
    d.selectEndsAt=null;
    d.updatedAtMs=now();
    return d;
  });
}

async function autoPickIfNeeded(){
  if(!raceState) return;
  if(raceState.phase!=="obstacle_select") return;

  const t=now();
  if(raceState.selectEndsAt && t >= raceState.selectEndsAt){
    await chooseObstacle(null, true);
  }
}

async function rematch(){
  await txn((d)=>{
    pruneParticipants(d);
    d.phase="ready";
    d.startAtMs=null;
    d.deadlineAt=null;
    d.roundPlayers=[];
    d.lap=1;
    d.maxLaps=MAX_LAPS;
    d.obstacles=[];
    d.obstacleHistory=[];
    d.selectorUid=null;
    d.selectEndsAt=null;
    d.winnerUid=null;

    d.players=d.players||{};
    (d.participants||[]).forEach(uid=>{
      ensurePlayerObj(d, uid, d.players?.[uid]?.name||"Racer");
      d.players[uid].ready=false;
      d.players[uid].laps=[];
      d.players[uid].avg=null;
    });

    ensurePlayerObj(d, myUid, username);
    d.players[myUid].lastSeenMs=now();
    d.updatedAtMs=now();
    return d;
  });
}

function attachRaceListener(){
  if(raceUnsub) raceUnsub();
  raceUnsub = onSnapshot(
    RACE_REF,
    (snap)=>{
      try{
        if(!snap.exists()){ raceState=null; return; }
        const prevSig = JSON.stringify(raceState?.obstacles||[]);
        const prevLap = raceState?.lap||1;
        raceState=snap.data();
        const nextSig = JSON.stringify(raceState?.obstacles||[]);
        const nextLap = raceState?.lap||1;
        if(nextSig!==prevSig || nextLap!==prevLap){
          spawnThreats(); // visuals update when stacking changes or lap changes
        }
      }catch(e){
        console.error("snapshot error:", e);
      }
    },
    (err)=>{
      showOverlay("raceErr","Sync error",
        `<b>${String(err?.code||"error")}</b><br/>${String(err?.message||err)}<br/><br/>
         Ensure Anonymous Auth is enabled.`,
        [{label:"Reload", className:"warn", onClick:()=>location.reload()}]
      );
    }
  );
}

/* ============================================================
   THREE WORLD (spectacular FX)
============================================================ */
const renderer=new THREE.WebGLRenderer({canvas:el("scene"), antialias:true, alpha:true});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.10;

const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(62,1,0.1,1400);

function makeCanvasTexture(drawFn, w=512, h=512){
  const c=document.createElement("canvas");
  c.width=w; c.height=h;
  const g=c.getContext("2d");
  drawFn(g,w,h);
  const tex=new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy?.()||8);
  return tex;
}

const skyTex = makeCanvasTexture((g,w,h)=>{
  const grd=g.createLinearGradient(0,0,0,h);
  grd.addColorStop(0, "#93d8ff");
  grd.addColorStop(.45, "#69b8ff");
  grd.addColorStop(1, "#2a5c9b");
  g.fillStyle=grd; g.fillRect(0,0,w,h);
  for(let i=0;i<80;i++){
    const x=Math.random()*w, y=Math.random()*h*0.55;
    const r=30+Math.random()*110;
    const a=.03+Math.random()*.07;
    const rg=g.createRadialGradient(x,y,0,x,y,r);
    rg.addColorStop(0, `rgba(255,255,255,${a})`);
    rg.addColorStop(1, "rgba(255,255,255,0)");
    g.fillStyle=rg;
    g.beginPath(); g.arc(x,y,r,0,Math.PI*2); g.fill();
  }
}, 1024, 1024);
scene.background = skyTex;

scene.fog = new THREE.FogExp2(0x6aaef5, 0.009);

scene.add(new THREE.HemisphereLight(0xd8f1ff, 0x1e4a2b, 1.05));
const sun=new THREE.DirectionalLight(0xffffff, 1.05);
sun.position.set(30, 55, 25);
scene.add(sun);

const glowLight = new THREE.PointLight(0x6fd1ff, 0.45, 280, 2.0);
glowLight.position.set(0, 28, 0);
scene.add(glowLight);

const grassTex = makeCanvasTexture((g,w,h)=>{
  g.fillStyle="#2f8d44"; g.fillRect(0,0,w,h);
  for(let i=0;i<14000;i++){
    const x=(Math.random()*w)|0, y=(Math.random()*h)|0;
    const v=40+Math.random()*60;
    g.fillStyle=`rgba(${10+v/3|0},${110+v|0},${30+v/4|0},${.08+Math.random()*.14})`;
    g.fillRect(x,y,1,1);
  }
  g.globalAlpha=.08;
  for(let y=0;y<h;y+=20){
    g.fillStyle = (y/20)%2 ? "#000" : "#fff";
    g.fillRect(0,y,w,10);
  }
  g.globalAlpha=1;
}, 768, 768);
grassTex.repeat.set(4,4);

const ground=new THREE.Mesh(
  new THREE.PlaneGeometry(420,420),
  new THREE.MeshStandardMaterial({map:grassTex, roughness:.98, metalness:0})
);
ground.rotation.x=-Math.PI/2;
scene.add(ground);

const roadTex = makeCanvasTexture((g,w,h)=>{
  g.fillStyle="#8a5d30"; g.fillRect(0,0,w,h);
  for(let i=0;i<16000;i++){
    const x=(Math.random()*w)|0, y=(Math.random()*h)|0;
    const v=120+Math.random()*90;
    g.fillStyle=`rgba(${v|0},${(v*0.72)|0},${(v*0.40)|0},${.08+Math.random()*.14})`;
    g.fillRect(x,y,1,1);
  }
  // subtle stripe
  g.globalAlpha=.10;
  g.fillStyle="#ffffff";
  g.fillRect(0, h*0.49, w, h*0.02);
  g.globalAlpha=1;

  // sparkly flecks
  for(let i=0;i<350;i++){
    const x=Math.random()*w, y=Math.random()*h;
    const a=.06+Math.random()*.10;
    g.fillStyle=`rgba(255,255,255,${a})`;
    g.fillRect(x,y,1,1);
  }
}, 768, 768);
roadTex.repeat.set(2, 2);

const ROAD_R = 52;
const ROAD_W = 34;
const INNER_R = ROAD_R - ROAD_W/2;
const OUTER_R = ROAD_R + ROAD_W/2;

const road = new THREE.Mesh(
  new THREE.RingGeometry(INNER_R, OUTER_R, 220, 1),
  new THREE.MeshStandardMaterial({map:roadTex, roughness:.86, metalness:.05})
);
road.rotation.x=-Math.PI/2;
road.position.y=0.02;
scene.add(road);

// luminous edge rings
const edgeMat = new THREE.MeshBasicMaterial({color:0x7bd7ff, transparent:true, opacity:0.14, side:THREE.DoubleSide});
const innerEdge = new THREE.Mesh(new THREE.RingGeometry(INNER_R-0.20, INNER_R+0.15, 240, 1), edgeMat);
const outerEdge = new THREE.Mesh(new THREE.RingGeometry(OUTER_R-0.15, OUTER_R+0.20, 240, 1), edgeMat);
innerEdge.rotation.x=-Math.PI/2; outerEdge.rotation.x=-Math.PI/2;
innerEdge.position.y=0.028; outerEdge.position.y=0.028;
scene.add(innerEdge, outerEdge);

// center stripe
const stripe = new THREE.Mesh(
  new THREE.RingGeometry(ROAD_R-0.45, ROAD_R+0.45, 240, 1),
  new THREE.MeshBasicMaterial({color:0xe9f2ff, transparent:true, opacity:0.46})
);
stripe.rotation.x=-Math.PI/2;
stripe.position.y=0.03;
scene.add(stripe);

// walls
function wallCylinder(radius, color){
  const m=new THREE.Mesh(
    new THREE.CylinderGeometry(radius, radius, 2.1, 220, 1, true),
    new THREE.MeshStandardMaterial({color, roughness:.74, metalness:.10, side:THREE.DoubleSide, emissive:0x071524, emissiveIntensity:0.25})
  );
  m.position.y=1.05;
  return m;
}
scene.add(wallCylinder(INNER_R, 0x2e3a4d), wallCylinder(OUTER_R, 0x2e3a4d));

// start line
const startLine = new THREE.Mesh(
  new THREE.PlaneGeometry(ROAD_W, 3.0),
  new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.62, side:THREE.DoubleSide})
);
startLine.rotation.x=-Math.PI/2;
startLine.position.set(ROAD_R, 0.031, 0);
startLine.rotation.z=Math.PI/2;
scene.add(startLine);

/* ============================================================
   CAR
============================================================ */
function buildCar(){
  const g=new THREE.Group();
  const body=new THREE.Mesh(
    new THREE.BoxGeometry(2.4,.85,3.8),
    new THREE.MeshStandardMaterial({color:0x1f74ff, metalness:.32, roughness:.28, emissive:0x0b1a2e, emissiveIntensity:0.15})
  );
  body.position.y=.9;
  const top=new THREE.Mesh(
    new THREE.BoxGeometry(1.6,.65,1.7),
    new THREE.MeshStandardMaterial({color:0xd8e8ff, metalness:.08, roughness:.36, emissive:0x111b2b, emissiveIntensity:0.12})
  );
  top.position.set(0,1.38,-.15);
  g.add(body, top);

  [[-.9,.35,-1.15],[.9,.35,-1.15],[-.9,.35,1.15],[.9,.35,1.15]].forEach(([x,y,z])=>{
    const w=new THREE.Mesh(
      new THREE.CylinderGeometry(.40,.40,.36,18),
      new THREE.MeshStandardMaterial({color:0x101218, roughness:.92, metalness:.05})
    );
    w.rotation.z=Math.PI/2;
    w.position.set(x,y,z);
    g.add(w);
  });

  const flameMat=new THREE.MeshBasicMaterial({color:0xff7a22, transparent:true, opacity:.94});
  const flame=new THREE.Mesh(new THREE.ConeGeometry(.26,1.28,12), flameMat);
  flame.position.set(0,.9,2.3);
  flame.rotation.x=Math.PI/2;
  g.add(flame);
  g.flame=flame; g.flameMat=flameMat;

  // underglow
  const under=new THREE.Mesh(
    new THREE.RingGeometry(0.5, 1.65, 32),
    new THREE.MeshBasicMaterial({color:0x3bd7ff, transparent:true, opacity:0.20, side:THREE.DoubleSide})
  );
  under.rotation.x=-Math.PI/2;
  under.position.y=0.07;
  g.add(under);
  g.under=under;

  g.scale.set(0.76,0.76,0.76);
  return g;
}
const car=buildCar();
scene.add(car);

const START_A=0;
function setCarAtStart(){
  const x=Math.cos(START_A)*ROAD_R;
  const z=Math.sin(START_A)*ROAD_R;
  car.position.set(x,0.1,z);
  car.rotation.set(0,0,0);
  car.rotation.y = Math.PI;
}
setCarAtStart();

/* ============================================================
   TRACK HELPERS
============================================================ */
const CAR_R=1.05;

function normAngle(a){
  const two=Math.PI*2;
  a%=two; if(a<0) a+=two;
  return a;
}
const startTheta = normAngle(START_A);

function roadInfo(x,z){
  const r=Math.hypot(x,z);
  const onRoad = (r>INNER_R+0.25 && r<OUTER_R-0.25);
  return {r,onRoad};
}

function enforceWalls(){
  const r=Math.hypot(car.position.x, car.position.z) || 0.0001;
  const nx=car.position.x/r;
  const nz=car.position.z/r;

  const minR = INNER_R + CAR_R;
  if(r < minR){
    car.position.x = nx*minR;
    car.position.z = nz*minR;
    return true;
  }
  const maxR = OUTER_R - CAR_R;
  if(r > maxR){
    car.position.x = nx*maxR;
    car.position.z = nz*maxR;
    return true;
  }
  return false;
}

/* ============================================================
   SPECTACULAR FX (shockwaves, sparks, lightning)
============================================================ */
const shockwaves=[];
const sparks=[];
const boltFX=[];
const impactLights=[];
let shake=0;

function addShockwave(pos, color=0xffffff, life=0.65, startR=0.4, endR=8.0, opacity=0.70){
  const mesh=new THREE.Mesh(
    new THREE.RingGeometry(startR, startR+0.55, 64),
    new THREE.MeshBasicMaterial({color, transparent:true, opacity, side:THREE.DoubleSide, depthWrite:false})
  );
  mesh.rotation.x=-Math.PI/2;
  mesh.position.set(pos.x, 0.07, pos.z);
  scene.add(mesh);
  shockwaves.push({mesh, life, t:0, startR, endR, opacity});
}

function addSparks(pos, color=0xffe3a0, count=38, speed=12, life=0.75){
  const mat=new THREE.MeshBasicMaterial({color, transparent:true, opacity:0.9, depthWrite:false});
  for(let i=0;i<count;i++){
    const m=new THREE.Mesh(new THREE.SphereGeometry(0.08 + Math.random()*0.08, 8, 6), mat.clone());
    const a=Math.random()*Math.PI*2;
    const up=0.3+Math.random()*1.3;
    const v=new THREE.Vector3(Math.cos(a), up, Math.sin(a)).multiplyScalar(speed*(0.35+Math.random()*0.9));
    m.position.set(pos.x, 0.25, pos.z);
    scene.add(m);
    sparks.push({m, v, life, t:0});
  }
}

function addImpactLight(pos, color=0xffd188, intensity=3.2, dist=55, life=0.35){
  const l=new THREE.PointLight(color, intensity, dist, 2.0);
  l.position.set(pos.x, 5.5, pos.z);
  scene.add(l);
  impactLights.push({l, life, t:0, intensity});
}

function addLightningBolt(from, to, color=0x9ec9ff, life=0.22){
  const segs=10;
  const pts=[];
  for(let i=0;i<=segs;i++){
    const t=i/segs;
    const p=new THREE.Vector3().lerpVectors(from, to, t);
    const j=(1-t)*(0.55);
    p.x += (Math.random()-.5)*j;
    p.z += (Math.random()-.5)*j;
    pts.push(p);
  }
  const geom=new THREE.BufferGeometry().setFromPoints(pts);
  const mat=new THREE.LineBasicMaterial({color, transparent:true, opacity:0.95, depthWrite:false});
  const line=new THREE.Line(geom, mat);
  scene.add(line);
  boltFX.push({line, life, t:0});
}

function updateFX(dt){
  for(let i=shockwaves.length-1;i>=0;i--){
    const s=shockwaves[i];
    s.t += dt;
    const k = s.t / s.life;
    const r = s.startR + (s.endR - s.startR)*k;
    const inner = Math.max(0.01, r);
    const outer = inner + (0.75*(1-k) + 0.15);
    s.mesh.geometry.dispose();
    s.mesh.geometry = new THREE.RingGeometry(inner, outer, 64);
    s.mesh.material.opacity = s.opacity * (1-k);
    if(k>=1){
      scene.remove(s.mesh);
      shockwaves.splice(i,1);
    }
  }

  for(let i=sparks.length-1;i>=0;i--){
    const sp=sparks[i];
    sp.t += dt;
    sp.v.y -= 18*dt;
    sp.m.position.addScaledVector(sp.v, dt);
    sp.m.material.opacity = Math.max(0, 1 - (sp.t/sp.life));
    if(sp.t>=sp.life){
      scene.remove(sp.m);
      sparks.splice(i,1);
    }
  }

  for(let i=boltFX.length-1;i>=0;i--){
    const b=boltFX[i];
    b.t += dt;
    b.line.material.opacity = Math.max(0, 1 - (b.t/b.life));
    if(b.t>=b.life){
      scene.remove(b.line);
      boltFX.splice(i,1);
    }
  }

  for(let i=impactLights.length-1;i>=0;i--){
    const it=impactLights[i];
    it.t += dt;
    it.l.intensity = it.intensity * Math.max(0, 1 - (it.t/it.life));
    if(it.t>=it.life){
      scene.remove(it.l);
      impactLights.splice(i,1);
    }
  }

  shake = Math.max(0, shake - dt*1.8);
}

/* ============================================================
   THREATS (stacked)
============================================================ */
const threats=[];

function clearThreats(){
  threats.splice(0).forEach(t=>scene.remove(t.root));
}

function spawnThreats(){
  clearThreats();

  const active = (raceState?.obstacles||[]).slice();
  if(!active.length) return;

  // deterministic-ish seeding based on room + lap + active signature
  const seedStr = gameId + "|" + (raceState?.lap||1) + "|" + JSON.stringify(active);
  let seed=2166136261>>>0;
  for(let i=0;i<seedStr.length;i++){ seed ^= seedStr.charCodeAt(i); seed = Math.imul(seed,16777619); }
  function rnd(){
    seed = (seed + 0x6D2B79F5)|0;
    let t = seed;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }

  const pickR = ()=> (INNER_R+4) + rnd()*(ROAD_W-8);
  const pickA = ()=> rnd()*Math.PI*2;

  // Each stacked obstacle adds more instances
  active.forEach((type, stackIdx)=>{
    if(type==="meteorites"){
      const count = 2 + stackIdx; // grows with stack
      for(let i=0;i<count;i++){
        const a=pickA();
        const r=pickR();
        const x=Math.cos(a)*r;
        const z=Math.sin(a)*r;

        const root=new THREE.Group();

        const warnRing=new THREE.Mesh(
          new THREE.RingGeometry(0.6, 0.95, 42),
          new THREE.MeshBasicMaterial({color:0xffc266, transparent:true, opacity:0.0, side:THREE.DoubleSide, depthWrite:false})
        );
        warnRing.rotation.x=-Math.PI/2;
        warnRing.position.set(0,0.06,0);

        const pillar=new THREE.Mesh(
          new THREE.CylinderGeometry(0.10,0.10,9.0,10),
          new THREE.MeshBasicMaterial({color:0xffc266, transparent:true, opacity:0.0, depthWrite:false})
        );
        pillar.position.set(0,4.5,0);

        root.position.set(x,0,z);
        root.add(warnRing, pillar);
        scene.add(root);

        threats.push({
          type, root,
          pos:new THREE.Vector3(x,0,z),
          warnRing, pillar,
          state:"idle",
          t: 0,
          next: 2.0 + rnd()*2.2,     // time to telegraph
          tele: 2.2 + rnd()*1.0,     // telegraph duration
          hot: 0,                    // explosion hot window
          blastR: 6.5 + stackIdx*0.6,
          hitCd: 0
        });
      }
    }

    if(type==="towers"){
      const count = 2 + Math.min(2, stackIdx);
      for(let i=0;i<count;i++){
        const a=pickA();
        const r=ROAD_R + (rnd()-.5)*(ROAD_W*0.26);
        const x=Math.cos(a)*r;
        const z=Math.sin(a)*r;

        const root=new THREE.Group();

        const base=new THREE.Mesh(
          new THREE.CylinderGeometry(0.7,1.0,4.8,10),
          new THREE.MeshStandardMaterial({color:0x3e4b63, roughness:.84, metalness:.10, emissive:0x081427, emissiveIntensity:0.35})
        );
        base.position.y=2.4;

        const core=new THREE.Mesh(
          new THREE.SphereGeometry(0.30, 14, 10),
          new THREE.MeshBasicMaterial({color:0xbfe0ff})
        );
        core.position.y=4.85;

        const ring=new THREE.Mesh(
          new THREE.RingGeometry(6.0, 6.45, 72),
          new THREE.MeshBasicMaterial({color:0x9ec9ff, transparent:true, opacity:0.26, side:THREE.DoubleSide, depthWrite:false})
        );
        ring.rotation.x=-Math.PI/2;
        ring.position.y=0.06;

        const halo=new THREE.Mesh(
          new THREE.RingGeometry(0.55, 1.35, 48),
          new THREE.MeshBasicMaterial({color:0x9ec9ff, transparent:true, opacity:0.55, side:THREE.DoubleSide, depthWrite:false})
        );
        halo.rotation.x=-Math.PI/2;
        halo.position.y=4.9;

        root.position.set(x,0,z);
        root.add(base, ring, core, halo);
        scene.add(root);

        threats.push({
          type, root,
          ring, core, halo,
          pos:new THREE.Vector3(x,0,z),
          rad: 6.2,
          cd: 2.0 + rnd()*2.2,
          fireEvery: 5.0,
          flash: 0,
          hitCd: 0
        });
      }
    }

    if(type==="monsters"){
      const count = 2 + Math.min(2, stackIdx);
      for(let i=0;i<count;i++){
        const a=pickA();
        const r=pickR();
        const x=Math.cos(a)*r, z=Math.sin(a)*r;

        const root=new THREE.Group();

        const body=new THREE.Mesh(
          new THREE.DodecahedronGeometry(1.05, 0),
          new THREE.MeshStandardMaterial({color:0x6f32a8, roughness:.58, metalness:.10, emissive:0x24093f, emissiveIntensity:0.55})
        );
        body.position.y=1.05;

        const eye=new THREE.Mesh(
          new THREE.SphereGeometry(0.18, 12, 10),
          new THREE.MeshBasicMaterial({color:0xff6f89})
        );
        eye.position.set(0.35,1.25,0.75);

        const aura=new THREE.Mesh(
          new THREE.RingGeometry(0.9, 1.8, 42),
          new THREE.MeshBasicMaterial({color:0xc07cff, transparent:true, opacity:0.22, side:THREE.DoubleSide, depthWrite:false})
        );
        aura.rotation.x=-Math.PI/2;
        aura.position.y=0.06;

        root.add(body, eye, aura);
        root.position.set(x,0,z);
        scene.add(root);

        threats.push({
          type, root,
          a, r,
          da: (rnd()>.5?1:-1) * (0.55 + rnd()*0.9),
          dr: (rnd()>.5?1:-1) * (0.8 + rnd()*1.4),
          rad: 1.9,
          hitCd: 0
        });
      }
    }

    if(type==="rhinos"){
      const count = 1 + Math.min(2, stackIdx);
      for(let i=0;i<count;i++){
        const a=pickA();
        const r=ROAD_R + (rnd()-.5)*(ROAD_W*0.15);

        const root=new THREE.Group();
        const body=new THREE.Mesh(
          new THREE.BoxGeometry(2.6,1.4,3.6),
          new THREE.MeshStandardMaterial({color:0x7b7f86, roughness:.78, metalness:.10, emissive:0x101217, emissiveIntensity:0.20})
        );
        body.position.y=0.9;

        const horn=new THREE.Mesh(
          new THREE.ConeGeometry(0.25, 0.9, 14),
          new THREE.MeshStandardMaterial({color:0xe7eef7, roughness:.35, metalness:.15, emissive:0x0b1020, emissiveIntensity:0.15})
        );
        horn.position.set(0, 1.0, 2.0);
        horn.rotation.x=Math.PI/2;

        const glow=new THREE.Mesh(
          new THREE.RingGeometry(0.8, 2.4, 52),
          new THREE.MeshBasicMaterial({color:0xff6f89, transparent:true, opacity:0.14, side:THREE.DoubleSide, depthWrite:false})
        );
        glow.rotation.x=-Math.PI/2;
        glow.position.y=0.06;

        root.add(body, horn, glow);
        root.position.set(Math.cos(a)*r, 0, Math.sin(a)*r);
        root.rotation.y = -a + Math.PI/2;
        scene.add(root);

        threats.push({
          type, root,
          a, r,
          speed: 1.05 + rnd()*0.65, // radians/sec
          rad: 2.15,
          hitCd: 0
        });
      }
    }
  });
}

function updateThreats(dt){
  updateFX(dt);

  const phase=raceState?.phase;
  const canHit = (phase==="racing") && isRacing && (now() >= raceGoAtMs);

  for(const t of threats){
    t.hitCd = Math.max(0, (t.hitCd||0) - dt);

    if(t.type==="meteorites"){
      t.t += dt;

      // visual: gentle hover shimmer
      t.root.position.y = 0.0 + Math.sin((t.t*2.0) + t.pos.x*0.07)*0.02;

      if(t.state==="idle"){
        t.next -= dt;
        if(t.next<=0){
          t.state="tele";
          t.warnLeft = t.tele;
          t.warnRing.material.opacity = 0.46;
          t.warnRing.material.color.setHex(0xffc266);
          t.pillar.material.opacity = 0.22;
          t.pillar.material.color.setHex(0xffc266);
        }
      }else if(t.state==="tele"){
        t.warnLeft -= dt;
        // pulse ring
        const p = Math.max(0, t.warnLeft / t.tele);
        const pulse = 0.7 + (1-p)*6.0;
        t.warnRing.scale.set(pulse, pulse, pulse);
        t.warnRing.material.opacity = 0.16 + (1-p)*0.58;
        t.pillar.material.opacity = 0.10 + (1-p)*0.35;

        if(t.warnLeft<=0){
          t.state="impact";
          t.hot = 0.35; // hot window
          t.warnRing.material.opacity = 0.0;
          t.pillar.material.opacity = 0.0;

          // impact FX
          shake = Math.max(shake, 0.65);
          addShockwave(t.pos, 0xff4b4b, 0.75, 0.7, t.blastR*1.35, 0.78);
          addSparks(t.pos, 0xffe3a0, 46, 15, 0.85);
          addImpactLight(t.pos, 0xff8b3d, 3.8, 70, 0.40);

          // reset
          t.next = 2.4 + Math.random()*2.6;
        }
      }else if(t.state==="impact"){
        t.hot -= dt;
        if(t.hot<=0){
          t.state="idle";
          t.warnRing.scale.set(1,1,1);
        }
      }

      if(canHit){
        // explosion effect if within blast radius during hot window
        if(t.state==="impact" && t.hot>0 && t.hitCd<=0){
          const dx=car.position.x - t.pos.x;
          const dz=car.position.z - t.pos.z;
          const dist=Math.hypot(dx,dz);
          if(dist < t.blastR + CAR_R){
            t.hitCd=1.2;
            // knock away + stun
            const dir=new THREE.Vector3(dx,0,dz).normalize();
            car.position.addScaledVector(dir, 4.5 + (t.blastR - dist)*0.25);
            stunUntil = Math.max(stunUntil, now() + 1800);
            bumpSlowUntil = Math.max(bumpSlowUntil, now() + 900);
          }
        }
      }
    }

    if(t.type==="towers"){
      // subtle pulsing aura
      t.flash = Math.max(0, (t.flash||0) - dt);
      t.halo.material.opacity = 0.35 + t.flash*0.75;

      t.cd -= dt;
      if(t.cd<=0){
        t.cd = t.fireEvery; // every 5s
        t.flash = 0.32;

        // strike FX
        const from = new THREE.Vector3(t.pos.x, 8.5, t.pos.z);
        const to   = new THREE.Vector3(t.pos.x, 0.1, t.pos.z);
        addLightningBolt(from, to, 0x9ec9ff, 0.22);
        addShockwave(t.pos, 0x9ec9ff, 0.55, 0.6, t.rad*1.05, 0.55);
        addImpactLight(t.pos, 0x9ec9ff, 2.8, 85, 0.28);
        shake = Math.max(shake, 0.35);

        if(canHit){
          const dx=car.position.x - t.pos.x;
          const dz=car.position.z - t.pos.z;
          const dist=Math.hypot(dx,dz);
          if(dist < t.rad + CAR_R){
            // stun 1s
            stunUntil = Math.max(stunUntil, now() + 1000);
          }
        }
      }
    }

    if(t.type==="monsters"){
      // roam (angle and radius wander)
      t.a = normAngle(t.a + t.da*dt*0.45);
      t.r = clamp(t.r + t.dr*dt*0.35, INNER_R+4, OUTER_R-4);
      const x=Math.cos(t.a)*t.r;
      const z=Math.sin(t.a)*t.r;
      t.root.position.set(x,0,z);
      t.root.rotation.y = -t.a + Math.PI/2;

      if(Math.random()<0.01){
        t.da *= (Math.random()>.5?1:-1);
      }
      if(Math.random()<0.01){
        t.dr *= (Math.random()>.5?1:-1);
      }

      if(canHit && t.hitCd<=0){
        const dx=car.position.x - x;
        const dz=car.position.z - z;
        const dist=Math.hypot(dx,dz);
        if(dist < t.rad + CAR_R){
          t.hitCd=1.0;
          // bounce back strongly
          const back=new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);
          car.position.addScaledVector(back, 6.0);
          bumpSlowUntil = Math.max(bumpSlowUntil, now() + 900);
          addShockwave(new THREE.Vector3(x,0,z), 0xc07cff, 0.55, 0.5, 5.8, 0.55);
          addSparks(new THREE.Vector3(x,0,z), 0xc07cff, 22, 10, 0.55);
          shake = Math.max(shake, 0.38);
        }
      }
    }

    if(t.type==="rhinos"){
      // run opposite direction (negative angle)
      t.a = normAngle(t.a - dt*t.speed);
      const x=Math.cos(t.a)*t.r;
      const z=Math.sin(t.a)*t.r;
      t.root.position.set(x,0,z);
      t.root.rotation.y = -t.a - Math.PI/2;

      if(canHit && t.hitCd<=0){
        const dx=car.position.x - x;
        const dz=car.position.z - z;
        const dist=Math.hypot(dx,dz);
        if(dist < t.rad + CAR_R){
          t.hitCd=1.6;
          // stun 3s + shove
          stunUntil = Math.max(stunUntil, now() + 3000);
          const back=new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);
          car.position.addScaledVector(back, 8.5);
          bumpSlowUntil = Math.max(bumpSlowUntil, now() + 1200);
          addShockwave(new THREE.Vector3(x,0,z), 0xff6f89, 0.65, 0.6, 7.4, 0.65);
          addImpactLight(new THREE.Vector3(x,0,z), 0xff6f89, 2.8, 65, 0.35);
          shake = Math.max(shake, 0.75);
        }
      }
    }
  }
}

/* ============================================================
   ROAD ROCKS (small bumps)
============================================================ */
function hashSeed(s){
  let h=2166136261>>>0;
  for(let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h = Math.imul(h,16777619); }
  return h>>>0;
}
function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
}
const rand = mulberry32(hashSeed(gameId||"solo"));
const roadRocks=[];
function spawnRoadRocks(){
  roadRocks.splice(0).forEach(r=>scene.remove(r.mesh));
  const rockMat=new THREE.MeshStandardMaterial({color:0x565b62, roughness:.97, emissive:0x0a0c10, emissiveIntensity:0.10});
  for(let i=0;i<26;i++){
    const a=normAngle(rand()*Math.PI*2);
    const r=(INNER_R+4) + rand()*(ROAD_W-8);
    const x=Math.cos(a)*r, z=Math.sin(a)*r;
    const s=0.55 + rand()*0.95;
    const mesh=new THREE.Mesh(new THREE.DodecahedronGeometry(s,0), rockMat);
    mesh.position.set(x,0.15,z);
    mesh.rotation.set(rand()*3,rand()*3,rand()*3);
    scene.add(mesh);
    roadRocks.push({mesh,rad:s*0.95,hitCd:0});
  }
}
spawnRoadRocks();

/* ============================================================
   GAMEPLAY (LOCAL)
============================================================ */
let isRacing=false;
let lapStart=0;
let raceGoAtMs=0;
let currentLapLocal=1;
let lastSubmittedLap=0;

let stunUntil=0;
let boostReadyAt=0;
let bumpSlowUntil=0;

let halfWay=false;
let lastProgress=0;

const keys={ forward:false,left:false,right:false,brake:false,boost:false };

function lapProgress(theta){
  const t=normAngle(theta);
  return normAngle(t - startTheta);
}

function armLocalLap(goAtMs, lapNumber){
  setCarAtStart();
  isRacing=true;
  raceGoAtMs = goAtMs || now();
  lapStart   = raceGoAtMs;
  currentLapLocal = lapNumber || 1;
  lastSubmittedLap = 0;

  stunUntil=0;
  bumpSlowUntil=0;
  halfWay=false;
  lastProgress=0;
}

function updateRoadRocks(dt){
  const phase=raceState?.phase;
  const canHit = (phase==="racing") && isRacing && (now() >= raceGoAtMs);
  if(!canHit) return;

  for(const r of roadRocks){
    r.hitCd=Math.max(0,r.hitCd-dt);
    const d=r.mesh.position.distanceTo(car.position);
    if(d < r.rad + CAR_R && r.hitCd<=0){
      r.hitCd=1.1;
      bumpSlowUntil=Math.max(bumpSlowUntil, now()+650);
      const back=new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);
      car.position.addScaledVector(back, 1.0);
      addShockwave(r.mesh.position, 0x5a5f66, 0.45, 0.4, 3.0, 0.35);
    }
  }
}

function updateCar(dt){
  const t=now();

  // ‚úÖ hard gate: nobody moves until shared go-time
  if(t < raceGoAtMs){
    car.position.y=0.1;
    return;
  }

  const stunned = t < stunUntil;
  const ri = roadInfo(car.position.x, car.position.z);
  const onRoad = ri.onRoad;

  let speed = onRoad ? 22 : 12;
  if(keys.forward && !stunned) speed = onRoad ? 30 : 16;
  if(keys.brake && !stunned) speed *= 0.38;
  if(t < bumpSlowUntil) speed *= 0.72;

  const boosting = keys.boost && (t > boostReadyAt) && !stunned;
  if(boosting){
    speed = onRoad ? 46 : 26;
    boostReadyAt = t + 8000;
    shake = Math.max(shake, 0.12);
    addShockwave(new THREE.Vector3(car.position.x,0,car.position.z), 0x3bd7ff, 0.32, 0.4, 2.2, 0.45);
  }

  const turn=(keys.left?-1:0)+(keys.right?1:0);
  const turnRate = (keys.brake ? 2.85 : 2.30);
  car.rotation.y -= turn * dt * turnRate;

  const forward=new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion);
  car.position.addScaledVector(forward, speed*dt);
  car.position.y=0.1;

  const hitWall = enforceWalls();
  if(hitWall){
    bumpSlowUntil=Math.max(bumpSlowUntil, now()+350);
    shake = Math.max(shake, 0.18);
  }

  // boost UI + visuals
  const cdLeft=Math.max(0,(boostReadyAt - t)/1000);
  el("boostBtn").classList.toggle("onCd", cdLeft>0.01);

  const baseColor=new THREE.Color(0xff7a22);
  const boostColor=new THREE.Color(0x3bd7ff);
  car.flameMat.color.copy(baseColor).lerp(boostColor, boosting ? 1 : 0.15);
  const flameScale = boosting ? 2.10 : (cdLeft>0.01 ? 1.12 : 0.85);
  car.flame.scale.set(1, flameScale, flameScale);
  car.under.material.opacity = boosting ? 0.34 : 0.18;

  // lap completion detection (one full loop)
  const theta = Math.atan2(car.position.z, car.position.x);
  const prog = lapProgress(theta);

  if(prog > Math.PI) halfWay=true;

  if(halfWay && lastProgress > 6.0 && prog < 0.25){
    if(lastSubmittedLap===currentLapLocal) return;
    const lapSec = (t - lapStart)/1000;
    lastSubmittedLap=currentLapLocal;
    isRacing=false;
    submitLap(lapSec);
  }
  lastProgress=prog;
}

/* ============================================================
   CAMERA (zoomed out on mobile + car lower)
============================================================ */
function updateCamera(){
  const mobile=isMobile();

  const height = mobile ? 86 : 18;   // ‚úÖ zoom out significantly on mobile
const behind = mobile ? 9.5 : 16;


camera.fov = mobile ? 82 : 62;

  const back = new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);
  const desired = new THREE.Vector3(
    car.position.x + back.x*behind,
    height,
    car.position.z + back.z*behind
  );

  camera.position.lerp(desired, mobile ? 0.22 : 0.10);

  // camera shake
  if(shake>0.0001){
    const s = shake * 0.65;
    camera.position.x += (Math.random()-0.5)*s;
    camera.position.y += (Math.random()-0.5)*s;
    camera.position.z += (Math.random()-0.5)*s;
  }

  // ‚úÖ look slightly above car so it sits lower on screen
  const lookY = mobile ? 2.8 : 1.2;
  camera.lookAt(car.position.x, lookY, car.position.z);
}

/* ============================================================
   UI (minimal until finished)
============================================================ */
function updateUIMode(){
  const phase = raceState?.phase || "ready";
  document.body.classList.toggle("uiMinimal", phase !== "finished");
}

function renderHUD(){
  const t=now();
  const lapElapsed = isRacing ? Math.max(0, ((t - lapStart)/1000)) : 0;
  el("lapTimer").textContent = lapElapsed.toFixed(3);

  el("roomText").textContent = (gameId||"‚Äî").slice(0, 14);

  const cdLeft=Math.max(0,(boostReadyAt-t)/1000);
  el("boostText").textContent = cdLeft ? `Cooldown ${cdLeft.toFixed(1)}s` : "Ready";

  const d=raceState;
  const phase=d?.phase||"‚Äî";

  let status="Connecting‚Ä¶";
  if(offlineMode) status="Offline";
  else if(!d) status="Connecting‚Ä¶";
  else if(phase==="ready") status="Ready-up";
  else if(phase==="countdown") status="Starting‚Ä¶";
  else if(phase==="racing") status=(t < (d.startAtMs||t)) ? "Get set‚Ä¶" : "Racing";
  else if(phase==="lap_wait") status="Waiting‚Ä¶";
  else if(phase==="obstacle_select") status="Threat Pick";
  else if(phase==="finished") status="Finished";
  el("statusText").textContent=status;

  let lapText = "‚Äî";
  if(d){
    const lap=d.lap||1;
    const maxLaps=d.maxLaps||MAX_LAPS;
    if(d.phase==="obstacle_select") lapText = `Lap ${lap} complete ‚Ä¢ Picking threat for lap ${Math.min(maxLaps, lap+1)}`;
    else if(d.phase==="finished") lapText = `Complete (${maxLaps}/${maxLaps})`;
    else lapText = `Lap ${lap} / ${maxLaps}`;
  }
  el("lapText").textContent = lapText;

  const act = d ? (()=>{ try{ return activeParticipants(structuredClone(d)); }catch{ return (d.participants||[]); } })() : [];
  const readyCount = d ? act.filter(uid=>!!d.players?.[uid]?.ready).length : 0;
  el("playersText").textContent = d ? `${readyCount}/${act.length} ready` : "‚Äî";

  updateUIMode();
}

function renderResultsBoard(){
  if(!raceState) return;

  const d=raceState;
  if(d.phase!=="finished"){
    el("scoreRows").innerHTML="";
    el("tags").innerHTML="";
    el("msg").textContent="‚Äî";
    return;
  }

  const r = roster(d);
  const players=d.players||{};
  const rows=r.map(uid=>{
    const p=players[uid]||{};
    const laps=p.laps||[];
    const a=avg(laps);
    return {
      uid,
      name:p.name||uid.slice(0,6),
      l1:laps[0], l2:laps[1], l3:laps[2],
      avg:a,
      note:(uid===d.winnerUid) ? "üèÜ Winner" : ""
    };
  }).sort((a,b)=>((a.avg??999)-(b.avg??999)));

  el("scoreRows").innerHTML = rows.map(rw=>`
    <tr class="${rw.uid===myUid ? "youRow" : ""}">
      <td>${rw.name}${rw.uid===myUid?" (you)":""}</td>
      <td>${fmt(rw.l1)}</td>
      <td>${fmt(rw.l2)}</td>
      <td>${fmt(rw.l3)}</td>
      <td>${fmt(rw.avg)}</td>
      <td>${rw.note}</td>
    </tr>
  `).join("");

  const hist = Array.isArray(d.obstacleHistory) ? d.obstacleHistory : [];
  const used = Array.isArray(d.obstacles) ? d.obstacles : [];

  const tags = [];
  if(d.winnerUid){
    tags.push(`<span class="tag">üèÜ Winner: ${players[d.winnerUid]?.name||"‚Äî"}</span>`);
  }
  if(used.length){
    tags.push(...used.map(o=>`<span class="tag">‚ö†Ô∏è ${OBSTACLES[o]?.name||o}</span>`));
  }else{
    tags.push(`<span class="tag">No threats were chosen</span>`);
  }
  el("tags").innerHTML = tags.join("");

  const pickLines = hist.map(h=>{
    const by = (h.chosenByUid==="auto") ? "Auto" : (players[h.chosenByUid]?.name || "Slowest");
    return `Lap ${h.lap}: ${OBSTACLES[h.type]?.name||h.type} (picked by ${by})`;
  });

  el("msg").textContent = pickLines.length
    ? pickLines.join(" ‚Ä¢ ")
    : "‚Äî";
}

async function copyInviteLink(){
  const u = new URL(location.href);
  u.searchParams.set("gameId", gameId);
  u.searchParams.set("username", username);
  try{ await navigator.clipboard.writeText(u.toString()); }catch(e){}
}

/* ============================================================
   OVERLAY (Ready -> Lap flow -> Threat selection)
============================================================ */
function renderOverlay(){
  if(offlineMode){
    showOverlay("offline","Offline / Auth Failed",
      `Firebase auth/sync failed.<br/><br/>
       If this is GitHub Pages, make sure <b>Anonymous Auth</b> is enabled.`,
      [{label:"Reload", className:"warn", onClick:()=>location.reload()}]
    );
    return;
  }

  if(!raceState){
    showOverlay("conn","Connecting‚Ä¶",
      "Syncing room state‚Ä¶",
      [{label:"Fullscreen", className:"ghost", onClick:requestFullscreen}]
    );
    return;
  }

  const d=raceState;
  const t=now();

  if(d.phase==="ready"){
    const act = (()=>{ try{ return activeParticipants(structuredClone(d)); }catch{ return (d.participants||[]); } })();
    const readyCount = act.filter(uid=>!!d.players?.[uid]?.ready).length;
    const amReady = !!d.players?.[myUid]?.ready;

    showOverlay("ready","Ready Up (3 Laps)",
      `Room: <b>${(gameId||"").slice(0,18)}</b><br/>
       Active ready: <b>${readyCount}/${act.length}</b><br/><br/>
       Runs are <b>3 laps</b>. After each lap, the <b>slowest time picks</b> a new threat for the next lap.<br/>
       Threats <b>stack</b>. Lowest <b>average</b> time wins.`,
      [
        {label: amReady ? "‚úÖ Ready (click to unready)" : "üèÅ Ready", onClick:()=>setMyReady(!amReady)},
        {label:"Copy Invite Link", className:"ghost", onClick:copyInviteLink},
        {label:"Fullscreen", className:"ghost", onClick:requestFullscreen}
      ]
    );
    return;
  }

  if(d.phase==="countdown"){
    const go=d.startAtMs||t;
    const s=Math.max(0, Math.ceil((go - t)/1000));
    showOverlay("countdown",`Lap ${d.lap||1} / ${d.maxLaps||MAX_LAPS}`,
      `Starting in <b style="font-size:28px">${s}</b> seconds.<br/>
       Current threats: <b>${(d.obstacles||[]).map(o=>OBSTACLES[o]?.name||o).join(", ") || "None"}</b>`,
      [{label:"Fullscreen", className:"ghost", onClick:requestFullscreen}]
    );
    return;
  }

  if(d.phase==="lap_wait"){
    const s=Math.max(0, Math.ceil(((d.deadlineAt||t)-t)/1000));
    showOverlay("wait","Waiting for racers‚Ä¶",
      `Lap <b>${d.lap||1}</b> in progress.<br/>
       Timeouts in <b>${s}s</b>.`,
      []
    );
    return;
  }

  if(d.phase==="obstacle_select"){
    const selectorName = d.players?.[d.selectorUid]?.name || "Slowest racer";
    const end=d.selectEndsAt || (t+SELECT_MS);
    const s=Math.max(0, Math.ceil((end - t)/1000));

    const r = roster(d);
    const single = r.length<=1;
    const canPick = single || (d.selectorUid===myUid);

    const buttons = canPick
      ? obstacleOrder.map(o=>({
          label: `‚ö†Ô∏è ${OBSTACLES[o].name}`,
          onClick:()=>chooseObstacle(o,false)
        })).concat([{label:"üé≤ Random", className:"ghost", onClick:()=>chooseObstacle(null,false)}])
      : [{label:"Waiting‚Ä¶", className:"ghost", disabled:true}];

    showOverlay("pick","Choose Next Threat",
      `<b>${selectorName}</b> had the slowest time ‚Äî they pick the next challenge.<br/>
       Selection closes in <b>${s}s</b>.<br/><br/>
       Threats stack: next lap will include <b>everything already chosen</b> plus the new one.`,
      buttons
    );
    return;
  }

  if(d.phase==="racing"){
    // hide overlay once start time passes
    if(t < (d.startAtMs||t)){
      const s=Math.max(0, Math.ceil(((d.startAtMs||t)-t)/1000));
      showOverlay("getset","Get set‚Ä¶",`Starting in <b style="font-size:28px">${s}</b>`, []);
      return;
    }
    hideOverlay();
    return;
  }

  if(d.phase==="finished"){
    const w=d.winnerUid;
    const name=d.players?.[w]?.name || "‚Äî";
    const a=avg(d.players?.[w]?.laps||[]);
    showOverlay("finished","üèÜ Series Complete",
      `<b>${name}</b> wins with the fastest average (${fmt(a)}).<br/><br/>
       Full results are shown now.`,
      [
        {label:"Rematch", onClick:rematch},
        {label:"Copy Invite Link", className:"ghost", onClick:copyInviteLink},
        {label:"Fullscreen", className:"ghost", onClick:requestFullscreen}
      ]
    );
    return;
  }

  hideOverlay();
}

/* ============================================================
   MAIN LOOP
============================================================ */
let prev=performance.now();
let lastW=0, lastH=0;
let armedStartAt=0;
let armedLap=0;

function loop(ts){
  const dt=Math.min(.033,(ts-prev)/1000); prev=ts;

  updateThreats(dt);
  updateRoadRocks(dt);

  const phase=raceState?.phase;
  if(phase==="countdown" || phase==="racing"){
    const go=raceState?.startAtMs || now();
    const lap=raceState?.lap || 1;
    if(!isRacing || armedStartAt!==go || armedLap!==lap){
      armedStartAt=go;
      armedLap=lap;
      armLocalLap(go, lap);
    }
    if(phase==="racing"){
      updateCar(dt);
    }
  }else{
    isRacing=false;
  }

  updateCamera();

  const w=innerWidth, h=innerHeight;
  if(w!==lastW || h!==lastH){
    lastW=w; lastH=h;
    renderer.setSize(w,h,false);
    camera.aspect=w/h;
    camera.updateProjectionMatrix();
  }

  renderer.render(scene,camera);

  renderHUD();
  renderResultsBoard();
  renderOverlay();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ============================================================
   CONTROLS
============================================================ */
function setupControls(){
  const fsBtn=el("mobileFsBtn");
  fsBtn?.addEventListener("click", requestFullscreen);
  updateFullscreenBtn();
  addEventListener("resize", updateFullscreenBtn);
  document.addEventListener("fullscreenchange", updateFullscreenBtn);

  addEventListener("blur", ()=>{ keys.forward=keys.left=keys.right=keys.brake=keys.boost=false; });
  document.addEventListener("visibilitychange", ()=>{
    if(document.hidden) keys.forward=keys.left=keys.right=keys.brake=keys.boost=false;
  });

  function keyDown(e){
    const code=e.code;
    if(code==="ArrowUp" || code==="KeyW") { keys.forward=true; e.preventDefault(); }
    if(code==="ArrowLeft"|| code==="KeyA") { keys.left=true; e.preventDefault(); }
    if(code==="ArrowRight"||code==="KeyD") { keys.right=true; e.preventDefault(); }
    if(code==="ArrowDown"||code==="KeyS") { keys.brake=true; e.preventDefault(); }
    if(code==="Space"){ keys.boost=true; e.preventDefault(); }
  }
  function keyUp(e){
    const code=e.code;
    if(code==="ArrowUp" || code==="KeyW") keys.forward=false;
    if(code==="ArrowLeft"|| code==="KeyA") keys.left=false;
    if(code==="ArrowRight"||code==="KeyD") keys.right=false;
    if(code==="ArrowDown"||code==="KeyS") keys.brake=false;
    if(code==="Space") keys.boost=false;
  }
  addEventListener("keydown", keyDown, {passive:false});
  addEventListener("keyup", keyUp, {passive:false});

  // Mobile pad
  const pad=el("pad"), dot=el("padDot");
  let padActive=false;

  function applyPad(clientX, clientY){
    const r=pad.getBoundingClientRect();
    const x=Math.max(0,Math.min(r.width, clientX-r.left));
    const y=Math.max(0,Math.min(r.height, clientY-r.top));

    dot.style.left=(x-13)+"px";
    dot.style.top=(y-13)+"px";

    keys.forward = y < r.height*0.82;
    keys.left    = x < r.width*0.40;
    keys.right   = x > r.width*0.60;
  }

  pad.addEventListener("pointerdown", (e)=>{
    padActive=true;
    pad.setPointerCapture?.(e.pointerId);
    applyPad(e.clientX, e.clientY);
    e.preventDefault();
  }, {passive:false});

  pad.addEventListener("pointermove", (e)=>{
    if(!padActive) return;
    applyPad(e.clientX, e.clientY);
    e.preventDefault();
  }, {passive:false});

  function endPad(){
    padActive=false;
    keys.forward=keys.left=keys.right=false;
    dot.style.left="62px";
    dot.style.top="62px";
  }
  pad.addEventListener("pointerup", endPad);
  pad.addEventListener("pointercancel", endPad);
  pad.addEventListener("pointerleave", ()=>{ if(padActive) endPad(); });

  // Boost button
  const boost=el("boostBtn");
  boost.addEventListener("pointerdown", (e)=>{ keys.boost=true; e.preventDefault(); }, {passive:false});
  boost.addEventListener("pointerup",   ()=>{ keys.boost=false; });
  boost.addEventListener("pointercancel",()=>{ keys.boost=false; });
  boost.addEventListener("pointerleave",()=>{ keys.boost=false; });
}
setupControls();

/* ============================================================
   STATE MACHINE TICK (keeps sync progressing)
============================================================ */
function tickStateMachine(){
  if(!raceState) return;

  if(raceState.phase==="ready"){
    maybeStartIfAllReady();
  }
  if(raceState.phase==="countdown"){
    maybeFlipCountdownToRacing();
  }
  if(raceState.phase==="racing"){
    ensureDeadlineIfNeeded();
  }
  if(raceState.phase==="lap_wait" || raceState.phase==="racing"){
    finalizeDeadlineIfNeeded();
  }
  if(raceState.phase==="obstacle_select"){
    autoPickIfNeeded();
  }
}

/* ============================================================
   BOOT
============================================================ */
(async function main(){
  el("roomText").textContent = (gameId||"‚Äî").slice(0, 14);

  try{
    const u = await ensureAuthed();
    myUid = u.uid;
  }catch(e){
    offlineMode=true;
    showOverlay("authFail","Auth failed",
      `<b>${String(e?.code||"error")}</b><br/>${String(e?.message||e)}<br/><br/>
       Common fix: enable <b>Anonymous Auth</b>.`,
      [{label:"Reload", className:"warn", onClick:()=>location.reload()}]
    );
    return;
  }

  await ensureRaceDoc();
  attachRaceListener();

  await joinRace();
  await presencePing();
  setInterval(presencePing, PRESENCE_PING_MS);
  setInterval(tickStateMachine, 800);

  // initial spawn (in case threats already selected)
  spawnThreats();
})();
</script>
</body>
</html>
