<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
        content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <title>üìà StockKings ‚Äî Donut Rush (Ready Race)</title>

  <style>
    :root{
      --bg0:#050812;
      --bg1:#08122b;
      --bg2:#0b1b3f;
      --panel: rgba(14, 23, 38, .78);
      --panel2: rgba(8, 11, 19, .78);
      --line: rgba(87,178,255,.22);
      --line2: rgba(255,255,255,.08);
      --ink:#ecf3ff;
      --muted:#a9bad8;
      --muted2:#7f93b7;
      --accent:#57b2ff;
      --good:#60f0a1;
      --warn:#ffd972;
      --bad:#ff6f89;
      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --r: 14px;
      --r2: 12px;
    }

    *{ box-sizing:border-box; }
    html,body{
      height:100%;
      margin:0;
      color:var(--ink);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background:
        radial-gradient(1200px 900px at 20% 10%, rgba(87,178,255,.18), transparent 58%),
        radial-gradient(900px 700px at 80% 0%, rgba(96,240,161,.12), transparent 55%),
        radial-gradient(900px 700px at 50% 100%, rgba(255,111,137,.10), transparent 55%),
        linear-gradient(180deg, var(--bg2), var(--bg0));
      overflow:hidden;
      overscroll-behavior:none;
      touch-action:none;
    }

    /* subtle film grain */
    body::before{
      content:"";
      position:fixed; inset:0;
      pointer-events:none;
      opacity:.06;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='240' height='240'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='240' height='240' filter='url(%23n)' opacity='.55'/%3E%3C/svg%3E");
      mix-blend-mode:overlay;
    }

    #app{ position:relative; height:100%; width:100%; overflow:hidden; }
    #scene{
      position:absolute; inset:0;
      width:100%; height:100%;
      display:block;
      touch-action:none;
    }

    .hud{
      position:absolute; inset:0;
      pointer-events:none;
      display:flex;
      flex-direction:column;
      justify-content:space-between;
      padding:
        calc(12px + env(safe-area-inset-top))
        calc(12px + env(safe-area-inset-right))
        calc(12px + env(safe-area-inset-bottom))
        calc(12px + env(safe-area-inset-left));
      gap:12px;
      z-index:5;
    }

    .top{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:stretch;
    }

    .chip{
      pointer-events:auto;
      background: linear-gradient(180deg, rgba(14,23,38,.82), rgba(8,11,19,.72));
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 9px 11px;
      font-weight: 900;
      letter-spacing:.2px;
      box-shadow: 0 10px 28px rgba(0,0,0,.26);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      min-width: 128px;
      position:relative;
      overflow:hidden;
    }
    .chip::after{
      content:"";
      position:absolute; inset:-1px;
      border-radius:12px;
      background:
        radial-gradient(160px 70px at 20% 0%, rgba(87,178,255,.20), transparent 60%),
        radial-gradient(140px 70px at 80% 100%, rgba(96,240,161,.12), transparent 60%);
      opacity:.75;
      pointer-events:none;
      mix-blend-mode:screen;
    }
    .chip > *{ position:relative; z-index:1; }

    .chip small{
      display:block;
      color: var(--muted2);
      font-weight: 750;
      letter-spacing:.25px;
      margin-bottom:2px;
    }

    .big{ font-size: 24px; font-weight: 950; }

    .board{
      pointer-events:auto;
      background: linear-gradient(180deg, rgba(8,11,19,.90), rgba(14,23,38,.74));
      border: 1px solid var(--line);
      border-radius: var(--r);
      padding: 12px;
      max-width: 620px;
      max-height: 52vh;
      overflow:auto;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    .board h3{
      margin:0 0 10px;
      font-weight: 1000;
      letter-spacing:.2px;
    }

    table{
      width:100%;
      border-collapse:collapse;
      font-size: 13px;
      border-radius: 12px;
      overflow:hidden;
    }
    thead th{
      position:sticky;
      top:0;
      z-index:2;
      background: rgba(10,15,25,.92);
      border-bottom:1px solid var(--line2);
      padding:8px 8px;
      text-align:left;
      color:#dff0ff;
      font-weight:950;
      letter-spacing:.2px;
    }
    tbody td{
      padding:7px 8px;
      border-bottom:1px solid rgba(255,255,255,.06);
      color:#eaf3ff;
    }
    tbody tr:nth-child(odd) td{ background: rgba(255,255,255,.02); }
    tbody tr:hover td{ background: rgba(87,178,255,.06); }

    .youRow td{
      background: rgba(96,240,161,.06) !important;
      border-bottom: 1px solid rgba(96,240,161,.12);
    }

    .msg{
      font-size: 13px;
      color: var(--muted);
      margin-top: 10px;
      line-height:1.35;
    }

    .tags{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      margin-top:10px;
    }
    .tag{
      font-size: 12px;
      padding: 5px 9px;
      border-radius:999px;
      border:1px solid rgba(87,178,255,.22);
      background: rgba(87,178,255,.08);
      color: #cfe7ff;
      font-weight:850;
      letter-spacing:.15px;
    }

    /* Overlay modal */
    .modalWrap{
      position:absolute; inset:0;
      background: radial-gradient(900px 700px at 50% 10%, rgba(87,178,255,.14), transparent 55%),
                  rgba(3,6,12,.72);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      z-index:20;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }
    .modalWrap.show{ display:flex; }
    .modal{
      pointer-events:auto;
      background: linear-gradient(180deg, rgba(14,23,38,.92), rgba(8,11,19,.86));
      border:1px solid rgba(87,178,255,.28);
      border-radius: 18px;
      max-width: 780px;
      width: min(780px, 95vw);
      padding: 16px 16px 14px;
      box-shadow: 0 26px 90px rgba(0,0,0,.55);
      animation: pop .14s ease-out;
      position:relative;
      overflow:hidden;
    }
    .modal::before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(380px 180px at 20% 0%, rgba(87,178,255,.20), transparent 60%),
        radial-gradient(320px 160px at 80% 100%, rgba(255,111,137,.14), transparent 60%);
      opacity:.7;
      pointer-events:none;
      mix-blend-mode:screen;
    }
    .modal > *{ position:relative; z-index:1; }
    @keyframes pop{
      from{ transform: translateY(8px) scale(.985); opacity:.0; }
      to  { transform: translateY(0) scale(1); opacity:1; }
    }
    .modal h2{ margin:0 0 8px; font-weight: 1050; letter-spacing:.2px; }
    .modal p{ margin:6px 0; color: var(--muted); line-height:1.35; }

    .btns{ display:flex; flex-wrap:wrap; gap:10px; margin-top:12px; }

    button{
      cursor:pointer;
      border: 1px solid rgba(87,178,255,.32);
      background: linear-gradient(180deg, rgba(29,75,128,.92), rgba(20,55,98,.92));
      color:#fff;
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 950;
      letter-spacing:.2px;
      box-shadow: 0 10px 24px rgba(0,0,0,.22);
      transition: transform .08s ease, filter .08s ease, opacity .08s ease;
      user-select:none;
    }
    button:hover{ filter: brightness(1.07); }
    button:active{ transform: translateY(1px); }
    button.ghost{
      background: linear-gradient(180deg, rgba(24,33,51,.86), rgba(18,25,40,.86));
      border-color: rgba(255,255,255,.14);
    }
    button.warn{
      background: linear-gradient(180deg, rgba(109,79,18,.92), rgba(84,58,12,.92));
      border-color: rgba(255,217,114,.35);
    }
    button:disabled{ opacity:.55; cursor:not-allowed; filter:none; transform:none; }

    /* Mobile controls */
    .controls{
      position:absolute;
      inset:auto 0 calc(10px + env(safe-area-inset-bottom)) 0;
      display:none;
      justify-content:space-between;
      padding:0 10px;
      z-index:8;
      pointer-events:none;
    }
    .pad,.boost{
      pointer-events:auto;
      background: rgba(8,14,24,.70);
      border: 1px solid rgba(87,178,255,.28);
      border-radius: 16px;
      touch-action:none;
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .pad{
      width:150px;height:150px;
      position:relative;
    }
    .pad::after{
      content:"";
      position:absolute; inset:10px;
      border-radius: 14px;
      border: 1px dashed rgba(255,255,255,.10);
      opacity:.55;
      pointer-events:none;
    }
    .padDot{
      position:absolute;
      width:26px;height:26px;
      border-radius:50%;
      background: radial-gradient(circle at 30% 30%, #bfe6ff, #2e8dff);
      left:62px; top:62px;
      pointer-events:none;
      box-shadow: 0 0 18px rgba(87,178,255,.55);
    }

    .boost{
      width:120px;height:120px;
      display:grid;
      place-items:center;
      font-weight:1050;
      letter-spacing:.5px;
      text-transform:uppercase;
    }
    .boost.onCd{
      background: rgba(45,18,18,.80);
      border-color: rgba(255,111,137,.36);
    }

    .mobileFsBtn{
      position:absolute;
      right:10px;
      top: calc(10px + env(safe-area-inset-top));
      z-index:12;
      display:none;
      padding: 9px 12px;
      border-radius: 12px;
      background: rgba(8,14,24,.74);
      border: 1px solid rgba(87,178,255,.28);
      color:#fff;
      font-weight: 900;
      letter-spacing:.2px;
      box-shadow: 0 12px 34px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .mobileFsBtn.show{ display:block; }

    @media (max-width:920px){
      .controls{ display:flex; pointer-events:auto; }
    }

    /* ‚úÖ Hide UI until AFTER the race (except lap time chip) */
    body.uiMinimal .top .chip:not(#lapChip){ display:none; }
    body.uiMinimal .board{ display:none; }
  </style>
</head>

<body class="uiMinimal">
<div id="app">
  <canvas id="scene"></canvas>
  <button id="mobileFsBtn" class="mobileFsBtn" type="button">‚õ∂ Fullscreen</button>

  <div class="hud">
    <div class="top">
      <div class="chip" id="lapChip"><small>Lap Timer</small><span class="big" id="lapTimer">00.000</span></div>
      <div class="chip"><small>Status</small><span id="statusText">Connecting‚Ä¶</span></div>
      <div class="chip"><small>Players</small><span id="playersText">‚Äî</span></div>
      <div class="chip"><small>Boost</small><span id="boostText">Ready</span></div>
      <div class="chip"><small>Room</small><span id="roomText">‚Äî</span></div>
    </div>

    <div class="board">
      <h3>üèÅ Results</h3>
      <table>
        <thead><tr><th>Player</th><th>Time</th><th>Note</th></tr></thead>
        <tbody id="scoreRows"></tbody>
      </table>
      <div class="tags" id="tags"></div>
      <div class="msg" id="msg">‚Äî</div>
    </div>
  </div>

  <div class="controls">
    <div class="pad" id="pad"><div class="padDot" id="padDot"></div></div>
    <button class="boost" id="boostBtn" type="button">BOOST</button>
  </div>

  <div class="modalWrap show" id="overlay">
    <div class="modal">
      <h2 id="overlayTitle">StockKings ‚Äî Donut Rush</h2>
      <p id="overlayBody">Connecting‚Ä¶</p>
      <div class="btns" id="overlayButtons"></div>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.162/build/three.module.js";
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getAuth, signInAnonymously, onAuthStateChanged, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
import { getFirestore, doc, onSnapshot, runTransaction, setDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

/* ============================================================
   FIREBASE INIT
============================================================ */
const firebaseConfig={
  apiKey:"AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain:"bible-game-246c0.firebaseapp.com",
  projectId:"bible-game-246c0",
  storageBucket:"bible-game-246c0.appspot.com",
  messagingSenderId:"959619818996",
  appId:"1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app=initializeApp(firebaseConfig);
const auth=getAuth(app);
const db=getFirestore(app);

/* ============================================================
   URL + LOCAL STORAGE (auto-create room if missing)
============================================================ */
const LS_USER="gh.username";
const LS_LOBBY="gh.lastLobbyId";
const params=new URLSearchParams(location.search);

function randId(){
  return "sk-" + Math.random().toString(36).slice(2,8) + "-" + Math.random().toString(36).slice(2,6);
}

let gameId=(params.get("gameId")||localStorage.getItem(LS_LOBBY)||"").trim();
let username=(params.get("username")||localStorage.getItem(LS_USER)||"Racer").trim();

if(!gameId){
  gameId = randId();
  params.set("gameId", gameId);
  history.replaceState(null, "", `${location.pathname}?${params.toString()}`);
}
if(!username) username="Racer";
localStorage.setItem(LS_LOBBY, gameId);
localStorage.setItem(LS_USER, username);

const RACE_REF = doc(db, "lobbies", gameId, "stockkings", "race");

/* ============================================================
   DOM
============================================================ */
const el=id=>document.getElementById(id);

let overlayKey="";
function showOverlay(key,title,body,buttons){
  overlayKey=key;
  el("overlayTitle").textContent=title;
  el("overlayBody").innerHTML=body;
  const wrap=el("overlayButtons"); wrap.innerHTML="";
  (buttons||[]).forEach(b=>{
    const bt=document.createElement("button");
    bt.textContent=b.label;
    if(b.className) bt.className=b.className;
    if(b.disabled) bt.disabled=true;
    bt.type="button";
    bt.onclick=b.onClick||(()=>{});
    wrap.appendChild(bt);
  });
  el("overlay").classList.add("show");
}
function hideOverlay(){
  overlayKey="";
  el("overlay").classList.remove("show");
}

function isMobile(){ return innerWidth < 920; }

async function requestFullscreen(){
  try{
    const root=document.documentElement;
    if(document.fullscreenElement){
      await document.exitFullscreen?.();
      return;
    }
    await root.requestFullscreen?.();
  }catch(e){}
}
function updateFullscreenBtn(){
  const btn=el("mobileFsBtn");
  if(!btn) return;
  btn.classList.toggle("show", isMobile());
  btn.textContent=document.fullscreenElement?"üóó Exit Fullscreen":"‚õ∂ Fullscreen";
}

/* ============================================================
   AUTH (Anonymous)
============================================================ */
async function ensureAuthed(){
  let signInErr = null;

  try { await setPersistence(auth, browserLocalPersistence); }
  catch(e){ console.warn("setPersistence failed:", e); }

  if(auth.currentUser) return auth.currentUser;

  try{
    await signInAnonymously(auth);
  }catch(e){
    signInErr = e;
    console.error("signInAnonymously failed:", e);
  }

  return await new Promise((resolve, reject)=>{
    const timeout=setTimeout(()=>{
      reject(signInErr || new Error("auth-timeout"));
    }, 10000);

    const unsub=onAuthStateChanged(auth, (u)=>{
      if(u){
        clearTimeout(timeout);
        unsub();
        resolve(u);
      }
    });
  });
}

/* ============================================================
   READY-RACE STATE (no lobby dependency)
============================================================ */
let raceState=null;
let raceUnsub=null;
let pendingTxn=false;
let myUid="";
let offlineMode=false;

const ACTIVE_WINDOW_MS = 20000;
const PRESENCE_PING_MS = 3500;
const READY_START_DELAY_MS = 1300;  // shared start delay
const DEADLINE_MS = 30000;          // auto-finish timeout
const MAX_PLAYERS = 8;

function now(){ return Date.now(); }
function fmt(n){ return typeof n==="number" ? n.toFixed(2)+"s" : "‚Äî"; }

function ensurePlayerObj(d, uid, name){
  d.players = d.players || {};
  d.players[uid] = d.players[uid] || {
    uid, name,
    ready:false,
    lastSeenMs:0,
    lapTime:null
  };
  d.players[uid].name = name || d.players[uid].name || "Racer";
  if(typeof d.players[uid].ready !== "boolean") d.players[uid].ready=false;
  if(typeof d.players[uid].lastSeenMs !== "number") d.players[uid].lastSeenMs=0;
  if(typeof d.players[uid].lapTime !== "number") d.players[uid].lapTime = (d.players[uid].lapTime===null ? null : null);
}

function pruneParticipants(d){
  const parts = Array.isArray(d.participants) ? d.participants.slice() : [];
  const players = d.players || {};
  const keep = parts.filter(uid => (now() - (players[uid]?.lastSeenMs||0)) < (5*60*1000));
  const uniq=[];
  for(const uid of keep){ if(!uniq.includes(uid)) uniq.push(uid); }
  d.participants = uniq.slice(0, MAX_PLAYERS);
}

function activeParticipants(d){
  pruneParticipants(d);
  const parts = Array.isArray(d.participants) ? d.participants : [];
  const players = d.players || {};
  const t=now();
  const act = parts.filter(uid => (t - (players[uid]?.lastSeenMs||0)) < ACTIVE_WINDOW_MS);
  if(myUid && parts.includes(myUid) && !act.includes(myUid)) act.push(myUid);
  return act.slice(0, MAX_PLAYERS);
}

function roster(d){
  return (Array.isArray(d.roundPlayers) && d.roundPlayers.length)
    ? d.roundPlayers.slice(0, MAX_PLAYERS)
    : activeParticipants(d);
}

function computeWinnerUid(d){
  const r = roster(d);
  let bestUid=null, best=1e18;
  for(const uid of r){
    const t = d.players?.[uid]?.lapTime;
    if(typeof t==="number" && t<best){ best=t; bestUid=uid; }
  }
  return bestUid;
}

async function txn(mutator){
  if(!RACE_REF) return;
  if(pendingTxn) return;
  pendingTxn=true;
  try{
    await runTransaction(db, async (tx)=>{
      const snap=await tx.get(RACE_REF);
      if(!snap.exists()) return;
      const d=snap.data();
      const out=mutator(d);
      if(!out) return;
      tx.set(RACE_REF, out, {merge:false});
    });
  }catch(e){
    showOverlay("txerr","Sync error",
      `<b>${String(e?.code||"error")}</b><br/>${String(e?.message||e)}`,
      [{label:"Reload", className:"warn", onClick:()=>location.reload()}]
    );
  }finally{
    pendingTxn=false;
  }
}

async function ensureRaceDoc(){
  await runTransaction(db, async (tx)=>{
    const snap=await tx.get(RACE_REF);
    if(snap.exists()) return;
    tx.set(RACE_REF, {
      game:"stockkings-ready-race",
      phase:"ready",            // ready | countdown | racing | finished
      participants:[],
      players:{},
      roundPlayers:[],
      startAtMs:null,
      deadlineAt:null,
      winnerUid:null,
      updatedAtMs: now(),
      createdAtMs: now()
    }, {merge:false});
  });
}

async function joinRace(){
  await txn((d)=>{
    pruneParticipants(d);
    d.participants = Array.isArray(d.participants) ? d.participants : [];
    if(myUid && !d.participants.includes(myUid)) d.participants.push(myUid);
    d.participants = d.participants.slice(0, MAX_PLAYERS);

    ensurePlayerObj(d, myUid, username);
    d.players[myUid].lastSeenMs = now();
    d.players[myUid].name = username;

    d.updatedAtMs = now();
    return d;
  });
}

async function presencePing(){
  if(!myUid) return;
  try{
    await setDoc(RACE_REF, {
      players: { [myUid]: { name: username, lastSeenMs: now() } }
    }, {merge:true});
  }catch(e){
    console.warn("presencePing failed:", e);
  }
}

async function setMyReady(ready){
  await txn((d)=>{
    if(!["ready","countdown"].includes(d.phase)) return null;

    pruneParticipants(d);
    d.participants = Array.isArray(d.participants) ? d.participants : [];
    if(myUid && !d.participants.includes(myUid)) d.participants.push(myUid);
    d.participants = d.participants.slice(0, MAX_PLAYERS);

    ensurePlayerObj(d, myUid, username);
    d.players[myUid].ready = !!ready;
    d.players[myUid].lastSeenMs = now();
    d.players[myUid].name = username;

    // If someone unreadies during countdown, revert to ready
    if(d.phase==="countdown"){
      d.phase="ready";
      d.startAtMs=null;
      d.deadlineAt=null;
      d.roundPlayers=[];
    }

    d.updatedAtMs=now();
    return d;
  });
}

async function maybeStartIfAllReady(){
  await txn((d)=>{
    if(d.phase!=="ready") return null;

    const act = activeParticipants(d);
    if(!act.length) return null;

    act.forEach(uid => ensurePlayerObj(d, uid, d.players?.[uid]?.name || "Racer"));
    const allReady = act.every(uid => !!d.players?.[uid]?.ready);
    if(!allReady) return null;

    d.roundPlayers = act.slice(0, MAX_PLAYERS);
    d.phase = "countdown";
    d.startAtMs = now() + READY_START_DELAY_MS;
    d.deadlineAt = d.startAtMs + DEADLINE_MS;
    d.winnerUid = null;

    // clear lapTimes for roster (fresh run)
    d.roundPlayers.forEach(uid=>{
      ensurePlayerObj(d, uid, d.players?.[uid]?.name || "Racer");
      d.players[uid].lapTime = null;
    });

    d.updatedAtMs = now();
    return d;
  });
}

async function maybeFlipCountdownToRacing(){
  await txn((d)=>{
    if(d.phase!=="countdown") return null;
    if(!d.startAtMs) return null;
    if(now() < d.startAtMs) return null;
    d.phase="racing";
    d.updatedAtMs=now();
    return d;
  });
}

async function submitLap(timeSec){
  await txn((d)=>{
    if(d.phase!=="racing") return null;

    const r = roster(d);
    ensurePlayerObj(d, myUid, username);
    if(!r.includes(myUid)) return null;

    const me = d.players[myUid];
    if(typeof me.lapTime === "number") return null;

    const t = Math.min(30, Math.max(0.5, timeSec));
    me.lapTime = t;
    me.lastSeenMs = now();

    // If everyone finished, end
    const allDone = r.every(uid => typeof d.players?.[uid]?.lapTime === "number");
    if(allDone){
      d.phase="finished";
      d.winnerUid = computeWinnerUid(d);
      d.updatedAtMs = now();
      return d;
    }

    d.updatedAtMs = now();
    return d;
  });
}

async function finalizeDeadlineIfNeeded(){
  await txn((d)=>{
    if(!["countdown","racing"].includes(d.phase)) return null;
    if(!d.deadlineAt) return null;
    if(now() < d.deadlineAt) return null;

    // Force any missing lapTimes to 30
    const r = roster(d);
    r.forEach(uid=>{
      ensurePlayerObj(d, uid, d.players?.[uid]?.name || "Racer");
      if(typeof d.players[uid].lapTime !== "number"){
        d.players[uid].lapTime = 30;
      }
    });

    d.phase="finished";
    d.winnerUid = computeWinnerUid(d);
    d.updatedAtMs = now();
    return d;
  });
}

async function rematch(){
  await txn((d)=>{
    // New run: ready up again
    pruneParticipants(d);
    d.phase="ready";
    d.startAtMs=null;
    d.deadlineAt=null;
    d.roundPlayers=[];
    d.winnerUid=null;

    d.players = d.players || {};
    (d.participants||[]).forEach(uid=>{
      ensurePlayerObj(d, uid, d.players?.[uid]?.name || "Racer");
      d.players[uid].ready = false;
      d.players[uid].lapTime = null;
    });

    ensurePlayerObj(d, myUid, username);
    d.players[myUid].lastSeenMs = now();
    d.updatedAtMs = now();
    return d;
  });
}

function attachRaceListener(){
  if(raceUnsub) raceUnsub();
  raceUnsub = onSnapshot(
    RACE_REF,
    (snap)=>{
      try{
        if(!snap.exists()){ raceState=null; return; }
        raceState=snap.data();
      }catch(e){
        console.error("snapshot error:", e);
      }
    },
    (err)=>{
      showOverlay("raceErr","Sync error",
        `<b>${String(err?.code||"error")}</b><br/>${String(err?.message||err)}<br/><br/>
         If this is GitHub Pages, make sure Anonymous Auth is enabled in Firebase Console.`,
        [{label:"Reload", className:"warn", onClick:()=>location.reload()}]
      );
    }
  );
}

/* ============================================================
   THREE WORLD (Donut track)
============================================================ */
const renderer=new THREE.WebGLRenderer({canvas:el("scene"), antialias:true, alpha:true});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.08;

const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(62,1,0.1,1400);

function makeCanvasTexture(drawFn, w=512, h=512){
  const c=document.createElement("canvas");
  c.width=w; c.height=h;
  const g=c.getContext("2d");
  drawFn(g,w,h);
  const tex=new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy?.()||8);
  return tex;
}

const skyTex = makeCanvasTexture((g,w,h)=>{
  const grd=g.createLinearGradient(0,0,0,h);
  grd.addColorStop(0, "#93d8ff");
  grd.addColorStop(.45, "#69b8ff");
  grd.addColorStop(1, "#2a5c9b");
  g.fillStyle=grd; g.fillRect(0,0,w,h);
  for(let i=0;i<70;i++){
    const x=Math.random()*w, y=Math.random()*h*0.55;
    const r=30+Math.random()*90;
    const a=.04+Math.random()*.06;
    const rg=g.createRadialGradient(x,y,0,x,y,r);
    rg.addColorStop(0, `rgba(255,255,255,${a})`);
    rg.addColorStop(1, "rgba(255,255,255,0)");
    g.fillStyle=rg;
    g.beginPath(); g.arc(x,y,r,0,Math.PI*2); g.fill();
  }
}, 1024, 1024);
scene.background = skyTex;

scene.fog = new THREE.FogExp2(0x6aaef5, 0.009);

scene.add(new THREE.HemisphereLight(0xd8f1ff, 0x1e4a2b, 1.05));
const sun=new THREE.DirectionalLight(0xffffff, 1.05);
sun.position.set(30, 55, 25);
scene.add(sun);

const grassTex = makeCanvasTexture((g,w,h)=>{
  g.fillStyle="#2f8d44"; g.fillRect(0,0,w,h);
  for(let i=0;i<12000;i++){
    const x=(Math.random()*w)|0, y=(Math.random()*h)|0;
    const v=40+Math.random()*60;
    g.fillStyle=`rgba(${10+v/3|0},${110+v|0},${30+v/4|0},${.08+Math.random()*.12})`;
    g.fillRect(x,y,1,1);
  }
  g.globalAlpha=.08;
  for(let y=0;y<h;y+=20){
    g.fillStyle = (y/20)%2 ? "#000" : "#fff";
    g.fillRect(0,y,w,10);
  }
  g.globalAlpha=1;
}, 768, 768);
grassTex.repeat.set(4,4);

const ground=new THREE.Mesh(
  new THREE.PlaneGeometry(420,420),
  new THREE.MeshStandardMaterial({map:grassTex, roughness:.98, metalness:0})
);
ground.rotation.x=-Math.PI/2;
scene.add(ground);

const roadTex = makeCanvasTexture((g,w,h)=>{
  g.fillStyle="#8a5d30"; g.fillRect(0,0,w,h);
  for(let i=0;i<14000;i++){
    const x=(Math.random()*w)|0, y=(Math.random()*h)|0;
    const v=120+Math.random()*80;
    g.fillStyle=`rgba(${v|0},${(v*0.72)|0},${(v*0.40)|0},${.09+Math.random()*.12})`;
    g.fillRect(x,y,1,1);
  }
  g.globalAlpha=.10;
  g.fillStyle="#ffffff";
  g.fillRect(0, h*0.49, w, h*0.02);
  g.globalAlpha=1;
}, 768, 768);
roadTex.repeat.set(2, 2);

const ROAD_R = 52;
const ROAD_W = 34;
const INNER_R = ROAD_R - ROAD_W/2;
const OUTER_R = ROAD_R + ROAD_W/2;

const road = new THREE.Mesh(
  new THREE.RingGeometry(INNER_R, OUTER_R, 160, 1),
  new THREE.MeshStandardMaterial({map:roadTex, roughness:.90, metalness:.02})
);
road.rotation.x=-Math.PI/2;
road.position.y=0.02;
scene.add(road);

const stripe = new THREE.Mesh(
  new THREE.RingGeometry(ROAD_R-0.35, ROAD_R+0.35, 180, 1),
  new THREE.MeshBasicMaterial({color:0xe9f2ff, transparent:true, opacity:0.50})
);
stripe.rotation.x=-Math.PI/2;
stripe.position.y=0.03;
scene.add(stripe);

function wallCylinder(radius, color){
  const m=new THREE.Mesh(
    new THREE.CylinderGeometry(radius, radius, 2.1, 180, 1, true),
    new THREE.MeshStandardMaterial({color, roughness:.78, metalness:.08, side:THREE.DoubleSide})
  );
  m.position.y=1.05;
  return m;
}
scene.add(wallCylinder(INNER_R, 0x2e3a4d), wallCylinder(OUTER_R, 0x2e3a4d));

const startLine = new THREE.Mesh(
  new THREE.PlaneGeometry(ROAD_W, 3.0),
  new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.62, side:THREE.DoubleSide})
);
startLine.rotation.x=-Math.PI/2;
startLine.position.set(ROAD_R, 0.031, 0);
startLine.rotation.z=Math.PI/2;
scene.add(startLine);

/* ============================================================
   CAR + BOOST FLAME
============================================================ */
function buildCar(){
  const g=new THREE.Group();
  const body=new THREE.Mesh(
    new THREE.BoxGeometry(2.4,.85,3.8),
    new THREE.MeshStandardMaterial({color:0x1f74ff, metalness:.28, roughness:.34})
  );
  body.position.y=.9;

  const top=new THREE.Mesh(
    new THREE.BoxGeometry(1.6,.65,1.7),
    new THREE.MeshStandardMaterial({color:0xd8e8ff, metalness:.06, roughness:.45})
  );
  top.position.set(0,1.38,-.15);
  g.add(body, top);

  [[-.9,.35,-1.15],[.9,.35,-1.15],[-.9,.35,1.15],[.9,.35,1.15]].forEach(([x,y,z])=>{
    const w=new THREE.Mesh(
      new THREE.CylinderGeometry(.40,.40,.36,18),
      new THREE.MeshStandardMaterial({color:0x101218, roughness:.92, metalness:.05})
    );
    w.rotation.z=Math.PI/2;
    w.position.set(x,y,z);
    g.add(w);
  });

  const flameMat=new THREE.MeshBasicMaterial({color:0xff7a22, transparent:true, opacity:.92});
  const flame=new THREE.Mesh(new THREE.ConeGeometry(.26,1.28,12), flameMat);
  flame.position.set(0,.9,2.3);
  flame.rotation.x=Math.PI/2;
  g.add(flame);
  g.flame=flame; g.flameMat=flameMat;

  // Slightly smaller car (helps ‚Äúzoomed out‚Äù feel on mobile too)
  g.scale.set(0.76,0.76,0.76);
  return g;
}
const car=buildCar();
scene.add(car);

const START_A = 0;
function setCarAtStart(){
  const x=Math.cos(START_A)*ROAD_R;
  const z=Math.sin(START_A)*ROAD_R;
  car.position.set(x,0.1,z);
  car.rotation.set(0,0,0);
  car.rotation.y = Math.atan2(0,1) + Math.PI;
}
setCarAtStart();

/* ============================================================
   TRACK HELPERS + WALL COLLISION
============================================================ */
const CAR_R = 1.05;

function normAngle(a){
  const two=Math.PI*2;
  a%=two; if(a<0) a+=two;
  return a;
}
const startTheta = normAngle(START_A);

function roadInfo(x,z){
  const r=Math.hypot(x,z);
  const onRoad = (r>INNER_R+0.25 && r<OUTER_R-0.25);
  const distToEdge = Math.min(Math.abs(r-INNER_R), Math.abs(OUTER_R-r));
  return {r,onRoad,distToEdge};
}

function enforceWalls(){
  const r=Math.hypot(car.position.x, car.position.z) || 0.0001;
  const nx=car.position.x/r;
  const nz=car.position.z/r;

  const minR = INNER_R + CAR_R;
  if(r < minR){
    car.position.x = nx*minR;
    car.position.z = nz*minR;
    return true;
  }
  const maxR = OUTER_R - CAR_R;
  if(r > maxR){
    car.position.x = nx*maxR;
    car.position.z = nz*maxR;
    return true;
  }
  return false;
}

/* ============================================================
   ROAD ROCKS (local-only bumps)
============================================================ */
function hashSeed(s){
  let h=2166136261>>>0;
  for(let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h = Math.imul(h,16777619); }
  return h>>>0;
}
function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
}
const rand = mulberry32(hashSeed(gameId||"solo"));
const roadRocks=[];
function spawnRoadRocks(){
  roadRocks.splice(0).forEach(r=>scene.remove(r.mesh));
  const rockMat=new THREE.MeshStandardMaterial({color:0x565b62, roughness:.97});
  for(let i=0;i<26;i++){
    const a=normAngle(rand()*Math.PI*2);
    const r=(INNER_R+4) + rand()*(ROAD_W-8);
    const x=Math.cos(a)*r, z=Math.sin(a)*r;
    const s=0.55 + rand()*0.95;
    const mesh=new THREE.Mesh(new THREE.DodecahedronGeometry(s,0), rockMat);
    mesh.position.set(x,0.15,z);
    mesh.rotation.set(rand()*3,rand()*3,rand()*3);
    scene.add(mesh);
    roadRocks.push({mesh,rad:s*0.95,hitCd:0});
  }
}
spawnRoadRocks();

/* ============================================================
   GAMEPLAY (LOCAL)
============================================================ */
let isRacing=false;
let lapStart=0;
let raceGoAtMs=0;

let stunUntil=0;
let boostReadyAt=0;
let lastHitAt=0;
let bumpSlowUntil=0;

let halfWay=false;
let lastProgress=0;

const keys={ forward:false,left:false,right:false,brake:false,boost:false };

function lapProgress(theta){
  const t=normAngle(theta);
  return normAngle(t - startTheta);
}

function armLocalRace(goAtMs){
  setCarAtStart();
  isRacing=true;
  raceGoAtMs = goAtMs || now();
  lapStart   = raceGoAtMs;
  stunUntil=0;
  bumpSlowUntil=0;
  halfWay=false;
  lastProgress=0;
}

function updateRoadRocks(dt){
  for(const r of roadRocks){
    r.hitCd=Math.max(0,r.hitCd-dt);
    const d=r.mesh.position.distanceTo(car.position);
    if(d < r.rad + CAR_R && r.hitCd<=0){
      r.hitCd=1.1;
      bumpSlowUntil=Math.max(bumpSlowUntil, now()+650);
      const back=new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);
      car.position.addScaledVector(back, 1.0);
    }
  }
}

function updateCar(dt){
  const t=now();

  // ‚úÖ hard gate: nobody moves until shared go-time
  if(t < raceGoAtMs){
    car.position.y=0.1;
    return;
  }

  const stunned = t < stunUntil;
  const ri = roadInfo(car.position.x, car.position.z);
  const onRoad = ri.onRoad;

  let speed = onRoad ? 22 : 12;
  if(keys.forward && !stunned) speed = onRoad ? 30 : 16;
  if(keys.brake && !stunned) speed *= 0.38;
  if(t < bumpSlowUntil) speed *= 0.72;

  const boosting = keys.boost && (t > boostReadyAt) && !stunned;
  if(boosting){
    speed = onRoad ? 46 : 26;
    boostReadyAt = t + 8000;
  }

  const turn=(keys.left?-1:0)+(keys.right?1:0);
  const turnRate = (keys.brake ? 2.85 : 2.30);
  car.rotation.y -= turn * dt * turnRate;

  const forward=new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion);
  car.position.addScaledVector(forward, speed*dt);
  car.position.y=0.1;

  const hitWall = enforceWalls();
  if(hitWall) bumpSlowUntil=Math.max(bumpSlowUntil, now()+350);

  const cdLeft=Math.max(0,(boostReadyAt - t)/1000);
  el("boostBtn").classList.toggle("onCd", cdLeft>0.01);

  const baseColor=new THREE.Color(0xff7a22);
  const boostColor=new THREE.Color(0x3bd7ff);
  car.flameMat.color.copy(baseColor).lerp(boostColor, boosting ? 1 : 0.15);
  const flameScale = boosting ? 2.05 : (cdLeft>0.01 ? 1.10 : 0.85);
  car.flame.scale.set(1, flameScale, flameScale);

  // lap detection
  const theta = Math.atan2(car.position.z, car.position.x);
  const prog = lapProgress(theta);

  if(prog > Math.PI) halfWay=true;

  // completed loop when we pass near start again after halfway
  if(halfWay && lastProgress > 6.0 && prog < 0.25){
    const lapSec = (t - lapStart)/1000;
    isRacing=false;
    submitLap(lapSec);
  }
  lastProgress=prog;
}

/* ============================================================
   CAMERA (‚úÖ zoom out on mobile + car lower in frame)
============================================================ */
function updateCamera(){
  const mobile=isMobile();

  // ‚úÖ significantly zoomed out on mobile
  const height = mobile ? 86 : 18;
  const behind = mobile ? 14 : 16;

  camera.fov = mobile ? 96 : 62;

  const back = new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);
  const desired = new THREE.Vector3(
    car.position.x + back.x*behind,
    height,
    car.position.z + back.z*behind
  );

  camera.position.lerp(desired, mobile ? 0.22 : 0.10);

  // ‚úÖ look slightly ABOVE car so the car sits a bit LOWER on screen (mobile especially)
  const lookY = mobile ? 2.8 : 1.2;
  camera.lookAt(car.position.x, lookY, car.position.z);
}

/* ============================================================
   UI (Minimal until finished; lap timer always visible)
============================================================ */
function updateUIMode(){
  const phase = raceState?.phase || "ready";
  // show full UI only after finished
  const minimal = (phase !== "finished");
  document.body.classList.toggle("uiMinimal", minimal);
}

function renderHUD(){
  const t=now();
  const lapElapsed = isRacing ? Math.max(0, ((t - lapStart)/1000)) : 0;
  el("lapTimer").textContent = lapElapsed.toFixed(3);

  el("roomText").textContent = (gameId||"‚Äî").slice(0, 14);

  const cdLeft=Math.max(0,(boostReadyAt-t)/1000);
  el("boostText").textContent = cdLeft ? `Cooldown ${cdLeft.toFixed(1)}s` : "Ready";

  const d=raceState;
  const phase=d?.phase||"‚Äî";
  let status="Connecting‚Ä¶";
  if(offlineMode) status="Offline";
  else if(!d) status="Connecting‚Ä¶";
  else if(phase==="ready") status="Ready-up";
  else if(phase==="countdown") status="Starting‚Ä¶";
  else if(phase==="racing") status=(t < raceGoAtMs) ? "Get set‚Ä¶" : "Racing";
  else if(phase==="finished") status="Finished";

  el("statusText").textContent=status;

  const parts=(d?.participants||[]).slice(0,MAX_PLAYERS);
  const players=d?.players||{};
  const act = (()=>{ try{ return activeParticipants(structuredClone(d)); }catch{ return parts; } })();
  const readyCount = act.filter(uid => !!players?.[uid]?.ready).length;
  el("playersText").textContent = d ? `${readyCount}/${act.length} ready` : "‚Äî";

  updateUIMode();
}

function renderResultsBoard(){
  if(!raceState) return;

  const d=raceState;
  const players=d.players||{};
  const parts=(d.participants||[]).slice(0,MAX_PLAYERS);

  const r = roster(d);
  const show = (d.phase==="finished") ? r : [];

  if(d.phase==="finished"){
    const winnerUid=d.winnerUid;
    el("tags").innerHTML = winnerUid
      ? `<span class="tag">üèÜ Winner: ${players[winnerUid]?.name||winnerUid.slice(0,6)}</span>`
      : `<span class="tag">üèÅ Finished</span>`;
    el("msg").textContent = "Results are shown below. Hit Rematch to run it again.";
  }else{
    el("tags").innerHTML = `<span class="tag">Room: ${(gameId||"").slice(0,14)}</span>`;
    el("msg").textContent = "UI stays hidden during the race ‚Äî only the lap timer shows.";
  }

  if(d.phase!=="finished"){
    el("scoreRows").innerHTML = "";
    return;
  }

  const rows = show.map(uid=>{
    const p=players[uid]||{};
    const time=p.lapTime;
    return {
      uid,
      name:p.name||uid.slice(0,6),
      time,
      note:(uid===d.winnerUid) ? "üèÜ Winner" : (typeof time==="number" ? "" : "‚Äî")
    };
  }).sort((a,b)=>((a.time??999)-(b.time??999)));

  el("scoreRows").innerHTML = rows.map(r=>`
    <tr class="${r.uid===myUid ? "youRow" : ""}">
      <td>${r.name}${r.uid===myUid?" (you)":""}</td>
      <td>${fmt(r.time)}</td>
      <td>${r.note}</td>
    </tr>
  `).join("");
}

async function copyInviteLink(){
  const u = new URL(location.href);
  u.searchParams.set("gameId", gameId);
  u.searchParams.set("username", username);
  try{
    await navigator.clipboard.writeText(u.toString());
  }catch(e){}
}

/* ============================================================
   OVERLAY (Ready -> Countdown -> Racing -> Finished)
============================================================ */
function renderOverlay(){
  if(offlineMode){
    showOverlay("offline","Offline / Auth Failed",
      `Firebase auth/sync failed.<br/><br/>
       If this is GitHub Pages, make sure <b>Anonymous Auth</b> is enabled in Firebase Console.`,
      [{label:"Reload", className:"warn", onClick:()=>location.reload()}]
    );
    return;
  }

  if(!raceState){
    showOverlay("conn","Connecting‚Ä¶",
      "Syncing room state‚Ä¶",
      [{label:"Fullscreen", className:"ghost", onClick:requestFullscreen}]
    );
    return;
  }

  const d=raceState;
  const t=now();
  const phase=d.phase;

  if(phase==="ready"){
    const act = (()=>{ try{ return activeParticipants(structuredClone(d)); }catch{ return (d.participants||[]); } })();
    const readyCount = act.filter(uid => !!d.players?.[uid]?.ready).length;
    const amReady = !!d.players?.[myUid]?.ready;

    showOverlay("ready","Ready Up",
      `Room: <b>${(gameId||"").slice(0,18)}</b><br/>
       Active ready: <b>${readyCount}/${act.length}</b><br/><br/>
       The race starts <b>as soon as everyone active hits Ready</b>.`,
      [
        {label: amReady ? "‚úÖ Ready (click to unready)" : "üèÅ Ready", onClick:()=>setMyReady(!amReady)},
        {label:"Copy Invite Link", className:"ghost", onClick:copyInviteLink},
        {label:"Fullscreen", className:"ghost", onClick:requestFullscreen}
      ]
    );
    return;
  }

  if(phase==="countdown"){
    const go=d.startAtMs||t;
    const s=Math.max(0, Math.ceil((go - t)/1000));
    showOverlay("countdown","Starting‚Ä¶",
      `Race begins in <b style="font-size:28px">${s}</b> seconds.`,
      [{label:"Fullscreen", className:"ghost", onClick:requestFullscreen}]
    );
    return;
  }

  if(phase==="racing"){
    // hide overlay once start time passes
    if(t < (d.startAtMs||t)){
      const s=Math.max(0, Math.ceil(((d.startAtMs||t)-t)/1000));
      showOverlay("countdown2","Get set‚Ä¶",
        `Starting in <b style="font-size:28px">${s}</b>`,
        []
      );
      return;
    }
    hideOverlay();
    return;
  }

  if(phase==="finished"){
    const w=d.winnerUid;
    const name=d.players?.[w]?.name || "‚Äî";
    const time=d.players?.[w]?.lapTime;
    showOverlay("finished","üèÜ Finished",
      `<b>${name}</b> wins (${fmt(time)}).<br/><br/>
       UI is now visible with results.`,
      [
        {label:"Rematch", onClick:rematch},
        {label:"Copy Invite Link", className:"ghost", onClick:copyInviteLink},
        {label:"Fullscreen", className:"ghost", onClick:requestFullscreen}
      ]
    );
    return;
  }

  hideOverlay();
}

/* ============================================================
   MAIN LOOP
============================================================ */
let prev=performance.now();
let lastW=0, lastH=0;
let armedStartAt=0;

function loop(ts){
  const dt=Math.min(.033,(ts-prev)/1000); prev=ts;

  updateRoadRocks(dt);

  // local race start/stop based on synced phase
  const phase=raceState?.phase;
  if(phase==="countdown" || phase==="racing"){
    const go=raceState?.startAtMs || now();
    if(!isRacing || armedStartAt!==go){
      armedStartAt=go;
      armLocalRace(go);
    }
    if(phase==="racing"){
      updateCar(dt);
    }
  }else{
    isRacing=false;
  }

  updateCamera();

  const w=innerWidth, h=innerHeight;
  if(w!==lastW || h!==lastH){
    lastW=w; lastH=h;
    renderer.setSize(w,h,false);
    camera.aspect=w/h;
    camera.updateProjectionMatrix();
  }

  renderer.render(scene,camera);

  renderHUD();
  renderResultsBoard();
  renderOverlay();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ============================================================
   CONTROLS
============================================================ */
function setupControls(){
  const fsBtn=el("mobileFsBtn");
  fsBtn?.addEventListener("click", requestFullscreen);
  updateFullscreenBtn();
  addEventListener("resize", updateFullscreenBtn);
  document.addEventListener("fullscreenchange", updateFullscreenBtn);

  addEventListener("blur", ()=>{ keys.forward=keys.left=keys.right=keys.brake=keys.boost=false; });
  document.addEventListener("visibilitychange", ()=>{
    if(document.hidden) keys.forward=keys.left=keys.right=keys.brake=keys.boost=false;
  });

  function keyDown(e){
    const code=e.code;
    if(code==="ArrowUp" || code==="KeyW") { keys.forward=true; e.preventDefault(); }
    if(code==="ArrowLeft"|| code==="KeyA") { keys.left=true; e.preventDefault(); }
    if(code==="ArrowRight"||code==="KeyD") { keys.right=true; e.preventDefault(); }
    if(code==="ArrowDown"||code==="KeyS") { keys.brake=true; e.preventDefault(); }
    if(code==="Space"){ keys.boost=true; e.preventDefault(); }
  }
  function keyUp(e){
    const code=e.code;
    if(code==="ArrowUp" || code==="KeyW") keys.forward=false;
    if(code==="ArrowLeft"|| code==="KeyA") keys.left=false;
    if(code==="ArrowRight"||code==="KeyD") keys.right=false;
    if(code==="ArrowDown"||code==="KeyS") keys.brake=false;
    if(code==="Space") keys.boost=false;
  }
  addEventListener("keydown", keyDown, {passive:false});
  addEventListener("keyup", keyUp, {passive:false});

  // Mobile pad
  const pad=el("pad"), dot=el("padDot");
  let padActive=false;

  function applyPad(clientX, clientY){
    const r=pad.getBoundingClientRect();
    const x=Math.max(0,Math.min(r.width, clientX-r.left));
    const y=Math.max(0,Math.min(r.height, clientY-r.top));

    dot.style.left=(x-13)+"px";
    dot.style.top=(y-13)+"px";

    keys.forward = y < r.height*0.82;
    keys.left    = x < r.width*0.40;
    keys.right   = x > r.width*0.60;
  }

  pad.addEventListener("pointerdown", (e)=>{
    padActive=true;
    pad.setPointerCapture?.(e.pointerId);
    applyPad(e.clientX, e.clientY);
    e.preventDefault();
  }, {passive:false});

  pad.addEventListener("pointermove", (e)=>{
    if(!padActive) return;
    applyPad(e.clientX, e.clientY);
    e.preventDefault();
  }, {passive:false});

  function endPad(){
    padActive=false;
    keys.forward=keys.left=keys.right=false;
    dot.style.left="62px";
    dot.style.top="62px";
  }
  pad.addEventListener("pointerup", endPad);
  pad.addEventListener("pointercancel", endPad);
  pad.addEventListener("pointerleave", ()=>{ if(padActive) endPad(); });

  // Boost button
  const boost=el("boostBtn");
  boost.addEventListener("pointerdown", (e)=>{ keys.boost=true; e.preventDefault(); }, {passive:false});
  boost.addEventListener("pointerup",   ()=>{ keys.boost=false; });
  boost.addEventListener("pointercancel",()=>{ keys.boost=false; });
  boost.addEventListener("pointerleave",()=>{ keys.boost=false; });
}
setupControls();

/* ============================================================
   STATE MACHINE TICK (prevents ‚Äúsyncing‚Äù stalls)
============================================================ */
function tickStateMachine(){
  if(!raceState) return;

  if(raceState.phase==="ready"){
    maybeStartIfAllReady();
  }
  if(raceState.phase==="countdown"){
    maybeFlipCountdownToRacing();
  }
  if(raceState.phase==="countdown" || raceState.phase==="racing"){
    finalizeDeadlineIfNeeded();
  }
}

/* ============================================================
   BOOT
============================================================ */
(async function main(){
  el("roomText").textContent = (gameId||"‚Äî").slice(0, 14);

  try{
    const u = await ensureAuthed();
    myUid = u.uid;
  }catch(e){
    offlineMode=true;
    showOverlay("authFail","Auth failed",
      `<b>${String(e?.code||"error")}</b><br/>${String(e?.message||e)}<br/><br/>
       Common fix: enable <b>Anonymous Auth</b> in Firebase Console.`,
      [{label:"Reload", className:"warn", onClick:()=>location.reload()}]
    );
    return;
  }

  await ensureRaceDoc();
  attachRaceListener();

  await joinRace();
  await presencePing();
  setInterval(presencePing, PRESENCE_PING_MS);
  setInterval(tickStateMachine, 800);
})();
</script>
</body>
</html>


