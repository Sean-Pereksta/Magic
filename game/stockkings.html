<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <title>üìà StockKings ‚Äî Donut Rush (1‚Äì8P)</title>
  <style>
    :root{
      --bg0:#050812;
      --bg1:#08122b;
      --bg2:#0b1b3f;
      --panel: rgba(14, 23, 38, .78);
      --panel2: rgba(8, 11, 19, .78);
      --line: rgba(87,178,255,.22);
      --line2: rgba(255,255,255,.08);
      --ink:#ecf3ff;
      --muted:#a9bad8;
      --muted2:#7f93b7;
      --accent:#57b2ff;
      --good:#60f0a1;
      --warn:#ffd972;
      --bad:#ff6f89;

      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --r: 14px;
      --r2: 12px;
    }

    *{ box-sizing:border-box; }
    html,body{
      height:100%;
      margin:0;
      color:var(--ink);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background:
        radial-gradient(1200px 900px at 20% 10%, rgba(87,178,255,.18), transparent 58%),
        radial-gradient(900px 700px at 80% 0%, rgba(96,240,161,.12), transparent 55%),
        radial-gradient(900px 700px at 50% 100%, rgba(255,111,137,.10), transparent 55%),
        linear-gradient(180deg, var(--bg2), var(--bg0));
      overflow:hidden;
    }

    /* subtle film grain */
    body::before{
      content:"";
      position:fixed; inset:0;
      pointer-events:none;
      opacity:.06;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='240' height='240'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='240' height='240' filter='url(%23n)' opacity='.55'/%3E%3C/svg%3E");
      mix-blend-mode:overlay;
    }

    #app{ position:relative; height:100%; width:100%; overflow:hidden; }
    #scene{
      position:absolute; inset:0;
      width:100%; height:100%;
      display:block;
      touch-action:none;
    }

    .hud{
      position:absolute; inset:0;
      pointer-events:none;
      display:flex;
      flex-direction:column;
      justify-content:space-between;
      padding:
        calc(12px + env(safe-area-inset-top))
        calc(12px + env(safe-area-inset-right))
        calc(12px + env(safe-area-inset-bottom))
        calc(12px + env(safe-area-inset-left));
      gap:12px;
    }

    .top{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:stretch;
    }

    .chip{
      pointer-events:auto;
      background: linear-gradient(180deg, rgba(14,23,38,.82), rgba(8,11,19,.72));
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 9px 11px;
      font-weight: 900;
      letter-spacing:.2px;
      box-shadow: 0 10px 28px rgba(0,0,0,.26);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      min-width: 128px;
      position:relative;
      overflow:hidden;
    }
    .chip::after{
      content:"";
      position:absolute; inset:-1px;
      border-radius:12px;
      background:
        radial-gradient(160px 70px at 20% 0%, rgba(87,178,255,.20), transparent 60%),
        radial-gradient(140px 70px at 80% 100%, rgba(96,240,161,.12), transparent 60%);
      opacity:.75;
      pointer-events:none;
      mix-blend-mode:screen;
    }
    .chip > *{ position:relative; z-index:1; }

    .chip small{
      display:block;
      color: var(--muted2);
      font-weight: 750;
      letter-spacing:.25px;
      margin-bottom:2px;
    }

    .big{ font-size: 24px; font-weight: 950; }

    .board{
      pointer-events:auto;
      background: linear-gradient(180deg, rgba(8,11,19,.90), rgba(14,23,38,.74));
      border: 1px solid var(--line);
      border-radius: var(--r);
      padding: 12px;
      max-width: 580px;
      max-height: 50vh;
      overflow:auto;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    .board h3{
      margin:0 0 10px;
      font-weight: 1000;
      letter-spacing:.2px;
    }

    table{
      width:100%;
      border-collapse:collapse;
      font-size: 13px;
      border-radius: 12px;
      overflow:hidden;
    }
    thead th{
      position:sticky;
      top:0;
      z-index:2;
      background: rgba(10,15,25,.92);
      border-bottom:1px solid var(--line2);
      padding:8px 8px;
      text-align:left;
      color:#dff0ff;
      font-weight:950;
      letter-spacing:.2px;
    }
    tbody td{
      padding:7px 8px;
      border-bottom:1px solid rgba(255,255,255,.06);
      color:#eaf3ff;
    }
    tbody tr:nth-child(odd) td{ background: rgba(255,255,255,.02); }
    tbody tr:hover td{ background: rgba(87,178,255,.06); }

    .youRow td{
      background: rgba(96,240,161,.06) !important;
      border-bottom: 1px solid rgba(96,240,161,.12);
    }

    .msg{
      font-size: 13px;
      color: var(--muted);
      margin-top: 10px;
      line-height:1.35;
    }

    .tags{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      margin-top:10px;
    }
    .tag{
      font-size: 12px;
      padding: 5px 9px;
      border-radius:999px;
      border:1px solid rgba(87,178,255,.22);
      background: rgba(87,178,255,.08);
      color: #cfe7ff;
      font-weight:850;
      letter-spacing:.15px;
    }

    /* Overlay modal */
    .modalWrap{
      position:absolute; inset:0;
      background: radial-gradient(900px 700px at 50% 10%, rgba(87,178,255,.14), transparent 55%),
                  rgba(3,6,12,.72);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      z-index:20;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }
    .modalWrap.show{ display:flex; }
    .modal{
      pointer-events:auto;
      background: linear-gradient(180deg, rgba(14,23,38,.92), rgba(8,11,19,.86));
      border:1px solid rgba(87,178,255,.28);
      border-radius: 18px;
      max-width: 780px;
      width: min(780px, 95vw);
      padding: 16px 16px 14px;
      box-shadow: 0 26px 90px rgba(0,0,0,.55);
      transform: translateY(0);
      animation: pop .14s ease-out;
      position:relative;
      overflow:hidden;
    }
    .modal::before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(380px 180px at 20% 0%, rgba(87,178,255,.20), transparent 60%),
        radial-gradient(320px 160px at 80% 100%, rgba(255,111,137,.14), transparent 60%);
      opacity:.7;
      pointer-events:none;
      mix-blend-mode:screen;
    }
    .modal > *{ position:relative; z-index:1; }

    @keyframes pop{
      from{ transform: translateY(8px) scale(.985); opacity:.0; }
      to  { transform: translateY(0) scale(1); opacity:1; }
    }

    .modal h2{ margin:0 0 8px; font-weight: 1050; letter-spacing:.2px; }
    .modal p{ margin:6px 0; color: var(--muted); line-height:1.35; }

    .btns{ display:flex; flex-wrap:wrap; gap:10px; margin-top:12px; }

    button{
      cursor:pointer;
      border: 1px solid rgba(87,178,255,.32);
      background: linear-gradient(180deg, rgba(29,75,128,.92), rgba(20,55,98,.92));
      color:#fff;
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 950;
      letter-spacing:.2px;
      box-shadow: 0 10px 24px rgba(0,0,0,.22);
      transition: transform .08s ease, filter .08s ease, opacity .08s ease;
      user-select:none;
    }
    button:hover{ filter: brightness(1.07); }
    button:active{ transform: translateY(1px); }
    button.ghost{
      background: linear-gradient(180deg, rgba(24,33,51,.86), rgba(18,25,40,.86));
      border-color: rgba(255,255,255,.14);
    }
    button.warn{
      background: linear-gradient(180deg, rgba(109,79,18,.92), rgba(84,58,12,.92));
      border-color: rgba(255,217,114,.35);
    }
    button:disabled{ opacity:.55; cursor:not-allowed; filter:none; transform:none; }

    /* Mobile controls */
    .controls{
      position:absolute;
      inset:auto 0 calc(10px + env(safe-area-inset-bottom)) 0;
      display:none;
      justify-content:space-between;
      padding:0 10px;
      z-index:8;
      pointer-events:none;
    }
    .pad,.boost{
      pointer-events:auto;
      background: rgba(8,14,24,.70);
      border: 1px solid rgba(87,178,255,.28);
      border-radius: 16px;
      touch-action:none;
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .pad{
      width:150px;height:150px;
      position:relative;
    }
    .pad::after{
      content:"";
      position:absolute; inset:10px;
      border-radius: 14px;
      border: 1px dashed rgba(255,255,255,.10);
      opacity:.55;
      pointer-events:none;
    }
    .padDot{
      position:absolute;
      width:26px;height:26px;
      border-radius:50%;
      background: radial-gradient(circle at 30% 30%, #bfe6ff, #2e8dff);
      left:62px; top:62px;
      pointer-events:none;
      box-shadow: 0 0 18px rgba(87,178,255,.55);
    }

    .boost{
      width:120px;height:120px;
      display:grid;
      place-items:center;
      font-weight:1050;
      letter-spacing:.5px;
      text-transform:uppercase;
    }
    .boost.onCd{
      background: rgba(45,18,18,.80);
      border-color: rgba(255,111,137,.36);
    }

    .mobileFsBtn{
      position:absolute;
      right:10px;
      top: calc(10px + env(safe-area-inset-top));
      z-index:12;
      display:none;
      padding: 9px 12px;
      border-radius: 12px;
      background: rgba(8,14,24,.74);
      border: 1px solid rgba(87,178,255,.28);
      color:#fff;
      font-weight: 900;
      letter-spacing:.2px;
      box-shadow: 0 12px 34px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .mobileFsBtn.show{ display:block; }

    @media (max-width:920px){
      html,body{ touch-action:none; }
      .controls{ display:flex; pointer-events:auto; }
      .board{ max-width:none; }
      .chip{ min-width: 118px; }
    }
  </style>
</head>
<body>
<div id="app">
  <canvas id="scene"></canvas>
  <button id="mobileFsBtn" class="mobileFsBtn" type="button">‚õ∂ Fullscreen</button>

  <div class="hud">
    <div class="top">
      <div class="chip"><small>Status</small><span id="statusText">Connecting‚Ä¶</span></div>
      <div class="chip"><small>Phase</small><span id="phaseText">‚Äî</span></div>
      <div class="chip"><small>Round</small><span id="roundText">‚Äî</span></div>
      <div class="chip"><small>Lap Timer</small><span class="big" id="lapTimer">00.000</span></div>
      <div class="chip"><small>Boost</small><span id="boostText">Ready</span></div>
    </div>

    <div class="board">
      <h3>üèÅ Round Results</h3>
      <table>
        <thead><tr><th>Player</th><th>R1</th><th>R2</th><th>R3</th><th>Avg</th></tr></thead>
        <tbody id="scoreRows"></tbody>
      </table>
      <div class="tags" id="threatTags"></div>
      <div class="msg" id="waitingMsg">‚Äî</div>
    </div>
  </div>

  <!-- Mobile controls only. (No extra UI for desktop controls, per request.) -->
  <div class="controls">
    <div class="pad" id="pad"><div class="padDot" id="padDot"></div></div>
    <button class="boost" id="boostBtn" type="button">BOOST</button>
  </div>

  <div class="modalWrap show" id="overlay">
    <div class="modal">
      <h2 id="overlayTitle">StockKings ‚Äî Donut Rush</h2>
      <p id="overlayBody">Connecting‚Ä¶</p>
      <div class="btns" id="overlayButtons"></div>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.162/build/three.module.js";
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getAuth, signInAnonymously, onAuthStateChanged, setPersistence, browserLocalPersistence, signOut } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
import { getFirestore, doc, getDoc, setDoc, onSnapshot, runTransaction } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

/* ============================================================
   FIREBASE INIT
============================================================ */
const firebaseConfig={
  apiKey:"AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain:"bible-game-246c0.firebaseapp.com",
  projectId:"bible-game-246c0",
  storageBucket:"bible-game-246c0.appspot.com",
  messagingSenderId:"959619818996",
  appId:"1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app=initializeApp(firebaseConfig);
const auth=getAuth(app);
const db=getFirestore(app);

const LS_USER="gh.username";
const LS_LOBBY="gh.lastLobbyId";

const params=new URLSearchParams(location.search);
const gameId=(params.get("gameId")||localStorage.getItem(LS_LOBBY)||"").trim();
const username=(params.get("username")||localStorage.getItem(LS_USER)||"Racer").trim();
if(gameId) localStorage.setItem(LS_LOBBY, gameId);
if(username) localStorage.setItem(LS_USER, username);

const LOBBY_REF = gameId ? doc(db,"lobbies",gameId) : null;
const RACE_REF  = gameId ? doc(db,"lobbies",gameId,"crowncouncil","stockkingsRace") : null;

/* ============================================================
   GAME CONFIG
============================================================ */
const COUNTDOWN_MS = 9000;
const DEADLINE_MS  = 30000;
const SELECT_MS    = 15000;
const MAX_ROUNDS   = 3;
const MAX_PLAYERS  = 8;

const OBSTACLES={
  meteorites:{name:"Meteorites",desc:"Telegraphed impacts that stun briefly.",stunMs:2200},
  monsters:{name:"Track Monsters",desc:"Roam the road and body-check racers."},
  eggs:{name:"Egg Storm",desc:"Bouncy eggs spill out and knock racers back."},
  towers:{name:"Lightning Towers",desc:"Periodic zaps near the ring."},
  rhinos:{name:"Rhino Stampede",desc:"Stampede around the donut and shove racers back."}
};
const obstacleOrder=Object.keys(OBSTACLES);

/* ============================================================
   DOM
============================================================ */
const el=id=>document.getElementById(id);

let overlayKey="";
function showOverlay(key,title,body,buttons){
  overlayKey=key;
  el("overlayTitle").textContent=title;
  el("overlayBody").innerHTML=body;
  const wrap=el("overlayButtons"); wrap.innerHTML="";
  (buttons||[]).forEach(b=>{
    const bt=document.createElement("button");
    bt.textContent=b.label;
    if(b.className) bt.className=b.className;
    if(b.disabled) bt.disabled=true;
    bt.type="button";
    bt.onclick=b.onClick||(()=>{});
    wrap.appendChild(bt);
  });
  el("overlay").classList.add("show");
}
function hideOverlay(){
  overlayKey="";
  el("overlay").classList.remove("show");
}

function isMobile(){ return innerWidth < 920; }

async function requestFullscreen(){
  try{
    const root=document.documentElement;
    if(document.fullscreenElement){
      await document.exitFullscreen?.();
      return;
    }
    await root.requestFullscreen?.();
  }catch(e){}
}

function updateFullscreenBtn(){
  const btn=el("mobileFsBtn");
  if(!btn) return;
  btn.classList.toggle("show", isMobile());
  btn.textContent=document.fullscreenElement?"üóó Exit Fullscreen":"‚õ∂ Fullscreen";
}

/* ============================================================
   AUTH-SAFE BOOTSTRAP
============================================================ */
async function ensureAuthed(){
  try{ await setPersistence(auth, browserLocalPersistence); }catch(e){}
  if(auth.currentUser) return auth.currentUser;

  try{ await signInAnonymously(auth); }catch(e){}

  return await new Promise((resolve, reject)=>{
    const timeout=setTimeout(()=>reject(new Error("auth-timeout")), 9000);
    const unsub=onAuthStateChanged(auth, (u)=>{
      if(u){
        clearTimeout(timeout);
        unsub();
        resolve(u);
      }
    });
  });
}

/* ============================================================
   RACE STATE
============================================================ */
let lobbyState=null;
let raceState=null;
let lobbyUnsub=null;
let raceUnsub=null;
let pendingTxn=false;
let retriedWithoutAuth=false;

function now(){ return Date.now(); }
function avg(arr){
  const v=(arr||[]).filter(n=>typeof n==="number");
  return v.length ? (v.reduce((a,b)=>a+b,0)/v.length) : null;
}
function fmt(n){ return typeof n==="number" ? n.toFixed(2)+"s" : "‚Äî"; }

function expectedPlayers(){
  return (raceState?.expectedPlayers && Array.isArray(raceState.expectedPlayers) && raceState.expectedPlayers.length)
    ? raceState.expectedPlayers
    : (lobbyState?.players || [username]);
}
function lobbyStarted(){ return (lobbyState?.status === "started"); }

async function txn(mutator){
  if(!RACE_REF) return;
  if(pendingTxn) return;
  pendingTxn=true;
  try{
    await runTransaction(db, async (tx)=>{
      const snap=await tx.get(RACE_REF);
      if(!snap.exists()) return;
      const d=snap.data();
      const out = mutator(d);
      if(!out) return;
      tx.set(RACE_REF, out, {merge:false});
    });
  }catch(e){
    showOverlay("txerr","Sync error",
      `<b>${String(e?.code||"error")}</b><br/>${String(e?.message||e)}`,
      [{label:"Back to Lobby", className:"warn", onClick:()=>location.href="/lobby/lobby.html"}]
    );
  }finally{
    pendingTxn=false;
  }
}

async function ensureRaceDoc(){
  if(!RACE_REF) return;
  const snap=await getDoc(RACE_REF);
  if(snap.exists()) return;

  const exp = (lobbyState?.players && lobbyState.players.length) ? lobbyState.players.slice(0,MAX_PLAYERS) : [username];
  const players = {};
  exp.forEach(n=>players[n]={name:n,laps:[],avg:null,lastLap:null});
  players[username]=players[username]||{name:username,laps:[],avg:null,lastLap:null};

  await setDoc(RACE_REF,{
    game:"stockkings-race",
    phase:"lobby_wait",
    round:1,
    maxRounds:MAX_ROUNDS,
    expectedPlayers:exp,
    players,
    obstacles:[],
    countdownEndsAt:null,
    deadlineAt:null,
    selector:null,
    selectEndsAt:null,
    winnerName:null,
    lastSelectorReason:"",
    updatedAtMs: now(),
    createdAtMs: now()
  }, {merge:false});
}

async function ensureMeInPlayers(){
  await txn((d)=>{
    const exp = (Array.isArray(d.expectedPlayers)&&d.expectedPlayers.length)
      ? d.expectedPlayers.slice(0,MAX_PLAYERS)
      : (lobbyState?.players||[username]).slice(0,MAX_PLAYERS);

    if(!exp.includes(username)) exp.push(username);
    exp.splice(MAX_PLAYERS);

    d.players = d.players || {};
    exp.forEach(n=>{
      if(!d.players[n]) d.players[n]={name:n,laps:[],avg:null,lastLap:null};
      d.players[n].laps = d.players[n].laps || [];
      d.players[n].avg  = (typeof d.players[n].avg==="number") ? d.players[n].avg : avg(d.players[n].laps);
    });

    d.expectedPlayers = exp;
    d.updatedAtMs = now();
    return d;
  });
}

function computeBottomSelector(d){
  const exp=(d.expectedPlayers||[]).slice(0,MAX_PLAYERS);
  const round=d.round||1;
  const players=d.players||{};
  const entries=exp.map(n=>{
    const t=players[n]?.laps?.[round-1];
    return {name:n, t:(typeof t==="number")?t:30};
  });
  const maxT=Math.max(...entries.map(e=>e.t));
  const bottoms=entries.filter(e=>e.t===maxT);
  return bottoms[Math.floor(Math.random()*bottoms.length)].name;
}

function computeWinner(d){
  const exp=(d.expectedPlayers||[]).slice(0,MAX_PLAYERS);
  const players=d.players||{};
  let bestName=null,best=1e18;
  exp.forEach(n=>{
    const a=avg(players[n]?.laps||[]);
    if(typeof a==="number" && a<best){best=a;bestName=n;}
  });
  return bestName || exp[0] || null;
}

async function maybeStartFromLobby(){
  if(!raceState || !lobbyStarted()) return;
  if(raceState.phase==="lobby_wait"){
    await txn((d)=>{
      if(d.phase!=="lobby_wait") return null;
      d.phase="countdown";
      d.countdownEndsAt=now()+COUNTDOWN_MS;
      d.updatedAtMs=now();
      return d;
    });
  }
}

async function advanceCountdownIfNeeded(){
  if(!raceState) return;
  if(raceState.phase!=="countdown") return;
  if(!raceState.countdownEndsAt) return;
  if(now() < raceState.countdownEndsAt) return;

  await txn((d)=>{
    if(d.phase!=="countdown") return null;
    if(now() < (d.countdownEndsAt||0)) return null;
    d.phase="racing";
    d.deadlineAt=null;
    d.selector=null;
    d.selectEndsAt=null;
    d.lastSelectorReason="";
    d.updatedAtMs=now();
    return d;
  });
}

async function finalizeDeadlineIfNeeded(){
  if(!raceState) return;
  if(raceState.phase!=="lap_wait") return;
  if(!raceState.deadlineAt) return;
  if(now() < raceState.deadlineAt) return;

  await txn((d)=>{
    if(d.phase!=="lap_wait") return null;
    if(now() < (d.deadlineAt||0)) return null;

    const round=d.round||1;
    const exp=(d.expectedPlayers||[]).slice(0,MAX_PLAYERS);
    d.players=d.players||{};
    exp.forEach(n=>{
      const p=d.players[n]||(d.players[n]={name:n,laps:[],avg:null,lastLap:null});
      p.laps=p.laps||[];
      if(typeof p.laps[round-1]!=="number"){
        p.laps[round-1]=30;
        p.lastLap=30;
        p.avg=avg(p.laps);
      }
    });

    if(round >= (d.maxRounds||MAX_ROUNDS)){
      d.phase="finished";
      d.winnerName=computeWinner(d);
      d.updatedAtMs=now();
      return d;
    }

    d.phase="obstacle_select";
    d.selector=computeBottomSelector(d);
    d.selectEndsAt=now()+SELECT_MS;
    d.lastSelectorReason="Deadline reached ‚Äî slowest lap chooses next threat.";
    d.deadlineAt=null;
    d.updatedAtMs=now();
    return d;
  });
}

async function chooseThreat(type=null, auto=false){
  if(!raceState) return;
  if(raceState.phase!=="obstacle_select") return;

  await txn((d)=>{
    if(d.phase!=="obstacle_select") return null;

    const exp=(d.expectedPlayers||[]).slice(0,MAX_PLAYERS);
    const single = exp.length<=1;
    const canPick = single || auto || (d.selector===username);
    if(!canPick) return null;

    const used=Array.isArray(d.obstacles)?d.obstacles.slice():[];
    const all=obstacleOrder;
    const avail=all.filter(o=>!used.includes(o));

    let pick=(type && all.includes(type))?type:null;
    if(!pick) pick = (avail.length ? avail : all)[Math.floor(Math.random()*(avail.length?avail.length:all.length))];
    if(avail.length && used.includes(pick)) pick = avail[Math.floor(Math.random()*avail.length)];

    if(avail.length){
      if(!used.includes(pick)) used.push(pick);
    }else{
      used.push(pick);
    }

    d.obstacles=used;
    d.round=(d.round||1)+1;
    d.phase="countdown";
    d.countdownEndsAt=now()+COUNTDOWN_MS;
    d.selector=null;
    d.selectEndsAt=null;
    d.deadlineAt=null;
    d.lastSelectorReason = auto ? "Auto-picked (timeout / solo)." : "";
    d.updatedAtMs=now();
    return d;
  });
}

async function autoPickIfNeeded(){
  if(!raceState) return;
  if(raceState.phase!=="obstacle_select") return;

  const exp=expectedPlayers();
  const single=exp.length<=1;

  if(single){
    await chooseThreat(null,true);
    return;
  }
  if(raceState.selectEndsAt && now() >= raceState.selectEndsAt){
    await chooseThreat(null,true);
  }
}

async function submitLap(lapSeconds){
  await txn((d)=>{
    const round=d.round||1;
    const maxRounds=d.maxRounds||MAX_ROUNDS;
    const exp=(d.expectedPlayers||[]).slice(0,MAX_PLAYERS);
    if(!exp.includes(username)) exp.push(username);
    exp.splice(MAX_PLAYERS);

    if(!(d.phase==="racing" || d.phase==="lap_wait")) return null;
    if(d.deadlineAt && now() > d.deadlineAt) return null;

    d.players=d.players||{};
    const me=d.players[username]||(d.players[username]={name:username,laps:[],avg:null,lastLap:null});
    me.laps=me.laps||[];
    if(typeof me.laps[round-1]==="number") return null;

    const time=Math.min(30, Math.max(0.5, lapSeconds));
    me.laps[round-1]=time;
    me.lastLap=time;
    me.avg=avg(me.laps);

    exp.forEach(n=>{
      const p=d.players[n]||(d.players[n]={name:n,laps:[],avg:null,lastLap:null});
      p.laps=p.laps||[];
      p.avg=(typeof p.avg==="number")?p.avg:avg(p.laps);
    });
    d.expectedPlayers=exp;

    const done=exp.map(n=>typeof d.players[n]?.laps?.[round-1]==="number");
    const anyFinished=done.some(Boolean);
    const everyoneDone=done.every(Boolean);

    if(everyoneDone){
      if(round >= maxRounds){
        d.phase="finished";
        d.winnerName=computeWinner(d);
        d.updatedAtMs=now();
        return d;
      }
      d.phase="obstacle_select";
      d.selector=computeBottomSelector(d);
      d.selectEndsAt=now()+SELECT_MS;
      d.lastSelectorReason="Slowest lap chooses next threat.";
      d.deadlineAt=null;
      d.updatedAtMs=now();
      return d;
    }

    if(!d.deadlineAt && anyFinished){
      d.phase="lap_wait";
      d.deadlineAt=now()+DEADLINE_MS;
      d.updatedAtMs=now();
      return d;
    }

    d.updatedAtMs=now();
    return d;
  });
}

/* ============================================================
   THREE WORLD ‚Äî polished look (procedural textures)
============================================================ */
const renderer=new THREE.WebGLRenderer({canvas:el("scene"), antialias:true, alpha:true});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.08;

const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(62,1,0.1,1400);

function makeCanvasTexture(drawFn, w=512, h=512){
  const c=document.createElement("canvas");
  c.width=w; c.height=h;
  const g=c.getContext("2d");
  drawFn(g,w,h);
  const tex=new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy?.()||8);
  return tex;
}

const skyTex = makeCanvasTexture((g,w,h)=>{
  const grd=g.createLinearGradient(0,0,0,h);
  grd.addColorStop(0, "#93d8ff");
  grd.addColorStop(.45, "#69b8ff");
  grd.addColorStop(1, "#2a5c9b");
  g.fillStyle=grd; g.fillRect(0,0,w,h);

  // soft clouds
  for(let i=0;i<70;i++){
    const x=Math.random()*w, y=Math.random()*h*0.55;
    const r=30+Math.random()*90;
    const a=.04+Math.random()*.06;
    const rg=g.createRadialGradient(x,y,0,x,y,r);
    rg.addColorStop(0, `rgba(255,255,255,${a})`);
    rg.addColorStop(1, "rgba(255,255,255,0)");
    g.fillStyle=rg;
    g.beginPath(); g.arc(x,y,r,0,Math.PI*2); g.fill();
  }
}, 1024, 1024);
scene.background = skyTex;

scene.fog = new THREE.FogExp2(0x6aaef5, 0.009);

scene.add(new THREE.HemisphereLight(0xd8f1ff, 0x1e4a2b, 1.05));
const sun=new THREE.DirectionalLight(0xffffff, 1.05);
sun.position.set(30, 55, 25);
scene.add(sun);

const grassTex = makeCanvasTexture((g,w,h)=>{
  g.fillStyle="#2f8d44"; g.fillRect(0,0,w,h);
  for(let i=0;i<12000;i++){
    const x=(Math.random()*w)|0, y=(Math.random()*h)|0;
    const v=40+Math.random()*60;
    g.fillStyle=`rgba(${10+v/3|0},${110+v|0},${30+v/4|0},${.08+Math.random()*.12})`;
    g.fillRect(x,y,1,1);
  }
  // faint mowing bands
  g.globalAlpha=.08;
  for(let y=0;y<h;y+=20){
    g.fillStyle = (y/20)%2 ? "#000" : "#fff";
    g.fillRect(0,y,w,10);
  }
  g.globalAlpha=1;
}, 768, 768);
grassTex.repeat.set(4,4);

const ground=new THREE.Mesh(
  new THREE.PlaneGeometry(420,420),
  new THREE.MeshStandardMaterial({map:grassTex, roughness:.98, metalness:0})
);
ground.rotation.x=-Math.PI/2;
scene.add(ground);

const roadTex = makeCanvasTexture((g,w,h)=>{
  // baked dirt + specks
  g.fillStyle="#8a5d30"; g.fillRect(0,0,w,h);
  for(let i=0;i<14000;i++){
    const x=(Math.random()*w)|0, y=(Math.random()*h)|0;
    const v=120+Math.random()*80;
    g.fillStyle=`rgba(${v|0},${(v*0.72)|0},${(v*0.40)|0},${.09+Math.random()*.12})`;
    g.fillRect(x,y,1,1);
  }
  // subtle tire streak arcs
  g.globalAlpha=.12;
  g.strokeStyle="#000";
  g.lineWidth=6;
  for(let i=0;i<24;i++){
    g.beginPath();
    const y=h*(i/24);
    g.arc(w/2, y, 260+Math.random()*110, 0, Math.PI*2);
    g.stroke();
  }
  g.globalAlpha=1;

  // lane stripe (center) - we draw a horizontal stripe so it repeats nicely
  g.globalAlpha=.10;
  g.fillStyle="#ffffff";
  g.fillRect(0, h*0.49, w, h*0.02);
  g.globalAlpha=1;
}, 768, 768);
roadTex.repeat.set(2, 2);

const ROAD_R = 52;   // centerline radius
const ROAD_W = 34;   // width
const INNER_R = ROAD_R - ROAD_W/2;
const OUTER_R = ROAD_R + ROAD_W/2;

const road = new THREE.Mesh(
  new THREE.RingGeometry(INNER_R, OUTER_R, 160, 1),
  new THREE.MeshStandardMaterial({map:roadTex, roughness:.90, metalness:.02})
);
road.rotation.x=-Math.PI/2;
road.position.y=0.02;
scene.add(road);

// lane stripe ring (nice bright)
const stripe = new THREE.Mesh(
  new THREE.RingGeometry(ROAD_R-0.35, ROAD_R+0.35, 180, 1),
  new THREE.MeshBasicMaterial({color:0xe9f2ff, transparent:true, opacity:0.50})
);
stripe.rotation.x=-Math.PI/2;
stripe.position.y=0.03;
scene.add(stripe);

// walls (visual)
function wallCylinder(radius, color){
  const m=new THREE.Mesh(
    new THREE.CylinderGeometry(radius, radius, 2.1, 180, 1, true),
    new THREE.MeshStandardMaterial({color, roughness:.78, metalness:.08, side:THREE.DoubleSide})
  );
  m.position.y=1.05;
  return m;
}
const innerWall = wallCylinder(INNER_R, 0x2e3a4d);
const outerWall = wallCylinder(OUTER_R, 0x2e3a4d);
scene.add(innerWall, outerWall);

// start line
const startLine = new THREE.Mesh(
  new THREE.PlaneGeometry(ROAD_W, 3.0),
  new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.62, side:THREE.DoubleSide})
);
startLine.rotation.x=-Math.PI/2;
startLine.position.set(ROAD_R, 0.031, 0);
startLine.rotation.z=Math.PI/2;
scene.add(startLine);

/* ============================================================
   CAR + BOOST FLAME
============================================================ */
function buildCar(){
  const g=new THREE.Group();
  const body=new THREE.Mesh(
    new THREE.BoxGeometry(2.4,.85,3.8),
    new THREE.MeshStandardMaterial({color:0x1f74ff, metalness:.28, roughness:.34})
  );
  body.position.y=.9;
  const top=new THREE.Mesh(
    new THREE.BoxGeometry(1.6,.65,1.7),
    new THREE.MeshStandardMaterial({color:0xd8e8ff, metalness:.06, roughness:.45})
  );
  top.position.set(0,1.38,-.15);
  g.add(body, top);

  [[-.9,.35,-1.15],[.9,.35,-1.15],[-.9,.35,1.15],[.9,.35,1.15]].forEach(([x,y,z])=>{
    const w=new THREE.Mesh(
      new THREE.CylinderGeometry(.40,.40,.36,18),
      new THREE.MeshStandardMaterial({color:0x101218, roughness:.92, metalness:.05})
    );
    w.rotation.z=Math.PI/2;
    w.position.set(x,y,z);
    g.add(w);
  });

  const flameMat=new THREE.MeshBasicMaterial({color:0xff7a22, transparent:true, opacity:.92});
  const flame=new THREE.Mesh(new THREE.ConeGeometry(.26,1.28,12), flameMat);
  flame.position.set(0,.9,2.3);
  flame.rotation.x=Math.PI/2;
  g.add(flame);
  g.flame=flame; g.flameMat=flameMat;

  g.scale.set(0.82,0.82,0.82);
  return g;
}
const car=buildCar();
scene.add(car);

const START_A = 0; // start at (ROAD_R, 0)
function setCarAtStart(){
  const x=Math.cos(START_A)*ROAD_R;
  const z=Math.sin(START_A)*ROAD_R;
  car.position.set(x,0.1,z);

  car.rotation.set(0,0,0);
  car.rotation.y = Math.atan2(0,1) + Math.PI;
}
setCarAtStart();

/* ============================================================
   TRACK HELPERS + WALL COLLISION
============================================================ */
const CAR_R = 1.05;

function normAngle(a){
  const two=Math.PI*2;
  a%=two; if(a<0) a+=two;
  return a;
}
const startTheta = normAngle(START_A);

function roadInfo(x,z){
  const r=Math.hypot(x,z);
  const onRoad = (r>INNER_R+0.25 && r<OUTER_R-0.25);
  const distToEdge = Math.min(Math.abs(r-INNER_R), Math.abs(OUTER_R-r));
  return {r,onRoad,distToEdge};
}

function enforceWalls(){
  const r=Math.hypot(car.position.x, car.position.z) || 0.0001;
  const nx=car.position.x/r;
  const nz=car.position.z/r;

  const minR = INNER_R + CAR_R;
  if(r < minR){
    car.position.x = nx*minR;
    car.position.z = nz*minR;
    return true;
  }
  const maxR = OUTER_R - CAR_R;
  if(r > maxR){
    car.position.x = nx*maxR;
    car.position.z = nz*maxR;
    return true;
  }
  return false;
}

/* ============================================================
   THREATS + FX
============================================================ */
const threats=[];
const boomFX=[];
function addBoom(pos, colorHex){
  const ring=new THREE.Mesh(
    new THREE.RingGeometry(0.2,0.7,36),
    new THREE.MeshBasicMaterial({color:colorHex, transparent:true, opacity:0.86, side:THREE.DoubleSide})
  );
  ring.rotation.x=-Math.PI/2;
  ring.position.set(pos.x,0.07,pos.z);
  scene.add(ring);
  boomFX.push({mesh:ring,life:0.5});
}
function clearThreats(){
  threats.splice(0).forEach(t=>scene.remove(t.mesh));
  boomFX.splice(0).forEach(b=>scene.remove(b.mesh));
}
function spawnThreats(){
  clearThreats();
  const active=(raceState?.obstacles||[]);
  if(!active.length) return;

  const pickR = ()=> (INNER_R+4) + Math.random()*(ROAD_W-8);
  active.forEach((type,stackIdx)=>{
    const n = 3 + Math.min(2, stackIdx);
    for(let i=0;i<n;i++){
      const a = normAngle((stackIdx*0.95 + i*(Math.PI*2/n) + (Math.random()-.5)*0.22));
      const r = pickR();
      const x=Math.cos(a)*r;
      const z=Math.sin(a)*r;

      let mesh=null;

      if(type==="meteorites"){
        mesh=new THREE.Mesh(
          new THREE.CylinderGeometry(2.2,2.2,.06,30),
          new THREE.MeshBasicMaterial({color:0xffc266, transparent:true, opacity:0.34})
        );
        mesh.position.set(x,0.06,z);
        threats.push({type,mesh,rad:2.3,timer:1.8+Math.random()*3.2,hot:0});
      }

      if(type==="monsters"){
        mesh=new THREE.Mesh(
          new THREE.BoxGeometry(1.6,1.7,1.6),
          new THREE.MeshStandardMaterial({color:0x6f32a8, roughness:.62, metalness:.06, emissive:0x1a0830, emissiveIntensity:.35})
        );
        mesh.position.set(x,0.95,z);
        threats.push({type,mesh,rad:1.8,da:(Math.random()>.5?1:-1)*(0.5+Math.random()*0.7),a, r});
      }

      if(type==="eggs"){
        mesh=new THREE.Mesh(
          new THREE.SphereGeometry(.82,18,12),
          new THREE.MeshStandardMaterial({color:0xf4efe5, roughness:.45, metalness:0})
        );
        mesh.position.set(x,.82,z);
        threats.push({type,mesh,rad:1.25,v:new THREE.Vector2((Math.random()-.5)*2.6,(Math.random()-.5)*2.6)});
      }

      if(type==="towers"){
        mesh=new THREE.Group();
        const p=new THREE.Mesh(
          new THREE.CylinderGeometry(.75,1.05,4.3,10),
          new THREE.MeshStandardMaterial({color:0x3e4b63, roughness:.85})
        );
        p.position.y=2.1;
        const ring=new THREE.Mesh(
          new THREE.RingGeometry(2.8,3.4,30),
          new THREE.MeshBasicMaterial({color:0x9ec9ff, side:THREE.DoubleSide, transparent:true, opacity:.55})
        );
        ring.rotation.x=-Math.PI/2;
        const core=new THREE.Mesh(
          new THREE.SphereGeometry(.28,14,10),
          new THREE.MeshBasicMaterial({color:0xbfe0ff})
        );
        core.position.y=4.15;
        mesh.add(p,ring,core);
        mesh.position.set(x,0,z);
        threats.push({type,mesh,rad:3.2,flash:0,cool:0.9+Math.random()*2.1});
      }

      if(type==="rhinos"){
        mesh=new THREE.Mesh(
          new THREE.BoxGeometry(2.2,1.4,3.2),
          new THREE.MeshStandardMaterial({color:0x7b7f86, roughness:.82, metalness:.08})
        );
        mesh.position.set(x,.7,z);
        threats.push({type,mesh,rad:2.1,a, r: ROAD_R + (Math.random()-.5)*(ROAD_W*0.2)});
      }

      if(mesh) scene.add(mesh);
    }
  });
}

/* ============================================================
   ROAD ROCKS
============================================================ */
function hashSeed(s){
  let h=2166136261>>>0;
  for(let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h = Math.imul(h,16777619); }
  return h>>>0;
}
function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
}
const rand = mulberry32(hashSeed(gameId||"solo"));
const roadRocks=[];
function spawnRoadRocks(){
  roadRocks.splice(0).forEach(r=>scene.remove(r.mesh));
  const rockMat=new THREE.MeshStandardMaterial({color:0x565b62, roughness:.97});
  for(let i=0;i<26;i++){
    const a=normAngle(rand()*Math.PI*2);
    const r=(INNER_R+4) + rand()*(ROAD_W-8);
    const x=Math.cos(a)*r, z=Math.sin(a)*r;

    const s=0.55 + rand()*0.95;
    const mesh=new THREE.Mesh(new THREE.DodecahedronGeometry(s,0), rockMat);
    mesh.position.set(x,0.15,z);
    mesh.rotation.set(rand()*3,rand()*3,rand()*3);
    scene.add(mesh);
    roadRocks.push({mesh,rad:s*0.95,hitCd:0});
  }
}
spawnRoadRocks();

/* ============================================================
   GAMEPLAY (LOCAL)
============================================================ */
let isRacing=false;
let lapStart=0;
let stunUntil=0;
let boostReadyAt=0;
let lastHitAt=0;
let bumpSlowUntil=0;

let halfWay=false;
let lastProgress=0;

// Desktop + mobile input state (NO extra UI added for desktop)
const keys={
  forward:false,
  left:false,
  right:false,
  brake:false,   // S / ArrowDown (adds real WASD)
  boost:false
};

function startLapLocal(){
  setCarAtStart();
  isRacing=true;
  lapStart=now();
  stunUntil=0;
  bumpSlowUntil=0;
  halfWay=false;
  lastProgress=0;
}

function lapProgress(theta){
  const t=normAngle(theta);
  return normAngle(t - startTheta);
}

function updateFX(dt){
  for(let i=boomFX.length-1;i>=0;i--){
    const b=boomFX[i];
    b.life-=dt;
    const s=1+(0.5-b.life)*5.2;
    b.mesh.scale.set(s,s,s);
    b.mesh.material.opacity=Math.max(0,b.life/0.5)*0.86;
    if(b.life<=0){ scene.remove(b.mesh); boomFX.splice(i,1); }
  }
}

function updateThreats(dt){
  updateFX(dt);

  threats.forEach(t=>{
    if(t.type==="meteorites"){
      t.timer -= dt;
      t.hot = Math.max(0, t.hot - dt);
      if(t.timer <= 0){
        t.timer = 2.6 + Math.random()*3.2;
        t.hot   = 0.28;
        t.mesh.material.color.setHex(0xff4b4b);
        addBoom(t.mesh.position, 0xff4b4b);
        setTimeout(()=>{ if(t.mesh?.material) t.mesh.material.color.setHex(0xffc266); }, 220);
      }
    }

    if(t.type==="monsters"){
      t.a = normAngle(t.a + t.da*dt*0.45);
      const x=Math.cos(t.a)*t.r, z=Math.sin(t.a)*t.r;
      t.mesh.position.set(x,0.95,z);
    }

    if(t.type==="eggs"){
      t.mesh.position.x += t.v.x*dt;
      t.mesh.position.z += t.v.y*dt;
      t.v.multiplyScalar(0.985);
    }

    if(t.type==="towers"){
      t.flash = Math.max(0, t.flash-dt);
      t.cool -= dt;
      if(t.cool<=0){
        t.cool = 0.9 + Math.random()*2.1;
        t.flash = 0.22;
        addBoom(t.mesh.position, 0x9ec9ff);
      }
      const ring=t.mesh.children[1];
      ring.material.opacity = 0.42 + (t.flash*2.0);
    }

    if(t.type==="rhinos"){
      t.a = normAngle(t.a + dt*0.9);
      const x=Math.cos(t.a)*t.r, z=Math.sin(t.a)*t.r;
      t.mesh.position.set(x,0.7,z);
    }

    const d=t.mesh.position.distanceTo(car.position);
    if(d < t.rad + CAR_R && now()-lastHitAt>1200){
      if(t.type==="meteorites" && t.hot<=0) return;

      lastHitAt=now();
      if(t.type==="meteorites"||t.type==="towers"){
        stunUntil=Math.max(stunUntil, now() + (t.type==="meteorites"?2200:1700));
      }
      if(t.type==="eggs"){
        const back=new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);
        car.position.addScaledVector(back, 2.6);
        t.dead=true;
        addBoom(t.mesh.position, 0xffffff);
      }
      if(t.type==="rhinos"||t.type==="monsters"){
        const back=new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);
        car.position.addScaledVector(back, 6.0);
        stunUntil=Math.max(stunUntil, now()+900);
        addBoom(car.position, 0xff6f89);
      }
    }
  });

  for(let i=threats.length-1;i>=0;i--){
    if(threats[i].dead){ scene.remove(threats[i].mesh); threats.splice(i,1); }
  }
}

function updateRoadRocks(dt){
  for(const r of roadRocks){
    r.hitCd=Math.max(0,r.hitCd-dt);
    const d=r.mesh.position.distanceTo(car.position);
    if(d < r.rad + CAR_R && r.hitCd<=0){
      r.hitCd=1.1;
      bumpSlowUntil=Math.max(bumpSlowUntil, now()+650);
      const back=new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);
      car.position.addScaledVector(back, 1.0);
      addBoom(r.mesh.position, 0x5a5f66);
    }
  }
}

function updateCar(dt){
  const t=now();
  const stunned = t < stunUntil;

  const ri = roadInfo(car.position.x, car.position.z);
  const onRoad = ri.onRoad;

  // base speed (coast)
  let speed = onRoad ? 22 : 12;

  // forward (W / ArrowUp) accelerates
  if(keys.forward && !stunned) speed = onRoad ? 30 : 16;

  // brake (S / ArrowDown) slows hard (adds full WASD)
  if(keys.brake && !stunned) speed *= 0.38;

  // bumps
  if(t < bumpSlowUntil) speed *= 0.72;

  // boost (Space or mobile button)
  const boosting = keys.boost && (t > boostReadyAt) && !stunned;
  if(boosting){
    speed = onRoad ? 46 : 26;
    boostReadyAt = t + 8000;
    addBoom(car.position, 0x3bd7ff);
  }

  // steering (slightly tighter while braking)
  const turn=(keys.left?-1:0)+(keys.right?1:0);
  const turnRate = (keys.brake ? 2.85 : 2.30);
  car.rotation.y -= turn * dt * turnRate;

  // move forward along car direction
  const forward=new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion);
  car.position.addScaledVector(forward, speed*dt);
  car.position.y=0.1;

  // inner/outer walls
  const hitWall = enforceWalls();
  if(hitWall){
    bumpSlowUntil=Math.max(bumpSlowUntil, now()+350);
  }

  // boost button cooldown UI (mobile)
  const cdLeft=Math.max(0,(boostReadyAt - t)/1000);
  el("boostBtn").classList.toggle("onCd", cdLeft>0.01);

  // flame visuals
  const baseColor=new THREE.Color(0xff7a22);
  const boostColor=new THREE.Color(0x3bd7ff);
  car.flameMat.color.copy(baseColor).lerp(boostColor, boosting ? 1 : 0.15);
  const flameScale = boosting ? 2.05 : (cdLeft>0.01 ? 1.10 : 0.85);
  car.flame.scale.set(1, flameScale, flameScale);

  // lap detection
  const theta = Math.atan2(car.position.z, car.position.x);
  const prog = lapProgress(theta);

  if(prog > Math.PI) halfWay=true;

  // completed loop when we pass near start again after halfway
  if(halfWay && lastProgress > 6.0 && prog < 0.25){
    const lapSec=(t-lapStart)/1000;
    isRacing=false;
    submitLap(lapSec);
  }
  lastProgress=prog;
}

/* ============================================================
   CAMERA
============================================================ */
function updateCamera(){
  const mobile = isMobile();
  const height = mobile ? 56 : 18;
  const behind = mobile ? 8 : 16;

  camera.fov = mobile ? 84 : 62;

  const back = new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);
  const desired = new THREE.Vector3(
    car.position.x + back.x*behind,
    height,
    car.position.z + back.z*behind
  );
  camera.position.lerp(desired, mobile ? 0.2 : 0.10);
  camera.lookAt(car.position.x, 1.2, car.position.z);
}

/* ============================================================
   UI
============================================================ */
function renderBoard(){
  const exp=expectedPlayers().slice(0,MAX_PLAYERS);
  const players=raceState?.players||{};
  const rows=exp.map(n=>{
    const p=players[n]||{laps:[]};
    const laps=p.laps||[];
    return {name:n,l1:laps[0],l2:laps[1],l3:laps[2],avg:avg(laps)};
  }).sort((a,b)=>((a.avg??999)-(b.avg??999)));

  el("scoreRows").innerHTML = rows.map(r=>`
    <tr class="${r.name===username ? "youRow" : ""}">
      <td>${r.name}${r.name===username?" (you)":""}</td>
      <td>${fmt(r.l1)}</td>
      <td>${fmt(r.l2)}</td>
      <td>${fmt(r.l3)}</td>
      <td>${fmt(r.avg)}</td>
    </tr>`).join("");

  el("phaseText").textContent = (raceState?.phase||"‚Äî").replaceAll("_"," ");
  el("roundText").textContent = `${raceState?.round||1} / ${raceState?.maxRounds||MAX_ROUNDS}`;

  const used=(raceState?.obstacles||[]);
  el("threatTags").innerHTML = used.length
    ? used.map(o=>`<span class="tag">‚ö†Ô∏è ${OBSTACLES[o]?.name||o}</span>`).join("")
    : `<span class="tag">No threats yet</span>`;

  const phase=raceState?.phase||"";
  const t=now();
  if(!lobbyState) el("waitingMsg").textContent="Connecting to lobby‚Ä¶";
  else if(!lobbyStarted()) el("waitingMsg").textContent="Waiting for lobby host to start‚Ä¶";
  else if(phase==="countdown"){
    const s=Math.max(0, Math.ceil(((raceState?.countdownEndsAt||t)-t)/1000));
    el("waitingMsg").textContent=`Round starts in ${s}s.`;
  }else if(phase==="lap_wait"){
    const s=Math.max(0, Math.ceil(((raceState?.deadlineAt||t)-t)/1000));
    el("waitingMsg").textContent=`Waiting for racers‚Ä¶ ${s}s until timeouts.`;
  }else if(phase==="obstacle_select"){
    el("waitingMsg").textContent=(raceState?.selector===username)
      ? "You were slowest ‚Äî choose the next threat!"
      : `Waiting for ${raceState?.selector||"slowest racer"} to choose threat‚Ä¶`;
  }else if(phase==="racing"){
    el("waitingMsg").textContent="Race!";
  }else if(phase==="finished"){
    el("waitingMsg").textContent=`üèÜ Winner: ${raceState?.winnerName||"‚Äî"}`;
  }else{
    el("waitingMsg").textContent="Syncing‚Ä¶";
  }
}

function renderOverlay(){
  if(!gameId){
    showOverlay("nogame","Missing gameId",
      "Open StockKings from the Lobby so multiplayer syncing works.",
      [{label:"Back to Lobby", className:"warn", onClick:()=>location.href="/lobby/lobby.html"}]
    );
    return;
  }

  if(!lobbyState){
    showOverlay("connLobby","Connecting to Lobby‚Ä¶",
      "Waiting for Firestore lobby doc access‚Ä¶",
      []
    );
    return;
  }

  if(!lobbyStarted()){
    showOverlay("waitStart","Waiting for Lobby Start",
      "Host hasn‚Äôt started the match yet. Go back and press <b>Start Game</b>.",
      [{label:"Back to Lobby", className:"warn", onClick:()=>location.href="/lobby/lobby.html"}]
    );
    return;
  }

  if(!raceState){
    showOverlay("connRace","Connecting to Race State‚Ä¶","Creating/reading race doc‚Ä¶",[]);
    return;
  }

  const phase=raceState.phase;
  const t=now();

  if(phase==="countdown"){
    const s=Math.max(0, Math.ceil(((raceState.countdownEndsAt||t)-t)/1000));
    showOverlay("countdown","Race starts soon",
      `<b style="font-size:28px">${s}</b> seconds until launch.<br/>Boost cooldown: <b>8s</b>.<br/>Threats stack each round.`,
      [
        {label:"Fullscreen", className:"warn", onClick:requestFullscreen},
        {label:"Ready", className:"ghost", onClick:hideOverlay}
      ]
    );
    return;
  }

  if(phase==="obstacle_select"){
    const exp=expectedPlayers();
    const single=exp.length<=1;

    const used=raceState.obstacles||[];
    const avail=obstacleOrder.filter(o=>!used.includes(o));
    const options=(avail.length?avail:obstacleOrder);

    const canPick = single || (raceState.selector===username);
    const end=raceState.selectEndsAt || (t+SELECT_MS);
    const s=Math.max(0, Math.ceil((end-t)/1000));
    const reason=raceState.lastSelectorReason || "Slowest lap chooses the next threat.";

    const buttons = canPick
      ? options.map(o=>({label:OBSTACLES[o].name, onClick:()=>chooseThreat(o,false)}))
        .concat([{label:"Random", className:"ghost", onClick:()=>chooseThreat(null,false)}])
      : [{label:"Waiting‚Ä¶", className:"ghost", disabled:true}];

    showOverlay("pickThreat", canPick ? "Choose the next threat" : "Waiting for threat choice",
      `<b>${reason}</b><br/>Selection closes in <b>${s}s</b>.`,
      buttons
    );
    return;
  }

  if(phase==="finished"){
    const w=raceState.winnerName||"Winner";
    const a=avg((raceState.players?.[w]?.laps)||[]);
    showOverlay("finished","üèÜ Race Complete",
      `<b>${w}</b> wins with the lowest average time (${typeof a==="number"?a.toFixed(2)+"s":"‚Äî"}).`,
      [{label:"Return to Lobby", className:"warn", onClick:()=>location.href="/lobby/lobby.html"}]
    );
    return;
  }

  hideOverlay();
}

function renderHUD(){
  const t=now();
  const lapElapsed = isRacing ? ((t-lapStart)/1000) : 0;
  el("lapTimer").textContent = lapElapsed.toFixed(3);

  const cdLeft=Math.max(0,(boostReadyAt-t)/1000);
  el("boostText").textContent = cdLeft ? `Cooldown ${cdLeft.toFixed(1)}s` : "Ready";

  const phase=raceState?.phase||"";
  let status =
    !lobbyState ? "Connecting to lobby‚Ä¶" :
    !lobbyStarted() ? "Waiting for start‚Ä¶" :
    !raceState ? "Connecting to race‚Ä¶" :
    (t < stunUntil) ? "Stunned!" :
    (phase==="racing") ? "Racing" :
    (phase==="lap_wait") ? "Waiting‚Ä¶" :
    (phase==="countdown") ? "Countdown‚Ä¶" :
    (phase==="obstacle_select") ? "Choosing threat‚Ä¶" :
    (phase==="finished") ? "Finished" :
    "Syncing‚Ä¶";

  el("statusText").textContent=status;
}

/* ============================================================
   MAIN LOOP (opt: only resize renderer when needed)
============================================================ */
let prev=performance.now();
let lastW=0, lastH=0;

function loop(ts){
  const dt=Math.min(.033,(ts-prev)/1000); prev=ts;

  updateThreats(dt);
  updateRoadRocks(dt);

  if(raceState?.phase==="racing"){
    if(!isRacing) startLapLocal();
    updateCar(dt);
  }else{
    isRacing=false;
  }

  updateCamera();

  const w=innerWidth, h=innerHeight;
  if(w!==lastW || h!==lastH){
    lastW=w; lastH=h;
    renderer.setSize(w,h,false);
    camera.aspect=w/h;
    camera.updateProjectionMatrix();
  }

  renderer.render(scene,camera);

  renderHUD();
  renderBoard();
  renderOverlay();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ============================================================
   CONTROLS
   - Desktop: WASD + Arrow keys + Space (boost) + S/ArrowDown (brake)
   - Mobile: joystick pad + boost button
   - No extra desktop control UI added.
============================================================ */
function setupControls(){
  const fsBtn=el("mobileFsBtn");
  fsBtn?.addEventListener("click", requestFullscreen);
  updateFullscreenBtn();
  addEventListener("resize", updateFullscreenBtn);
  document.addEventListener("fullscreenchange", updateFullscreenBtn);

  // Clear inputs when tab loses focus
  addEventListener("blur", ()=>{
    keys.forward=keys.left=keys.right=keys.brake=keys.boost=false;
  });
  document.addEventListener("visibilitychange", ()=>{
    if(document.hidden) keys.forward=keys.left=keys.right=keys.brake=keys.boost=false;
  });

  // Keyboard (desktop)
  function keyDown(e){
    const code=e.code;

    if(code==="ArrowUp" || code==="KeyW") { keys.forward=true; e.preventDefault(); }
    if(code==="ArrowLeft"|| code==="KeyA") { keys.left=true; e.preventDefault(); }
    if(code==="ArrowRight"||code==="KeyD") { keys.right=true; e.preventDefault(); }
    if(code==="ArrowDown"||code==="KeyS") { keys.brake=true; e.preventDefault(); }

    if(code==="Space"){
      keys.boost=true;
      e.preventDefault();
    }
  }
  function keyUp(e){
    const code=e.code;

    if(code==="ArrowUp" || code==="KeyW") keys.forward=false;
    if(code==="ArrowLeft"|| code==="KeyA") keys.left=false;
    if(code==="ArrowRight"||code==="KeyD") keys.right=false;
    if(code==="ArrowDown"||code==="KeyS") keys.brake=false;

    if(code==="Space") keys.boost=false;
  }
  addEventListener("keydown", keyDown, {passive:false});
  addEventListener("keyup", keyUp, {passive:false});

  // Mobile pad (pointer events unify touch + mouse)
  const pad=el("pad"), dot=el("padDot");
  let padActive=false;

  function applyPad(clientX, clientY){
    const r=pad.getBoundingClientRect();
    const x=Math.max(0,Math.min(r.width, clientX-r.left));
    const y=Math.max(0,Math.min(r.height, clientY-r.top));

    dot.style.left=(x-13)+"px";
    dot.style.top=(y-13)+"px";

    keys.forward = y < r.height*0.82;
    keys.left    = x < r.width*0.40;
    keys.right   = x > r.width*0.60;
    // (no brake on mobile pad to keep it simple)
  }

  pad.addEventListener("pointerdown", (e)=>{
    padActive=true;
    pad.setPointerCapture?.(e.pointerId);
    applyPad(e.clientX, e.clientY);
    e.preventDefault();
  }, {passive:false});

  pad.addEventListener("pointermove", (e)=>{
    if(!padActive) return;
    applyPad(e.clientX, e.clientY);
    e.preventDefault();
  }, {passive:false});

  function endPad(){
    padActive=false;
    keys.forward=keys.left=keys.right=false;
    dot.style.left="62px";
    dot.style.top="62px";
  }
  pad.addEventListener("pointerup", endPad);
  pad.addEventListener("pointercancel", endPad);
  pad.addEventListener("pointerleave", ()=>{ if(padActive) endPad(); });

  // Boost button (pointer events)
  const boost=el("boostBtn");
  boost.addEventListener("pointerdown", (e)=>{ keys.boost=true; e.preventDefault(); }, {passive:false});
  boost.addEventListener("pointerup",   ()=>{ keys.boost=false; });
  boost.addEventListener("pointercancel",()=>{ keys.boost=false; });
  boost.addEventListener("pointerleave",()=>{ keys.boost=false; });
}
setupControls();

/* ============================================================
   NETWORK: LISTENERS ATTACH ONLY AFTER AUTH IS READY
   (also: catch inside snapshot callback so it can't "uncaught" and hang)
============================================================ */
function attachLobbyListeners(){
  if(!LOBBY_REF) return;

  if(lobbyUnsub) lobbyUnsub();
  lobbyUnsub = onSnapshot(
    LOBBY_REF,
    async (snap)=>{
      try{
        if(!snap.exists()){
          lobbyState=null;
          showOverlay("nolobby","Lobby not found",
            "This lobby doc doesn't exist anymore.",
            [{label:"Back to Lobby", className:"warn", onClick:()=>location.href="/lobby/lobby.html"}]
          );
          return;
        }

        lobbyState=snap.data()||{};

        // Ensure race doc exists + join players list
        await ensureRaceDoc();
        await ensureMeInPlayers();
        await maybeStartFromLobby();

        // attach race once
        if(!raceUnsub){
          raceUnsub = onSnapshot(
            RACE_REF,
            (rsnap)=>{
              if(!rsnap.exists()) return;
              const prevObsSig=JSON.stringify(raceState?.obstacles||[]);
              raceState=rsnap.data();
              const nextObsSig=JSON.stringify(raceState?.obstacles||[]);
              if(nextObsSig!==prevObsSig) spawnThreats();
            },
            (err)=>{
              showOverlay("racePerm","Race permission error",
                `<b>${String(err?.code||"error")}</b><br/>${String(err?.message||err)}<br/><br/>
                 Make sure your rules allow <b>/lobbies/${gameId}/crowncouncil/stockkingsRace</b> read/write and that Anonymous Auth is enabled.`,
                [{label:"Back to Lobby", className:"warn", onClick:()=>location.href="/lobby/lobby.html"}]
              );
            }
          );
        }
      }catch(e){
        showOverlay("snapErr","Sync error",
          `<b>${String(e?.code||"error")}</b><br/>${String(e?.message||e)}<br/><br/>
           This usually means Firestore rules blocked a read/write in the lobby callback.`,
          [{label:"Back to Lobby", className:"warn", onClick:()=>location.href="/lobby/lobby.html"}]
        );
      }
    },
    async (err)=>{
      const code=String(err?.code||"");
      const msg=String(err?.message||err||"");
      if(!retriedWithoutAuth && (code.includes("permission-denied") || msg.includes("permission-denied"))){
        retriedWithoutAuth=true;
        try{ await signOut(auth); }catch(e){}
        attachLobbyListeners();
        return;
      }
      showOverlay("lobbyPerm","Lobby permission error",
        `<b>${code||"error"}</b><br/>${msg}<br/><br/>
         If you just updated rules, refresh after deploy completes. Also verify Anonymous Auth is enabled.`,
        [{label:"Back to Lobby", className:"warn", onClick:()=>location.href="/lobby/lobby.html"}]
      );
    }
  );
}

function tickStateMachine(){
  if(!raceState) return;
  advanceCountdownIfNeeded();
  finalizeDeadlineIfNeeded();
  autoPickIfNeeded();
}

(async function main(){
  if(!gameId){
    renderOverlay();
    return;
  }
  try{
    await ensureAuthed();
  }catch(e){
    showOverlay("authFail","Auth failed",
      `Could not establish Firebase Auth.<br/><br/>
       If you‚Äôre running on a custom domain, add it to <b>Firebase Auth ‚Üí Authorized domains</b>.`,
      [{label:"Back to Lobby", className:"warn", onClick:()=>location.href="/lobby/lobby.html"}]
    );
    return;
  }

  attachLobbyListeners();
  setInterval(tickStateMachine, 250);
})();
</script>
</body>
</html>

