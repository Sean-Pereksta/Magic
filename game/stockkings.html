<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1" />
  <title>StockKings: Figure-8 Rush</title>
  <style>
    :root{--bg:#060910;--panel:#0f1726;--line:#2f4468;--ink:#ecf3ff;--muted:#9fb0cc;--accent:#57b2ff;--good:#60f0a1;--warn:#ffd972;--bad:#ff6f89}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,Segoe UI,Roboto,sans-serif}
    #app{position:relative;height:100%;overflow:hidden}
    #scene{position:absolute;inset:0}
    .hud{position:absolute;inset:0;pointer-events:none;display:flex;flex-direction:column;justify-content:space-between;padding:12px}
    .top{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .chip{pointer-events:auto;background:rgba(10,15,25,.8);border:1px solid var(--line);border-radius:12px;padding:8px 10px;font-weight:700}
    .chip small{display:block;color:var(--muted);font-weight:600}
    .big{font-size:24px;font-weight:900}
    .board{pointer-events:auto;background:rgba(8,11,19,.9);border:1px solid var(--line);border-radius:14px;padding:10px;max-width:460px;max-height:45vh;overflow:auto}
    table{width:100%;border-collapse:collapse;font-size:13px}
    th,td{padding:6px;border-bottom:1px solid #21324e;text-align:left}
    .modalWrap{position:absolute;inset:0;background:rgba(3,6,12,.74);display:none;align-items:center;justify-content:center;padding:16px;z-index:20}
    .modalWrap.show{display:flex}
    .modal{pointer-events:auto;background:var(--panel);border:1px solid var(--line);border-radius:16px;max-width:700px;width:min(700px,95vw);padding:16px;box-shadow:0 16px 60px rgba(0,0,0,.45)}
    .modal h2{margin:0 0 8px}
    .modal p{margin:6px 0;color:var(--muted)}
    .btns{display:flex;flex-wrap:wrap;gap:10px;margin-top:12px}
    button{cursor:pointer;border:1px solid #35649f;background:#1d4b80;color:#fff;border-radius:10px;padding:10px 12px;font-weight:700}
    button.ghost{background:#182133;border-color:#344867}
    button.warn{background:#6d4f12;border-color:#a0802e}
    button:disabled{opacity:.5;cursor:not-allowed}
    .controls{position:absolute;inset:auto 0 10px 0;display:none;justify-content:space-between;padding:0 10px;z-index:8}
    .pad,.boost{pointer-events:auto;background:rgba(8,14,24,.75);border:1px solid #35517a;border-radius:14px;touch-action:none}
    .pad{width:150px;height:150px;position:relative}
    .padDot{position:absolute;width:26px;height:26px;border-radius:50%;background:#68b8ff;left:62px;top:62px;pointer-events:none}
    .boost{width:120px;height:120px;display:grid;place-items:center;font-weight:900}
    .boost.onCd{background:rgba(45,18,18,.86);border-color:#8b3f3f}
    .msg{font-size:13px;color:var(--muted)}
    @media (max-width:920px){.controls{display:flex}.board{max-width:none}}
  </style>
</head>
<body>
<div id="app">
  <canvas id="scene"></canvas>

  <div class="hud">
    <div class="top">
      <div class="chip"><small>Phase</small><span id="phaseText">Loading‚Ä¶</span></div>
      <div class="chip"><small>Round</small><span id="lapText">1 / 3</span></div>
      <div class="chip"><small>Lap Timer</small><span class="big" id="lapTimer">00.000</span></div>
      <div class="chip"><small>Boost</small><span id="boostText">Ready</span></div>
      <div class="chip"><small>Status</small><span id="statusText">Connecting‚Ä¶</span></div>
    </div>

    <div class="board">
      <h3 style="margin:0 0 8px">üèÅ Round Results</h3>
      <table>
        <thead><tr><th>Player</th><th>R1</th><th>R2</th><th>R3</th><th>Avg</th></tr></thead>
        <tbody id="scoreRows"></tbody>
      </table>
      <div class="msg" id="waitingMsg">Finish Round 1 to set the first ‚Äúbottom-performer threat‚Äù.</div>
    </div>
  </div>

  <div class="controls">
    <div class="pad" id="pad"><div class="padDot" id="padDot"></div></div>
    <button class="boost" id="boostBtn">BOOST</button>
  </div>

  <div class="modalWrap show" id="overlay">
    <div class="modal">
      <h2 id="overlayTitle">Figure-8 Rush</h2>
      <p id="overlayBody">Get ready.</p>
      <div class="btns" id="overlayButtons"></div>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.162/build/three.module.js";
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, serverTimestamp, runTransaction
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig={
  apiKey:"AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain:"bible-game-246c0.firebaseapp.com",
  projectId:"bible-game-246c0",
  storageBucket:"bible-game-246c0.appspot.com",
  messagingSenderId:"959619818996",
  appId:"1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app=initializeApp(firebaseConfig);
const auth=getAuth(app);
const db=getFirestore(app);

const params=new URLSearchParams(location.search);
const gameId=(params.get("gameId")||"").trim();
const username=(params.get("username")||"Racer").trim();
const LOBBY_REF=gameId?doc(db,"lobbies",gameId):null;
const RACE_REF=gameId?doc(db,"lobbies",gameId,"crowncouncil","stockkingsRace"):null;

const TOTAL_ROUNDS = 3;

// Threat catalog
const OBSTACLES={
  meteorites:{name:"Meteorites",desc:"Warning circles go hot ‚Üí BOOM. Stuns if you‚Äôre inside.",stun:3},
  monsters:{name:"Track Monsters",desc:"Swerve across the lane and body-check racers."},
  eggs:{name:"Egg Storm",desc:"Bouncy eggs spill out and knock racers backward."},
  towers:{name:"Lightning Towers",desc:"Flash strikes inside the ring. Don‚Äôt be there when it fires."},
  rhinos:{name:"Rhino Stampede",desc:"Rhinos run the track and launch racers back."}
};
const obstacleOrder=Object.keys(OBSTACLES);

const el=id=>document.getElementById(id);

// ---------- utils ----------
function deepClone(x){
  try{ return structuredClone(x); }catch(e){ return JSON.parse(JSON.stringify(x||null)); }
}
function avg(arr){
  const v=(arr||[]).filter(n=>typeof n==="number" && isFinite(n));
  return v.length ? (v.reduce((a,b)=>a+b,0)/v.length) : null;
}
function fmt(n){ return typeof n==="number" ? (n.toFixed(2)+"s") : "‚Äî"; }

// deterministic PRNG
function hashStr(s){
  let h=2166136261>>>0;
  for(let i=0;i<s.length;i++){
    h^=s.charCodeAt(i);
    h=Math.imul(h,16777619);
  }
  return h>>>0;
}
function mulberry32(a){
  return function(){
    let t=a+=0x6D2B79F5;
    t=Math.imul(t^(t>>>15),t|1);
    t^=t+Math.imul(t^(t>>>7),t|61);
    return ((t^(t>>>14))>>>0)/4294967296;
  };
}

// ---------- state ----------
let uid="";
let isHost=false;
let raceState=null;
let lobbyState=null;

let lapStart=0;
let isRacing=false;
let firstCheckpoint=false;
let lastParam=0;

let stunUntil=0;
let lastHitAt=0;

let boostReadyAt=0;      // cooldown end
let boostActiveUntil=0;  // boost duration end
let carSpeed=0;

const keys={forward:false,left:false,right:false,boost:false};

let overlayMode=null; // "countdown" | "select" | "info" | null
let lastSeenPhase=null;

let lastHazardKey=null;

// ---------- three.js ----------
const renderer=new THREE.WebGLRenderer({canvas:el("scene"),antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));

const scene=new THREE.Scene();
// Sky gradient-ish by fog + background
scene.background=new THREE.Color(0x79c6ff);
scene.fog = new THREE.Fog(0x79c6ff, 55, 240);

const camera=new THREE.PerspectiveCamera(62,1,0.1,1000);
camera.position.set(0,23,22);

scene.add(new THREE.HemisphereLight(0xcde8ff,0x32551c,1.2));
const sun=new THREE.DirectionalLight(0xffffff,1);
sun.position.set(18,40,20);
sun.castShadow=false;
scene.add(sun);

const ground=new THREE.Mesh(
  new THREE.PlaneGeometry(240,240),
  new THREE.MeshStandardMaterial({color:0x3a8b35, roughness:1, metalness:0})
);
ground.rotation.x=-Math.PI/2;
scene.add(ground);

// ---------- Track ----------
const trackPath=[];
for(let i=0;i<700;i++){
  const t=(i/700)*Math.PI*2;
  const x=36*Math.sin(t);
  const z=18*Math.sin(t)*Math.cos(t);
  trackPath.push(new THREE.Vector3(x,0.03,z));
}

// track ribbon + lane paint
const trackMat=new THREE.MeshStandardMaterial({color:0x7b5b35, roughness:.95});
const paintMat=new THREE.MeshStandardMaterial({color:0xf2f5ff, roughness:.75, emissive:0x101820});

for(let i=1;i<trackPath.length;i++){
  const a=trackPath[i-1],b=trackPath[i];
  const len=a.distanceTo(b);
  const mid=new THREE.Vector3().addVectors(a,b).multiplyScalar(.5);

  const mesh=new THREE.Mesh(new THREE.BoxGeometry(8,0.25,len+1),trackMat);
  mesh.position.copy(mid);
  mesh.lookAt(b.x,mid.y,b.z);
  mesh.rotateY(Math.PI/2);
  scene.add(mesh);

  // lane stripe
  const stripe=new THREE.Mesh(new THREE.BoxGeometry(.35,0.03,len+0.6), paintMat);
  stripe.position.copy(mid);
  stripe.position.y += 0.16;
  stripe.lookAt(b.x, stripe.position.y, b.z);
  stripe.rotateY(Math.PI/2);
  scene.add(stripe);
}

const TWO_PI=Math.PI*2;
const trackCenter=(t)=>new THREE.Vector3(36*Math.sin(t),0,18*Math.sin(t)*Math.cos(t));
function trackFrame(t){
  const p=trackCenter(t);
  const p2=trackCenter((t+0.010)%TWO_PI);
  const tangent=new THREE.Vector3().subVectors(p2,p).normalize();
  const normal=new THREE.Vector3(-tangent.z,0,tangent.x);
  return {p,tangent,normal};
}
function nearestParam(x,z){
  let bestT=0,best=1e18;
  for(let i=0;i<trackPath.length;i++){
    const p=trackPath[i];
    const d=(p.x-x)**2+(p.z-z)**2;
    if(d<best){best=d;bestT=(i/trackPath.length)*TWO_PI;}
  }
  return {t:bestT,d:Math.sqrt(best)};
}

// ---------- Procedural textures (glow / spark) ----------
function makeGlowTexture(){
  const c=document.createElement("canvas");
  c.width=c.height=128;
  const g=c.getContext("2d");
  const grd=g.createRadialGradient(64,64,2,64,64,64);
  grd.addColorStop(0,"rgba(255,255,255,1)");
  grd.addColorStop(.25,"rgba(255,255,255,.55)");
  grd.addColorStop(.55,"rgba(255,255,255,.12)");
  grd.addColorStop(1,"rgba(255,255,255,0)");
  g.fillStyle=grd;
  g.fillRect(0,0,128,128);
  const tex=new THREE.CanvasTexture(c);
  tex.needsUpdate=true;
  return tex;
}
const glowTex = makeGlowTexture();

// ---------- FX system (booms, boost bursts, dust puffs) ----------
const fx=[];
function addSpriteFX({pos, color=0xffffff, size=1.2, life=0.6, vel=null, grow=2.0, opacity=1.0}){
  const mat=new THREE.SpriteMaterial({
    map:glowTex, color, transparent:true, opacity,
    blending:THREE.AdditiveBlending, depthWrite:false
  });
  const spr=new THREE.Sprite(mat);
  spr.position.copy(pos);
  spr.scale.set(size,size,size);
  scene.add(spr);
  fx.push({kind:"sprite",obj:spr,t:0,life,vel:vel?vel.clone():new THREE.Vector3(),grow,baseSize:size,baseOpacity:opacity});
}
function addRingFX({pos, color=0x9ec9ff, inner=0.6, outer=1.2, life=0.5, grow=6.0, opacity=0.55}){
  const geo=new THREE.RingGeometry(inner, outer, 32);
  const mat=new THREE.MeshBasicMaterial({
    color, transparent:true, opacity, side:THREE.DoubleSide,
    blending:THREE.AdditiveBlending, depthWrite:false
  });
  const ring=new THREE.Mesh(geo,mat);
  ring.rotation.x=-Math.PI/2;
  ring.position.copy(pos);
  ring.position.y += 0.06;
  scene.add(ring);
  fx.push({kind:"ring",obj:ring,t:0,life,grow,baseOpacity:opacity});
}
function spawnMeteorBoom(pos){
  // big ring + sparks
  addRingFX({pos, color:0xff7a22, inner:1.0, outer:2.2, life:0.45, grow:10.0, opacity:0.6});
  addRingFX({pos, color:0xffe2a6, inner:0.7, outer:1.4, life:0.35, grow:7.0, opacity:0.7});
  // core flash
  addSpriteFX({pos:pos.clone().add(new THREE.Vector3(0,1.2,0)), color:0xfff2d6, size:2.2, life:0.22, grow:4.0, opacity:0.95});
  // debris sparks
  for(let i=0;i<14;i++){
    const v=new THREE.Vector3((Math.random()-.5)*7, (Math.random()*4)+1.5, (Math.random()-.5)*7);
    addSpriteFX({pos:pos.clone().add(new THREE.Vector3(0,0.3,0)), color:0xffc266, size:0.5+Math.random()*0.45, life:0.45+Math.random()*0.35, vel:v, grow:1.6, opacity:0.85});
  }
  // dust puff
  for(let i=0;i<10;i++){
    const v=new THREE.Vector3((Math.random()-.5)*2.2, 0.2+Math.random()*0.4, (Math.random()-.5)*2.2);
    addSpriteFX({pos:pos.clone().add(new THREE.Vector3(0,0.1,0)), color:0xb8c2d4, size:1.3+Math.random()*0.8, life:0.65+Math.random()*0.25, vel:v, grow:2.6, opacity:0.25});
  }
}
function spawnBoostBurst(){
  const back=new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);
  const base=car.position.clone().addScaledVector(back, 2.4).add(new THREE.Vector3(0,1.0,0));
  // blue shock ring
  addRingFX({pos:car.position.clone(), color:0x57d7ff, inner:0.7, outer:1.3, life:0.25, grow:8.0, opacity:0.55});
  // core flash
  addSpriteFX({pos:base.clone(), color:0x7cf2ff, size:1.6, life:0.18, grow:4.5, opacity:0.95});
  // trail sparks
  for(let i=0;i<18;i++){
    const v = back.clone().multiplyScalar( - (10 + Math.random()*18) )
      .add(new THREE.Vector3((Math.random()-.5)*5, (Math.random()-.5)*1.2, (Math.random()-.5)*5));
    addSpriteFX({pos:base.clone(), color:0x3ecbff, size:0.55+Math.random()*0.55, life:0.35+Math.random()*0.25, vel:v, grow:1.8, opacity:0.85});
  }
}
function spawnRockBumpFX(pos){
  addSpriteFX({pos:pos.clone().add(new THREE.Vector3(0,1.0,0)), color:0xcbd5e1, size:1.2, life:0.35, grow:3.0, opacity:0.45});
  for(let i=0;i<8;i++){
    const v=new THREE.Vector3((Math.random()-.5)*3, 1+Math.random()*2.2, (Math.random()-.5)*3);
    addSpriteFX({pos:pos.clone().add(new THREE.Vector3(0,0.3,0)), color:0xa3b2c8, size:0.35+Math.random()*0.35, life:0.35+Math.random()*0.25, vel:v, grow:1.4, opacity:0.65});
  }
}
function updateFX(dt){
  for(let i=fx.length-1;i>=0;i--){
    const f=fx[i];
    f.t += dt;
    const a = Math.min(1, f.t / f.life);
    const fade = 1 - a;
    if(f.kind==="sprite"){
      f.obj.position.addScaledVector(f.vel, dt);
      f.obj.scale.setScalar(f.baseSize * (1 + a*f.grow));
      f.obj.material.opacity = f.baseOpacity * (fade*fade);
    }else if(f.kind==="ring"){
      f.obj.scale.setScalar(1 + a*f.grow);
      f.obj.material.opacity = f.baseOpacity * (fade*fade);
    }
    if(f.t >= f.life){
      scene.remove(f.obj);
      if(f.obj.material) f.obj.material.dispose?.();
      if(f.obj.geometry) f.obj.geometry.dispose?.();
      fx.splice(i,1);
    }
  }
}

// ---------- Car ----------
function buildCar(){
  const g=new THREE.Group();

  const body=new THREE.Mesh(
    new THREE.BoxGeometry(2.6,.9,4.2),
    new THREE.MeshStandardMaterial({color:0x2376ff,metalness:.25,roughness:.35})
  );
  body.position.y=.9;

  const top=new THREE.Mesh(
    new THREE.BoxGeometry(1.8,.7,2),
    new THREE.MeshStandardMaterial({color:0xd8e8ff,metalness:.05,roughness:.3})
  );
  top.position.set(0,1.45,-.2);

  g.add(body,top);

  [[-1,.35,-1.3],[1,.35,-1.3],[-1,.35,1.3],[1,.35,1.3]].forEach(([x,y,z])=>{
    const w=new THREE.Mesh(
      new THREE.CylinderGeometry(.45,.45,.4,16),
      new THREE.MeshStandardMaterial({color:0x111111, roughness:.9})
    );
    w.rotation.z=Math.PI/2;
    w.position.set(x,y,z);
    g.add(w);
  });

  // Exhaust flames (orange idle + blue boost) as 2 cones for depth
  const flameG=new THREE.Group();
  flameG.position.set(0,1.0,2.65);

  const flame1=new THREE.Mesh(
    new THREE.ConeGeometry(.28,1.5,10),
    new THREE.MeshBasicMaterial({color:0xff8b2e,transparent:true,opacity:.72, blending:THREE.AdditiveBlending, depthWrite:false})
  );
  flame1.rotation.x=Math.PI/2;

  const flame2=new THREE.Mesh(
    new THREE.ConeGeometry(.18,1.0,10),
    new THREE.MeshBasicMaterial({color:0xfff0b8,transparent:true,opacity:.65, blending:THREE.AdditiveBlending, depthWrite:false})
  );
  flame2.rotation.x=Math.PI/2;
  flame2.position.z=-0.1;

  flameG.add(flame1,flame2);
  g.add(flameG);

  g.flameG=flameG;
  g.flame1=flame1;
  g.flame2=flame2;

  return g;
}
const car=buildCar();
scene.add(car);

function resetCarToStart(){
  car.position.set(0,.1,-6);
  car.rotation.set(0,0,0);
  carSpeed=0;
}

// ---------- Decorative stones / roadside clutter ----------
const sceneryRocks=[];
function buildSceneryRocks(){
  const seed=hashStr(`${gameId||"local"}|scenery|v2`);
  const rnd=mulberry32(seed);

  const rockGeo=new THREE.DodecahedronGeometry(0.55,0);
  const rockMat=new THREE.MeshStandardMaterial({color:0x4b5563, roughness:1, metalness:0});

  const instCount=240;
  const inst=new THREE.InstancedMesh(rockGeo, rockMat, instCount);
  inst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

  const m=new THREE.Matrix4();
  const q=new THREE.Quaternion();
  const s=new THREE.Vector3();

  // scatter around, but bias toward track region
  for(let i=0;i<instCount;i++){
    const t=rnd()*TWO_PI;
    const fr=trackFrame(t);
    const lateral=(rnd()*2-1) * (6 + rnd()*10);
    const p=fr.p.clone().addScaledVector(fr.normal, lateral);
    p.y = 0.2 + rnd()*0.18;

    // push some farther out as "field rocks"
    if(rnd()<0.35){
      p.x += (rnd()*2-1)*45;
      p.z += (rnd()*2-1)*45;
    }

    q.setFromEuler(new THREE.Euler(rnd()*3, rnd()*3, rnd()*3));
    const scale=0.35 + rnd()*1.15;
    s.set(scale, scale*(0.6+rnd()*0.8), scale);
    m.compose(p,q,s);
    inst.setMatrixAt(i,m);
  }
  inst.instanceMatrix.needsUpdate=true;
  scene.add(inst);
  sceneryRocks.push(inst);

  // a few bushes/tufts (simple spheres, cheap)
  const bushMat=new THREE.MeshStandardMaterial({color:0x2f6d2f, roughness:1});
  for(let i=0;i<55;i++){
    const t=rnd()*TWO_PI;
    const fr=trackFrame(t);
    const lateral=(rnd()*2-1) * (10 + rnd()*16);
    const p=fr.p.clone().addScaledVector(fr.normal, lateral);
    p.y=0.25;
    const b=new THREE.Mesh(new THREE.SphereGeometry(0.7+rnd()*0.9, 10, 8), bushMat);
    b.position.copy(p);
    b.scale.y=0.6+rnd()*0.7;
    scene.add(b);
    sceneryRocks.push(b);
  }
}
buildSceneryRocks();

// ---------- Road rocks (bump + slight slow) ----------
const roadRocks=[];
function buildRoadRocks(){
  // consistent across everyone: seed only depends on gameId
  const seed=hashStr(`${gameId||"local"}|roadrocks|v3`);
  const rnd=mulberry32(seed);

  const geo=new THREE.DodecahedronGeometry(0.45,0);
  const mat=new THREE.MeshStandardMaterial({color:0x606a77, roughness:1, metalness:0});

  for(let i=0;i<28;i++){
    const tp=rnd()*TWO_PI;
    const fr=trackFrame(tp);
    const lat=(rnd()*2-1)*2.3; // on the road
    const p=fr.p.clone().addScaledVector(fr.normal, lat);
    p.y=0.35;
    const mesh=new THREE.Mesh(geo,mat);
    mesh.position.copy(p);
    mesh.rotation.set(rnd()*3, rnd()*3, rnd()*3);
    const sc=0.7 + rnd()*0.95;
    mesh.scale.set(sc, sc*(0.6+rnd()*0.7), sc);
    scene.add(mesh);
    roadRocks.push({mesh, r:0.9 + sc*0.25});
  }
}
buildRoadRocks();

// ---------- Hazards (stack cumulatively) ----------
const threats=[];

function clearThreats(){
  while(threats.length){
    const t=threats.pop();
    if(t.mesh) scene.remove(t.mesh);
    if(t.light) scene.remove(t.light);
  }
}

function placeOnTrack(tParam, lateral=0){
  const fr=trackFrame(tParam);
  const pos=fr.p.clone().addScaledVector(fr.normal, lateral);
  pos.y = 0.06;
  return {pos, fr};
}

function getActiveThreatEntriesForRound(){
  // stack cumulatively: once introduced, stays for later rounds
  const r = (raceState?.round||1);
  const stack = (raceState?.threatStack||[]);
  return stack.filter(e => (e?.roundIntroduced||999) <= r);
}

function rebuildHazardsIfNeeded(){
  if(!raceState) return;

  // key includes stack + round + uid
  const stack = raceState.threatStack || [];
  const stackKey = stack.map(e=>`${e.type}|${e.roundIntroduced}|${e.excludeUid||""}`).join(";");
  const key = `${raceState.round||1}|${uid||"?"}|${stackKey}`;

  if(key === lastHazardKey) return;
  lastHazardKey = key;

  clearThreats();

  const entries = getActiveThreatEntriesForRound();

  // spawn for each active entry, unless player is immune to that entry
  entries.forEach((entry)=>{
    if(!entry?.type) return;
    if(entry.excludeUid && entry.excludeUid === uid) return; // immune

    const type = entry.type;
    const seed = hashStr(`${gameId}|round${raceState.round}|${type}|hazards|v3`);
    const rnd = mulberry32(seed);

    const randT = ()=> rnd()*TWO_PI;
    const randLat = ()=> (rnd()*2-1)*2.35; // keep on/near road

    // Slight scaling by how long threat has been active (more chaos later)
    const age = Math.max(0, (raceState.round||1) - (entry.roundIntroduced||1));
    const mult = 1 + age*0.20;

    if(type==="meteorites"){
      const count = Math.round(7*mult);
      for(let i=0;i<count;i++){
        const tp=randT();
        const {pos}=placeOnTrack(tp, randLat());
        const mesh=new THREE.Mesh(
          new THREE.CylinderGeometry(1.9,1.9,.05,24),
          new THREE.MeshBasicMaterial({color:0xffc266,transparent:true,opacity:.34})
        );
        mesh.position.set(pos.x, 0.06, pos.z);
        scene.add(mesh);
        threats.push({type:"meteorites",mesh,r:2.0,timer:1.2+rnd()*3.3,hotUntil:0,boomAt:0});
      }
    }

    if(type==="towers"){
      const count = Math.round(5*mult);
      for(let i=0;i<count;i++){
        const tp=randT();
        const {pos}=placeOnTrack(tp, randLat()*0.85);
        const mesh=new THREE.Group();
        const pole=new THREE.Mesh(
          new THREE.CylinderGeometry(.8,1.1,4,10),
          new THREE.MeshStandardMaterial({color:0x45526b, roughness:.9})
        );
        pole.position.y=2;
        const ring=new THREE.Mesh(
          new THREE.RingGeometry(2.4,2.95,22),
          new THREE.MeshBasicMaterial({color:0x9ec9ff,side:THREE.DoubleSide,transparent:true,opacity:.38, blending:THREE.AdditiveBlending, depthWrite:false})
        );
        ring.rotation.x=-Math.PI/2;
        mesh.add(pole,ring);
        mesh.position.set(pos.x,0,pos.z);

        // lightning flash light
        const light=new THREE.PointLight(0x9ee9ff, 0, 12);
        light.position.set(pos.x, 3.2, pos.z);

        scene.add(mesh);
        scene.add(light);

        threats.push({type:"towers",mesh,light,r:2.85,flash:0,cool:1.0+rnd()*2.3});
      }
    }

    if(type==="eggs"){
      const count = Math.round(11*mult);
      for(let i=0;i<count;i++){
        const tp=randT();
        const {pos,fr}=placeOnTrack(tp, randLat());
        const mesh=new THREE.Mesh(
          new THREE.SphereGeometry(.75,16,12),
          new THREE.MeshStandardMaterial({color:0xf4efe5, roughness:.6, metalness:0.05})
        );
        mesh.position.set(pos.x, .8, pos.z);
        scene.add(mesh);

        const v = fr.tangent.clone().multiplyScalar((rnd()*2-1)*2.0)
          .addScaledVector(fr.normal, (rnd()*2-1)*2.0);

        threats.push({type:"eggs",mesh,r:1.15,v});
      }
    }

    if(type==="monsters"){
      const count = Math.round(6*mult);
      for(let i=0;i<count;i++){
        const tp=randT();
        const {pos,fr}=placeOnTrack(tp, 0);
        const mesh=new THREE.Mesh(
          new THREE.BoxGeometry(1.55,1.85,1.55),
          new THREE.MeshStandardMaterial({color:0x6f32a8, roughness:.55, metalness:.15, emissive:0x120018})
        );
        mesh.position.set(pos.x,1,pos.z);
        scene.add(mesh);
        threats.push({
          type:"monsters",
          mesh,r:1.6,
          base: new THREE.Vector3(pos.x,1,pos.z),
          normal: fr.normal.clone(),
          phase: rnd()*Math.PI*2,
          amp: 3.2 + rnd()*2.3,
          spd: 1.2 + rnd()*0.9
        });
      }
    }

    if(type==="rhinos"){
      const count = Math.round(3*mult);
      for(let i=0;i<count;i++){
        const tp=randT();
        const {pos}=placeOnTrack(tp, randLat()*0.55);
        const mesh=new THREE.Mesh(
          new THREE.BoxGeometry(2.2,1.4,3.4),
          new THREE.MeshStandardMaterial({color:0x7b7f86, roughness:.9})
        );
        mesh.position.set(pos.x,.7,pos.z);
        scene.add(mesh);
        threats.push({type:"rhinos",mesh,r:1.85,t:tp});
      }
    }
  });
}

function updateThreats(dt){
  if(!isRacing) return;
  const nowMs = Date.now();

  threats.forEach(t=>{
    if(t.type==="meteorites"){
      t.timer -= dt;
      if(t.timer < 0){
        // impact window starts now
        t.timer = 2.5 + Math.random()*3.1;
        t.hotUntil = nowMs + 520; // hot for ~0.52s
        t.boomAt = nowMs + 180;   // boom visuals after a short telegraph

        t.mesh.material.color.setHex(0xff4b4b);
        t.mesh.material.opacity = 0.46;

        setTimeout(()=>{
          if(!t.mesh) return;
          t.mesh.material.color.setHex(0xffc266);
          t.mesh.material.opacity = 0.34;
        }, 260);
      }
      // spawn boom visual once per cycle
      if(t.boomAt && nowMs > t.boomAt){
        t.boomAt = 0;
        spawnMeteorBoom(t.mesh.position.clone());
      }
    }

    if(t.type==="towers"){
      t.cool -= dt;
      if(t.cool < 0){
        t.cool = 1.2 + Math.random()*2.6;
        t.flash = 0.32;
        // lightning strike visuals
        const p=t.mesh.position.clone();
        addSpriteFX({pos:p.clone().add(new THREE.Vector3(0,3.2,0)), color:0x9ee9ff, size:2.3, life:0.18, grow:5.5, opacity:0.95});
        addRingFX({pos:p, color:0x9ee9ff, inner:0.9, outer:2.0, life:0.28, grow:6.0, opacity:0.55});
      }
      t.flash = Math.max(0, t.flash - dt);
      const ring=t.mesh.children[1];
      ring.material.opacity = 0.28 + t.flash*2.4;
      if(t.light) t.light.intensity = (t.flash>0 ? 2.2 : 0);
    }

    if(t.type==="monsters"){
      t.phase += dt*t.spd;
      const off = Math.sin(t.phase) * t.amp;
      t.mesh.position.set(
        t.base.x + t.normal.x*off,
        1,
        t.base.z + t.normal.z*off
      );
      if(Math.random()<0.02){
        addSpriteFX({pos:t.mesh.position.clone().add(new THREE.Vector3(0,1.2,0)), color:0x7a3bff, size:0.9, life:0.22, grow:2.4, opacity:0.45});
      }
    }

    if(t.type==="eggs"){
      t.mesh.position.addScaledVector(t.v, dt);
      t.v.multiplyScalar(0.985);
      const near=nearestParam(t.mesh.position.x, t.mesh.position.z);
      if(near.d > 3.6){
        const fr=trackFrame(near.t);
        const target=fr.p.clone(); target.y = 0.8;
        t.mesh.position.lerp(target, 0.06);
      }
      if(Math.random()<0.012){
        addSpriteFX({pos:t.mesh.position.clone().add(new THREE.Vector3(0,0.6,0)), color:0xeef2ff, size:0.55, life:0.18, grow:2.2, opacity:0.35});
      }
    }

    if(t.type==="rhinos"){
      t.t = (t.t - dt*1.2 + TWO_PI) % TWO_PI;
      const fr=trackFrame(t.t);
      const pos = fr.p.clone().addScaledVector(fr.normal, 0.8);
      t.mesh.position.set(pos.x, .7, pos.z);
      if(Math.random()<0.02){
        addSpriteFX({pos:t.mesh.position.clone().add(new THREE.Vector3(0,1.1,0)), color:0xffffff, size:0.7, life:0.18, grow:2.0, opacity:0.22});
      }
    }

    // Collisions
    const d = t.mesh.position.distanceTo(car.position);
    if(d < (t.r + 1.08) && (nowMs - lastHitAt > 900)){
      const stunned = nowMs < stunUntil;
      if(stunned) return;

      if(t.type==="meteorites"){
        if(nowMs < (t.hotUntil||0)){
          lastHitAt = nowMs;
          stunUntil = Math.max(stunUntil, nowMs + 3000);
          addSpriteFX({pos:car.position.clone().add(new THREE.Vector3(0,1.2,0)), color:0xff4b4b, size:1.8, life:0.22, grow:3.2, opacity:0.7});
        }
        return;
      }

      if(t.type==="towers"){
        if((t.flash||0) > 0.01){
          lastHitAt = nowMs;
          stunUntil = Math.max(stunUntil, nowMs + 2600);
          addSpriteFX({pos:car.position.clone().add(new THREE.Vector3(0,1.5,0)), color:0x9ee9ff, size:2.0, life:0.2, grow:4.5, opacity:0.9});
        }
        return;
      }

      if(t.type==="eggs"){
        lastHitAt = nowMs;
        const dir=new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);
        car.position.addScaledVector(dir,-2.2);
        carSpeed *= 0.72;
        spawnRockBumpFX(t.mesh.position.clone());
        scene.remove(t.mesh);
        t.dead=true;
        return;
      }

      if(t.type==="rhinos" || t.type==="monsters"){
        lastHitAt = nowMs;
        const dir=new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);
        car.position.addScaledVector(dir,-5.6);
        carSpeed *= 0.55;
        stunUntil = Math.max(stunUntil, nowMs + 1000);
        addRingFX({pos:car.position.clone(), color:0xb07cff, inner:0.7, outer:1.4, life:0.22, grow:6.5, opacity:0.35});
        return;
      }
    }
  });

  for(let i=threats.length-1;i>=0;i--){
    if(threats[i].dead){
      threats.splice(i,1);
    }
  }
}

// ---------- UI modal ----------
function showModal(title,body,buttons){
  el("overlayTitle").textContent=title;
  el("overlayBody").innerHTML=body;
  const wrap=el("overlayButtons");
  wrap.innerHTML="";
  (buttons||[]).forEach(b=>{
    const bt=document.createElement("button");
    bt.textContent=b.label;
    if(b.className) bt.className=b.className;
    bt.disabled=!!b.disabled;
    bt.onclick=b.onClick;
    wrap.appendChild(bt);
  });
  el("overlay").classList.add("show");
}
function hideModal(){
  el("overlay").classList.remove("show");
  overlayMode=null;
}
function setOverlayCountdown(seconds){
  el("overlayTitle").textContent = "Race starts in‚Ä¶";
  el("overlayBody").innerHTML =
    `<div style="font-size:44px;font-weight:1000;line-height:1;margin:4px 0 10px">${seconds}</div>
     <div style="color:var(--muted)">
       Drive: <b>W/‚Üë</b> + <b>A/D</b> (or joystick). Boost: <b>Space</b> (or button).<br/>
       Boost cooldown: <b>8s</b>. Hazards now stack each round. üåÄ
     </div>`;
  const wrap=el("overlayButtons");
  if(!wrap.dataset.built){
    wrap.dataset.built="1";
    wrap.innerHTML="";
    const fs=document.createElement("button");
    fs.className="warn";
    fs.textContent="Enter Fullscreen";
    fs.onclick=()=>document.documentElement.requestFullscreen?.();
    const ok=document.createElement("button");
    ok.className="ghost";
    ok.textContent="Hide";
    ok.onclick=hideModal;
    wrap.append(fs,ok);
  }
  el("overlay").classList.add("show");
  overlayMode="countdown";
}

// ---------- scoreboard ----------
function activeThreatNames(){
  const entries = getActiveThreatEntriesForRound();
  const names = entries.map(e=>OBSTACLES[e.type]?.name||e.type);
  // unique while preserving order
  const seen=new Set();
  const out=[];
  for(const n of names){ if(!seen.has(n)){seen.add(n); out.push(n);} }
  return out;
}

function renderBoard(){
  const players=raceState?.players||{};
  const rows=Object.entries(players).sort((a,b)=>((a[1].avg??999)-(b[1].avg??999)));

  el("scoreRows").innerHTML=rows.map(([id,p])=>`
    <tr>
      <td>${(p.name||id)}${id===uid?" (you)":""}</td>
      <td>${fmt(p.laps?.[0])}</td>
      <td>${fmt(p.laps?.[1])}</td>
      <td>${fmt(p.laps?.[2])}</td>
      <td>${fmt(p.avg)}</td>
    </tr>`).join("");

  const ph=raceState?.phase||"pregame";
  el("phaseText").textContent=ph.replaceAll("_"," ");
  el("lapText").textContent=`${raceState?.round||1} / ${TOTAL_ROUNDS}`;

  const threatsNow = activeThreatNames();
  const threatsLine = threatsNow.length ? `Active threats: <b>${threatsNow.join(", ")}</b>.` : "No active threats yet.";

  if(ph==="lap_wait" && raceState?.deadlineAt){
    const sec=Math.max(0,Math.ceil((raceState.deadlineAt-Date.now())/1000));
    el("waitingMsg").innerHTML=`Others can still finish. <b>${sec}s</b> until round locks. ${threatsLine}`;
  } else if(ph==="obstacle_select"){
    const p = (raceState?.players||{})[raceState?.selectorUid||""]?.name;
    el("waitingMsg").innerHTML = raceState?.selectorUid
      ? `Slowest lap (<b>${p||"bottom performer"}</b>) chooses a threat that stacks for the rest of the match.`
      : `Choosing next threat‚Ä¶`;
  } else if(ph==="countdown"){
    el("waitingMsg").innerHTML = `Next round launching‚Ä¶ ${threatsLine}`;
  } else {
    el("waitingMsg").innerHTML = threatsLine;
  }

  if(raceState?.winnerUid){
    const w=players[raceState.winnerUid];
    showModal(
      "üèÜ Race Complete",
      `${(w?.name||"Winner")} wins with the lowest average time!<br/><br/>Return to the lobby to start another match.`,
      [{label:"Return to Lobby",onClick:()=>location.href="/lobby/lobby.html"}]
    );
  }
}

// ---------- Firestore flow ----------
async function ensureRaceDoc(){
  if(!RACE_REF) return;
  const snap=await getDoc(RACE_REF);
  if(snap.exists()) return;

  await setDoc(RACE_REF,{
    game:"stockkings-racer",
    phase:"pregame",
    round:1,
    maxRounds:TOTAL_ROUNDS,
    players:{},
    obstacles:[],     // unique history
    threatStack:[],   // [{type, roundIntroduced, excludeUid}] ‚Äî stacks cumulatively
    selectorUid:null,
    lastSelectorReason:"",
    pickedObstacle:null,
    countdownEndsAt:null,
    deadlineAt:null,
    selectEndsAt:null,
    winnerUid:null,
    updatedAt:serverTimestamp()
  },{merge:true});
}

async function joinRacePlayer(){
  if(!RACE_REF||!uid) return;
  await setDoc(RACE_REF,{
    players:{
      [uid]:{name:username,laps:[],avg:null,lastLap:null}
    }
  },{merge:true});
}

async function hostMaybeStart(){
  if(!isHost || !RACE_REF || !raceState) return;
  if(raceState.phase==="pregame"){
    await updateDoc(RACE_REF,{
      phase:"countdown",
      countdownEndsAt:Date.now()+10000,
      updatedAt:serverTimestamp()
    });
  }
}

function stackHasType(stack,type){
  return (stack||[]).some(e=>e?.type===type);
}

async function applyObstaclePick(type, auto=false){
  if(!isHost || !RACE_REF || !raceState) return;

  const history=[...(raceState.obstacles||[])];
  if(!history.includes(type)) history.push(type);

  const nextRound=(raceState.round||1)+1;
  const picker = raceState.selectorUid || null;

  // build updated stack: once a type is introduced, it stays (no duplicates)
  const stack=deepClone(raceState.threatStack||[]);
  if(!stackHasType(stack,type)){
    stack.push({type, roundIntroduced: nextRound, excludeUid: picker});
  }

  if(nextRound > TOTAL_ROUNDS){
    // finish: compute winner
    const players=deepClone(raceState.players||{});
    let bestId=null,best=1e18;
    Object.entries(players).forEach(([id,p])=>{
      p.avg=avg(p.laps||[]);
      if((p.avg??999)<best){best=p.avg;bestId=id;}
    });
    await updateDoc(RACE_REF,{
      obstacles:history,
      threatStack:stack,
      phase:"finished",
      winnerUid:bestId,
      pickedObstacle:null,
      updatedAt:serverTimestamp()
    });
    return;
  }

  await updateDoc(RACE_REF,{
    obstacles:history,
    threatStack:stack,
    round:nextRound,
    phase:"countdown",
    countdownEndsAt:Date.now()+10000,
    selectorUid:null,
    lastSelectorReason:auto?"Auto-picked due to timeout.":"",
    pickedObstacle:null,
    deadlineAt:null,
    selectEndsAt:null,
    updatedAt:serverTimestamp()
  });
}

async function hostTick(){
  if(!isHost || !raceState || !RACE_REF) return;
  const now=Date.now();

  if(raceState.phase==="countdown" && raceState.countdownEndsAt && now > raceState.countdownEndsAt){
    await updateDoc(RACE_REF,{phase:"racing",updatedAt:serverTimestamp()});
    return;
  }

  if(raceState.phase==="lap_wait" && raceState.deadlineAt && now > raceState.deadlineAt){
    const players=deepClone(raceState.players||{});
    const r=(raceState.round||1);

    Object.entries(players).forEach(([id,p])=>{
      p.laps = p.laps || [];
      if(typeof p.laps[r-1] !== "number"){
        p.laps[r-1] = 30;
      }
      p.avg = avg(p.laps);
    });

    const vals=Object.entries(players).map(([id,p])=>({id,t:(typeof p.laps[r-1]==="number"?p.laps[r-1]:30)}));
    const maxT=Math.max(...vals.map(v=>v.t));
    const bottoms=vals.filter(v=>v.t===maxT);
    const pick=bottoms[Math.floor(Math.random()*bottoms.length)]?.id || vals[0]?.id || null;

    await updateDoc(RACE_REF,{
      players,
      phase:"obstacle_select",
      selectorUid:pick,
      selectEndsAt:now+15000,
      lastSelectorReason:bottoms.length>1?"Tie on slowest; random bottom performer selected.":"Slowest lap selects next threat.",
      updatedAt:serverTimestamp()
    });
    return;
  }

  if(raceState.phase==="obstacle_select" && raceState.selectEndsAt && now > raceState.selectEndsAt){
    const used=raceState.obstacles||[];
    let opts=obstacleOrder.filter(o=>!used.includes(o));
    if(!opts.length) opts=[...obstacleOrder];
    const pick=opts[Math.floor(Math.random()*opts.length)];
    await applyObstaclePick(pick,true);
    return;
  }

  if(raceState.phase==="obstacle_select" && raceState.pickedObstacle){
    await applyObstaclePick(raceState.pickedObstacle,false);
  }
}

async function submitLap(){
  if(!RACE_REF || !raceState || !uid || !isRacing) return;

  isRacing=false;

  const lap=((Date.now()-lapStart)/1000);
  const r=(raceState.round||1);

  await runTransaction(db, async (tx)=>{
    const snap=await tx.get(RACE_REF);
    if(!snap.exists()) return;
    const rs=snap.data();

    const players=deepClone(rs.players||{});
    const me=players[uid] || {name:username,laps:[]};

    me.name = me.name || username;
    me.laps = me.laps || [];
    me.laps[r-1] = Math.min(30, lap);
    me.lastLap = me.laps[r-1];
    me.avg = avg(me.laps);
    players[uid] = me;

    const list = Object.entries(players);
    const hasAny = list.some(([,p])=>typeof (p.laps||[])[r-1] === "number");
    const allHave = list.length>0 && list.every(([,p])=>typeof (p.laps||[])[r-1] === "number");

    const patch={players,updatedAt:serverTimestamp()};

    if(rs.phase==="racing" && hasAny && !rs.deadlineAt){
      patch.phase="lap_wait";
      patch.deadlineAt=Date.now()+30000;
    }

    if((rs.phase==="racing" || rs.phase==="lap_wait") && allHave){
      const vals=list.map(([id,p])=>({id,t:(p.laps||[])[r-1] ?? 30}));
      const maxT=Math.max(...vals.map(v=>v.t));
      const bottoms=vals.filter(v=>v.t===maxT);
      patch.phase="obstacle_select";
      patch.selectorUid=bottoms[Math.floor(Math.random()*bottoms.length)]?.id || vals[0]?.id;
      patch.selectEndsAt=Date.now()+15000;
      patch.lastSelectorReason=bottoms.length>1?"Tie on slowest; random bottom performer selected.":"Slowest lap selects next threat.";
      patch.deadlineAt=null;
    }

    tx.update(RACE_REF, patch);
  });
}

// ---------- Local driving ----------
function startLapLocal(){
  const r=(raceState?.round||1);
  const my = (raceState?.players||{})[uid];
  if(my && typeof (my.laps||[])[r-1] === "number"){
    isRacing=false;
    return;
  }

  resetCarToStart();

  lapStart=Date.now();
  isRacing=true;
  firstCheckpoint=false;

  lastParam = nearestParam(car.position.x,car.position.z).t;
  stunUntil=0;
  lastHitAt=0;

  rebuildHazardsIfNeeded();
}

function updateCar(dt){
  const nowMs = Date.now();
  const stunned = nowMs < stunUntil;

  // acceleration model
  const ACC=26;
  const DEC=22;
  const MAX=20.5;
  const MAX_BOOST=34;
  const TURN=2.35;

  if(!stunned){
    if(keys.forward) carSpeed = Math.min(MAX, carSpeed + ACC*dt);
    else carSpeed = Math.max(0, carSpeed - DEC*dt);
  }else{
    carSpeed = Math.max(0, carSpeed - 28*dt);
  }

  // boost: usable every 8s, lasts ~1.2s, BLUE burst
  if(keys.boost && nowMs >= boostReadyAt && !stunned){
    boostActiveUntil = nowMs + 1200;
    boostReadyAt = nowMs + 8000;
    spawnBoostBurst();
  }
  const boosting = (nowMs < boostActiveUntil && !stunned);
  if(boosting) carSpeed = Math.max(carSpeed, MAX_BOOST);

  // traction penalty off-track
  const near=nearestParam(car.position.x,car.position.z);
  if(near.d > 4.2){
    carSpeed *= 0.94;
  }

  // steering
  const turn=(keys.left?-1:0)+(keys.right?1:0);
  car.rotation.y -= turn * dt * TURN;

  // movement
  const forward=new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion);
  car.position.addScaledVector(forward, carSpeed * dt);
  car.position.y=.1;

  // flame visuals: orange idle, BLUE when boosting
  car.flameG.visible = (carSpeed > 0.1);
  const jitter = 0.85 + Math.random()*0.3;
  if(boosting){
    car.flame1.material.color.setHex(0x22b9ff);
    car.flame2.material.color.setHex(0xa9f2ff);
    car.flame1.material.opacity = 0.85;
    car.flame2.material.opacity = 0.75;
    car.flameG.scale.set(1.0, 1.6*jitter, 1.6*jitter);
  }else{
    car.flame1.material.color.setHex(0xff8b2e);
    car.flame2.material.color.setHex(0xfff0b8);
    car.flame1.material.opacity = 0.55;
    car.flame2.material.opacity = 0.45;
    car.flameG.scale.set(1.0, 0.9*jitter, 0.9*jitter);
  }

  // Road-rock bumps (slight slow)
  for(const rr of roadRocks){
    const d = rr.mesh.position.distanceTo(car.position);
    if(d < rr.r + 0.95 && (nowMs - lastHitAt > 500)){
      lastHitAt = nowMs;
      // bump: tiny push + slowdown (not stun)
      const dir=new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);
      car.position.addScaledVector(dir,-0.9);
      carSpeed *= 0.72;
      spawnRockBumpFX(rr.mesh.position.clone());
      // little camera shake via micro ring
      addRingFX({pos:car.position.clone(), color:0xcbd5e1, inner:0.6, outer:1.1, life:0.18, grow:5.5, opacity:0.25});
      break;
    }
  }

  // lap completion
  const p = nearestParam(car.position.x,car.position.z).t;
  if(p > Math.PI*.9 && p < Math.PI*1.1) firstCheckpoint=true;
  if(firstCheckpoint && lastParam > 5.7 && p < .5){
    submitLap();
  }
  lastParam=p;
}

// ---------- Overlay/HUD ----------
function updateOverlayAndHud(){
  if(!raceState){
    if(overlayMode!=="info"){
      showModal("Connecting‚Ä¶","Waiting for race state‚Ä¶",[{label:"Return to Lobby",className:"ghost",onClick:()=>location.href="/lobby/lobby.html"}]);
      overlayMode="info";
    }
    return;
  }

  const ph = raceState.phase || "pregame";
  const now = Date.now();
  const drivePhase = (ph==="racing" || ph==="lap_wait");

  if(ph !== lastSeenPhase){
    lastSeenPhase = ph;

    if(drivePhase){
      rebuildHazardsIfNeeded();
      if(!isRacing) startLapLocal();
    }

    if(ph==="countdown"){
      isRacing=false;
      clearThreats();
      lastHazardKey=null;
    }

    if(ph==="obstacle_select"){
      isRacing=false;
      clearThreats();
    }
  }

  // Countdown overlay: true 10s and auto-disappears at 0
  if(ph==="countdown" && raceState.countdownEndsAt){
    const sec = Math.max(0, Math.ceil((raceState.countdownEndsAt - now)/1000));
    setOverlayCountdown(sec);
    if(sec<=0) hideModal();
  }
  else if(ph==="obstacle_select"){
    const canPick = (raceState.selectorUid === uid);
    const used = raceState.obstacles || [];
    let opts = obstacleOrder.filter(o=>!used.includes(o));
    if(!opts.length) opts=[...obstacleOrder];

    if(overlayMode!=="select"){
      overlayMode="select";
      showModal(
        canPick ? "Choose the next threat" : "Waiting for bottom performer‚Ä¶",
        `<b>${(raceState.lastSelectorReason||"Slowest racer chooses the next threat.")}</b><br/>
         <span style="color:var(--muted)">Your pick stacks for all later rounds, and the picker is immune to that threat.</span>`,
        []
      );
    }

    const wrap=el("overlayButtons");
    wrap.innerHTML="";

    if(canPick){
      opts.forEach(o=>{
        const bt=document.createElement("button");
        bt.textContent = OBSTACLES[o].name;
        bt.onclick = ()=>updateDoc(RACE_REF,{pickedObstacle:o,updatedAt:serverTimestamp()});
        wrap.appendChild(bt);
      });
      const rand=document.createElement("button");
      rand.className="ghost";
      rand.textContent="Random";
      rand.onclick=()=>updateDoc(RACE_REF,{pickedObstacle:opts[Math.floor(Math.random()*opts.length)],updatedAt:serverTimestamp()});
      wrap.appendChild(rand);
    } else {
      const bt=document.createElement("button");
      bt.className="ghost";
      bt.textContent="Waiting‚Ä¶";
      bt.disabled=true;
      wrap.appendChild(bt);
    }

    el("overlay").classList.add("show");
  }
  else if(ph==="pregame"){
    if(overlayMode!=="info"){
      showModal("Figure-8 Rush","Waiting for host to start‚Ä¶",[
        {label:"Enter Fullscreen",className:"warn",onClick:()=>document.documentElement.requestFullscreen?.()},
        {label:"Hide",className:"ghost",onClick:hideModal}
      ]);
      overlayMode="info";
    }
  }
  else {
    if(overlayMode && ph!=="finished"){
      hideModal();
    }
  }

  // HUD numbers
  const lapElapsed = isRacing ? ((Date.now()-lapStart)/1000) : 0;
  el("lapTimer").textContent = lapElapsed.toFixed(3);

  const cd = Math.max(0, (boostReadyAt - Date.now())/1000);
  el("boostText").textContent = cd>0 ? `Cooldown ${cd.toFixed(1)}s` : "Ready";
  el("boostBtn").classList.toggle("onCd", cd>0);

  const status = (Date.now() < stunUntil) ? "Stunned!" :
    (drivePhase ? (isRacing ? "Racing" : "Lap locked") : "Waiting");
  el("statusText").textContent = status;

  if(drivePhase){
    rebuildHazardsIfNeeded();
  }
}

// ---------- Render loop ----------
let prev=performance.now();
function loop(t){
  const dt=Math.min(.033,(t-prev)/1000);
  prev=t;

  const ph=raceState?.phase||"pregame";
  const drivePhase = (ph==="racing" || ph==="lap_wait");

  if(drivePhase){
    updateThreats(dt);
    if(isRacing) updateCar(dt);
  }

  updateFX(dt);

  // Camera chase with slight damping
  const follow=new THREE.Vector3(
    car.position.x + Math.sin(car.rotation.y)*13,
    15,
    car.position.z + Math.cos(car.rotation.y)*13
  );
  camera.position.lerp(follow,.08);
  camera.lookAt(car.position.x,1.2,car.position.z);

  renderer.setSize(innerWidth,innerHeight,false);
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();

  renderer.render(scene,camera);

  updateOverlayAndHud();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ---------- Controls ----------
function setupControls(){
  addEventListener("keydown",e=>{
    if(e.key==='ArrowUp'||e.key==='w') keys.forward=true;
    if(e.key==='ArrowLeft'||e.key==='a') keys.left=true;
    if(e.key==='ArrowRight'||e.key==='d') keys.right=true;
    if(e.key===' ') keys.boost=true;
  });
  addEventListener("keyup",e=>{
    if(e.key==='ArrowUp'||e.key==='w') keys.forward=false;
    if(e.key==='ArrowLeft'||e.key==='a') keys.left=false;
    if(e.key==='ArrowRight'||e.key==='d') keys.right=false;
    if(e.key===' ') keys.boost=false;
  });

  const pad=el("pad"),dot=el("padDot");
  function movePad(ev){
    const r=pad.getBoundingClientRect();
    const t=(ev.touches?ev.touches[0]:ev);
    const x=Math.max(0,Math.min(r.width,t.clientX-r.left));
    const y=Math.max(0,Math.min(r.height,t.clientY-r.top));
    dot.style.left=(x-13)+"px";
    dot.style.top=(y-13)+"px";
    keys.forward = y < r.height*0.82;
    keys.left = x < r.width*0.40;
    keys.right = x > r.width*0.60;
  }
  ["touchstart","touchmove","mousedown","mousemove"].forEach(evt=>{
    pad.addEventListener(evt,e=>{
      if(evt.includes("move") && e.buttons===0 && !e.touches) return;
      movePad(e);
    }, {passive:false});
  });
  ["touchend","mouseup","mouseleave"].forEach(evt=>{
    pad.addEventListener(evt,()=>{
      keys.forward=keys.left=keys.right=false;
      dot.style.left="62px";
      dot.style.top="62px";
    });
  });

  const boost=el("boostBtn");
  const down=()=>keys.boost=true, up=()=>keys.boost=false;
  boost.addEventListener("touchstart",down,{passive:true});
  boost.addEventListener("touchend",up);
  boost.addEventListener("mousedown",down);
  boost.addEventListener("mouseup",up);
  boost.addEventListener("mouseleave",up);
}
setupControls();

// ---------- Auth + Firestore wiring ----------
onAuthStateChanged(auth, async user=>{
  if(!user){ await signInAnonymously(auth); return; }

  uid=user.uid;
  el("statusText").textContent="Connected";

  if(!gameId){
    showModal("Missing gameId","Open from lobby so the race can sync multiplayer state.",[
      {label:"Back to Lobby",onClick:()=>location.href="/lobby/lobby.html"}
    ]);
    overlayMode="info";
    return;
  }

  const lobbySnap=await getDoc(LOBBY_REF);
  lobbyState=lobbySnap.data()||{};
  isHost=(lobbyState.hostUid===uid);

  await ensureRaceDoc();
  await joinRacePlayer();

  onSnapshot(RACE_REF, snap=>{
    if(!snap.exists()) return;
    raceState=snap.data();
    renderBoard();
    hostMaybeStart();
  });

  setInterval(hostTick, 350);
});
</script>
</body>
</html>
