<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <title>üìà StockKings ‚Äî Donut Rush (1‚Äì8P)</title>
  <style>
    :root{--bg:#050812;--panel:#0e1726;--line:#2b4369;--ink:#ecf3ff;--muted:#9fb0cc;--accent:#57b2ff;--good:#60f0a1;--warn:#ffd972;--bad:#ff6f89}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,Segoe UI,Roboto,sans-serif}
    #app{position:relative;height:100%;overflow:hidden}
    #scene{position:absolute;inset:0}
    .hud{position:absolute;inset:0;pointer-events:none;display:flex;flex-direction:column;justify-content:space-between;padding:12px}
    .top{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .chip{pointer-events:auto;background:rgba(10,15,25,.82);border:1px solid var(--line);border-radius:12px;padding:8px 10px;font-weight:800}
    .chip small{display:block;color:var(--muted);font-weight:650}
    .big{font-size:24px;font-weight:950}
    .board{pointer-events:auto;background:rgba(8,11,19,.9);border:1px solid var(--line);border-radius:14px;padding:10px;max-width:560px;max-height:48vh;overflow:auto}
    table{width:100%;border-collapse:collapse;font-size:13px}
    th,td{padding:6px;border-bottom:1px solid #21324e;text-align:left}
    .msg{font-size:13px;color:var(--muted);margin-top:8px}
    .tags{display:flex;flex-wrap:wrap;gap:6px;margin-top:8px}
    .tag{font-size:12px;padding:4px 8px;border-radius:999px;border:1px solid #2f4468;background:rgba(87,178,255,.08);color:#cfe7ff}

    .modalWrap{position:absolute;inset:0;background:rgba(3,6,12,.74);display:none;align-items:center;justify-content:center;padding:16px;z-index:20}
    .modalWrap.show{display:flex}
    .modal{pointer-events:auto;background:var(--panel);border:1px solid var(--line);border-radius:16px;max-width:760px;width:min(760px,95vw);padding:16px;box-shadow:0 16px 60px rgba(0,0,0,.45)}
    .modal h2{margin:0 0 8px}
    .modal p{margin:6px 0;color:var(--muted);line-height:1.35}
    .btns{display:flex;flex-wrap:wrap;gap:10px;margin-top:12px}
    button{cursor:pointer;border:1px solid #35649f;background:#1d4b80;color:#fff;border-radius:10px;padding:10px 12px;font-weight:900}
    button.ghost{background:#182133;border-color:#344867}
    button.warn{background:#6d4f12;border-color:#a0802e}
    button:disabled{opacity:.55;cursor:not-allowed}

    .controls{position:absolute;inset:auto 0 10px 0;display:none;justify-content:space-between;padding:0 10px;z-index:8}
    .pad,.boost{pointer-events:auto;background:rgba(8,14,24,.75);border:1px solid #35517a;border-radius:14px;touch-action:none}
    .pad{width:150px;height:150px;position:relative}
    .padDot{position:absolute;width:26px;height:26px;border-radius:50%;background:#68b8ff;left:62px;top:62px;pointer-events:none;box-shadow:0 0 14px rgba(104,184,255,.45)}
    .boost{width:120px;height:120px;display:grid;place-items:center;font-weight:1000;letter-spacing:.4px}
    .boost.onCd{background:rgba(45,18,18,.86);border-color:#8b3f3f}
    .mobileFsBtn{position:absolute;right:10px;top:10px;z-index:12;display:none;padding:9px 12px;border-radius:10px;background:rgba(8,14,24,.78);border:1px solid #35517a;color:#fff;font-weight:850}
    .mobileFsBtn.show{display:block}
    @media (max-width:920px){html,body{touch-action:none}.controls{display:flex}.board{max-width:none}}
  </style>
</head>
<body>
<div id="app">
  <canvas id="scene"></canvas>
  <button id="mobileFsBtn" class="mobileFsBtn" type="button">‚õ∂ Fullscreen</button>

  <div class="hud">
    <div class="top">
      <div class="chip"><small>Status</small><span id="statusText">Connecting‚Ä¶</span></div>
      <div class="chip"><small>Phase</small><span id="phaseText">‚Äî</span></div>
      <div class="chip"><small>Round</small><span id="roundText">‚Äî</span></div>
      <div class="chip"><small>Lap Timer</small><span class="big" id="lapTimer">00.000</span></div>
      <div class="chip"><small>Boost</small><span id="boostText">Ready</span></div>
    </div>

    <div class="board">
      <h3 style="margin:0 0 8px">üèÅ Round Results</h3>
      <table>
        <thead><tr><th>Player</th><th>R1</th><th>R2</th><th>R3</th><th>Avg</th></tr></thead>
        <tbody id="scoreRows"></tbody>
      </table>
      <div class="tags" id="threatTags"></div>
      <div class="msg" id="waitingMsg">‚Äî</div>
    </div>
  </div>

  <div class="controls">
    <div class="pad" id="pad"><div class="padDot" id="padDot"></div></div>
    <button class="boost" id="boostBtn">BOOST</button>
  </div>

  <div class="modalWrap show" id="overlay">
    <div class="modal">
      <h2 id="overlayTitle">StockKings ‚Äî Donut Rush</h2>
      <p id="overlayBody">Connecting‚Ä¶</p>
      <div class="btns" id="overlayButtons"></div>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.162/build/three.module.js";
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getAuth, signInAnonymously, onAuthStateChanged, setPersistence, browserLocalPersistence, signOut } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
import { getFirestore, doc, getDoc, setDoc, onSnapshot, runTransaction } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

/* ============================================================
   FIREBASE INIT
============================================================ */
const firebaseConfig={
  apiKey:"AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain:"bible-game-246c0.firebaseapp.com",
  projectId:"bible-game-246c0",
  storageBucket:"bible-game-246c0.appspot.com",
  messagingSenderId:"959619818996",
  appId:"1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app=initializeApp(firebaseConfig);
const auth=getAuth(app);
const db=getFirestore(app);

const LS_USER="gh.username";
const LS_LOBBY="gh.lastLobbyId";

const params=new URLSearchParams(location.search);
const gameId=(params.get("gameId")||localStorage.getItem(LS_LOBBY)||"").trim();
const username=(params.get("username")||localStorage.getItem(LS_USER)||"Racer").trim();
if(gameId) localStorage.setItem(LS_LOBBY, gameId);
if(username) localStorage.setItem(LS_USER, username);

const LOBBY_REF = gameId ? doc(db,"lobbies",gameId) : null;
const RACE_REF  = gameId ? doc(db,"lobbies",gameId,"crowncouncil","stockkingsRace") : null;

/* ============================================================
   GAME CONFIG
============================================================ */
const COUNTDOWN_MS = 9000;
const DEADLINE_MS  = 30000;
const SELECT_MS    = 15000;
const MAX_ROUNDS   = 3;
const MAX_PLAYERS  = 8;

const OBSTACLES={
  meteorites:{name:"Meteorites",desc:"Telegraphed impacts that stun briefly.",stunMs:2200},
  monsters:{name:"Track Monsters",desc:"Roam the road and body-check racers."},
  eggs:{name:"Egg Storm",desc:"Bouncy eggs spill out and knock racers back."},
  towers:{name:"Lightning Towers",desc:"Periodic zaps near the ring."},
  rhinos:{name:"Rhino Stampede",desc:"Stampede around the donut and shove racers back."}
};
const obstacleOrder=Object.keys(OBSTACLES);

/* ============================================================
   DOM
============================================================ */
const el=id=>document.getElementById(id);

let overlayKey="";
function showOverlay(key,title,body,buttons){
  overlayKey=key;
  el("overlayTitle").textContent=title;
  el("overlayBody").innerHTML=body;
  const wrap=el("overlayButtons"); wrap.innerHTML="";
  (buttons||[]).forEach(b=>{
    const bt=document.createElement("button");
    bt.textContent=b.label;
    if(b.className) bt.className=b.className;
    if(b.disabled) bt.disabled=true;
    bt.onclick=b.onClick||(()=>{});
    wrap.appendChild(bt);
  });
  el("overlay").classList.add("show");
}
function hideOverlay(){
  overlayKey="";
  el("overlay").classList.remove("show");
}

function isMobile(){ return innerWidth < 920; }

async function requestFullscreen(){
  try{
    const root=document.documentElement;
    if(document.fullscreenElement){
      await document.exitFullscreen?.();
      return;
    }
    await root.requestFullscreen?.();
  }catch(e){}
}

function updateFullscreenBtn(){
  const btn=el("mobileFsBtn");
  if(!btn) return;
  btn.classList.toggle("show", isMobile());
  btn.textContent=document.fullscreenElement?"üóó Exit Fullscreen":"‚õ∂ Fullscreen";
}

/* ============================================================
   AUTH-SAFE BOOTSTRAP (THIS FIXES YOUR PERMISSION-DENIED)
============================================================ */
async function ensureAuthed(){
  // Strongly persist auth across pages
  try{ await setPersistence(auth, browserLocalPersistence); }catch(e){}

  if(auth.currentUser) return auth.currentUser;

  // Kick anon sign-in
  try{ await signInAnonymously(auth); }catch(e){}

  // Wait until request.auth is definitely non-null
  return await new Promise((resolve, reject)=>{
    const timeout=setTimeout(()=>reject(new Error("auth-timeout")), 9000);
    const unsub=onAuthStateChanged(auth, (u)=>{
      if(u){
        clearTimeout(timeout);
        unsub();
        resolve(u);
      }
    });
  });
}

/* ============================================================
   RACE STATE
============================================================ */
let lobbyState=null;
let raceState=null;
let lobbyUnsub=null;
let raceUnsub=null;
let pendingTxn=false;
let retriedWithoutAuth=false;

function now(){ return Date.now(); }
function avg(arr){
  const v=(arr||[]).filter(n=>typeof n==="number");
  return v.length ? (v.reduce((a,b)=>a+b,0)/v.length) : null;
}
function fmt(n){ return typeof n==="number" ? n.toFixed(2)+"s" : "‚Äî"; }

function expectedPlayers(){
  return (raceState?.expectedPlayers && Array.isArray(raceState.expectedPlayers) && raceState.expectedPlayers.length)
    ? raceState.expectedPlayers
    : (lobbyState?.players || [username]);
}
function lobbyStarted(){ return (lobbyState?.status === "started"); }

async function txn(mutator){
  if(!RACE_REF) return;
  if(pendingTxn) return;
  pendingTxn=true;
  try{
    await runTransaction(db, async (tx)=>{
      const snap=await tx.get(RACE_REF);
      if(!snap.exists()) return;
      const d=snap.data();
      const out = mutator(d);
      if(!out) return;
      tx.set(RACE_REF, out, {merge:false});
    });
  }catch(e){
    // surface errors
    showOverlay("txerr","Sync error",
      `<b>${String(e?.code||"error")}</b><br/>${String(e?.message||e)}`,
      [{label:"Back to Lobby", className:"warn", onClick:()=>location.href="/lobby/lobby.html"}]
    );
  }finally{
    pendingTxn=false;
  }
}

async function ensureRaceDoc(){
  if(!RACE_REF) return;
  const snap=await getDoc(RACE_REF);
  if(snap.exists()) return;

  const exp = (lobbyState?.players && lobbyState.players.length) ? lobbyState.players.slice(0,MAX_PLAYERS) : [username];
  const players = {};
  exp.forEach(n=>players[n]={name:n,laps:[],avg:null,lastLap:null});
  players[username]=players[username]||{name:username,laps:[],avg:null,lastLap:null};

  await setDoc(RACE_REF,{
    game:"stockkings-race",
    phase:"lobby_wait",
    round:1,
    maxRounds:MAX_ROUNDS,
    expectedPlayers:exp,
    players,
    obstacles:[],                 // stacked cumulatively
    countdownEndsAt:null,
    deadlineAt:null,
    selector:null,
    selectEndsAt:null,
    winnerName:null,
    lastSelectorReason:"",
    updatedAtMs: now(),
    createdAtMs: now()
  }, {merge:false});
}

async function ensureMeInPlayers(){
  await txn((d)=>{
    const exp = (Array.isArray(d.expectedPlayers)&&d.expectedPlayers.length)
      ? d.expectedPlayers.slice(0,MAX_PLAYERS)
      : (lobbyState?.players||[username]).slice(0,MAX_PLAYERS);

    if(!exp.includes(username)) exp.push(username);
    exp.splice(MAX_PLAYERS);

    d.players = d.players || {};
    exp.forEach(n=>{
      if(!d.players[n]) d.players[n]={name:n,laps:[],avg:null,lastLap:null};
      d.players[n].laps = d.players[n].laps || [];
      d.players[n].avg  = (typeof d.players[n].avg==="number") ? d.players[n].avg : avg(d.players[n].laps);
    });

    d.expectedPlayers = exp;
    d.updatedAtMs = now();
    return d;
  });
}

function computeBottomSelector(d){
  const exp=(d.expectedPlayers||[]).slice(0,MAX_PLAYERS);
  const round=d.round||1;
  const players=d.players||{};
  const entries=exp.map(n=>{
    const t=players[n]?.laps?.[round-1];
    return {name:n, t:(typeof t==="number")?t:30};
  });
  const maxT=Math.max(...entries.map(e=>e.t));
  const bottoms=entries.filter(e=>e.t===maxT);
  return bottoms[Math.floor(Math.random()*bottoms.length)].name;
}

function computeWinner(d){
  const exp=(d.expectedPlayers||[]).slice(0,MAX_PLAYERS);
  const players=d.players||{};
  let bestName=null,best=1e18;
  exp.forEach(n=>{
    const a=avg(players[n]?.laps||[]);
    if(typeof a==="number" && a<best){best=a;bestName=n;}
  });
  return bestName || exp[0] || null;
}

async function maybeStartFromLobby(){
  if(!raceState || !lobbyStarted()) return;
  if(raceState.phase==="lobby_wait"){
    await txn((d)=>{
      if(d.phase!=="lobby_wait") return null;
      d.phase="countdown";
      d.countdownEndsAt=now()+COUNTDOWN_MS;
      d.updatedAtMs=now();
      return d;
    });
  }
}

async function advanceCountdownIfNeeded(){
  if(!raceState) return;
  if(raceState.phase!=="countdown") return;
  if(!raceState.countdownEndsAt) return;
  if(now() < raceState.countdownEndsAt) return;

  await txn((d)=>{
    if(d.phase!=="countdown") return null;
    if(now() < (d.countdownEndsAt||0)) return null;
    d.phase="racing";
    d.deadlineAt=null;
    d.selector=null;
    d.selectEndsAt=null;
    d.lastSelectorReason="";
    d.updatedAtMs=now();
    return d;
  });
}

async function finalizeDeadlineIfNeeded(){
  if(!raceState) return;
  if(raceState.phase!=="lap_wait") return;
  if(!raceState.deadlineAt) return;
  if(now() < raceState.deadlineAt) return;

  await txn((d)=>{
    if(d.phase!=="lap_wait") return null;
    if(now() < (d.deadlineAt||0)) return null;

    const round=d.round||1;
    const exp=(d.expectedPlayers||[]).slice(0,MAX_PLAYERS);
    d.players=d.players||{};
    exp.forEach(n=>{
      const p=d.players[n]||(d.players[n]={name:n,laps:[],avg:null,lastLap:null});
      p.laps=p.laps||[];
      if(typeof p.laps[round-1]!=="number"){
        p.laps[round-1]=30;
        p.lastLap=30;
        p.avg=avg(p.laps);
      }
    });

    if(round >= (d.maxRounds||MAX_ROUNDS)){
      d.phase="finished";
      d.winnerName=computeWinner(d);
      d.updatedAtMs=now();
      return d;
    }

    d.phase="obstacle_select";
    d.selector=computeBottomSelector(d);
    d.selectEndsAt=now()+SELECT_MS;
    d.lastSelectorReason="Deadline reached ‚Äî slowest lap chooses next threat.";
    d.deadlineAt=null;
    d.updatedAtMs=now();
    return d;
  });
}

async function chooseThreat(type=null, auto=false){
  if(!raceState) return;
  if(raceState.phase!=="obstacle_select") return;

  const exp=expectedPlayers();
  const single=exp.length<=1;

  await txn((d)=>{
    if(d.phase!=="obstacle_select") return null;

    const exp=(d.expectedPlayers||[]).slice(0,MAX_PLAYERS);
    const single = exp.length<=1;
    const canPick = single || auto || (d.selector===username);
    if(!canPick) return null;

    const used=Array.isArray(d.obstacles)?d.obstacles.slice():[];
    const all=obstacleOrder;
    const avail=all.filter(o=>!used.includes(o));

    let pick=(type && all.includes(type))?type:null;
    if(!pick) pick = (avail.length ? avail : all)[Math.floor(Math.random()*(avail.length?avail.length:all.length))];
    if(avail.length && used.includes(pick)) pick = avail[Math.floor(Math.random()*avail.length)];

    // stack cumulatively; avoid repeats until exhausted, then allow repeats
    if(avail.length){
      if(!used.includes(pick)) used.push(pick);
    }else{
      used.push(pick);
    }

    d.obstacles=used;
    d.round=(d.round||1)+1;
    d.phase="countdown";
    d.countdownEndsAt=now()+COUNTDOWN_MS;
    d.selector=null;
    d.selectEndsAt=null;
    d.deadlineAt=null;
    d.lastSelectorReason = auto ? "Auto-picked (timeout / solo)." : "";
    d.updatedAtMs=now();
    return d;
  });
}

async function autoPickIfNeeded(){
  if(!raceState) return;
  if(raceState.phase!=="obstacle_select") return;

  const exp=expectedPlayers();
  const single=exp.length<=1;

  if(single){
    await chooseThreat(null,true);
    return;
  }
  if(raceState.selectEndsAt && now() >= raceState.selectEndsAt){
    await chooseThreat(null,true);
  }
}

async function submitLap(lapSeconds){
  await txn((d)=>{
    const round=d.round||1;
    const maxRounds=d.maxRounds||MAX_ROUNDS;
    const exp=(d.expectedPlayers||[]).slice(0,MAX_PLAYERS);
    if(!exp.includes(username)) exp.push(username);
    exp.splice(MAX_PLAYERS);

    if(!(d.phase==="racing" || d.phase==="lap_wait")) return null;
    if(d.deadlineAt && now() > d.deadlineAt) return null;

    d.players=d.players||{};
    const me=d.players[username]||(d.players[username]={name:username,laps:[],avg:null,lastLap:null});
    me.laps=me.laps||[];
    if(typeof me.laps[round-1]==="number") return null;

    const time=Math.min(30, Math.max(0.5, lapSeconds));
    me.laps[round-1]=time;
    me.lastLap=time;
    me.avg=avg(me.laps);

    exp.forEach(n=>{
      const p=d.players[n]||(d.players[n]={name:n,laps:[],avg:null,lastLap:null});
      p.laps=p.laps||[];
      p.avg=(typeof p.avg==="number")?p.avg:avg(p.laps);
    });
    d.expectedPlayers=exp;

    const done=exp.map(n=>typeof d.players[n]?.laps?.[round-1]==="number");
    const anyFinished=done.some(Boolean);
    const everyoneDone=done.every(Boolean);

    if(everyoneDone){
      if(round >= maxRounds){
        d.phase="finished";
        d.winnerName=computeWinner(d);
        d.updatedAtMs=now();
        return d;
      }
      d.phase="obstacle_select";
      d.selector=computeBottomSelector(d);
      d.selectEndsAt=now()+SELECT_MS;
      d.lastSelectorReason="Slowest lap chooses next threat.";
      d.deadlineAt=null;
      d.updatedAtMs=now();
      return d;
    }

    if(!d.deadlineAt && anyFinished){
      d.phase="lap_wait";
      d.deadlineAt=now()+DEADLINE_MS;
      d.updatedAtMs=now();
      return d;
    }

    d.updatedAtMs=now();
    return d;
  });
}

/* ============================================================
   THREE WORLD ‚Äî WIDE DONUT ROAD + INNER/OUTER WALLS
============================================================ */
const renderer=new THREE.WebGLRenderer({canvas:el("scene"),antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));

const scene=new THREE.Scene();
scene.background=new THREE.Color(0x69b8ff);
scene.fog=new THREE.FogExp2(0x69b8ff, 0.010);

const camera=new THREE.PerspectiveCamera(62,1,0.1,1400);

scene.add(new THREE.HemisphereLight(0xcfeaff,0x244b25,1.1));
const sun=new THREE.DirectionalLight(0xffffff,1);
sun.position.set(20,40,20);
scene.add(sun);

// Ground
const ground=new THREE.Mesh(
  new THREE.PlaneGeometry(420,420),
  new THREE.MeshStandardMaterial({color:0x2f8d44,roughness:.96})
);
ground.rotation.x=-Math.PI/2;
scene.add(ground);

// ROAD GEOMETRY (wide)
const ROAD_R = 52;          // centerline radius
const ROAD_W = 34;          // WIDENED A TON
const INNER_R = ROAD_R - ROAD_W/2;
const OUTER_R = ROAD_R + ROAD_W/2;

const road = new THREE.Mesh(
  new THREE.RingGeometry(INNER_R, OUTER_R, 140, 1),
  new THREE.MeshStandardMaterial({color:0x8a5d30,roughness:.86,metalness:.02})
);
road.rotation.x=-Math.PI/2;
road.position.y=0.02;
scene.add(road);

// Lane stripe ring
const stripe = new THREE.Mesh(
  new THREE.RingGeometry(ROAD_R-0.35, ROAD_R+0.35, 140, 1),
  new THREE.MeshBasicMaterial({color:0xe9f2ff,transparent:true,opacity:0.45})
);
stripe.rotation.x=-Math.PI/2;
stripe.position.y=0.03;
scene.add(stripe);

// WALLS (visual rings)
function wallCylinder(radius, color){
  const m=new THREE.Mesh(
    new THREE.CylinderGeometry(radius, radius, 2.1, 160, 1, true),
    new THREE.MeshStandardMaterial({color,roughness:.8,metalness:.05,side:THREE.DoubleSide})
  );
  m.position.y=1.05;
  return m;
}
const innerWall = wallCylinder(INNER_R, 0x354155);
const outerWall = wallCylinder(OUTER_R, 0x354155);
scene.add(innerWall, outerWall);

// Start line
const startLine = new THREE.Mesh(
  new THREE.PlaneGeometry(ROAD_W, 2.8),
  new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:0.6,side:THREE.DoubleSide})
);
startLine.rotation.x=-Math.PI/2;
startLine.position.set(ROAD_R, 0.031, 0);
startLine.rotation.z=Math.PI/2;
scene.add(startLine);

/* ============================================================
   CAR (smaller) + BOOST FLAME (blue burst)
============================================================ */
function buildCar(){
  const g=new THREE.Group();
  const body=new THREE.Mesh(
    new THREE.BoxGeometry(2.4,.85,3.8),
    new THREE.MeshStandardMaterial({color:0x1f74ff,metalness:.25,roughness:.35})
  );
  body.position.y=.9;
  const top=new THREE.Mesh(
    new THREE.BoxGeometry(1.6,.65,1.7),
    new THREE.MeshStandardMaterial({color:0xd8e8ff,metalness:.05,roughness:.5})
  );
  top.position.set(0,1.38,-.15);
  g.add(body,top);

  [[-.9,.35,-1.15],[.9,.35,-1.15],[-.9,.35,1.15],[.9,.35,1.15]].forEach(([x,y,z])=>{
    const w=new THREE.Mesh(new THREE.CylinderGeometry(.40,.40,.36,16),
      new THREE.MeshStandardMaterial({color:0x101218,roughness:.9})
    );
    w.rotation.z=Math.PI/2;
    w.position.set(x,y,z);
    g.add(w);
  });

  const flameMat=new THREE.MeshBasicMaterial({color:0xff7a22,transparent:true,opacity:.9});
  const flame=new THREE.Mesh(new THREE.ConeGeometry(.26,1.28,10), flameMat);
  flame.position.set(0,.9,2.3);
  flame.rotation.x=Math.PI/2;
  g.add(flame);
  g.flame=flame; g.flameMat=flameMat;

  // make it a bit smaller overall
  g.scale.set(0.82,0.82,0.82);
  return g;
}
const car=buildCar();
scene.add(car);

const START_A = 0; // start at (ROAD_R, 0)
function setCarAtStart(){
  const x=Math.cos(START_A)*ROAD_R;
  const z=Math.sin(START_A)*ROAD_R;
  car.position.set(x,0.1,z);

  // CCW direction tangent at angle a is (-sin(a), cos(a)) => (0,1) here (toward +Z)
  car.rotation.set(0, 0, 0);
  car.rotation.y = Math.atan2(0, 1) + Math.PI; // face "forward" along -Z local, so rotate 180 from +Z
}
setCarAtStart();

/* ============================================================
   TRACK HELPERS + WALL COLLISION
============================================================ */
const CAR_R = 1.05; // collision radius-ish for walls/rocks

function normAngle(a){
  const two=Math.PI*2;
  a%=two; if(a<0) a+=two;
  return a;
}
const startTheta = normAngle(START_A);

function roadInfo(x,z){
  const r=Math.hypot(x,z);
  const onRoad = (r>INNER_R+0.25 && r<OUTER_R-0.25);
  const distToEdge = Math.min(Math.abs(r-INNER_R), Math.abs(OUTER_R-r));
  return {r,onRoad,distToEdge};
}

function enforceWalls(){
  const r=Math.hypot(car.position.x, car.position.z) || 0.0001;
  const nx=car.position.x/r;
  const nz=car.position.z/r;

  // inner
  const minR = INNER_R + CAR_R;
  if(r < minR){
    car.position.x = nx*minR;
    car.position.z = nz*minR;
    return true;
  }
  // outer
  const maxR = OUTER_R - CAR_R;
  if(r > maxR){
    car.position.x = nx*maxR;
    car.position.z = nz*maxR;
    return true;
  }
  return false;
}

/* ============================================================
   THREATS + FX (happen throughout the lap, not just at the start)
============================================================ */
const threats=[];
const boomFX=[];
function addBoom(pos, colorHex){
  const ring=new THREE.Mesh(
    new THREE.RingGeometry(0.2,0.7,32),
    new THREE.MeshBasicMaterial({color:colorHex,transparent:true,opacity:0.85,side:THREE.DoubleSide})
  );
  ring.rotation.x=-Math.PI/2;
  ring.position.set(pos.x,0.07,pos.z);
  scene.add(ring);
  boomFX.push({mesh:ring,life:0.5});
}
function clearThreats(){
  threats.splice(0).forEach(t=>scene.remove(t.mesh));
  boomFX.splice(0).forEach(b=>scene.remove(b.mesh));
}
function spawnThreats(){
  clearThreats();
  const active=(raceState?.obstacles||[]);
  if(!active.length) return;

  const pickR = ()=> (INNER_R+4) + Math.random()*(ROAD_W-8);
  active.forEach((type,stackIdx)=>{
    // spawn a few instances per stacked threat
    const n = 3 + Math.min(2, stackIdx);
    for(let i=0;i<n;i++){
      const a = normAngle((stackIdx*0.95 + i*(Math.PI*2/n) + (Math.random()-.5)*0.22));
      const r = pickR();
      const x=Math.cos(a)*r;
      const z=Math.sin(a)*r;

      let mesh=null;

      if(type==="meteorites"){
        mesh=new THREE.Mesh(
          new THREE.CylinderGeometry(2.2,2.2,.06,28),
          new THREE.MeshBasicMaterial({color:0xffc266,transparent:true,opacity:0.33})
        );
        mesh.position.set(x,0.06,z);
        threats.push({type,mesh,rad:2.3,timer:1.8+Math.random()*3.2,hot:0});
      }

      if(type==="monsters"){
        mesh=new THREE.Mesh(
          new THREE.BoxGeometry(1.6,1.7,1.6),
          new THREE.MeshStandardMaterial({color:0x6f32a8,roughness:.65,metalness:.05,emissive:0x1a0830,emissiveIntensity:.35})
        );
        mesh.position.set(x,0.95,z);
        threats.push({type,mesh,rad:1.8,da:(Math.random()>.5?1:-1)*(0.5+Math.random()*0.7),a, r});
      }

      if(type==="eggs"){
        mesh=new THREE.Mesh(
          new THREE.SphereGeometry(.82,18,12),
          new THREE.MeshStandardMaterial({color:0xf4efe5,roughness:.4,metalness:0})
        );
        mesh.position.set(x,.82,z);
        threats.push({type,mesh,rad:1.25,v:new THREE.Vector2((Math.random()-.5)*2.6,(Math.random()-.5)*2.6)});
      }

      if(type==="towers"){
        mesh=new THREE.Group();
        const p=new THREE.Mesh(new THREE.CylinderGeometry(.75,1.05,4.3,10),
          new THREE.MeshStandardMaterial({color:0x3e4b63,roughness:.85})
        );
        p.position.y=2.1;
        const ring=new THREE.Mesh(
          new THREE.RingGeometry(2.8,3.4,28),
          new THREE.MeshBasicMaterial({color:0x9ec9ff,side:THREE.DoubleSide,transparent:true,opacity:.55})
        );
        ring.rotation.x=-Math.PI/2;
        const core=new THREE.Mesh(new THREE.SphereGeometry(.28,14,10), new THREE.MeshBasicMaterial({color:0xbfe0ff}));
        core.position.y=4.15;
        mesh.add(p,ring,core);
        mesh.position.set(x,0,z);
        threats.push({type,mesh,rad:3.2,flash:0,cool:0.9+Math.random()*2.1});
      }

      if(type==="rhinos"){
        mesh=new THREE.Mesh(
          new THREE.BoxGeometry(2.2,1.4,3.2),
          new THREE.MeshStandardMaterial({color:0x7b7f86,roughness:.8,metalness:.08})
        );
        mesh.position.set(x,.7,z);
        threats.push({type,mesh,rad:2.1,a, r: ROAD_R + (Math.random()-.5)*(ROAD_W*0.2)});
      }

      if(mesh) scene.add(mesh);
    }
  });
}

/* ============================================================
   ROAD ROCKS (bumps that slow you)
============================================================ */
function hashSeed(s){
  let h=2166136261>>>0;
  for(let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h = Math.imul(h,16777619); }
  return h>>>0;
}
function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
}
const rand = mulberry32(hashSeed(gameId||"solo"));
const roadRocks=[];
function spawnRoadRocks(){
  roadRocks.splice(0).forEach(r=>scene.remove(r.mesh));
  const rockMat=new THREE.MeshStandardMaterial({color:0x5a5f66,roughness:.95});
  for(let i=0;i<26;i++){
    const a=normAngle(rand()*Math.PI*2);
    const r=(INNER_R+4) + rand()*(ROAD_W-8);
    const x=Math.cos(a)*r, z=Math.sin(a)*r;

    const s=0.55 + rand()*0.95;
    const mesh=new THREE.Mesh(new THREE.DodecahedronGeometry(s,0), rockMat);
    mesh.position.set(x,0.15,z);
    mesh.rotation.set(rand()*3,rand()*3,rand()*3);
    scene.add(mesh);
    roadRocks.push({mesh,rad:s*0.95,hitCd:0});
  }
}
spawnRoadRocks();

/* ============================================================
   GAMEPLAY (LOCAL)
============================================================ */
let isRacing=false;
let lapStart=0;
let stunUntil=0;
let boostReadyAt=0;
let lastHitAt=0;
let bumpSlowUntil=0;

let halfWay=false;
let lastProgress=0;

const keys={forward:false,left:false,right:false,boost:false};

function startLapLocal(){
  setCarAtStart();
  isRacing=true;
  lapStart=now();
  stunUntil=0;
  bumpSlowUntil=0;
  halfWay=false;
  lastProgress=0;
}

function lapProgress(theta){
  // CCW progress from startTheta in [0, 2œÄ)
  const t=normAngle(theta);
  const p=normAngle(t - startTheta);
  return p;
}

function updateFX(dt){
  for(let i=boomFX.length-1;i>=0;i--){
    const b=boomFX[i];
    b.life-=dt;
    const s=1+(0.5-b.life)*5.2;
    b.mesh.scale.set(s,s,s);
    b.mesh.material.opacity=Math.max(0,b.life/0.5)*0.85;
    if(b.life<=0){ scene.remove(b.mesh); boomFX.splice(i,1); }
  }
}

function updateThreats(dt){
  updateFX(dt);

  threats.forEach(t=>{
    if(t.type==="meteorites"){
      t.timer -= dt;
      t.hot = Math.max(0, t.hot - dt);
      if(t.timer <= 0){
        t.timer = 2.6 + Math.random()*3.2;     // throughout the lap
        t.hot   = 0.28;
        t.mesh.material.color.setHex(0xff4b4b);
        addBoom(t.mesh.position, 0xff4b4b);
        setTimeout(()=>{ if(t.mesh?.material) t.mesh.material.color.setHex(0xffc266); }, 220);
      }
    }

    if(t.type==="monsters"){
      t.a = normAngle(t.a + t.da*dt*0.45);
      const x=Math.cos(t.a)*t.r, z=Math.sin(t.a)*t.r;
      t.mesh.position.set(x,0.95,z);
    }

    if(t.type==="eggs"){
      t.mesh.position.x += t.v.x*dt;
      t.mesh.position.z += t.v.y*dt;
      t.v.multiplyScalar(0.985);
    }

    if(t.type==="towers"){
      t.flash = Math.max(0, t.flash-dt);
      t.cool -= dt;
      if(t.cool<=0){
        t.cool = 0.9 + Math.random()*2.1;
        t.flash = 0.22;
        addBoom(t.mesh.position, 0x9ec9ff);
      }
      const ring=t.mesh.children[1];
      ring.material.opacity = 0.42 + (t.flash*2.0);
    }

    if(t.type==="rhinos"){
      t.a = normAngle(t.a + dt*0.9);
      const x=Math.cos(t.a)*t.r, z=Math.sin(t.a)*t.r;
      t.mesh.position.set(x,0.7,z);
    }

    // collisions
    const d=t.mesh.position.distanceTo(car.position);
    if(d < t.rad + CAR_R && now()-lastHitAt>1200){
      if(t.type==="meteorites" && t.hot<=0) return; // only punish on boom window

      lastHitAt=now();
      if(t.type==="meteorites"||t.type==="towers"){
        stunUntil=Math.max(stunUntil, now() + (t.type==="meteorites"?2200:1700));
      }
      if(t.type==="eggs"){
        const back=new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);
        car.position.addScaledVector(back, 2.6);
        t.dead=true;
        addBoom(t.mesh.position, 0xffffff);
      }
      if(t.type==="rhinos"||t.type==="monsters"){
        const back=new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);
        car.position.addScaledVector(back, 6.0);
        stunUntil=Math.max(stunUntil, now()+900);
        addBoom(car.position, 0xff6f89);
      }
    }
  });

  for(let i=threats.length-1;i>=0;i--){
    if(threats[i].dead){ scene.remove(threats[i].mesh); threats.splice(i,1); }
  }
}

function updateRoadRocks(dt){
  for(const r of roadRocks){
    r.hitCd=Math.max(0,r.hitCd-dt);
    const d=r.mesh.position.distanceTo(car.position);
    if(d < r.rad + CAR_R && r.hitCd<=0){
      r.hitCd=1.1;
      bumpSlowUntil=Math.max(bumpSlowUntil, now()+650);
      const back=new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);
      car.position.addScaledVector(back, 1.0);
      addBoom(r.mesh.position, 0x5a5f66);
    }
  }
}

function updateCar(dt){
  const t=now();
  const stunned = t < stunUntil;

  // on-road = faster; off-road = slower
  const ri = roadInfo(car.position.x, car.position.z);
  const onRoad = ri.onRoad;

  let speed = onRoad ? 22 : 12;
  if(keys.forward && !stunned) speed = onRoad ? 30 : 16;

  // bumps
  if(t < bumpSlowUntil) speed *= 0.72;

  // boost
  const boosting = keys.boost && (t > boostReadyAt) && !stunned;
  if(boosting){
    speed = onRoad ? 46 : 26;
    boostReadyAt = t + 8000;
    addBoom(car.position, 0x3bd7ff); // blue burst pop
  }

  // steering
  const turn=(keys.left?-1:0)+(keys.right?1:0);
  car.rotation.y -= turn * dt * 2.3;

  // move forward along car direction
  const forward=new THREE.Vector3(0,0,-1).applyQuaternion(car.quaternion);
  car.position.addScaledVector(forward, speed*dt);
  car.position.y=0.1;

  // enforce inner/outer walls physically
  const hitWall = enforceWalls();
  if(hitWall){
    bumpSlowUntil=Math.max(bumpSlowUntil, now()+350);
  }

  // flame visuals: blue while boosting, otherwise orange
  const cdLeft=Math.max(0,(boostReadyAt - t)/1000);
  el("boostBtn").classList.toggle("onCd", cdLeft>0.01);

  const baseColor=new THREE.Color(0xff7a22);
  const boostColor=new THREE.Color(0x3bd7ff);
  car.flameMat.color.copy(baseColor).lerp(boostColor, boosting ? 1 : 0.15);
  const flameScale = boosting ? 2.0 : (cdLeft>0.01 ? 1.05 : 0.8);
  car.flame.scale.set(1, flameScale, flameScale);

  // lap detection using angle progress
  const theta = Math.atan2(car.position.z, car.position.x);
  const prog = lapProgress(theta);

  if(prog > Math.PI) halfWay=true;

  // completed loop when we pass near start again after halfway
  if(halfWay && lastProgress > 6.0 && prog < 0.25){
    const lapSec=(t-lapStart)/1000;
    isRacing=false;
    submitLap(lapSec);
  }
  lastProgress=prog;
}

/* ============================================================
   CAMERA (mobile-friendly: slight downward, above & behind)
============================================================ */
function updateCamera(){
  const mobile = isMobile();
  const height = mobile ? 56 : 18;
  const behind = mobile ? 8 : 16;

  camera.fov = mobile ? 84 : 62;

  const back = new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion); // behind (since forward is -Z)
  const desired = new THREE.Vector3(
    car.position.x + back.x*behind,
    height,
    car.position.z + back.z*behind
  );
  camera.position.lerp(desired, mobile ? 0.2 : 0.10);
  camera.lookAt(car.position.x, 1.2, car.position.z);
}

/* ============================================================
   UI
============================================================ */
function renderBoard(){
  const exp=expectedPlayers().slice(0,MAX_PLAYERS);
  const players=raceState?.players||{};
  const rows=exp.map(n=>{
    const p=players[n]||{laps:[]};
    const laps=p.laps||[];
    return {name:n,l1:laps[0],l2:laps[1],l3:laps[2],avg:avg(laps)};
  }).sort((a,b)=>((a.avg??999)-(b.avg??999)));

  el("scoreRows").innerHTML = rows.map(r=>`
    <tr>
      <td>${r.name}${r.name===username?" (you)":""}</td>
      <td>${fmt(r.l1)}</td>
      <td>${fmt(r.l2)}</td>
      <td>${fmt(r.l3)}</td>
      <td>${fmt(r.avg)}</td>
    </tr>`).join("");

  el("phaseText").textContent = (raceState?.phase||"‚Äî").replaceAll("_"," ");
  el("roundText").textContent = `${raceState?.round||1} / ${raceState?.maxRounds||MAX_ROUNDS}`;

  const used=(raceState?.obstacles||[]);
  el("threatTags").innerHTML = used.length
    ? used.map(o=>`<span class="tag">‚ö†Ô∏è ${OBSTACLES[o]?.name||o}</span>`).join("")
    : `<span class="tag">No threats yet</span>`;

  const phase=raceState?.phase||"";
  const t=now();
  if(!lobbyState) el("waitingMsg").textContent="Connecting to lobby‚Ä¶";
  else if(!lobbyStarted()) el("waitingMsg").textContent="Waiting for lobby host to start‚Ä¶";
  else if(phase==="countdown"){
    const s=Math.max(0, Math.ceil(((raceState?.countdownEndsAt||t)-t)/1000));
    el("waitingMsg").textContent=`Round starts in ${s}s.`;
  }else if(phase==="lap_wait"){
    const s=Math.max(0, Math.ceil(((raceState?.deadlineAt||t)-t)/1000));
    el("waitingMsg").textContent=`Waiting for racers‚Ä¶ ${s}s until timeouts.`;
  }else if(phase==="obstacle_select"){
    el("waitingMsg").textContent=(raceState?.selector===username)
      ? "You were slowest ‚Äî choose the next threat!"
      : `Waiting for ${raceState?.selector||"slowest racer"} to choose threat‚Ä¶`;
  }else if(phase==="racing"){
    el("waitingMsg").textContent="Race!";
  }else if(phase==="finished"){
    el("waitingMsg").textContent=`üèÜ Winner: ${raceState?.winnerName||"‚Äî"}`;
  }else{
    el("waitingMsg").textContent="Syncing‚Ä¶";
  }
}

function renderOverlay(){
  if(!gameId){
    showOverlay("nogame","Missing gameId",
      "Open StockKings from the Lobby so multiplayer syncing works.",
      [{label:"Back to Lobby", className:"warn", onClick:()=>location.href="/lobby/lobby.html"}]
    );
    return;
  }

  if(!lobbyState){
    showOverlay("connLobby","Connecting to Lobby‚Ä¶",
      "Waiting for Firestore lobby doc access‚Ä¶",
      []
    );
    return;
  }

  if(!lobbyStarted()){
    showOverlay("waitStart","Waiting for Lobby Start",
      "Host hasn‚Äôt started the match yet. Go back and press <b>Start Game</b>.",
      [{label:"Back to Lobby", className:"warn", onClick:()=>location.href="/lobby/lobby.html"}]
    );
    return;
  }

  if(!raceState){
    showOverlay("connRace","Connecting to Race State‚Ä¶","Creating/reading race doc‚Ä¶",[]);
    return;
  }

  const phase=raceState.phase;
  const t=now();

  if(phase==="countdown"){
    const s=Math.max(0, Math.ceil(((raceState.countdownEndsAt||t)-t)/1000));
    showOverlay("countdown","Race starts soon",
      `<b style="font-size:28px">${s}</b> seconds until launch.<br/>Boost cooldown: <b>8s</b>.<br/>Threats stack each round.`,
      [
        {label:"Fullscreen", className:"warn", onClick:requestFullscreen},
        {label:"Ready", className:"ghost", onClick:hideOverlay}
      ]
    );
    return;
  }

  if(phase==="obstacle_select"){
    const exp=expectedPlayers();
    const single=exp.length<=1;

    const used=raceState.obstacles||[];
    const avail=obstacleOrder.filter(o=>!used.includes(o));
    const options=(avail.length?avail:obstacleOrder);

    const canPick = single || (raceState.selector===username);
    const end=raceState.selectEndsAt || (t+SELECT_MS);
    const s=Math.max(0, Math.ceil((end-t)/1000));
    const reason=raceState.lastSelectorReason || "Slowest lap chooses the next threat.";

    const buttons = canPick
      ? options.map(o=>({label:OBSTACLES[o].name, onClick:()=>chooseThreat(o,false)}))
        .concat([{label:"Random", className:"ghost", onClick:()=>chooseThreat(null,false)}])
      : [{label:"Waiting‚Ä¶", className:"ghost", disabled:true}];

    showOverlay("pickThreat", canPick ? "Choose the next threat" : "Waiting for threat choice",
      `<b>${reason}</b><br/>Selection closes in <b>${s}s</b>.`,
      buttons
    );
    return;
  }

  if(phase==="finished"){
    const w=raceState.winnerName||"Winner";
    const a=avg((raceState.players?.[w]?.laps)||[]);
    showOverlay("finished","üèÜ Race Complete",
      `<b>${w}</b> wins with the lowest average time (${typeof a==="number"?a.toFixed(2)+"s":"‚Äî"}).`,
      [{label:"Return to Lobby", className:"warn", onClick:()=>location.href="/lobby/lobby.html"}]
    );
    return;
  }

  hideOverlay();
}

function renderHUD(){
  const t=now();
  const lapElapsed = isRacing ? ((t-lapStart)/1000) : 0;
  el("lapTimer").textContent = lapElapsed.toFixed(3);

  const cdLeft=Math.max(0,(boostReadyAt-t)/1000);
  el("boostText").textContent = cdLeft ? `Cooldown ${cdLeft.toFixed(1)}s` : "Ready";

  const phase=raceState?.phase||"";
  let status =
    !lobbyState ? "Connecting to lobby‚Ä¶" :
    !lobbyStarted() ? "Waiting for start‚Ä¶" :
    !raceState ? "Connecting to race‚Ä¶" :
    (t < stunUntil) ? "Stunned!" :
    (phase==="racing") ? "Racing" :
    (phase==="lap_wait") ? "Waiting‚Ä¶" :
    (phase==="countdown") ? "Countdown‚Ä¶" :
    (phase==="obstacle_select") ? "Choosing threat‚Ä¶" :
    (phase==="finished") ? "Finished" :
    "Syncing‚Ä¶";

  el("statusText").textContent=status;
}

/* ============================================================
   MAIN LOOP
============================================================ */
let prev=performance.now();
function loop(ts){
  const dt=Math.min(.033,(ts-prev)/1000); prev=ts;

  updateThreats(dt);
  updateRoadRocks(dt);

  if(raceState?.phase==="racing"){
    if(!isRacing) startLapLocal();
    updateCar(dt);
  }else{
    isRacing=false;
  }

  updateCamera();

  renderer.setSize(innerWidth,innerHeight,false);
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.render(scene,camera);

  renderHUD();
  renderBoard();
  renderOverlay();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ============================================================
   CONTROLS
============================================================ */
function setupControls(){
  const fsBtn=el("mobileFsBtn");
  fsBtn?.addEventListener("click", requestFullscreen);
  updateFullscreenBtn();
  addEventListener("resize", updateFullscreenBtn);
  document.addEventListener("fullscreenchange", updateFullscreenBtn);

  addEventListener("keydown",e=>{
    if(e.key==="ArrowUp"||e.key==="w") keys.forward=true;
    if(e.key==="ArrowLeft"||e.key==="a") keys.left=true;
    if(e.key==="ArrowRight"||e.key==="d") keys.right=true;
    if(e.key===" ") keys.boost=true;
  });
  addEventListener("keyup",e=>{
    if(e.key==="ArrowUp"||e.key==="w") keys.forward=false;
    if(e.key==="ArrowLeft"||e.key==="a") keys.left=false;
    if(e.key==="ArrowRight"||e.key==="d") keys.right=false;
    if(e.key===" ") keys.boost=false;
  });

  const pad=el("pad"), dot=el("padDot");
  function movePad(ev){
    const r=pad.getBoundingClientRect();
    const t=(ev.touches?ev.touches[0]:ev);
    const x=Math.max(0,Math.min(r.width, t.clientX-r.left));
    const y=Math.max(0,Math.min(r.height, t.clientY-r.top));
    dot.style.left=(x-13)+"px";
    dot.style.top=(y-13)+"px";
    keys.forward = y < r.height*0.82;
    keys.left    = x < r.width*0.40;
    keys.right   = x > r.width*0.60;
  }
  ["touchstart","touchmove","mousedown","mousemove"].forEach(evt=>{
    pad.addEventListener(evt, e=>{
      if(evt.includes("move") && e.buttons===0 && !e.touches) return;
      movePad(e);
    }, {passive:false});
  });
  ["touchend","mouseup","mouseleave"].forEach(evt=>{
    pad.addEventListener(evt, ()=>{
      keys.forward=keys.left=keys.right=false;
      dot.style.left="62px"; dot.style.top="62px";
    });
  });

  const boost=el("boostBtn");
  const down=()=>keys.boost=true, up=()=>keys.boost=false;
  boost.addEventListener("touchstart",down,{passive:true});
  boost.addEventListener("touchend",up);
  boost.addEventListener("mousedown",down);
  boost.addEventListener("mouseup",up);
  boost.addEventListener("mouseleave",up);
}
setupControls();

/* ============================================================
   NETWORK: LISTENERS ATTACH ONLY AFTER AUTH IS READY
============================================================ */
function attachLobbyListeners(){
  if(!LOBBY_REF) return;

  if(lobbyUnsub) lobbyUnsub();
  lobbyUnsub = onSnapshot(
    LOBBY_REF,
    async (snap)=>{
      if(!snap.exists()){
        lobbyState=null;
        showOverlay("nolobby","Lobby not found",
          "This lobby doc doesn't exist anymore.",
          [{label:"Back to Lobby", className:"warn", onClick:()=>location.href="/lobby/lobby.html"}]
        );
        return;
      }
      lobbyState=snap.data()||{};
      await ensureRaceDoc();
      await ensureMeInPlayers();
      await maybeStartFromLobby();

      // attach race once
      if(!raceUnsub){
        raceUnsub = onSnapshot(
          RACE_REF,
          (rsnap)=>{
            if(!rsnap.exists()) return;
            const prevObsSig=JSON.stringify(raceState?.obstacles||[]);
            raceState=rsnap.data();
            const nextObsSig=JSON.stringify(raceState?.obstacles||[]);
            if(nextObsSig!==prevObsSig) spawnThreats();
          },
          (err)=>{
            showOverlay("racePerm","Race permission error",
              `<b>${String(err?.code||"error")}</b><br/>${String(err?.message||err)}`,
              [{label:"Back to Lobby", className:"warn", onClick:()=>location.href="/lobby/lobby.html"}]
            );
          }
        );
      }
    },
    async (err)=>{
      const code=String(err?.code||"");
      const msg=String(err?.message||err||"");
      if(!retriedWithoutAuth && (code.includes("permission-denied") || msg.includes("permission-denied"))){
        retriedWithoutAuth=true;
        try{ await signOut(auth); }catch(e){}
        attachLobbyListeners();
        return;
      }
      showOverlay("lobbyPerm","Lobby permission error",
        `<b>${code||"error"}</b><br/>${msg}<br/><br/>
        Retried once with signed-out auth=null mode. If this still fails, check Firestore rules for this lobby path.`,
        [{label:"Back to Lobby", className:"warn", onClick:()=>location.href="/lobby/lobby.html"}]
      );
    }
  );
}

function tickStateMachine(){
  if(!raceState) return;
  advanceCountdownIfNeeded();
  finalizeDeadlineIfNeeded();
  autoPickIfNeeded();
}

(async function main(){
  if(!gameId){
    renderOverlay();
    return;
  }
  try{
    await ensureAuthed();
  }catch(e){
    showOverlay("authFail","Auth failed",
      `Could not establish Firebase Auth.<br/><br/>
       If you‚Äôre running on a custom domain, add it to <b>Firebase Auth ‚Üí Authorized domains</b>.`,
      [{label:"Back to Lobby", className:"warn", onClick:()=>location.href="/lobby/lobby.html"}]
    );
    return;
  }

  attachLobbyListeners();
  setInterval(tickStateMachine, 250);
})();
</script>
</body>
</html>
