<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>📈 Stock Kings — 5 Round Showdown (Boosted)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <style>
    :root{
      --bg:#0e1116; --ink:#e9eef5; --muted:#9db0c4; --card:#121722; --br:#1e2734;
      --accent:#4da3ff; --good:#38ef7d; --bad:#ff6b6b; --warn:#ffd166;
      --tile:#0f141e; --tile-br:#1b2533; --shadow:0 12px 36px rgba(0,0,0,.25);
      --stage-max: 1100px; --radius:16px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--ink);
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";
      -webkit-tap-highlight-color: transparent;
    }
    button { touch-action: manipulation; cursor:pointer }

    .wrap{display:grid; grid-template-rows:auto 1fr; min-height:100%}

    /* Top Bar */
    .top{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding:10px 12px; border-bottom:1px solid var(--br); background:#0b0f17; position:sticky; top:0; z-index:6;
    }
    .round{font-weight:800}
    .timer{font-weight:900; font-size:20px; letter-spacing:.5px}
    .wins{display:flex; gap:10px; flex-wrap:wrap; font-size:13px; color:var(--muted)}
    .wins .me{color:#fff; font-weight:800}

    .toggles{display:flex; gap:8px; align-items:center}
    .toggle{
      display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border:1px solid var(--br);
      border-radius:10px; background:#0f1522; font-weight:800; color:#cfe0f4;
    }

    /* Layout */
    .board{
      display:grid;
      grid-template-columns: minmax(0,1fr) min(max(660px, 66vw), var(--stage-max)) minmax(0,1fr);
      gap:12px; padding:12px;
    }
    @media (max-width: 1080px){
      .board{grid-template-columns: 1fr}
    }
    .rail{ display:flex; flex-direction:column; gap:12px; }
    @media (max-width:1080px){
      #leftRail, #rightRail{ display:none; }
    }

    /* Center stage */
    .stage{
      width:100%; max-width: var(--stage-max); margin: 0 auto;
      display:grid; gap:12px;
      grid-template-areas:
        "top"
        "grid"
        "feed"
        "bottom";
      grid-template-rows: auto 1fr auto auto;
      min-height: calc(100vh - 120px);
    }
    @supports (height: 100svh) { .stage{ min-height: calc(100svh - 120px); } }

    .players-top{ grid-area: top; display:flex; flex-wrap:wrap; gap:10px; justify-content:center; }
    .players-bottom{ grid-area: bottom; display:flex; flex-wrap:wrap; gap:10px; justify-content:center; }

    /* Stocks grid */
    .stocks{
      grid-area: grid;
      display:grid; gap:12px;
      grid-template-columns: repeat(3, minmax(220px,1fr));
      justify-items:stretch; align-items:start;
    }
    @media (max-width: 860px){ .stocks{ grid-template-columns: repeat(2, minmax(200px,1fr)); } }
    @media (max-width: 520px){ .stocks{ grid-template-columns: 1fr; } }

    /* Player cards */
    .pbox{
      background:var(--card); border:1px solid var(--tile-br); border-radius:14px; padding:10px;
      display:flex; flex-direction:column; align-items:center; gap:4px; min-width: 190px; box-shadow:var(--shadow);
    }
    .pbox.me{ outline:2px solid var(--accent) }
    .p-val{ font-weight:900; font-size:18px }
    .p-name{ font-weight:800; color:var(--muted) }
    .p-wins{ font-size:12px; color:var(--muted) }
    .p-cash,.p-net{ font-size:12px; color:var(--muted) }

    /* Stock tile */
    .tile{
      background:var(--card); border:1px solid var(--tile-br); border-radius:var(--radius); padding:12px; display:grid;
      grid-template-rows: auto auto auto 1fr auto; gap:8px; position:relative; min-height: 236px; box-shadow:var(--shadow);
      overflow:hidden;
    }
    .head{display:flex; justify-content:space-between; align-items:baseline}
    .sym{font-weight:900; letter-spacing:.5px; font-size:18px}
    .price{font-weight:900}
    .spark{height:28px; width:100%;}
    .mine{ font-size:12px; color:var(--muted); display:flex; gap:8px; flex-wrap:wrap }

    .barwrap{
      border:1px solid var(--tile-br); border-radius:10px; padding:4px; height:100px; overflow:hidden; background:linear-gradient(180deg,#0c1320 0%,#0a101a 100%);
      position:relative;
    }
    .bar{
      position:absolute; left:4px; right:4px; bottom:4px; height:10px; border-radius:8px; background:var(--good);
      transition: height .25s ease;
    }
    .row{display:flex; gap:8px; align-items:center; justify-content:space-between}
    .btn{
      appearance:none; border:1px solid var(--tile-br); background:#132033; color:#fff; padding:10px 12px; border-radius:10px; font-weight:800;
    }
    .btn.sell{ background:#2c1a1a; border-color:#412121; position:relative }
    .btn:disabled{opacity:.6}
    .btn:hover{filter:brightness(1.06)}
    .cost{font-weight:700; color:var(--muted); font-size:12px}

    /* Opponent strip in tile */
    .opprow{
      display:flex; gap:6px; flex-wrap:wrap; align-items:center; min-height: 28px;
      margin-top:-4px;
    }
    .opp{
      --ring: #2a3f59;
      display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border:1px solid var(--tile-br);
      border-radius:999px; background:#0f1623; font-size:12px; color:#d5e2f3; position:relative;
      box-shadow:0 0 0 2px var(--ring) inset;
    }
    .opp .av{
      width:18px; height:18px; border-radius:50%; background:#0b1220; color:#cfe0f4; font-weight:900;
      display:inline-grid; place-items:center; border:1px solid var(--tile-br);
      font-size:11px;
    }
    .opp .qty{ font-weight:800 }
    .opp .pl{ font-weight:800 }
    .opp.good{ --ring: #1f8f66; }
    .opp.bad { --ring: #9f2b2b; }

    /* Floating notes */
    .float{
      position:absolute; left:50%; transform:translateX(-50%); bottom:56px;
      font-weight:900; pointer-events:none; opacity:0; animation: popfade 1.2s ease forwards;
      text-shadow: 0 2px 10px rgba(0,0,0,.45);
      padding:2px 8px; border-radius:8px; border:1px solid rgba(255,255,255,.08); backdrop-filter: blur(4px);
    }
    .float.good{ color:var(--good); background:rgba(20,60,40,.22) }
    .float.bad { color:var(--bad);  background:rgba(70,20,20,.22) }
    .float.neu { color:#dbeafe;    background:rgba(30,50,90,.22) }
    @keyframes popfade{
      0%{ transform:translate(-50%, 8px) scale(.95); opacity:0 }
      10%{ opacity:1; transform:translate(-50%, 0) scale(1) }
      100%{ transform:translate(-50%, -48px) scale(1); opacity:0 }
    }

    /* Cooldown lock on Sell */
    .lock{
      position:absolute; right:-6px; top:-6px; background:#1a2333; border:1px solid #2a3b59; color:#9db0c4; border-radius:8px;
      font-size:11px; padding:3px 6px;
    }

    /* Leaderboard */
    .lb-card{
      background:var(--card); border:1px solid var(--tile-br); border-radius:14px; padding:12px; box-shadow:var(--shadow);
    }
    .lb-title{ font-weight:900; margin-bottom:8px; display:flex; align-items:center; gap:8px }
    .lb-list{ list-style:none; padding:0; margin:0; display:flex; flex-direction:column; gap:6px; }
    .lb-row{ display:flex; align-items:center; justify-content:space-between; gap:12px; font-size:14px; }
    .lb-row .lb-left{ display:flex; align-items:center; gap:8px; }
    .lb-rank{
      width:22px; height:22px; display:inline-flex; align-items:center; justify-content:center;
      border-radius:6px; border:1px solid var(--tile-br); background:#0f1623; font-weight:800; font-size:12px; color:var(--muted);
    }
    .lb-name{ font-weight:800; }
    .lb-net{ font-variant-numeric: tabular-nums; }
    .lb-row.me .lb-name{ color:#fff; }
    .lb-mobile{ display:none; }
    @media (max-width:1080px){ .lb-mobile{ display:block; padding:0 12px 12px; } }

    /* Global activity feed */
    .feed{
      grid-area: feed;
      display:flex; gap:12px; align-items:stretch; flex-wrap:wrap; justify-content:center;
    }
    .ticker{
      flex:1 1 320px; max-width: var(--stage-max); background:var(--card); border:1px solid var(--tile-br);
      border-radius:14px; padding:10px; box-shadow:var(--shadow);
    }
    .tick-row{ display:flex; align-items:center; justify-content:space-between; font-size:13px; color:#cfe0f4; padding:6px 4px; border-bottom:1px dashed rgba(255,255,255,.06); }
    .tick-row:last-child{ border-bottom:0 }
    .tick-left{ display:flex; gap:8px; align-items:center }
    .tag{ font-size:11px; padding:3px 6px; border-radius:999px; background:#0f1623; border:1px solid var(--tile-br); font-weight:800; color:#8fb6e8 }
    .act-buy .tag{ color:#9ff1b5 }
    .act-sell .tag{ color:#f7a3a3 }

    /* Overlay for match end */
    .overlay{
      position:fixed; inset:0; background:rgba(0,0,0,.6);
      display:none; align-items:center; justify-content:center; z-index:20;
    }
    .overlay.show{ display:flex }
    .modal{
      background:var(--card); border:1px solid var(--br); border-radius:16px; padding:18px; width:min(560px, 92vw);
      box-shadow:0 30px 80px rgba(0,0,0,.45);
    }
    .modal h2{ margin:0 0 8px 0 }
    .modal p{ color:var(--muted); margin:6px 0 12px }
    .modal .btn{ width:100% }
  </style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <div class="round">
      <span id="modeLabel">Local Practice</span> · Round <b id="roundNo">1</b>/<b>5</b>
    </div>
    <div class="timer" id="timer">01:30</div>
    <div class="wins" id="winsBar"></div>
    <div class="toggles">
      <label class="toggle"><input id="posToggle" type="checkbox" checked /> Show Positions</label>
    </div>
  </div>

  <div class="board">
    <div class="rail" id="leftRail"></div>

    <div class="stage">
      <div class="players-top" id="topRail"></div>

      <div class="stocks" id="stocksGrid"><!-- tiles injected --></div>

      <!-- Global activity feed -->
      <div class="feed">
        <div class="ticker">
          <div class="lb-title">📰 Activity</div>
          <div id="tickerBody"></div>
        </div>
      </div>

      <div class="players-bottom" id="bottomRail"></div>

      <!-- Mobile leaderboard -->
      <div class="lb-mobile" id="lbMobile">
        <div class="lb-card">
          <div class="lb-title">🏁 Leaderboard</div>
          <ol class="lb-list" id="lbListMobile"></ol>
        </div>
      </div>
    </div>

    <!-- Desktop right rail leaderboard -->
    <div class="rail" id="rightRail">
      <div class="lb-card">
        <div class="lb-title">🏁 Leaderboard</div>
        <ol class="lb-list" id="lbList"></ol>
      </div>
    </div>
  </div>
</div>

<!-- Match end overlay -->
<div class="overlay" id="overlay">
  <div class="modal">
    <h2 id="overlayTitle">Match Over</h2>
    <p id="overlayMsg">Great game!</p>
    <button class="btn" id="overlayBtn">Play Again</button>
  </div>
</div>

<script type="module">
/* ===========================================================
   Firebase (multiplayer via lobby)
   =========================================================== */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot,
  runTransaction, serverTimestamp, increment
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);

/* ===========================================================
   Game constants
   =========================================================== */
const params     = new URLSearchParams(location.search);
const gameId     = params.get("gameId");
const username   = (params.get("username") || "Player").trim();
const LOBBY_REF  = gameId ? doc(db, "lobbies", gameId)      : null;
const GAME_REF   = gameId ? doc(db, "stockkings", gameId)   : null;

const ROUNDS          = 5;
const ROUND_MS        = 90_000;   // 1.5 minutes
const START_CASH      = 100;
const BASE_PRICE      = 15;
const MIN_PRICE       = 3;
const MAX_PRICE       = 60;
const HISTORY_LEN     = 48;
const ORDER_IMPACT    = 0.02;     // per-share impact scaled by 1/√players
const COOLDOWN_MS     = 8_000;    // SELL COOLDOWN after each BUY
const TICKER_KEEP     = 40;       // recent activity rows to keep
const STOCKS = [
  { key:"METAL",  name:"Metal"  },
  { key:"WOOL",   name:"Wool"   },
  { key:"WHEAT",  name:"Wheat"  },
  { key:"COFFEE", name:"Coffee" },
  { key:"ROCK",   name:"Rock"   },
];
const N = STOCKS.length;

/* small cross-impact matrix (gentle, symmetric-ish) */
const X = [
  /*        M     Wl    Wh    Cf    Rk */
  /* M */ [ 0.00, -0.06, 0.08, 0.00, 0.10],
  /* Wl */[-0.06, 0.00,  0.05, 0.02, 0.00],
  /* Wh */[ 0.08, 0.05,  0.00, 0.12, 0.00],
  /* Cf */[ 0.00, 0.02,  0.12, 0.00, 0.00],
  /* Rk */[ 0.10, 0.00,  0.00, 0.00, 0.00],
];

/* ===========================================================
   DOM helpers
   =========================================================== */
const $ = (id)=> document.getElementById(id);
const stocksGrid  = $("stocksGrid");
const topRail     = $("topRail");
const bottomRail  = $("bottomRail");
const leftRail    = $("leftRail");
const rightRail   = $("rightRail");
const timerEl     = $("timer");
const roundEl     = $("roundNo");
const winsBar     = $("winsBar");
const modeLabel   = $("modeLabel");
const overlayEl   = $("overlay");
const overlayTitle= $("overlayTitle");
const overlayMsg  = $("overlayMsg");
const overlayBtn  = $("overlayBtn");
const lbList      = $("lbList");
const lbListMobile= $("lbListMobile");
const tickerBody  = $("tickerBody");
const posToggle   = $("posToggle");

const fmt$ = (n)=> "$" + Number(n).toFixed(2);
const clamp = (v,a,b)=> Math.max(a, Math.min(b,v));

/* ===========================================================
   Local state
   =========================================================== */
let lobbyData   = null;
let isHost      = false;
let gameData    = null;
let tickerId    = null; // host drift loop
let timerId     = null; // UI clock loop
const bound     = new Set();

/* ===========================================================
   Builders
   =========================================================== */
function initStocks(){
  const out = [];
  for (let i=0;i<N;i++){
    const base = BASE_PRICE * (1 + (Math.random()*0.10 - 0.05));
    out.push({
      key: STOCKS[i].key,
      name: STOCKS[i].name,
      price: Number(base.toFixed(2)),
      min: MIN_PRICE, max: MAX_PRICE,
      history: Array.from({length: 12}, ()=> Number((base*(1+ (Math.random()*0.02 - 0.01))).toFixed(2)))
    });
  }
  return out;
}
function initPortfolios(players){
  const p = {};
  for (const name of players){
    p[name] = {
      cash: START_CASH,
      holdings: Array(N).fill(0),
      avgCost: Array(N).fill(0),
      cooldowns: Array(N).fill(0) // per-stock sell cooldownUntil (ms epoch)
    };
  }
  return p;
}
function holdingsValue(name, d){
  const pf = d?.portfolios?.[name]; if (!pf) return 0;
  let v = 0;
  for (let i=0;i<N;i++) v += (pf.holdings[i]||0) * d.stocks[i].price;
  return v;
}
function netValue(name, d){
  const pf = d?.portfolios?.[name]; if (!pf) return 0;
  return pf.cash + holdingsValue(name, d);
}

/* ===========================================================
   UI: Tiles + Opponents + Players + Ticker
   =========================================================== */
function initials(name){
  const p = name.trim().split(/\s+/);
  if (p.length===1) return p[0].slice(0,2).toUpperCase();
  return (p[0][0]||"").toUpperCase() + (p[1][0]||"").toUpperCase();
}
function ensureTiles(){
  if (stocksGrid.childElementCount) return;
  const frag = document.createDocumentFragment();
  for (let i=0;i<N;i++){
    const tile = document.createElement("div");
    tile.className = "tile";
    tile.dataset.idx = i;
    tile.innerHTML = `
      <div class="head">
        <div class="sym"><span id="s-name-${i}">—</span></div>
        <div class="price" id="s-price-${i}">$0.00</div>
      </div>
      <canvas class="spark" height="28" id="s-spark-${i}"></canvas>
      <div class="opprow" id="s-opps-${i}"></div>
      <div class="mine" id="s-mine-${i}">You own 0</div>
      <div class="barwrap"><div class="bar" id="s-bar-${i}" style="height:12px;"></div></div>
      <div class="row">
        <button class="btn buy"  id="s-buy-${i}">Buy</button>
        <div class="cost" id="s-cost-${i}">$0.00</div>
        <button class="btn sell" id="s-sell-${i}">Sell</button>
      </div>
    `;
    frag.appendChild(tile);
  }
  stocksGrid.appendChild(frag);
  sizeAllSparks();
}
function sizeSpark(i){
  const c = $(`s-spark-${i}`); if (!c) return;
  const tile = c.closest(".tile");
  const w = tile ? tile.clientWidth : 220;
  c.width = Math.max(160, w - 24);
  c.height = 28;
}
function sizeAllSparks(){ for(let i=0;i<N;i++) sizeSpark(i); }
function drawSpark(i, history){
  const c = $(`s-spark-${i}`); if (!c) return;
  const ctx = c.getContext("2d");
  ctx.clearRect(0,0,c.width,c.height);
  const n = history.length, min = Math.min(...history), max = Math.max(...history);
  const pad = 2, H = c.height - pad*2, W = c.width - pad*2;

  ctx.strokeStyle = "#2a3d57";
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(pad, pad + H); ctx.lineTo(pad+W, pad + H); ctx.stroke();

  ctx.strokeStyle = "#6cc1ff";
  ctx.lineWidth = 2; ctx.beginPath();
  for (let k=0;k<n;k++){
    const x = pad + (W*(k/(n-1||1)));
    const t = (history[k]-min)/Math.max(0.0001,(max-min));
    const y = pad + H - t*H;
    if (k===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();
}
function bindOnce(id, fn){
  if (bound.has(id)) return;
  const el = $(id); if (!el) return;
  el.addEventListener("click", fn);
  bound.add(id);
}
function cssSafe(s){ return String(s).replace(/[^a-zA-Z0-9_-]/g, "_"); }

function renderOpponentsStrip(i){
  const wrap = $(`s-opps-${i}`); if (!wrap) return;
  if (!posToggle.checked){ wrap.innerHTML=""; return; }
  const players = gameData?.players || [];
  const price   = gameData?.stocks?.[i]?.price || 0;
  const frag = document.createDocumentFragment();
  for (const p of players){
    if (p===username) continue;
    const pf = gameData.portfolios?.[p];
    if (!pf) continue;
    const qty = pf.holdings?.[i] || 0;
    const avg = pf.avgCost?.[i] || 0;
    const recent = isRecentActor(p, i); // shows even if 0 qty if just acted
    if (qty<=0 && !recent) continue;

    const plPct = avg>0 ? ((price - avg)/avg)*100 : 0;
    const div = document.createElement("div");
    div.className = "opp " + (plPct>=0 ? "good":"bad");
    div.title = `${p} • Qty ${qty} • Avg ${fmt$(avg)} • Now ${fmt$(price)}`;
    div.innerHTML = `
      <span class="av">${initials(p)}</span>
      <span class="qty">x${qty}</span>
      <span class="pl">${plPct>=0?'+':''}${plPct.toFixed(1)}%</span>
    `;
    frag.appendChild(div);
  }
  wrap.innerHTML = "";
  wrap.appendChild(frag);
}
function isRecentActor(user, idx){
  const evs = gameData?.events || [];
  const since = Date.now() - 8000;
  return evs.some(e => e.user===user && e.idx===idx && e.t>=since);
}

function renderStocks(){
  ensureTiles();
  if (!gameData?.stocks) return;
  requestAnimationFrame(()=>{
    sizeAllSparks();
    const me = gameData.portfolios?.[username];

    for (let i=0;i<N;i++){
      const s = gameData.stocks[i]; if (!s) continue;
      $(`s-name-${i}`).textContent  = s.name;
      $(`s-price-${i}`).textContent = fmt$(s.price);
      $(`s-cost-${i}`).textContent  = `Buy ${fmt$(s.price)} · Sell ${fmt$(s.price)}`;
      drawSpark(i, s.history || [s.price]);

      renderOpponentsStrip(i);

      // bar
      const bar = $(`s-bar-${i}`);
      if (bar && bar.parentElement){
        const wrapH = (bar.parentElement.offsetHeight) || 100;
        const hMax = Math.max(12, wrapH - 8);
        const t = clamp((s.price - MIN_PRICE) / (MAX_PRICE - MIN_PRICE), 0, 1);
        bar.style.height = (8 + t*(hMax-8)) + "px";
        bar.style.background = "linear-gradient(180deg,#5dffb3,#21a86a)";
      }

      // your position
      const mine = $(`s-mine-${i}`);
      if (mine){
        mine.innerHTML = "You own 0";
        if (me){
          const qty = me.holdings?.[i] || 0;
          const avg = me.avgCost?.[i] || 0;
          if (qty > 0){
            const diffPct = avg > 0 ? ((s.price - avg) / avg) * 100 : 0;
            const span1 = document.createElement("span");
            const span2 = document.createElement("span");
            const span3 = document.createElement("span");
            const pl    = document.createElement("span");
            span1.textContent = `Own ${qty}`;
            span2.textContent = `Avg ${fmt$(avg)}`;
            span3.textContent = `Now ${fmt$(s.price)}`;
            pl.className = "pl";
            pl.textContent = `(${diffPct>=0?'+':''}${diffPct.toFixed(1)}%)`;
            pl.style.color = diffPct>=0 ? "var(--good)" : "var(--bad)";
            mine.innerHTML = "";
            mine.appendChild(span1); mine.appendChild(span2); mine.appendChild(span3); mine.appendChild(pl);
          }
        }
      }

      // BUY/SELL state + cooldown
      const buyBtn  = $(`s-buy-${i}`);
      const sellBtn = $(`s-sell-${i}`);
      const have    = me ? (me.holdings?.[i] || 0) : 0;
      const cash    = me ? (me.cash ?? START_CASH) : START_CASH;

      if (buyBtn){ buyBtn.disabled = cash < s.price; }
      if (sellBtn){
        let leftMs = 0;
        if (me && me.cooldowns){
          const until = me.cooldowns[i] || 0;
          leftMs = Math.max(0, until - Date.now());
        }
        const leftSec = Math.ceil(leftMs/1000);
        const cooldownActive = leftMs > 0;
        sellBtn.disabled = cooldownActive || have <= 0;
        sellBtn.textContent = cooldownActive ? `Sell (${leftSec}s)` : "Sell";

        // lock badge
        sellBtn.querySelector(".lock")?.remove();
        if (cooldownActive){
          const lock = document.createElement("span");
          lock.className = "lock";
          lock.textContent = `⏳ ${leftSec}s`;
          sellBtn.appendChild(lock);
        }
      }

      bindOnce(`s-buy-${i}`,  ()=> order("buy", i));
      bindOnce(`s-sell-${i}`, ()=> order("sell", i));
    }
  });
}

function renderPlayers(){
  const players = gameData?.players || [username];
  const wins    = gameData?.wins    || {};
  winsBar.innerHTML = "";
  for (const p of players){
    const span = document.createElement("span");
    span.textContent = `${p}: ${wins[p]||0}`;
    if (p===username) span.className = "me";
    winsBar.appendChild(span);
  }
  const boxes = players.map(p=>{
    const div = document.createElement("div");
    div.className = "pbox" + (p===username ? " me":"");
    const net = gameData ? netValue(p, gameData) : START_CASH;
    const cash = gameData?.portfolios?.[p]?.cash ?? START_CASH;
    div.innerHTML = `
      <div class="p-val" id="pval-${cssSafe(p)}">${fmt$(net)}</div>
      <div class="p-name">${p}</div>
      <div class="p-cash" id="pcash-${cssSafe(p)}">Cash: ${fmt$(cash)}</div>
      <div class="p-net"  id="pnet-${cssSafe(p)}">Net: ${fmt$(net)}</div>
      <div class="p-wins">Round Wins: <b>${wins[p]||0}</b></div>
    `;
    return div;
  });
  topRail.innerHTML = bottomRail.innerHTML = leftRail.innerHTML = rightRail.innerHTML = "";
  const q = Math.ceil(boxes.length/4);
  const g = [ boxes.slice(0,q), boxes.slice(q,2*q), boxes.slice(2*q,3*q), boxes.slice(3*q) ];
  g[0].forEach(el=> topRail.appendChild(el));
  g[2].forEach(el=> bottomRail.appendChild(el));
  g[1].forEach(el=> rightRail.appendChild(el));
  g[3].forEach(el=> leftRail.appendChild(el));

  renderLeaderboard();
}
function refreshPlayerValues(){
  if (!gameData) return;
  for (const p of (gameData.players||[])){
    const cash = gameData?.portfolios?.[p]?.cash ?? START_CASH;
    const net  = netValue(p, gameData);
    const id = cssSafe(p);
    const pv = $(`pval-${id}`), pc = $(`pcash-${id}`), pn = $(`pnet-${id}`);
    if (pv) pv.textContent = fmt$(net);
    if (pc) pc.textContent = `Cash: ${fmt$(cash)}`;
    if (pn) pn.textContent = `Net: ${fmt$(net)}`;
  }
  renderLeaderboard();
}

/* ===== Ticker ===== */
function renderTicker(){
  const evs = (gameData?.events || []).slice().sort((a,b)=> b.t - a.t).slice(0, TICKER_KEEP);
  tickerBody.innerHTML = "";
  for (const e of evs){
    const row = document.createElement("div");
    row.className = "tick-row " + (e.kind==="buy" ? "act-buy" : "act-sell");
    const stock = gameData?.stocks?.[e.idx]?.name || "—";
    const plTxt = (e.kind==="sell" && typeof e.pl === "number")
      ? `<span style="font-weight:800;color:${e.pl>=0?'var(--good)':'var(--bad)'}">${e.pl>=0?'+':''}${fmt$(e.pl)}</span>`
      : "";
    row.innerHTML = `
      <div class="tick-left">
        <span class="tag">${e.kind==="buy"?'BUY':'SELL'}</span>
        <b>${e.user}</b>
        <span>1 × ${stock}</span>
      </div>
      <div>
        <span>${fmt$(e.price)}</span>
        ${plTxt}
      </div>
    `;
    tickerBody.appendChild(row);
  }
}

/* ===========================================================
   Leaderboard
   =========================================================== */
function renderLeaderboard(){
  if (!gameData) return;
  const players = gameData.players || [username];
  const arr = players.map(p => ({ name: p, net: netValue(p, gameData) }));
  arr.sort((a,b)=> b.net - a.net);

  function fillList(el){
    if (!el) return;
    el.innerHTML = "";
    arr.forEach((it, idx)=>{
      const li = document.createElement("li");
      li.className = "lb-row" + (it.name===username ? " me" : "");
      li.innerHTML = `
        <div class="lb-left">
          <span class="lb-rank">${idx+1}</span>
          <span class="lb-name">${it.name}</span>
        </div>
        <span class="lb-net">${fmt$(it.net)}</span>
      `;
      el.appendChild(li);
    });
  }
  fillList(lbList);
  fillList(lbListMobile);
}

/* ===========================================================
   Host loop: price drift + round controller
   =========================================================== */
function stopLoops(){ if (tickerId){ clearInterval(tickerId); tickerId=null; } if (timerId){ clearInterval(timerId); timerId=null; } }

function startHostLoop(){
  if (!isHost || !GAME_REF) return;
  stopLoops();
  tickerId = setInterval(async ()=>{
    try{
      await runTransaction(db, async (tx)=>{
        const snap = await tx.get(GAME_REF); if (!snap.exists()) return;
        const d = snap.data(); if (d.status !== "running") return;
        const now = Date.now();

        // price drift
        const stocks = d.stocks.map(s => ({...s}));
        const del = new Array(N).fill(0);
        for (let i=0;i<N;i++){
          const s = stocks[i];
          const meanRev = (BASE_PRICE - s.price) / (MAX_PRICE - MIN_PRICE);
          const noise   = (Math.random()*0.010 - 0.005);
          del[i] = meanRev * 0.25 + noise;
        }
        for (let i=0;i<N;i++){
          let mix = del[i];
          for (let j=0;j<N;j++){
            if (j===i) continue;
            mix += X[i][j] * del[j] * 0.35;
          }
          let np = stocks[i].price * (1 + mix);
          np = clamp(np, MIN_PRICE, MAX_PRICE);
          stocks[i].price = Number(np.toFixed(2));
          const hist = (stocks[i].history || []).slice(-HISTORY_LEN+1);
          hist.push(stocks[i].price);
          stocks[i].history = hist;
        }

        // round end?
        const left = (d.roundEndAt || 0) - now;
        if (left <= 0){
          const players = d.players || [];
          let best = -Infinity, winners = [];
          for (const p of players){
            const val = netValue(p, {stocks, portfolios:d.portfolios});
            if (val > best + 1e-6){ best = val; winners = [p]; }
            else if (Math.abs(val - best) < 1e-6){ winners.push(p); }
          }
          const wins = {...d.wins};
          for (const w of winners) wins[w] = (wins[w]||0) + 1;

          if ((d.round||1) >= ROUNDS){
            tx.update(GAME_REF, { status:"finished", wins, stocks });
          } else {
            tx.update(GAME_REF, {
              round: (d.round||1)+1,
              roundEndAt: Date.now() + ROUND_MS,
              wins,
              portfolios: initPortfolios(players),
              stocks: initStocks()
            });
          }
        } else {
          tx.update(GAME_REF, { stocks });
        }
      });
    }catch(e){ /* ignore transient errors */ }
  }, 1000);
}

function startUiClock(){
  timerId = setInterval(()=>{
    if (!gameData) return;
    const ms = Math.max(0, (gameData.roundEndAt || 0) - Date.now());
    const s  = Math.ceil(ms/1000);
    const mm = String(Math.floor(s/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    timerEl.textContent = `${mm}:${ss}`;
    refreshPlayerValues();
    renderStocks();
    renderTicker();
  }, 250);
}

/* ===========================================================
   Multiplayer bootstrapping
   =========================================================== */
async function ensureGameDoc(){
  if (!GAME_REF || !lobbyData) return;
  const g = await getDoc(GAME_REF);
  if (g.exists()) return;
  if (!isHost) return;
  const players = Array.isArray(lobbyData.players) && lobbyData.players.length ? lobbyData.players : [username];
  const payload = {
    host: lobbyData.host || username,
    players,
    status: "running",
    round: 1,
    roundEndAt: Date.now() + ROUND_MS,
    wins: Object.fromEntries(players.map(p=>[p,0])),
    portfolios: initPortfolios(players),
    stocks: initStocks(),
    events: [],
    createdAt: serverTimestamp()
  };
  await setDoc(GAME_REF, payload);
  startHostLoop();
}

if (LOBBY_REF){
  onSnapshot(LOBBY_REF, (snap)=>{
    if (!snap.exists()) return;
    lobbyData = snap.data();
    isHost = lobbyData.host === username;
    modeLabel.textContent = "Multiplayer";
    ensureGameDoc();
  });
}

if (GAME_REF){
  onSnapshot(GAME_REF, async (snap)=>{
    if (!snap.exists()) return;
    gameData = snap.data();

    // compat for old docs
    for (const p of gameData.players || []){
      const pf = gameData.portfolios?.[p];
      if (pf){
        if (!pf.avgCost)   pf.avgCost = Array(N).fill(0);
        if (!pf.cooldowns) pf.cooldowns = Array(N).fill(0);
      }
    }
    if (!Array.isArray(gameData.events)) gameData.events = [];

    roundEl.textContent = gameData.round || 1;
    renderPlayers();
    renderStocks();
    renderLeaderboard();
    renderTicker();
    if (!timerId) startUiClock();

    if (gameData.status === "finished"){
      const entries = Object.entries(gameData.wins || {});
      const topCount = Math.max(...entries.map(([,c])=>c), 0);
      const champs = entries.filter(([,c])=> c===topCount).map(([n])=>n);
      overlayTitle.textContent = "Match Over";
      overlayMsg.textContent   = `Winner${champs.length>1?'s':''}: ${champs.join(', ')}  —  ${topCount} round win${topCount===1?'':'s'}`;
      overlayEl.classList.add("show");
      if (isHost){
        for (const c of champs){
          try{ await updateDoc(doc(db,"users",c), { wins: increment(1) }); }
          catch(e){ try{ await setDoc(doc(db,"users",c), { wins: 1 }, { merge:true }); }catch(_){ } }
        }
        stopLoops();
      }
    }
  });
}

/* ===========================================================
   Orders (1 share per click) — with events + float notes
   =========================================================== */
function impactScale(data){
  const n = Math.max(1, (data?.players || []).length);
  return ORDER_IMPACT / Math.sqrt(n);
}
function addEventMut(d, ev){
  const arr = Array.isArray(d.events) ? d.events.slice() : [];
  arr.push(ev);
  const cutoff = Date.now() - 60_000; // keep ~last minute for doc size
  const trimmed = arr.filter(e => e.t >= cutoff).slice(-TICKER_KEEP);
  d.events = trimmed;
}
function floatNote(idx, text, cls="neu"){
  const tile = [...document.querySelectorAll(".tile")].find(t=> Number(t.dataset.idx)===idx);
  if (!tile) return;
  const n = document.createElement("div");
  n.className = "float " + cls;
  n.textContent = text;
  tile.appendChild(n);
  setTimeout(()=> n.remove(), 1400);
}

async function order(kind, idx){
  const beforePrice = gameData?.stocks?.[idx]?.price ?? 0;
  const myPf = gameData?.portfolios?.[username];
  const myAvg = myPf?.avgCost?.[idx] || 0;

  if (GAME_REF){
    try{
      await runTransaction(db, async (tx)=>{
        const snap = await tx.get(GAME_REF); if (!snap.exists()) return;
        const d = snap.data(); if (d.status!=="running") return;

        const portfolios = {...d.portfolios};
        const me = {...(portfolios[username] || { cash: START_CASH, holdings: Array(N).fill(0), avgCost: Array(N).fill(0), cooldowns: Array(N).fill(0) })};
        me.holdings  = Array.isArray(me.holdings)  ? me.holdings  : Array(N).fill(0);
        me.avgCost   = Array.isArray(me.avgCost)   ? me.avgCost   : Array(N).fill(0);
        me.cooldowns = Array.isArray(me.cooldowns) ? me.cooldowns : Array(N).fill(0);

        const stocks = d.stocks.map(s=> ({...s}));
        const s = stocks[idx]; if (!s) return;
        const price = s.price;
        const now = Date.now();

        if (kind==="buy"){
          if (me.cash < price) { return; }
          const qty0 = me.holdings[idx]||0;
          const avg0 = me.avgCost[idx]||0;
          me.cash = Number((me.cash - price).toFixed(2));
          me.holdings[idx] = qty0 + 1;
          me.avgCost[idx]  = Number(((qty0*avg0 + price)/(qty0+1)).toFixed(2));
          me.cooldowns[idx]= now + COOLDOWN_MS;

          s.price = Number(clamp(price * (1 + impactScale(d)), MIN_PRICE, MAX_PRICE).toFixed(2));

          addEventMut(d, { kind:"buy", user:username, idx, price, t:now });

        }else{
          const until = me.cooldowns[idx]||0;
          if (now < until) return;
          const qty0 = me.holdings[idx]||0;
          if (qty0 <= 0) return;

          const avg0 = me.avgCost[idx] || 0;
          const pl   = Number((price - avg0).toFixed(2)); // P/L per share vs avg
          me.holdings[idx] = qty0 - 1;
          me.cash = Number((me.cash + price).toFixed(2));
          if (me.holdings[idx] === 0) me.avgCost[idx] = 0;

          s.price = Number(clamp(price * (1 - impactScale(d)), MIN_PRICE, MAX_PRICE).toFixed(2));

          addEventMut(d, { kind:"sell", user:username, idx, price, pl, t:now });
        }

        const hist = (s.history || []).slice(-HISTORY_LEN+1); hist.push(s.price); s.history = hist;
        portfolios[username] = me;
        stocks[idx] = s;
        tx.update(GAME_REF, { portfolios, stocks, events: (d.events || []) });
      });
    }catch(e){ /* ignore */ }
    // Local floating feedback for UX responsiveness (best-effort)
    if (kind==="buy"){
      floatNote(idx, `-${fmt$(beforePrice)}`, "neu");
    }else{
      const pl = Number((beforePrice - myAvg).toFixed(2));
      floatNote(idx, `${pl>=0?'+':''}${fmt$(pl)}`, pl>=0 ? "good" : "bad");
    }
    return;
  }

  // Local practice (no Firestore)
  if (!gameData) return;
  const me = gameData.portfolios[username];
  if (!me.avgCost)   me.avgCost = Array(N).fill(0);
  if (!me.cooldowns) me.cooldowns = Array(N).fill(0);

  const s  = gameData.stocks[idx]; if (!s) return;
  const now = Date.now();

  if (kind==="buy"){
    if (me.cash < s.price) return;
    const qty0 = me.holdings[idx]||0, avg0 = me.avgCost[idx]||0;
    me.cash = Number((me.cash - s.price).toFixed(2));
    me.holdings[idx] = qty0 + 1;
    me.avgCost[idx]  = Number(((qty0*avg0 + s.price)/(qty0+1)).toFixed(2));
    me.cooldowns[idx]= now + COOLDOWN_MS;
    addEventMut(gameData, { kind:"buy", user:username, idx, price:s.price, t:now });

    floatNote(idx, `-${fmt$(s.price)}`, "neu");

    s.price = Number(clamp(s.price * (1 + 0.02), MIN_PRICE, MAX_PRICE).toFixed(2));
  }else{
    const until = me.cooldowns[idx]||0;
    if (now < until) return;
    const qty0 = me.holdings[idx]||0;
    if (qty0 <= 0) return;
    const avg0 = me.avgCost[idx] || 0;
    const pl   = Number((s.price - avg0).toFixed(2));
    me.holdings[idx] = qty0 - 1;
    me.cash = Number((me.cash + s.price).toFixed(2));
    if (me.holdings[idx] === 0) me.avgCost[idx] = 0;
    addEventMut(gameData, { kind:"sell", user:username, idx, price:s.price, pl, t:now });

    floatNote(idx, `${pl>=0?'+':''}${fmt$(pl)}`, pl>=0 ? "good" : "bad");

    s.price = Number(clamp(s.price * (1 - 0.02), MIN_PRICE, MAX_PRICE).toFixed(2));
  }

  const hist = (s.history || []).slice(-HISTORY_LEN+1); hist.push(s.price); s.history = hist;
  renderStocks(); refreshPlayerValues(); renderTicker();
}
window.order = order;

/* ===========================================================
   Local practice fallback (no gameId)
   =========================================================== */
function startLocalPractice(){
  modeLabel.textContent = "Local Practice";
  gameData = {
    players: [username],
    wins: { [username]: 0 },
    round: 1,
    roundEndAt: Date.now() + ROUND_MS,
    portfolios: initPortfolios([username]),
    stocks: initStocks(),
    events: [],
    status: "running"
  };
  roundEl.textContent = "1";
  renderPlayers(); renderStocks(); renderLeaderboard(); renderTicker();

  stopLoops();
  startUiClock();

  // drift + rounds
  tickerId = setInterval(()=>{
    const d = gameData; if (!d || d.status!=="running") return;
    // drift
    for (let i=0;i<N;i++){
      const s = d.stocks[i];
      const meanRev = (BASE_PRICE - s.price) / (MAX_PRICE - MIN_PRICE);
      const noise   = (Math.random()*0.010 - 0.005);
      let np = s.price * (1 + meanRev*0.25 + noise);
      np = clamp(np, MIN_PRICE, MAX_PRICE);
      s.price = Number(np.toFixed(2));
      const hist = (s.history || []).slice(-HISTORY_LEN+1); hist.push(s.price); s.history = hist;
    }
    renderStocks();
    renderLeaderboard();
    renderTicker();

    // end round
    const left = (d.roundEndAt || 0) - Date.now();
    if (left <= 0){
      const val = netValue(username, d);
      if (val >= START_CASH) d.wins[username] = (d.wins[username]||0) + 1;

      if ((d.round||1) >= ROUNDS){
        overlayTitle.textContent = "Practice Over";
        overlayMsg.textContent   = `Your round wins: ${d.wins[username]||0}`;
        overlayEl.classList.add("show");
        stopLoops();
      }else{
        d.round += 1;
        d.roundEndAt = Date.now() + ROUND_MS;
        d.portfolios = initPortfolios(d.players);
        d.stocks     = initStocks();
        roundEl.textContent = d.round;
        renderPlayers(); renderStocks(); renderLeaderboard(); renderTicker();
      }
    }
  }, 1000);
}

/* ===========================================================
   Boot
   =========================================================== */
ensureTiles();
overlayBtn.addEventListener("click", ()=>{
  overlayEl.classList.remove("show");
  if (GAME_REF && isHost){
    (async ()=>{
      try{
        await setDoc(GAME_REF, {
          host: lobbyData?.host || username,
          players: gameData?.players || [username],
          status: "running",
          round: 1,
          roundEndAt: Date.now() + ROUND_MS,
          wins: Object.fromEntries((gameData?.players||[username]).map(p=>[p,0])),
          portfolios: initPortfolios(gameData?.players||[username]),
          stocks: initStocks(),
          events: [],
          createdAt: serverTimestamp()
        });
        startHostLoop();
      }catch(e){}
    })();
  }else{
    startLocalPractice();
  }
});

if (!GAME_REF){
  startLocalPractice();
}else{
  (async ()=>{
    const ls = await getDoc(LOBBY_REF);
    if (ls.exists()){
      isHost = (ls.data().host === username);
      if (isHost) startHostLoop();
    }
  })();
}

posToggle.addEventListener("change", ()=> renderStocks());

let rez=null; window.addEventListener("resize", ()=>{
  clearTimeout(rez);
  rez=setTimeout(()=>{ sizeAllSparks(); renderStocks(); renderLeaderboard(); }, 80);
});
</script>
</body>
</html>






