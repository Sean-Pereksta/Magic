<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>‚öîÔ∏è Battle</title>
  <style>
    body { font-family: Arial, sans-serif; background: #eef2f5; margin: 0; padding: 0; display: flex; }
    #sidebar { width: 180px; background: #ddd; padding: 10px; border-right: 2px solid #aaa; }
    #grid { display: grid; grid-template-columns: repeat(16, 30px); gap: 2px; margin: 20px; position: relative; }
    .cell { width: 30px; height: 30px; background: #fff; border: 1px solid #ccc; position: relative; }

    /* Structures */
    .wall{ background:black; }
    .strongWall{ background:orange; }
    .archerTower{ background:red; }
    .trap{ background:green; }
    .lightningStriker{ background:blue; }
    .troopStructure{ background:purple; }
    .sniperTower{ background:#555; }
    .cannonTower{ background:#6b7280; }
    .necromancerTower{ background:#3b0764; }

    .health-bar { position: absolute; top: 1px; left: 1px; width: 28px; height: 4px; background: #aaa; }
    .health-fill { height: 100%; background: limegreen; }

    /* Troops */
    .troop {
      background: gray; border: 2px solid black; width: 26px; height: 26px; margin: auto; border-radius: 50%;
      display:grid; place-items:center; font-size:14px;
    }
    .troop.archer{ background:darkgreen; }
    .troop.guardian{ background:darkblue; }
    .troop.bomber{ background:red; }
    .troop.raider{ background:#8b5cf6; }
    .troop.golem{ background:#334155; }
    .troop.minigolem{ background:#475569; }
    .troop.dragon{ background:#7c2d12; border-radius:6px; } /* flying look */

    .troop-hp {
      position: absolute; top: -12px; left: 50%; transform: translateX(-50%);
      font-size:10px; background:#fff; border:1px solid #000; padding:1px 3px; border-radius:3px; font-weight:bold;
    }

    .structure-icon {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      font-size: 18px; pointer-events: none;
    }

    .troop-tray button, #surrenderBtn, #backLobbyBtn {
      display:block; margin:5px 0; padding:6px; width:100%; background:gray; border:none; color:white; font-weight:bold; cursor:pointer;
    }
    #backLobbyBtn{ background:#0f172a; }

    #resultPopup {
      display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%);
      background:white; border:3px solid black; padding:30px; text-align:center; z-index:1000; border-radius:10px;
    }
    #resultPopup h2{ margin-top:0; }
    #resultPopup button{
      padding:10px 20px; font-size:16px; background:#3498db; color:white; border:none; border-radius:5px; cursor:pointer;
    }

    /* Projectile + FX */
    .proj, .fx {
      position:absolute; width:6px; height:6px; border-radius:50%; pointer-events:none; z-index: 50;
      transform: translate(-50%, -50%);
    }
    .proj.arrow { background:#2f855a; }
    .proj.snipe { background:#ff00ff; width:4px; height:4px; }
    .proj.cannon { background:#374151; width:8px; height:8px; }
    .proj.necro { background:#a855f7; }
    .proj.zap { background:#fde047; width:5px; height:5px; }
    .proj.fire { background:#ef4444; width:7px; height:7px; }

    .fx.hit { background:rgba(128,128,128,.65); width:12px; height:12px; animation: puff .25s ease-out forwards; }
    .fx.splash { background:rgba(75,85,99,.6); width:16px; height:16px; animation:puff .3s ease-out forwards; }
    .fx.fire { background:rgba(239,68,68,.55); width:18px; height:18px; animation:puff .35s ease-out forwards; }
    @keyframes puff{
      from{ opacity:1; transform:translate(-50%,-50%) scale(1); }
      to{ opacity:0; transform:translate(-50%,-50%) scale(2); }
    }
  </style>
</head>
<body>
  <div id="sidebar">
    <h4>üõ°Ô∏è Troops</h4>
    <div class="troop-tray">
      <button onclick="selectTroopType('base')">üó°Ô∏è Swordsman (1)</button>
      <button onclick="selectTroopType('archer')">üèπ Archer (1)</button>
      <button onclick="selectTroopType('guardian')">üõ°Ô∏è Guardian (4)</button>
      <button onclick="selectTroopType('raider')">üêé Raider (4)</button>
      <button onclick="selectTroopType('bomber')">üí£ Bomber (6)</button>
      <button onclick="selectTroopType('golem')">üíé Golem (8)</button>
      <button onclick="selectTroopType('dragon')">üêâ Dragon (12)</button>
    </div>
    <div><strong>Troops Left:</strong> <span id="troopCount">0</span></div>
    <button id="surrenderBtn" onclick="endBattle(false)">üè≥Ô∏è Surrender</button>
    <button id="backLobbyBtn">‚üµ Back to Lobby</button>
  </div>

  <div id="grid"></div>

  <div id="resultPopup">
    <h2 id="resultText">Result</h2>
    <button onclick="(function(){const q=new URLSearchParams(location.search);const u=q.get('attacker')||q.get('username')||'';const base='/game/villagelobby.html';location.href=u?`${base}?username=${encodeURIComponent(u)}`:base;})()">Return to Village Lobby</button>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getFirestore, doc, getDoc, updateDoc, increment } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
      authDomain: "bible-game-246c0.firebaseapp.com",
      projectId: "bible-game-246c0",
      storageBucket: "bible-game-246c0.appspot.com",
      messagingSenderId: "959619818996",
      appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
    };
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    const params = new URLSearchParams(window.location.search);
    const attacker = params.get("attacker");
    const defender = params.get("defender");
    const defenderUserRef = doc(db, "users", defender);

    const goblinVillages = ["Goblin1","Goblin2","Goblin3","Goblin4","Goblin5","Goblin6","Goblin7","Goblin8","Goblin9","Goblin10","Goblin11","Goblin12","Goblin13","Goblin14","Goblin15","Goblin16","Goblin17","Goblin18","Goblin19","Goblin20"];
    const isGoblinBattle = goblinVillages.includes(defender);

    const gridSize = 16;
    const gridElement = document.getElementById("grid");

    const healthMap = {};         // static structures (x,y) -> {current,max}
    const troopUnits = [];        // attacking troops
    const skeletons = [];         // necro summons
    let selectedTroopType = "base";
    let troopsLeft = 0;
    let archerInterval;
    let battleOver = false;
    let attackerRef;
    let defenderData;

    /* =================== CONFIG =================== */
    const buildingHealth = {
      wall: 40,
      strongWall: 180,
      archerTower: 25,
      trap: 40,
      lightningStriker: 30,
      troopStructure: 10,
      sniperTower: 30,
      cannonTower: 35,
      necromancerTower: 28
    };

    const structureEmoji = {
      wall: "üß±",
      strongWall: "üß±",
      archerTower: "üèπ",
      trap: "ü™§",
      lightningStriker: "‚ö°",
      troopStructure: "üè∞",
      sniperTower: "üéØ",
      cannonTower: "üí£",
      necromancerTower: "‚ò†Ô∏è"
    };

    const troopStats = {
      base:    { hp: 22,  damage: 6, range: 1, speed: 1, cost: 1 },
      archer:  { hp: 12,  damage: 3, range: 4, speed: 1, cost: 1 },
      guardian:{ hp: 110, damage: 4, range: 1, speed: 1, cost: 4 },
      raider:  { hp: 26,  damage: 5, range: 2, speed: 2, cost: 4 },
      bomber:  { hp: 20,  damage: 20,range: 2, speed: 0, cost: 6 },
      golem:   { hp: 200, damage: 4, range: 1, speed: 1, cost: 8 },  // hulking low DPS
      dragon:  { hp: 90,  damage: 8, range: 3, speed: 2, cost: 12 }  // fire breath, flies
    };

    const enemyStructures = [];
    const archerTowers = [];
    const lightningTowers = [];
    const trapTowers = [];
    const sniperTowers = [];
    const cannonTowers = [];
    const necroTowers = [];

    /* =================== HELPERS =================== */
    const inBounds = (x,y)=> x>=0 && y>=0 && x<gridSize && y<gridSize;
    const cellAt = (x,y)=> document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
    const isBlocked = (x,y)=> {
      const c = cellAt(x,y);
      return !c || (c.classList.length > 1); // has a structure class
    };
    function gridCenter(el){
      const rect = el.getBoundingClientRect();
      const gridRect = gridElement.getBoundingClientRect();
      return { x: rect.left - gridRect.left + rect.width/2, y: rect.top - gridRect.top + rect.height/2 };
    }
    function spawnFX(x,y,cls="hit"){
      const c = cellAt(x,y); if(!c) return;
      const fx = document.createElement("div");
      fx.className = `fx ${cls}`;
      const p = gridCenter(c);
      fx.style.left = p.x + "px"; fx.style.top = p.y + "px";
      gridElement.appendChild(fx);
      setTimeout(()=> fx.remove(), 360);
    }
    function shootProjectile(fromX,fromY,toX,toY,cls,onHit,travelMs=250){
      const from = cellAt(fromX,fromY), to = cellAt(toX,toY);
      if(!from || !to){ onHit?.(); return; }
      const pFrom = gridCenter(from), pTo = gridCenter(to);
      const dot = document.createElement("div");
      dot.className = `proj ${cls}`;
      dot.style.left = pFrom.x + "px";
      dot.style.top = pFrom.y + "px";
      gridElement.appendChild(dot);
      const start = performance.now();
      function step(t){
        const k = Math.min(1,(t-start)/travelMs);
        dot.style.left = (pFrom.x + (pTo.x-pFrom.x)*k) + "px";
        dot.style.top  = (pFrom.y + (pTo.y-pFrom.y)*k) + "px";
        if(k<1) requestAnimationFrame(step);
        else{ dot.remove(); onHit?.(); }
      }
      requestAnimationFrame(step);
    }

    function renderHealth(cell, key, value) {
      let healthBar = cell.querySelector(".health-bar");
      if (!healthBar) {
        healthBar = document.createElement("div");
        healthBar.className = "health-bar";
        const fill = document.createElement("div");
        fill.className = "health-fill";
        healthBar.appendChild(fill);
        cell.appendChild(healthBar);
      }
      const fill = healthBar.querySelector(".health-fill");
      const full = healthMap[key].max;
      fill.style.width = `${(value / full) * 100}%`;
    }

    function getClosestTarget(x, y) {
      // consider structures
      let minDist = Infinity, closest = null;
      for (const s of enemyStructures) {
        const key = `${s.x},${s.y}`;
        if (healthMap[key]?.current > 0) {
          const dist = Math.abs(s.x - x) + Math.abs(s.y - y);
          if (dist < minDist) { minDist = dist; closest = s; }
        }
      }
      // consider skeletons
      for (const sk of skeletons) {
        if (sk.hp <= 0) continue;
        const dist = Math.abs(sk.x - x) + Math.abs(sk.y - y);
        if (dist < minDist) { minDist = dist; closest = sk; }
      }
      return closest;
    }

    function getClosestTower(x,y){
      let best=null, bd=Infinity;
      for (const s of enemyStructures){
        const key = `${s.x},${s.y}`;
        if (!healthMap[key]?.current) continue;
        // tower-ish (not walls)
        if (["archerTower","lightningStriker","troopStructure","sniperTower","cannonTower","necromancerTower","trap"].includes(s.type)){
          const d = Math.abs(s.x-x)+Math.abs(s.y-y);
          if (d<bd){ bd=d; best=s; }
        }
      }
      return best;
    }

    /* =================== TROOPS =================== */
    function selectTroopType(type){ selectedTroopType = type; }
    window.selectTroopType = selectTroopType;

    function createTroopDiv(emoji, cls, hp){
      const wrap = document.createElement("div"); wrap.style.position="relative";
      const hpBar = document.createElement("div"); hpBar.className="troop-hp"; hpBar.textContent = hp;
      const icon = document.createElement("div"); icon.className = "troop " + cls; icon.textContent = emoji;
      wrap.appendChild(hpBar); wrap.appendChild(icon);
      return {wrap, hpBar};
    }

    function spawnTroop(x, y) {
      const cost = troopStats[selectedTroopType].cost;
      if (troopsLeft < cost || battleOver) return;
      const cell = cellAt(x,y);
      if (!cell || cell.classList.length > 1) return;

      const stats = troopStats[selectedTroopType];
      const emoji =
        selectedTroopType === "archer"   ? "üèπ" :
        selectedTroopType === "guardian" ? "üõ°Ô∏è" :
        selectedTroopType === "bomber"   ? "üí£" :
        selectedTroopType === "raider"   ? "üêé" :
        selectedTroopType === "golem"    ? "üíé" :
        selectedTroopType === "dragon"   ? "üêâ" : "üó°Ô∏è";

      const {wrap, hpBar} = createTroopDiv(emoji, selectedTroopType, stats.hp);
      cell.appendChild(wrap);

      const troop = {
        x, y,
        hp: stats.hp,
        damage: stats.damage,
        range: stats.range,
        speed: stats.speed,
        type: selectedTroopType,
        interval: null,
        div: wrap, hpDisplay: hpBar,
        taunt: (selectedTroopType === "guardian"),
        flying: (selectedTroopType === "dragon")
      };
      troopUnits.push(troop);

      troopsLeft -= cost;
      document.getElementById("troopCount").textContent = troopsLeft;

      const getClosestSpecialTarget = (ox, oy) => {
        const prio = ["archerTower","sniperTower","lightningStriker","necromancerTower","cannonTower","trap"];
        let best=null, bestDist=Infinity;
        for (const s of enemyStructures) {
          if (!prio.includes(s.type)) continue;
          const key = `${s.x},${s.y}`;
          if (!healthMap[key] || healthMap[key].current <= 0) continue;
          const d = Math.abs(s.x - ox) + Math.abs(s.y - oy);
          if (d < bestDist) { bestDist = d; best = s; }
        }
        return best;
      };

      /* -------- main behaviour loop -------- */
      troop.interval = setInterval(() => {
        if (battleOver) return;

        // Bomber proximity burst
        if (troop.type === "bomber") {
          let didExplode = false;
          const R = troop.range;
          for (let dx=-R; dx<=R; dx++){
            for (let dy=-R; dy<=R; dy++){
              if (dx===0 && dy===0) continue;
              const tx=troop.x+dx, ty=troop.y+dy;
              const key = `${tx},${ty}`, th = healthMap[key];
              if (th?.current > 0){
                didExplode = true;
                th.current = Math.max(0, th.current - troop.damage);
                const cellT = cellAt(tx,ty);
                if (th.current === 0){
                  delete healthMap[key];
                  if (cellT){ cellT.className="cell"; cellT.innerHTML=""; }
                  removeStructureFromList(tx,ty);
                  checkVictoryCondition();
                } else if (cellT){ renderHealth(cellT, key, th.current); }
              }
            }
          }
          if (didExplode){
            troop.hp = Math.max(0, troop.hp - troop.damage);
            troop.hpDisplay.textContent = troop.hp;
            if (troop.hp <= 0){
              clearInterval(troop.interval);
              const c = cellAt(troop.x,troop.y); if (c) c.innerHTML="";
              onTroopDeath(troop.x,troop.y);
            }
            return;
          }
        }

        // DRAGON: prioritize towers
        let targetObj = (troop.type==='dragon')
          ? (getClosestTower(troop.x,troop.y) || getClosestTarget(troop.x,troop.y))
          : (troop.type==='raider'
              ? (getClosestSpecialTarget(troop.x,troop.y) || getClosestTarget(troop.x,troop.y))
              : getClosestTarget(troop.x,troop.y));

        if (!targetObj) { clearInterval(troop.interval); endBattle(true); return; }

        const isSkeleton = !!targetObj.isSkeleton;
        const tx = targetObj.x, ty = targetObj.y;
        const dx = tx - troop.x, dy = ty - troop.y;
        const dist = Math.abs(dx)+Math.abs(dy);
        const inRange = dist <= troop.range;

        // remove old DOM pos
        const oldCell = cellAt(troop.x,troop.y);
        if (oldCell && troop.div && troop.div.parentNode===oldCell) oldCell.removeChild(troop.div);

        // ATTACK or MOVE
        if (inRange){
          if (troop.type==='archer'){
            shootProjectile(troop.x,troop.y,tx,ty,"arrow",()=>{
              doDamageToTarget(targetObj, troop.damage);
              spawnFX(tx,ty,"hit");
            }, 220);
          } else if (troop.type==='dragon'){
            // fire breath projectile + small fire splash to structures
            shootProjectile(troop.x,troop.y,tx,ty,"fire",()=>{
              // prefer structures
              if (!isSkeleton){
                doDamageToTarget(targetObj, troop.damage);
                spawnFX(tx,ty,"fire");
                // tiny AoE to adjacent structures
                for (let ax=-1; ax<=1; ax++){
                  for (let ay=-1; ay<=1; ay++){
                    if (ax===0 && ay===0) continue;
                    const sx=tx+ax, sy=ty+ay, k=`${sx},${sy}`;
                    const th = healthMap[k];
                    if (th?.current>0){
                      th.current = Math.max(0, th.current - Math.ceil(troop.damage/2));
                      const c = cellAt(sx,sy);
                      if (th.current===0){ delete healthMap[k]; if(c){c.className="cell"; c.innerHTML="";} removeStructureFromList(sx,sy); checkVictoryCondition(); }
                      else if (c){ renderHealth(c,k,th.current); }
                    }
                  }
                }
              } else { // skeleton target fallback
                targetObj.hp = Math.max(0, targetObj.hp - troop.damage);
                if (targetObj.hp<=0){
                  const c = cellAt(targetObj.x,targetObj.y); if (c) c.innerHTML="";
                }
                spawnFX(tx,ty,"fire");
              }
            }, 250);
          } else {
            // melee hit
            doDamageToTarget(targetObj, troop.damage);
            spawnFX(tx,ty,"splash");
          }
        } else {
          // MOVE
          if (troop.type==='archer'){
            troop.x += Math.sign(dx);
            troop.y += Math.sign(dy);
          } else if (troop.type==='dragon'){
            // can fly: ignores blocks, moves 2 steps
            const steps = troop.speed;
            for (let s=0; s<steps; s++){
              troop.x += Math.sign(dx);
              troop.y += Math.sign(dy);
            }
          } else if (troop.type==='golem' || troop.type==='minigolem'){
            // slow, cannot pass walls; if blocked, attack wall next tick
            const nx = troop.x + Math.sign(dx);
            const ny = troop.y + Math.sign(dy);
            if (inBounds(nx,ny) && !isBlocked(nx,ny)){
              troop.x=nx; troop.y=ny;
            } else {
              // blocked‚Äîdo nothing here; attack phase next tick will damage blocking wall when inRange=1
              const bdx = Math.sign(dx), bdy = Math.sign(dy);
              const bx = troop.x + bdx, by = troop.y + bdy;
              // If adjacent and blocked by a structure and within melee range, damage that block immediately
              if (inBounds(bx,by) && isBlocked(bx,by) && (Math.abs(dx)+Math.abs(dy) <= troop.range+1)){
                const block = enemyStructures.find(s=>s.x===bx && s.y===by);
                if (block){
                  doDamageToTarget(block, troop.damage);
                  spawnFX(bx,by,"splash");
                }
              }
            }
          } else {
            const steps = troop.type==='raider' ? 2 : 1;
            for (let s=0; s<steps; s++){
              const nx = troop.x + Math.sign(dx);
              const ny = troop.y + Math.sign(dy);
              if (!inBounds(nx,ny)) break;
              const blocked = isBlocked(nx,ny) && troop.type!=='raider';
              if (blocked) break;
              troop.x = nx; troop.y = ny;
            }
          }
        }

        // redraw
        const newCell = cellAt(troop.x,troop.y);
        if (newCell) newCell.appendChild(troop.div);

        // GOLEM death trigger (handled in doDamageToTroop callers too)
      }, 800);
    }

    function removeStructureFromList(x,y){
      const i = enemyStructures.findIndex(s=>s.x===x && s.y===y);
      if (i>-1) enemyStructures.splice(i,1);
    }

    function doDamageToTarget(targetOrSkeleton, dmg){
      // skeleton?
      if (targetOrSkeleton.isSkeleton){
        targetOrSkeleton.hp = Math.max(0, targetOrSkeleton.hp - dmg);
        if (targetOrSkeleton.hp <= 0){
          const c = cellAt(targetOrSkeleton.x,targetOrSkeleton.y);
          if (c && targetOrSkeleton.div && targetOrSkeleton.div.parentNode===c) c.removeChild(targetOrSkeleton.div);
          targetOrSkeleton.hp = 0;
        }
        return;
      }
      // structure
      const key = `${targetOrSkeleton.x},${targetOrSkeleton.y}`;
      const th = healthMap[key];
      if (!th) return;
      th.current = Math.max(0, th.current - dmg);
      const tCell = cellAt(targetOrSkeleton.x,targetOrSkeleton.y);
      if (th.current === 0){
        delete healthMap[key];
        if (tCell){ tCell.className="cell"; tCell.innerHTML=""; }
        removeStructureFromList(targetOrSkeleton.x,targetOrSkeleton.y);
        checkVictoryCondition();
      } else if (tCell){ renderHealth(tCell, key, th.current); }
    }

    /* =================== MINI-GOLEM & NECRO =================== */
    function spawnMiniGolem(x,y){
      if (!inBounds(x,y) || isBlocked(x,y)) return null;
      const {wrap, hpBar} = createTroopDiv("üîπ","minigolem",30);
      const c = cellAt(x,y); if (c) c.appendChild(wrap);
      const mg = { x,y, hp:30, damage:2, range:1, speed:1, type:"minigolem", div:wrap, hpDisplay:hpBar, interval:null };
      troopUnits.push(mg);
      mg.interval = setInterval(()=>{
        if (battleOver || mg.hp<=0) return;
        const target = getClosestTarget(mg.x,mg.y);
        if (!target) { clearInterval(mg.interval); endBattle(true); return; }
        const dx = target.x - mg.x, dy = target.y - mg.y;
        const dist = Math.abs(dx)+Math.abs(dy);
        if (dist <= mg.range){
          doDamageToTarget(target, mg.damage);
          spawnFX(target.x,target.y,"splash");
        } else {
          const nx = mg.x + Math.sign(dx), ny = mg.y + Math.sign(dy);
          if (inBounds(nx,ny) && !isBlocked(nx,ny)){
            const from = cellAt(mg.x,mg.y); if (from && mg.div && mg.div.parentNode===from) from.removeChild(mg.div);
            mg.x=nx; mg.y=ny;
            const to = cellAt(nx,ny); if (to) to.appendChild(mg.div);
          }
        }
      }, 900);
      return mg;
    }

    function onTroopDeath(x,y){
      // try necro reanimate
      if (typeof window.__checkNecroReanimate === "function"){
        const done = window.__checkNecroReanimate(x,y);
        if (done) return;
      }
    }

    /* =================== GRID & WIN =================== */
    function createGrid() {
      gridElement.innerHTML = "";
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.dataset.x = x;
          cell.dataset.y = y;
          cell.onclick = () => spawnTroop(x, y);
          gridElement.appendChild(cell);
        }
      }
    }

    function checkVictoryCondition() {
      const remaining = Object.values(healthMap).filter(h => h.current > 0);
      if (remaining.length === 0) endBattle(true);
    }

    async function endBattle(victory) {
      battleOver = true;
      clearInterval(archerInterval);
      troopUnits.forEach(t => clearInterval(t.interval));
      skeletons.forEach(s => clearInterval(s.interval));

      const attackerUserRef = doc(db, "users", attacker);
      const defenderUserRef2 = doc(db, "users", defender);
      const updates = [];

      if (victory) {
        const reward = isGoblinBattle ? 50 : 5;
        updates.push(updateDoc(attackerUserRef, { bucks: increment(reward) }));
        updates.push(updateDoc(defenderUserRef2, { bucks: increment(-10) }));
        if (isGoblinBattle) updates.push(updateDoc(attackerUserRef, { campaign: increment(1) }));
        document.getElementById("resultText").textContent = `üèÜ Victory! You earned ${reward} bucks.`;
      } else {
        document.getElementById("resultText").textContent = "‚ùå Defeat! Defender keeps their 10 bucks.";
      }

      if (updates.length) await Promise.all(updates);
      document.getElementById("resultPopup").style.display = "block";
    }

    /* =================== TOWERS =================== */
    function startArcherAttacks() {
      archerInterval = setInterval(() => {
        if (battleOver) return;
        for (const {x,y} of archerTowers){
          const key = `${x},${y}`; if (!healthMap[key]?.current) continue;
          const inRange = troopUnits.filter(t => t.hp>0 && Math.abs(t.x-x)+Math.abs(t.y-y) <= 5);
          if (!inRange.length) continue;
          const taunters = inRange.filter(t => t.taunt);
          const candidates = taunters.length ? taunters : inRange;
          let target = candidates.reduce((best,t)=>{
            const d = Math.abs(t.x-x)+Math.abs(t.y-y);
            const bd = Math.abs(best.x-x)+Math.abs(best.y-y);
            return d<bd ? t : best;
          }, candidates[0]);
          shootProjectile(x,y,target.x,target.y,"arrow",()=>{
            target.hp -= 5;
            if (target.hpDisplay) target.hpDisplay.textContent = target.hp;
            spawnFX(target.x,target.y,"hit");
            if (target.hp <= 0){
              clearInterval(target.interval);
              const c = cellAt(target.x,target.y); if (c) c.innerHTML="";
              onTroopDeath(target.x,target.y);
            }
          }, 240);
        }
      }, 1400);
    }

    function startLightningAttacks() {
      setInterval(() => {
        if (battleOver) return;
        for (const {x:lx,y:ly} of lightningTowers){
          const key = `${lx},${ly}`;
          const th = healthMap[key]; if (!th || th.current<=0) continue;
          for (const troop of troopUnits){
            if (troop.hp<=0) continue;
            if (Math.abs(troop.x-lx)+Math.abs(troop.y-ly) <= 3){
              shootProjectile(lx,ly,troop.x,troop.y,"zap",()=>{
                troop.hp -= 1;
                if (troop.hpDisplay) troop.hpDisplay.textContent = troop.hp;
                spawnFX(troop.x,troop.y,"hit");
                if (troop.hp<=0){
                  const c = cellAt(troop.x,troop.y); if (c) c.innerHTML="";
                  clearInterval(troop.interval);
                  onTroopDeath(troop.x,troop.y);
                }
              }, 120);
            }
          }
        }
      }, 400);
    }

    function startTrapAttacks() {
      setInterval(() => {
        if (battleOver) return;
        for (const {x:tx,y:ty} of trapTowers){
          const key = `${tx},${ty}`;
          const th = healthMap[key]; if (!th || th.current<=0) continue;
          for (const troop of troopUnits){
            if (troop.hp<=0) continue;
            if (troop.type==='dragon') continue; // traps cannot hit dragons
            if (Math.hypot(troop.x-tx, troop.y-ty) <= 1.5){
              troop.hp -= 10;
              if (troop.hpDisplay) troop.hpDisplay.textContent = troop.hp;
              spawnFX(troop.x,troop.y,"splash");
              if (troop.hp<=0){
                const c = cellAt(troop.x,troop.y); if (c) c.innerHTML="";
                clearInterval(troop.interval);
                onTroopDeath(troop.x,troop.y);
              }
            }
          }
        }
      }, 1000);
    }

    function startSniperAttacks() {
      const RANGE=12, DAMAGE=15, FIRE_RATE=1600;
      setInterval(() => {
        if (battleOver) return;
        for (const {x,y} of sniperTowers){
          const key = `${x},${y}`; if (!healthMap[key]?.current) continue;
          let target=null, bestDist=Infinity;
          for (const t of troopUnits){
            if (t.hp<=0) continue;
            const d = Math.abs(t.x-x)+Math.abs(t.y-y);
            if (d<=RANGE && d<bestDist){ bestDist=d; target=t; }
          }
          if (!target) continue;
          shootProjectile(x,y,target.x,target.y,"snipe",()=>{
            target.hp = Math.max(0, target.hp - DAMAGE);
            if (target.hpDisplay) target.hpDisplay.textContent = target.hp;
            spawnFX(target.x,target.y,"hit");
            if (target.hp<=0){
              const c = cellAt(target.x,target.y); if (c) c.innerHTML="";
              clearInterval(target.interval);
              onTroopDeath(target.x,target.y);
            }
          }, 200);
        }
      }, FIRE_RATE);
    }

    function startCannonAttacks(){
      const RANGE=6, DAMAGE=8, FIRE_RATE=2200, KNOCK=1;
      setInterval(()=>{
        if (battleOver) return;
        for (const {x,y} of cannonTowers){
          const key = `${x},${y}`; if (!healthMap[key]?.current) continue;
          // pick nearest troop in range, but NOT dragons
          let target=null, best=Infinity;
          for (const t of troopUnits){
            if (t.hp<=0 || t.type==='dragon') continue;
            const d = Math.abs(t.x-x)+Math.abs(t.y-y);
            if (d<=RANGE && d<best){ best=d; target=t; }
          }
          if (!target) continue;
          shootProjectile(x,y,target.x,target.y,"cannon",()=>{
            // splash: 3x3 around target & knockback 1
            for (let dx=-1; dx<=1; dx++){
              for (let dy=-1; dy<=1; dy++){
                const tx=target.x+dx, ty=target.y+dy;
                if (!inBounds(tx,ty)) continue;

                // damage troops in area
                for (const t of troopUnits){
                  if (t.hp<=0) continue;
                  if (t.x===tx && t.y===ty){
                    t.hp = Math.max(0, t.hp - DAMAGE);
                    if (t.hpDisplay) t.hpDisplay.textContent = t.hp;
                    spawnFX(tx,ty,"splash");
                    if (t.hp<=0){
                      const c = cellAt(t.x,t.y); if (c) c.innerHTML="";
                      clearInterval(t.interval);
                      onTroopDeath(t.x,t.y);
                    }
                  }
                }

                // knockback (troops + skeletons), not through walls/out of bounds
                const vx = Math.sign(tx - target.x), vy = Math.sign(ty - target.y);
                if (vx===0 && vy===0) continue;
                const kx = tx + vx*KNOCK, ky = ty + vy*KNOCK;
                if (!inBounds(kx,ky) || isBlocked(kx,ky)) continue;

                for (const t of troopUnits){
                  if (t.hp>0 && t.x===tx && t.y===ty){
                    const fromCell = cellAt(t.x,t.y);
                    if (fromCell && t.div && t.div.parentNode===fromCell) fromCell.removeChild(t.div);
                    t.x=kx; t.y=ky;
                    const toCell = cellAt(kx,ky); if (toCell) toCell.appendChild(t.div);
                  }
                }
                for (const s of skeletons){
                  if (s.hp>0 && s.x===tx && s.y===ty){
                    const fromCell = cellAt(s.x,s.y);
                    if (fromCell && s.div && s.div.parentNode===fromCell) fromCell.removeChild(s.div);
                    s.x=kx; s.y=ky;
                    const toCell = cellAt(kx,ky); if (toCell) toCell.appendChild(s.div);
                  }
                }
              }
            }
          }, 260);
        }
      }, FIRE_RATE);
    }

    function startNecroAttacks(){
      const RANGE=6, DAMAGE=4, FIRE_RATE=1500, REANIM_RANGE=4;
      setInterval(()=>{
        if (battleOver) return;
        for (const {x,y} of necroTowers){
          const key = `${x},${y}`; if (!healthMap[key]?.current) continue;
          let target=null, best=Infinity;
          for (const t of troopUnits){
            if (t.hp<=0) continue;
            const d = Math.abs(t.x-x)+Math.abs(t.y-y);
            if (d<=RANGE && d<best){ best=d; target=t; }
          }
          if (!target) continue;
          shootProjectile(x,y,target.x,target.y,"necro",()=>{
            target.hp = Math.max(0, target.hp - DAMAGE);
            if (target.hpDisplay) target.hpDisplay.textContent = target.hp;
            spawnFX(target.x,target.y,"hit");
            if (target.hp<=0){
              const cx = target.x, cy = target.y;
              const cell = cellAt(cx,cy); if (cell) cell.innerHTML="";
              clearInterval(target.interval);
              // reanimate if within REANIM_RANGE
              if (Math.abs(cx-x)+Math.abs(cy-y) <= REANIM_RANGE){
                spawnSkeleton(cx,cy);
              } else {
                onTroopDeath(cx,cy);
              }
            }
          }, 220);
        }
      }, FIRE_RATE);

      // Hook for global deaths
      window.__checkNecroReanimate = function(dx,dy){
        for (const n of necroTowers){
          const key = `${n.x},${n.y}`;
          if (!healthMap[key]?.current) continue;
          if (Math.abs(dx-n.x)+Math.abs(dy-n.y) <= REANIM_RANGE){
            spawnSkeleton(dx,dy);
            return true;
          }
        }
        return false;
      };
    }

    function spawnSkeleton(x,y){
      if (!inBounds(x,y) || isBlocked(x,y)) return;
      const c = cellAt(x,y);
      const div = document.createElement("div");
      div.className = "troop"; div.style.background = "#4b5563"; div.textContent = "üíÄ";
      const hpUi = document.createElement("div");
      hpUi.className = "troop-hp"; hpUi.textContent = "10";
      const wrap = document.createElement("div"); wrap.style.position="relative";
      wrap.appendChild(hpUi); wrap.appendChild(div);
      c.appendChild(wrap);

      const sk = { isSkeleton:true, x,y, hp:10, damage:2, range:1, speed:1, div:wrap, hpDisplay:hpUi, interval:null };
      skeletons.push(sk);

      sk.interval = setInterval(()=>{
        if (battleOver || sk.hp<=0) return;
        // go after nearest troop
        let tgt=null, best=Infinity;
        for (const t of troopUnits){
          if (t.hp<=0) continue;
          const d = Math.abs(t.x-sk.x)+Math.abs(t.y-sk.y);
          if (d<best){ best=d; tgt=t; }
        }
        if (!tgt) return;
        const dx = tgt.x - sk.x, dy = tgt.y - sk.y;
        const dist = Math.abs(dx)+Math.abs(dy);
        if (dist <= sk.range){
          tgt.hp = Math.max(0, tgt.hp - sk.damage);
          if (tgt.hpDisplay) tgt.hpDisplay.textContent = tgt.hp;
          spawnFX(tgt.x,tgt.y,"splash");
          if (tgt.hp<=0){
            const tc = cellAt(tgt.x,tgt.y); if (tc) tc.innerHTML="";
            clearInterval(tgt.interval);
            onTroopDeath(tgt.x,tgt.y);
          }
        } else {
          const nx = sk.x + Math.sign(dx);
          const ny = sk.y + Math.sign(dy);
          if (inBounds(nx,ny) && !isBlocked(nx,ny)){
            const from = cellAt(sk.x,sk.y); if (from && sk.div && sk.div.parentNode===from) from.removeChild(sk.div);
            sk.x=nx; sk.y=ny;
            const to = cellAt(nx,ny); if (to) to.appendChild(sk.div);
          }
        }
      }, 900);
      return sk;
    }

    /* =================== INIT =================== */
    async function init() {
      await updateDoc(defenderUserRef, { bucks: increment(10) });
      if (!attacker || !defender) return alert("Invalid URL");

      attackerRef = doc(db, "villages", attacker);
      const defenderRef = doc(db, "villages", defender);
      const [attackerSnap, defenderSnap] = await Promise.all([ getDoc(attackerRef), getDoc(defenderRef) ]);

      const attackerData = attackerSnap.data();
      defenderData = defenderSnap.data();

      const troopBuildings = attackerData.grid?.filter(b => b.type === "troopStructure").length || 0;
      troopsLeft = troopBuildings * 5;
      document.getElementById("troopCount").textContent = troopsLeft;

      createGrid();

      for (const b of defenderData.grid || []) {
        const key = `${b.x},${b.y}`;
        const cell = cellAt(b.x,b.y);
        if (!cell) continue;

        cell.classList.add(b.type);
        const hp = buildingHealth[b.type] || 10;
        healthMap[key] = { current: hp, max: hp };
        renderHealth(cell, key, hp);

        const icon = document.createElement("div");
        icon.className = "structure-icon";
        icon.textContent = structureEmoji[b.type] || "";
        cell.appendChild(icon);

        enemyStructures.push({ ...b });

        if (b.type === "archerTower")      archerTowers.push({ x: b.x, y: b.y });
        if (b.type === "lightningStriker") lightningTowers.push({ x: b.x, y: b.y });
        if (b.type === "trap")             trapTowers.push({ x: b.x, y: b.y });
        if (b.type === "sniperTower")      sniperTowers.push({ x: b.x, y: b.y });
        if (b.type === "cannonTower")      cannonTowers.push({ x: b.x, y: b.y });
        if (b.type === "necromancerTower") necroTowers.push({ x: b.x, y: b.y });
      }

      startArcherAttacks();
      startLightningAttacks();
      startTrapAttacks();
      startSniperAttacks();
      startCannonAttacks();
      startNecroAttacks();

      // Back to lobby button (keeps username/attacker)
      document.getElementById("backLobbyBtn").onclick = ()=>{
        const u = attacker || params.get("username") || "";
        const base = "/game/villagelobby.html";
        location.href = u ? `${base}?username=${encodeURIComponent(u)}` : base;
      };
    }

    init();

    /* ======== EXTRA: golem death hook for explosion & mini-golems ======== */
    // Intercept any place we remove a troop (handled already in tower loops & melee):
    // We‚Äôll wrap a small observer on troop hpDisplay updates‚Äîsimpler approach:
    const _desc = Object.getOwnPropertyDescriptor(Object.prototype, "toString"); // no-op, placeholder
    // For clarity, we trigger explosion when a GOLEM's hp drops to 0 inside existing damage paths:
    // Add small utility you can call before deleting a golem DOM (call wherever troop dies if type==='golem')
    function golemDeathExplosion(gx,gy){
      // 3x3 structure splash
      for (let dx=-1; dx<=1; dx++){
        for (let dy=-1; dy<=1; dy++){
          const sx=gx+dx, sy=gy+dy, k=`${sx},${sy}`;
          const th = healthMap[k];
          if (th?.current>0){
            th.current = Math.max(0, th.current - 12);
            const c = cellAt(sx,sy);
            if (th.current===0){ delete healthMap[k]; if(c){c.className="cell"; c.innerHTML="";} removeStructureFromList(sx,sy); checkVictoryCondition(); }
            else if (c){ renderHealth(c,k,th.current); }
            spawnFX(sx,sy,"splash");
          }
        }
      }
      // spawn two mini golems in nearby free cells (N,E,S,W)
      const spots = [[0,-1],[1,0],[0,1],[-1,0]];
      let spawned = 0;
      for (const [dx,dy] of spots){
        const mx=gx+dx, my=gy+dy;
        if (spawned>=2) break;
        if (inBounds(mx,my) && !isBlocked(mx,my)){
          spawnMiniGolem(mx,my); spawned++;
        }
      }
    }

    // Patch: when we set troop hp to 0, before clearing interval/DOM, if golem‚Äîexplode.
    // We already reduce hp in multiple places (towers, melee). We‚Äôll monkey-patch doDamageToTarget for skeletons (handled),
    // and add a helper when troops lose hp in tower loops. To keep it simple: hook a tiny helper:
    function onTroopReducedToZero(t){
      if (t.type==='golem'){
        golemDeathExplosion(t.x,t.y);
      }
    }

    // Override some kill sites to call onTroopReducedToZero:
    // Archer hits, lightning, traps, sniper, cannon splash, melee, etc., already call onTroopDeath.
    // We‚Äôll wrap onTroopDeath to also check for golem explosion if we can find the last dead troop at (x,y).
    const _origOnTroopDeath = onTroopDeath;
    onTroopDeath = function(x,y){
      // try find dead troop at this tile (most recent)
      const dead = troopUnits.find(t=>t.hp<=0 && t.x===x && t.y===y);
      if (dead) onTroopReducedToZero(dead);
      _origOnTroopDeath(x,y);
    };
  </script>
</body>
</html>



