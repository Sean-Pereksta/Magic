<!DOCTYPE html> 
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>‚öîÔ∏è Battle</title>
  <style>
    body { font-family: Arial, sans-serif; background: #eef2f5; margin: 0; padding: 0; display: flex; }
    #sidebar { width: 180px; background: #ddd; padding: 10px; border-right: 2px solid #aaa; }
    #grid { display: grid; grid-template-columns: repeat(16, 30px); gap: 2px; margin: 20px; position: relative; }
    .cell { width: 30px; height: 30px; background: #fff; border: 1px solid #ccc; position: relative; }

    /* Structures */
    .wall{ background:black; }
    .strongWall{ background:orange; }
    .archerTower{ background:red; }
    .trap{ background:green; }
    .lightningStriker{ background:blue; }
    .troopStructure{ background:purple; }
    .sniperTower{ background:#555; }
    .cannonTower{ background:#6b7280; }
    .necromancerTower{ background:#3b0764; }

    .health-bar { position: absolute; top: 1px; left: 1px; width: 28px; height: 4px; background: #aaa; }
    .health-fill { height: 100%; background: limegreen; }

    /* Troops */
    .troop {
      background: gray; border: 2px solid black; width: 26px; height: 26px; margin: auto; border-radius: 50%;
      display:grid; place-items:center; font-size:14px;
    }
    .troop.archer{ background:darkgreen; }
    .troop.guardian{ background:darkblue; }
    .troop.bomber{ background:#b91c1c; }
    .troop.raider{ background:#8b5cf6; }
    .troop.golem{ background:#334155; }
    .troop.minigolem{ background:#475569; }
    .troop.dragon{ background:#7c2d12; border-radius:6px; }
    .troop.cthulu{ background:#0f766e; }

    .troop-hp {
      position: absolute; top: -12px; left: 50%; transform: translateX(-50%);
      font-size:10px; background:#fff; border:1px solid #000; padding:1px 3px; border-radius:3px; font-weight:bold;
    }

    .structure-icon {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      font-size: 18px; pointer-events: none;
    }

    .troop-tray button, #surrenderBtn, #backLobbyBtn {
      display:block; margin:5px 0; padding:6px; width:100%; background:gray; border:none; color:white; font-weight:bold; cursor:pointer;
    }
    #backLobbyBtn{ background:#0f172a; }

    #resultPopup {
      display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%);
      background:white; border:3px solid black; padding:30px; text-align:center; z-index:1000; border-radius:10px;
    }
    #resultPopup h2{ margin-top:0; }
    #resultPopup button{
      padding:10px 20px; font-size:16px; background:#3498db; color:white; border:none; border-radius:5px; cursor:pointer;
    }

    /* Projectile + FX */
    .proj, .fx {
      position:absolute; width:6px; height:6px; border-radius:50%; pointer-events:none; z-index: 50;
      transform: translate(-50%, -50%);
    }
    .proj.arrow { background:#2f855a; }
    .proj.snipe { background:#ff00ff; width:4px; height:4px; }
    .proj.cannon { background:#374151; width:8px; height:8px; }
    .proj.necro { background:#a855f7; }
    /* OLD zap removed in favor of bolt FX */

    .proj.fire { background:#ef4444; width:7px; height:7px; }

    .fx.hit { background:rgba(128,128,128,.65); width:12px; height:12px; animation: puff .25s ease-out forwards; }
    .fx.splash { background:rgba(75,85,99,.6); width:16px; height:16px; animation:puff .3s ease-out forwards; }
    .fx.fire { background:rgba(239,68,68,.55); width:18px; height:18px; animation:puff .35s ease-out forwards; }

    .fx.explosion {
      width: 8px; height: 8px; border-radius: 50%;
      box-shadow: 0 0 0 0 rgba(255, 115, 0, 0.8), 0 0 0 0 rgba(255, 196, 0, .7);
      background: radial-gradient(circle, rgba(255,180,0,.9) 0%, rgba(220,38,38,.85) 60%, rgba(0,0,0,0) 61%);
      animation: boom .45s ease-out forwards;
      z-index: 60;
    }
    @keyframes boom{
      0%{ transform:translate(-50%,-50%) scale(1); opacity:1; box-shadow: 0 0 0 0 rgba(255,115,0,.8), 0 0 0 0 rgba(255,196,0,.7); }
      60%{ transform:translate(-50%,-50%) scale(3); opacity:.9; box-shadow: 0 0 20px 12px rgba(255,115,0,.45), 0 0 40px 22px rgba(255,196,0,.25); }
      100%{ transform:translate(-50%,-50%) scale(4.2); opacity:0; box-shadow: 0 0 60px 28px rgba(255,115,0,0); }
    }

    /* Cthulu beam (now rotatable) */
    .fx.beam {
      width: 28px; height: 6px; border-radius: 3px;
      background: linear-gradient(90deg, rgba(34,211,238,.15), rgba(34,211,238,.95), rgba(34,211,238,.15));
      filter: drop-shadow(0 0 6px rgba(34,211,238,.9));
      animation: flash .18s linear forwards;
      z-index: 58;
    }
    @keyframes flash {
      from { opacity: .95; }
      to   { opacity: 0; }
    }

    /* Lightning bolt (jagged multi-segment) */
    .fx.bolt {
      height: 3px;
      background: linear-gradient(90deg, #ffffff, #c7e0ff);
      box-shadow: 0 0 8px rgba(59,130,246,.95), 0 0 16px rgba(147,197,253,.8);
      border-radius: 2px;
      opacity: .95;
      animation: boltFade .14s ease-out forwards;
      z-index: 62;
    }
    @keyframes boltFade {
      to { opacity: 0; }
    }

    /* Burning particles */
    .fx.flameParticle {
      width: 6px; height: 6px; border-radius: 50%;
      background: radial-gradient(circle, rgba(255,196,0,1) 0%, rgba(255,94,0,.9) 55%, rgba(255,0,0,0) 60%);
      filter: drop-shadow(0 0 6px rgba(255,120,0,.9));
      animation: rise .8s ease-out forwards;
      z-index: 61;
    }
    .fx.smokeParticle {
      width: 6px; height: 6px; border-radius: 50%;
      background: radial-gradient(circle, rgba(120,120,120,.7) 0%, rgba(80,80,80,.4) 60%, rgba(0,0,0,0) 70%);
      animation: rise .9s ease-out forwards;
      z-index: 60;
    }
    @keyframes rise {
      0%   { transform: translate(-50%,-50%) translateY(0) scale(1); opacity: .9; }
      100% { transform: translate(-50%,-50%) translateY(-14px) scale(.6); opacity: 0; }
    }

    @keyframes puff{
      from{ opacity:1; transform:translate(-50%,-50%) scale(1); }
      to{ opacity:0; transform:translate(-50%,-50%) scale(2); }
    }
  </style>
</head>
<body>
  <div id="sidebar">
    <h4>üõ°Ô∏è Troops</h4>
    <div class="troop-tray">
      <button onclick="selectTroopType('base')">üó°Ô∏è Swordsman (1)</button>
      <button onclick="selectTroopType('archer')">üèπ Archer (1)</button>
      <button onclick="selectTroopType('guardian')">üõ°Ô∏è Guardian (4)</button>
      <button onclick="selectTroopType('raider')">üêé Raider (4)</button>
      <button onclick="selectTroopType('bomber')">üí£ Bomber (6)</button>
      <button onclick="selectTroopType('golem')">üíé Golem (8)</button>
      <button onclick="selectTroopType('dragon')">üêâ Dragon (12)</button>
      <button onclick="selectTroopType('cthulu')">üêô Cthulu (14)</button>
    </div>
    <div><strong>Troops Left:</strong> <span id="troopCount">0</span></div>
    <button id="surrenderBtn" onclick="endBattle(false, true)">üè≥Ô∏è Surrender</button>
    <button id="backLobbyBtn">‚üµ Back to Lobby</button>
  </div>

  <div id="grid"></div>

  <div id="resultPopup">
    <h2 id="resultText">Result</h2>
    <button onclick="(function(){const q=new URLSearchParams(location.search);const u=q.get('attacker')||q.get('username')||'';const base='/game/villagelobby.html';location.href=u?`${base}?username=${encodeURIComponent(u)}`:base;})()">Return to Village Lobby</button>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getFirestore, doc, getDoc, updateDoc, increment } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
      authDomain: "bible-game-246c0.firebaseapp.com",
      projectId: "bible-game-246c0",
      storageBucket: "bible-game-246c0.appspot.com",
      messagingSenderId: "959619818996",
      appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
    };
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    const params = new URLSearchParams(window.location.search);
    const attacker = params.get("attacker");
    const defender = params.get("defender");
    const defenderUserRef = doc(db, "users", defender);

    const goblinVillages = ["Goblin1","Goblin2","Goblin3","Goblin4","Goblin5","Goblin6","Goblin7","Goblin8","Goblin9","Goblin10","Goblin11","Goblin12","Goblin13","Goblin14","Goblin15","Goblin16","Goblin17","Goblin18","Goblin19","Goblin20"];
    const isGoblinBattle = goblinVillages.includes(defender);

    const gridSize = 16;
    const gridElement = document.getElementById("grid");

    const healthMap = {};
    const troopUnits = [];
    const skeletons = [];
    let selectedTroopType = "base";
    let troopsLeft = 0;
    let archerInterval;
    let battleOver = false;
    let attackerRef;
    let defenderData;

    /* Burning state: key -> {until, tickTimer, particleTimer} */
    const burningState = new Map();

    const buildingHealth = {
      wall: 40,
      strongWall: 180,
      archerTower: 25,
      trap: 40,
      lightningStriker: 30,
      troopStructure: 10,
      sniperTower: 30,
      cannonTower: 35,
      necromancerTower: 28
    };

    const structureEmoji = {
      wall: "üß±",
      strongWall: "üß±",
      archerTower: "üèπ",
      trap: "ü™§",
      lightningStriker: "‚ö°",
      troopStructure: "üè∞",
      sniperTower: "üéØ",
      cannonTower: "üí£",
      necromancerTower: "‚ò†Ô∏è"
    };

    const troopStats = {
      base:    { hp: 22,  damage: 6, range: 1, speed: 1, cost: 1, atkCd: 800 },
      archer:  { hp: 12,  damage: 3, range: 4, speed: 1, cost: 1, atkCd: 800 },
      guardian:{ hp: 110, damage: 4, range: 1, speed: 1, cost: 4, atkCd: 800 },
      raider:  { hp: 26,  damage: 5, range: 2, speed: 2, cost: 4, atkCd: 800 },
      bomber:  { hp: 20,  damage: 20,range: 2, speed: 0, cost: 6, atkCd: 800 },
      golem:   { hp: 200, damage: 4, range: 1, speed: 1, cost: 8, atkCd: 800 },
      /* DRAGON slower fire rate */
      dragon:  { hp: 90,  damage: 8, range: 3, speed: 2, cost: 12, atkCd: 1600 },
      cthulu:  { hp: 54,  damage: 6, range: 3, speed: 1, cost: 14, atkCd: 900 }
    };

    const enemyStructures = [];
    const archerTowers = [];
    const lightningTowers = [];
    const trapTowers = [];
    const sniperTowers = [];
    const cannonTowers = [];
    const necroTowers = [];

    const inBounds = (x,y)=> x>=0 && y>=0 && x<gridSize && y<gridSize;
    const cellAt = (x,y)=> document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
    const isBlocked = (x,y)=> {
      const c = cellAt(x,y);
      return !c || (c.classList.length > 1);
    };
    function gridCenter(el){
      const rect = el.getBoundingClientRect();
      const gridRect = gridElement.getBoundingClientRect();
      return { x: rect.left - gridRect.left + rect.width/2, y: rect.top - gridRect.top + rect.height/2 };
    }
    function spawnFX(x,y,cls="hit"){
      const c = cellAt(x,y); if(!c) return;
      const fx = document.createElement("div");
      fx.className = `fx ${cls}`;
      const p = gridCenter(c);
      fx.style.left = p.x + "px"; fx.style.top = p.y + "px";
      gridElement.appendChild(fx);
      setTimeout(()=> fx.remove(), 460);
    }
    function shootProjectile(fromX,fromY,toX,toY,cls,onHit,travelMs=250){
      const from = cellAt(fromX,fromY), to = cellAt(toX,toY);
      if(!from || !to){ onHit?.(); return; }
      const pFrom = gridCenter(from), pTo = gridCenter(to);
      const dot = document.createElement("div");
      dot.className = `proj ${cls}`;
      dot.style.left = pFrom.x + "px";
      dot.style.top = pFrom.y + "px";
      gridElement.appendChild(dot);
      const start = performance.now();
      function step(t){
        const k = Math.min(1,(t-start)/travelMs);
        dot.style.left = (pFrom.x + (pTo.x-pFrom.x)*k) + "px";
        dot.style.top  = (pFrom.y + (pTo.y-pFrom.y)*k) + "px";
        if(k<1) requestAnimationFrame(step);
        else{ dot.remove(); onHit?.(); }
      }
      requestAnimationFrame(step);
    }

    function renderHealth(cell, key, value) {
      let healthBar = cell.querySelector(".health-bar");
      if (!healthBar) {
        healthBar = document.createElement("div");
        healthBar.className = "health-bar";
        const fill = document.createElement("div");
        fill.className = "health-fill";
        healthBar.appendChild(fill);
        cell.appendChild(healthBar);
      }
      const fill = healthBar.querySelector(".health-fill");
      const full = healthMap[key].max;
      fill.style.width = `${(value / full) * 100}%`;
    }

    function getClosestTarget(x, y) {
      let minDist = Infinity, closest = null;
      for (const s of enemyStructures) {
        const key = `${s.x},${s.y}`;
        if (healthMap[key]?.current > 0) {
          const dist = Math.abs(s.x - x) + Math.abs(s.y - y);
          if (dist < minDist) { minDist = dist; closest = s; }
        }
      }
      for (const sk of skeletons) {
        if (sk.hp <= 0) continue;
        const dist = Math.abs(sk.x - x) + Math.abs(sk.y - y);
        if (dist < minDist) { minDist = dist; closest = sk; }
      }
      return closest;
    }

    function getClosestTower(x,y){
      let best=null, bd=Infinity;
      for (const s of enemyStructures){
        const key = `${s.x},${s.y}`;
        if (!healthMap[key]?.current) continue;
        if (["archerTower","lightningStriker","troopStructure","sniperTower","cannonTower","necromancerTower","trap"].includes(s.type)){
          const d = Math.abs(s.x-x)+Math.abs(s.y-y);
          if (d<bd){ bd=d; best=s; }
        }
      }
      return best;
    }

    /* ======== CTHULU: now supports diagonal beams (8-way) and still hurts skeletons ======== */
    function chooseBeamDirection8(fromX, fromY, targetX, targetY){
      const dx = Math.sign(targetX - fromX);
      const dy = Math.sign(targetY - fromY);
      // If both 0 (same tile), default to right
      return { dirX: dx || 1, dirY: dy || 0 };
    }
    function castBeam8(fromX, fromY, dirX, dirY, damage, range){
      let steps = 0;
      let x = fromX + dirX, y = fromY + dirY;
      const angle = Math.atan2(dirY, dirX) * 180 / Math.PI;

      while (inBounds(x,y) && steps < range){
        const cell = cellAt(x,y);
        if (cell){
          const seg = document.createElement("div");
          seg.className = "fx beam";
          const p = gridCenter(cell);
          seg.style.left = p.x + "px";
          seg.style.top  = p.y + "px";
          seg.style.transform = `translate(-50%,-50%) rotate(${angle}deg)`;
          gridElement.appendChild(seg);
          setTimeout(()=>seg.remove(), 220);
        }

        // Damage structures
        const k = `${x},${y}`;
        const th = healthMap[k];
        if (th?.current > 0){
          th.current = Math.max(0, th.current - damage);
          const tCell = cellAt(x,y);
          if (th.current === 0){
            delete healthMap[k];
            if (tCell){ tCell.className="cell"; tCell.innerHTML=""; }
            removeStructureFromList(x,y);
            stopBurning(k);
            checkVictoryCondition();
          } else if (tCell){ renderHealth(tCell, k, th.current); }
        }

        // Damage skeletons on the same tile
        for (const sk of skeletons){
          if (sk.hp > 0 && sk.x === x && sk.y === y){
            sk.hp = Math.max(0, sk.hp - damage);
            if (sk.hpDisplay) sk.hpDisplay.textContent = sk.hp;
            if (sk.hp === 0){
              const sc = cellAt(sk.x, sk.y);
              if (sc && sk.div && sk.div.parentNode === sc) sc.removeChild(sk.div);
              clearInterval(sk.interval);
            }
          }
        }

        steps++;
        x += dirX; y += dirY;
      }
    }

    /* =================== LIGHTNING FX (bolt) =================== */
    function spawnLightningFX(fromX,fromY,toX,toY){
      const a = cellAt(fromX,fromY);
      const b = cellAt(toX,toY);
      if (!a || !b) return;
      const pA = gridCenter(a), pB = gridCenter(b);

      // Create 5‚Äì7 jagged segments with small random lateral offsets
      const parts = 6 + Math.floor(Math.random()*2); // 6-7
      const points = [];
      for (let i=0;i<=parts;i++){
        const t = i/parts;
        const x = pA.x + (pB.x - pA.x)*t;
        const y = pA.y + (pB.y - pA.y)*t;
        // lateral jitter perpendicular to main dir
        const dx = pB.x - pA.x, dy = pB.y - pA.y;
        const len = Math.hypot(dx,dy) || 1;
        const nx = -dy/len, ny = dx/len;
        const jitter = (Math.random()*8 - 4); // -4..4 px
        points.push({x: x + nx*jitter, y: y + ny*jitter});
      }
      for (let i=0;i<points.length-1;i++){
        const p1 = points[i], p2 = points[i+1];
        const seg = document.createElement("div");
        seg.className = "fx bolt";
        const cx = (p1.x + p2.x)/2;
        const cy = (p1.y + p2.y)/2;
        const w = Math.hypot(p2.x-p1.x, p2.y-p1.y);
        const ang = Math.atan2(p2.y-p1.y, p2.x-p1.x) * 180/Math.PI;
        seg.style.width = `${w}px`;
        seg.style.left = `${cx}px`;
        seg.style.top  = `${cy}px`;
        seg.style.transform = `translate(-50%,-50%) rotate(${ang}deg)`;
        gridElement.appendChild(seg);
        setTimeout(()=>seg.remove(), 140);
      }
    }

    /* =================== BURNING (DOT + particles + spread) =================== */
    function igniteCell(x,y, dps=1, durationMs=1000){
      const key = `${x},${y}`;
      if (!healthMap[key]?.current) return; // no building to burn
      const now = Date.now();
      const until = now + durationMs;

      // If already burning, extend
      const prev = burningState.get(key);
      if (prev){
        prev.until = Math.max(prev.until, until);
        return;
      }

      const tickEvery = 250; // 4 ticks/sec
      const tick = setInterval(()=>{
        const th = healthMap[key];
        if (!th) { stopBurning(key); return; }
        th.current = Math.max(0, th.current - dps);
        const c = cellAt(x,y);
        if (th.current === 0){
          delete healthMap[key];
          if (c){ c.className="cell"; c.innerHTML=""; }
          removeStructureFromList(x,y);
          stopBurning(key);
          checkVictoryCondition();
        } else if (c){ renderHealth(c, key, th.current); }
        if (Date.now() >= (burningState.get(key)?.until || 0)) stopBurning(key);
      }, tickEvery);

      // Particle visuals while burning
      const particles = setInterval(()=>{
        const cell = cellAt(x,y);
        if (!cell || Date.now() >= (burningState.get(key)?.until || 0)) return;
        const p = gridCenter(cell);
        for (let i=0;i<2;i++){
          const f = document.createElement("div");
          f.className = "fx flameParticle";
          f.style.left = (p.x + (Math.random()*10 - 5)) + "px";
          f.style.top  = (p.y + (Math.random()*4 - 6)) + "px";
          gridElement.appendChild(f);
          setTimeout(()=>f.remove(), 800);
        }
        const s = document.createElement("div");
        s.className = "fx smokeParticle";
        s.style.left = (p.x + (Math.random()*12 - 6)) + "px";
        s.style.top  = (p.y - 2 + (Math.random()*4 - 2)) + "px";
        gridElement.appendChild(s);
        setTimeout(()=>s.remove(), 900);
      }, 150);

      burningState.set(key, { until, tickTimer: tick, particleTimer: particles });
    }
    function stopBurning(key){
      const st = burningState.get(key);
      if (!st) return;
      clearInterval(st.tickTimer);
      clearInterval(st.particleTimer);
      burningState.delete(key);
    }

    function spreadFireFrom(tx,ty, dps=1, durationMs=1000){
      const dirs = [-1,0,1];
      for (let ax of dirs){
        for (let ay of dirs){
          if (ax===0 && ay===0) continue;
          const sx = tx+ax, sy = ty+ay;
          const k = `${sx},${sy}`;
          if (healthMap[k]?.current>0){
            igniteCell(sx,sy,dps,durationMs);
          }
        }
      }
    }

    function getClosestSpecialTarget(ox, oy) {
      const prio = ["archerTower","sniperTower","lightningStriker","necromancerTower","cannonTower","trap"];
      let best=null, bestDist=Infinity;
      for (const s of enemyStructures) {
        if (!prio.includes(s.type)) continue;
        const key = `${s.x},${s.y}`;
        if (!healthMap[key] || healthMap[key].current <= 0) continue;
        const d = Math.abs(s.x - ox) + Math.abs(s.y - oy);
        if (d < bestDist) { bestDist = d; best = s; }
      }
      return best;
    }

    /* =================== TROOPS =================== */
    function selectTroopType(type){ selectedTroopType = type; }
    window.selectTroopType = selectTroopType;

    function createTroopDiv(emoji, cls, hp){
      const wrap = document.createElement("div"); wrap.style.position="relative";
      const hpBar = document.createElement("div"); hpBar.className="troop-hp"; hpBar.textContent = hp;
      const icon = document.createElement("div"); icon.className = "troop " + cls; icon.textContent = emoji;
      wrap.appendChild(hpBar); wrap.appendChild(icon);
      return {wrap, hpBar};
    }

    function spawnTroop(x, y) {
      const cost = troopStats[selectedTroopType].cost;
      if (troopsLeft < cost || battleOver) return;
      const cell = cellAt(x,y);
      if (!cell || cell.classList.length > 1) return;

      const stats = troopStats[selectedTroopType];
      const emoji =
        selectedTroopType === "archer"   ? "üèπ" :
        selectedTroopType === "guardian" ? "üõ°Ô∏è" :
        selectedTroopType === "bomber"   ? "üí£" :
        selectedTroopType === "raider"   ? "üêé" :
        selectedTroopType === "golem"    ? "üíé" :
        selectedTroopType === "dragon"   ? "üêâ" :
        selectedTroopType === "cthulu"   ? "üêô" : "üó°Ô∏è";

      const {wrap, hpBar} = createTroopDiv(emoji, selectedTroopType, stats.hp);
      cell.appendChild(wrap);

      const troop = {
        x, y,
        hp: stats.hp,
        damage: stats.damage,
        range: stats.range,
        speed: stats.speed,
        type: selectedTroopType,
        interval: null,
        div: wrap, hpDisplay: hpBar,
        taunt: (selectedTroopType === "guardian"),
        flying: (selectedTroopType === "dragon"),
        lastAttack: 0,
        atkCd: stats.atkCd || 800
      };
      troopUnits.push(troop);

      troopsLeft -= cost;
      document.getElementById("troopCount").textContent = troopsLeft;

      troop.interval = setInterval(() => {
        if (battleOver) return;

        /* ======== BOMBER: already hurts skeletons in radius ======== */
        if (troop.type === "bomber") {
          let didExplode = false;
          const R = troop.range;
          for (let dx=-R; dx<=R; dx++){
            for (let dy=-R; dy<=R; dy++){
              if (dx===0 && dy===0) continue;
              const tx=troop.x+dx, ty=troop.y+dy;
              if (!inBounds(tx,ty)) continue;

              // Damage structures
              const key = `${tx},${ty}`, th = healthMap[key];
              if (th?.current > 0){
                didExplode = true;
                th.current = Math.max(0, th.current - troop.damage);
                const cellT = cellAt(tx,ty);
                if (th.current === 0){
                  delete healthMap[key];
                  if (cellT){ cellT.className="cell"; cellT.innerHTML=""; }
                  removeStructureFromList(tx,ty);
                  stopBurning(key);
                  checkVictoryCondition();
                } else if (cellT){ renderHealth(cellT, key, th.current); }
              }

              // Damage skeletons on affected tiles
              for (const sk of skeletons){
                if (sk.hp > 0 && sk.x === tx && sk.y === ty){
                  didExplode = true;
                  sk.hp = Math.max(0, sk.hp - troop.damage);
                  if (sk.hpDisplay) sk.hpDisplay.textContent = sk.hp;
                  if (sk.hp === 0){
                    const sc = cellAt(sk.x, sk.y);
                    if (sc && sk.div && sk.div.parentNode === sc) sc.removeChild(sk.div);
                    clearInterval(sk.interval);
                  }
                }
              }
            }
          }
          if (didExplode){
            spawnFX(troop.x, troop.y, "explosion");
            troop.hp = Math.max(0, troop.hp - troop.damage);
            troop.hpDisplay.textContent = troop.hp;
            if (troop.hp <= 0){
              clearInterval(troop.interval);
              const c = cellAt(troop.x,troop.y); if (c) c.innerHTML="";
              onTroopDeath(troop.x,troop.y);
            }
            return;
          }
        }

        // Target selection
        const getClosestSpecialTarget = (ox, oy) => {
          const prio = ["archerTower","sniperTower","lightningStriker","necromancerTower","cannonTower","trap"];
          let best=null, bestDist=Infinity;
          for (const s of enemyStructures) {
            if (!prio.includes(s.type)) continue;
            const key = `${s.x},${s.y}`;
            if (!healthMap[key] || healthMap[key].current <= 0) continue;
            const d = Math.abs(s.x - ox) + Math.abs(s.y - oy);
            if (d < bestDist) { bestDist = d; best = s; }
          }
          return best;
        };

        const targetObj = (troop.type==='dragon')
          ? (getClosestTower(troop.x,troop.y) || getClosestTarget(troop.x,troop.y))
          : (troop.type==='raider'
              ? (getClosestSpecialTarget(troop.x,troop.y) || getClosestTarget(troop.x,troop.y))
              : getClosestTarget(troop.x,troop.y));

        if (!targetObj) { clearInterval(troop.interval); endBattle(true); return; }

        const isSkeleton = !!targetObj.isSkeleton;
        const tx = targetObj.x, ty = targetObj.y;
        const dx = tx - troop.x, dy = ty - troop.y;
        const dist = Math.abs(dx)+Math.abs(dy);
        const inRange = dist <= troop.range;

        const oldCell = cellAt(troop.x,troop.y);
        if (oldCell && troop.div && troop.div.parentNode===oldCell) oldCell.removeChild(troop.div);

        const now = Date.now();

        if (inRange && (now - troop.lastAttack) >= troop.atkCd){
          troop.lastAttack = now;

          if (troop.type==='archer'){
            shootProjectile(troop.x,troop.y,tx,ty,"arrow",()=>{
              doDamageToTarget(targetObj, troop.damage);
              spawnFX(tx,ty,"hit");
            }, 220);

          } else if (troop.type==='dragon'){
            // Fireball + ignite + spread + visible fire FX
            shootProjectile(troop.x,troop.y,tx,ty,"fire",()=>{
              if (!isSkeleton){
                doDamageToTarget(targetObj, troop.damage);
                spawnFX(tx,ty,"fire");
                // Ignite target and neighbors with low DPS for 1 second
                igniteCell(tx,ty, 1, 1000);
                spreadFireFrom(tx,ty, 1, 1000);
              } else {
                targetObj.hp = Math.max(0, targetObj.hp - troop.damage);
                if (targetObj.hp<=0){
                  const c = cellAt(targetObj.x,targetObj.y); if (c) c.innerHTML="";
                }
                spawnFX(tx,ty,"fire");
              }
            }, 270);

          } else if (troop.type==='cthulu'){
            const { dirX, dirY } = chooseBeamDirection8(troop.x, troop.y, tx, ty);
            castBeam8(troop.x, troop.y, dirX, dirY, troop.damage, troop.range);

          } else {
            doDamageToTarget(targetObj, troop.damage);
            spawnFX(tx,ty,"splash");
          }

        } else if (!inRange) {
          // Move toward target
          if (troop.type==='archer'){
            troop.x += Math.sign(dx);
            troop.y += Math.sign(dy);

          } else if (troop.type==='dragon'){
            const steps = troop.speed;
            for (let s=0; s<steps; s++){
              troop.x += Math.sign(dx);
              troop.y += Math.sign(dy);
            }

          } else if (troop.type==='golem' || troop.type==='minigolem' || troop.type==='cthulu'){
            const nx = troop.x + Math.sign(dx);
            const ny = troop.y + Math.sign(dy);
            if (inBounds(nx,ny) && !isBlocked(nx,ny)){
              troop.x=nx; troop.y=ny;
            } else {
              const bdx = Math.sign(dx), bdy = Math.sign(dy);
              const bx = troop.x + bdx, by = troop.y + bdy;
              if (inBounds(bx,by) && isBlocked(bx,by) && (Math.abs(dx)+Math.abs(dy) <= troop.range+1)){
                const block = enemyStructures.find(s=>s.x===bx && s.y===by);
                if (block){
                  if (troop.type==='cthulu'){
                    const { dirX, dirY } = chooseBeamDirection8(troop.x, troop.y, bx, by);
                    castBeam8(troop.x, troop.y, dirX, dirY, troop.damage, troop.range);
                  } else {
                    doDamageToTarget(block, troop.damage);
                  }
                  spawnFX(bx,by,"splash");
                }
              }
            }

          } else {
            const steps = troop.type==='raider' ? 2 : 1;
            for (let s=0; s<steps; s++){
              const nx = troop.x + Math.sign(dx);
              const ny = troop.y + Math.sign(dy);
              if (!inBounds(nx,ny)) break;
              const blocked = isBlocked(nx,ny) && troop.type!=='raider';
              if (blocked) break;
              troop.x = nx; troop.y = ny;
            }
          }
        }

        const newCell = cellAt(troop.x,troop.y);
        if (newCell) newCell.appendChild(troop.div);

      }, 800);
    }

    function removeStructureFromList(x,y){
      const i = enemyStructures.findIndex(s=>s.x===x && s.y===y);
      if (i>-1) enemyStructures.splice(i,1);
    }

    function doDamageToTarget(targetOrSkeleton, dmg){
      if (targetOrSkeleton.isSkeleton){
        targetOrSkeleton.hp = Math.max(0, targetOrSkeleton.hp - dmg);
        if (targetOrSkeleton.hpDisplay) targetOrSkeleton.hpDisplay.textContent = targetOrSkeleton.hp;
        if (targetOrSkeleton.hp <= 0){
          const c = cellAt(targetOrSkeleton.x,targetOrSkeleton.y);
          if (c && targetOrSkeleton.div && targetOrSkeleton.div.parentNode===c) c.removeChild(targetOrSkeleton.div);
          clearInterval(targetOrSkeleton.interval);
          targetOrSkeleton.hp = 0;
        }
        return;
      }
      const key = `${targetOrSkeleton.x},${targetOrSkeleton.y}`;
      const th = healthMap[key];
      if (!th) return;
      th.current = Math.max(0, th.current - dmg);
      const tCell = cellAt(targetOrSkeleton.x,targetOrSkeleton.y);
      if (th.current === 0){
        delete healthMap[key];
        if (tCell){ tCell.className="cell"; tCell.innerHTML=""; }
        removeStructureFromList(targetOrSkeleton.x,targetOrSkeleton.y);
        stopBurning(key);
        checkVictoryCondition();
      } else if (tCell){ renderHealth(tCell, key, th.current); }
    }

    /* =================== MINI-GOLEM & NECRO =================== */
    function spawnMiniGolem(x,y){
      if (!inBounds(x,y) || isBlocked(x,y)) return null;
      const {wrap, hpBar} = createTroopDiv("üîπ","minigolem",30);
      const c = cellAt(x,y); if (c) c.appendChild(wrap);
      const mg = { x,y, hp:30, damage:2, range:1, speed:1, type:"minigolem", div:wrap, hpDisplay:hpBar, interval:null, lastAttack:0, atkCd:900 };
      troopUnits.push(mg);
      mg.interval = setInterval(()=>{
        if (battleOver || mg.hp<=0) return;
        const target = getClosestTarget(mg.x,mg.y);
        if (!target) { clearInterval(mg.interval); endBattle(true); return; }
        const dx = target.x - mg.x, dy = target.y - mg.y;
        const dist = Math.abs(dx)+Math.abs(dy);
        const now = Date.now();
        if (dist <= mg.range && (now - mg.lastAttack) >= mg.atkCd){
          mg.lastAttack = now;
          doDamageToTarget(target, mg.damage);
          spawnFX(target.x,target.y,"splash");
        } else if (dist > mg.range){
          const nx = mg.x + Math.sign(dx), ny = mg.y + Math.sign(dy);
          if (inBounds(nx,ny) && !isBlocked(nx,ny)){
            const from = cellAt(mg.x,mg.y); if (from && mg.div && mg.div.parentNode===from) from.removeChild(mg.div);
            mg.x=nx; mg.y=ny;
            const to = cellAt(nx,ny); if (to) to.appendChild(mg.div);
          }
        }
      }, 900);
      return mg;
    }

    function onTroopDeath(x,y){
      if (typeof window.__checkNecroReanimate === "function"){
        const done = window.__checkNecroReanimate(x,y);
        if (done) return;
      }
    }

    /* =================== GRID & WIN =================== */
    function createGrid() {
      gridElement.innerHTML = "";
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.dataset.x = x;
          cell.dataset.y = y;
          cell.onclick = () => spawnTroop(x, y);
          gridElement.appendChild(cell);
        }
      }
    }

    function checkVictoryCondition() {
      const remaining = Object.values(healthMap).filter(h => h.current > 0);
      if (remaining.length === 0) endBattle(true);
    }

    // defeat now supports surrender redirect
    async function endBattle(victory, surrendered = false) {
      if (battleOver) return;
      battleOver = true;
      clearInterval(archerInterval);
      troopUnits.forEach(t => clearInterval(t.interval));
      skeletons.forEach(s => clearInterval(s.interval));

      // stop any burning timers
      for (const [k, st] of burningState.entries()) stopBurning(k);

      const attackerUserRef = doc(db, "users", attacker);
      const defenderUserRef2 = doc(db, "users", defender);
      const updates = [];

      if (victory) {
        const reward = isGoblinBattle ? 50 : 5;
        updates.push(updateDoc(attackerUserRef, { bucks: increment(reward) }));
        updates.push(updateDoc(defenderUserRef2, { bucks: increment(-10) }));
        if (isGoblinBattle) updates.push(updateDoc(attackerUserRef, { campaign: increment(1) }));
        document.getElementById("resultText").textContent = `üèÜ Victory! You earned ${reward} bucks.`;
        document.getElementById("resultPopup").style.display = "block";
      } else {
        try {
          const aSnap = await getDoc(attackerUserRef);
          const aData = aSnap.data() || {};
          const current = Number(aData.bucks || 0);
          const loss = Math.min(5, Math.max(0, current));
          if (loss > 0) updates.push(updateDoc(attackerUserRef, { bucks: current - loss }));
          if (!isGoblinBattle) updates.push(updateDoc(defenderUserRef2, { bucks: increment(5) }));
          await Promise.all(updates);
        } catch (e) { console.warn("Defeat update error:", e); }

        const msg = surrendered ? "üè≥Ô∏è You surrendered. Up to 5 bucks deducted." : "‚ùå Defeat! Up to 5 bucks deducted.";
        document.getElementById("resultText").textContent = msg;

        if (surrendered) {
          const u = attacker || params.get("username") || "";
          const base = "/game/villagelobby.html";
          location.href = u ? `${base}?username=${encodeURIComponent(u)}` : base;
        } else {
          document.getElementById("resultPopup").style.display = "block";
        }
      }
    }
    window.endBattle = endBattle;

    /* =================== TOWERS =================== */
    function startArcherAttacks() {
      archerInterval = setInterval(() => {
        if (battleOver) return;
        for (const {x,y} of archerTowers){
          const key = `${x},${y}`; if (!healthMap[key]?.current) continue;
          const inRange = troopUnits.filter(t => t.hp>0 && Math.abs(t.x-x)+Math.abs(t.y-y) <= 5);
          if (!inRange.length) continue;
          const taunters = inRange.filter(t => t.taunt);
          const candidates = taunters.length ? taunters : inRange;
          let target = candidates.reduce((best,t)=>{
            const d = Math.abs(t.x-x)+Math.abs(t.y-y);
            const bd = Math.abs(best.x-x)+Math.abs(best.y-y);
            return d<bd ? t : best;
          }, candidates[0]);
          shootProjectile(x,y,target.x,target.y,"arrow",()=>{
            target.hp -= 5;
            if (target.hpDisplay) targetHpUpdate(target);
            spawnFX(target.x,target.y,"hit");
            if (target.hp <= 0){
              clearInterval(target.interval);
              const c = cellAt(target.x,target.y); if (c) c.innerHTML="";
              onTroopDeath(target.x,target.y);
            }
          }, 240);
        }
      }, 1400);
    }

    function startLightningAttacks() {
      setInterval(() => {
        if (battleOver) return;
        for (const {x:lx,y:ly} of lightningTowers){
          const key = `${lx},${ly}`;
          const th = healthMap[key]; if (!th || th.current<=0) continue;
          for (const troop of troopUnits){
            if (troop.hp<=0) continue;
            if (Math.abs(troop.x-lx)+Math.abs(troop.y-ly) <= 3){
              // Fancy lightning bolt instead of ball
              spawnLightningFX(lx,ly,troop.x,troop.y);
              setTimeout(()=>{
                troop.hp -= 1;
                if (troop.hpDisplay) targetHpUpdate(troop);
                spawnFX(troop.x,troop.y,"hit");
                if (troop.hp<=0){
                  const c = cellAt(troop.x,troop.y); if (c) c.innerHTML="";
                  clearInterval(troop.interval);
                  onTroopDeath(troop.x,troop.y);
                }
              }, 100);
            }
          }
        }
      }, 400);
    }

    function targetHpUpdate(t){ if (t.hpDisplay) t.hpDisplay.textContent = t.hp; }

    function startTrapAttacks() {
      setInterval(() => {
        if (battleOver) return;
        for (const {x:tx,y:ty} of trapTowers){
          const key = `${tx},${ty}`;
          const th = healthMap[key]; if (!th || th.current<=0) continue;
          for (const troop of troopUnits){
            if (troop.hp<=0) continue;
            if (troop.type==='dragon') continue;
            if (Math.hypot(troop.x-tx, troop.y-ty) <= 1.5){
              troop.hp -= 10;
              targetHpUpdate(troop);
              spawnFX(troop.x,troop.y,"splash");
              if (troop.hp<=0){
                const c = cellAt(troop.x,troop.y); if (c) c.innerHTML="";
                clearInterval(troop.interval);
                onTroopDeath(troop.x,troop.y);
              }
            }
          }
        }
      }, 1000);
    }

    function startSniperAttacks() {
      const RANGE=12, DAMAGE=15, FIRE_RATE=1600;
      setInterval(() => {
        if (battleOver) return;
        for (const {x,y} of sniperTowers){
          const key = `${x},${y}`; if (!healthMap[key]?.current) continue;
          let target=null, bestDist=Infinity;
          for (const t of troopUnits){
            if (t.hp<=0) continue;
            const d = Math.abs(t.x-x)+Math.abs(t.y-y);
            if (d<=RANGE && d<bestDist){ bestDist=d; target=t; }
          }
          if (!target) continue;
          shootProjectile(x,y,target.x,target.y,"snipe",()=>{
            target.hp = Math.max(0, target.hp - DAMAGE);
            targetHpUpdate(target);
            spawnFX(target.x,target.y,"hit");
            if (target.hp<=0){
              const c = cellAt(target.x,target.y); if (c) c.innerHTML="";
              clearInterval(target.interval);
              onTroopDeath(target.x,target.y);
            }
          }, 200);
        }
      }, FIRE_RATE);
    }

    function startCannonAttacks(){
      const RANGE=6, DAMAGE=8, FIRE_RATE=2200, KNOCK=1;
      setInterval(()=>{
        if (battleOver) return;
        for (const {x,y} of cannonTowers){
          const key = `${x},${y}`; if (!healthMap[key]?.current) continue;
          let target=null, best=Infinity;
          for (const t of troopUnits){
            if (t.hp<=0 || t.type==='dragon') continue;
            const d = Math.abs(t.x-x)+Math.abs(t.y-y);
            if (d<=RANGE && d<best){ best=d; target=t; }
          }
          if (!target) continue;
          shootProjectile(x,y,target.x,target.y,"cannon",()=>{
            for (let dx=-1; dx<=1; dx++){
              for (let dy=-1; dy<=1; dy++){
                const tx=target.x+dx, ty=target.y+dy;
                if (!inBounds(tx,ty)) continue;

                for (const t of troopUnits){
                  if (t.hp<=0) continue;
                  if (t.x===tx && t.y===ty){
                    t.hp = Math.max(0, t.hp - DAMAGE);
                    targetHpUpdate(t);
                    spawnFX(tx,ty,"splash");
                    if (t.hp<=0){
                      const c = cellAt(t.x,t.y); if (c) c.innerHTML="";
                      clearInterval(t.interval);
                      onTroopDeath(t.x,t.y);
                    }
                  }
                }

                const vx = Math.sign(tx - target.x), vy = Math.sign(ty - target.y);
                if (vx===0 && vy===0) continue;
                const kx = tx + vx*KNOCK, ky = ty + vy*KNOCK;
                if (!inBounds(kx,ky) || isBlocked(kx,ky)) continue;

                for (const t of troopUnits){
                  if (t.hp>0 && t.x===tx && t.y===ty){
                    const fromCell = cellAt(t.x,t.y);
                    if (fromCell && t.div && t.div.parentNode===fromCell) fromCell.removeChild(t.div);
                    t.x=kx; t.y=ky;
                    const toCell = cellAt(kx,ky); if (toCell) toCell.appendChild(t.div);
                  }
                }
                for (const s of skeletons){
                  if (s.hp>0 && s.x===tx && s.y===ty){
                    const fromCell = cellAt(s.x,s.y);
                    if (fromCell && s.div && s.div.parentNode===fromCell) fromCell.removeChild(s.div);
                    s.x=kx; s.y=ky;
                    const toCell = cellAt(kx,ky); if (toCell) toCell.appendChild(s.div);
                  }
                }
              }
            }
          }, 260);
        }
      }, FIRE_RATE);
    }

    function startNecroAttacks(){
      const RANGE=6, DAMAGE=4, FIRE_RATE=1500, REANIM_RANGE=4;
      setInterval(()=>{
        if (battleOver) return;
        for (const {x,y} of necroTowers){
          const key = `${x},${y}`; if (!healthMap[key]?.current) continue;
          let target=null, best=Infinity;
          for (const t of troopUnits){
            if (t.hp<=0) continue;
            const d = Math.abs(t.x-x)+Math.abs(t.y-y);
            if (d<=RANGE && d<best){ best=d; target=t; }
          }
          if (!target) continue;
          shootProjectile(x,y,target.x,target.y,"necro",()=>{
            target.hp = Math.max(0, target.hp - DAMAGE);
            targetHpUpdate(target);
            spawnFX(target.x,target.y,"hit");
            if (target.hp<=0){
              const cx = target.x, cy = target.y;
              const cell = cellAt(cx,cy); if (cell) cell.innerHTML="";
              clearInterval(target.interval);
              if (Math.abs(cx-x)+Math.abs(cy-y) <= REANIM_RANGE){
                spawnSkeleton(cx,cy);
              } else {
                onTroopDeath(cx,cy);
              }
            }
          }, 220);
        }
      }, FIRE_RATE);

      window.__checkNecroReanimate = function(dx,dy){
        for (const n of necroTowers){
          const key = `${n.x},${n.y}`;
          if (!healthMap[key]?.current) continue;
          if (Math.abs(dx-n.x)+Math.abs(dy-n.y) <= REANIM_RANGE){
            spawnSkeleton(dx,dy);
            return true;
          }
        }
        return false;
      };
    }

    function spawnSkeleton(x,y){
      if (!inBounds(x,y) || isBlocked(x,y)) return;
      const c = cellAt(x,y);
      const div = document.createElement("div");
      div.className = "troop"; div.style.background = "#4b5563"; div.textContent = "üíÄ";
      const hpUi = document.createElement("div");
      hpUi.className = "troop-hp"; hpUi.textContent = "10";
      const wrap = document.createElement("div"); wrap.style.position="relative";
      wrap.appendChild(hpUi); wrap.appendChild(div);
      c.appendChild(wrap);

      const sk = { isSkeleton:true, x,y, hp:10, damage:2, range:1, speed:1, div:wrap, hpDisplay:hpUi, interval:null };
      skeletons.push(sk);

      sk.interval = setInterval(()=>{
        if (battleOver || sk.hp<=0) return;
        let tgt=null, best=Infinity;
        for (const t of troopUnits){
          if (t.hp<=0) continue;
          const d = Math.abs(t.x-sk.x)+Math.abs(t.y-sk.y);
          if (d<best){ best=d; tgt=t; }
        }
        if (!tgt) return;
        const dx = tgt.x - sk.x, dy = tgt.y - sk.y;
        const dist = Math.abs(dx)+Math.abs(dy);
        if (dist <= sk.range){
          tgt.hp = Math.max(0, tgt.hp - sk.damage);
          targetHpUpdate(tgt);
          spawnFX(tgt.x,tgt.y,"splash");
          if (tgt.hp<=0){
            const tc = cellAt(tgt.x,tgt.y); if (tc) tc.innerHTML="";
            clearInterval(tgt.interval);
            onTroopDeath(tgt.x,tgt.y);
          }
        } else {
          const nx = sk.x + Math.sign(dx);
          const ny = sk.y + Math.sign(dy);
          if (inBounds(nx,ny) && !isBlocked(nx,ny)){
            const from = cellAt(sk.x,sk.y); if (from && sk.div && sk.div.parentNode===from) from.removeChild(sk.div);
            sk.x=nx; sk.y=ny;
            const to = cellAt(nx,ny); if (to) to.appendChild(sk.div);
          }
        }
      }, 900);
      return sk;
    }

    /* =================== INIT =================== */
    async function init() {
      await updateDoc(defenderUserRef, { bucks: increment(10) });
      if (!attacker || !defender) return alert("Invalid URL");

      attackerRef = doc(db, "villages", attacker);
      const defenderRef = doc(db, "villages", defender);
      const [attackerSnap, defenderSnap] = await Promise.all([ getDoc(attackerRef), getDoc(defenderRef) ]);

      const attackerData = attackerSnap.data();
      defenderData = defenderSnap.data();

      const troopBuildings = attackerData.grid?.filter(b => b.type === "troopStructure").length || 0;
      troopsLeft = troopBuildings * 5;
      document.getElementById("troopCount").textContent = troopsLeft;

      createGrid();

      for (const b of defenderData.grid || []) {
        const key = `${b.x},${b.y}`;
        const cell = cellAt(b.x,b.y);
        if (!cell) continue;

        cell.classList.add(b.type);
        const hp = buildingHealth[b.type] || 10;
        healthMap[key] = { current: hp, max: hp };
        renderHealth(cell, key, hp);

        const icon = document.createElement("div");
        icon.className = "structure-icon";
        icon.textContent = structureEmoji[b.type] || "";
        cell.appendChild(icon);

        enemyStructures.push({ ...b });

        if (b.type === "archerTower")      archerTowers.push({ x: b.x, y: b.y });
        if (b.type === "lightningStriker") lightningTowers.push({ x: b.x, y: b.y });
        if (b.type === "trap")             trapTowers.push({ x: b.x, y: b.y });
        if (b.type === "sniperTower")      sniperTowers.push({ x: b.x, y: b.y });
        if (b.type === "cannonTower")      cannonTowers.push({ x: b.x, y: b.y });
        if (b.type === "necromancerTower") necroTowers.push({ x: b.x, y: b.y });
      }

      startArcherAttacks();
      startLightningAttacks();
      startTrapAttacks();
      startSniperAttacks();
      startCannonAttacks();
      startNecroAttacks();

      document.getElementById("backLobbyBtn").onclick = ()=>{
        const u = attacker || params.get("username") || "";
        const base = "/game/villagelobby.html";
        location.href = u ? `${base}?username=${encodeURIComponent(u)}` : base;
      };
    }

    init();

    /* ======== EXTRA: golem death hook ======== */
    function golemDeathExplosion(gx,gy){
      for (let dx=-1; dx<=1; dx++){
        for (let dy=-1; dy<=1; dy++){
          const sx=gx+dx, sy=gy+dy, k=`${sx},${sy}`;
          const th = healthMap[k];
          if (th?.current>0){
            th.current = Math.max(0, th.current - 12);
            const c = cellAt(sx,sy);
            if (th.current===0){ delete healthMap[k]; if(c){c.className="cell"; c.innerHTML="";} removeStructureFromList(sx,sy); stopBurning(k); checkVictoryCondition(); }
            else if (c){ renderHealth(c,k,th.current); }
            spawnFX(sx,sy,"splash");
          }
        }
      }
      const spots = [[0,-1],[1,0],[0,1],[-1,0]];
      let spawned = 0;
      for (const [dx,dy] of spots){
        const mx=gx+dx, my=gy+dy;
        if (spawned>=2) break;
        if (inBounds(mx,my) && !isBlocked(mx,my)){
          spawnMiniGolem(mx,my); spawned++;
        }
      }
    }

    const _origOnTroopDeath = onTroopDeath;
    onTroopDeath = function(x,y){
      const dead = troopUnits.find(t=>t.hp<=0 && t.x===x && t.y===y);
      if (dead && dead.type==='golem'){ golemDeathExplosion(dead.x,dead.y); }
      _origOnTroopDeath(x,y);
    };
  </script>
</body>
</html>






