<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>üóª Mountain Blade ‚Äî Battle (PvP)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{ --w:1024px; --h:640px; --tile:48px; }
  *{ box-sizing:border-box }
  body{ margin:0; background:#0b1014; color:#eaf1ff; font-family:system-ui,Segoe UI,Arial; display:grid; place-items:center; min-height:100vh }
  .frame{ width:var(--w); height:var(--h); border:1px solid #21324a; border-radius:12px; overflow:hidden; box-shadow:0 10px 40px rgba(0,0,0,.35); background:#0e1726; position:relative }
  .titlebar{ height:38px; display:flex; align-items:center; gap:8px; padding:0 10px; background:#0f1a2b; border-bottom:1px solid #203049; font-weight:700 }
  .titlebar .dot{ width:10px; height:10px; border-radius:50% } .red{background:#ff5f57}.yellow{background:#ffbd2e}.green{background:#28c840}
  .view{ position:absolute; inset:38px 0 0 0 }
  canvas{ width:100%; height:100%; display:block; background:#0d1020; cursor:crosshair }
  #ui{ position:absolute; inset:0; pointer-events:none }
  #timer{ position:absolute; top:8px; left:50%; transform:translateX(-50%); background:#0f1a2bcc; border:1px solid #2c3f5a; border-radius:10px; padding:6px 10px; font-weight:800 }
  #board{ position:absolute; top:8px; right:8px; min-width:240px; background:#0f1a2bcc; border:1px solid #2c3f5a; border-radius:10px; padding:8px 10px }
  #board h3{ margin:0 0 6px 0; font-size:14px; color:#cfe }
  .row{ display:flex; justify-content:space-between; gap:10px; font-size:13px; color:#cbd5e1 }
  #hint{ position:absolute; top:44px; left:50%; transform:translateX(-50%); background:#15243dcc; border:1px solid #355; border-radius:10px; padding:6px 10px; font-size:13px; display:none }
  #banner{ position:absolute; left:50%; top:28%; transform:translateX(-50%); font-size:26px; padding:10px 16px; background:#102030aa; border:1px solid #345; border-radius:12px; display:none }
  #hud{ position:absolute; left:0; right:0; bottom:0; height:108px; background:rgba(0,0,0,.35); backdrop-filter:blur(4px); border-top:1px solid #263042; display:flex; align-items:center; gap:16px; padding:10px 16px; pointer-events:auto }
  #selInfo{ min-width:280px; line-height:1.25 }
  #abilities{ display:flex; gap:10px }
  .slot{ width:72px; height:72px; border:1px solid #445; border-radius:10px; display:flex; flex-direction:column; align-items:center; justify-content:center; background:#1a2232; position:relative; cursor:pointer; pointer-events:auto }
  .slot .key{ position:absolute; right:6px; bottom:4px; font-size:12px; color:#9ab }
  .slot .emoji{ font-size:24px } .slot .name{ font-size:11px; color:#c9d4e3; margin-top:4px; text-align:center; line-height:1.1; padding:0 4px }
  .slot.oncd::after{ content:""; position:absolute; inset:0; background:rgba(0,0,0,.45); border-radius:10px }
  .cd-badge{ position:absolute; top:4px; right:6px; font-size:11px; color:#cfe; background:#0008; border:1px solid #345; border-radius:6px; padding:1px 5px }
  .legend{ position:absolute; left:8px; top:8px; background:#0f1a2bcc; border:1px solid #2c3f5a; border-radius:10px; padding:6px 10px; font-size:12px }
</style>
</head>
<body>
  <div class="frame">
    <div class="titlebar">
      <span class="dot red"></span><span class="dot yellow"></span><span class="dot green"></span>
      <span>üóª Mountain Blade ‚Äî Battle (PvP)</span>
    </div>
    <div class="view">
      <canvas id="cv" width="1024" height="602"></canvas>
      <div id="ui">
        <div id="timer">‚öîÔ∏è Eliminate the enemy</div>
        <div class="legend">Drag: select ‚Ä¢ Right-click empty: forced move ‚Ä¢ Right-click enemy: attack that unit ‚Ä¢ Q/W/E/R: ability ‚Ä¢ A: attack nearest ‚Ä¢ H: hold ‚Ä¢ Double-click: select same type</div>
        <div id="board"><h3>Armies on field</h3><div id="boardRows"></div></div>
        <div id="hint"></div>
        <div id="banner"></div>
        <div id="hud">
          <div id="selInfo">Select units</div>
          <div id="abilities"></div>
        </div>
      </div>
    </div>
  </div>

<script type="module">
/* ================= Firebase boot ================= */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc, collection, addDoc, onSnapshot,
  query, orderBy, limit, getDocs, deleteDoc, runTransaction
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0",
  storageBucket: "bible-game-246c0.appspot.com",
  messagingSenderId: "959619818996",
  appId: "1:959619818996:web:5a9fbf492e23c765e445a1"
};
const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);

/* ================= URL params ================= */
const Q = new URLSearchParams(location.search);
const BATTLE_ID = Q.get("battleId") || "local";
const ME        = Q.get("username") || "anon";
const RETURN_ROUTE = "/game/mountonline.html";

/* ================= Canvas, camera, helpers ================= */
const cv = document.getElementById("cv");
const ctx = cv.getContext("2d", { alpha:false });

const TILE=48, GRID_W=92, GRID_H=48;
const WORLD = { w: GRID_W*TILE, h: GRID_H*TILE };
const cam={ x: WORLD.w/2 - cv.width/2, y: WORLD.h/2 - cv.height/2, speed:1400 };
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function clampCam(){ cam.x=clamp(cam.x,0,WORLD.w-cv.width); cam.y=clamp(cam.y,0,WORLD.h-cv.height); }
function manh(ax,ay,bx,by){ return Math.abs(ax-bx)+Math.abs(ay-by); }
function cheby(ax,ay,bx,by){ return Math.max(Math.abs(ax-bx),Math.abs(ay-by)); }
const short = s => s.length>10 ? s.slice(0,10)+"‚Ä¶" : s;

/* Colors: Side 1 = BLUE, Side 2 = RED */
const SIDE_COLORS = ["#3b82f6", "#ef4444"];
let TEAM_COLOR_FOR = {};
function teamTint(owner){ return TEAM_COLOR_FOR[owner] || "#9aa6b2"; }

/* ================= Troop stats ================= */
const TYPES = {
  recruit:        { name:"Recruit",        emoji:"üßë‚Äçüåæ", hp:50,  dmg:5,  range:1, atkSpd:1.0, move:180, armor:0, abilities:[] },
  footman:        { name:"Footman",        emoji:"üõ°Ô∏è",  hp:85,  dmg:7,  range:1, atkSpd:1.0, move:175, armor:2, abilities:[{slot:1,key:"Q",id:"brace",label:"Brace",target:"self",cd:10,dur:4}] },
  swordsman:      { name:"Swordsman",      emoji:"üó°Ô∏è",  hp:100, dmg:10, range:1, atkSpd:1.0, move:170, armor:4, abilities:[{slot:1,key:"Q",id:"shieldwall",label:"Shield Wall",target:"self",cd:12,dur:5}] },
  cavalry:        { name:"Cavalry",        emoji:"üêé",  hp:115, dmg:12, range:1, atkSpd:0.9, move:300, armor:2, abilities:[{slot:1,key:"Q",id:"charge",label:"Charge",target:"pointOrUnit",cd:6}] },
  archer:         { name:"Archer",         emoji:"üèπ",  hp:60,  dmg:7,  range:4, atkSpd:0.9, move:185, armor:1,
                    abilities:[{slot:1,key:"Q",id:"volley",label:"Volley",target:"point",cd:14,size:3,channel:6000}] },
  crossbowman:    { name:"Crossbowman",    emoji:"üèπ",  hp:66,  dmg:12, range:4, atkSpd:0.7, move:180, armor:1,
                    abilities:[{slot:1,key:"Q",id:"pierceBolt",label:"Piercing Bolt",target:"pointOrUnit",cd:8, dmg:28, ap:0.65, rangeTiles:10, speedTiles:10}] },
  veteranArcher:  { name:"Veteran Archer", emoji:"üèπ",  hp:64,  dmg:9,  range:5, atkSpd:1.1, move:185, armor:1,
                    abilities:[{slot:1,key:"Q",id:"volley",label:"Volley+",target:"point",cd:12,size:3,channel:6000}] },
  monk:           { name:"Monk",           emoji:"üßò",  hp:68,  dmg:6,  range:1, atkSpd:0.9, move:180, armor:1, abilities:[{slot:1,key:"Q",id:"focus",label:"Focus (+dmg)",target:"self",cd:12,dur:5, dmgUp:3}] },
  priest:         { name:"Priest",         emoji:"‚úùÔ∏è",  hp:70,  dmg:3,  range:2, atkSpd:0.7, move:180, armor:1, abilities:[{slot:1,key:"Q",id:"mend",label:"Mend (HoT)",target:"self",cd:10,dur:5, healPerSec:8}] },
  mage:           { name:"Mage",           emoji:"üîÆ",  hp:56,  dmg:14, range:3, atkSpd:0.7, move:185, armor:0, abilities:[
                    {slot:1,key:"Q",id:"fireburst",label:"Fireburst",target:"point",cd:12,size:2, dmg:20},
                    {slot:2,key:"W",id:"arcaneBolt",label:"Arcane Bolt",target:"pointOrUnit",cd:7,dmg:34, ap:0.5, rangeTiles:10, speedTiles:10}
                   ] }
};

/* Tiers (rewards) */
const TIER = { recruit:1, footman:2, archer:2, monk:2, swordsman:3, cavalry:3, crossbowman:3, veteranArcher:3, priest:3, mage:3 };
const REWARD = { 1:2, 2:5, 3:8 };

/* ================= Banners ‚Üí owner modifiers ================= */
function bannerMods(equipped=[]){
  const m = { melee:1, ranged:1, speed:1, armorMul:1, magic:1, cavDmg:1, priestHeal:1, footmanHp:1 };
  for(const b of equipped){
    const eff=(b.effect||"").toLowerCase();
    if(eff.includes("melee")) m.melee *= 1.10;
    if(eff.includes("speed")) m.speed *= 1.08;
    if(eff.includes("armor")) m.armorMul *= 1.15;
    if(eff.includes("ranged")) m.ranged *= 1.12;
    if(eff.includes("spell")) m.magic  *= 1.06;
    if(eff.includes("cavalry")) m.cavDmg *= 1.09;
    if(eff.includes("priest heal")) m.priestHeal *= 1.08;
    if(eff.includes("footman hp")) m.footmanHp *= 1.10;
  }
  return m;
}

/* ================= Networking collections ================= */
const battleRef = doc(db,"mountonline_battles", BATTLE_ID);
const gameRef   = doc(db,"games", BATTLE_ID, "meta", "state");
const snapsCol  = collection(db,"games", BATTLE_ID, "snaps");
const intentsCol= collection(db,"games", BATTLE_ID, "intents");

/* ================= Input / selection ================= */
const mouse={x:0,y:0,worldX:0,worldY:0,inside:false, inViewport:false};
const viewEl=document.querySelector(".view");
function rect(el){ return el.getBoundingClientRect(); }
function rel(el,e){ const r=el.getBoundingClientRect(); return { x:e.clientX-r.left, y:e.clientY-r.top, w:r.width, h:r.height }; }
function worldToGrid(wx,wy){ return { gx: clamp(Math.floor(wx/TILE),0,GRID_W-1), gy: clamp(Math.floor(wy/TILE),0,GRID_H-1) }; }

let dragging=false, dragStart=null, selection=new Set(), targeting=null;
const localFX=[];

/* ================= Game state (hosted) ================= */
let isHost=false, state=null, snapBuf=[], hostClockOffset=0;
let participants=[]; // [p1, p2]
let ownerMods = {};

const MKEY = { // mountonline -> type ids
  recruits:"recruit", footmen:"footman", swordsmen:"swordsman", cavalry:"cavalry",
  archers:"archer", crossbowmen:"crossbowman", veteranArchers:"veteranArcher",
  monks:"monk", priests:"priest", mages:"mage"
};

/* ================= Armies from Firestore ================= */
async function loadArmiesAndSeedIfHost(){
  const b = await getDoc(battleRef); if(!b.exists()){ alert("Battle not found"); return false; }
  const d = b.data();
  participants = (d.participants || []).slice(0,2);

  // Side colors
  if (participants.length >= 2) {
    TEAM_COLOR_FOR[participants[0]] = SIDE_COLORS[0]; // Blue
    TEAM_COLOR_FOR[participants[1]] = SIDE_COLORS[1]; // Red
  }

  isHost = (participants[0] === ME);
  updateDoc(doc(db,"mountonline", ME), { active:false, inBattle:true }).catch(()=>{});

  const [p1Snap, p2Snap] = await Promise.all([
    getDoc(doc(db,"mountonline", participants[0])),
    getDoc(doc(db,"mountonline", participants[1]))
  ]);
  if (!p1Snap.exists() || !p2Snap.exists()){ alert("Player docs missing"); return false; }
  const P1 = p1Snap.data(), P2 = p2Snap.data();

  ownerMods[participants[0]] = bannerMods((P1.inventory?.equipped)||[]);
  ownerMods[participants[1]] = bannerMods((P2.inventory?.equipped)||[]);

  if(!isHost) return true;

  const units=[];
  spawnArmyBlock(units, participants[0], P1.army||{}, "left");
  spawnArmyBlock(units, participants[1], P2.army||{}, "right");

  await setDoc(gameRef, {
    startedAt: Date.now(), winner:null,
    map:{ w:WORLD.w, h:WORLD.h, tile:TILE, gridW:GRID_W, gridH:GRID_H },
    players: participants, units, effects:[], projs:[],
    stats: {
      [participants[0]]: { killsByType:{}, lostByType:{} },
      [participants[1]]: { killsByType:{}, lostByType:{} }
    }
  }, { merge:false });

  return true;
}

/* Compact block spawns per side */
function spawnArmyBlock(units, owner, armyCounts, side){
  const pool=[];
  for(const [k,v] of Object.entries(armyCounts||{})){
    const n = Math.max(0, parseInt(v||0,10));
    const typeId = MKEY[k]; if(!typeId) continue;
    for(let i=0;i<n;i++) pool.push(typeId);
  }
  if(!pool.length) return;
  // shuffle
  for(let i=pool.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [pool[i],pool[j]]=[pool[j],pool[i]]; }

  const mid = Math.floor(GRID_W/2);
  const padX = 3, padY = 2;
  const minX = side==="left" ? 2 : mid+padX;
  const maxX = side==="left" ? mid-padX : GRID_W-3;
  const safeW = Math.max(4, maxX - minX + 1);

  const perRow = Math.min(12, safeW);
  const rows   = Math.ceil(pool.length / perRow);
  const startX = side==="left" ? minX : (maxX - perRow + 1);
  const startY = clamp(Math.floor(GRID_H/2) - Math.floor(rows/2), padY, GRID_H - rows - padY);

  for(let i=0;i<pool.length;i++){
    const gx = startX + (i % perRow);
    const gy = startY + Math.floor(i / perRow);
    units.push(mkUnit(pool[i], owner, clamp(gx,0,GRID_W-1), clamp(gy,0,GRID_H-1)));
  }
}

/* ================= Unit creation ================= */
function mkUnit(type, owner, gx, gy){
  const base=TYPES[type];
  const mod=ownerMods[owner]||bannerMods([]);
  const isRanged = base.range>1;
  const dmgMul = (isRanged?mod.ranged:mod.melee) * (type==="cavalry"?mod.cavDmg:1) * (type==="mage"?mod.magic:1);
  const moveMul= mod.speed;
  const armorMul= mod.armorMul;
  const hpMul = (type==="footman"?mod.footmanHp:1);
  return {
    id: owner.slice(0,2).toUpperCase() + "-" + Math.random().toString(36).slice(2,7),
    tt:type, o:owner,
    gx, gy,
    hp: Math.round(base.hp * hpMul), maxHp: Math.round(base.hp * hpMul),
    dmg: Math.round(base.dmg * dmgMul),
    range: base.range, atkSpd: base.atkSpd, move: Math.round(base.move * moveMul),
    armor: Math.round(base.armor * armorMul),
    // brain/state (match the smooth SP movement brain)
    acd:{}, _aura:null, _channel:null, _charge:null, _hold:false,
    _order:null, _goal:null, nextStepAt:0, _atkCd:0,
    targetId:null, stuck:0, _lastDist:null, _lastBy:null
  };
}

/* ================= Host loop & snapshots ================= */
function compactUnits(units){
  return units.map(u=>({
    id:u.id, tt:u.tt, o:u.o, gx:u.gx, gy:u.gy, hp:Math.round(u.hp)
  }));
}

async function hostLoop(){
  const s=await getDoc(gameRef); if(!s.exists()) return;
  let g = s.data();
  g.projs = g.projs || [];
  let last = performance.now(), acc=0;
  const FIXED=1/20, PUB_MS=120, META_MS=250;
  let lastPub=performance.now(), lastMeta=performance.now();

  async function consumeIntents(){
    const qs = await getDocs(query(intentsCol, orderBy("ts","asc"), limit(200)));
    if(!qs.size) return;
    const intents = qs.docs.map(d=>({id:d.id, ...d.data()}));
    g = applyIntents(g, intents);
    for(const d of qs.docs) await deleteDoc(d.ref);
  }

  async function publishSnapshot(){
    await addDoc(snapsCol, { ts:Date.now(), units: compactUnits(g.units), projs: (g.projs||[]).map(p=>({...p})) });
    const keep = await getDocs(query(snapsCol, orderBy("ts","desc"), limit(10)));
    const extras = keep.docs.slice(8);
    for(const d of extras) await deleteDoc(d.ref);
  }
  async function publishMeta(){
    await setDoc(gameRef, { startedAt:g.startedAt, winner:g.winner, map:g.map, players:g.players, effects:g.effects||[], stats:g.stats||{} }, { merge:true });
  }

  async function settleAndExit(){
    const stats = g.stats || {};
    const owners = g.players || participants;
    for(const owner of owners){
      const lost = stats[owner]?.lostByType || {};
      const kills = stats[owner]?.killsByType || {};
      await runTransaction(db, async (tx)=>{
        const pref = doc(db,"mountonline", owner);
        const snap = await tx.get(pref); if(!snap.exists()) return;
        const me = snap.data();
        const army = {...(me.army||{})};
        for(const [tLost, nLost] of Object.entries(lost)){
          const mKey = Object.keys(MKEY).find(k=>MKEY[k]===tLost);
          if(!mKey) continue;
          const remove = Math.floor((nLost||0)/3);
          if(remove > 0) army[mKey] = Math.max(0, (army[mKey]||0) - remove);
        }
        let goldGain=0;
        for(const [tKill, nKill] of Object.entries(kills)){
          const tier = TIER[tKill] || 1;
          goldGain += (REWARD[tier]||0) * (nKill||0);
        }
        tx.update(pref, { army, gold: (me.gold||0) + goldGain, active:true, inBattle:false, battleId:null, lastSeen: Date.now() });
      });
    }
    try{ await deleteDoc(battleRef); }catch(e){}
    location.href = `${RETURN_ROUTE}?username=${encodeURIComponent(ME)}`;
  }

  if (window.__MB_ONLINE_BATTLE_HOST__) return;
  window.__MB_ONLINE_BATTLE_HOST__=true;

  async function step(){
    const now=performance.now();
    acc += Math.min(0.25,(now-last)/1000); last=now;

    await consumeIntents();
    while(acc>=FIXED){
      g = simulate(g, FIXED);
      acc -= FIXED;
    }

    if(now-lastPub>=PUB_MS){ await publishSnapshot(); lastPub=now; }
    if(now-lastMeta>=META_MS){ await publishMeta(); lastMeta=now; }

    // Winner?
    const aliveBy = countByOwner(g.units);
    const ownersAlive = Object.keys(aliveBy).filter(o=>aliveBy[o]>0);
    if(!g.winner && ownersAlive.length===1){
      g.winner = ownersAlive[0]; await publishMeta();
      setTimeout(settleAndExit, 1200);
      return;
    }
    requestAnimationFrame(step);
  }
  step();
}

/* ================= Intents & abilities ================= */
async function pushIntent(kind,payload){ await addDoc(intentsCol,{ ts:Date.now(), user:ME, kind, payload }); }
function slotAbilityOnUnit(u, slot){ return (TYPES[u.tt].abilities||[]).find(a=>a.slot===slot); }

async function castSlot(slot){
  const units=getUnitsView().filter(u=>selection.has(u.id));
  if(!units.length) return;

  const readyIds = units.filter(u=>{
    const ab=slotAbilityOnUnit(u,slot);
    return ab && (u.acd?.[slot]||0)<=0 && !u._channel;
  }).map(u=>u.id);

  if(!readyIds.length){ flash("‚è≥ No selected unit ready for this ability"); return; }

  const first = units.find(u=>readyIds.includes(u.id));
  const ab = slotAbilityOnUnit(first, slot);
  if(!ab){ flash("No ability on this slot for selection"); return; }

  if(ab.target==="self"){
    await pushIntent("ability",{slot,ids:readyIds,mode:"self"});
    fxRingOnSelection();
  }else{
    targeting={slot,ab,ids:readyIds};
    showHint(`üéØ ${ab.label}: click a tile (Esc cancel)`);
    const once=(e)=>{
      if(e.button!==0){ cv.removeEventListener("click", once); hideHint(); targeting=null; return;}
      const {gx,gy}=worldToGrid(mouse.worldX,mouse.worldY);
      pushIntent("ability",{slot,ids:readyIds,mode:(ab.target==="pointOrUnit"?"point":"point"), gx,gy});
      fxTile(gx,gy); hideHint(); targeting=null;
      cv.removeEventListener("click", once);
    };
    cv.addEventListener("click", once);
  }
}

function updateCooldownBadges(){
  const abil=document.getElementById("abilities"); if(!abil) return;
  const sel = getUnitsView().filter(u=>selection.has(u.id));
  for(let s=1;s<=4;s++){
    const el=abil.querySelector(`[data-slot="${s}"]`); if(!el) continue;
    let times=[]; let hasAny=false;
    for(const u of sel){
      const ab=slotAbilityOnUnit(u,s);
      if(ab){ hasAny=true; times.push(Math.max(0, u.acd?.[s]||0)); }
    }
    const allCd = hasAny && times.every(t=>t>0);
    const minRem = hasAny ? Math.min(...times) : 0;
    el.classList.toggle("oncd", allCd);
    let badge=el.querySelector(".cd-badge");
    if(hasAny && minRem>0){
      if(!badge){ badge=document.createElement("div"); badge.className="cd-badge"; el.appendChild(badge); }
      badge.textContent = `${Math.ceil(minRem)}s`;
    }else if(badge){ badge.remove(); }
  }
}
setInterval(updateCooldownBadges, 250);

const AbilityHandlers={
  brace:      { cast(g,u,ab,{mode},now){ if(mode!=="self")return false; u._aura={kind:"brace", until:now+ab.dur*1000}; return true; } },
  shieldwall: { cast(g,u,ab,{mode},now){ if(mode!=="self")return false; u._aura={kind:"shield",until:now+ab.dur*1000}; return true; } },
  focus:      { cast(g,u,ab,{mode},now){ if(mode!=="self")return false; u._aura={kind:"focus", until:now+ab.dur*1000, dmgUp:(ab.dmgUp||3)}; return true; } },
  mend:       { cast(g,u,ab,{mode},now){ if(mode!=="self")return false; u._aura={kind:"mend",  until:now+ab.dur*1000, healPerSec:(ab.healPerSec||8) * (u.priestHealMul||1)}; return true; } },

  volley: { cast(g,u,ab,{mode,gx,gy},now){
    if(mode!=="point")return false;
    const size=ab.size||3; const until=now+(ab.channel||6000);
    u._channel={kind:"volley",until};
    (g.effects=g.effects||[]).push({ type:"squarePulse", who:u.o, xgx:gx, xgy:gy, size,
      pulses:[now+1000,now+3000,now+5000], next:0, until, color:"#aef", dmg:3, pierce:0, whoOwner:u.o });
    return true;
  }},
  fireburst: { cast(g,u,ab,{mode,gx,gy},now){
    if(mode!=="point")return false;
    (g.effects=g.effects||[]).push({ type:"squareOnce", who:u.o, xgx:gx, xgy:gy, size:ab.size||2,
      when:now+120, did:false, until:now+600, color:"#f88", dmg:(ab.dmg||20)*(ownerMods[u.o]?.magic||1), pierce:0.2, whoOwner:u.o });
    return true;
  }},
  arcaneBolt: { cast(g,u,ab,{mode,gx,gy},now){
    const range=ab.rangeTiles||10, speed=ab.speedTiles||10, dmg=(ab.dmg||34)*(ownerMods[u.o]?.magic||1), ap=ab.ap??0.5;
    const path=bresenham(u.gx,u.gy,gx,gy).slice(1, range+1);
    (g.projs=g.projs||[]).push({ type:"bolt", who:u.o, path, idx:0, speedTiles:speed, nextHopAt:Date.now(), hopMs:Math.max(40,Math.floor(1000/speed)), dmg, ap, color:"#baf" });
    return true;
  }},
  pierceBolt: { cast(g,u,ab,{mode,gx,gy},now){
    const range=ab.rangeTiles||10, speed=ab.speedTiles||10, dmg=(ab.dmg||28)*(ownerMods[u.o]?.ranged||1), ap=ab.ap??0.65;
    const path=bresenham(u.gx,u.gy,gx,gy).slice(1, range+1);
    (g.projs=g.projs||[]).push({ type:"bolt", who:u.o, path, idx:0, speedTiles:speed, nextHopAt:Date.now(), hopMs:Math.max(40,Math.floor(1000/speed)), dmg, ap, color:"#cde" });
    return true;
  }},
  charge: { cast(g,u,ab,{mode,gx,gy},now){
    const path=bresenham(u.gx,u.gy,gx,gy).slice(1,6);
    u._charge = { path, idx:0, until:now+2500 };
    return true;
  }},
};

function bresenham(x0,y0,x1,y1){
  const pts=[]; let dx=Math.abs(x1-x0), sx=x0<x1?1:-1; let dy=-Math.abs(y1-y0), sy=y0<y1?1:-1; let err=dx+dy, x=x0,y=y0;
  while(true){ pts.push({gx:x,gy:y}); if(x===x1&&y===y1) break; const e2=2*err; if(e2>=dy){ err+=dy; x+=sx; } if(e2<=dx){ err+=dx; y+=sy; } }
  return pts;
}

/* ================= Apply intents (NOW with forced move like SP) ================= */
function applyIntents(g,intents){
  const byId=new Map(g.units.map(u=>[u.id,u]));
  for(const it of intents){
    const {kind,user,payload}=it;

    if(kind==="hold"){
      const {ids,toggle,enabled}=payload;
      for(const id of ids){
        const u=byId.get(id); if(!u||u.o!==user) continue;
        u._hold = toggle ? !u._hold : !!enabled;
        if(u._hold){ u._order=null; u._goal=null; u.targetId=null; }
      }
    }

    if(kind==="order"){
      if(payload.type==="move"){ // forced or gentle move
        const {ids,gx,gy,forced}=payload;
        for(const id of ids){
          const u=byId.get(id); if(!u||u.o!==user) continue;
          u._order={kind:"move",gx,gy,forced:!!forced};
          u.targetId=null; u._goal=null; u.stuck=0; u._lastDist=null;
        }
      }
      if(payload.type==="attack"){ // explicit attack THIS unit
        const {ids,targetId}=payload;
        for(const id of ids){
          const u=byId.get(id); if(!u||u.o!==user) continue;
          u._order={kind:"attack", targetId};
          u.targetId=targetId; u._goal=null; u.stuck=0; u._lastDist=null;
        }
      }
      // Back-compat: "attackMove" behaves like gentle move
      if(payload.type==="attackMove"){
        const {ids,gx,gy}=payload;
        for(const id of ids){
          const u=byId.get(id); if(!u||u.o!==user) continue;
          u._order={kind:"move",gx,gy,forced:false};
          u.targetId=null;
        }
      }
    }

    if(kind==="orderNearest"){ // A key ‚Üí explicit attack nearest
      const {ids}=payload;
      for(const id of ids){
        const u=byId.get(id); if(!u||u.o!==user) continue;
        let best=null,bd=1e9;
        for(const v of g.units){ if(v.o===u.o) continue; const d=manh(u.gx,u.gy,v.gx,v.gy); if(d<bd){bd=d; best=v;} }
        if(best){
          u._order={kind:"attack", targetId:best.id};
          u.targetId=best.id; u._goal=null; u.stuck=0; u._lastDist=null;
        }
      }
    }

    if(kind==="ability"){
      const {slot,ids,mode,gx,gy}=payload;
      for(const id of ids){
        const u=byId.get(id); if(!u||u.o!==user) continue;
        if(u._channel) continue;
        const ab=(TYPES[u.tt].abilities||[]).find(a=>a.slot===slot); if(!ab) continue;
        if(u.acd?.[slot]>0) continue;
        const ok=AbilityHandlers[ab.id]?.cast(g,u,ab,{mode,gx,gy},Date.now());
        if(ok){ u.acd[slot]=ab.cd; }
      }
    }
  }
  return g;
}


/* ================= Movement brain (same style as SP) ================= */
const PX2SQUARES = 1 / (TILE*0.9);
const AGGRO_PVP  = 8; // long aggro, but overridden by forced move

function occupancy(units){ const m=new Map(); for(const u of units){ const k=u.gx+"|"+u.gy; if(!m.has(k)) m.set(k,[]); m.get(k).push(u);} return m; }
function unitMap(units){ const m=new Map(); for(const u of units) m.set(u.id,u); return m; }
function inRange(u, v){ const r=u.range||1; return (r>1) ? (cheby(u.gx,u.gy,v.gx,v.gy) <= r) : (manh(u.gx,u.gy,v.gx,v.gy) <= 1); }
function findNearestEnemy(u, list){ let best=null, bd=1e9; for(const v of list){ if(v.o===u.o) continue; const d=manh(u.gx,u.gy,v.gx,v.gy); if(d<bd){ bd=d; best=v; } } return best; }

/* choose an attack ring tile; prefer free, nearest */
function desiredEngageTile(u, t, occ){
  const r=u.range||1, cand=[];
  for(let dx=-r; dx<=r; dx++){
    for(let dy=-r; dy<=r; dy++){
      if(Math.max(Math.abs(dx),Math.abs(dy))>r) continue;
      if(dx===0 && dy===0) continue;
      const gx=t.gx+dx, gy=t.gy+dy;
      if(gx<0||gx>=GRID_W||gy<0||gy>=GRID_H) continue;
      cand.push({gx,gy});
    }
  }
  const free = cand.filter(c => !occ.has(c.gx+"|"+c.gy));
  const list = free.length?free:cand;
  list.sort((a,b)=> manh(u.gx,u.gy,a.gx,a.gy) - manh(u.gx,u.gy,b.gx,b.gy));
  return list[0] || {gx:t.gx,gy:t.gy};
}

/* step options biased toward goal with mild sidesteps */
function neighborChoices(u, gx, gy){
  const sx = Math.sign(gx - u.gx), sy = Math.sign(gy - u.gy);
  const cand = [
    {gx:u.gx+sx, gy:u.gy},           // forward X
    {gx:u.gx,    gy:u.gy+sy},        // forward Y
    {gx:u.gx+sx, gy:u.gy+sy},        // diag
    {gx:u.gx+sx, gy:u.gy-sy},        // sidestep 1
    {gx:u.gx-sx, gy:u.gy+sy},        // sidestep 2
  ];
  const seen=new Set(), out=[];
  for(const c of cand){ const k=c.gx+"|"+c.gy; if(seen.has(k)) continue; seen.add(k); out.push(c); }
  out.sort((a,b)=> manh(a.gx,a.gy,gx,gy) - manh(b.gx,b.gy,gx,gy));
  return out;
}

function tryStepToward(u,gx,gy,occ,reserved){
  if(gx===u.gx && gy===u.gy) return false;
  const cand = neighborChoices(u,gx,gy);
  for(const c of cand){
    if(c.gx<0||c.gx>=GRID_W||c.gy<0||c.gy>=GRID_H) continue;
    const k=c.gx+"|"+c.gy;
    if(!occ.get(k) && !reserved.has(k)){
      const fromK=u.gx+"|"+u.gy; const list=occ.get(fromK)||[]; const i=list.indexOf(u);
      if(i>=0){ list.splice(i,1); if(!list.length) occ.delete(fromK); }
      u.gx=c.gx; u.gy=c.gy;
      (occ.get(k)||occ.set(k,[]).get(k)).push(u); reserved.add(k);
      return true;
    }
  }
  return false;
}

/* ================= Simulation ================= */
function simulate(g, dt){
  const now = Date.now();

  // cooldowns/auras
  for(const u of g.units){
    for(const k in (u.acd||{})) u.acd[k] = Math.max(0, u.acd[k]-dt);
    if(u._aura && u._aura.until<=now) u._aura=null;
    if(u._aura?.kind==="mend") u.hp=Math.min(u.maxHp, u.hp+(u._aura.healPerSec||8)*dt);
    if(u._channel && u._channel.until<=now) u._channel=null;
  }
  g.effects=(g.effects||[]).filter(e=>e.until?e.until>now:true);

  // projectiles
  const keep=[]; 
  for(const pr of (g.projs||[])){
    if(pr.type==="bolt"){
      if(now>=pr.nextHopAt){
        const hops=1+Math.floor((now-pr.nextHopAt)/pr.hopMs);
        pr.nextHopAt+=hops*pr.hopMs;
        pr.idx=Math.min(pr.idx+hops, pr.path.length-1);
      }
      const tile=pr.path[pr.idx]||pr.path[pr.path.length-1];
      let hit=null; 
      for(const u of g.units){ if(u.o===pr.who) continue; if(u.gx===tile.gx&&u.gy===tile.gy){hit=u;break;} }
      if(hit){ applyDamage(hit, pr.dmg, pr.ap||0.5, pr.who); continue; }
      if(pr.idx<pr.path.length-1) keep.push(pr);
    } else keep.push(pr);
  }
  g.projs=keep;

  // effects (AOE pulses)
  for(const e of (g.effects||[])){
    if(e.type==="squarePulse"){
      while(e.next<e.pulses.length && now>=e.pulses[e.next]){ pulseSquare(g,e.xgx,e.xgy,e.size,e.who,e.dmg,e.pierce||0); e.next++; }
    }
    if(e.type==="squareOnce"){
      if(!e.did && now>=e.when){ pulseSquare(g,e.xgx,e.xgy,e.size,e.who,e.dmg,e.pierce||0); e.did=true; }
    }
  }

  const byId = unitMap(g.units);
  const occ  = occupancy(g.units);

  for(const u of g.units){
    if(u._channel) continue;

    // Snapshot order safely (prevents null reads after we clear it)
    const o = u._order || null;
    const forcedMove     = !!(o && o.kind==="move"   && o.forced===true);
    const atkTargetId    =  (o && o.kind==="attack") ? o.targetId : null;
    const hasExplicitAtk = !!atkTargetId;

    // Clear invalid explicit attack (don‚Äôt crash or chase friendlies)
    if(hasExplicitAtk){
      const t = byId.get(atkTargetId);
      if(!t || t.o===u.o){ u._order=null; u.targetId=null; }
    }

    if(u._hold){
      // HOLD: never walk; can still fight if something stands in range
      const t = hasExplicitAtk ? byId.get(atkTargetId) : (u.targetId ? byId.get(u.targetId) : null);
      if(t && inRange(u,t)){ u.state="fight"; } else { u.state="hold"; }
      continue;
    }

    // Passive aggro only when not forced-moving and not explicitly attacking
    if(!forcedMove && !hasExplicitAtk){
      if(u.targetId){
        const t = byId.get(u.targetId);
        if(!t || t.o===u.o) u.targetId=null;
      }
      if(!u.targetId){
        const near = findNearestEnemy(u, g.units);
        if(near && manh(u.gx,u.gy,near.gx,near.gy) <= AGGRO_PVP){
          u.targetId = near.id;
        }
      }
    }

    // Decide state + goals
    let t=null;
    if(hasExplicitAtk){
      t = byId.get(atkTargetId) || null;
      if(t){
        if(inRange(u,t)){ u.state="fight"; u._goal=null; }
        else{ u.state="chase"; const want=desiredEngageTile(u,t,occ); u._goal={gx:want.gx,gy:want.gy}; }
      }else{
        u.state="idle"; u._goal=null; u._order=null; u.targetId=null;
      }
    } else if(forcedMove){
      u.state="move"; u._goal={gx:o.gx, gy:o.gy}; // no aggro while moving forced
    } else {
      t = u.targetId ? byId.get(u.targetId) : null;
      if(t && inRange(u,t)){ u.state="fight"; u._goal=null; }
      else if(t && manh(u.gx,u.gy,t.gx,t.gy) <= AGGRO_PVP){
        u.state="chase"; const want=desiredEngageTile(u,t,occ); u._goal={gx:want.gx,gy:want.gy};
      } else if(o && o.kind==="move"){ u.state="move"; u._goal={gx:o.gx, gy:o.gy}; }
      else { u.state="idle"; u._goal=null; }
    }
  }

  // Move & attack step
  const reserved = new Set();
  for(const u of g.units){
    if(u._channel) continue;

    // Attack on cooldowns
    if(u.state==="fight"){
      const o = u._order || null;
      const atkTargetId = (o && o.kind==="attack") ? o.targetId : null;
      const t = atkTargetId ? byId.get(atkTargetId) : (u.targetId ? byId.get(u.targetId) : null);
      if(t && inRange(u,t)){
        u._atkCd -= dt;
        if(u._atkCd<=0){
          const dmg=(u.dmg||5)+(u._aura?.dmgUp||0);
          applyDamage(t, dmg, 0, u.o);
          u._atkCd = Math.max(.05, 1/(u.atkSpd||1));
        }
      }
      continue;
    }

    // Charge dash (unchanged)
    if(u._charge && u._charge.until>now){
      const step=u._charge.path[u._charge.idx];
      if(step){
        const key=step.gx+"|"+step.gy;
        if(!occ.get(key) && !reserved.has(key)){ stepTo(u, step.gx, step.gy, occ, reserved); u._charge.idx++; }
        else { u._charge.until = now; }
      } else { u._charge.until=now; }
      if(!u._charge || u._charge.idx>=(u._charge.path?.length||0)){
        for(const v of g.units){ if(v.o===u.o) continue; if(manh(u.gx,u.gy,v.gx,v.gy)<=1){ applyDamage(v, 14, 0, u.o); } }
      }
      continue;
    }

    // Movement / chase with ‚Äústuck‚Äù logic & close-enough arrival for forced move
    if((u.state==="move"||u.state==="chase") && u._goal && !u._hold){
      const speedSquares=Math.max(0.5,(u.move||180)*PX2SQUARES*(u._aura?.kind==="brace"?0.75:1));
      const everyMs=Math.max(80,Math.floor(1000/speedSquares));
      if(now>=u.nextStepAt){
        u.nextStepAt = now + everyMs;
        const {gx,gy}=u._goal;

        const before=manh(u.gx,u.gy,gx,gy);
        const moved = tryStepToward(u,gx,gy,occ,reserved);
        const after = manh(u.gx,u.gy,gx,gy);

        if(u._lastDist==null) u._lastDist=before;
        if(moved && after<before){ u.stuck=0; u._lastDist=after; }
        else if(!moved || after>=u._lastDist){ u.stuck++; }

        const o = u._order || null;
        const forced = !!(o && o.kind==="move" && o.forced===true);
        const closeEnough = forced && after<=1 && u.stuck>=6;

        if(after===0 || closeEnough){
          if(u.state==="move"){ u._order=null; } // from forced move ‚Üí back to aggro-available
          u._goal=null; u.stuck=0; u._lastDist=null;
        }

        // For passive chase, give up if stuck; for explicit attack, keep trying
        if(u.state==="chase" && u.stuck>=6){
          const atkTargetId = (o && o.kind==="attack") ? o.targetId : null;
          if(atkTargetId){ u._lastDist=null; u.stuck=0; } // persist on explicit attack
          else { u._goal=null; u.state="idle"; u.stuck=0; u._lastDist=null; }
        }
      }
    }
  }

  // deaths/stat keeping
  const survivors=[]; const deaths=[];
  for(const u of g.units){ if(u.hp>0) survivors.push(u); else deaths.push(u); }
  if(deaths.length){
    g.stats = g.stats || {};
    for(const o of (g.players||participants)){ if(!g.stats[o]) g.stats[o]={killsByType:{}, lostByType:{}}; }
    for(const dead of deaths){
      const killer = dead._lastBy;
      const victim = dead.o;
      g.stats[victim].lostByType[dead.tt] = (g.stats[victim].lostByType[dead.tt]||0)+1;
      if(killer){ g.stats[killer].killsByType[dead.tt] = (g.stats[killer].killsByType[dead.tt]||0)+1; }
    }
  }
  g.units = survivors;
  return g;
}


/* ================= Damage/AOE/Utils ================= */
function applyDamage(target, dmg, ap, owner){
  const baseArmor=(TYPES[target.tt].armor||0);
  const auraArmor = (target._aura?.kind==="shield"?3:0) + (target._aura?.kind==="brace"?2:0);
  const totalArmor = baseArmor + auraArmor;
  const effArmor = Math.max(0, totalArmor - totalArmor*(ap||0));
  target.hp -= Math.max(1, Math.round(dmg - effArmor));
  target._lastBy = owner;
}
function stepTo(u,gx,gy,occ,res){
  const fromK=u.gx+"|"+u.gy; const list=occ.get(fromK)||[]; const i=list.indexOf(u);
  if(i>=0){ list.splice(i,1); if(!list.length) occ.delete(fromK); }
  u.gx=gx; u.gy=gy; const toK=gx+"|"+gy; (occ.get(toK)||occ.set(toK,[]).get(toK)).push(u); res.add(toK);
}
function countByOwner(units){ const m={}; for(const u of units){ m[u.o]=(m[u.o]||0)+1; } return m; }
function pulseSquare(g,cx,cy,size,owner,dmg,pierce){
  const half=Math.floor(size/2);
  for(const v of g.units){
    if(v.o===owner) continue;
    if(Math.abs(v.gx-cx)<=half && Math.abs(v.gy-cy)<=half){
      applyDamage(v, dmg, pierce||0, owner);
    }
  }
}

/* ================= Input handlers ================= */
function flash(t){ const h=document.getElementById("hint"); h.textContent=t; h.style.display="block"; clearTimeout(flash._t); flash._t=setTimeout(()=>h.style.display="none",900); }
function showHint(t){ const h=document.getElementById("hint"); h.textContent=t; h.style.display="block"; }
function hideHint(){ document.getElementById("hint").style.display="none"; }
function fxRingOnSelection(){ for(const u of getUnitsView().filter(u=>selection.has(u.id))){ localFX.push({kind:"ring",gx:u.gx,gy:u.gy,color:"#9bf",until:Date.now()+550}); } }
function fxTile(gx,gy){ localFX.push({kind:"tile",gx,gy,color:"#aef",until:Date.now()+600}); }

window.addEventListener("mousemove",(e)=>{ const r=rect(viewEl); mouse.inViewport = e.clientX>=r.left && e.clientX<=r.right && e.clientY<=r.bottom && e.clientY>=r.top; });
cv.addEventListener("mousemove",(e)=>{ const r=rel(cv,e); mouse.inside=r.x>=0&&r.y>=0&&r.x<=r.w&&r.y<=r.h; mouse.x=r.x; mouse.y=r.y; mouse.worldX=cam.x+mouse.x; mouse.worldY=cam.y+mouse.y; });

cv.addEventListener("mousedown",(e)=>{
  if(e.button===2){ // RIGHT-CLICK
    e.preventDefault();
    const ids=Array.from(selection); if(!ids.length) return;

    // If we clicked an enemy tile, issue explicit ATTACK on that unit.
    const enemy = pickEnemyAt(mouse.worldX, mouse.worldY, ME);
    if(enemy){
      pushIntent("order",{type:"attack", ids, targetId: enemy.id});
      return;
    }

    // Otherwise: forced move to ground tile (no aggro while moving).
    const {gx,gy}=worldToGrid(mouse.worldX,mouse.worldY);
    pushIntent("order",{type:"move", ids, gx, gy, forced:true});
    return;
  }
  // Left button ‚Üí selection drag
  dragging=true; dragStart={x:mouse.x,y:mouse.y};
});

window.addEventListener("mouseup",(e)=>{
  if(!dragging) return; dragging=false;
  const dx=mouse.x-dragStart.x, dy=mouse.y-dragStart.y, tiny=Math.hypot(dx,dy)<6;
  if(tiny){
    const u = pickUnitAt(mouse.worldX,mouse.worldY, ME);
    if(u){ if(!e.shiftKey) selection.clear(); selection.add(u.id); renderHUD(); }
  }else{
    const minx=Math.min(dragStart.x,mouse.x)+cam.x, maxx=Math.max(dragStart.x,mouse.x)+cam.x;
    const miny=Math.min(dragStart.y,mouse.y)+cam.y, maxy=Math.max(dragStart.y,mouse.y)+cam.y;
    const ids = pickInRect(minx,miny,maxx,maxy, ME);
    if(!e.shiftKey) selection.clear();
    ids.forEach(id=>selection.add(id));
    renderHUD();
  }
});
cv.addEventListener("contextmenu", e=>e.preventDefault());
cv.addEventListener("dblclick",(e)=>{ const u = pickUnitAt(mouse.worldX,mouse.worldY, ME); if(!u) return; selection.clear(); for(const v of getUnitsView()){ if(v.o===ME && v.tt===u.tt) selection.add(v.id); } renderHUD(); });

window.addEventListener("keydown",(e)=>{
  const k=e.key.toLowerCase();
  if(k==="escape"){ targeting=null; hideHint(); }
  if(["q","w","e","r"].includes(k)){ e.preventDefault(); castSlot({q:1,w:2,e:3,r:4}[k]); }
  if(k==="a"){ e.preventDefault(); const ids=Array.from(selection); if(!ids.length) return; pushIntent("orderNearest",{ids}); }
  if(k==="h"){ e.preventDefault(); const ids=Array.from(selection); if(!ids.length) return; pushIntent("hold",{ids,toggle:true}); }
});

/* Picking */
function getUnitsView(){ return snapBuf.length ? (snapBuf[snapBuf.length-1].units||[]) : (state?.units||[]); }
function pickUnitAt(wx,wy, owner){
  const {gx,gy}=worldToGrid(wx,wy);
  const list=getUnitsView();
  for(const u of list){ if(owner && u.o!==owner) continue; if(u.gx===gx && u.gy===gy) return u; }
  return null;
}
  function pickEnemyAt(wx,wy,myOwner){
  const {gx,gy}=worldToGrid(wx,wy);
  const list=getUnitsView();
  for(const u of list){ if(u.o===myOwner) continue; if(u.gx===gx && u.gy===gy) return u; }
  return null;
}

function pickInRect(x0,y0,x1,y1,owner){
  const list=getUnitsView(), out=[]; const g0=worldToGrid(x0,y0), g1=worldToGrid(x1,y1);
  const minGX=Math.min(g0.gx,g1.gx), maxGX=Math.max(g0.gx,g1.gx), minGY=Math.min(g0.gy,g1.gy), maxGY=Math.max(g0.gy,g1.gy);
  for(const u of list){ if(owner && u.o!==owner) continue; if(u.gx>=minGX&&u.gx<=maxGX&&u.gy>=minGY&&u.gy<=maxGY) out.push(u.id); }
  return out;
}

/* ================= UI: HUD & board ================= */
function renderHUD(){
  const abil=document.getElementById("abilities"); const selInfo=document.getElementById("selInfo");
  const sel=getUnitsView().filter(u=>selection.has(u.id));
  selInfo.innerHTML = sel.length ? `${sel.length} unit(s) selected ‚Äî <strong>A</strong>: nearest ‚Ä¢ <strong>H</strong>: hold` : "Select units";

  const slotMap=new Map();
  for(const u of sel){ for(const a of (TYPES[u.tt].abilities||[])){ if(!slotMap.has(a.slot)) slotMap.set(a.slot,{ name:a.label, key:a.key, emoji:TYPES[u.tt].emoji }); } }
  const keys={1:"Q",2:"W",3:"E",4:"R"}; const abilEl=document.getElementById("abilities"); abilEl.innerHTML="";
  for(let s=1;s<=4;s++){
    const spec=slotMap.get(s);
    const div=document.createElement("div"); div.className="slot"; div.dataset.slot=String(s);
    div.innerHTML = spec ? `<div class="emoji">${spec.emoji}</div><div class="name">${spec.name}</div><span class="key">${keys[s]}</span>`
                         : `<div class="emoji">‚Äî</div><div class="name">‚Äî</div><span class="key">${keys[s]}</span>`;
    if(spec) div.onclick=()=>castSlot(s);
    abilEl.appendChild(div);
  }
  updateCooldownBadges();
}
function renderBoard(){
  const rows=document.getElementById("boardRows"); rows.innerHTML="";
  const counts={}; for(const u of getUnitsView()){ counts[u.o]=(counts[u.o]||0)+1; }
  const ents=Object.entries(counts).sort((a,b)=>b[1]-a[1]||a[0].localeCompare(b[0]));
  for(const [name,c] of ents){
    const d=document.createElement("div"); d.className="row";
    d.innerHTML=`<span style="color:${teamTint(name)}">${short(name)}</span><span>${c}</span>`;
    rows.appendChild(d);
  }
}

/* ================= Render loop ================= */
function roundedRectPath(ctx, x, y, w, h, r){
  const rr=Math.min(r,w/2,h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  ctx.closePath();
}

function draw(){
  const dt=16/1000;
  // edge pan
  if(mouse.inViewport){
    const mx=mouse.x, my=mouse.y; const marginX=60, marginTop=80, marginBot=160;
    if(mx<=marginX) cam.x -= cam.speed*dt;
    else if(mx>=cv.width-marginX) cam.x += cam.speed*dt;
    if(my<=marginTop) cam.y -= cam.speed*dt;
    else if(my>=cv.height-marginBot) cam.y += cam.speed*dt;
    clampCam();
  }

  ctx.fillStyle="#0d1020"; ctx.fillRect(0,0,cv.width,cv.height);
  // grid
  ctx.strokeStyle="rgba(255,255,255,.06)"; ctx.lineWidth=1;
  for(let x=-cam.x%(TILE*4); x<cv.width; x+=TILE*4){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cv.height); ctx.stroke(); }
  for(let y=-cam.y%(TILE*4); y<cv.height; y+=TILE*4){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cv.width,y); ctx.stroke(); }

  // effects
  const now=Date.now();
  const eff = state?.effects || [];
  for(const e of eff){
    const size=e.size||2, half=Math.floor(size/2);
    const sx=(e.xgx-half)*TILE - cam.x, sy=(e.xgy-half)*TILE - cam.y;
    ctx.save();
    ctx.globalAlpha=.18; ctx.fillStyle=e.color||"#fff"; ctx.fillRect(sx,sy,size*TILE,size*TILE);
    ctx.globalAlpha=1; ctx.lineWidth=2; ctx.strokeStyle=e.color||"#fff"; ctx.strokeRect(sx,sy,size*TILE,size*TILE);
    ctx.restore();
  }

  // projectiles
  const projs = snapBuf.length ? (snapBuf[snapBuf.length-1].projs||[]) : (state?.projs||[]);
  for(const p of projs){
    if(p.type==="bolt"){
      const step = p.path[Math.min(p.idx, p.path.length-1)] || p.path[p.path.length-1];
      const sx=step.gx*TILE - cam.x, sy=step.gy*TILE - cam.y;
      ctx.globalAlpha=.9; ctx.fillStyle=p.color||"#baf"; ctx.fillRect(sx+TILE*.25, sy+TILE*.25, TILE*.5, TILE*.5); ctx.globalAlpha=1;
    }
  }

  // units
  const list=getUnitsView();
  ctx.textAlign="center"; ctx.textBaseline="middle";
  for(const u of list){
    const team=teamTint(u.o);
    const sx=u.gx*TILE + TILE/2 - cam.x, sy=u.gy*TILE + TILE/2 - cam.y;
    const w=TILE*.96, h=TILE*.96, x0=sx-w/2, y0=sy-h/2;

    ctx.save(); ctx.shadowColor="rgba(0,0,0,.7)"; ctx.shadowBlur=14; ctx.shadowOffsetY=3;
    roundedRectPath(ctx,x0,y0,w,h,8); ctx.fillStyle="#fff"; ctx.fill(); ctx.restore();

    roundedRectPath(ctx,x0,y0,w,h,8); ctx.lineWidth=3; ctx.strokeStyle=team; ctx.stroke();
    ctx.fillStyle=team+"66"; roundedRectPath(ctx,x0+4,y0+4,w-8, Math.max(10,Math.floor(TILE*.18)), 6); ctx.fill();

    ctx.font="24px system-ui"; ctx.fillStyle="#0a0a0a"; ctx.fillText(TYPES[u.tt].emoji, sx, sy+2);

    if(selection.has(u.id)){ ctx.save(); ctx.shadowColor="#fff"; ctx.shadowBlur=14; roundedRectPath(ctx,x0,y0,w,h,8); ctx.lineWidth=2; ctx.strokeStyle="#fff"; ctx.stroke(); ctx.restore(); }

    // HP bar
    const hpFrac=Math.max(0,Math.min(1,u.hp / Math.max(1,(TYPES[u.tt].hp||1))));
    const barPad=8, barW=w-barPad*2, barH=6, barX=x0+barPad, barY=y0+h-barPad-barH;
    ctx.fillStyle="#e7e7e7"; roundedRectPath(ctx,barX,barY,barW,barH,3); ctx.fill();
    ctx.fillStyle = hpFrac>0.5? "#35d07f" : (hpFrac>0.25? "#ffd166" : "#ff6b6b");
    roundedRectPath(ctx,barX,barY,barW*hpFrac,barH,3); ctx.fill();
  }

  // local fx
  for(let i=localFX.length-1;i>=0;i--){
    const fx=localFX[i]; const rem=fx.until-Date.now(); if(rem<=0){ localFX.splice(i,1); continue; }
    const a=Math.max(0, Math.min(1, rem/600));
    if(fx.kind==="ring"){ const cx=fx.gx*TILE + TILE/2 - cam.x, cy=fx.gy*TILE + TILE/2 - cam.y; ctx.save(); ctx.globalAlpha=.2+.6*a; ctx.strokeStyle=fx.color||"#9bf"; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(cx,cy,TILE*.45*(1+0.15*(1-a)),0,Math.PI*2); ctx.stroke(); ctx.restore(); }
    if(fx.kind==="tile"){ const sx=fx.gx*TILE - cam.x, sy=fx.gy*TILE - cam.y; ctx.save(); ctx.globalAlpha=.15+.25*a; ctx.fillStyle=fx.color||"#aef"; ctx.fillRect(sx,sy,TILE,TILE); ctx.restore(); }
  }

  // drag box
  if(dragging){ const x=Math.min(dragStart.x,mouse.x), y=Math.min(dragStart.y,mouse.y), w=Math.abs(mouse.x-dragStart.x), h=Math.abs(mouse.y-dragStart.y); ctx.strokeStyle="#9bf"; ctx.lineWidth=1.5; ctx.strokeRect(x,y,w,h); }

  renderBoard(); updateCooldownBadges();
  requestAnimationFrame(draw);
}

/* ================= Snapshots (clients) ================= */
onSnapshot(gameRef,(snap)=>{ if(!snap.exists()) return; state=snap.data(); renderBoard(); maybeWinnerBanner(); });
onSnapshot(query(snapsCol, orderBy("ts","asc"), limit(32)), (qs)=>{
  snapBuf = qs.docs.map(d=>d.data());
  if(snapBuf.length){ const hostTs=snapBuf[snapBuf.length-1].ts; const drift=hostTs-Date.now(); hostClockOffset=hostClockOffset===0?drift:(hostClockOffset*0.9 + drift*0.1); }
});

/* Also watch the battle doc; when host deletes it after settlement, everyone returns home */
let __sentHome=false;
onSnapshot(battleRef,(snap)=>{
  if(!snap.exists() && !__sentHome){
    __sentHome=true;
    setTimeout(()=>{ location.href = `${RETURN_ROUTE}?username=${encodeURIComponent(ME)}`; }, 1200);
  }
});

/* ================= Winner banner ================= */
function maybeWinnerBanner(){
  if(!state?.winner) return;
  const b=document.getElementById("banner");
  b.textContent=`üèÜ ${state.winner} wins!`;
  b.style.display="block";
}

/* ================= Init ================= */
(async function init(){
  const ok = await loadArmiesAndSeedIfHost();
  if(!ok) return;

  if(isHost) hostLoop();

  cam.x = WORLD.w/2 - cv.width/2; cam.y = WORLD.h/2 - cv.height/2; clampCam();
  draw();
})();
</script>
</body>
</html>




