<!DOCTYPE html> 
<html lang="en">
<head>
<meta charset="utf-8" />
<title>MOBA ‚Äî Talents + Ally Bulwark + Clean UI + AI Level Timer</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --panel-w: 320px; --bg:#0f1116; --ink:#e7ecf2; --muted:#8ba0b3; --accent:#58a6ff;
    --good:#50e3a4; --bad:#ff6b6b; --warn:#ffd166; --grid:#171a22;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial,"Noto Sans";
    user-select:none; overflow:hidden}
  #wrap{display:grid;grid-template-columns:1fr var(--panel-w);height:100%}
  #canvas{display:block;background:#0c0f15}
  #panel{background:#0f131b;border-left:1px solid #1f2631;padding:12px 12px 96px 12px;overflow:auto}
  h2,h3{margin:10px 0 6px}
  .chip{background:#151a22;border:1px solid #283142;padding:6px 10px;border-radius:999px;
    display:inline-flex;gap:8px;align-items:center;font-weight:700;box-shadow:0 1px 0 #0008,inset 0 1px 0 #ffffff08}
  #hud{position:absolute;left:10px;right:calc(var(--panel-w) + 10px);top:10px;display:flex;gap:10px;pointer-events:none}
  .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;background:#0d1420;border:1px solid #2a3240;border-bottom-color:#1a2230;padding:0 6px;border-radius:6px;font-weight:700}
  #abilityBar{position:absolute;left:10px;right:calc(var(--panel-w) + 10px);bottom:10px;display:flex;gap:10px}
  .ab{background:#111725;border:1px solid #2a3240;border-radius:10px;padding:8px 10px;min-width:170px;cursor:default}
  .ab h4{margin:0 0 6px;font-size:14px}
  .cd{font-size:12px;color:var(--muted)}
  .locked{opacity:.55}
  .prog{height:6px;background:#0d1420;border:1px solid #2a3240;border-radius:8px;overflow:hidden;margin-top:6px}
  .progFill{height:100%;width:0%;background:linear-gradient(90deg,#ffd166,#ff9b66)}
  .btn{background:#162131;border:1px solid #2a3240;color:var(--ink);padding:8px 10px;border-radius:10px;font-weight:700;cursor:pointer;box-shadow:inset 0 -1px 0 #0008,0 1px 0 #0006}
  .btn:hover{filter:brightness(1.1)}
  #start{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:#0009;z-index:3}
  #card{background:#0f1218;border:1px solid #2a3240;border-radius:16px;padding:18px;width:min(560px,92vw);box-shadow:0 12px 50px #000a,inset 0 1px 0 #ffffff06}
  #fpsChip{position:absolute;top:10px;right:calc(var(--panel-w) + 10px)}
  #msg{position:absolute;top:48px;left:10px;color:#a9b6c6;font-size:13px}
  #banner{position:absolute;inset:0 calc(var(--panel-w) + 0px) auto 0;display:flex;align-items:center;justify-content:center;
    font-size:42px;font-weight:900;color:#ffffffdd;text-shadow:0 2px 20px #000;opacity:0;transition:opacity .4s}
  /* Move this helper line higher so it doesn't clash with ability bar */
  #corner{position:absolute;left:10px;bottom:120px;color:#a9b6c6;font-size:12px}

  /* XP bar ‚Äî lowered so it doesn't overlap HUD chips */
  #xpBarWrap{position:absolute;left:10px;right:calc(var(--panel-w) + 10px);top:76px;height:8px;background:#101420;border:1px solid #263043;border-radius:12px;overflow:hidden}
  #xpBar{height:100%;background:linear-gradient(90deg,#58a6ff,#8bd6ff)}

  /* Talent chooser */
  #talentOverlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:#0009;z-index:4}
  #talentBox{background:#0f1218;border:1px solid #2a3240;border-radius:16px;padding:18px;width:min(680px,95vw);box-shadow:0 12px 50px #000a}
  #talentBox h3{margin:0 0 10px}
  .talentRow{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .talent{background:#121827;border:1px solid #2a3240;border-radius:12px;padding:12px;display:flex;flex-direction:column;gap:6px}
  .talent small{color:#9fb2c7}
  .talent .pick{margin-top:6px}
  .hint{font-size:12px;color:#9fb2c7;margin:6px 0 0}
</style>
</head>
<body>
<div id="wrap">
  <div style="position:relative">
    <canvas id="canvas"></canvas>
    <div id="hud">
      <div class="chip">Stage <b id="stage">1</b></div>
      <div class="chip">Hero Lv <b id="hLevel">1</b> <span style="color:#8ba0b3;margin-left:6px">XP <span id="xp">0</span>/<span id="xpNeed">100</span></span></div>
      <div class="chip">Allies <b id="allyCount">0</b> | Enemies <b id="enemyCount">0</b></div>
      <div class="chip">Towers üóº <b id="twInfo">2 vs 2</b></div>
      <div class="chip">Core üí† HP <b id="myCoreHp">‚Äî</b> / <b id="enCoreHp">‚Äî</b></div>
    </div>
    <div id="xpBarWrap"><div id="xpBar" style="width:0%"></div></div>

    <div id="abilityBar">
      <div class="ab" id="abQ" title="Press Q">
        <h4>Q ‚Äî <span id="qName">‚Äî</span></h4>
        <div class="cd" id="qInfo">‚Äî</div>
        <div class="prog"><div class="progFill" id="qProg"></div></div>
      </div>
      <div class="ab" id="abW" title="Press W (click to choose when unlocked)">
        <h4>W ‚Äî <span id="wName">‚Äî</span></h4>
        <div class="cd" id="wInfo">Unlock at Lv4</div>
        <div class="prog"><div class="progFill" id="wProg"></div></div>
      </div>
      <div class="ab" id="abE" title="Press E (click to choose when unlocked)">
        <h4>E ‚Äî <span id="eName">‚Äî</span></h4>
        <div class="cd" id="eInfo">Unlock at Lv7</div>
        <div class="prog"><div class="progFill" id="eProg"></div></div>
      </div>
    </div>

    <div id="corner">Right-click ground: move (cancels target). Right-click <b>enemy</b>: hard-target & chase until in range. While moving, your hero <b>won‚Äôt shoot</b>. Q/W/E to aim/cast. <span class="kbd">Esc</span> cancels. Edge-pan horizontally.</div>
    <div id="msg"></div>
    <div id="banner">STAGE 1</div>

    <!-- Start hero picker -->
    <div id="start">
      <div id="card">
        <h2 style="margin:0 0 6px">Choose your Hero</h2>
        <div class="listy" style="color:#a9b6c6">Destroy the enemy üí† Core. Your kills grant full XP. Nearby team kills grant a small assist XP. Abilities unlock Lv2/Lv4/Lv7. At Lv4/Lv7, pick between two W/E talents.</div>
        <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;margin-top:12px">
          <button class="btn" id="pickHealer">üßë‚Äç‚öïÔ∏è Healer</button>
          <button class="btn" id="pickTank">üõ°Ô∏è Tank</button>
          <button class="btn" id="pickMage">üßô‚Äç‚ôÇÔ∏è Mage</button>
        </div>
      </div>
    </div>

    <!-- Talent chooser -->
    <div id="talentOverlay">
      <div id="talentBox">
        <h3 id="talentTitle">Choose W Talent (Lv4)</h3>
        <div class="talentRow">
          <div class="talent">
            <div><b id="talentAName">‚Äî</b></div>
            <small id="talentADesc">‚Äî</small>
            <button class="btn pick" id="pickA">Choose</button>
          </div>
          <div class="talent">
            <div><b id="talentBName">‚Äî</b></div>
            <small id="talentBDesc">‚Äî</small>
            <button class="btn pick" id="pickB">Choose</button>
          </div>
        </div>
        <div class="hint">Tip: you can also open this by clicking the W/E panel after unlocking.</div>
      </div>
    </div>

    <div class="chip" id="fpsChip">FPS: <b id="fps">60</b></div>
  </div>
  <aside id="panel">
    <h2>Info</h2>
    <div>‚Ä¢ Moving cancels your current target; you won‚Äôt fire while moving.</div>
    <div>‚Ä¢ Assist XP: nearby ally kills grant <b>small XP</b> (defaults to 20% of base).</div>
    <div>‚Ä¢ Base XP: <b>Minion 25</b>, <b>Hero 75</b>. (Towers/Core unchanged.)</div>
    <div>‚Ä¢ Red ring = your current attack target (hard target or in-range auto target).</div>
    <div style="margin-top:8px;color:#9fb2c7">‚Ä¢ Talents: At Lv4 choose one of 2 W abilities; at Lv7 choose one of 2 E abilities. AI picks automatically.</div>
  </aside>
</div>

<script>
/* ========================= Helpers & Constants ========================= */
const TWO_PI=Math.PI*2;
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const rand=(a,b)=>a+Math.random()*(b-a);
const randi=(a,b)=>Math.floor(rand(a,b+1));
const dist2=(a,b)=>{const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy;};
const nowMS=()=>performance.now();

const MAP_W=2800, MAP_H=900;
const LANE_Y = MAP_H/2;
const LANE_HALF = 170;
const VIEWPAD_X=100, EDGE_SCROLL_X=750;
const GRID=60;

const PLAYER=1, ENEMY=2;

const COLORS={
  hpGood:"#4de395", hpBad:"#ff6b6b",
  ringSelf:"#58a6ff", ringEnemy:"#38ef7d",
  area:"#8fd9ff66", areaStroke:"#8fd9ff",
  stun:"#ffd166", heal:"#50e3a488",
  target:"#ff4a4a"
};

const ASSIST_RADIUS = 380;
const ASSIST_SHARE  = 0.20; // 20% of base
const AI_LEVEL_INTERVAL_MS = 25000; // <<< enemy & co-ally heroes level up on a timer

const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");
const $=id=>document.getElementById(id);
const fpsEl=$("fps"), stageEl=$("stage"), hLevelEl=$("hLevel"), xpEl=$("xp"), xpNeedEl=$("xpNeed"),
      allyCountEl=$("allyCount"), enemyCountEl=$("enemyCount"), twInfoEl=$("twInfo"),
      myCoreHpEl=$("myCoreHp"), enCoreHpEl=$("enCoreHp"), msgEl=$("msg"), banner=$("banner"),
      xpBar=$("xpBar");
const startEl=$("start");
const abQ=$("abQ"), abW=$("abW"), abE=$("abE"),
      qName=$("qName"), wName=$("wName"), eName=$("eName"),
      qInfo=$("qInfo"), wInfo=$("wInfo"), eInfo=$("eInfo"),
      qProg=$("qProg"), wProg=$("wProg"), eProg=$("eProg");

const talentOverlay=$("talentOverlay"), talentTitle=$("talentTitle"),
      talentAName=$("talentAName"), talentADesc=$("talentADesc"),
      talentBName=$("talentBName"), talentBDesc=$("talentBDesc"),
      pickA=$("pickA"), pickB=$("pickB");

/* ========================= Data ========================= */
const AB_UNLOCKS={ Q:2, W:4, E:7 };

const HERO_BASES={
  healer:{hp:220, speed:200, range:260, dmg:10, emoji:"üßë‚Äç‚öïÔ∏è"},
  tank:{hp:360, speed:185, range:150, dmg:12, emoji:"üõ°Ô∏è"},
  mage:{hp:250, speed:210, range:300, dmg:9,  emoji:"üßô‚Äç‚ôÇÔ∏è"}
};

/* 5 abilities per hero: Q (fixed), W has W1/W2 options, E has E1/E2 options */
const HERO_ABILITIES={
  healer:{
    Q:{name:"Heal Beam", desc:"Heal an ally in range.",
       target:"ally-unit", cd:4000, power:(lv)=>18+6*lv},
    W1:{name:"Sanctuary", desc:"Area HoT field that pulses healing over time.",
        target:"area", cd:12000, power:(lv)=>6+3*lv, dur:3000, radius:100},
    W2:{name:"Cleanse Pulse", desc:"Cleanse CC & grant haste + shields to allies around you.",
        target:"self-aura", cd:14000, radius:120, hasteDur:3000, hasteMul:1.25, shield:(lv)=>10+3*lv},
    E1:{name:"Revitalize", desc:"Big heal + shield to one ally.",
        target:"ally-hero", cd:20000, power:(lv)=>45+10*lv, shield:(lv)=>15+4*lv},
    E2:{name:"Tranquility", desc:"Channel a large HoT around yourself.",
        target:"self-aura-hot", cd:22000, radius:140, dur:4500, tick:700, power:(lv)=>10+3*lv}
  },
  tank:{
    Q:{name:"Shield Bash",desc:"Damage & brief stun to a nearby enemy.",
       target:"enemy-unit", cd:6000, power:(lv)=>10+3*lv, stun:1200},
    W1:{name:"Fortify", desc:"Reduce damage taken for a short time.",
        target:"self", cd:14000, reduce:0.4, dur:5000},
    /* Bulwark is now aimable on a teammate; aura is centered on the selected ally */
    W2:{name:"Bulwark", desc:"Target a teammate; allies near them gain shields & DR.",
        target:"ally-aura", cd:16000, radius:130, dur:3500, shield:(lv)=>12+3*lv, reduce:0.4},
    E1:{name:"Charge", desc:"Dash toward a point, damaging in an area on arrival.",
        target:"point", cd:18000, power:(lv)=>18+7*lv, radius:70},
    E2:{name:"War Shout", desc:"Debuff enemies in an area: slow movement & attacks.",
        target:"debuff-area", cd:17000, radius:140, dur:4500, slowMul:0.7, atkMul:0.7}
  },
  mage:{
    Q:{name:"Firebolt", desc:"Ranged nuke to a target.",
       target:"enemy-unit", cd:3500, power:(lv)=>20+6*lv},
    W1:{name:"Arcane Nova", desc:"Burst AoE damage.",
        target:"area", cd:9000,  power:(lv)=>12+5*lv, radius:90},
    W2:{name:"Time Warp", desc:"Zone that slows and makes foes vulnerable.",
        target:"debuff-area", cd:12000, radius:110, dur:4000, slowMul:0.7, vulnMul:1.2},
    E1:{name:"Meteor", desc:"Large AoE nuke.",
        target:"area", cd:16000, power:(lv)=>24+10*lv, radius:110},
    E2:{name:"Blink + Surge", desc:"Short blink; brief damage surge to attacks & spells.",
        target:"blink", cd:14000, maxStep:280, boostDur:4000, dmgMul:1.3}
  }
};

const MINION_BASE={ hp:65, dmg:6, speed:110, range:18, aggro:260, fireRate:1.4 };
const TOWER_BASE ={ hp:380, dmg:18, range:320, firerate:1.2 };
const CORE_BASE  ={ hp:900 };

const XP_ON_KILL={ MINION:25, HERO:75, TOWER:160, CORE:300 };

/* ========================= State ========================= */
const state={
  stage:1,
  units:[],
  projectiles:[],
  effects:[],
  camera:{x:0,y:0,w:0,h:0},
  mouse:{x:0,y:0,worldX:0,worldY:0,over:false},
  keys:{},
  targeting:null,
  playerId:null,
  minionTimers:{player:0, enemy:0},
  lastMsgUntil:0,
  pendingSlot:null,
  aiLevelTickAt:0
};

function resize(){
  const w = window.innerWidth - parseInt(getComputedStyle(document.documentElement).getPropertyValue("--panel-w"));
  const h = window.innerHeight;
  canvas.width=w; canvas.height=h;
  state.camera.w=w; state.camera.h=h;
}
window.addEventListener("resize", resize);

/* ========================= Units ========================= */
function makeUnit(kind, team, x, y, opts={}){
  const u={
    id:Math.random().toString(36).slice(2),
    kind, team, x,y, vx:0,vy:0, r:12, alive:true,
    range:120, dmg:10, speed:140, fireRate:1.2, cd:0, aggro:320,
    maxHp:120, hp:120, emoji:"‚ùì",
    order:null, target:null, explicitTargetId:null,
    born:nowMS(),
    heroClass:opts.heroClass||null, level:opts.level||1, xp:0,
    respawnAt:0, shield:0, fortifyUntil:0, stunnedUntil:0,
    pickW:null, pickE:null,
    slowUntil:0, hasteUntil:0, atkSlowUntil:0, dmgBoostUntil:0, vulnUntil:0,
    isStructure:false, isCore:false
  };
  if (kind==="hero"){
    const b=HERO_BASES[opts.heroClass]; Object.assign(u,{emoji:b.emoji,maxHp:b.hp,hp:b.hp,range:b.range,dmg:b.dmg,speed:b.speed,r:14});
  } else if (kind==="cohero" || kind==="aihero"){
    const roles=["healer","tank","mage"]; const role=opts.heroClass||roles[randi(0,2)];
    const b=HERO_BASES[role]; u.heroClass=role; Object.assign(u,{emoji:b.emoji,maxHp:b.hp,hp:b.hp,range:b.range,dmg:b.dmg,speed:b.speed,r:14});
  } else if (kind==="minion"){
    Object.assign(u,{emoji:"‚öîÔ∏è",r:10,maxHp:MINION_BASE.hp,hp:MINION_BASE.hp,speed:MINION_BASE.speed,dmg:MINION_BASE.dmg,range:MINION_BASE.range,aggro:MINION_BASE.aggro,fireRate:MINION_BASE.fireRate});
  } else if (kind==="tower"){
    Object.assign(u,{emoji:"üóº",r:16,maxHp:TOWER_BASE.hp,hp:TOWER_BASE.hp,range:TOWER_BASE.range,dmg:TOWER_BASE.dmg,fireRate:TOWER_BASE.firerate,isStructure:true});
  } else if (kind==="core"){
    Object.assign(u,{emoji:"üí†",r:18,maxHp:CORE_BASE.hp,hp:CORE_BASE.hp,isStructure:true,isCore:true});
  }
  if (opts.scale){ u.maxHp=Math.round(u.maxHp*opts.scale); u.hp=u.maxHp; u.dmg=Math.round(u.dmg*opts.scale); }
  return u;
}

/* ========================= World Setup ========================= */
function setupWorld(stage, heroClass){
  state.units.length=0; state.projectiles.length=0; state.effects.length=0;
  state.minionTimers.player = nowMS()+1500;
  state.minionTimers.enemy  = nowMS()+1500;
  state.aiLevelTickAt = nowMS() + AI_LEVEL_INTERVAL_MS;

  const leftX=180, rightX=MAP_W-180;
  const enemyScale = 1 + 0.12*(stage-1);

  const myC = makeUnit("core", PLAYER, leftX, LANE_Y);
  const enC = makeUnit("core", ENEMY,  rightX, LANE_Y, {scale:enemyScale});
  state.units.push(myC,enC);
  state.units.push(makeUnit("tower", PLAYER, 700, LANE_Y));
  state.units.push(makeUnit("tower", PLAYER, 1200, LANE_Y));
  state.units.push(makeUnit("tower", ENEMY,  MAP_W-1200, LANE_Y, {scale:enemyScale}));
  state.units.push(makeUnit("tower", ENEMY,  MAP_W-700,  LANE_Y, {scale:enemyScale}));

  const me=makeUnit("hero", PLAYER, leftX+80, LANE_Y+40, {heroClass});
  state.units.push(me); state.playerId=me.id;

  state.units.push(makeUnit("cohero", PLAYER, leftX+40, LANE_Y-40, {heroClass:"tank"}));
  state.units.push(makeUnit("cohero", PLAYER, leftX+40, LANE_Y+90, {heroClass:"mage"}));

  state.units.push(makeUnit("aihero", ENEMY, rightX-40, LANE_Y-40, {heroClass:"tank", scale:enemyScale}));
  state.units.push(makeUnit("aihero", ENEMY, rightX-40, LANE_Y+90, {heroClass:"mage", scale:enemyScale}));

  state.camera.x = clamp(me.x - 200, 0, MAP_W - canvas.width);
  state.camera.y = 0;

  stageEl.textContent = state.stage;
  flashBanner("STAGE "+state.stage);
  const A=abilitySetFor(me);
  qName.textContent=A.Q.name; setWBar(me); setEBar(me);
  updateAbilityUI(); updateHud();
}

/* ========================= Ability helpers ========================= */
function abilitySetFor(u){
  const H=HERO_ABILITIES[u.heroClass];
  return {
    Q: H.Q,
    W: u.pickW ? H[u.pickW] : null,
    E: u.pickE ? H[u.pickE] : null,
    raw: H
  };
}
function setWBar(me){
  const H=HERO_ABILITIES[me.heroClass];
  if (me.pickW){ wName.textContent=H[me.pickW].name; }
  else { wName.textContent=`Choose: ${H.W1.name} / ${H.W2.name}`; }
}
function setEBar(me){
  const H=HERO_ABILITIES[me.heroClass];
  if (me.pickE){ eName.textContent=H[me.pickE].name; }
  else { eName.textContent=`Choose: ${H.E1.name} / ${H.E2.name}`; }
}

/* ========================= Queries & Goals ========================= */
function getUnit(id){ return state.units.find(u=>u.id===id); }
function playerHero(){ return getUnit(state.playerId); }
function myCore(){ return state.units.find(u=>u.isCore && u.team===PLAYER); }
function enCore(){ return state.units.find(u=>u.isCore && u.team===ENEMY); }

function nearestEnemyTo(u, maxR=Infinity){
  const r2 = maxR===Infinity?Infinity:maxR*maxR;
  let best=null, bestD2=Infinity;
  for (const e of state.units){
    if (!e.alive || e.team===u.team) continue;
    const d2=dist2(u,e); if (d2<bestD2 && d2<=r2){ best=e; bestD2=d2; }
  }
  return best;
}
function nearestAllyToPoint(team, x, y, maxR){
  const r2=maxR*maxR; let best=null, bestD2=Infinity;
  for (const a of state.units){
    if (!a.alive || a.team!==team) continue;
    const d2=(a.x-x)*(a.x-x)+(a.y-y)*(a.y-y);
    if (d2<bestD2 && d2<=r2){ best=a; bestD2=d2; }
  }
  return best;
}
function nextObjective(team){
  const enemyTowers = state.units.filter(u=>u.alive && u.kind==="tower" && u.team!==team);
  if (team===PLAYER){
    const t = enemyTowers.sort((a,b)=>a.x-b.x)[0];
    return t || enCore();
  } else {
    const t = enemyTowers.sort((a,b)=>b.x-a.x)[0];
    return t || myCore();
  }
}

/* ========================= Hit Test ========================= */
function unitAtPoint(wx, wy, teamWanted=null){
  let best=null, bestD2=Infinity;
  for (const u of state.units){
    if (!u.alive) continue;
    if (teamWanted && u.team!==teamWanted) continue;
    const rr = (u.r||12) + 6;
    const d2 = (wx-u.x)*(wx-u.x) + (wy-u.y)*(wy-u.y);
    if (d2 <= rr*rr && d2 < bestD2){ best=u; bestD2=d2; }
  }
  return best;
}

/* ========================= Input & Camera ========================= */
canvas.addEventListener("contextmenu", e=>e.preventDefault());
canvas.addEventListener("mouseenter", ()=>state.mouse.over=true);
canvas.addEventListener("mouseleave", ()=>state.mouse.over=false);
canvas.addEventListener("mousemove",(e)=>{
  const rect=canvas.getBoundingClientRect();
  state.mouse.x=e.clientX-rect.left; state.mouse.y=e.clientY-rect.top;
  state.mouse.worldX = state.mouse.x + state.camera.x;
  state.mouse.worldY = state.mouse.y + state.camera.y;
});
canvas.addEventListener("mousedown",(e)=>{
  const w={x:state.mouse.worldX, y:clamp(state.mouse.worldY, LANE_Y-LANE_HALF, LANE_Y+LANE_HALF)};
  if (e.button===2){
    const me=playerHero(); if (!me || !me.alive) return;
    const enemyHit = unitAtPoint(w.x, w.y, ENEMY);
    if (enemyHit){
      me.explicitTargetId = enemyHit.id;
      me.target = enemyHit;
      me.order = { type:"move", x:enemyHit.x, y:enemyHit.y, chase:true };
      say("Target set.");
    } else {
      me.explicitTargetId = null;
      me.target = null;
      me.order = { type:"move", x:w.x, y:w.y, chase:false };
    }
    cancelTargeting();
  } else if (e.button===0){
    if (state.targeting){ tryCast(state.targeting, w); }
  }
});

window.addEventListener("keydown",(e)=>{
  state.keys[e.code]=true;
  if (e.code==="KeyQ"||e.code==="KeyW"||e.code==="KeyE"){ primeAbility(e.code.slice(3).toUpperCase()); }
  if (e.code==="Escape") cancelTargeting();
});
window.addEventListener("keyup", e=>state.keys[e.code]=false);

abW.addEventListener("click", ()=>{
  const me=playerHero(); if (!me) return;
  if (me.level>=AB_UNLOCKS.W && !me.pickW) openTalentPicker(me, "W");
});
abE.addEventListener("click", ()=>{
  const me=playerHero(); if (!me) return;
  if (me.level>=AB_UNLOCKS.E && !me.pickE) openTalentPicker(me, "E");
});

function primeAbility(key){
  const me=playerHero(); if (!me || !me.alive) return;
  const L=me.level, S=abilitySetFor(me);

  if (key==="W" && L>=AB_UNLOCKS.W && !me.pickW){ openTalentPicker(me, "W"); return; }
  if (key==="E" && L>=AB_UNLOCKS.E && !me.pickE){ openTalentPicker(me, "E"); return; }

  const A=S[key]; if (!A) return;
  if (L<AB_UNLOCKS[key]){ say(`${key} unlocks at Lv${AB_UNLOCKS[key]}`); return; }
  if (me[`cd_${key}`] && nowMS()<me[`cd_${key}`]){ say(`${key} cooling down`); return; }

  // Clear, specific targeting texts
  let targetText=A.target;
  if (A.target==="ally-aura") targetText="ally (center aura)";
  else if (A.target==="self-aura") targetText="self aura";
  else if (A.target==="self-aura-hot") targetText="self HoT aura";
  state.targeting={key, A};
  say(`Target ${targetText} for ${A.name}. Left-click to cast.`);
}
function cancelTargeting(){ state.targeting=null; }

/* ========================= Waves ========================= */
function spawnWave(team){
  const core = team===PLAYER ? myCore() : enCore();
  const n = 5;
  for (let i=0;i<n;i++){
    const m = makeUnit("minion", team, core.x + (team===PLAYER?60:-60), LANE_Y + randi(-20,20), {scale: (team===ENEMY? 1+0.12*(state.stage-1):1)});
    state.units.push(m);
    const obj = nextObjective(team);
    m.order={type:"move", x:obj.x + (team===PLAYER? -80:80), y:LANE_Y + randi(-30,30)};
  }
}

/* ========================= Combat math helpers ========================= */
function rateMul(u){
  const now=nowMS(); let m=1;
  if (now < (u.atkSlowUntil||0)) m *= 0.7;
  if (now < (u.hasteUntil||0))   m *= 1.15;
  return m;
}
function effSpeed(u){
  const now=nowMS(); let s=u.speed;
  if (now < (u.slowUntil||0))  s *= 0.7;
  if (now < (u.hasteUntil||0)) s *= 1.25;
  return s;
}
function dmgOutMul(u){
  return nowMS() < (u.dmgBoostUntil||0) ? 1.3 : 1;
}
function takeVulnMul(u){
  return nowMS() < (u.vulnUntil||0) ? 1.2 : 1;
}

/* ========================= Combat ========================= */
function fireProjectile(from,to,dmg,spd=900,pierce=0){
  const ang=Math.atan2(to.y-from.y, to.x-from.x);
  state.projectiles.push({
    id:Math.random().toString(36).slice(2),
    team:from.team, dealerId: from.id,
    x:from.x, y:from.y,
    vx:Math.cos(ang)*spd, vy:Math.sin(ang)*spd,
    dmg, life:2000, pierce
  });
}
function xpKeyFor(target){
  if (target.kind==="minion") return "MINION";
  if (target.kind==="hero"||target.kind==="aihero"||target.kind==="cohero") return "HERO";
  if (target.isStructure && !target.isCore) return "TOWER";
  if (target.isCore) return "CORE";
  return "MINION";
}
function applyDamage(target, dmg, dealer){
  if (!target.alive) return;
  let left=dmg;
  left *= takeVulnMul(target);
  if (target.shield>0){ const s=Math.min(target.shield,left); target.shield-=s; left-=s; }
  if (left>0){
    if (target.fortifyUntil && nowMS()<target.fortifyUntil) left *= 0.6;
    target.hp -= left;
  }
  if (target.hp<=0){
    target.alive=false;

    // Player XP only (assist logic too)
    const me = playerHero();
    const base = XP_ON_KILL[xpKeyFor(target)] || 0;
    if (dealer && me && dealer.id===me.id){
      gainXP(me, base);
    } else {
      if (me && me.alive && dealer && dealer.team===PLAYER){
        if (dist2(me, target) <= ASSIST_RADIUS*ASSIST_RADIUS){
          const assistXp = Math.max(1, Math.round(base * ASSIST_SHARE));
          gainXP(me, assistXp);
        }
      }
    }

    if (target.isCore){
      if (target.team===ENEMY) winStage(); else loseStage();
    }
    if (target.kind==="hero"||target.kind==="aihero"||target.kind==="cohero"){
      target.respawnAt = nowMS() + 6000;
    }
  }
}

/* ========================= Leveling ========================= */
function gainXP(hero, amount){
  if (!amount) return;
  hero.xp += amount;
  let leveled=false;
  while (hero.xp >= xpNeed(hero.level)){
    hero.xp -= xpNeed(hero.level);
    levelUpOnce(hero);
    leveled=true;
  }
  if (leveled){ setWBar(hero); setEBar(hero); }
  updateAbilityUI(); updateHud();
}
function levelUpOnce(u){
  u.level++;
  u.maxHp = Math.round(u.maxHp*1.05 + 8);
  u.hp    = u.maxHp;
  u.dmg   = Math.round(u.dmg*1.06 + 1);
  say(`Level Up! Lv${u.level}`);
}
function xpNeed(lv){ return 100 + (lv-1)*40; }

/* ========================= AI & Behavior ========================= */
function aiTick(dt){
  const now = nowMS();

  for (const u of state.units){
    if (!u.alive){
      if ((u.kind==="hero"||u.kind==="aihero"||u.kind==="cohero") && u.respawnAt && now>=u.respawnAt){
        const core = u.team===PLAYER ? myCore() : enCore();
        u.x = core.x + (u.team===PLAYER ? 60 : -60);
        u.y = LANE_Y + randi(-40,40);
        u.hp = u.maxHp; u.alive = true; u.respawnAt = 0;
        u.order = null; u.vx = u.vy = 0; u.target = null; u.explicitTargetId = null;
      }
      continue;
    }

    // AI auto-pick talents when reaching thresholds
    if ((u.kind==="aihero"||u.kind==="cohero")){
      if (u.level>=AB_UNLOCKS.W && !u.pickW){ u.pickW = (Math.random()<0.5) ? "W1" : "W2"; }
      if (u.level>=AB_UNLOCKS.E && !u.pickE){ u.pickE = (Math.random()<0.5) ? "E1" : "E2"; }
    }

    // Stun lock
    if (now < (u.stunnedUntil || 0)){ u.vx = 0; u.vy = 0; continue; }

    if (u.kind === "minion"){
      if (!u.target || !u.target.alive || dist2(u,u.target) > (u.aggro*u.aggro)){
        u.target = nearestEnemyTo(u, u.aggro);
      }
      if (u.target){
        const needDist = u.range + (u.target.r||0) + 2;
        const d = Math.hypot(u.target.x - u.x, u.target.y - u.y);
        if (d > needDist){
          u.order = { type:"move", x:u.target.x, y:u.target.y };
        } else {
          u.order = null;
          if (u.cd <= 0){
            fireProjectile(u, u.target, u.dmg * dmgOutMul(u), 900);
            u.cd = 1000 / (u.fireRate * rateMul(u));
          }
        }
      } else if (!u.order){
        const obj = nextObjective(u.team);
        u.order = { type:"move", x: obj.x + (u.team===PLAYER? -60:60), y: LANE_Y + randi(-35,35) };
      }

    } else if (u.kind === "tower"){
      const t = nearestEnemyTo(u, u.range);
      if (t && u.cd <= 0){
        fireProjectile(u, t, u.dmg * dmgOutMul(u), 1000);
        u.cd = 1000 / (u.fireRate * rateMul(u));
      }

    } else if (u.kind === "core"){
      // no action

    } else {
      const isPlayer  = (u.id === state.playerId);
      const hasMove   = !!(u.order && u.order.type === "move");
      const isChasing = hasMove && !!u.order.chase;

      if (!(isPlayer && hasMove && !isChasing)){
        if (isPlayer && u.explicitTargetId){
          const ex = getUnit(u.explicitTargetId);
          if (ex && ex.alive) u.target = ex; else u.explicitTargetId = null;
        }
        if ((!u.target || !u.target.alive) && !(isPlayer && hasMove && !isChasing)){
          u.target = nearestEnemyTo(u, Math.max(u.range + 200, 520));
        }
        if (u.target){
          const needDist = u.range + (u.target.r||0) - 2;
          const d = Math.hypot(u.target.x - u.x, u.target.y - u.y);
          if (d > needDist){
            if (!isPlayer || isChasing || !hasMove){
              u.order = { type:"move", x:u.target.x, y:u.target.y, chase: (isPlayer && !!u.explicitTargetId) };
            }
          } else {
            if (isChasing) u.order = null;
          }
        } else if (!isPlayer){
          const obj = nextObjective(u.team);
          u.order = { type:"move", x: obj.x + (u.team===PLAYER? -120:120), y: LANE_Y };
        }
      }

      // Auto-fire (player won‚Äôt shoot while moving)
      if (u.target && u.cd <= 0){
        const inRange = dist2(u,u.target) <= (u.range + u.r + (u.target.r||0))**2;
        const movingBlock = (isPlayer && hasMove);
        if (inRange && !movingBlock){
          fireProjectile(u, u.target, u.dmg * dmgOutMul(u), 900);
          u.cd = 1000 / (u.fireRate * rateMul(u));
        }
      }

      // AI abilities
      if (!isPlayer) trySmartAbility(u);
    }
  }
}

/* Enemy + co-ally heroes level up on a global timer */
function aiTimedLeveling(tNow){
  if (tNow >= state.aiLevelTickAt){
    for (const u of state.units){
      if ((u.kind==="aihero"||u.kind==="cohero") && u.alive){
        levelUpOnce(u);
      }
    }
    state.aiLevelTickAt = tNow + AI_LEVEL_INTERVAL_MS;
  }
}

function trySmartAbility(u){
  const S=abilitySetFor(u); if (!S) return;
  const lv=u.level, now=nowMS();
  const foes = state.units.filter(e=>e.alive && e.team!==u.team);
  const allies = state.units.filter(a=>a.alive && a.team===u.team);
  const lowAlly = allies.filter(a=>a.hp/a.maxHp < 0.6).sort((a,b)=>a.hp/a.maxHp - b.hp/b.maxHp)[0];

  // Q (fixed)
  if (lv>=AB_UNLOCKS.Q && S.Q && !(u[`cd_Q`] && now<u[`cd_Q`])){
    if (u.heroClass==="healer" && lowAlly && dist2(u,lowAlly) <= (u.range+150)**2){
      lowAlly.hp = clamp(lowAlly.hp + S.Q.power(lv), 0, lowAlly.maxHp);
      state.effects.push({type:"beam", from:u, to:lowAlly, color:COLORS.heal, until:now+250});
      u[`cd_Q`]=now + S.Q.cd;
    }
    else if (u.heroClass==="tank" && u.target && dist2(u,u.target) <= (u.range+80)**2){
      applyDamage(u.target, S.Q.power(lv), u); u.target.stunnedUntil = now + S.Q.stun;
      state.effects.push({type:"beam", from:u, to:u.target, color:COLORS.stun, until:now+200});
      u[`cd_Q`]=now + S.Q.cd;
    }
    else if (u.heroClass==="mage" && u.target && dist2(u,u.target) <= (u.range+120)**2){
      applyDamage(u.target, S.Q.power(lv)*dmgOutMul(u), u);
      state.effects.push({type:"beam", from:u, to:u.target, color:"#faa", until:now+200});
      u[`cd_Q`]=now + S.Q.cd;
    }
  }

  // W (chosen)
  if (lv>=AB_UNLOCKS.W && S.W && !(u[`cd_W`] && now<u[`cd_W`])){
    if (u.heroClass==="healer"){
      if (S.W.target==="area" && lowAlly){
        const r=S.W.radius; const center={x:lowAlly.x,y:lowAlly.y};
        state.effects.push({type:"hot", x:center.x, y:center.y, r, power:S.W.power(lv), tickEvery:500, tickAt:now+500, until:now+S.W.dur, team:u.team});
        u[`cd_W`]=now + S.W.cd;
      } else if (S.W.target==="self-aura"){
        for (const a of allies){
          if (dist2(a,u)<=S.W.radius*S.W.radius){
            a.stunnedUntil = Math.min(a.stunnedUntil||0, now);
            a.slowUntil = Math.min(a.slowUntil||0, now);
            a.hasteUntil = Math.max(a.hasteUntil||0, now + S.W.hasteDur);
            a.shield += S.W.shield(lv);
          }
        }
        state.effects.push({type:"circle", x:u.x, y:u.y, r:S.W.radius, color:COLORS.heal, until:now+400});
        u[`cd_W`]=now + S.W.cd;
      }
    } else if (u.heroClass==="tank"){
      if (S.W.target==="self"){
        u.fortifyUntil = now + S.W.dur; u[`cd_W`]=now + S.W.cd;
      } else if (S.W.target==="ally-aura"){
        // AI centers on lowest ally
        const center = lowAlly || u;
        for (const a of allies){
          if (dist2(a,center)<=S.W.radius*S.W.radius){
            a.shield += S.W.shield(lv);
            a.fortifyUntil = Math.max(a.fortifyUntil||0, now + S.W.dur);
          }
        }
        state.effects.push({type:"circle", x:center.x, y:center.y, r:S.W.radius, color:"#88e0ff55", until:now+400});
        u[`cd_W`]=now + S.W.cd;
      }
    } else if (u.heroClass==="mage"){
      if (S.W.target==="area" && u.target){
        const r=S.W.radius, c={x:u.target.x,y:u.target.y};
        for (const e of foes){ if (dist2(e,c)<=r*r) applyDamage(e, S.W.power(lv)*dmgOutMul(u), u); }
        state.effects.push({type:"circle", x:c.x, y:c.y, r, color:COLORS.area, until:now+300});
        u[`cd_W`]=now + S.W.cd;
      } else if (S.W.target==="debuff-area" && u.target){
        for (const e of foes){
          if (dist2(e,u.target)<=S.W.radius*S.W.radius){
            e.slowUntil = Math.max(e.slowUntil||0, now + S.W.dur);
            e.vulnUntil = Math.max(e.vulnUntil||0, now + S.W.dur);
          }
        }
        state.effects.push({type:"circle", x:u.target.x, y:u.target.y, r:S.W.radius, color:"#ff7e5e55", until:now+400});
        u[`cd_W`]=now + S.W.cd;
      }
    }
  }

  // E (chosen)
  if (lv>=AB_UNLOCKS.E && S.E && !(u[`cd_E`] && now<u[`cd_E`])){
    if (u.heroClass==="healer"){
      if (S.E.target==="ally-hero" && lowAlly && lowAlly.hp/lowAlly.maxHp<0.4){
        lowAlly.hp = clamp(lowAlly.hp + S.E.power(lv), 0, lowAlly.maxHp);
        lowAlly.shield += S.E.shield ? S.E.shield(lv) : 0;
        state.effects.push({type:"beam", from:u, to:lowAlly, color:COLORS.heal, until:now+300});
        u[`cd_E`]=now + S.E.cd;
      } else if (S.E.target==="self-aura-hot"){
        state.effects.push({type:"hot", x:u.x, y:u.y, r:S.E.radius, power:S.E.power(lv), tickEvery:S.E.tick, tickAt:now+S.E.tick, until:now+S.E.dur, team:u.team});
        u[`cd_E`]=now + S.E.cd;
      }
    } else if (u.heroClass==="tank"){
      if (S.E.target==="point" && u.target){
        const dx=u.target.x-u.x, dy=u.target.y-u.y, d=Math.hypot(dx,dy)||1;
        const step=Math.min(260,d); u.x += dx/d*step; u.y += dy/d*step;
        for (const e of foes){ if (dist2(e,u)<=S.E.radius*S.E.radius) applyDamage(e, S.E.power(lv), u); }
        u[`cd_E`]=now + S.E.cd;
      } else if (S.E.target==="debuff-area" && u.target){
        for (const e of foes){
          if (dist2(e,u.target)<=S.E.radius*S.E.radius){
            e.slowUntil = Math.max(e.slowUntil||0, now + S.E.dur);
            e.atkSlowUntil = Math.max(e.atkSlowUntil||0, now + S.E.dur);
          }
        }
        state.effects.push({type:"circle", x:u.target.x, y:u.target.y, r:S.E.radius, color:"#ffd16655", until:now+450});
        u[`cd_E`]=now + S.E.cd;
      }
    } else if (u.heroClass==="mage"){
      if (S.E.target==="area" && u.target){
        const r=S.E.radius, c={x:u.target.x,y:u.target.y};
        const foesHere = state.units.filter(e=>e.alive && e.team!==u.team && dist2(e,c)<=r*r);
        if (foesHere.length>=2){
          for (const e of foesHere){ applyDamage(e, S.E.power(lv)*dmgOutMul(u), u); }
          state.effects.push({type:"circle", x:c.x, y:c.y, r, color:COLORS.area, until:now+450});
          u[`cd_E`]=now + S.E.cd;
        }
      } else if (S.E.target==="blink"){
        const tgt = u.target ? {x:u.target.x, y:u.target.y} : {x:u.x+220*(u.team===PLAYER?1:-1), y:u.y};
        const dx=tgt.x-u.x, dy=tgt.y-u.y, d=Math.hypot(dx,dy)||1;
        const step=Math.min(S.E.maxStep,d); u.x += dx/d*step; u.y += dy/d*step;
        u.dmgBoostUntil = now + S.E.boostDur;
        state.effects.push({type:"circle", x:u.x, y:u.y, r:60, color:"#9b7dff55", until:now+250});
        u[`cd_E`]=now + S.E.cd;
      }
    }
  }
}

/* ========================= Physics & Collision ========================= */
function physics(dt){
  const damp=0.88;

  // Movement integration
  for (const u of state.units){
    if (!u.alive) continue;
    u.cd = Math.max(0, u.cd - dt);

    if (u.order && u.order.type==="move"){
      const tx=u.order.x, ty=clamp(u.order.y, LANE_Y-LANE_HALF, LANE_Y+LANE_HALF);
      const dx=tx - u.x, dy=ty - u.y;
      const d=Math.hypot(dx,dy);
      if (d>4){ const sp=effSpeed(u); u.vx+=(dx/(d||1))*sp - u.vx; u.vy+=(dy/(d||1))*sp - u.vy; }
      else { u.order=null; u.vx*=0.6; u.vy*=0.6; }
    } else { u.vx *= 0.92; u.vy *= 0.92; }

    u.vx *= damp; u.vy *= damp;
    const maxSpd=effSpeed(u)*1.05;
    const s=Math.hypot(u.vx,u.vy);
    if (s>maxSpd){ u.vx=u.vx/s*maxSpd; u.vy=u.vy/s*maxSpd; }
    u.x = clamp(u.x + u.vx*dt/1000, u.r, MAP_W - u.r);
    u.y = clamp(u.y + u.vy*dt/1000, LANE_Y-LANE_HALF + u.r*0.3, LANE_Y+LANE_HALF - u.r*0.3);
  }

  // separation
  for (let i=0;i<state.units.length;i++){
    const a=state.units[i]; if (!a.alive || a.isStructure) continue;
    for (let j=i+1;j<state.units.length;j++){
      const b=state.units[j]; if (!b.alive || b.isStructure) continue;
      const dx=b.x-a.x, dy=b.y-a.y;
      const minDist = a.r + b.r + 2;
      const d2=dx*dx+dy*dy;
      if (d2>0 && d2 < minDist*minDist){
        const d=Math.sqrt(d2);
        const overlap=(minDist - d);
        const ux=dx/(d||1), uy=dy/(d||1);
        a.x -= ux * overlap*0.5; a.y -= uy * overlap*0.5;
        b.x += ux * overlap*0.5; b.y += uy * overlap*0.5;
        a.y = clamp(a.y, LANE_Y-LANE_HALF + a.r*0.3, LANE_Y+LANE_HALF - a.r*0.3);
        b.y = clamp(b.y, LANE_Y-LANE_HALF + b.r*0.3, LANE_Y+LANE_HALF - b.r*0.3);
      }
    }
  }

  // Projectiles
  for (let i=state.projectiles.length-1;i>=0;i--){
    const p=state.projectiles[i];
    p.life-=dt; if (p.life<=0){ state.projectiles.splice(i,1); continue; }
    p.x += p.vx*dt/1000; p.y += p.vy*dt/1000;
    for (const u of state.units){
      if (!u.alive || u.team===p.team) continue;
      const rr=u.r+3;
      if (dist2(p,u) <= rr*rr){
        const dealer = getUnit(p.dealerId);
        applyDamage(u, p.dmg, dealer);
        state.projectiles.splice(i,1);
        break;
      }
    }
  }
}

function updateCamera(dt){
  if (!state.mouse.over) return;
  const mx=state.mouse.x;
  let vx=0;
  if (mx < VIEWPAD_X) vx = -EDGE_SCROLL_X;
  else if (mx > canvas.width - VIEWPAD_X) vx = EDGE_SCROLL_X;
  const fx = mx < VIEWPAD_X ? (1 - mx/VIEWPAD_X)
           : (mx > canvas.width - VIEWPAD_X ? (mx - (canvas.width - VIEWPAD_X))/VIEWPAD_X : 0);
  state.camera.x = clamp(state.camera.x + vx*fx*dt/1000, 0, MAP_W - canvas.width);
}

/* ========================= Abilities (Player Cast) ========================= */
function tryCast(tgt, w){
  const me = playerHero(); if (!me || !me.alive) return;
  const key = tgt.key;
  const S   = abilitySetFor(me);
  const A   = S[key];
  const now = nowMS();
  if (!A){ say(`Pick your ${key} talent first.`); return; }

  if (me[`cd_${key}`] && now < me[`cd_${key}`]) { say(`${key} cooling down`); return; }
  const need = AB_UNLOCKS[key];
  if (me.level < need) { say(`${key} unlocks at Lv${need}`); return; }

  const inRangeUnit = (u) => dist2(u, me) <= (me.range + 160) * (me.range + 160);
  let casted = false;

  if (A.target === "self"){
    me.fortifyUntil = now + A.dur;
    me[`cd_${key}`] = now + A.cd; casted = true; say("Fortify on!");
  }
  else if (A.target === "self-aura"){
    const allies = state.units.filter(a=>a.alive && a.team===me.team);
    for (const a of allies){
      if (dist2(a,me)<=A.radius*A.radius){
        a.stunnedUntil = Math.min(a.stunnedUntil||0, now);
        a.slowUntil = Math.min(a.slowUntil||0, now);
        a.hasteUntil = Math.max(a.hasteUntil||0, now + A.hasteDur);
        a.shield += A.shield(me.level);
      }
    }
    state.effects.push({type:"circle", x:me.x, y:me.y, r:A.radius, color:COLORS.heal, until:now+450});
    me[`cd_${key}`] = now + A.cd; casted = true;
  }
  else if (A.target === "self-aura-hot"){
    state.effects.push({type:"hot", x:me.x, y:me.y, r:A.radius, power:A.power(me.level), tickEvery:A.tick, tickAt:now+A.tick, until:now+A.dur, team:me.team});
    me[`cd_${key}`] = now + A.cd; casted = true;
  }
  else if (A.target === "ally-aura"){
    // NEW: Bulwark targeting ‚Äî click a teammate to center the aura there
    const ally = nearestAllyToPoint(me.team, w.x, w.y, me.range + 160);
    if (ally){
      for (const a of state.units){
        if (a.alive && a.team===me.team && dist2(a,ally)<=A.radius*A.radius){
          a.shield += A.shield(me.level);
          a.fortifyUntil = Math.max(a.fortifyUntil||0, now + A.dur);
        }
      }
      state.effects.push({type:"circle", x:ally.x, y:ally.y, r:A.radius, color:"#88e0ff55", until:now+450});
      me[`cd_${key}`] = now + A.cd; casted = true;
    } else {
      say("No teammate in range to center Bulwark on.");
    }
  }
  else if (A.target === "point"){
    const dx = w.x - me.x, dy = w.y - me.y, d = Math.hypot(dx,dy) || 1;
    const step = Math.min(260, d);
    me.x += (dx/d) * step; me.y += (dy/d) * step;
    for (const e of state.units){
      if (!e.alive || e.team === me.team) continue;
      if (dist2(e, me) <= (A.radius * A.radius)) applyDamage(e, A.power(me.level), me);
    }
    me[`cd_${key}`] = now + A.cd; casted = true;
  }
  else if (A.target === "area"){
    const radius = A.radius;
    if (me.heroClass === "mage"){
      const dmg = A.power(me.level) * dmgOutMul(me);
      for (const e of state.units){
        if (!e.alive || e.team === me.team) continue;
        if (dist2(e, w) <= radius*radius) applyDamage(e, dmg, me);
      }
      state.effects.push({ type:"circle", x:w.x, y:w.y, r:radius, color:COLORS.area, until: now + 300 });
      me[`cd_${key}`] = now + A.cd; casted = true;
    } else if (me.heroClass === "healer"){
      const power = A.power(me.level);
      state.effects.push({type:"hot", x:w.x, y:w.y, r:radius, power, tickEvery:500, tickAt: now + 500, until: now + A.dur, team: me.team});
      me[`cd_${key}`] = now + A.cd; casted = true;
    }
  }
  else if (A.target === "debuff-area"){
    const r=A.radius, c={x:w.x,y:w.y};
    for (const e of state.units){
      if (!e.alive || e.team===me.team) continue;
      if (dist2(e,c)<=r*r){
        if (me.heroClass==="tank"){
          e.slowUntil    = Math.max(e.slowUntil||0, now + A.dur);
          e.atkSlowUntil = Math.max(e.atkSlowUntil||0, now + A.dur);
        } else if (me.heroClass==="mage"){
          e.slowUntil = Math.max(e.slowUntil||0, now + A.dur);
          e.vulnUntil = Math.max(e.vulnUntil||0, now + A.dur);
        }
      }
    }
    state.effects.push({type:"circle", x:c.x, y:c.y, r:r, color: me.heroClass==="tank" ? "#ffd16655" : "#ff7e5e55", until: now+450});
    me[`cd_${key}`] = now + A.cd; casted = true;
  }
  else if (A.target === "blink"){
    const dx = w.x - me.x, dy = w.y - me.y, d = Math.hypot(dx,dy)||1;
    const step = Math.min(A.maxStep,d);
    me.x += dx/d*step; me.y += dy/d*step;
    me.dmgBoostUntil = now + A.boostDur;
    state.effects.push({type:"circle", x:me.x, y:me.y, r:60, color:"#9b7dff55", until:now+250});
    me[`cd_${key}`] = now + A.cd; casted = true;
  }
  else if (A.target === "enemy-unit"){
    let best = null, bestD2 = 1e12;
    for (const e of state.units){
      if (!e.alive || e.team === me.team) continue;
      const d2 = dist2(e, w); if (d2 < bestD2){ best = e; bestD2 = d2; }
    }
    if (best && inRangeUnit(best)){
      const base = A.power ? A.power(me.level) : me.dmg;
      applyDamage(best, base*dmgOutMul(me), me);
      if (me.heroClass === "tank" && key === "Q" && A.stun){
        best.stunnedUntil = now + A.stun;
        state.effects.push({ type:"beam", from:me, to:best, color:COLORS.stun, until: now + 200 });
      } else if (me.heroClass === "mage" && key === "Q"){
        state.effects.push({ type:"beam", from:me, to:best, color:"#faa", until: now + 200 });
      }
      me[`cd_${key}`] = now + A.cd; casted = true;
    } else {
      say("Out of range or no target.");
    }
  }
  else if (A.target === "ally-unit" || A.target === "ally-hero"){
    let best = null, bestD2 = 1e12;
    for (const a of state.units){
      if (!a.alive || a.team !== me.team) continue;
      const d2 = dist2(a, w); if (d2 < bestD2){ best = a; bestD2 = d2; }
    }
    if (best && inRangeUnit(best) && me.heroClass === "healer"){
      const healAmt = A.power ? A.power(me.level) : 0;
      best.hp = clamp(best.hp + healAmt, 0, best.maxHp);
      if (A.shield) best.shield += A.shield(me.level);
      state.effects.push({ type:"beam", from:me, to:best, color:COLORS.heal, until: now + 250 });
      me[`cd_${key}`] = now + A.cd; casted = true;
    } else {
      say("No ally in range.");
    }
  }

  if (casted){ cancelTargeting(); updateAbilityUI(); }
}

/* ========================= Rendering ========================= */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  ctx.save(); ctx.translate(-state.camera.x, -state.camera.y);
  ctx.fillStyle="#0e1320";
  ctx.fillRect(0, LANE_Y-LANE_HALF, MAP_W, LANE_HALF*2);
  ctx.strokeStyle="#151a22"; ctx.lineWidth=1;
  for (let x=0;x<=MAP_W;x+=GRID){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,MAP_H); ctx.stroke(); }
  for (let y=0;y<=MAP_H;y+=GRID){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(MAP_W,y); ctx.stroke(); }
  ctx.restore();

  const now=nowMS();
  for (let i=state.effects.length-1;i>=0;i--){
    const ef=state.effects[i];
    if (ef.type==="circle"){
      if (now>ef.until){ state.effects.splice(i,1); continue; }
      const sc=screen(ef.x, ef.y);
      ctx.beginPath(); ctx.arc(sc.x, sc.y, ef.r, 0, TWO_PI);
      ctx.fillStyle=ef.color; ctx.fill();
    } else if (ef.type==="beam"){
      if (now>ef.until || !ef.from.alive || !ef.to.alive){ state.effects.splice(i,1); continue; }
      const a=screen(ef.from.x,ef.from.y), b=screen(ef.to.x,ef.to.y);
      ctx.lineWidth=3; ctx.strokeStyle=ef.color; ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    } else if (ef.type==="hot"){
      if (now>ef.until){ state.effects.splice(i,1); continue; }
      if (now>=ef.tickAt){
        for (const u of state.units){
          if (u.alive && u.team===ef.team && dist2(u,ef)<=ef.r*ef.r){
            u.hp = clamp(u.hp + ef.power, 0, u.maxHp);
          }
        }
        ef.tickAt+=ef.tickEvery;
      }
      const sc=screen(ef.x, ef.y);
      ctx.beginPath(); ctx.arc(sc.x, sc.y, ef.r, 0, TWO_PI);
      ctx.fillStyle=COLORS.heal; ctx.fill();
    }
  }

  let highlightId=null;
  const me=playerHero();
  if (me && me.alive){
    let t=null;
    if (me.explicitTargetId){
      const ex=getUnit(me.explicitTargetId);
      if (ex && ex.alive) t=ex;
    }
    if (!t && me.target){
      const inRange = dist2(me,me.target) <= (me.range + me.r + (me.target.r||0))**2;
      if (inRange) t=me.target;
    }
    highlightId = t ? t.id : null;
  }

  for (const p of state.projectiles){
    const sc=screen(p.x,p.y);
    ctx.fillStyle="#e7edf7"; ctx.beginPath(); ctx.arc(sc.x, sc.y, 3, 0, TWO_PI); ctx.fill();
  }

  for (const u of state.units){
    const sc=screen(u.x,u.y);

    if (!u.alive){
      if (u.respawnAt){
        const sec=Math.ceil((u.respawnAt-now)/1000);
        ctx.fillStyle="#8896a8"; ctx.font="12px ui-monospace, monospace"; ctx.textAlign="center"; ctx.fillText(`‚è≥${sec}`, sc.x, sc.y-22);
      }
      continue;
    }

    ctx.beginPath(); ctx.arc(sc.x, sc.y, u.r+2, 0, TWO_PI);
    ctx.strokeStyle = u.team===PLAYER? COLORS.ringSelf : COLORS.ringEnemy;
    ctx.lineWidth=4; ctx.stroke();

    if (highlightId && u.id===highlightId){
      ctx.beginPath(); ctx.arc(sc.x, sc.y, u.r+6, 0, TWO_PI);
      ctx.lineWidth=3; ctx.strokeStyle=COLORS.target; ctx.stroke();
    }

    ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.font="22px system-ui, emoji";
    ctx.fillText(u.emoji, sc.x, sc.y+1);

    if (u.kind==="hero"||u.kind==="aihero"||u.kind==="cohero"){
      ctx.fillStyle="#a9b6c6"; ctx.font="12px ui-monospace, monospace";
      ctx.fillText(`Lv${u.level}`, sc.x, sc.y - u.r - 28);
    }

    const w=Math.max(32, u.r*3), h=5, pct=clamp(u.hp/u.maxHp,0,1);
    ctx.fillStyle="#000000aa"; ctx.fillRect(sc.x - w/2, sc.y - u.r - 18, w, h);
    ctx.fillStyle = pct>0.5? COLORS.hpGood : COLORS.hpBad;
    ctx.fillRect(sc.x - w/2, sc.y - u.r - 18, w*pct, h);
    ctx.strokeStyle="#00000055"; ctx.lineWidth=1; ctx.strokeRect(sc.x - w/2, sc.y - u.r - 18, w, h);

    if (u.id===state.playerId){
      let dx = sc.x + 34, dy = sc.y - u.r - 16; const nowT=now;
      for (const K of ["Q","W","E"]){
        const cd = u[`cd_${K}`] ? Math.max(0, Math.ceil((u[`cd_${K}`]-nowT)/1000)) : 0;
        if (cd>0){ drawCooldownDot(dx, dy, cd, "#ffd166"); dx += 14; }
      }
    }
  }

  // Targeting preview for area/debuff-area/ally-aura
  if (state.targeting){
    const A=state.targeting.A;
    const mouseY = clamp(state.mouse.worldY, LANE_Y-LANE_HALF, LANE_Y+LANE_HALF);
    if (A.target==="area"||A.target==="debuff-area"){
      const sc=screen(state.mouse.worldX, mouseY);
      ctx.beginPath(); ctx.arc(sc.x, sc.y, A.radius, 0, TWO_PI);
      ctx.fillStyle=(A.target==="debuff-area"?"#ff8c6e55":COLORS.area); ctx.fill();
      ctx.strokeStyle=COLORS.areaStroke; ctx.lineWidth=2; ctx.stroke();
    } else if (A.target==="ally-aura"){
      const me=playerHero();
      const ally = nearestAllyToPoint(me.team, state.mouse.worldX, mouseY, me.range + 160) || me;
      const sc=screen(ally.x, ally.y);
      ctx.beginPath(); ctx.arc(sc.x, sc.y, A.radius, 0, TWO_PI);
      ctx.fillStyle="#88e0ff33"; ctx.fill();
      ctx.strokeStyle="#88e0ffbb"; ctx.lineWidth=2; ctx.stroke();
    }
  }
}

function drawCooldownDot(x,y,secs,color="#a3b1c3"){
  ctx.beginPath(); ctx.arc(x,y,6,0,TWO_PI); ctx.fillStyle="#000a"; ctx.fill();
  ctx.beginPath(); ctx.arc(x,y,5,0,TWO_PI); ctx.fillStyle=color; ctx.fill();
  ctx.fillStyle="#000"; ctx.font="10px ui-monospace, monospace"; ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.fillText(secs, x, y);
}
function screen(x,y){ return {x:x - state.camera.x, y:y - state.camera.y}; }

/* ========================= HUD/Msgs ========================= */
function updateHud(){
  const allies=state.units.filter(u=>u.alive && u.team===PLAYER && !u.isStructure);
  const enemies=state.units.filter(u=>u.alive && u.team===ENEMY && !u.isStructure);
  allyCountEl.textContent=allies.length; enemyCountEl.textContent=enemies.length;
  const myT = state.units.filter(u=>u.alive && u.team===PLAYER && u.kind==="tower").length;
  const enT = state.units.filter(u=>u.alive && u.team===ENEMY  && u.kind==="tower").length;
  twInfoEl.textContent=`${myT} vs ${enT}`;
  const mc=myCore(), ec=enCore();
  myCoreHpEl.textContent=mc?mc.hp:0; enCoreHpEl.textContent=ec?ec.hp:0;
  const me=playerHero(); if (me){
    hLevelEl.textContent=me.level; xpEl.textContent=me.xp; xpNeedEl.textContent=xpNeed(me.level);
    const pct = clamp(me.xp / xpNeed(me.level), 0, 1);
    xpBar.style.width = (pct*100).toFixed(1) + "%";
  }
}
function say(text, dur=1400){ msgEl.textContent=text; state.lastMsgUntil = nowMS()+dur; }
function flashBanner(text){ banner.textContent=text; banner.style.opacity=1; setTimeout(()=> banner.style.opacity=0, 900); }

/* ========================= Stage Win/Loss ========================= */
function winStage(){
  say("Core destroyed! Advancing Stage...", 1800);
  state.stage++;
  setTimeout(()=>{
    const heroClass = playerHero().heroClass;
    setupWorld(state.stage, heroClass);
    const me=playerHero(); me.level=1; me.xp=0; me.pickW=null; me.pickE=null;
    const b=HERO_BASES[heroClass]; me.maxHp=b.hp; me.hp=b.hp; me.dmg=b.dmg;
    updateAbilityUI(); updateHud();
  }, 1200);
}
function loseStage(){
  say("Your core fell. Resetting to Stage 1...", 1800);
  state.stage=1;
  setTimeout(()=>{
    const heroClass = playerHero().heroClass;
    setupWorld(1, heroClass);
    const me=playerHero(); me.level=1; me.xp=0; me.pickW=null; me.pickE=null;
    const b=HERO_BASES[heroClass]; me.maxHp=b.hp; me.hp=b.hp; me.dmg=b.dmg;
    updateAbilityUI(); updateHud();
  }, 1200);
}

/* ========================= Ability UI & Cooldown Bars ========================= */
function updateAbilityUI(){
  const me=playerHero(); if (!me) return;
  const S=abilitySetFor(me), now=nowMS();

  function setBlock(block, nameEl, infoEl, progEl, key){
    const need=AB_UNLOCKS[key];
    let data = (key==="Q") ? S.Q : S[key]; // chosen ability for W/E (or null)
    if (key==="W" && !me.pickW){
      const H=S.raw; nameEl.textContent=`Choose: ${H.W1.name} / ${H.W2.name}`;
      infoEl.textContent = me.level < need ? `Unlock at Lv${need}` : "Pick one (click or press W)";
      progEl.style.width="0%";
      block.classList.toggle("locked", me.level < need);
      return;
    }
    if (key==="E" && !me.pickE){
      const H=S.raw; nameEl.textContent=`Choose: ${H.E1.name} / ${H.E2.name}`;
      infoEl.textContent = me.level < need ? `Unlock at Lv${need}` : "Pick one (click or press E)";
      progEl.style.width="0%";
      block.classList.toggle("locked", me.level < need);
      return;
    }

    nameEl.textContent = data.name;
    const total = data.cd;
    const remMs = me[`cd_${key}`] ? Math.max(0, me[`cd_${key}`]-now) : 0;
    const remS  = Math.ceil(remMs/1000);
    const pct = total ? (remMs/total) : 0;
    block.classList.toggle("locked", me.level < need);
    infoEl.textContent = me.level < need ? `Unlock at Lv${need}` : (remS>0 ? `CD: ${remS}s` : "Ready");
    progEl.style.width = (remS>0 ? (pct*100) : 0).toFixed(1) + "%";
  }
  setBlock(abQ, qName, qInfo, qProg, "Q");
  setBlock(abW, wName, wInfo, wProg, "W");
  setBlock(abE, eName, eInfo, eProg, "E");
}

/* ========================= Talent Picker ========================= */
function openTalentPicker(me, slot){
  const H=HERO_ABILITIES[me.heroClass];
  state.pendingSlot=slot;
  if (slot==="W"){
    talentTitle.textContent="Choose W Talent (Lv4)";
    talentAName.textContent=H.W1.name; talentADesc.textContent=H.W1.desc;
    talentBName.textContent=H.W2.name; talentBDesc.textContent=H.W2.desc;
  } else {
    talentTitle.textContent="Choose E Talent (Lv7)";
    talentAName.textContent=H.E1.name; talentADesc.textContent=H.E1.desc;
    talentBName.textContent=H.E2.name; talentBDesc.textContent=H.E2.desc;
  }
  talentOverlay.style.display="flex";

  const onPickA=()=>{ chooseTalent(me, slot, slot+"1"); cleanup(); };
  const onPickB=()=>{ chooseTalent(me, slot, slot+"2"); cleanup(); };
  pickA.onclick=onPickA; pickB.onclick=onPickB;

  function cleanup(){
    pickA.onclick=null; pickB.onclick=null;
    talentOverlay.style.display="none";
    setWBar(me); setEBar(me);
    updateAbilityUI();
  }
}
function chooseTalent(me, slot, key){
  if (slot==="W") me.pickW = key;
  else me.pickE = key;
  say(`${slot} talent: ${HERO_ABILITIES[me.heroClass][key].name}`);
}

/* ========================= Main Loop ========================= */
let last=nowMS(), fpsS=nowMS(), frames=0;
function tick(){
  const t=nowMS(); let dt=t-last; if (dt>60) dt=60; last=t;

  if (t >= state.minionTimers.player){ spawnWave(PLAYER); state.minionTimers.player = t + 6500; }
  if (t >= state.minionTimers.enemy ){ spawnWave(ENEMY);  state.minionTimers.enemy  = t + 6500; }

  aiTick(dt);
  physics(dt);
  updateCamera(dt);

  // NEW: timed AI leveling (enemies and allied co-heroes)
  aiTimedLeveling(t);

  updateAbilityUI();
  updateHud();

  if (t > state.lastMsgUntil) msgEl.textContent="";

  draw();

  frames++; if (t - fpsS >= 500){ fpsEl.textContent=Math.round(frames * 1000/(t - fpsS)); fpsS=t; frames=0; }
  requestAnimationFrame(tick);
}

/* ========================= Start ========================= */
function init(){
  resize();
  document.getElementById("pickHealer").onclick=()=>{ startEl.style.display="none"; state.stage=1; setupWorld(1,"healer"); requestAnimationFrame(tick); };
  document.getElementById("pickTank").onclick  =()=>{ startEl.style.display="none"; state.stage=1; setupWorld(1,"tank");   requestAnimationFrame(tick); };
  document.getElementById("pickMage").onclick  =()=>{ startEl.style.display="none"; state.stage=1; setupWorld(1,"mage");   requestAnimationFrame(tick); };

  talentOverlay.addEventListener("click", (e)=>{ if (e.target===talentOverlay) talentOverlay.style.display="none"; });
}
init();
</script>
</body>
</html>



